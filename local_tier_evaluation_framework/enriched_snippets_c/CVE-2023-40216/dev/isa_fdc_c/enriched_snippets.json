[
  {
    "function_name": "fdcintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
    "lines": "334-348",
    "snippet": "int\nfdcintr(arg)\n\tvoid *arg;\n{\n#if NFD > 0\n\tstruct fdc_softc *fdc = arg;\n\textern int fdintr __P((struct fdc_softc *));\n\n\t/* Will switch on device type, shortly. */\n\treturn (fdintr(fdc));\n#else\n\tprintf(\"fdcintr: got interrupt, but no devices!\\n\");\n\treturn (1);\n#endif\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int fdcintr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"fdcintr: got interrupt, but no devices!\\n\""
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdintr",
          "args": [
            "fdc"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "fdintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
          "lines": "587-866",
          "snippet": "int\nfdintr(fdc)\n\tstruct fdc_softc *fdc;\n{\n#define\tst0\tfdc->sc_status[0]\n#define\tcyl\tfdc->sc_status[1]\n\tstruct fd_softc *fd;\n\tstruct buf *bp;\n\tbus_space_tag_t iot = fdc->sc_iot;\n\tbus_space_handle_t ioh = fdc->sc_ioh;\n\tbus_space_handle_t ioh_ctl = fdc->sc_ioh_ctl;\n\tint read, head, sec, i, nblks;\n\tstruct fd_type *type;\n\tstruct fd_formb *finfo = NULL;\n\tint fd_bsize, bf;\n\nloop:\n\t/* Is there a transfer to this drive?  If not, deactivate drive. */\n\tfd = fdc->sc_link.fdlink.sc_drives.tqh_first;\n\tif (fd == NULL) {\n\t\tfdc->sc_state = DEVIDLE;\n\t\treturn 1;\n\t}\n\tfd_bsize = 128 << fd->sc_type->secsize;\n\tbf = fd_bsize / FDC_BSIZE;\n\n\tbp = fd->sc_q.b_actf;\n\tif (bp == NULL) {\n\t\tfd->sc_ops = 0;\n\t\tTAILQ_REMOVE(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);\n\t\tfd->sc_q.b_active = 0;\n\t\tgoto loop;\n\t}\n\n\tif (bp->b_flags & B_FORMAT)\n\t    finfo = (struct fd_formb *)bp->b_data;\n\n\tswitch (fdc->sc_state) {\n\tcase DEVIDLE:\n\t\tfdc->sc_errors = 0;\n\t\tfd->sc_skip = 0;\n\t\tfd->sc_bcount = bp->b_bcount;\n\t\tfd->sc_blkno = bp->b_blkno / (fd_bsize / DEV_BSIZE);\n\t\tuntimeout(fd_motor_off, fd);\n\t\tif ((fd->sc_flags & FD_MOTOR_WAIT) != 0) {\n\t\t\tfdc->sc_state = MOTORWAIT;\n\t\t\treturn 1;\n\t\t}\n\t\tif ((fd->sc_flags & FD_MOTOR) == 0) {\n\t\t\t/* Turn on the motor, being careful about pairing. */\n\t\t\tstruct fd_softc *ofd =\n\t\t\t\tfdc->sc_link.fdlink.sc_fd[fd->sc_drive ^ 1];\n\t\t\tif (ofd && ofd->sc_flags & FD_MOTOR) {\n\t\t\t\tuntimeout(fd_motor_off, ofd);\n\t\t\t\tofd->sc_flags &= ~(FD_MOTOR | FD_MOTOR_WAIT);\n\t\t\t}\n\t\t\tfd->sc_flags |= FD_MOTOR | FD_MOTOR_WAIT;\n\t\t\tfd_set_motor(fdc, 0);\n\t\t\tfdc->sc_state = MOTORWAIT;\n\t\t\t/* Allow .25s for motor to stabilize. */\n\t\t\ttimeout(fd_motor_on, fd, hz / 4);\n\t\t\treturn 1;\n\t\t}\n\t\t/* Make sure the right drive is selected. */\n\t\tfd_set_motor(fdc, 0);\n\n\t\t/* fall through */\n\tcase DOSEEK:\n\tdoseek:\n\t\tif (fd->sc_cylin == bp->b_cylin)\n\t\t\tgoto doio;\n\n\t\tout_fdc(iot, ioh, NE7CMD_SPECIFY);/* specify command */\n\t\tout_fdc(iot, ioh, fd->sc_type->steprate);\n\t\tout_fdc(iot, ioh, 6);\t\t/* XXX head load time == 6ms */\n\n\t\tout_fdc(iot, ioh, NE7CMD_SEEK);\t/* seek function */\n\t\tout_fdc(iot, ioh, fd->sc_drive);\t/* drive number */\n\t\tout_fdc(iot, ioh, bp->b_cylin * fd->sc_type->step);\n\n\t\tfd->sc_cylin = -1;\n\t\tfdc->sc_state = SEEKWAIT;\n\n\t\tfd->sc_dk.dk_seek++;\n\t\tdisk_busy(&fd->sc_dk);\n\n\t\ttimeout(fdtimeout, fd, 4 * hz);\n\t\treturn 1;\n\n\tcase DOIO:\n\tdoio:\n\t\ttype = fd->sc_type;\n\t\tif (finfo)\n\t\t    fd->sc_skip = (char *)&(finfo->fd_formb_cylno(0)) -\n\t\t\t(char *)finfo;\n\t\tsec = fd->sc_blkno % type->seccyl;\n\t\tnblks = type->seccyl - sec;\n\t\tnblks = min(nblks, fd->sc_bcount / fd_bsize);\n\t\tnblks = min(nblks, FDC_MAXIOSIZE / fd_bsize);\n\t\tfd->sc_nblks = nblks;\n\t\tfd->sc_nbytes = finfo ? bp->b_bcount : nblks * fd_bsize;\n\t\thead = sec / type->sectrac;\n\t\tsec -= head * type->sectrac;\n#ifdef DIAGNOSTIC\n\t\t{int block;\n\t\t block = (fd->sc_cylin * type->heads + head) * type->sectrac + sec;\n\t\t if (block != fd->sc_blkno) {\n\t\t\t printf(\"fdintr: block %d != blkno %d\\n\", block, fd->sc_blkno);\n#ifdef DDB\n\t\t\t Debugger();\n#endif\n\t\t }}\n#endif\n\t\tread = bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE;\n\t\tisadma_start(bp->b_data + fd->sc_skip, fd->sc_nbytes,\n\t\t    fdc->sc_drq, read);\n\t\tbus_space_write_1(iot, ioh_ctl, fdctl, type->rate);\n#ifdef FD_DEBUG\n\t\tprintf(\"fdintr: %s drive %d track %d head %d sec %d nblks %d\\n\",\n\t\t    read ? \"read\" : \"write\", fd->sc_drive, fd->sc_cylin, head,\n\t\t    sec, nblks);\n#endif\n\t\tif (finfo) {\n                        /* formatting */\n\t\t\tif (out_fdc(iot, ioh, NE7CMD_FORMAT) < 0) {\n\t\t\t    fdc->sc_errors = 4;\n\t\t\t    fdretry(fd);\n\t\t\t    goto loop;\n\t\t\t}\n                        out_fdc(iot, ioh, (head << 2) | fd->sc_drive);\n                        out_fdc(iot, ioh, finfo->fd_formb_secshift);\n                        out_fdc(iot, ioh, finfo->fd_formb_nsecs);\n                        out_fdc(iot, ioh, finfo->fd_formb_gaplen);\n                        out_fdc(iot, ioh, finfo->fd_formb_fillbyte);\n\t\t} else {\n\t\t\tif (read)\n\t\t\t\tout_fdc(iot, ioh, NE7CMD_READ);\t/* READ */\n\t\t\telse\n\t\t\t\tout_fdc(iot, ioh, NE7CMD_WRITE);/* WRITE */\n\t\t\tout_fdc(iot, ioh, (head << 2) | fd->sc_drive);\n\t\t\tout_fdc(iot, ioh, fd->sc_cylin);\t/* track */\n\t\t\tout_fdc(iot, ioh, head);\n\t\t\tout_fdc(iot, ioh, sec + 1);\t\t/* sec +1 */\n\t\t\tout_fdc(iot, ioh, type->secsize);\t/* sec size */\n\t\t\tout_fdc(iot, ioh, type->sectrac);\t/* secs/track */\n\t\t\tout_fdc(iot, ioh, type->gap1);\t\t/* gap1 size */\n\t\t\tout_fdc(iot, ioh, type->datalen);\t/* data len */\n\t\t}\n\t\tfdc->sc_state = IOCOMPLETE;\n\n\t\tdisk_busy(&fd->sc_dk);\n\n\t\t/* allow 2 seconds for operation */\n\t\ttimeout(fdtimeout, fd, 2 * hz);\n\t\treturn 1;\t\t\t\t/* will return later */\n\n\tcase SEEKWAIT:\n\t\tuntimeout(fdtimeout, fd);\n\t\tfdc->sc_state = SEEKCOMPLETE;\n\t\t/* allow 1/50 second for heads to settle */\n\t\ttimeout(fdcpseudointr, fdc, hz / 50);\n\t\treturn 1;\n\n\tcase SEEKCOMPLETE:\n\t\tdisk_unbusy(&fd->sc_dk, 0);\t/* no data on seek */\n\n\t\t/* Make sure seek really happened. */\n\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\tif (fdcresult(fdc) != 2 || (st0 & 0xf8) != 0x20 ||\n\t\t    cyl != bp->b_cylin * fd->sc_type->step) {\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 2, \"seek failed\");\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tfd->sc_cylin = bp->b_cylin;\n\t\tgoto doio;\n\n\tcase IOTIMEDOUT:\n\t\tisadma_abort(fdc->sc_drq);\n\tcase SEEKTIMEDOUT:\n\tcase RECALTIMEDOUT:\n\tcase RESETTIMEDOUT:\n\t\tfdretry(fd);\n\t\tgoto loop;\n\n\tcase IOCOMPLETE: /* IO DONE, post-analyze */\n\t\tuntimeout(fdtimeout, fd);\n\n\t\tdisk_unbusy(&fd->sc_dk, (bp->b_bcount - bp->b_resid));\n\n\t\tif (fdcresult(fdc) != 7 || (st0 & 0xf8) != 0) {\n\t\t\tisadma_abort(fdc->sc_drq);\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 7, bp->b_flags & B_READ ?\n\t\t\t    \"read failed\" : \"write failed\");\n\t\t\tprintf(\"blkno %d nblks %d\\n\",\n\t\t\t    fd->sc_blkno, fd->sc_nblks);\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tread = bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE;\n\t\tisadma_done(fdc->sc_drq);\n\t\tif (fdc->sc_errors) {\n\t\t\tdiskerr(bp, \"fd\", \"soft error\", LOG_PRINTF,\n\t\t\t    fd->sc_skip / fd_bsize, (struct disklabel *)NULL);\n\t\t\tprintf(\"\\n\");\n\t\t\tfdc->sc_errors = 0;\n\t\t}\n\t\tfd->sc_blkno += fd->sc_nblks;\n\t\tfd->sc_skip += fd->sc_nbytes;\n\t\tfd->sc_bcount -= fd->sc_nbytes;\n\t\tif (!finfo && fd->sc_bcount > 0) {\n\t\t\tbp->b_cylin = fd->sc_blkno / fd->sc_type->seccyl;\n\t\t\tgoto doseek;\n\t\t}\n\t\tfdfinish(fd, bp);\n\t\tgoto loop;\n\n\tcase DORESET:\n\t\t/* try a reset, keep motor on */\n\t\tfd_set_motor(fdc, 1);\n\t\tdelay(100);\n\t\tfd_set_motor(fdc, 0);\n\t\tfdc->sc_state = RESETCOMPLETE;\n\t\ttimeout(fdtimeout, fd, hz / 2);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RESETCOMPLETE:\n\t\tuntimeout(fdtimeout, fd);\n\t\t/* clear the controller output buffer */\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\t\t(void) fdcresult(fdc);\n\t\t}\n\n\t\t/* fall through */\n\tcase DORECAL:\n\t\tout_fdc(iot, ioh, NE7CMD_RECAL);\t/* recal function */\n\t\tout_fdc(iot, ioh, fd->sc_drive);\n\t\tfdc->sc_state = RECALWAIT;\n\t\ttimeout(fdtimeout, fd, 5 * hz);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RECALWAIT:\n\t\tuntimeout(fdtimeout, fd);\n\t\tfdc->sc_state = RECALCOMPLETE;\n\t\t/* allow 1/30 second for heads to settle */\n\t\ttimeout(fdcpseudointr, fdc, hz / 30);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RECALCOMPLETE:\n\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\tif (fdcresult(fdc) != 2 || (st0 & 0xf8) != 0x20 || cyl != 0) {\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 2, \"recalibrate failed\");\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tfd->sc_cylin = 0;\n\t\tgoto doseek;\n\n\tcase MOTORWAIT:\n\t\tif (fd->sc_flags & FD_MOTOR_WAIT)\n\t\t\treturn 1;\t\t/* time's not up yet */\n\t\tgoto doseek;\n\n\tdefault:\n\t\tfdcstatus(&fd->sc_dev, 0, \"stray interrupt\");\n\t\treturn 1;\n\t}\n#ifdef DIAGNOSTIC\n\tpanic(\"fdintr: impossible\");\n#endif\n#undef\tst0\n#undef\tcyl\n}",
          "includes": [
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tcyl\tfdc->sc_status[1]",
            "#define\tst0\tfdc->sc_status[0]",
            "#define\tFD_MOTOR_WAIT\t0x04\t\t/* motor coming up */",
            "#define\tFD_MOTOR\t0x02\t\t/* motor should be on */",
            "#define b_cylin b_resid",
            "#define B_FORMAT B_XXX"
          ],
          "globals_used": [
            "int fdintr",
            "void fd_set_motor",
            "void fd_motor_off",
            "void fd_motor_on",
            "void fdfinish",
            "void fdretry",
            "void fdtimeout",
            "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
            "int nvraminfo, drive;",
            "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tcyl\tfdc->sc_status[1]\n#define\tst0\tfdc->sc_status[0]\n#define\tFD_MOTOR_WAIT\t0x04\t\t/* motor coming up */\n#define\tFD_MOTOR\t0x02\t\t/* motor should be on */\n#define b_cylin b_resid\n#define B_FORMAT B_XXX\n\nint fdintr;\nvoid fd_set_motor;\nvoid fd_motor_off;\nvoid fd_motor_on;\nvoid fdfinish;\nvoid fdretry;\nvoid fdtimeout;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\nint nvraminfo, drive;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nint\nfdintr(fdc)\n\tstruct fdc_softc *fdc;\n{\n#define\tst0\tfdc->sc_status[0]\n#define\tcyl\tfdc->sc_status[1]\n\tstruct fd_softc *fd;\n\tstruct buf *bp;\n\tbus_space_tag_t iot = fdc->sc_iot;\n\tbus_space_handle_t ioh = fdc->sc_ioh;\n\tbus_space_handle_t ioh_ctl = fdc->sc_ioh_ctl;\n\tint read, head, sec, i, nblks;\n\tstruct fd_type *type;\n\tstruct fd_formb *finfo = NULL;\n\tint fd_bsize, bf;\n\nloop:\n\t/* Is there a transfer to this drive?  If not, deactivate drive. */\n\tfd = fdc->sc_link.fdlink.sc_drives.tqh_first;\n\tif (fd == NULL) {\n\t\tfdc->sc_state = DEVIDLE;\n\t\treturn 1;\n\t}\n\tfd_bsize = 128 << fd->sc_type->secsize;\n\tbf = fd_bsize / FDC_BSIZE;\n\n\tbp = fd->sc_q.b_actf;\n\tif (bp == NULL) {\n\t\tfd->sc_ops = 0;\n\t\tTAILQ_REMOVE(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);\n\t\tfd->sc_q.b_active = 0;\n\t\tgoto loop;\n\t}\n\n\tif (bp->b_flags & B_FORMAT)\n\t    finfo = (struct fd_formb *)bp->b_data;\n\n\tswitch (fdc->sc_state) {\n\tcase DEVIDLE:\n\t\tfdc->sc_errors = 0;\n\t\tfd->sc_skip = 0;\n\t\tfd->sc_bcount = bp->b_bcount;\n\t\tfd->sc_blkno = bp->b_blkno / (fd_bsize / DEV_BSIZE);\n\t\tuntimeout(fd_motor_off, fd);\n\t\tif ((fd->sc_flags & FD_MOTOR_WAIT) != 0) {\n\t\t\tfdc->sc_state = MOTORWAIT;\n\t\t\treturn 1;\n\t\t}\n\t\tif ((fd->sc_flags & FD_MOTOR) == 0) {\n\t\t\t/* Turn on the motor, being careful about pairing. */\n\t\t\tstruct fd_softc *ofd =\n\t\t\t\tfdc->sc_link.fdlink.sc_fd[fd->sc_drive ^ 1];\n\t\t\tif (ofd && ofd->sc_flags & FD_MOTOR) {\n\t\t\t\tuntimeout(fd_motor_off, ofd);\n\t\t\t\tofd->sc_flags &= ~(FD_MOTOR | FD_MOTOR_WAIT);\n\t\t\t}\n\t\t\tfd->sc_flags |= FD_MOTOR | FD_MOTOR_WAIT;\n\t\t\tfd_set_motor(fdc, 0);\n\t\t\tfdc->sc_state = MOTORWAIT;\n\t\t\t/* Allow .25s for motor to stabilize. */\n\t\t\ttimeout(fd_motor_on, fd, hz / 4);\n\t\t\treturn 1;\n\t\t}\n\t\t/* Make sure the right drive is selected. */\n\t\tfd_set_motor(fdc, 0);\n\n\t\t/* fall through */\n\tcase DOSEEK:\n\tdoseek:\n\t\tif (fd->sc_cylin == bp->b_cylin)\n\t\t\tgoto doio;\n\n\t\tout_fdc(iot, ioh, NE7CMD_SPECIFY);/* specify command */\n\t\tout_fdc(iot, ioh, fd->sc_type->steprate);\n\t\tout_fdc(iot, ioh, 6);\t\t/* XXX head load time == 6ms */\n\n\t\tout_fdc(iot, ioh, NE7CMD_SEEK);\t/* seek function */\n\t\tout_fdc(iot, ioh, fd->sc_drive);\t/* drive number */\n\t\tout_fdc(iot, ioh, bp->b_cylin * fd->sc_type->step);\n\n\t\tfd->sc_cylin = -1;\n\t\tfdc->sc_state = SEEKWAIT;\n\n\t\tfd->sc_dk.dk_seek++;\n\t\tdisk_busy(&fd->sc_dk);\n\n\t\ttimeout(fdtimeout, fd, 4 * hz);\n\t\treturn 1;\n\n\tcase DOIO:\n\tdoio:\n\t\ttype = fd->sc_type;\n\t\tif (finfo)\n\t\t    fd->sc_skip = (char *)&(finfo->fd_formb_cylno(0)) -\n\t\t\t(char *)finfo;\n\t\tsec = fd->sc_blkno % type->seccyl;\n\t\tnblks = type->seccyl - sec;\n\t\tnblks = min(nblks, fd->sc_bcount / fd_bsize);\n\t\tnblks = min(nblks, FDC_MAXIOSIZE / fd_bsize);\n\t\tfd->sc_nblks = nblks;\n\t\tfd->sc_nbytes = finfo ? bp->b_bcount : nblks * fd_bsize;\n\t\thead = sec / type->sectrac;\n\t\tsec -= head * type->sectrac;\n#ifdef DIAGNOSTIC\n\t\t{int block;\n\t\t block = (fd->sc_cylin * type->heads + head) * type->sectrac + sec;\n\t\t if (block != fd->sc_blkno) {\n\t\t\t printf(\"fdintr: block %d != blkno %d\\n\", block, fd->sc_blkno);\n#ifdef DDB\n\t\t\t Debugger();\n#endif\n\t\t }}\n#endif\n\t\tread = bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE;\n\t\tisadma_start(bp->b_data + fd->sc_skip, fd->sc_nbytes,\n\t\t    fdc->sc_drq, read);\n\t\tbus_space_write_1(iot, ioh_ctl, fdctl, type->rate);\n#ifdef FD_DEBUG\n\t\tprintf(\"fdintr: %s drive %d track %d head %d sec %d nblks %d\\n\",\n\t\t    read ? \"read\" : \"write\", fd->sc_drive, fd->sc_cylin, head,\n\t\t    sec, nblks);\n#endif\n\t\tif (finfo) {\n                        /* formatting */\n\t\t\tif (out_fdc(iot, ioh, NE7CMD_FORMAT) < 0) {\n\t\t\t    fdc->sc_errors = 4;\n\t\t\t    fdretry(fd);\n\t\t\t    goto loop;\n\t\t\t}\n                        out_fdc(iot, ioh, (head << 2) | fd->sc_drive);\n                        out_fdc(iot, ioh, finfo->fd_formb_secshift);\n                        out_fdc(iot, ioh, finfo->fd_formb_nsecs);\n                        out_fdc(iot, ioh, finfo->fd_formb_gaplen);\n                        out_fdc(iot, ioh, finfo->fd_formb_fillbyte);\n\t\t} else {\n\t\t\tif (read)\n\t\t\t\tout_fdc(iot, ioh, NE7CMD_READ);\t/* READ */\n\t\t\telse\n\t\t\t\tout_fdc(iot, ioh, NE7CMD_WRITE);/* WRITE */\n\t\t\tout_fdc(iot, ioh, (head << 2) | fd->sc_drive);\n\t\t\tout_fdc(iot, ioh, fd->sc_cylin);\t/* track */\n\t\t\tout_fdc(iot, ioh, head);\n\t\t\tout_fdc(iot, ioh, sec + 1);\t\t/* sec +1 */\n\t\t\tout_fdc(iot, ioh, type->secsize);\t/* sec size */\n\t\t\tout_fdc(iot, ioh, type->sectrac);\t/* secs/track */\n\t\t\tout_fdc(iot, ioh, type->gap1);\t\t/* gap1 size */\n\t\t\tout_fdc(iot, ioh, type->datalen);\t/* data len */\n\t\t}\n\t\tfdc->sc_state = IOCOMPLETE;\n\n\t\tdisk_busy(&fd->sc_dk);\n\n\t\t/* allow 2 seconds for operation */\n\t\ttimeout(fdtimeout, fd, 2 * hz);\n\t\treturn 1;\t\t\t\t/* will return later */\n\n\tcase SEEKWAIT:\n\t\tuntimeout(fdtimeout, fd);\n\t\tfdc->sc_state = SEEKCOMPLETE;\n\t\t/* allow 1/50 second for heads to settle */\n\t\ttimeout(fdcpseudointr, fdc, hz / 50);\n\t\treturn 1;\n\n\tcase SEEKCOMPLETE:\n\t\tdisk_unbusy(&fd->sc_dk, 0);\t/* no data on seek */\n\n\t\t/* Make sure seek really happened. */\n\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\tif (fdcresult(fdc) != 2 || (st0 & 0xf8) != 0x20 ||\n\t\t    cyl != bp->b_cylin * fd->sc_type->step) {\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 2, \"seek failed\");\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tfd->sc_cylin = bp->b_cylin;\n\t\tgoto doio;\n\n\tcase IOTIMEDOUT:\n\t\tisadma_abort(fdc->sc_drq);\n\tcase SEEKTIMEDOUT:\n\tcase RECALTIMEDOUT:\n\tcase RESETTIMEDOUT:\n\t\tfdretry(fd);\n\t\tgoto loop;\n\n\tcase IOCOMPLETE: /* IO DONE, post-analyze */\n\t\tuntimeout(fdtimeout, fd);\n\n\t\tdisk_unbusy(&fd->sc_dk, (bp->b_bcount - bp->b_resid));\n\n\t\tif (fdcresult(fdc) != 7 || (st0 & 0xf8) != 0) {\n\t\t\tisadma_abort(fdc->sc_drq);\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 7, bp->b_flags & B_READ ?\n\t\t\t    \"read failed\" : \"write failed\");\n\t\t\tprintf(\"blkno %d nblks %d\\n\",\n\t\t\t    fd->sc_blkno, fd->sc_nblks);\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tread = bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE;\n\t\tisadma_done(fdc->sc_drq);\n\t\tif (fdc->sc_errors) {\n\t\t\tdiskerr(bp, \"fd\", \"soft error\", LOG_PRINTF,\n\t\t\t    fd->sc_skip / fd_bsize, (struct disklabel *)NULL);\n\t\t\tprintf(\"\\n\");\n\t\t\tfdc->sc_errors = 0;\n\t\t}\n\t\tfd->sc_blkno += fd->sc_nblks;\n\t\tfd->sc_skip += fd->sc_nbytes;\n\t\tfd->sc_bcount -= fd->sc_nbytes;\n\t\tif (!finfo && fd->sc_bcount > 0) {\n\t\t\tbp->b_cylin = fd->sc_blkno / fd->sc_type->seccyl;\n\t\t\tgoto doseek;\n\t\t}\n\t\tfdfinish(fd, bp);\n\t\tgoto loop;\n\n\tcase DORESET:\n\t\t/* try a reset, keep motor on */\n\t\tfd_set_motor(fdc, 1);\n\t\tdelay(100);\n\t\tfd_set_motor(fdc, 0);\n\t\tfdc->sc_state = RESETCOMPLETE;\n\t\ttimeout(fdtimeout, fd, hz / 2);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RESETCOMPLETE:\n\t\tuntimeout(fdtimeout, fd);\n\t\t/* clear the controller output buffer */\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\t\t(void) fdcresult(fdc);\n\t\t}\n\n\t\t/* fall through */\n\tcase DORECAL:\n\t\tout_fdc(iot, ioh, NE7CMD_RECAL);\t/* recal function */\n\t\tout_fdc(iot, ioh, fd->sc_drive);\n\t\tfdc->sc_state = RECALWAIT;\n\t\ttimeout(fdtimeout, fd, 5 * hz);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RECALWAIT:\n\t\tuntimeout(fdtimeout, fd);\n\t\tfdc->sc_state = RECALCOMPLETE;\n\t\t/* allow 1/30 second for heads to settle */\n\t\ttimeout(fdcpseudointr, fdc, hz / 30);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RECALCOMPLETE:\n\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\tif (fdcresult(fdc) != 2 || (st0 & 0xf8) != 0x20 || cyl != 0) {\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 2, \"recalibrate failed\");\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tfd->sc_cylin = 0;\n\t\tgoto doseek;\n\n\tcase MOTORWAIT:\n\t\tif (fd->sc_flags & FD_MOTOR_WAIT)\n\t\t\treturn 1;\t\t/* time's not up yet */\n\t\tgoto doseek;\n\n\tdefault:\n\t\tfdcstatus(&fd->sc_dev, 0, \"stray interrupt\");\n\t\treturn 1;\n\t}\n#ifdef DIAGNOSTIC\n\tpanic(\"fdintr: impossible\");\n#endif\n#undef\tst0\n#undef\tcyl\n}"
        }
      },
      {
        "call_info": {
          "callee": "__P",
          "args": [
            "(struct fdc_softc *)"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint fdcintr;\n\nint\nfdcintr(arg)\n\tvoid *arg;\n{\n#if NFD > 0\n\tstruct fdc_softc *fdc = arg;\n\textern int fdintr __P((struct fdc_softc *));\n\n\t/* Will switch on device type, shortly. */\n\treturn (fdintr(fdc));\n#else\n\tprintf(\"fdcintr: got interrupt, but no devices!\\n\");\n\treturn (1);\n#endif\n}"
  },
  {
    "function_name": "fdcpseudointr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
    "lines": "322-332",
    "snippet": "void\nfdcpseudointr(arg)\n\tvoid *arg;\n{\n\tint s;\n\n\t/* Just ensure it has the right spl. */\n\ts = splbio();\n\t(void) fdcintr(arg);\n\tsplx(s);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int fdcintr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdcintr",
          "args": [
            "arg"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "fdcintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
          "lines": "334-348",
          "snippet": "int\nfdcintr(arg)\n\tvoid *arg;\n{\n#if NFD > 0\n\tstruct fdc_softc *fdc = arg;\n\textern int fdintr __P((struct fdc_softc *));\n\n\t/* Will switch on device type, shortly. */\n\treturn (fdintr(fdc));\n#else\n\tprintf(\"fdcintr: got interrupt, but no devices!\\n\");\n\treturn (1);\n#endif\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int fdcintr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint fdcintr;\n\nint\nfdcintr(arg)\n\tvoid *arg;\n{\n#if NFD > 0\n\tstruct fdc_softc *fdc = arg;\n\textern int fdintr __P((struct fdc_softc *));\n\n\t/* Will switch on device type, shortly. */\n\treturn (fdintr(fdc));\n#else\n\tprintf(\"fdcintr: got interrupt, but no devices!\\n\");\n\treturn (1);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint fdcintr;\n\nvoid\nfdcpseudointr(arg)\n\tvoid *arg;\n{\n\tint s;\n\n\t/* Just ensure it has the right spl. */\n\ts = splbio();\n\t(void) fdcintr(arg);\n\tsplx(s);\n}"
  },
  {
    "function_name": "fdcstatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
    "lines": "282-320",
    "snippet": "void\nfdcstatus(dv, n, s)\n\tstruct device *dv;\n\tint n;\n\tchar *s;\n{\n\tstruct fdc_softc *fdc = (void *)dv->dv_parent;\n\n\tif (n == 0) {\n\t\tout_fdc(fdc->sc_iot, fdc->sc_ioh, NE7CMD_SENSEI);\n\t\t(void) fdcresult(fdc);\n\t\tn = 2;\n\t}\n\n\tprintf(\"%s: %s\", dv->dv_xname, s);\n\n\tswitch (n) {\n\tcase 0:\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tprintf(\" (st0 %b cyl %d)\\n\",\n\t\t    fdc->sc_status[0], NE7_ST0BITS,\n\t\t    fdc->sc_status[1]);\n\t\tbreak;\n\tcase 7:\n\t\tprintf(\" (st0 %b st1 %b st2 %b cyl %d head %d sec %d)\\n\",\n\t\t    fdc->sc_status[0], NE7_ST0BITS,\n\t\t    fdc->sc_status[1], NE7_ST1BITS,\n\t\t    fdc->sc_status[2], NE7_ST2BITS,\n\t\t    fdc->sc_status[3], fdc->sc_status[4], fdc->sc_status[5]);\n\t\tbreak;\n#ifdef DIAGNOSTIC\n\tdefault:\n\t\tprintf(\"\\nfdcstatus: weird size\");\n\t\tbreak;\n#endif\n\t}\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nfdcstatus: weird size\""
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdcresult",
          "args": [
            "fdc"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "fdcresult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
          "lines": "220-246",
          "snippet": "int\nfdcresult(fdc)\n\tstruct fdc_softc *fdc;\n{\n\tbus_space_tag_t iot = fdc->sc_iot;\n\tbus_space_handle_t ioh = fdc->sc_ioh;\n\tu_char i;\n\tint j = 100000, n = 0;\n\n\tfor (; j; j--) {\n\t\ti = bus_space_read_1(iot, ioh, fdsts) &\n\t\t    (NE7_DIO | NE7_RQM | NE7_CB);\n\t\tif (i == NE7_RQM)\n\t\t\treturn n;\n\t\tif (i == (NE7_DIO | NE7_RQM | NE7_CB)) {\n\t\t\tif (n >= sizeof(fdc->sc_status)) {\n\t\t\t\tlog(LOG_ERR, \"fdcresult: overrun\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfdc->sc_status[n++] =\n\t\t\t    bus_space_read_1(iot, ioh, fddata);\n\t\t}\n\t\tdelay(10);\n\t}\n\tlog(LOG_ERR, \"fdcresult: timeout\\n\");\n\treturn -1;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nfdcresult(fdc)\n\tstruct fdc_softc *fdc;\n{\n\tbus_space_tag_t iot = fdc->sc_iot;\n\tbus_space_handle_t ioh = fdc->sc_ioh;\n\tu_char i;\n\tint j = 100000, n = 0;\n\n\tfor (; j; j--) {\n\t\ti = bus_space_read_1(iot, ioh, fdsts) &\n\t\t    (NE7_DIO | NE7_RQM | NE7_CB);\n\t\tif (i == NE7_RQM)\n\t\t\treturn n;\n\t\tif (i == (NE7_DIO | NE7_RQM | NE7_CB)) {\n\t\t\tif (n >= sizeof(fdc->sc_status)) {\n\t\t\t\tlog(LOG_ERR, \"fdcresult: overrun\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfdc->sc_status[n++] =\n\t\t\t    bus_space_read_1(iot, ioh, fddata);\n\t\t}\n\t\tdelay(10);\n\t}\n\tlog(LOG_ERR, \"fdcresult: timeout\\n\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "out_fdc",
          "args": [
            "fdc->sc_iot",
            "fdc->sc_ioh",
            "NE7CMD_SENSEI"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "out_fdc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
          "lines": "248-264",
          "snippet": "int\nout_fdc(iot, ioh, x)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tu_char x;\n{\n\tint i = 100000;\n\n\twhile ((bus_space_read_1(iot, ioh, fdsts) & NE7_DIO) && i-- > 0);\n\tif (i <= 0)\n\t\treturn -1;\n\twhile ((bus_space_read_1(iot, ioh, fdsts) & NE7_RQM) == 0 && i-- > 0);\n\tif (i <= 0)\n\t\treturn -1;\n\tbus_space_write_1(iot, ioh, fddata, x);\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nout_fdc(iot, ioh, x)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tu_char x;\n{\n\tint i = 100000;\n\n\twhile ((bus_space_read_1(iot, ioh, fdsts) & NE7_DIO) && i-- > 0);\n\tif (i <= 0)\n\t\treturn -1;\n\twhile ((bus_space_read_1(iot, ioh, fdsts) & NE7_RQM) == 0 && i-- > 0);\n\tif (i <= 0)\n\t\treturn -1;\n\tbus_space_write_1(iot, ioh, fddata, x);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nfdcstatus(dv, n, s)\n\tstruct device *dv;\n\tint n;\n\tchar *s;\n{\n\tstruct fdc_softc *fdc = (void *)dv->dv_parent;\n\n\tif (n == 0) {\n\t\tout_fdc(fdc->sc_iot, fdc->sc_ioh, NE7CMD_SENSEI);\n\t\t(void) fdcresult(fdc);\n\t\tn = 2;\n\t}\n\n\tprintf(\"%s: %s\", dv->dv_xname, s);\n\n\tswitch (n) {\n\tcase 0:\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tprintf(\" (st0 %b cyl %d)\\n\",\n\t\t    fdc->sc_status[0], NE7_ST0BITS,\n\t\t    fdc->sc_status[1]);\n\t\tbreak;\n\tcase 7:\n\t\tprintf(\" (st0 %b st1 %b st2 %b cyl %d head %d sec %d)\\n\",\n\t\t    fdc->sc_status[0], NE7_ST0BITS,\n\t\t    fdc->sc_status[1], NE7_ST1BITS,\n\t\t    fdc->sc_status[2], NE7_ST2BITS,\n\t\t    fdc->sc_status[3], fdc->sc_status[4], fdc->sc_status[5]);\n\t\tbreak;\n#ifdef DIAGNOSTIC\n\tdefault:\n\t\tprintf(\"\\nfdcstatus: weird size\");\n\t\tbreak;\n#endif\n\t}\n}"
  },
  {
    "function_name": "fdcstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
    "lines": "266-280",
    "snippet": "void\nfdcstart(fdc)\n\tstruct fdc_softc *fdc;\n{\n\n#ifdef DIAGNOSTIC\n\t/* only got here if controller's drive queue was inactive; should\n\t   be in idle state */\n\tif (fdc->sc_state != DEVIDLE) {\n\t\tprintf(\"fdcstart: not idle\\n\");\n\t\treturn;\n\t}\n#endif\n\t(void) fdcintr(fdc);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int fdcintr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdcintr",
          "args": [
            "fdc"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "fdcintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
          "lines": "334-348",
          "snippet": "int\nfdcintr(arg)\n\tvoid *arg;\n{\n#if NFD > 0\n\tstruct fdc_softc *fdc = arg;\n\textern int fdintr __P((struct fdc_softc *));\n\n\t/* Will switch on device type, shortly. */\n\treturn (fdintr(fdc));\n#else\n\tprintf(\"fdcintr: got interrupt, but no devices!\\n\");\n\treturn (1);\n#endif\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int fdcintr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint fdcintr;\n\nint\nfdcintr(arg)\n\tvoid *arg;\n{\n#if NFD > 0\n\tstruct fdc_softc *fdc = arg;\n\textern int fdintr __P((struct fdc_softc *));\n\n\t/* Will switch on device type, shortly. */\n\treturn (fdintr(fdc));\n#else\n\tprintf(\"fdcintr: got interrupt, but no devices!\\n\");\n\treturn (1);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"fdcstart: not idle\\n\""
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint fdcintr;\n\nvoid\nfdcstart(fdc)\n\tstruct fdc_softc *fdc;\n{\n\n#ifdef DIAGNOSTIC\n\t/* only got here if controller's drive queue was inactive; should\n\t   be in idle state */\n\tif (fdc->sc_state != DEVIDLE) {\n\t\tprintf(\"fdcstart: not idle\\n\");\n\t\treturn;\n\t}\n#endif\n\t(void) fdcintr(fdc);\n}"
  },
  {
    "function_name": "out_fdc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
    "lines": "248-264",
    "snippet": "int\nout_fdc(iot, ioh, x)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tu_char x;\n{\n\tint i = 100000;\n\n\twhile ((bus_space_read_1(iot, ioh, fdsts) & NE7_DIO) && i-- > 0);\n\tif (i <= 0)\n\t\treturn -1;\n\twhile ((bus_space_read_1(iot, ioh, fdsts) & NE7_RQM) == 0 && i-- > 0);\n\tif (i <= 0)\n\t\treturn -1;\n\tbus_space_write_1(iot, ioh, fddata, x);\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "fddata",
            "x"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "fdsts"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "fdsts"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nout_fdc(iot, ioh, x)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tu_char x;\n{\n\tint i = 100000;\n\n\twhile ((bus_space_read_1(iot, ioh, fdsts) & NE7_DIO) && i-- > 0);\n\tif (i <= 0)\n\t\treturn -1;\n\twhile ((bus_space_read_1(iot, ioh, fdsts) & NE7_RQM) == 0 && i-- > 0);\n\tif (i <= 0)\n\t\treturn -1;\n\tbus_space_write_1(iot, ioh, fddata, x);\n\treturn 0;\n}"
  },
  {
    "function_name": "fdcresult",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
    "lines": "220-246",
    "snippet": "int\nfdcresult(fdc)\n\tstruct fdc_softc *fdc;\n{\n\tbus_space_tag_t iot = fdc->sc_iot;\n\tbus_space_handle_t ioh = fdc->sc_ioh;\n\tu_char i;\n\tint j = 100000, n = 0;\n\n\tfor (; j; j--) {\n\t\ti = bus_space_read_1(iot, ioh, fdsts) &\n\t\t    (NE7_DIO | NE7_RQM | NE7_CB);\n\t\tif (i == NE7_RQM)\n\t\t\treturn n;\n\t\tif (i == (NE7_DIO | NE7_RQM | NE7_CB)) {\n\t\t\tif (n >= sizeof(fdc->sc_status)) {\n\t\t\t\tlog(LOG_ERR, \"fdcresult: overrun\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfdc->sc_status[n++] =\n\t\t\t    bus_space_read_1(iot, ioh, fddata);\n\t\t}\n\t\tdelay(10);\n\t}\n\tlog(LOG_ERR, \"fdcresult: timeout\\n\");\n\treturn -1;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"fdcresult: timeout\\n\""
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_read_error_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "324-340",
          "snippet": "static pdq_boolean_t\npdq_read_error_log(\n    pdq_t *pdq,\n    pdq_response_error_log_get_t *log_entry)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_uint32_t *ptr = (pdq_uint32_t *) log_entry;\n\n    pdq_do_port_control(csrs, PDQ_PCTL_ERROR_LOG_START);\n\n    while (pdq_do_port_control(csrs, PDQ_PCTL_FW_REV_READ) == PDQ_TRUE) {\n\t*ptr++ = PDQ_CSR_READ(csrs, csr_host_data);\n\tif ((pdq_uint8_t *) ptr - (pdq_uint8_t *) log_entry == sizeof(*log_entry))\n\t    break;\n    }\n    return (ptr == (pdq_uint32_t *) log_entry) ? PDQ_FALSE : PDQ_TRUE;\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic pdq_boolean_t\npdq_read_error_log(\n    pdq_t *pdq,\n    pdq_response_error_log_get_t *log_entry)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_uint32_t *ptr = (pdq_uint32_t *) log_entry;\n\n    pdq_do_port_control(csrs, PDQ_PCTL_ERROR_LOG_START);\n\n    while (pdq_do_port_control(csrs, PDQ_PCTL_FW_REV_READ) == PDQ_TRUE) {\n\t*ptr++ = PDQ_CSR_READ(csrs, csr_host_data);\n\tif ((pdq_uint8_t *) ptr - (pdq_uint8_t *) log_entry == sizeof(*log_entry))\n\t    break;\n    }\n    return (ptr == (pdq_uint32_t *) log_entry) ? PDQ_FALSE : PDQ_TRUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "fddata"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "fdsts"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nfdcresult(fdc)\n\tstruct fdc_softc *fdc;\n{\n\tbus_space_tag_t iot = fdc->sc_iot;\n\tbus_space_handle_t ioh = fdc->sc_ioh;\n\tu_char i;\n\tint j = 100000, n = 0;\n\n\tfor (; j; j--) {\n\t\ti = bus_space_read_1(iot, ioh, fdsts) &\n\t\t    (NE7_DIO | NE7_RQM | NE7_CB);\n\t\tif (i == NE7_RQM)\n\t\t\treturn n;\n\t\tif (i == (NE7_DIO | NE7_RQM | NE7_CB)) {\n\t\t\tif (n >= sizeof(fdc->sc_status)) {\n\t\t\t\tlog(LOG_ERR, \"fdcresult: overrun\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfdc->sc_status[n++] =\n\t\t\t    bus_space_read_1(iot, ioh, fddata);\n\t\t}\n\t\tdelay(10);\n\t}\n\tlog(LOG_ERR, \"fdcresult: timeout\\n\");\n\treturn -1;\n}"
  },
  {
    "function_name": "fddprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
    "lines": "208-218",
    "snippet": "int\nfddprint(aux, fdc)\n\tvoid *aux;\n\tconst char *fdc;\n{\n\tregister struct fdc_attach_args *fa = aux;\n\n\tif (!fdc)\n\t\tprintf(\" drive %d\", fa->fa_drive);\n\treturn QUIET;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int fddprint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" drive %d\"",
            "fa->fa_drive"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint fddprint;\n\nint\nfddprint(aux, fdc)\n\tvoid *aux;\n\tconst char *fdc;\n{\n\tregister struct fdc_attach_args *fa = aux;\n\n\tif (!fdc)\n\t\tprintf(\" drive %d\", fa->fa_drive);\n\treturn QUIET;\n}"
  },
  {
    "function_name": "fdcattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
    "lines": "141-199",
    "snippet": "void\nfdcattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct fdc_softc *fdc = (void *)self;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tbus_space_handle_t ioh_ctl;\n\tstruct isa_attach_args *ia = aux;\n\tstruct fdc_attach_args fa;\n\tint type;\n\n\tiot = ia->ia_iot;\n\n\t/* Re-map the I/O space. */\n\tif (bus_space_map(iot, ia->ia_iobase, FDC_NPORT, 0, &ioh) ||\n\t    bus_space_map(iot, ia->ia_iobase + FDCTL_OFFSET,\n\t\t\t  FDCTL_NPORT, 0, &ioh_ctl))\n\t\tpanic(\"fdcattach: couldn't map I/O ports\");\n\n\tfdc->sc_iot = iot;\n\tfdc->sc_ioh = ioh;\n\tfdc->sc_ioh_ctl = ioh_ctl;\n\n\tfdc->sc_drq = ia->ia_drq;\n\tfdc->sc_state = DEVIDLE;\n\tTAILQ_INIT(&fdc->sc_link.fdlink.sc_drives);\t/* XXX */\n\n\tprintf(\"\\n\");\n\n\tfdc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_BIO, fdcintr, fdc, fdc->sc_dev.dv_xname);\n\n#if defined(i386)\n\t/*\n\t * The NVRAM info only tells us about the first two disks on the\n\t * `primary' floppy controller.\n\t */\n\tif (fdc->sc_dev.dv_unit == 0)\n\t\ttype = mc146818_read(NULL, NVRAM_DISKETTE); /* XXX softc */\n\telse\n#endif\n\t\ttype = -1;\n\n\t/* physical limit: four drives per controller. */\n\tfor (fa.fa_drive = 0; fa.fa_drive < 4; fa.fa_drive++) {\n\t\tfa.fa_flags = 0;\n\t\tfa.fa_type = 0;\n#if NFD > 0\n\t\tif (type >= 0 && fa.fa_drive < 2)\n\t\t\tfa.fa_deftype = fd_nvtotype(fdc->sc_dev.dv_xname,\n\t\t\t    type, fa.fa_drive);\n\t\telse\n#endif\n\t\t\tfa.fa_deftype = NULL;\t\t/* unknown */\n\t\t(void)config_found(self, (void *)&fa, fddprint);\n\t}\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void fdcattach",
      "int fddprint",
      "int fdcintr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "self",
            "(void *)&fa",
            "fddprint"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd_nvtotype",
          "args": [
            "fdc->sc_dev.dv_xname",
            "type",
            "fa.fa_drive"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mc146818_read",
          "args": [
            "NULL",
            "NVRAM_DISKETTE"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "ia->ia_irq",
            "IST_EDGE",
            "IPL_BIO",
            "fdcintr",
            "fdc",
            "fdc->sc_dev.dv_xname"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&fdc->sc_link.fdlink.sc_drives"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"fdcattach: couldn't map I/O ports\""
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "ia->ia_iobase + FDCTL_OFFSET",
            "FDCTL_NPORT",
            "0",
            "&ioh_ctl"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "ia->ia_iobase",
            "FDC_NPORT",
            "0",
            "&ioh"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid fdcattach;\nint fddprint;\nint fdcintr;\n\nvoid\nfdcattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct fdc_softc *fdc = (void *)self;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tbus_space_handle_t ioh_ctl;\n\tstruct isa_attach_args *ia = aux;\n\tstruct fdc_attach_args fa;\n\tint type;\n\n\tiot = ia->ia_iot;\n\n\t/* Re-map the I/O space. */\n\tif (bus_space_map(iot, ia->ia_iobase, FDC_NPORT, 0, &ioh) ||\n\t    bus_space_map(iot, ia->ia_iobase + FDCTL_OFFSET,\n\t\t\t  FDCTL_NPORT, 0, &ioh_ctl))\n\t\tpanic(\"fdcattach: couldn't map I/O ports\");\n\n\tfdc->sc_iot = iot;\n\tfdc->sc_ioh = ioh;\n\tfdc->sc_ioh_ctl = ioh_ctl;\n\n\tfdc->sc_drq = ia->ia_drq;\n\tfdc->sc_state = DEVIDLE;\n\tTAILQ_INIT(&fdc->sc_link.fdlink.sc_drives);\t/* XXX */\n\n\tprintf(\"\\n\");\n\n\tfdc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_BIO, fdcintr, fdc, fdc->sc_dev.dv_xname);\n\n#if defined(i386)\n\t/*\n\t * The NVRAM info only tells us about the first two disks on the\n\t * `primary' floppy controller.\n\t */\n\tif (fdc->sc_dev.dv_unit == 0)\n\t\ttype = mc146818_read(NULL, NVRAM_DISKETTE); /* XXX softc */\n\telse\n#endif\n\t\ttype = -1;\n\n\t/* physical limit: four drives per controller. */\n\tfor (fa.fa_drive = 0; fa.fa_drive < 4; fa.fa_drive++) {\n\t\tfa.fa_flags = 0;\n\t\tfa.fa_type = 0;\n#if NFD > 0\n\t\tif (type >= 0 && fa.fa_drive < 2)\n\t\t\tfa.fa_deftype = fd_nvtotype(fdc->sc_dev.dv_xname,\n\t\t\t    type, fa.fa_drive);\n\t\telse\n#endif\n\t\t\tfa.fa_deftype = NULL;\t\t/* unknown */\n\t\t(void)config_found(self, (void *)&fa, fddprint);\n\t}\n}"
  },
  {
    "function_name": "fdcprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
    "lines": "99-139",
    "snippet": "int\nfdcprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tregister struct isa_attach_args *ia = aux;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tbus_space_handle_t ioh_ctl;\n\tint rv;\n\n\tiot = ia->ia_iot;\n\trv = 0;\n\n\t/* Map the i/o space. */\n\tif (bus_space_map(iot, ia->ia_iobase, FDC_NPORT, 0, &ioh))\n\t\treturn 0;\n\tif (bus_space_map(iot, ia->ia_iobase + FDCTL_OFFSET,\n\t\t\t  FDCTL_NPORT, 0, &ioh_ctl))\n\t\treturn 0;\n\n\t/* reset */\n\tbus_space_write_1(iot, ioh, fdout, 0);\n\tdelay(100);\n\tbus_space_write_1(iot, ioh, fdout, FDO_FRST);\n\n\t/* see if it can handle a command */\n\tif (out_fdc(iot, ioh, NE7CMD_SPECIFY) < 0)\n\t\tgoto out;\n\tout_fdc(iot, ioh, 0xdf);\n\tout_fdc(iot, ioh, 2);\n\n\trv = 1;\n\tia->ia_iosize = FDC_NPORT;\n\tia->ia_msize = 0;\n\n out:\n\tbus_space_unmap(iot, ioh, FDC_NPORT);\n\tbus_space_unmap(iot, ioh_ctl, FDCTL_NPORT);\n\treturn rv;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int fdcprobe"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh_ctl",
            "FDCTL_NPORT"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh",
            "FDC_NPORT"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out_fdc",
          "args": [
            "iot",
            "ioh",
            "2"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "out_fdc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
          "lines": "248-264",
          "snippet": "int\nout_fdc(iot, ioh, x)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tu_char x;\n{\n\tint i = 100000;\n\n\twhile ((bus_space_read_1(iot, ioh, fdsts) & NE7_DIO) && i-- > 0);\n\tif (i <= 0)\n\t\treturn -1;\n\twhile ((bus_space_read_1(iot, ioh, fdsts) & NE7_RQM) == 0 && i-- > 0);\n\tif (i <= 0)\n\t\treturn -1;\n\tbus_space_write_1(iot, ioh, fddata, x);\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nout_fdc(iot, ioh, x)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tu_char x;\n{\n\tint i = 100000;\n\n\twhile ((bus_space_read_1(iot, ioh, fdsts) & NE7_DIO) && i-- > 0);\n\tif (i <= 0)\n\t\treturn -1;\n\twhile ((bus_space_read_1(iot, ioh, fdsts) & NE7_RQM) == 0 && i-- > 0);\n\tif (i <= 0)\n\t\treturn -1;\n\tbus_space_write_1(iot, ioh, fddata, x);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "fdout",
            "FDO_FRST"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "fdout",
            "0"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "ia->ia_iobase + FDCTL_OFFSET",
            "FDCTL_NPORT",
            "0",
            "&ioh_ctl"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "ia->ia_iobase",
            "FDC_NPORT",
            "0",
            "&ioh"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint fdcprobe;\n\nint\nfdcprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tregister struct isa_attach_args *ia = aux;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tbus_space_handle_t ioh_ctl;\n\tint rv;\n\n\tiot = ia->ia_iot;\n\trv = 0;\n\n\t/* Map the i/o space. */\n\tif (bus_space_map(iot, ia->ia_iobase, FDC_NPORT, 0, &ioh))\n\t\treturn 0;\n\tif (bus_space_map(iot, ia->ia_iobase + FDCTL_OFFSET,\n\t\t\t  FDCTL_NPORT, 0, &ioh_ctl))\n\t\treturn 0;\n\n\t/* reset */\n\tbus_space_write_1(iot, ioh, fdout, 0);\n\tdelay(100);\n\tbus_space_write_1(iot, ioh, fdout, FDO_FRST);\n\n\t/* see if it can handle a command */\n\tif (out_fdc(iot, ioh, NE7CMD_SPECIFY) < 0)\n\t\tgoto out;\n\tout_fdc(iot, ioh, 0xdf);\n\tout_fdc(iot, ioh, 2);\n\n\trv = 1;\n\tia->ia_iosize = FDC_NPORT;\n\tia->ia_msize = 0;\n\n out:\n\tbus_space_unmap(iot, ioh, FDC_NPORT);\n\tbus_space_unmap(iot, ioh_ctl, FDCTL_NPORT);\n\treturn rv;\n}"
  }
]