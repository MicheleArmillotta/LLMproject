[
  {
    "function_name": "read_seeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc93cx6.c",
    "lines": "93-180",
    "snippet": "int\nread_seeprom(sd, buf, start_addr, count)\n\tstruct seeprom_descriptor *sd;\n\tu_int16_t *buf;\n\tbus_size_t start_addr;\n\tbus_size_t count;\n{\n\tint i = 0;\n\tu_int k = 0;\n\tu_int16_t v;\n\tu_int8_t temp;\n\n\t/*\n\t * Read the requested registers of the seeprom.  The loop\n\t * will range from 0 to count-1.\n\t */\n\tfor (k = start_addr; k < count + start_addr; k++) {\n\t\t/* Send chip select for one clock cycle. */\n\t\ttemp = sd->sd_MS ^ sd->sd_CS;\n\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\n\t\t/*\n\t\t * Now we're ready to send the read command followed by the\n\t\t * address of the 16-bit register we want to read.\n\t\t */\n\t\tfor (i = 0; i < seeprom_read.len; i++) {\n\t\t\tif (seeprom_read.bits[i] != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t\tSEEPROM_OUTB(sd, temp);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tif (seeprom_read.bits[i] != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t}\n\t\t/* Send the 6 or 8 bit address (MSB first, LSB last). */\n\t\tfor (i = (sd->sd_chip - 1); i >= 0; i--) {\n\t\t\tif ((k & (1 << i)) != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t\tSEEPROM_OUTB(sd, temp);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tif ((k & (1 << i)) != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t}\n\n\t\t/*\n\t\t * Now read the 16 bit register.  An initial 0 precedes the\n\t\t * register contents which begins with bit 15 (MSB) and ends\n\t\t * with bit 0 (LSB).  The initial 0 will be shifted off the\n\t\t * top of our word as we let the loop run from 0 to 16.\n\t\t */\n\t\tv = 0;\n\t\tfor (i = 16; i >= 0; i--) {\n\t\t\tSEEPROM_OUTB(sd, temp);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tv <<= 1;\n\t\t\tif (SEEPROM_DATA_INB(sd) & sd->sd_DI)\n\t\t\t\tv |= 1;\n\t\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t}\n\n\t\tbuf[k - start_addr] = v;\n\n\t\t/* Reset the chip select for the next command cycle. */\n\t\ttemp = sd->sd_MS;\n\t\tSEEPROM_OUTB(sd, temp);\n\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\tSEEPROM_OUTB(sd, temp);\n\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t}\n#ifdef AHC_DUMP_EEPROM\n\tprintf(\"\\nSerial EEPROM:\\n\\t\");\n\tfor (k = 0; k < count; k = k + 1) {\n\t\tif (((k % 8) == 0) && (k != 0)) {\n\t\t\tprintf (\"\\n\\t\");\n\t\t}\n\t\tprintf (\" 0x%x\", buf[k]);\n\t}\n\tprintf (\"\\n\");\n#endif\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/smc93cx6var.h>",
      "#include <dev/aic7xxx/93cx6.h>",
      "#include <machine/bus.h>",
      "#include <machine/bus_pio.h>",
      "#include <machine/bus_memio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct seeprom_cmd {\n  \tunsigned char len;\n \tunsigned char bits[3];\n} seeprom_read = {3, {1, 1, 0}};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CLOCK_PULSE",
          "args": [
            "sd",
            "sd->sd_RDY"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEEPROM_OUTB",
          "args": [
            "sd",
            "temp"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLOCK_PULSE",
          "args": [
            "sd",
            "sd->sd_RDY"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEEPROM_OUTB",
          "args": [
            "sd",
            "temp ^ sd->sd_CK"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLOCK_PULSE",
          "args": [
            "sd",
            "sd->sd_RDY"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEEPROM_OUTB",
          "args": [
            "sd",
            "temp"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLOCK_PULSE",
          "args": [
            "sd",
            "sd->sd_RDY"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEEPROM_OUTB",
          "args": [
            "sd",
            "temp ^ sd->sd_CK"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEEPROM_DATA_INB",
          "args": [
            "sd"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLOCK_PULSE",
          "args": [
            "sd",
            "sd->sd_RDY"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEEPROM_OUTB",
          "args": [
            "sd",
            "temp"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLOCK_PULSE",
          "args": [
            "sd",
            "sd->sd_RDY"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEEPROM_OUTB",
          "args": [
            "sd",
            "temp ^ sd->sd_CK"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLOCK_PULSE",
          "args": [
            "sd",
            "sd->sd_RDY"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEEPROM_OUTB",
          "args": [
            "sd",
            "temp"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLOCK_PULSE",
          "args": [
            "sd",
            "sd->sd_RDY"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEEPROM_OUTB",
          "args": [
            "sd",
            "temp ^ sd->sd_CK"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLOCK_PULSE",
          "args": [
            "sd",
            "sd->sd_RDY"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEEPROM_OUTB",
          "args": [
            "sd",
            "temp"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLOCK_PULSE",
          "args": [
            "sd",
            "sd->sd_RDY"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEEPROM_OUTB",
          "args": [
            "sd",
            "temp ^ sd->sd_CK"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/aic7xxx/93cx6.h>\n#include <machine/bus.h>\n#include <machine/bus_pio.h>\n#include <machine/bus_memio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic struct seeprom_cmd {\n  \tunsigned char len;\n \tunsigned char bits[3];\n} seeprom_read = {3, {1, 1, 0}};\n\nint\nread_seeprom(sd, buf, start_addr, count)\n\tstruct seeprom_descriptor *sd;\n\tu_int16_t *buf;\n\tbus_size_t start_addr;\n\tbus_size_t count;\n{\n\tint i = 0;\n\tu_int k = 0;\n\tu_int16_t v;\n\tu_int8_t temp;\n\n\t/*\n\t * Read the requested registers of the seeprom.  The loop\n\t * will range from 0 to count-1.\n\t */\n\tfor (k = start_addr; k < count + start_addr; k++) {\n\t\t/* Send chip select for one clock cycle. */\n\t\ttemp = sd->sd_MS ^ sd->sd_CS;\n\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\n\t\t/*\n\t\t * Now we're ready to send the read command followed by the\n\t\t * address of the 16-bit register we want to read.\n\t\t */\n\t\tfor (i = 0; i < seeprom_read.len; i++) {\n\t\t\tif (seeprom_read.bits[i] != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t\tSEEPROM_OUTB(sd, temp);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tif (seeprom_read.bits[i] != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t}\n\t\t/* Send the 6 or 8 bit address (MSB first, LSB last). */\n\t\tfor (i = (sd->sd_chip - 1); i >= 0; i--) {\n\t\t\tif ((k & (1 << i)) != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t\tSEEPROM_OUTB(sd, temp);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tif ((k & (1 << i)) != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t}\n\n\t\t/*\n\t\t * Now read the 16 bit register.  An initial 0 precedes the\n\t\t * register contents which begins with bit 15 (MSB) and ends\n\t\t * with bit 0 (LSB).  The initial 0 will be shifted off the\n\t\t * top of our word as we let the loop run from 0 to 16.\n\t\t */\n\t\tv = 0;\n\t\tfor (i = 16; i >= 0; i--) {\n\t\t\tSEEPROM_OUTB(sd, temp);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tv <<= 1;\n\t\t\tif (SEEPROM_DATA_INB(sd) & sd->sd_DI)\n\t\t\t\tv |= 1;\n\t\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t}\n\n\t\tbuf[k - start_addr] = v;\n\n\t\t/* Reset the chip select for the next command cycle. */\n\t\ttemp = sd->sd_MS;\n\t\tSEEPROM_OUTB(sd, temp);\n\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\tSEEPROM_OUTB(sd, temp);\n\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t}\n#ifdef AHC_DUMP_EEPROM\n\tprintf(\"\\nSerial EEPROM:\\n\\t\");\n\tfor (k = 0; k < count; k = k + 1) {\n\t\tif (((k % 8) == 0) && (k != 0)) {\n\t\t\tprintf (\"\\n\\t\");\n\t\t}\n\t\tprintf (\" 0x%x\", buf[k]);\n\t}\n\tprintf (\"\\n\");\n#endif\n\treturn (1);\n}"
  }
]