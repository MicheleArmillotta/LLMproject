[
  {
    "function_name": "ti_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "2440-2450",
    "snippet": "void ti_shutdown(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct ti_softc\t\t*sc;\n\n\tsc = xsc;\n\n\tti_chipinit(sc);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_shutdown",
      "int ti_chipinit",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ti_chipinit",
          "args": [
            "sc"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "ti_chipinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "1169-1306",
          "snippet": "int ti_chipinit(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tu_int32_t\t\tcacheline;\n\tu_int32_t\t\tpci_writemax = 0;\n\n\t/* Initialize link to down state. */\n\tsc->ti_linkstat = TI_EV_CODE_LINK_DOWN;\n\n\t/* Set endianness before we access any non-PCI registers. */\n#if BYTE_ORDER == BIG_ENDIAN\n\tCSR_WRITE_4(sc, TI_MISC_HOST_CTL,\n\t    TI_MHC_BIGENDIAN_INIT | (TI_MHC_BIGENDIAN_INIT << 24));\n#else\n\tCSR_WRITE_4(sc, TI_MISC_HOST_CTL,\n\t    TI_MHC_LITTLEENDIAN_INIT | (TI_MHC_LITTLEENDIAN_INIT << 24));\n#endif\n\n\t/* Check the ROM failed bit to see if self-tests passed. */\n\tif (CSR_READ_4(sc, TI_CPU_STATE) & TI_CPUSTATE_ROMFAIL) {\n\t\tprintf(\"%s: board self-diagnostics failed!\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\t\treturn(ENODEV);\n\t}\n\n\t/* Halt the CPU. */\n\tTI_SETBIT(sc, TI_CPU_STATE, TI_CPUSTATE_HALT);\n\n\t/* Figure out the hardware revision. */\n\tswitch(CSR_READ_4(sc, TI_MISC_HOST_CTL) & TI_MHC_CHIP_REV_MASK) {\n\tcase TI_REV_TIGON_I:\n\t\tsc->ti_hwrev = TI_HWREV_TIGON;\n\t\tbreak;\n\tcase TI_REV_TIGON_II:\n\t\tsc->ti_hwrev = TI_HWREV_TIGON_II;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unsupported chip revision\\n\", sc->sc_dv.dv_xname);\n\t\treturn(ENODEV);\n\t}\n\n\t/* Do special setup for Tigon 2. */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II) {\n\t\tTI_SETBIT(sc, TI_CPU_CTL_B, TI_CPUSTATE_HALT);\n\t\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_SRAM_BANK_256K);\n\t\tTI_SETBIT(sc, TI_MISC_CONF, TI_MCR_SRAM_SYNCHRONOUS);\n\t}\n\n\t/* Set up the PCI state register. */\n\tCSR_WRITE_4(sc, TI_PCI_STATE, TI_PCI_READ_CMD|TI_PCI_WRITE_CMD);\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II) {\n\t\tTI_SETBIT(sc, TI_PCI_STATE, TI_PCISTATE_USE_MEM_RD_MULT);\n\t}\n\n\t/* Clear the read/write max DMA parameters. */\n\tTI_CLRBIT(sc, TI_PCI_STATE, (TI_PCISTATE_WRITE_MAXDMA|\n\t    TI_PCISTATE_READ_MAXDMA));\n\n\t/* Get cache line size. */\n\tcacheline = CSR_READ_4(sc, TI_PCI_BIST) & 0xFF;\n\n\t/*\n\t * If the system has set enabled the PCI memory write\n\t * and invalidate command in the command register, set\n\t * the write max parameter accordingly. This is necessary\n\t * to use MWI with the Tigon 2.\n\t */\n\tif (CSR_READ_4(sc, TI_PCI_CMDSTAT) & PCIM_CMD_MWIEN) {\n\t\tswitch(cacheline) {\n\t\tcase 1:\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\tcase 32:\n\t\tcase 64:\n\t\t\tbreak;\n\t\tdefault:\n\t\t/* Disable PCI memory write and invalidate. */\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: cache line size %d not \"\n\t\t\t\t    \"supported; disabling PCI MWI\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname, cacheline);\n\t\t\tCSR_WRITE_4(sc, TI_PCI_CMDSTAT, CSR_READ_4(sc,\n\t\t\t    TI_PCI_CMDSTAT) & ~PCIM_CMD_MWIEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef __brokenalpha__\n\t/*\n\t * From the Alteon sample driver:\n\t * Must insure that we do not cross an 8K (bytes) boundary\n\t * for DMA reads.  Our highest limit is 1K bytes.  This is a \n\t * restriction on some ALPHA platforms with early revision \n\t * 21174 PCI chipsets, such as the AlphaPC 164lx \n\t */\n\tTI_SETBIT(sc, TI_PCI_STATE, pci_writemax|TI_PCI_READMAX_1024);\n#else\n\tTI_SETBIT(sc, TI_PCI_STATE, pci_writemax);\n#endif\n\n\t/* This sets the min dma param all the way up (0xff). */\n\tTI_SETBIT(sc, TI_PCI_STATE, TI_PCISTATE_MINDMA);\n\n\t/* Configure DMA variables. */\n#if BYTE_ORDER == BIG_ENDIAN\n\tCSR_WRITE_4(sc, TI_GCR_OPMODE, TI_OPMODE_BYTESWAP_BD |\n\t    TI_OPMODE_BYTESWAP_DATA | TI_OPMODE_WORDSWAP_BD |\n\t    TI_OPMODE_WARN_ENB | TI_OPMODE_FATAL_ENB |\n\t    TI_OPMODE_DONT_FRAG_JUMBO);\n#else\n\tCSR_WRITE_4(sc, TI_GCR_OPMODE, TI_OPMODE_BYTESWAP_DATA|\n\t    TI_OPMODE_WORDSWAP_BD|TI_OPMODE_DONT_FRAG_JUMBO|\n\t    TI_OPMODE_WARN_ENB|TI_OPMODE_FATAL_ENB);\n#endif\n\n\t/*\n\t * Only allow 1 DMA channel to be active at a time.\n\t * I don't think this is a good idea, but without it\n\t * the firmware racks up lots of nicDmaReadRingFull\n\t * errors.\n\t */\n#ifndef TI_CSUM_OFFLOAD\n\tTI_SETBIT(sc, TI_GCR_OPMODE, TI_OPMODE_1_DMA_ACTIVE);\n#endif\n\n\t/* Recommended settings from Tigon manual. */\n\tCSR_WRITE_4(sc, TI_GCR_DMA_WRITECFG, TI_DMA_STATE_THRESH_8W);\n\tCSR_WRITE_4(sc, TI_GCR_DMA_READCFG, TI_DMA_STATE_THRESH_8W);\n\n\tif (ti_64bitslot_war(sc)) {\n\t\tprintf(\"%s: bios thinks we're in a 64 bit slot, \"\n\t\t    \"but we aren't\", sc->sc_dv.dv_xname);\n\t\treturn(EINVAL);\n\t}\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define bootverbose\t1"
          ],
          "globals_used": [
            "int ti_64bitslot_war",
            "int ti_chipinit",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define bootverbose\t1\n\nint ti_64bitslot_war;\nint ti_chipinit;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_chipinit(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tu_int32_t\t\tcacheline;\n\tu_int32_t\t\tpci_writemax = 0;\n\n\t/* Initialize link to down state. */\n\tsc->ti_linkstat = TI_EV_CODE_LINK_DOWN;\n\n\t/* Set endianness before we access any non-PCI registers. */\n#if BYTE_ORDER == BIG_ENDIAN\n\tCSR_WRITE_4(sc, TI_MISC_HOST_CTL,\n\t    TI_MHC_BIGENDIAN_INIT | (TI_MHC_BIGENDIAN_INIT << 24));\n#else\n\tCSR_WRITE_4(sc, TI_MISC_HOST_CTL,\n\t    TI_MHC_LITTLEENDIAN_INIT | (TI_MHC_LITTLEENDIAN_INIT << 24));\n#endif\n\n\t/* Check the ROM failed bit to see if self-tests passed. */\n\tif (CSR_READ_4(sc, TI_CPU_STATE) & TI_CPUSTATE_ROMFAIL) {\n\t\tprintf(\"%s: board self-diagnostics failed!\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\t\treturn(ENODEV);\n\t}\n\n\t/* Halt the CPU. */\n\tTI_SETBIT(sc, TI_CPU_STATE, TI_CPUSTATE_HALT);\n\n\t/* Figure out the hardware revision. */\n\tswitch(CSR_READ_4(sc, TI_MISC_HOST_CTL) & TI_MHC_CHIP_REV_MASK) {\n\tcase TI_REV_TIGON_I:\n\t\tsc->ti_hwrev = TI_HWREV_TIGON;\n\t\tbreak;\n\tcase TI_REV_TIGON_II:\n\t\tsc->ti_hwrev = TI_HWREV_TIGON_II;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unsupported chip revision\\n\", sc->sc_dv.dv_xname);\n\t\treturn(ENODEV);\n\t}\n\n\t/* Do special setup for Tigon 2. */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II) {\n\t\tTI_SETBIT(sc, TI_CPU_CTL_B, TI_CPUSTATE_HALT);\n\t\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_SRAM_BANK_256K);\n\t\tTI_SETBIT(sc, TI_MISC_CONF, TI_MCR_SRAM_SYNCHRONOUS);\n\t}\n\n\t/* Set up the PCI state register. */\n\tCSR_WRITE_4(sc, TI_PCI_STATE, TI_PCI_READ_CMD|TI_PCI_WRITE_CMD);\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II) {\n\t\tTI_SETBIT(sc, TI_PCI_STATE, TI_PCISTATE_USE_MEM_RD_MULT);\n\t}\n\n\t/* Clear the read/write max DMA parameters. */\n\tTI_CLRBIT(sc, TI_PCI_STATE, (TI_PCISTATE_WRITE_MAXDMA|\n\t    TI_PCISTATE_READ_MAXDMA));\n\n\t/* Get cache line size. */\n\tcacheline = CSR_READ_4(sc, TI_PCI_BIST) & 0xFF;\n\n\t/*\n\t * If the system has set enabled the PCI memory write\n\t * and invalidate command in the command register, set\n\t * the write max parameter accordingly. This is necessary\n\t * to use MWI with the Tigon 2.\n\t */\n\tif (CSR_READ_4(sc, TI_PCI_CMDSTAT) & PCIM_CMD_MWIEN) {\n\t\tswitch(cacheline) {\n\t\tcase 1:\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\tcase 32:\n\t\tcase 64:\n\t\t\tbreak;\n\t\tdefault:\n\t\t/* Disable PCI memory write and invalidate. */\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: cache line size %d not \"\n\t\t\t\t    \"supported; disabling PCI MWI\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname, cacheline);\n\t\t\tCSR_WRITE_4(sc, TI_PCI_CMDSTAT, CSR_READ_4(sc,\n\t\t\t    TI_PCI_CMDSTAT) & ~PCIM_CMD_MWIEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef __brokenalpha__\n\t/*\n\t * From the Alteon sample driver:\n\t * Must insure that we do not cross an 8K (bytes) boundary\n\t * for DMA reads.  Our highest limit is 1K bytes.  This is a \n\t * restriction on some ALPHA platforms with early revision \n\t * 21174 PCI chipsets, such as the AlphaPC 164lx \n\t */\n\tTI_SETBIT(sc, TI_PCI_STATE, pci_writemax|TI_PCI_READMAX_1024);\n#else\n\tTI_SETBIT(sc, TI_PCI_STATE, pci_writemax);\n#endif\n\n\t/* This sets the min dma param all the way up (0xff). */\n\tTI_SETBIT(sc, TI_PCI_STATE, TI_PCISTATE_MINDMA);\n\n\t/* Configure DMA variables. */\n#if BYTE_ORDER == BIG_ENDIAN\n\tCSR_WRITE_4(sc, TI_GCR_OPMODE, TI_OPMODE_BYTESWAP_BD |\n\t    TI_OPMODE_BYTESWAP_DATA | TI_OPMODE_WORDSWAP_BD |\n\t    TI_OPMODE_WARN_ENB | TI_OPMODE_FATAL_ENB |\n\t    TI_OPMODE_DONT_FRAG_JUMBO);\n#else\n\tCSR_WRITE_4(sc, TI_GCR_OPMODE, TI_OPMODE_BYTESWAP_DATA|\n\t    TI_OPMODE_WORDSWAP_BD|TI_OPMODE_DONT_FRAG_JUMBO|\n\t    TI_OPMODE_WARN_ENB|TI_OPMODE_FATAL_ENB);\n#endif\n\n\t/*\n\t * Only allow 1 DMA channel to be active at a time.\n\t * I don't think this is a good idea, but without it\n\t * the firmware racks up lots of nicDmaReadRingFull\n\t * errors.\n\t */\n#ifndef TI_CSUM_OFFLOAD\n\tTI_SETBIT(sc, TI_GCR_OPMODE, TI_OPMODE_1_DMA_ACTIVE);\n#endif\n\n\t/* Recommended settings from Tigon manual. */\n\tCSR_WRITE_4(sc, TI_GCR_DMA_WRITECFG, TI_DMA_STATE_THRESH_8W);\n\tCSR_WRITE_4(sc, TI_GCR_DMA_READCFG, TI_DMA_STATE_THRESH_8W);\n\n\tif (ti_64bitslot_war(sc)) {\n\t\tprintf(\"%s: bios thinks we're in a 64 bit slot, \"\n\t\t    \"but we aren't\", sc->sc_dv.dv_xname);\n\t\treturn(EINVAL);\n\t}\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_shutdown;\nint ti_chipinit;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_shutdown(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct ti_softc\t\t*sc;\n\n\tsc = xsc;\n\n\tti_chipinit(sc);\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "2394-2434",
    "snippet": "void ti_stop(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct ti_cmd_desc\tcmd;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Disable host interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);\n\t/*\n\t * Tell firmware we're shutting down.\n\t */\n\tTI_DO_CMD(TI_CMD_HOST_STATE, TI_CMD_CODE_STACK_DOWN, 0);\n\n\t/* Halt and reinitialize. */\n\tti_chipinit(sc);\n\tti_mem(sc, 0x2000, 0x100000 - 0x2000, NULL);\n\tti_chipinit(sc);\n\n\t/* Free the RX lists. */\n\tti_free_rx_ring_std(sc);\n\n\t/* Free jumbo RX list. */\n\tti_free_rx_ring_jumbo(sc);\n\n\t/* Free mini RX list. */\n\tti_free_rx_ring_mini(sc);\n\n\t/* Free TX buffers. */\n\tti_free_tx_ring(sc);\n\n\tsc->ti_ev_prodidx.ti_idx = 0;\n\tsc->ti_return_prodidx.ti_idx = 0;\n\tsc->ti_tx_considx.ti_idx = 0;\n\tsc->ti_tx_saved_considx = TI_TXCONS_UNSET;\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_stop",
      "void ti_mem",
      "void ti_free_rx_ring_std",
      "void ti_free_rx_ring_jumbo",
      "void ti_free_rx_ring_mini",
      "void ti_free_tx_ring",
      "int ti_chipinit",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ti_free_tx_ring",
          "args": [
            "sc"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "ti_free_tx_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "981-999",
          "snippet": "void ti_free_tx_ring(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tif (sc->ti_rdata->ti_tx_ring == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < TI_TX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_tx_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_tx_chain[i]);\n\t\t\tsc->ti_cdata.ti_tx_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_tx_ring[i],\n\t\t    sizeof(struct ti_tx_desc));\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_free_tx_ring",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_free_tx_ring;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_free_tx_ring(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tif (sc->ti_rdata->ti_tx_ring == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < TI_TX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_tx_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_tx_chain[i]);\n\t\t\tsc->ti_cdata.ti_tx_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_tx_ring[i],\n\t\t    sizeof(struct ti_tx_desc));\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_free_rx_ring_mini",
          "args": [
            "sc"
          ],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "ti_free_rx_ring_mini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "964-979",
          "snippet": "void ti_free_rx_ring_mini(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_MINI_RX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_rx_mini_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_rx_mini_chain[i]);\n\t\t\tsc->ti_cdata.ti_rx_mini_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_rx_mini_ring[i],\n\t\t    sizeof(struct ti_rx_desc));\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_free_rx_ring_mini",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_free_rx_ring_mini;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_free_rx_ring_mini(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_MINI_RX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_rx_mini_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_rx_mini_chain[i]);\n\t\t\tsc->ti_cdata.ti_rx_mini_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_rx_mini_ring[i],\n\t\t    sizeof(struct ti_rx_desc));\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_free_rx_ring_jumbo",
          "args": [
            "sc"
          ],
          "line": 2418
        },
        "resolved": true,
        "details": {
          "function_name": "ti_free_rx_ring_jumbo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "931-946",
          "snippet": "void ti_free_rx_ring_jumbo(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_JUMBO_RX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_rx_jumbo_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_rx_jumbo_chain[i]);\n\t\t\tsc->ti_cdata.ti_rx_jumbo_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_rx_jumbo_ring[i],\n\t\t    sizeof(struct ti_rx_desc));\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_free_rx_ring_jumbo",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_free_rx_ring_jumbo;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_free_rx_ring_jumbo(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_JUMBO_RX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_rx_jumbo_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_rx_jumbo_chain[i]);\n\t\t\tsc->ti_cdata.ti_rx_jumbo_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_rx_jumbo_ring[i],\n\t\t    sizeof(struct ti_rx_desc));\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_free_rx_ring_std",
          "args": [
            "sc"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "ti_free_rx_ring_std",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "897-912",
          "snippet": "void ti_free_rx_ring_std(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_STD_RX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_rx_std_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_rx_std_chain[i]);\n\t\t\tsc->ti_cdata.ti_rx_std_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_rx_std_ring[i],\n\t\t    sizeof(struct ti_rx_desc));\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_free_rx_ring_std",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_free_rx_ring_std;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_free_rx_ring_std(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_STD_RX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_rx_std_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_rx_std_chain[i]);\n\t\t\tsc->ti_cdata.ti_rx_std_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_rx_std_ring[i],\n\t\t    sizeof(struct ti_rx_desc));\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_chipinit",
          "args": [
            "sc"
          ],
          "line": 2412
        },
        "resolved": true,
        "details": {
          "function_name": "ti_chipinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "1169-1306",
          "snippet": "int ti_chipinit(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tu_int32_t\t\tcacheline;\n\tu_int32_t\t\tpci_writemax = 0;\n\n\t/* Initialize link to down state. */\n\tsc->ti_linkstat = TI_EV_CODE_LINK_DOWN;\n\n\t/* Set endianness before we access any non-PCI registers. */\n#if BYTE_ORDER == BIG_ENDIAN\n\tCSR_WRITE_4(sc, TI_MISC_HOST_CTL,\n\t    TI_MHC_BIGENDIAN_INIT | (TI_MHC_BIGENDIAN_INIT << 24));\n#else\n\tCSR_WRITE_4(sc, TI_MISC_HOST_CTL,\n\t    TI_MHC_LITTLEENDIAN_INIT | (TI_MHC_LITTLEENDIAN_INIT << 24));\n#endif\n\n\t/* Check the ROM failed bit to see if self-tests passed. */\n\tif (CSR_READ_4(sc, TI_CPU_STATE) & TI_CPUSTATE_ROMFAIL) {\n\t\tprintf(\"%s: board self-diagnostics failed!\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\t\treturn(ENODEV);\n\t}\n\n\t/* Halt the CPU. */\n\tTI_SETBIT(sc, TI_CPU_STATE, TI_CPUSTATE_HALT);\n\n\t/* Figure out the hardware revision. */\n\tswitch(CSR_READ_4(sc, TI_MISC_HOST_CTL) & TI_MHC_CHIP_REV_MASK) {\n\tcase TI_REV_TIGON_I:\n\t\tsc->ti_hwrev = TI_HWREV_TIGON;\n\t\tbreak;\n\tcase TI_REV_TIGON_II:\n\t\tsc->ti_hwrev = TI_HWREV_TIGON_II;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unsupported chip revision\\n\", sc->sc_dv.dv_xname);\n\t\treturn(ENODEV);\n\t}\n\n\t/* Do special setup for Tigon 2. */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II) {\n\t\tTI_SETBIT(sc, TI_CPU_CTL_B, TI_CPUSTATE_HALT);\n\t\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_SRAM_BANK_256K);\n\t\tTI_SETBIT(sc, TI_MISC_CONF, TI_MCR_SRAM_SYNCHRONOUS);\n\t}\n\n\t/* Set up the PCI state register. */\n\tCSR_WRITE_4(sc, TI_PCI_STATE, TI_PCI_READ_CMD|TI_PCI_WRITE_CMD);\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II) {\n\t\tTI_SETBIT(sc, TI_PCI_STATE, TI_PCISTATE_USE_MEM_RD_MULT);\n\t}\n\n\t/* Clear the read/write max DMA parameters. */\n\tTI_CLRBIT(sc, TI_PCI_STATE, (TI_PCISTATE_WRITE_MAXDMA|\n\t    TI_PCISTATE_READ_MAXDMA));\n\n\t/* Get cache line size. */\n\tcacheline = CSR_READ_4(sc, TI_PCI_BIST) & 0xFF;\n\n\t/*\n\t * If the system has set enabled the PCI memory write\n\t * and invalidate command in the command register, set\n\t * the write max parameter accordingly. This is necessary\n\t * to use MWI with the Tigon 2.\n\t */\n\tif (CSR_READ_4(sc, TI_PCI_CMDSTAT) & PCIM_CMD_MWIEN) {\n\t\tswitch(cacheline) {\n\t\tcase 1:\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\tcase 32:\n\t\tcase 64:\n\t\t\tbreak;\n\t\tdefault:\n\t\t/* Disable PCI memory write and invalidate. */\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: cache line size %d not \"\n\t\t\t\t    \"supported; disabling PCI MWI\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname, cacheline);\n\t\t\tCSR_WRITE_4(sc, TI_PCI_CMDSTAT, CSR_READ_4(sc,\n\t\t\t    TI_PCI_CMDSTAT) & ~PCIM_CMD_MWIEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef __brokenalpha__\n\t/*\n\t * From the Alteon sample driver:\n\t * Must insure that we do not cross an 8K (bytes) boundary\n\t * for DMA reads.  Our highest limit is 1K bytes.  This is a \n\t * restriction on some ALPHA platforms with early revision \n\t * 21174 PCI chipsets, such as the AlphaPC 164lx \n\t */\n\tTI_SETBIT(sc, TI_PCI_STATE, pci_writemax|TI_PCI_READMAX_1024);\n#else\n\tTI_SETBIT(sc, TI_PCI_STATE, pci_writemax);\n#endif\n\n\t/* This sets the min dma param all the way up (0xff). */\n\tTI_SETBIT(sc, TI_PCI_STATE, TI_PCISTATE_MINDMA);\n\n\t/* Configure DMA variables. */\n#if BYTE_ORDER == BIG_ENDIAN\n\tCSR_WRITE_4(sc, TI_GCR_OPMODE, TI_OPMODE_BYTESWAP_BD |\n\t    TI_OPMODE_BYTESWAP_DATA | TI_OPMODE_WORDSWAP_BD |\n\t    TI_OPMODE_WARN_ENB | TI_OPMODE_FATAL_ENB |\n\t    TI_OPMODE_DONT_FRAG_JUMBO);\n#else\n\tCSR_WRITE_4(sc, TI_GCR_OPMODE, TI_OPMODE_BYTESWAP_DATA|\n\t    TI_OPMODE_WORDSWAP_BD|TI_OPMODE_DONT_FRAG_JUMBO|\n\t    TI_OPMODE_WARN_ENB|TI_OPMODE_FATAL_ENB);\n#endif\n\n\t/*\n\t * Only allow 1 DMA channel to be active at a time.\n\t * I don't think this is a good idea, but without it\n\t * the firmware racks up lots of nicDmaReadRingFull\n\t * errors.\n\t */\n#ifndef TI_CSUM_OFFLOAD\n\tTI_SETBIT(sc, TI_GCR_OPMODE, TI_OPMODE_1_DMA_ACTIVE);\n#endif\n\n\t/* Recommended settings from Tigon manual. */\n\tCSR_WRITE_4(sc, TI_GCR_DMA_WRITECFG, TI_DMA_STATE_THRESH_8W);\n\tCSR_WRITE_4(sc, TI_GCR_DMA_READCFG, TI_DMA_STATE_THRESH_8W);\n\n\tif (ti_64bitslot_war(sc)) {\n\t\tprintf(\"%s: bios thinks we're in a 64 bit slot, \"\n\t\t    \"but we aren't\", sc->sc_dv.dv_xname);\n\t\treturn(EINVAL);\n\t}\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define bootverbose\t1"
          ],
          "globals_used": [
            "int ti_64bitslot_war",
            "int ti_chipinit",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define bootverbose\t1\n\nint ti_64bitslot_war;\nint ti_chipinit;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_chipinit(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tu_int32_t\t\tcacheline;\n\tu_int32_t\t\tpci_writemax = 0;\n\n\t/* Initialize link to down state. */\n\tsc->ti_linkstat = TI_EV_CODE_LINK_DOWN;\n\n\t/* Set endianness before we access any non-PCI registers. */\n#if BYTE_ORDER == BIG_ENDIAN\n\tCSR_WRITE_4(sc, TI_MISC_HOST_CTL,\n\t    TI_MHC_BIGENDIAN_INIT | (TI_MHC_BIGENDIAN_INIT << 24));\n#else\n\tCSR_WRITE_4(sc, TI_MISC_HOST_CTL,\n\t    TI_MHC_LITTLEENDIAN_INIT | (TI_MHC_LITTLEENDIAN_INIT << 24));\n#endif\n\n\t/* Check the ROM failed bit to see if self-tests passed. */\n\tif (CSR_READ_4(sc, TI_CPU_STATE) & TI_CPUSTATE_ROMFAIL) {\n\t\tprintf(\"%s: board self-diagnostics failed!\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\t\treturn(ENODEV);\n\t}\n\n\t/* Halt the CPU. */\n\tTI_SETBIT(sc, TI_CPU_STATE, TI_CPUSTATE_HALT);\n\n\t/* Figure out the hardware revision. */\n\tswitch(CSR_READ_4(sc, TI_MISC_HOST_CTL) & TI_MHC_CHIP_REV_MASK) {\n\tcase TI_REV_TIGON_I:\n\t\tsc->ti_hwrev = TI_HWREV_TIGON;\n\t\tbreak;\n\tcase TI_REV_TIGON_II:\n\t\tsc->ti_hwrev = TI_HWREV_TIGON_II;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unsupported chip revision\\n\", sc->sc_dv.dv_xname);\n\t\treturn(ENODEV);\n\t}\n\n\t/* Do special setup for Tigon 2. */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II) {\n\t\tTI_SETBIT(sc, TI_CPU_CTL_B, TI_CPUSTATE_HALT);\n\t\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_SRAM_BANK_256K);\n\t\tTI_SETBIT(sc, TI_MISC_CONF, TI_MCR_SRAM_SYNCHRONOUS);\n\t}\n\n\t/* Set up the PCI state register. */\n\tCSR_WRITE_4(sc, TI_PCI_STATE, TI_PCI_READ_CMD|TI_PCI_WRITE_CMD);\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II) {\n\t\tTI_SETBIT(sc, TI_PCI_STATE, TI_PCISTATE_USE_MEM_RD_MULT);\n\t}\n\n\t/* Clear the read/write max DMA parameters. */\n\tTI_CLRBIT(sc, TI_PCI_STATE, (TI_PCISTATE_WRITE_MAXDMA|\n\t    TI_PCISTATE_READ_MAXDMA));\n\n\t/* Get cache line size. */\n\tcacheline = CSR_READ_4(sc, TI_PCI_BIST) & 0xFF;\n\n\t/*\n\t * If the system has set enabled the PCI memory write\n\t * and invalidate command in the command register, set\n\t * the write max parameter accordingly. This is necessary\n\t * to use MWI with the Tigon 2.\n\t */\n\tif (CSR_READ_4(sc, TI_PCI_CMDSTAT) & PCIM_CMD_MWIEN) {\n\t\tswitch(cacheline) {\n\t\tcase 1:\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\tcase 32:\n\t\tcase 64:\n\t\t\tbreak;\n\t\tdefault:\n\t\t/* Disable PCI memory write and invalidate. */\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: cache line size %d not \"\n\t\t\t\t    \"supported; disabling PCI MWI\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname, cacheline);\n\t\t\tCSR_WRITE_4(sc, TI_PCI_CMDSTAT, CSR_READ_4(sc,\n\t\t\t    TI_PCI_CMDSTAT) & ~PCIM_CMD_MWIEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef __brokenalpha__\n\t/*\n\t * From the Alteon sample driver:\n\t * Must insure that we do not cross an 8K (bytes) boundary\n\t * for DMA reads.  Our highest limit is 1K bytes.  This is a \n\t * restriction on some ALPHA platforms with early revision \n\t * 21174 PCI chipsets, such as the AlphaPC 164lx \n\t */\n\tTI_SETBIT(sc, TI_PCI_STATE, pci_writemax|TI_PCI_READMAX_1024);\n#else\n\tTI_SETBIT(sc, TI_PCI_STATE, pci_writemax);\n#endif\n\n\t/* This sets the min dma param all the way up (0xff). */\n\tTI_SETBIT(sc, TI_PCI_STATE, TI_PCISTATE_MINDMA);\n\n\t/* Configure DMA variables. */\n#if BYTE_ORDER == BIG_ENDIAN\n\tCSR_WRITE_4(sc, TI_GCR_OPMODE, TI_OPMODE_BYTESWAP_BD |\n\t    TI_OPMODE_BYTESWAP_DATA | TI_OPMODE_WORDSWAP_BD |\n\t    TI_OPMODE_WARN_ENB | TI_OPMODE_FATAL_ENB |\n\t    TI_OPMODE_DONT_FRAG_JUMBO);\n#else\n\tCSR_WRITE_4(sc, TI_GCR_OPMODE, TI_OPMODE_BYTESWAP_DATA|\n\t    TI_OPMODE_WORDSWAP_BD|TI_OPMODE_DONT_FRAG_JUMBO|\n\t    TI_OPMODE_WARN_ENB|TI_OPMODE_FATAL_ENB);\n#endif\n\n\t/*\n\t * Only allow 1 DMA channel to be active at a time.\n\t * I don't think this is a good idea, but without it\n\t * the firmware racks up lots of nicDmaReadRingFull\n\t * errors.\n\t */\n#ifndef TI_CSUM_OFFLOAD\n\tTI_SETBIT(sc, TI_GCR_OPMODE, TI_OPMODE_1_DMA_ACTIVE);\n#endif\n\n\t/* Recommended settings from Tigon manual. */\n\tCSR_WRITE_4(sc, TI_GCR_DMA_WRITECFG, TI_DMA_STATE_THRESH_8W);\n\tCSR_WRITE_4(sc, TI_GCR_DMA_READCFG, TI_DMA_STATE_THRESH_8W);\n\n\tif (ti_64bitslot_war(sc)) {\n\t\tprintf(\"%s: bios thinks we're in a 64 bit slot, \"\n\t\t    \"but we aren't\", sc->sc_dv.dv_xname);\n\t\treturn(EINVAL);\n\t}\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_mem",
          "args": [
            "sc",
            "0x2000",
            "0x100000 - 0x2000",
            "NULL"
          ],
          "line": 2411
        },
        "resolved": true,
        "details": {
          "function_name": "ti_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "333-365",
          "snippet": "void ti_mem(sc, addr, len, buf)\n\tstruct ti_softc\t\t*sc;\n\tu_int32_t\t\taddr, len;\n\tcaddr_t\t\t\tbuf;\n{\n\tint\t\t\tsegptr, segsize, cnt;\n\tcaddr_t\t\t\tti_winbase, ptr;\n\n\tsegptr = addr;\n\tcnt = len;\n\tti_winbase = (caddr_t)(sc->ti_bhandle + TI_WINDOW);\n\tptr = buf;\n\n\twhile(cnt) {\n\t\tif (cnt < TI_WINLEN)\n\t\t\tsegsize = cnt;\n\t\telse\n\t\t\tsegsize = TI_WINLEN - (segptr % TI_WINLEN);\n\t\tCSR_WRITE_4(sc, TI_WINBASE, (segptr & ~(TI_WINLEN - 1)));\n\t\tif (buf == NULL)\n\t\t\tbzero((char *)ti_winbase + (segptr &\n\t\t\t    (TI_WINLEN - 1)), segsize);\n\t\telse {\n\t\t\tbcopy((char *)ptr, (char *)ti_winbase +\n\t\t\t    (segptr & (TI_WINLEN - 1)), segsize);\n\t\t\tptr += segsize;\n\t\t}\n\t\tsegptr += segsize;\n\t\tcnt -= segsize;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_mem",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_mem;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_mem(sc, addr, len, buf)\n\tstruct ti_softc\t\t*sc;\n\tu_int32_t\t\taddr, len;\n\tcaddr_t\t\t\tbuf;\n{\n\tint\t\t\tsegptr, segsize, cnt;\n\tcaddr_t\t\t\tti_winbase, ptr;\n\n\tsegptr = addr;\n\tcnt = len;\n\tti_winbase = (caddr_t)(sc->ti_bhandle + TI_WINDOW);\n\tptr = buf;\n\n\twhile(cnt) {\n\t\tif (cnt < TI_WINLEN)\n\t\t\tsegsize = cnt;\n\t\telse\n\t\t\tsegsize = TI_WINLEN - (segptr % TI_WINLEN);\n\t\tCSR_WRITE_4(sc, TI_WINBASE, (segptr & ~(TI_WINLEN - 1)));\n\t\tif (buf == NULL)\n\t\t\tbzero((char *)ti_winbase + (segptr &\n\t\t\t    (TI_WINLEN - 1)), segsize);\n\t\telse {\n\t\t\tbcopy((char *)ptr, (char *)ti_winbase +\n\t\t\t    (segptr & (TI_WINLEN - 1)), segsize);\n\t\t\tptr += segsize;\n\t\t}\n\t\tsegptr += segsize;\n\t\tcnt -= segsize;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TI_DO_CMD",
          "args": [
            "TI_CMD_HOST_STATE",
            "TI_CMD_CODE_STACK_DOWN",
            "0"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_MB_HOSTINTR",
            "1"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_stop;\nvoid ti_mem;\nvoid ti_free_rx_ring_std;\nvoid ti_free_rx_ring_jumbo;\nvoid ti_free_rx_ring_mini;\nvoid ti_free_tx_ring;\nint ti_chipinit;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_stop(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct ti_cmd_desc\tcmd;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Disable host interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);\n\t/*\n\t * Tell firmware we're shutting down.\n\t */\n\tTI_DO_CMD(TI_CMD_HOST_STATE, TI_CMD_CODE_STACK_DOWN, 0);\n\n\t/* Halt and reinitialize. */\n\tti_chipinit(sc);\n\tti_mem(sc, 0x2000, 0x100000 - 0x2000, NULL);\n\tti_chipinit(sc);\n\n\t/* Free the RX lists. */\n\tti_free_rx_ring_std(sc);\n\n\t/* Free jumbo RX list. */\n\tti_free_rx_ring_jumbo(sc);\n\n\t/* Free mini RX list. */\n\tti_free_rx_ring_mini(sc);\n\n\t/* Free TX buffers. */\n\tti_free_tx_ring(sc);\n\n\tsc->ti_ev_prodidx.ti_idx = 0;\n\tsc->ti_return_prodidx.ti_idx = 0;\n\tsc->ti_tx_considx.ti_idx = 0;\n\tsc->ti_tx_saved_considx = TI_TXCONS_UNSET;\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "2374-2388",
    "snippet": "void ti_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct ti_softc\t\t*sc;\n\n\tsc = ifp->if_softc;\n\n\tprintf(\"%s: watchdog timeout -- resetting\\n\", sc->sc_dv.dv_xname);\n\tti_stop(sc);\n\tti_init(sc);\n\n\tifp->if_oerrors++;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_init",
      "void ti_stop",
      "void ti_watchdog",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ti_init",
          "args": [
            "sc"
          ],
          "line": 2383
        },
        "resolved": true,
        "details": {
          "function_name": "ti_init2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "2112-2195",
          "snippet": "void ti_init2(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ti_cmd_desc\tcmd;\n\tstruct ifnet\t\t*ifp;\n\tu_int16_t\t\t*m;\n\tstruct ifmedia\t\t*ifm;\n\tint\t\t\ttmp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Specify MTU and interface index. */\n\tCSR_WRITE_4(sc, TI_GCR_IFINDEX, sc->sc_dv.dv_unit);\n\tCSR_WRITE_4(sc, TI_GCR_IFMTU, ifp->if_mtu +\n\t    ETHER_HDR_LEN + ETHER_CRC_LEN);\n\tTI_DO_CMD(TI_CMD_UPDATE_GENCOM, 0, 0);\n\n\t/* Load our MAC address. */\n\tm = (u_int16_t *)&sc->arpcom.ac_enaddr[0];\n\tCSR_WRITE_4(sc, TI_GCR_PAR0, htons(m[0]));\n\tCSR_WRITE_4(sc, TI_GCR_PAR1, (htons(m[1]) << 16) | htons(m[2]));\n\tTI_DO_CMD(TI_CMD_SET_MAC_ADDR, 0, 0);\n\n\t/* Enable or disable promiscuous mode as needed. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tTI_DO_CMD(TI_CMD_SET_PROMISC_MODE, TI_CMD_CODE_PROMISC_ENB, 0);\n\t} else {\n\t\tTI_DO_CMD(TI_CMD_SET_PROMISC_MODE, TI_CMD_CODE_PROMISC_DIS, 0);\n\t}\n\n\t/* Program multicast filter. */\n\tti_setmulti(sc);\n\n\t/*\n\t * If this is a Tigon 1, we should tell the\n\t * firmware to use software packet filtering.\n\t */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON) {\n\t\tTI_DO_CMD(TI_CMD_FDR_FILTERING, TI_CMD_CODE_FILT_ENB, 0);\n\t}\n\n\t/* Init RX ring. */\n\tti_init_rx_ring_std(sc);\n\n\t/* Init jumbo RX ring. */\n\tif (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))\n\t\tti_init_rx_ring_jumbo(sc);\n\n\t/*\n\t * If this is a Tigon 2, we can also configure the\n\t * mini ring.\n\t */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II)\n\t\tti_init_rx_ring_mini(sc);\n\n\tCSR_WRITE_4(sc, TI_GCR_RXRETURNCONS_IDX, 0);\n\tsc->ti_rx_saved_considx = 0;\n\n\t/* Init TX ring. */\n\tti_init_tx_ring(sc);\n\n\t/* Tell firmware we're alive. */\n\tTI_DO_CMD(TI_CMD_HOST_STATE, TI_CMD_CODE_STACK_UP, 0);\n\n\t/* Enable host interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 0);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Make sure to set media properly. We have to do this\n\t * here since we have to issue commands in order to set\n\t * the link negotiation and we can't issue commands until\n\t * the firmware is running.\n\t */\n\tifm = &sc->ifmedia;\n\ttmp = ifm->ifm_media;\n\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\tti_ifmedia_upd(ifp);\n\tifm->ifm_media = tmp;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_init2",
            "int ti_ifmedia_upd",
            "void ti_setmulti",
            "int ti_init_rx_ring_std",
            "int ti_init_rx_ring_jumbo",
            "int ti_init_rx_ring_mini",
            "int ti_init_tx_ring",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_init2;\nint ti_ifmedia_upd;\nvoid ti_setmulti;\nint ti_init_rx_ring_std;\nint ti_init_rx_ring_jumbo;\nint ti_init_rx_ring_mini;\nint ti_init_tx_ring;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_init2(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ti_cmd_desc\tcmd;\n\tstruct ifnet\t\t*ifp;\n\tu_int16_t\t\t*m;\n\tstruct ifmedia\t\t*ifm;\n\tint\t\t\ttmp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Specify MTU and interface index. */\n\tCSR_WRITE_4(sc, TI_GCR_IFINDEX, sc->sc_dv.dv_unit);\n\tCSR_WRITE_4(sc, TI_GCR_IFMTU, ifp->if_mtu +\n\t    ETHER_HDR_LEN + ETHER_CRC_LEN);\n\tTI_DO_CMD(TI_CMD_UPDATE_GENCOM, 0, 0);\n\n\t/* Load our MAC address. */\n\tm = (u_int16_t *)&sc->arpcom.ac_enaddr[0];\n\tCSR_WRITE_4(sc, TI_GCR_PAR0, htons(m[0]));\n\tCSR_WRITE_4(sc, TI_GCR_PAR1, (htons(m[1]) << 16) | htons(m[2]));\n\tTI_DO_CMD(TI_CMD_SET_MAC_ADDR, 0, 0);\n\n\t/* Enable or disable promiscuous mode as needed. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tTI_DO_CMD(TI_CMD_SET_PROMISC_MODE, TI_CMD_CODE_PROMISC_ENB, 0);\n\t} else {\n\t\tTI_DO_CMD(TI_CMD_SET_PROMISC_MODE, TI_CMD_CODE_PROMISC_DIS, 0);\n\t}\n\n\t/* Program multicast filter. */\n\tti_setmulti(sc);\n\n\t/*\n\t * If this is a Tigon 1, we should tell the\n\t * firmware to use software packet filtering.\n\t */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON) {\n\t\tTI_DO_CMD(TI_CMD_FDR_FILTERING, TI_CMD_CODE_FILT_ENB, 0);\n\t}\n\n\t/* Init RX ring. */\n\tti_init_rx_ring_std(sc);\n\n\t/* Init jumbo RX ring. */\n\tif (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))\n\t\tti_init_rx_ring_jumbo(sc);\n\n\t/*\n\t * If this is a Tigon 2, we can also configure the\n\t * mini ring.\n\t */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II)\n\t\tti_init_rx_ring_mini(sc);\n\n\tCSR_WRITE_4(sc, TI_GCR_RXRETURNCONS_IDX, 0);\n\tsc->ti_rx_saved_considx = 0;\n\n\t/* Init TX ring. */\n\tti_init_tx_ring(sc);\n\n\t/* Tell firmware we're alive. */\n\tTI_DO_CMD(TI_CMD_HOST_STATE, TI_CMD_CODE_STACK_UP, 0);\n\n\t/* Enable host interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 0);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Make sure to set media properly. We have to do this\n\t * here since we have to issue commands in order to set\n\t * the link negotiation and we can't issue commands until\n\t * the firmware is running.\n\t */\n\tifm = &sc->ifmedia;\n\ttmp = ifm->ifm_media;\n\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\tti_ifmedia_upd(ifp);\n\tifm->ifm_media = tmp;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_stop",
          "args": [
            "sc"
          ],
          "line": 2382
        },
        "resolved": true,
        "details": {
          "function_name": "ti_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "2394-2434",
          "snippet": "void ti_stop(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct ti_cmd_desc\tcmd;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Disable host interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);\n\t/*\n\t * Tell firmware we're shutting down.\n\t */\n\tTI_DO_CMD(TI_CMD_HOST_STATE, TI_CMD_CODE_STACK_DOWN, 0);\n\n\t/* Halt and reinitialize. */\n\tti_chipinit(sc);\n\tti_mem(sc, 0x2000, 0x100000 - 0x2000, NULL);\n\tti_chipinit(sc);\n\n\t/* Free the RX lists. */\n\tti_free_rx_ring_std(sc);\n\n\t/* Free jumbo RX list. */\n\tti_free_rx_ring_jumbo(sc);\n\n\t/* Free mini RX list. */\n\tti_free_rx_ring_mini(sc);\n\n\t/* Free TX buffers. */\n\tti_free_tx_ring(sc);\n\n\tsc->ti_ev_prodidx.ti_idx = 0;\n\tsc->ti_return_prodidx.ti_idx = 0;\n\tsc->ti_tx_considx.ti_idx = 0;\n\tsc->ti_tx_saved_considx = TI_TXCONS_UNSET;\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_stop",
            "void ti_mem",
            "void ti_free_rx_ring_std",
            "void ti_free_rx_ring_jumbo",
            "void ti_free_rx_ring_mini",
            "void ti_free_tx_ring",
            "int ti_chipinit",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_stop;\nvoid ti_mem;\nvoid ti_free_rx_ring_std;\nvoid ti_free_rx_ring_jumbo;\nvoid ti_free_rx_ring_mini;\nvoid ti_free_tx_ring;\nint ti_chipinit;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_stop(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct ti_cmd_desc\tcmd;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Disable host interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);\n\t/*\n\t * Tell firmware we're shutting down.\n\t */\n\tTI_DO_CMD(TI_CMD_HOST_STATE, TI_CMD_CODE_STACK_DOWN, 0);\n\n\t/* Halt and reinitialize. */\n\tti_chipinit(sc);\n\tti_mem(sc, 0x2000, 0x100000 - 0x2000, NULL);\n\tti_chipinit(sc);\n\n\t/* Free the RX lists. */\n\tti_free_rx_ring_std(sc);\n\n\t/* Free jumbo RX list. */\n\tti_free_rx_ring_jumbo(sc);\n\n\t/* Free mini RX list. */\n\tti_free_rx_ring_mini(sc);\n\n\t/* Free TX buffers. */\n\tti_free_tx_ring(sc);\n\n\tsc->ti_ev_prodidx.ti_idx = 0;\n\tsc->ti_return_prodidx.ti_idx = 0;\n\tsc->ti_tx_considx.ti_idx = 0;\n\tsc->ti_tx_saved_considx = TI_TXCONS_UNSET;\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: watchdog timeout -- resetting\\n\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_init;\nvoid ti_stop;\nvoid ti_watchdog;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct ti_softc\t\t*sc;\n\n\tsc = ifp->if_softc;\n\n\tprintf(\"%s: watchdog timeout -- resetting\\n\", sc->sc_dv.dv_xname);\n\tti_stop(sc);\n\tti_init(sc);\n\n\tifp->if_oerrors++;\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "2290-2372",
    "snippet": "int ti_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tstruct ti_softc\t\t*sc = ifp->if_softc;\n\tstruct ifreq\t\t*ifr = (struct ifreq *)data;\n\tstruct ifaddr\t\t*ifa = (struct ifaddr *)data;\n\tint\t\t\ts, error = 0;\n\tstruct ti_cmd_desc\tcmd;\n\n\ts = splimp();\n\n\tif ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn (error);\n\t}\n\n\tswitch(command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tti_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif /* INET */\n\t\tdefault:\n\t\t\tti_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\t/*\n\t\t\t * If only the state of the PROMISC flag changed,\n\t\t\t * then just use the 'set promisc mode' command\n\t\t\t * instead of reinitializing the entire NIC. Doing\n\t\t\t * a full re-init means reloading the firmware and\n\t\t\t * waiting for it to start up, which may take a\n\t\t\t * second or two.\n\t\t\t */\n\t\t\tif (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    ifp->if_flags & IFF_PROMISC &&\n\t\t\t    !(sc->ti_if_flags & IFF_PROMISC)) {\n\t\t\t\tTI_DO_CMD(TI_CMD_SET_PROMISC_MODE,\n\t\t\t\t    TI_CMD_CODE_PROMISC_ENB, 0);\n\t\t\t} else if (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    sc->ti_if_flags & IFF_PROMISC) {\n\t\t\t\tTI_DO_CMD(TI_CMD_SET_PROMISC_MODE,\n\t\t\t\t    TI_CMD_CODE_PROMISC_DIS, 0);\n\t\t\t} else\n\t\t\t\tti_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING) {\n\t\t\t\tti_stop(sc);\n\t\t\t}\n\t\t}\n\t\tsc->ti_if_flags = ifp->if_flags;\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\tif (ifp->if_flags & IFF_RUNNING) {\n\t\t\tti_setmulti(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFMEDIA:\n\tcase SIOCGIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->ifmedia, command);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\t(void)splx(s);\n\n\treturn(error);\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ti_ioctl",
      "void ti_init",
      "void ti_stop",
      "void ti_setmulti",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&sc->ifmedia",
            "command"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ti_setmulti",
          "args": [
            "sc"
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "ti_setmulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "1087-1136",
          "snippet": "void ti_setmulti(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tstruct ti_cmd_desc\tcmd;\n\tstruct ti_mc_entry\t*mc;\n\tu_int32_t\t\tintrs;\n\tstruct ti_mc_entry *p;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tif (ifp->if_flags & IFF_ALLMULTI) {\n\t\tTI_DO_CMD(TI_CMD_SET_ALLMULTI, TI_CMD_CODE_ALLMULTI_ENB, 0);\n\t\treturn;\n\t} else {\n\t\tTI_DO_CMD(TI_CMD_SET_ALLMULTI, TI_CMD_CODE_ALLMULTI_DIS, 0);\n\t}\n\n\t/* Disable interrupts. */\n\tintrs = CSR_READ_4(sc, TI_MB_HOSTINTR);\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);\n\n\t/* First, zot all the existing filters. */\n\tp = LIST_FIRST(&sc->ti_mc_listhead);\n\twhile (p != NULL) {\n\t\tmc = p;\n\t\tti_del_mcast(sc, &mc->mc_addr);\n\t\tp = LIST_FIRST(&sc->ti_mc_listhead);\n\t\tLIST_REMOVE(mc, mc_entries);\n\t\tp = LIST_NEXT(p, mc_entries);\n\t\tfree(mc, M_DEVBUF);\n\t}\n\n\t/* Now program new ones. */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tmc = malloc(sizeof(struct ti_mc_entry), M_DEVBUF, M_NOWAIT);\n\t\tbcopy(enm->enm_addrlo, (char *)&mc->mc_addr, ETHER_ADDR_LEN);\n\t\tLIST_INSERT_HEAD(&sc->ti_mc_listhead, mc, mc_entries);\n\t\tti_add_mcast(sc, &mc->mc_addr);\n\t}\n\n\t/* Re-enable interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, intrs);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_add_mcast",
            "void ti_del_mcast",
            "void ti_setmulti",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_add_mcast;\nvoid ti_del_mcast;\nvoid ti_setmulti;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_setmulti(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tstruct ti_cmd_desc\tcmd;\n\tstruct ti_mc_entry\t*mc;\n\tu_int32_t\t\tintrs;\n\tstruct ti_mc_entry *p;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tif (ifp->if_flags & IFF_ALLMULTI) {\n\t\tTI_DO_CMD(TI_CMD_SET_ALLMULTI, TI_CMD_CODE_ALLMULTI_ENB, 0);\n\t\treturn;\n\t} else {\n\t\tTI_DO_CMD(TI_CMD_SET_ALLMULTI, TI_CMD_CODE_ALLMULTI_DIS, 0);\n\t}\n\n\t/* Disable interrupts. */\n\tintrs = CSR_READ_4(sc, TI_MB_HOSTINTR);\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);\n\n\t/* First, zot all the existing filters. */\n\tp = LIST_FIRST(&sc->ti_mc_listhead);\n\twhile (p != NULL) {\n\t\tmc = p;\n\t\tti_del_mcast(sc, &mc->mc_addr);\n\t\tp = LIST_FIRST(&sc->ti_mc_listhead);\n\t\tLIST_REMOVE(mc, mc_entries);\n\t\tp = LIST_NEXT(p, mc_entries);\n\t\tfree(mc, M_DEVBUF);\n\t}\n\n\t/* Now program new ones. */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tmc = malloc(sizeof(struct ti_mc_entry), M_DEVBUF, M_NOWAIT);\n\t\tbcopy(enm->enm_addrlo, (char *)&mc->mc_addr, ETHER_ADDR_LEN);\n\t\tLIST_INSERT_HEAD(&sc->ti_mc_listhead, mc, mc_entries);\n\t\tti_add_mcast(sc, &mc->mc_addr);\n\t}\n\n\t/* Re-enable interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, intrs);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_stop",
          "args": [
            "sc"
          ],
          "line": 2347
        },
        "resolved": true,
        "details": {
          "function_name": "ti_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "2394-2434",
          "snippet": "void ti_stop(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct ti_cmd_desc\tcmd;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Disable host interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);\n\t/*\n\t * Tell firmware we're shutting down.\n\t */\n\tTI_DO_CMD(TI_CMD_HOST_STATE, TI_CMD_CODE_STACK_DOWN, 0);\n\n\t/* Halt and reinitialize. */\n\tti_chipinit(sc);\n\tti_mem(sc, 0x2000, 0x100000 - 0x2000, NULL);\n\tti_chipinit(sc);\n\n\t/* Free the RX lists. */\n\tti_free_rx_ring_std(sc);\n\n\t/* Free jumbo RX list. */\n\tti_free_rx_ring_jumbo(sc);\n\n\t/* Free mini RX list. */\n\tti_free_rx_ring_mini(sc);\n\n\t/* Free TX buffers. */\n\tti_free_tx_ring(sc);\n\n\tsc->ti_ev_prodidx.ti_idx = 0;\n\tsc->ti_return_prodidx.ti_idx = 0;\n\tsc->ti_tx_considx.ti_idx = 0;\n\tsc->ti_tx_saved_considx = TI_TXCONS_UNSET;\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_stop",
            "void ti_mem",
            "void ti_free_rx_ring_std",
            "void ti_free_rx_ring_jumbo",
            "void ti_free_rx_ring_mini",
            "void ti_free_tx_ring",
            "int ti_chipinit",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_stop;\nvoid ti_mem;\nvoid ti_free_rx_ring_std;\nvoid ti_free_rx_ring_jumbo;\nvoid ti_free_rx_ring_mini;\nvoid ti_free_tx_ring;\nint ti_chipinit;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_stop(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct ti_cmd_desc\tcmd;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Disable host interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);\n\t/*\n\t * Tell firmware we're shutting down.\n\t */\n\tTI_DO_CMD(TI_CMD_HOST_STATE, TI_CMD_CODE_STACK_DOWN, 0);\n\n\t/* Halt and reinitialize. */\n\tti_chipinit(sc);\n\tti_mem(sc, 0x2000, 0x100000 - 0x2000, NULL);\n\tti_chipinit(sc);\n\n\t/* Free the RX lists. */\n\tti_free_rx_ring_std(sc);\n\n\t/* Free jumbo RX list. */\n\tti_free_rx_ring_jumbo(sc);\n\n\t/* Free mini RX list. */\n\tti_free_rx_ring_mini(sc);\n\n\t/* Free TX buffers. */\n\tti_free_tx_ring(sc);\n\n\tsc->ti_ev_prodidx.ti_idx = 0;\n\tsc->ti_return_prodidx.ti_idx = 0;\n\tsc->ti_tx_considx.ti_idx = 0;\n\tsc->ti_tx_saved_considx = TI_TXCONS_UNSET;\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_init",
          "args": [
            "sc"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "ti_init2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "2112-2195",
          "snippet": "void ti_init2(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ti_cmd_desc\tcmd;\n\tstruct ifnet\t\t*ifp;\n\tu_int16_t\t\t*m;\n\tstruct ifmedia\t\t*ifm;\n\tint\t\t\ttmp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Specify MTU and interface index. */\n\tCSR_WRITE_4(sc, TI_GCR_IFINDEX, sc->sc_dv.dv_unit);\n\tCSR_WRITE_4(sc, TI_GCR_IFMTU, ifp->if_mtu +\n\t    ETHER_HDR_LEN + ETHER_CRC_LEN);\n\tTI_DO_CMD(TI_CMD_UPDATE_GENCOM, 0, 0);\n\n\t/* Load our MAC address. */\n\tm = (u_int16_t *)&sc->arpcom.ac_enaddr[0];\n\tCSR_WRITE_4(sc, TI_GCR_PAR0, htons(m[0]));\n\tCSR_WRITE_4(sc, TI_GCR_PAR1, (htons(m[1]) << 16) | htons(m[2]));\n\tTI_DO_CMD(TI_CMD_SET_MAC_ADDR, 0, 0);\n\n\t/* Enable or disable promiscuous mode as needed. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tTI_DO_CMD(TI_CMD_SET_PROMISC_MODE, TI_CMD_CODE_PROMISC_ENB, 0);\n\t} else {\n\t\tTI_DO_CMD(TI_CMD_SET_PROMISC_MODE, TI_CMD_CODE_PROMISC_DIS, 0);\n\t}\n\n\t/* Program multicast filter. */\n\tti_setmulti(sc);\n\n\t/*\n\t * If this is a Tigon 1, we should tell the\n\t * firmware to use software packet filtering.\n\t */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON) {\n\t\tTI_DO_CMD(TI_CMD_FDR_FILTERING, TI_CMD_CODE_FILT_ENB, 0);\n\t}\n\n\t/* Init RX ring. */\n\tti_init_rx_ring_std(sc);\n\n\t/* Init jumbo RX ring. */\n\tif (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))\n\t\tti_init_rx_ring_jumbo(sc);\n\n\t/*\n\t * If this is a Tigon 2, we can also configure the\n\t * mini ring.\n\t */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II)\n\t\tti_init_rx_ring_mini(sc);\n\n\tCSR_WRITE_4(sc, TI_GCR_RXRETURNCONS_IDX, 0);\n\tsc->ti_rx_saved_considx = 0;\n\n\t/* Init TX ring. */\n\tti_init_tx_ring(sc);\n\n\t/* Tell firmware we're alive. */\n\tTI_DO_CMD(TI_CMD_HOST_STATE, TI_CMD_CODE_STACK_UP, 0);\n\n\t/* Enable host interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 0);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Make sure to set media properly. We have to do this\n\t * here since we have to issue commands in order to set\n\t * the link negotiation and we can't issue commands until\n\t * the firmware is running.\n\t */\n\tifm = &sc->ifmedia;\n\ttmp = ifm->ifm_media;\n\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\tti_ifmedia_upd(ifp);\n\tifm->ifm_media = tmp;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_init2",
            "int ti_ifmedia_upd",
            "void ti_setmulti",
            "int ti_init_rx_ring_std",
            "int ti_init_rx_ring_jumbo",
            "int ti_init_rx_ring_mini",
            "int ti_init_tx_ring",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_init2;\nint ti_ifmedia_upd;\nvoid ti_setmulti;\nint ti_init_rx_ring_std;\nint ti_init_rx_ring_jumbo;\nint ti_init_rx_ring_mini;\nint ti_init_tx_ring;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_init2(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ti_cmd_desc\tcmd;\n\tstruct ifnet\t\t*ifp;\n\tu_int16_t\t\t*m;\n\tstruct ifmedia\t\t*ifm;\n\tint\t\t\ttmp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Specify MTU and interface index. */\n\tCSR_WRITE_4(sc, TI_GCR_IFINDEX, sc->sc_dv.dv_unit);\n\tCSR_WRITE_4(sc, TI_GCR_IFMTU, ifp->if_mtu +\n\t    ETHER_HDR_LEN + ETHER_CRC_LEN);\n\tTI_DO_CMD(TI_CMD_UPDATE_GENCOM, 0, 0);\n\n\t/* Load our MAC address. */\n\tm = (u_int16_t *)&sc->arpcom.ac_enaddr[0];\n\tCSR_WRITE_4(sc, TI_GCR_PAR0, htons(m[0]));\n\tCSR_WRITE_4(sc, TI_GCR_PAR1, (htons(m[1]) << 16) | htons(m[2]));\n\tTI_DO_CMD(TI_CMD_SET_MAC_ADDR, 0, 0);\n\n\t/* Enable or disable promiscuous mode as needed. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tTI_DO_CMD(TI_CMD_SET_PROMISC_MODE, TI_CMD_CODE_PROMISC_ENB, 0);\n\t} else {\n\t\tTI_DO_CMD(TI_CMD_SET_PROMISC_MODE, TI_CMD_CODE_PROMISC_DIS, 0);\n\t}\n\n\t/* Program multicast filter. */\n\tti_setmulti(sc);\n\n\t/*\n\t * If this is a Tigon 1, we should tell the\n\t * firmware to use software packet filtering.\n\t */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON) {\n\t\tTI_DO_CMD(TI_CMD_FDR_FILTERING, TI_CMD_CODE_FILT_ENB, 0);\n\t}\n\n\t/* Init RX ring. */\n\tti_init_rx_ring_std(sc);\n\n\t/* Init jumbo RX ring. */\n\tif (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))\n\t\tti_init_rx_ring_jumbo(sc);\n\n\t/*\n\t * If this is a Tigon 2, we can also configure the\n\t * mini ring.\n\t */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II)\n\t\tti_init_rx_ring_mini(sc);\n\n\tCSR_WRITE_4(sc, TI_GCR_RXRETURNCONS_IDX, 0);\n\tsc->ti_rx_saved_considx = 0;\n\n\t/* Init TX ring. */\n\tti_init_tx_ring(sc);\n\n\t/* Tell firmware we're alive. */\n\tTI_DO_CMD(TI_CMD_HOST_STATE, TI_CMD_CODE_STACK_UP, 0);\n\n\t/* Enable host interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 0);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Make sure to set media properly. We have to do this\n\t * here since we have to issue commands in order to set\n\t * the link negotiation and we can't issue commands until\n\t * the firmware is running.\n\t */\n\tifm = &sc->ifmedia;\n\ttmp = ifm->ifm_media;\n\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\tti_ifmedia_upd(ifp);\n\tifm->ifm_media = tmp;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TI_DO_CMD",
          "args": [
            "TI_CMD_SET_PROMISC_MODE",
            "TI_CMD_CODE_PROMISC_DIS",
            "0"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_DO_CMD",
          "args": [
            "TI_CMD_SET_PROMISC_MODE",
            "TI_CMD_CODE_PROMISC_ENB",
            "0"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->arpcom",
            "ifa"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "&sc->arpcom",
            "command",
            "data"
          ],
          "line": 2303
        },
        "resolved": true,
        "details": {
          "function_name": "wx_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "303-356",
          "snippet": "static int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_init",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_init;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_ioctl;\nvoid ti_init;\nvoid ti_stop;\nvoid ti_setmulti;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tstruct ti_softc\t\t*sc = ifp->if_softc;\n\tstruct ifreq\t\t*ifr = (struct ifreq *)data;\n\tstruct ifaddr\t\t*ifa = (struct ifaddr *)data;\n\tint\t\t\ts, error = 0;\n\tstruct ti_cmd_desc\tcmd;\n\n\ts = splimp();\n\n\tif ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn (error);\n\t}\n\n\tswitch(command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tti_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif /* INET */\n\t\tdefault:\n\t\t\tti_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\t/*\n\t\t\t * If only the state of the PROMISC flag changed,\n\t\t\t * then just use the 'set promisc mode' command\n\t\t\t * instead of reinitializing the entire NIC. Doing\n\t\t\t * a full re-init means reloading the firmware and\n\t\t\t * waiting for it to start up, which may take a\n\t\t\t * second or two.\n\t\t\t */\n\t\t\tif (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    ifp->if_flags & IFF_PROMISC &&\n\t\t\t    !(sc->ti_if_flags & IFF_PROMISC)) {\n\t\t\t\tTI_DO_CMD(TI_CMD_SET_PROMISC_MODE,\n\t\t\t\t    TI_CMD_CODE_PROMISC_ENB, 0);\n\t\t\t} else if (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    sc->ti_if_flags & IFF_PROMISC) {\n\t\t\t\tTI_DO_CMD(TI_CMD_SET_PROMISC_MODE,\n\t\t\t\t    TI_CMD_CODE_PROMISC_DIS, 0);\n\t\t\t} else\n\t\t\t\tti_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING) {\n\t\t\t\tti_stop(sc);\n\t\t\t}\n\t\t}\n\t\tsc->ti_if_flags = ifp->if_flags;\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\tif (ifp->if_flags & IFF_RUNNING) {\n\t\t\tti_setmulti(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFMEDIA:\n\tcase SIOCGIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->ifmedia, command);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\t(void)splx(s);\n\n\treturn(error);\n}"
  },
  {
    "function_name": "ti_ifmedia_sts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "2256-2288",
    "snippet": "void ti_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct ti_softc\t\t*sc;\n\n\tsc = ifp->if_softc;\n\n\tifmr->ifm_status = IFM_AVALID;\n\tifmr->ifm_active = IFM_ETHER;\n\n\tif (sc->ti_linkstat == TI_EV_CODE_LINK_DOWN)\n\t\treturn;\n\n\tifmr->ifm_status |= IFM_ACTIVE;\n\n\tif (sc->ti_linkstat == TI_EV_CODE_GIG_LINK_UP)\n\t\tifmr->ifm_active |= IFM_1000_SX|IFM_FDX;\n\telse if (sc->ti_linkstat == TI_EV_CODE_LINK_UP) {\n\t\tu_int32_t\t\tmedia;\n\t\tmedia = CSR_READ_4(sc, TI_GCR_LINK_STAT);\n\t\tif (media & TI_LNK_100MB)\n\t\t\tifmr->ifm_active |= IFM_100_FX;\n\t\tif (media & TI_LNK_10MB)\n\t\t\tifmr->ifm_active |= IFM_10_FL;\n\t\tif (media & TI_LNK_FULL_DUPLEX)\n\t\t\tifmr->ifm_active |= IFM_FDX;\n\t\tif (media & TI_LNK_HALF_DUPLEX)\n\t\t\tifmr->ifm_active |= IFM_HDX;\n\t}\n\t\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_ifmedia_sts",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TI_GCR_LINK_STAT"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_ifmedia_sts;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct ti_softc\t\t*sc;\n\n\tsc = ifp->if_softc;\n\n\tifmr->ifm_status = IFM_AVALID;\n\tifmr->ifm_active = IFM_ETHER;\n\n\tif (sc->ti_linkstat == TI_EV_CODE_LINK_DOWN)\n\t\treturn;\n\n\tifmr->ifm_status |= IFM_ACTIVE;\n\n\tif (sc->ti_linkstat == TI_EV_CODE_GIG_LINK_UP)\n\t\tifmr->ifm_active |= IFM_1000_SX|IFM_FDX;\n\telse if (sc->ti_linkstat == TI_EV_CODE_LINK_UP) {\n\t\tu_int32_t\t\tmedia;\n\t\tmedia = CSR_READ_4(sc, TI_GCR_LINK_STAT);\n\t\tif (media & TI_LNK_100MB)\n\t\t\tifmr->ifm_active |= IFM_100_FX;\n\t\tif (media & TI_LNK_10MB)\n\t\t\tifmr->ifm_active |= IFM_10_FL;\n\t\tif (media & TI_LNK_FULL_DUPLEX)\n\t\t\tifmr->ifm_active |= IFM_FDX;\n\t\tif (media & TI_LNK_HALF_DUPLEX)\n\t\t\tifmr->ifm_active |= IFM_HDX;\n\t}\n\t\n\treturn;\n}"
  },
  {
    "function_name": "ti_ifmedia_upd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "2200-2251",
    "snippet": "int ti_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct ti_softc\t\t*sc;\n\tstruct ifmedia\t\t*ifm;\n\tstruct ti_cmd_desc\tcmd;\n\n\tsc = ifp->if_softc;\n\tifm = &sc->ifmedia;\n\n\tif (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)\n\t\treturn(EINVAL);\n\n\tswitch(IFM_SUBTYPE(ifm->ifm_media)) {\n\tcase IFM_AUTO:\n\t\tCSR_WRITE_4(sc, TI_GCR_GLINK, TI_GLNK_PREF|TI_GLNK_1000MB|\n\t\t    TI_GLNK_FULL_DUPLEX|TI_GLNK_RX_FLOWCTL_Y|\n\t\t    TI_GLNK_AUTONEGENB|TI_GLNK_ENB);\n\t\tCSR_WRITE_4(sc, TI_GCR_LINK, TI_LNK_100MB|TI_LNK_10MB|\n\t\t    TI_LNK_FULL_DUPLEX|TI_LNK_HALF_DUPLEX|\n\t\t    TI_LNK_AUTONEGENB|TI_LNK_ENB);\n\t\tTI_DO_CMD(TI_CMD_LINK_NEGOTIATION,\n\t\t    TI_CMD_CODE_NEGOTIATE_BOTH, 0);\n\t\tbreak;\n\tcase IFM_1000_SX:\n\t\tCSR_WRITE_4(sc, TI_GCR_GLINK, TI_GLNK_PREF|TI_GLNK_1000MB|\n\t\t    TI_GLNK_FULL_DUPLEX|TI_GLNK_RX_FLOWCTL_Y|TI_GLNK_ENB);\n\t\tCSR_WRITE_4(sc, TI_GCR_LINK, 0);\n\t\tTI_DO_CMD(TI_CMD_LINK_NEGOTIATION,\n\t\t    TI_CMD_CODE_NEGOTIATE_GIGABIT, 0);\n\t\tbreak;\n\tcase IFM_100_FX:\n\tcase IFM_10_FL:\n\t\tCSR_WRITE_4(sc, TI_GCR_GLINK, 0);\n\t\tCSR_WRITE_4(sc, TI_GCR_LINK, TI_LNK_ENB|TI_LNK_PREF);\n\t\tif (IFM_SUBTYPE(ifm->ifm_media) == IFM_100_FX) {\n\t\t\tTI_SETBIT(sc, TI_GCR_LINK, TI_LNK_100MB);\n\t\t} else {\n\t\t\tTI_SETBIT(sc, TI_GCR_LINK, TI_LNK_10MB);\n\t\t}\n\t\tif ((ifm->ifm_media & IFM_GMASK) == IFM_FDX) {\n\t\t\tTI_SETBIT(sc, TI_GCR_LINK, TI_LNK_FULL_DUPLEX);\n\t\t} else {\n\t\t\tTI_SETBIT(sc, TI_GCR_LINK, TI_LNK_HALF_DUPLEX);\n\t\t}\n\t\tTI_DO_CMD(TI_CMD_LINK_NEGOTIATION,\n\t\t    TI_CMD_CODE_NEGOTIATE_10_100, 0);\n\t\tbreak;\n\t}\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ti_ifmedia_upd",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TI_DO_CMD",
          "args": [
            "TI_CMD_LINK_NEGOTIATION",
            "TI_CMD_CODE_NEGOTIATE_10_100",
            "0"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_SETBIT",
          "args": [
            "sc",
            "TI_GCR_LINK",
            "TI_LNK_HALF_DUPLEX"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_SETBIT",
          "args": [
            "sc",
            "TI_GCR_LINK",
            "TI_LNK_FULL_DUPLEX"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_SETBIT",
          "args": [
            "sc",
            "TI_GCR_LINK",
            "TI_LNK_10MB"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_SETBIT",
          "args": [
            "sc",
            "TI_GCR_LINK",
            "TI_LNK_100MB"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "ifm->ifm_media"
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_LINK",
            "TI_LNK_ENB|TI_LNK_PREF"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_GLINK",
            "0"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_DO_CMD",
          "args": [
            "TI_CMD_LINK_NEGOTIATION",
            "TI_CMD_CODE_NEGOTIATE_GIGABIT",
            "0"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_LINK",
            "0"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_GLINK",
            "TI_GLNK_PREF|TI_GLNK_1000MB|\n\t\t    TI_GLNK_FULL_DUPLEX|TI_GLNK_RX_FLOWCTL_Y|TI_GLNK_ENB"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_DO_CMD",
          "args": [
            "TI_CMD_LINK_NEGOTIATION",
            "TI_CMD_CODE_NEGOTIATE_BOTH",
            "0"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_LINK",
            "TI_LNK_100MB|TI_LNK_10MB|\n\t\t    TI_LNK_FULL_DUPLEX|TI_LNK_HALF_DUPLEX|\n\t\t    TI_LNK_AUTONEGENB|TI_LNK_ENB"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_GLINK",
            "TI_GLNK_PREF|TI_GLNK_1000MB|\n\t\t    TI_GLNK_FULL_DUPLEX|TI_GLNK_RX_FLOWCTL_Y|\n\t\t    TI_GLNK_AUTONEGENB|TI_GLNK_ENB"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "ifm->ifm_media"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_TYPE",
          "args": [
            "ifm->ifm_media"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_ifmedia_upd;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct ti_softc\t\t*sc;\n\tstruct ifmedia\t\t*ifm;\n\tstruct ti_cmd_desc\tcmd;\n\n\tsc = ifp->if_softc;\n\tifm = &sc->ifmedia;\n\n\tif (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)\n\t\treturn(EINVAL);\n\n\tswitch(IFM_SUBTYPE(ifm->ifm_media)) {\n\tcase IFM_AUTO:\n\t\tCSR_WRITE_4(sc, TI_GCR_GLINK, TI_GLNK_PREF|TI_GLNK_1000MB|\n\t\t    TI_GLNK_FULL_DUPLEX|TI_GLNK_RX_FLOWCTL_Y|\n\t\t    TI_GLNK_AUTONEGENB|TI_GLNK_ENB);\n\t\tCSR_WRITE_4(sc, TI_GCR_LINK, TI_LNK_100MB|TI_LNK_10MB|\n\t\t    TI_LNK_FULL_DUPLEX|TI_LNK_HALF_DUPLEX|\n\t\t    TI_LNK_AUTONEGENB|TI_LNK_ENB);\n\t\tTI_DO_CMD(TI_CMD_LINK_NEGOTIATION,\n\t\t    TI_CMD_CODE_NEGOTIATE_BOTH, 0);\n\t\tbreak;\n\tcase IFM_1000_SX:\n\t\tCSR_WRITE_4(sc, TI_GCR_GLINK, TI_GLNK_PREF|TI_GLNK_1000MB|\n\t\t    TI_GLNK_FULL_DUPLEX|TI_GLNK_RX_FLOWCTL_Y|TI_GLNK_ENB);\n\t\tCSR_WRITE_4(sc, TI_GCR_LINK, 0);\n\t\tTI_DO_CMD(TI_CMD_LINK_NEGOTIATION,\n\t\t    TI_CMD_CODE_NEGOTIATE_GIGABIT, 0);\n\t\tbreak;\n\tcase IFM_100_FX:\n\tcase IFM_10_FL:\n\t\tCSR_WRITE_4(sc, TI_GCR_GLINK, 0);\n\t\tCSR_WRITE_4(sc, TI_GCR_LINK, TI_LNK_ENB|TI_LNK_PREF);\n\t\tif (IFM_SUBTYPE(ifm->ifm_media) == IFM_100_FX) {\n\t\t\tTI_SETBIT(sc, TI_GCR_LINK, TI_LNK_100MB);\n\t\t} else {\n\t\t\tTI_SETBIT(sc, TI_GCR_LINK, TI_LNK_10MB);\n\t\t}\n\t\tif ((ifm->ifm_media & IFM_GMASK) == IFM_FDX) {\n\t\t\tTI_SETBIT(sc, TI_GCR_LINK, TI_LNK_FULL_DUPLEX);\n\t\t} else {\n\t\t\tTI_SETBIT(sc, TI_GCR_LINK, TI_LNK_HALF_DUPLEX);\n\t\t}\n\t\tTI_DO_CMD(TI_CMD_LINK_NEGOTIATION,\n\t\t    TI_CMD_CODE_NEGOTIATE_10_100, 0);\n\t\tbreak;\n\t}\n\n\treturn(0);\n}"
  },
  {
    "function_name": "ti_init2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "2112-2195",
    "snippet": "void ti_init2(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ti_cmd_desc\tcmd;\n\tstruct ifnet\t\t*ifp;\n\tu_int16_t\t\t*m;\n\tstruct ifmedia\t\t*ifm;\n\tint\t\t\ttmp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Specify MTU and interface index. */\n\tCSR_WRITE_4(sc, TI_GCR_IFINDEX, sc->sc_dv.dv_unit);\n\tCSR_WRITE_4(sc, TI_GCR_IFMTU, ifp->if_mtu +\n\t    ETHER_HDR_LEN + ETHER_CRC_LEN);\n\tTI_DO_CMD(TI_CMD_UPDATE_GENCOM, 0, 0);\n\n\t/* Load our MAC address. */\n\tm = (u_int16_t *)&sc->arpcom.ac_enaddr[0];\n\tCSR_WRITE_4(sc, TI_GCR_PAR0, htons(m[0]));\n\tCSR_WRITE_4(sc, TI_GCR_PAR1, (htons(m[1]) << 16) | htons(m[2]));\n\tTI_DO_CMD(TI_CMD_SET_MAC_ADDR, 0, 0);\n\n\t/* Enable or disable promiscuous mode as needed. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tTI_DO_CMD(TI_CMD_SET_PROMISC_MODE, TI_CMD_CODE_PROMISC_ENB, 0);\n\t} else {\n\t\tTI_DO_CMD(TI_CMD_SET_PROMISC_MODE, TI_CMD_CODE_PROMISC_DIS, 0);\n\t}\n\n\t/* Program multicast filter. */\n\tti_setmulti(sc);\n\n\t/*\n\t * If this is a Tigon 1, we should tell the\n\t * firmware to use software packet filtering.\n\t */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON) {\n\t\tTI_DO_CMD(TI_CMD_FDR_FILTERING, TI_CMD_CODE_FILT_ENB, 0);\n\t}\n\n\t/* Init RX ring. */\n\tti_init_rx_ring_std(sc);\n\n\t/* Init jumbo RX ring. */\n\tif (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))\n\t\tti_init_rx_ring_jumbo(sc);\n\n\t/*\n\t * If this is a Tigon 2, we can also configure the\n\t * mini ring.\n\t */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II)\n\t\tti_init_rx_ring_mini(sc);\n\n\tCSR_WRITE_4(sc, TI_GCR_RXRETURNCONS_IDX, 0);\n\tsc->ti_rx_saved_considx = 0;\n\n\t/* Init TX ring. */\n\tti_init_tx_ring(sc);\n\n\t/* Tell firmware we're alive. */\n\tTI_DO_CMD(TI_CMD_HOST_STATE, TI_CMD_CODE_STACK_UP, 0);\n\n\t/* Enable host interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 0);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Make sure to set media properly. We have to do this\n\t * here since we have to issue commands in order to set\n\t * the link negotiation and we can't issue commands until\n\t * the firmware is running.\n\t */\n\tifm = &sc->ifmedia;\n\ttmp = ifm->ifm_media;\n\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\tti_ifmedia_upd(ifp);\n\tifm->ifm_media = tmp;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_init2",
      "int ti_ifmedia_upd",
      "void ti_setmulti",
      "int ti_init_rx_ring_std",
      "int ti_init_rx_ring_jumbo",
      "int ti_init_rx_ring_mini",
      "int ti_init_tx_ring",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ti_ifmedia_upd",
          "args": [
            "ifp"
          ],
          "line": 2191
        },
        "resolved": true,
        "details": {
          "function_name": "ti_ifmedia_upd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "2200-2251",
          "snippet": "int ti_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct ti_softc\t\t*sc;\n\tstruct ifmedia\t\t*ifm;\n\tstruct ti_cmd_desc\tcmd;\n\n\tsc = ifp->if_softc;\n\tifm = &sc->ifmedia;\n\n\tif (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)\n\t\treturn(EINVAL);\n\n\tswitch(IFM_SUBTYPE(ifm->ifm_media)) {\n\tcase IFM_AUTO:\n\t\tCSR_WRITE_4(sc, TI_GCR_GLINK, TI_GLNK_PREF|TI_GLNK_1000MB|\n\t\t    TI_GLNK_FULL_DUPLEX|TI_GLNK_RX_FLOWCTL_Y|\n\t\t    TI_GLNK_AUTONEGENB|TI_GLNK_ENB);\n\t\tCSR_WRITE_4(sc, TI_GCR_LINK, TI_LNK_100MB|TI_LNK_10MB|\n\t\t    TI_LNK_FULL_DUPLEX|TI_LNK_HALF_DUPLEX|\n\t\t    TI_LNK_AUTONEGENB|TI_LNK_ENB);\n\t\tTI_DO_CMD(TI_CMD_LINK_NEGOTIATION,\n\t\t    TI_CMD_CODE_NEGOTIATE_BOTH, 0);\n\t\tbreak;\n\tcase IFM_1000_SX:\n\t\tCSR_WRITE_4(sc, TI_GCR_GLINK, TI_GLNK_PREF|TI_GLNK_1000MB|\n\t\t    TI_GLNK_FULL_DUPLEX|TI_GLNK_RX_FLOWCTL_Y|TI_GLNK_ENB);\n\t\tCSR_WRITE_4(sc, TI_GCR_LINK, 0);\n\t\tTI_DO_CMD(TI_CMD_LINK_NEGOTIATION,\n\t\t    TI_CMD_CODE_NEGOTIATE_GIGABIT, 0);\n\t\tbreak;\n\tcase IFM_100_FX:\n\tcase IFM_10_FL:\n\t\tCSR_WRITE_4(sc, TI_GCR_GLINK, 0);\n\t\tCSR_WRITE_4(sc, TI_GCR_LINK, TI_LNK_ENB|TI_LNK_PREF);\n\t\tif (IFM_SUBTYPE(ifm->ifm_media) == IFM_100_FX) {\n\t\t\tTI_SETBIT(sc, TI_GCR_LINK, TI_LNK_100MB);\n\t\t} else {\n\t\t\tTI_SETBIT(sc, TI_GCR_LINK, TI_LNK_10MB);\n\t\t}\n\t\tif ((ifm->ifm_media & IFM_GMASK) == IFM_FDX) {\n\t\t\tTI_SETBIT(sc, TI_GCR_LINK, TI_LNK_FULL_DUPLEX);\n\t\t} else {\n\t\t\tTI_SETBIT(sc, TI_GCR_LINK, TI_LNK_HALF_DUPLEX);\n\t\t}\n\t\tTI_DO_CMD(TI_CMD_LINK_NEGOTIATION,\n\t\t    TI_CMD_CODE_NEGOTIATE_10_100, 0);\n\t\tbreak;\n\t}\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int ti_ifmedia_upd",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_ifmedia_upd;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct ti_softc\t\t*sc;\n\tstruct ifmedia\t\t*ifm;\n\tstruct ti_cmd_desc\tcmd;\n\n\tsc = ifp->if_softc;\n\tifm = &sc->ifmedia;\n\n\tif (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)\n\t\treturn(EINVAL);\n\n\tswitch(IFM_SUBTYPE(ifm->ifm_media)) {\n\tcase IFM_AUTO:\n\t\tCSR_WRITE_4(sc, TI_GCR_GLINK, TI_GLNK_PREF|TI_GLNK_1000MB|\n\t\t    TI_GLNK_FULL_DUPLEX|TI_GLNK_RX_FLOWCTL_Y|\n\t\t    TI_GLNK_AUTONEGENB|TI_GLNK_ENB);\n\t\tCSR_WRITE_4(sc, TI_GCR_LINK, TI_LNK_100MB|TI_LNK_10MB|\n\t\t    TI_LNK_FULL_DUPLEX|TI_LNK_HALF_DUPLEX|\n\t\t    TI_LNK_AUTONEGENB|TI_LNK_ENB);\n\t\tTI_DO_CMD(TI_CMD_LINK_NEGOTIATION,\n\t\t    TI_CMD_CODE_NEGOTIATE_BOTH, 0);\n\t\tbreak;\n\tcase IFM_1000_SX:\n\t\tCSR_WRITE_4(sc, TI_GCR_GLINK, TI_GLNK_PREF|TI_GLNK_1000MB|\n\t\t    TI_GLNK_FULL_DUPLEX|TI_GLNK_RX_FLOWCTL_Y|TI_GLNK_ENB);\n\t\tCSR_WRITE_4(sc, TI_GCR_LINK, 0);\n\t\tTI_DO_CMD(TI_CMD_LINK_NEGOTIATION,\n\t\t    TI_CMD_CODE_NEGOTIATE_GIGABIT, 0);\n\t\tbreak;\n\tcase IFM_100_FX:\n\tcase IFM_10_FL:\n\t\tCSR_WRITE_4(sc, TI_GCR_GLINK, 0);\n\t\tCSR_WRITE_4(sc, TI_GCR_LINK, TI_LNK_ENB|TI_LNK_PREF);\n\t\tif (IFM_SUBTYPE(ifm->ifm_media) == IFM_100_FX) {\n\t\t\tTI_SETBIT(sc, TI_GCR_LINK, TI_LNK_100MB);\n\t\t} else {\n\t\t\tTI_SETBIT(sc, TI_GCR_LINK, TI_LNK_10MB);\n\t\t}\n\t\tif ((ifm->ifm_media & IFM_GMASK) == IFM_FDX) {\n\t\t\tTI_SETBIT(sc, TI_GCR_LINK, TI_LNK_FULL_DUPLEX);\n\t\t} else {\n\t\t\tTI_SETBIT(sc, TI_GCR_LINK, TI_LNK_HALF_DUPLEX);\n\t\t}\n\t\tTI_DO_CMD(TI_CMD_LINK_NEGOTIATION,\n\t\t    TI_CMD_CODE_NEGOTIATE_10_100, 0);\n\t\tbreak;\n\t}\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_MB_HOSTINTR",
            "0"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_DO_CMD",
          "args": [
            "TI_CMD_HOST_STATE",
            "TI_CMD_CODE_STACK_UP",
            "0"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ti_init_tx_ring",
          "args": [
            "sc"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "ti_init_tx_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "1001-1008",
          "snippet": "int ti_init_tx_ring(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tsc->ti_txcnt = 0;\n\tsc->ti_tx_saved_considx = 0;\n\tCSR_WRITE_4(sc, TI_MB_SENDPROD_IDX, 0);\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int ti_init_tx_ring",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_init_tx_ring;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_init_tx_ring(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tsc->ti_txcnt = 0;\n\tsc->ti_tx_saved_considx = 0;\n\tCSR_WRITE_4(sc, TI_MB_SENDPROD_IDX, 0);\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_RXRETURNCONS_IDX",
            "0"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ti_init_rx_ring_mini",
          "args": [
            "sc"
          ],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "ti_init_rx_ring_mini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "948-962",
          "snippet": "int ti_init_rx_ring_mini(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_MSLOTS; i++) {\n\t\tif (ti_newbuf_mini(sc, i, NULL) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t};\n\n\tTI_UPDATE_MINIPROD(sc, i - 1);\n\tsc->ti_mini = i - 1;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int ti_newbuf_mini",
            "int ti_init_rx_ring_mini",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_newbuf_mini;\nint ti_init_rx_ring_mini;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_init_rx_ring_mini(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_MSLOTS; i++) {\n\t\tif (ti_newbuf_mini(sc, i, NULL) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t};\n\n\tTI_UPDATE_MINIPROD(sc, i - 1);\n\tsc->ti_mini = i - 1;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_init_rx_ring_jumbo",
          "args": [
            "sc"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "ti_init_rx_ring_jumbo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "914-929",
          "snippet": "int ti_init_rx_ring_jumbo(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ti_cmd_desc\tcmd;\n\n\tfor (i = 0; i < (TI_JSLOTS - 20); i++) {\n\t\tif (ti_newbuf_jumbo(sc, i, NULL) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t};\n\n\tTI_UPDATE_JUMBOPROD(sc, i - 1);\n\tsc->ti_jumbo = i - 1;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int ti_newbuf_jumbo",
            "int ti_init_rx_ring_jumbo",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_newbuf_jumbo;\nint ti_init_rx_ring_jumbo;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_init_rx_ring_jumbo(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ti_cmd_desc\tcmd;\n\n\tfor (i = 0; i < (TI_JSLOTS - 20); i++) {\n\t\tif (ti_newbuf_jumbo(sc, i, NULL) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t};\n\n\tTI_UPDATE_JUMBOPROD(sc, i - 1);\n\tsc->ti_jumbo = i - 1;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_init_rx_ring_std",
          "args": [
            "sc"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "ti_init_rx_ring_std",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "880-895",
          "snippet": "int ti_init_rx_ring_std(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ti_cmd_desc\tcmd;\n\n\tfor (i = 0; i < TI_SSLOTS; i++) {\n\t\tif (ti_newbuf_std(sc, i, NULL) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t};\n\n\tTI_UPDATE_STDPROD(sc, i - 1);\n\tsc->ti_std = i - 1;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int ti_newbuf_std",
            "int ti_init_rx_ring_std",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_newbuf_std;\nint ti_init_rx_ring_std;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_init_rx_ring_std(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ti_cmd_desc\tcmd;\n\n\tfor (i = 0; i < TI_SSLOTS; i++) {\n\t\tif (ti_newbuf_std(sc, i, NULL) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t};\n\n\tTI_UPDATE_STDPROD(sc, i - 1);\n\tsc->ti_std = i - 1;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TI_DO_CMD",
          "args": [
            "TI_CMD_FDR_FILTERING",
            "TI_CMD_CODE_FILT_ENB",
            "0"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ti_setmulti",
          "args": [
            "sc"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "ti_setmulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "1087-1136",
          "snippet": "void ti_setmulti(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tstruct ti_cmd_desc\tcmd;\n\tstruct ti_mc_entry\t*mc;\n\tu_int32_t\t\tintrs;\n\tstruct ti_mc_entry *p;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tif (ifp->if_flags & IFF_ALLMULTI) {\n\t\tTI_DO_CMD(TI_CMD_SET_ALLMULTI, TI_CMD_CODE_ALLMULTI_ENB, 0);\n\t\treturn;\n\t} else {\n\t\tTI_DO_CMD(TI_CMD_SET_ALLMULTI, TI_CMD_CODE_ALLMULTI_DIS, 0);\n\t}\n\n\t/* Disable interrupts. */\n\tintrs = CSR_READ_4(sc, TI_MB_HOSTINTR);\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);\n\n\t/* First, zot all the existing filters. */\n\tp = LIST_FIRST(&sc->ti_mc_listhead);\n\twhile (p != NULL) {\n\t\tmc = p;\n\t\tti_del_mcast(sc, &mc->mc_addr);\n\t\tp = LIST_FIRST(&sc->ti_mc_listhead);\n\t\tLIST_REMOVE(mc, mc_entries);\n\t\tp = LIST_NEXT(p, mc_entries);\n\t\tfree(mc, M_DEVBUF);\n\t}\n\n\t/* Now program new ones. */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tmc = malloc(sizeof(struct ti_mc_entry), M_DEVBUF, M_NOWAIT);\n\t\tbcopy(enm->enm_addrlo, (char *)&mc->mc_addr, ETHER_ADDR_LEN);\n\t\tLIST_INSERT_HEAD(&sc->ti_mc_listhead, mc, mc_entries);\n\t\tti_add_mcast(sc, &mc->mc_addr);\n\t}\n\n\t/* Re-enable interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, intrs);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_add_mcast",
            "void ti_del_mcast",
            "void ti_setmulti",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_add_mcast;\nvoid ti_del_mcast;\nvoid ti_setmulti;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_setmulti(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tstruct ti_cmd_desc\tcmd;\n\tstruct ti_mc_entry\t*mc;\n\tu_int32_t\t\tintrs;\n\tstruct ti_mc_entry *p;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tif (ifp->if_flags & IFF_ALLMULTI) {\n\t\tTI_DO_CMD(TI_CMD_SET_ALLMULTI, TI_CMD_CODE_ALLMULTI_ENB, 0);\n\t\treturn;\n\t} else {\n\t\tTI_DO_CMD(TI_CMD_SET_ALLMULTI, TI_CMD_CODE_ALLMULTI_DIS, 0);\n\t}\n\n\t/* Disable interrupts. */\n\tintrs = CSR_READ_4(sc, TI_MB_HOSTINTR);\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);\n\n\t/* First, zot all the existing filters. */\n\tp = LIST_FIRST(&sc->ti_mc_listhead);\n\twhile (p != NULL) {\n\t\tmc = p;\n\t\tti_del_mcast(sc, &mc->mc_addr);\n\t\tp = LIST_FIRST(&sc->ti_mc_listhead);\n\t\tLIST_REMOVE(mc, mc_entries);\n\t\tp = LIST_NEXT(p, mc_entries);\n\t\tfree(mc, M_DEVBUF);\n\t}\n\n\t/* Now program new ones. */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tmc = malloc(sizeof(struct ti_mc_entry), M_DEVBUF, M_NOWAIT);\n\t\tbcopy(enm->enm_addrlo, (char *)&mc->mc_addr, ETHER_ADDR_LEN);\n\t\tLIST_INSERT_HEAD(&sc->ti_mc_listhead, mc, mc_entries);\n\t\tti_add_mcast(sc, &mc->mc_addr);\n\t}\n\n\t/* Re-enable interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, intrs);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TI_DO_CMD",
          "args": [
            "TI_CMD_SET_PROMISC_MODE",
            "TI_CMD_CODE_PROMISC_DIS",
            "0"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_DO_CMD",
          "args": [
            "TI_CMD_SET_PROMISC_MODE",
            "TI_CMD_CODE_PROMISC_ENB",
            "0"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_DO_CMD",
          "args": [
            "TI_CMD_SET_MAC_ADDR",
            "0",
            "0"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_PAR1",
            "(htons(m[1]) << 16) | htons(m[2])"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "m[2]"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "m[1]"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_PAR0",
            "htons(m[0])"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "m[0]"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_DO_CMD",
          "args": [
            "TI_CMD_UPDATE_GENCOM",
            "0",
            "0"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_IFMTU",
            "ifp->if_mtu +\n\t    ETHER_HDR_LEN + ETHER_CRC_LEN"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_IFINDEX",
            "sc->sc_dv.dv_unit"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_init2;\nint ti_ifmedia_upd;\nvoid ti_setmulti;\nint ti_init_rx_ring_std;\nint ti_init_rx_ring_jumbo;\nint ti_init_rx_ring_mini;\nint ti_init_tx_ring;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_init2(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ti_cmd_desc\tcmd;\n\tstruct ifnet\t\t*ifp;\n\tu_int16_t\t\t*m;\n\tstruct ifmedia\t\t*ifm;\n\tint\t\t\ttmp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Specify MTU and interface index. */\n\tCSR_WRITE_4(sc, TI_GCR_IFINDEX, sc->sc_dv.dv_unit);\n\tCSR_WRITE_4(sc, TI_GCR_IFMTU, ifp->if_mtu +\n\t    ETHER_HDR_LEN + ETHER_CRC_LEN);\n\tTI_DO_CMD(TI_CMD_UPDATE_GENCOM, 0, 0);\n\n\t/* Load our MAC address. */\n\tm = (u_int16_t *)&sc->arpcom.ac_enaddr[0];\n\tCSR_WRITE_4(sc, TI_GCR_PAR0, htons(m[0]));\n\tCSR_WRITE_4(sc, TI_GCR_PAR1, (htons(m[1]) << 16) | htons(m[2]));\n\tTI_DO_CMD(TI_CMD_SET_MAC_ADDR, 0, 0);\n\n\t/* Enable or disable promiscuous mode as needed. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tTI_DO_CMD(TI_CMD_SET_PROMISC_MODE, TI_CMD_CODE_PROMISC_ENB, 0);\n\t} else {\n\t\tTI_DO_CMD(TI_CMD_SET_PROMISC_MODE, TI_CMD_CODE_PROMISC_DIS, 0);\n\t}\n\n\t/* Program multicast filter. */\n\tti_setmulti(sc);\n\n\t/*\n\t * If this is a Tigon 1, we should tell the\n\t * firmware to use software packet filtering.\n\t */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON) {\n\t\tTI_DO_CMD(TI_CMD_FDR_FILTERING, TI_CMD_CODE_FILT_ENB, 0);\n\t}\n\n\t/* Init RX ring. */\n\tti_init_rx_ring_std(sc);\n\n\t/* Init jumbo RX ring. */\n\tif (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))\n\t\tti_init_rx_ring_jumbo(sc);\n\n\t/*\n\t * If this is a Tigon 2, we can also configure the\n\t * mini ring.\n\t */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II)\n\t\tti_init_rx_ring_mini(sc);\n\n\tCSR_WRITE_4(sc, TI_GCR_RXRETURNCONS_IDX, 0);\n\tsc->ti_rx_saved_considx = 0;\n\n\t/* Init TX ring. */\n\tti_init_tx_ring(sc);\n\n\t/* Tell firmware we're alive. */\n\tTI_DO_CMD(TI_CMD_HOST_STATE, TI_CMD_CODE_STACK_UP, 0);\n\n\t/* Enable host interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 0);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Make sure to set media properly. We have to do this\n\t * here since we have to issue commands in order to set\n\t * the link negotiation and we can't issue commands until\n\t * the firmware is running.\n\t */\n\tifm = &sc->ifmedia;\n\ttmp = ifm->ifm_media;\n\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\tti_ifmedia_upd(ifp);\n\tifm->ifm_media = tmp;\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "2089-2110",
    "snippet": "void ti_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct ti_softc\t\t*sc = xsc;\n        int\t\t\ts;\n\n\ts = splimp();\n\n\t/* Cancel pending I/O and flush buffers. */\n\tti_stop(sc);\n\n\t/* Init the gen info block, ring control blocks and firmware. */\n\tif (ti_gibinit(sc)) {\n\t\tprintf(\"%s: initialization failure\\n\", sc->sc_dv.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\tsplx(s);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_init",
      "void ti_stop",
      "int ti_gibinit",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: initialization failure\\n\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_gibinit",
          "args": [
            "sc"
          ],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "ti_gibinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "1312-1476",
          "snippet": "int ti_gibinit(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ti_rcb\t\t*rcb;\n\tint\t\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Disable interrupts for now. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);\n\n\t/* Tell the chip where to find the general information block. */\n\tCSR_WRITE_4(sc, TI_GCR_GENINFO_HI, 0);\n\tCSR_WRITE_4(sc, TI_GCR_GENINFO_LO, vtophys(&sc->ti_rdata->ti_info));\n\n\t/* Load the firmware into SRAM. */\n\tti_loadfw(sc);\n\n\t/* Set up the contents of the general info and ring control blocks. */\n\n\t/* Set up the event ring and producer pointer. */\n\trcb = &sc->ti_rdata->ti_info.ti_ev_rcb;\n\n\tTI_HOSTADDR(rcb->ti_hostaddr) = vtophys(&sc->ti_rdata->ti_event_ring);\n\trcb->ti_flags = 0;\n\tTI_HOSTADDR(sc->ti_rdata->ti_info.ti_ev_prodidx_ptr) =\n\t    vtophys(&sc->ti_ev_prodidx);\n\tsc->ti_ev_prodidx.ti_idx = 0;\n\tCSR_WRITE_4(sc, TI_GCR_EVENTCONS_IDX, 0);\n\tsc->ti_ev_saved_considx = 0;\n\n\t/* Set up the command ring and producer mailbox. */\n\trcb = &sc->ti_rdata->ti_info.ti_cmd_rcb;\n\n\tsc->ti_rdata->ti_cmd_ring =\n\t    (struct ti_cmd_desc *)(sc->ti_bhandle + TI_GCR_CMDRING);\n\tTI_HOSTADDR(rcb->ti_hostaddr) = TI_GCR_NIC_ADDR(TI_GCR_CMDRING);\n\trcb->ti_flags = 0;\n\trcb->ti_max_len = 0;\n\tfor (i = 0; i < TI_CMD_RING_CNT; i++) {\n\t\tCSR_WRITE_4(sc, TI_GCR_CMDRING + (i * 4), 0);\n\t}\n\tCSR_WRITE_4(sc, TI_GCR_CMDCONS_IDX, 0);\n\tCSR_WRITE_4(sc, TI_MB_CMDPROD_IDX, 0);\n\tsc->ti_cmd_saved_prodidx = 0;\n\n\t/*\n\t * Assign the address of the stats refresh buffer.\n\t * We re-use the current stats buffer for this to\n\t * conserve memory.\n\t */\n\tTI_HOSTADDR(sc->ti_rdata->ti_info.ti_refresh_stats_ptr) =\n\t    vtophys(&sc->ti_rdata->ti_info.ti_stats);\n\n\t/* Set up the standard receive ring. */\n\trcb = &sc->ti_rdata->ti_info.ti_std_rx_rcb;\n\tTI_HOSTADDR(rcb->ti_hostaddr) = vtophys(&sc->ti_rdata->ti_rx_std_ring);\n\trcb->ti_max_len = TI_FRAMELEN;\n\trcb->ti_flags = 0;\n#ifdef TI_CSUM_OFFLOAD\n\trcb->ti_flags |= TI_RCB_FLAG_TCP_UDP_CKSUM|TI_RCB_FLAG_IP_CKSUM;\n#endif\n#if NVLAN > 0\n\trcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;\n#endif\n\n\t/* Set up the jumbo receive ring. */\n\trcb = &sc->ti_rdata->ti_info.ti_jumbo_rx_rcb;\n\tTI_HOSTADDR(rcb->ti_hostaddr) =\n\t    vtophys(&sc->ti_rdata->ti_rx_jumbo_ring);\n\trcb->ti_max_len = TI_JUMBO_FRAMELEN;\n\trcb->ti_flags = 0;\n#ifdef TI_CSUM_OFFLOAD\n\trcb->ti_flags |= TI_RCB_FLAG_TCP_UDP_CKSUM|TI_RCB_FLAG_IP_CKSUM;\n#endif\n#if NVLAN > 0\n\trcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;\n#endif\n\n\t/*\n\t * Set up the mini ring. Only activated on the\n\t * Tigon 2 but the slot in the config block is\n\t * still there on the Tigon 1.\n\t */\n\trcb = &sc->ti_rdata->ti_info.ti_mini_rx_rcb;\n\tTI_HOSTADDR(rcb->ti_hostaddr) =\n\t    vtophys(&sc->ti_rdata->ti_rx_mini_ring);\n\trcb->ti_max_len = MHLEN - ETHER_ALIGN;\n\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\trcb->ti_flags = TI_RCB_FLAG_RING_DISABLED;\n\telse\n\t\trcb->ti_flags = 0;\n#ifdef TI_CSUM_OFFLOAD\n\trcb->ti_flags |= TI_RCB_FLAG_TCP_UDP_CKSUM|TI_RCB_FLAG_IP_CKSUM;\n#endif\n#if NVLAN > 0\n\trcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;\n#endif\n\n\t/*\n\t * Set up the receive return ring.\n\t */\n\trcb = &sc->ti_rdata->ti_info.ti_return_rcb;\n\tTI_HOSTADDR(rcb->ti_hostaddr) =\n\t    vtophys(&sc->ti_rdata->ti_rx_return_ring);\n\trcb->ti_flags = 0;\n\trcb->ti_max_len = TI_RETURN_RING_CNT;\n\tTI_HOSTADDR(sc->ti_rdata->ti_info.ti_return_prodidx_ptr) =\n\t    vtophys(&sc->ti_return_prodidx);\n\n\t/*\n\t * Set up the tx ring. Note: for the Tigon 2, we have the option\n\t * of putting the transmit ring in the host's address space and\n\t * letting the chip DMA it instead of leaving the ring in the NIC's\n\t * memory and accessing it through the shared memory region. We\n\t * do this for the Tigon 2, but it doesn't work on the Tigon 1,\n\t * so we have to revert to the shared memory scheme if we detect\n\t * a Tigon 1 chip.\n\t */\n\tCSR_WRITE_4(sc, TI_WINBASE, TI_TX_RING_BASE);\n\tif (sc->ti_hwrev == TI_HWREV_TIGON) {\n\t\tsc->ti_rdata->ti_tx_ring_nic =\n\t\t    (struct ti_tx_desc *)(sc->ti_bhandle + TI_WINDOW);\n\t}\n\tbzero((char *)sc->ti_rdata->ti_tx_ring,\n\t    TI_TX_RING_CNT * sizeof(struct ti_tx_desc));\n\trcb = &sc->ti_rdata->ti_info.ti_tx_rcb;\n\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\trcb->ti_flags = 0;\n\telse\n\t\trcb->ti_flags = TI_RCB_FLAG_HOST_RING;\n#if NVLAN > 0\n\trcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;\n#endif\n\trcb->ti_max_len = TI_TX_RING_CNT;\n\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\tTI_HOSTADDR(rcb->ti_hostaddr) = TI_TX_RING_BASE;\n\telse\n\t\tTI_HOSTADDR(rcb->ti_hostaddr) =\n\t\t    vtophys(&sc->ti_rdata->ti_tx_ring);\n\tTI_HOSTADDR(sc->ti_rdata->ti_info.ti_tx_considx_ptr) =\n\t    vtophys(&sc->ti_tx_considx);\n\n\t/* Set up tuneables */\n\tif (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))\n\t\tCSR_WRITE_4(sc, TI_GCR_RX_COAL_TICKS,\n\t\t    (sc->ti_rx_coal_ticks / 10));\n\telse\n\t\tCSR_WRITE_4(sc, TI_GCR_RX_COAL_TICKS, sc->ti_rx_coal_ticks);\n\tCSR_WRITE_4(sc, TI_GCR_TX_COAL_TICKS, sc->ti_tx_coal_ticks);\n\tCSR_WRITE_4(sc, TI_GCR_STAT_TICKS, sc->ti_stat_ticks);\n\tCSR_WRITE_4(sc, TI_GCR_RX_MAX_COAL_BD, sc->ti_rx_max_coal_bds);\n\tCSR_WRITE_4(sc, TI_GCR_TX_MAX_COAL_BD, sc->ti_tx_max_coal_bds);\n\tCSR_WRITE_4(sc, TI_GCR_TX_BUFFER_RATIO, sc->ti_tx_buf_ratio);\n\n\t/* Turn interrupts on. */\n\tCSR_WRITE_4(sc, TI_GCR_MASK_INTRS, 0);\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 0);\n\n\t/* Start CPU. */\n\tTI_CLRBIT(sc, TI_CPU_STATE, (TI_CPUSTATE_HALT|TI_CPUSTATE_STEP));\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_loadfw",
            "int ti_gibinit",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_loadfw;\nint ti_gibinit;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_gibinit(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ti_rcb\t\t*rcb;\n\tint\t\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Disable interrupts for now. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);\n\n\t/* Tell the chip where to find the general information block. */\n\tCSR_WRITE_4(sc, TI_GCR_GENINFO_HI, 0);\n\tCSR_WRITE_4(sc, TI_GCR_GENINFO_LO, vtophys(&sc->ti_rdata->ti_info));\n\n\t/* Load the firmware into SRAM. */\n\tti_loadfw(sc);\n\n\t/* Set up the contents of the general info and ring control blocks. */\n\n\t/* Set up the event ring and producer pointer. */\n\trcb = &sc->ti_rdata->ti_info.ti_ev_rcb;\n\n\tTI_HOSTADDR(rcb->ti_hostaddr) = vtophys(&sc->ti_rdata->ti_event_ring);\n\trcb->ti_flags = 0;\n\tTI_HOSTADDR(sc->ti_rdata->ti_info.ti_ev_prodidx_ptr) =\n\t    vtophys(&sc->ti_ev_prodidx);\n\tsc->ti_ev_prodidx.ti_idx = 0;\n\tCSR_WRITE_4(sc, TI_GCR_EVENTCONS_IDX, 0);\n\tsc->ti_ev_saved_considx = 0;\n\n\t/* Set up the command ring and producer mailbox. */\n\trcb = &sc->ti_rdata->ti_info.ti_cmd_rcb;\n\n\tsc->ti_rdata->ti_cmd_ring =\n\t    (struct ti_cmd_desc *)(sc->ti_bhandle + TI_GCR_CMDRING);\n\tTI_HOSTADDR(rcb->ti_hostaddr) = TI_GCR_NIC_ADDR(TI_GCR_CMDRING);\n\trcb->ti_flags = 0;\n\trcb->ti_max_len = 0;\n\tfor (i = 0; i < TI_CMD_RING_CNT; i++) {\n\t\tCSR_WRITE_4(sc, TI_GCR_CMDRING + (i * 4), 0);\n\t}\n\tCSR_WRITE_4(sc, TI_GCR_CMDCONS_IDX, 0);\n\tCSR_WRITE_4(sc, TI_MB_CMDPROD_IDX, 0);\n\tsc->ti_cmd_saved_prodidx = 0;\n\n\t/*\n\t * Assign the address of the stats refresh buffer.\n\t * We re-use the current stats buffer for this to\n\t * conserve memory.\n\t */\n\tTI_HOSTADDR(sc->ti_rdata->ti_info.ti_refresh_stats_ptr) =\n\t    vtophys(&sc->ti_rdata->ti_info.ti_stats);\n\n\t/* Set up the standard receive ring. */\n\trcb = &sc->ti_rdata->ti_info.ti_std_rx_rcb;\n\tTI_HOSTADDR(rcb->ti_hostaddr) = vtophys(&sc->ti_rdata->ti_rx_std_ring);\n\trcb->ti_max_len = TI_FRAMELEN;\n\trcb->ti_flags = 0;\n#ifdef TI_CSUM_OFFLOAD\n\trcb->ti_flags |= TI_RCB_FLAG_TCP_UDP_CKSUM|TI_RCB_FLAG_IP_CKSUM;\n#endif\n#if NVLAN > 0\n\trcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;\n#endif\n\n\t/* Set up the jumbo receive ring. */\n\trcb = &sc->ti_rdata->ti_info.ti_jumbo_rx_rcb;\n\tTI_HOSTADDR(rcb->ti_hostaddr) =\n\t    vtophys(&sc->ti_rdata->ti_rx_jumbo_ring);\n\trcb->ti_max_len = TI_JUMBO_FRAMELEN;\n\trcb->ti_flags = 0;\n#ifdef TI_CSUM_OFFLOAD\n\trcb->ti_flags |= TI_RCB_FLAG_TCP_UDP_CKSUM|TI_RCB_FLAG_IP_CKSUM;\n#endif\n#if NVLAN > 0\n\trcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;\n#endif\n\n\t/*\n\t * Set up the mini ring. Only activated on the\n\t * Tigon 2 but the slot in the config block is\n\t * still there on the Tigon 1.\n\t */\n\trcb = &sc->ti_rdata->ti_info.ti_mini_rx_rcb;\n\tTI_HOSTADDR(rcb->ti_hostaddr) =\n\t    vtophys(&sc->ti_rdata->ti_rx_mini_ring);\n\trcb->ti_max_len = MHLEN - ETHER_ALIGN;\n\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\trcb->ti_flags = TI_RCB_FLAG_RING_DISABLED;\n\telse\n\t\trcb->ti_flags = 0;\n#ifdef TI_CSUM_OFFLOAD\n\trcb->ti_flags |= TI_RCB_FLAG_TCP_UDP_CKSUM|TI_RCB_FLAG_IP_CKSUM;\n#endif\n#if NVLAN > 0\n\trcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;\n#endif\n\n\t/*\n\t * Set up the receive return ring.\n\t */\n\trcb = &sc->ti_rdata->ti_info.ti_return_rcb;\n\tTI_HOSTADDR(rcb->ti_hostaddr) =\n\t    vtophys(&sc->ti_rdata->ti_rx_return_ring);\n\trcb->ti_flags = 0;\n\trcb->ti_max_len = TI_RETURN_RING_CNT;\n\tTI_HOSTADDR(sc->ti_rdata->ti_info.ti_return_prodidx_ptr) =\n\t    vtophys(&sc->ti_return_prodidx);\n\n\t/*\n\t * Set up the tx ring. Note: for the Tigon 2, we have the option\n\t * of putting the transmit ring in the host's address space and\n\t * letting the chip DMA it instead of leaving the ring in the NIC's\n\t * memory and accessing it through the shared memory region. We\n\t * do this for the Tigon 2, but it doesn't work on the Tigon 1,\n\t * so we have to revert to the shared memory scheme if we detect\n\t * a Tigon 1 chip.\n\t */\n\tCSR_WRITE_4(sc, TI_WINBASE, TI_TX_RING_BASE);\n\tif (sc->ti_hwrev == TI_HWREV_TIGON) {\n\t\tsc->ti_rdata->ti_tx_ring_nic =\n\t\t    (struct ti_tx_desc *)(sc->ti_bhandle + TI_WINDOW);\n\t}\n\tbzero((char *)sc->ti_rdata->ti_tx_ring,\n\t    TI_TX_RING_CNT * sizeof(struct ti_tx_desc));\n\trcb = &sc->ti_rdata->ti_info.ti_tx_rcb;\n\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\trcb->ti_flags = 0;\n\telse\n\t\trcb->ti_flags = TI_RCB_FLAG_HOST_RING;\n#if NVLAN > 0\n\trcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;\n#endif\n\trcb->ti_max_len = TI_TX_RING_CNT;\n\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\tTI_HOSTADDR(rcb->ti_hostaddr) = TI_TX_RING_BASE;\n\telse\n\t\tTI_HOSTADDR(rcb->ti_hostaddr) =\n\t\t    vtophys(&sc->ti_rdata->ti_tx_ring);\n\tTI_HOSTADDR(sc->ti_rdata->ti_info.ti_tx_considx_ptr) =\n\t    vtophys(&sc->ti_tx_considx);\n\n\t/* Set up tuneables */\n\tif (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))\n\t\tCSR_WRITE_4(sc, TI_GCR_RX_COAL_TICKS,\n\t\t    (sc->ti_rx_coal_ticks / 10));\n\telse\n\t\tCSR_WRITE_4(sc, TI_GCR_RX_COAL_TICKS, sc->ti_rx_coal_ticks);\n\tCSR_WRITE_4(sc, TI_GCR_TX_COAL_TICKS, sc->ti_tx_coal_ticks);\n\tCSR_WRITE_4(sc, TI_GCR_STAT_TICKS, sc->ti_stat_ticks);\n\tCSR_WRITE_4(sc, TI_GCR_RX_MAX_COAL_BD, sc->ti_rx_max_coal_bds);\n\tCSR_WRITE_4(sc, TI_GCR_TX_MAX_COAL_BD, sc->ti_tx_max_coal_bds);\n\tCSR_WRITE_4(sc, TI_GCR_TX_BUFFER_RATIO, sc->ti_tx_buf_ratio);\n\n\t/* Turn interrupts on. */\n\tCSR_WRITE_4(sc, TI_GCR_MASK_INTRS, 0);\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 0);\n\n\t/* Start CPU. */\n\tTI_CLRBIT(sc, TI_CPU_STATE, (TI_CPUSTATE_HALT|TI_CPUSTATE_STEP));\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_stop",
          "args": [
            "sc"
          ],
          "line": 2098
        },
        "resolved": true,
        "details": {
          "function_name": "ti_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "2394-2434",
          "snippet": "void ti_stop(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct ti_cmd_desc\tcmd;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Disable host interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);\n\t/*\n\t * Tell firmware we're shutting down.\n\t */\n\tTI_DO_CMD(TI_CMD_HOST_STATE, TI_CMD_CODE_STACK_DOWN, 0);\n\n\t/* Halt and reinitialize. */\n\tti_chipinit(sc);\n\tti_mem(sc, 0x2000, 0x100000 - 0x2000, NULL);\n\tti_chipinit(sc);\n\n\t/* Free the RX lists. */\n\tti_free_rx_ring_std(sc);\n\n\t/* Free jumbo RX list. */\n\tti_free_rx_ring_jumbo(sc);\n\n\t/* Free mini RX list. */\n\tti_free_rx_ring_mini(sc);\n\n\t/* Free TX buffers. */\n\tti_free_tx_ring(sc);\n\n\tsc->ti_ev_prodidx.ti_idx = 0;\n\tsc->ti_return_prodidx.ti_idx = 0;\n\tsc->ti_tx_considx.ti_idx = 0;\n\tsc->ti_tx_saved_considx = TI_TXCONS_UNSET;\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_stop",
            "void ti_mem",
            "void ti_free_rx_ring_std",
            "void ti_free_rx_ring_jumbo",
            "void ti_free_rx_ring_mini",
            "void ti_free_tx_ring",
            "int ti_chipinit",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_stop;\nvoid ti_mem;\nvoid ti_free_rx_ring_std;\nvoid ti_free_rx_ring_jumbo;\nvoid ti_free_rx_ring_mini;\nvoid ti_free_tx_ring;\nint ti_chipinit;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_stop(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct ti_cmd_desc\tcmd;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Disable host interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);\n\t/*\n\t * Tell firmware we're shutting down.\n\t */\n\tTI_DO_CMD(TI_CMD_HOST_STATE, TI_CMD_CODE_STACK_DOWN, 0);\n\n\t/* Halt and reinitialize. */\n\tti_chipinit(sc);\n\tti_mem(sc, 0x2000, 0x100000 - 0x2000, NULL);\n\tti_chipinit(sc);\n\n\t/* Free the RX lists. */\n\tti_free_rx_ring_std(sc);\n\n\t/* Free jumbo RX list. */\n\tti_free_rx_ring_jumbo(sc);\n\n\t/* Free mini RX list. */\n\tti_free_rx_ring_mini(sc);\n\n\t/* Free TX buffers. */\n\tti_free_tx_ring(sc);\n\n\tsc->ti_ev_prodidx.ti_idx = 0;\n\tsc->ti_return_prodidx.ti_idx = 0;\n\tsc->ti_tx_considx.ti_idx = 0;\n\tsc->ti_tx_saved_considx = TI_TXCONS_UNSET;\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_init;\nvoid ti_stop;\nint ti_gibinit;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct ti_softc\t\t*sc = xsc;\n        int\t\t\ts;\n\n\ts = splimp();\n\n\t/* Cancel pending I/O and flush buffers. */\n\tti_stop(sc);\n\n\t/* Init the gen info block, ring control blocks and firmware. */\n\tif (ti_gibinit(sc)) {\n\t\tprintf(\"%s: initialization failure\\n\", sc->sc_dv.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\tsplx(s);\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "2041-2087",
    "snippet": "void ti_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct ti_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tu_int32_t\t\tprodidx = 0;\n\n\tsc = ifp->if_softc;\n\n\tprodidx = CSR_READ_4(sc, TI_MB_SENDPROD_IDX);\n\n\twhile(sc->ti_cdata.ti_tx_chain[prodidx] == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Pack the data into the transmit ring. If we\n\t\t * don't have room, set the OACTIVE flag and wait\n\t\t * for the NIC to drain the ring.\n\t\t */\n\t\tif (ti_encap(sc, m_head, &prodidx)) {\n\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m_head);\n#endif\n\t}\n\n\t/* Transmit */\n\tCSR_WRITE_4(sc, TI_MB_SENDPROD_IDX, prodidx);\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ti_encap",
      "void ti_start",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_MB_SENDPROD_IDX",
            "prodidx"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m_head"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_PREPEND",
          "args": [
            "&ifp->if_snd",
            "m_head"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ti_encap",
          "args": [
            "sc",
            "m_head",
            "&prodidx"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "ti_encap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "1950-2035",
          "snippet": "int ti_encap(sc, m_head, txidx)\n\tstruct ti_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head;\n\tu_int32_t\t\t*txidx;\n{\n\tstruct ti_tx_desc\t*f = NULL;\n\tstruct mbuf\t\t*m;\n\tu_int32_t\t\tfrag, cur, cnt = 0;\n#if NVLAN > 0\n\tstruct ifvlan\t\t*ifv = NULL;\n\n\tif ((m_head->m_flags & (M_PROTO1|M_PKTHDR)) == (M_PROTO1|M_PKTHDR) &&\n\t    m_head->m_pkthdr.rcvif != NULL &&\n\t    m_head->m_pkthdr.rcvif->if_type == IFT_8021_VLAN)\n\t\tifv = m_head->m_pkthdr.rcvif->if_softc;\n#endif\n\n\tm = m_head;\n\tcur = frag = *txidx;\n\n\t/*\n \t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n \t * of fragments or hit the end of the mbuf chain.\n\t */\n\tfor (m = m_head; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (sc->ti_hwrev == TI_HWREV_TIGON) {\n\t\t\t\tif (frag > 383)\n\t\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t\t    TI_TX_RING_BASE + 6144);\n\t\t\t\telse if (frag > 255)\n\t\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t\t    TI_TX_RING_BASE + 4096);\n\t\t\t\telse if (frag > 127)\n\t\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t\t    TI_TX_RING_BASE + 2048);\n\t\t\t\telse\n\t\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t\t    TI_TX_RING_BASE);\n\t\t\t\tf = &sc->ti_rdata->ti_tx_ring_nic[frag % 128];\n\t\t\t} else\n\t\t\t\tf = &sc->ti_rdata->ti_tx_ring[frag];\n\t\t\tif (sc->ti_cdata.ti_tx_chain[frag] != NULL)\n\t\t\t\tbreak;\n\t\t\tTI_HOSTADDR(f->ti_addr) = vtophys(mtod(m, vm_offset_t));\n\t\t\tf->ti_len = m->m_len;\n\t\t\tf->ti_flags = 0;\n#if NVLAN > 0\n\t\t\tif (ifv != NULL) {\n\t\t\t\tf->ti_flags |= TI_BDFLAG_VLAN_TAG;\n\t\t\t\tf->ti_vlan_tag = ifv->ifv_tag;\n\t\t\t} else {\n\t\t\t\tf->ti_vlan_tag = 0;\n\t\t\t}\n#endif\n\t\t\t/*\n\t\t\t * Sanity check: avoid coming within 16 descriptors\n\t\t\t * of the end of the ring.\n\t\t\t */\n\t\t\tif ((TI_TX_RING_CNT - (sc->ti_txcnt + cnt)) < 16)\n\t\t\t\treturn(ENOBUFS);\n\t\t\tcur = frag;\n\t\t\tTI_INC(frag, TI_TX_RING_CNT);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tif (m != NULL)\n\t\treturn(ENOBUFS);\n\n\tif (frag == sc->ti_tx_saved_considx)\n\t\treturn(ENOBUFS);\n\n\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\tsc->ti_rdata->ti_tx_ring_nic[cur % 128].ti_flags |=\n\t\t    TI_BDFLAG_END;\n\telse\n\t\tsc->ti_rdata->ti_tx_ring[cur].ti_flags |= TI_BDFLAG_END;\n\tsc->ti_cdata.ti_tx_chain[cur] = m_head;\n\tsc->ti_txcnt += cnt;\n\n\t*txidx = frag;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int ti_encap",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_encap;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_encap(sc, m_head, txidx)\n\tstruct ti_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head;\n\tu_int32_t\t\t*txidx;\n{\n\tstruct ti_tx_desc\t*f = NULL;\n\tstruct mbuf\t\t*m;\n\tu_int32_t\t\tfrag, cur, cnt = 0;\n#if NVLAN > 0\n\tstruct ifvlan\t\t*ifv = NULL;\n\n\tif ((m_head->m_flags & (M_PROTO1|M_PKTHDR)) == (M_PROTO1|M_PKTHDR) &&\n\t    m_head->m_pkthdr.rcvif != NULL &&\n\t    m_head->m_pkthdr.rcvif->if_type == IFT_8021_VLAN)\n\t\tifv = m_head->m_pkthdr.rcvif->if_softc;\n#endif\n\n\tm = m_head;\n\tcur = frag = *txidx;\n\n\t/*\n \t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n \t * of fragments or hit the end of the mbuf chain.\n\t */\n\tfor (m = m_head; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (sc->ti_hwrev == TI_HWREV_TIGON) {\n\t\t\t\tif (frag > 383)\n\t\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t\t    TI_TX_RING_BASE + 6144);\n\t\t\t\telse if (frag > 255)\n\t\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t\t    TI_TX_RING_BASE + 4096);\n\t\t\t\telse if (frag > 127)\n\t\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t\t    TI_TX_RING_BASE + 2048);\n\t\t\t\telse\n\t\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t\t    TI_TX_RING_BASE);\n\t\t\t\tf = &sc->ti_rdata->ti_tx_ring_nic[frag % 128];\n\t\t\t} else\n\t\t\t\tf = &sc->ti_rdata->ti_tx_ring[frag];\n\t\t\tif (sc->ti_cdata.ti_tx_chain[frag] != NULL)\n\t\t\t\tbreak;\n\t\t\tTI_HOSTADDR(f->ti_addr) = vtophys(mtod(m, vm_offset_t));\n\t\t\tf->ti_len = m->m_len;\n\t\t\tf->ti_flags = 0;\n#if NVLAN > 0\n\t\t\tif (ifv != NULL) {\n\t\t\t\tf->ti_flags |= TI_BDFLAG_VLAN_TAG;\n\t\t\t\tf->ti_vlan_tag = ifv->ifv_tag;\n\t\t\t} else {\n\t\t\t\tf->ti_vlan_tag = 0;\n\t\t\t}\n#endif\n\t\t\t/*\n\t\t\t * Sanity check: avoid coming within 16 descriptors\n\t\t\t * of the end of the ring.\n\t\t\t */\n\t\t\tif ((TI_TX_RING_CNT - (sc->ti_txcnt + cnt)) < 16)\n\t\t\t\treturn(ENOBUFS);\n\t\t\tcur = frag;\n\t\t\tTI_INC(frag, TI_TX_RING_CNT);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tif (m != NULL)\n\t\treturn(ENOBUFS);\n\n\tif (frag == sc->ti_tx_saved_considx)\n\t\treturn(ENOBUFS);\n\n\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\tsc->ti_rdata->ti_tx_ring_nic[cur % 128].ti_flags |=\n\t\t    TI_BDFLAG_END;\n\telse\n\t\tsc->ti_rdata->ti_tx_ring[cur].ti_flags |= TI_BDFLAG_END;\n\tsc->ti_cdata.ti_tx_chain[cur] = m_head;\n\tsc->ti_txcnt += cnt;\n\n\t*txidx = frag;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m_head"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TI_MB_SENDPROD_IDX"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_encap;\nvoid ti_start;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct ti_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tu_int32_t\t\tprodidx = 0;\n\n\tsc = ifp->if_softc;\n\n\tprodidx = CSR_READ_4(sc, TI_MB_SENDPROD_IDX);\n\n\twhile(sc->ti_cdata.ti_tx_chain[prodidx] == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Pack the data into the transmit ring. If we\n\t\t * don't have room, set the OACTIVE flag and wait\n\t\t * for the NIC to drain the ring.\n\t\t */\n\t\tif (ti_encap(sc, m_head, &prodidx)) {\n\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m_head);\n#endif\n\t}\n\n\t/* Transmit */\n\tCSR_WRITE_4(sc, TI_MB_SENDPROD_IDX, prodidx);\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_encap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "1950-2035",
    "snippet": "int ti_encap(sc, m_head, txidx)\n\tstruct ti_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head;\n\tu_int32_t\t\t*txidx;\n{\n\tstruct ti_tx_desc\t*f = NULL;\n\tstruct mbuf\t\t*m;\n\tu_int32_t\t\tfrag, cur, cnt = 0;\n#if NVLAN > 0\n\tstruct ifvlan\t\t*ifv = NULL;\n\n\tif ((m_head->m_flags & (M_PROTO1|M_PKTHDR)) == (M_PROTO1|M_PKTHDR) &&\n\t    m_head->m_pkthdr.rcvif != NULL &&\n\t    m_head->m_pkthdr.rcvif->if_type == IFT_8021_VLAN)\n\t\tifv = m_head->m_pkthdr.rcvif->if_softc;\n#endif\n\n\tm = m_head;\n\tcur = frag = *txidx;\n\n\t/*\n \t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n \t * of fragments or hit the end of the mbuf chain.\n\t */\n\tfor (m = m_head; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (sc->ti_hwrev == TI_HWREV_TIGON) {\n\t\t\t\tif (frag > 383)\n\t\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t\t    TI_TX_RING_BASE + 6144);\n\t\t\t\telse if (frag > 255)\n\t\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t\t    TI_TX_RING_BASE + 4096);\n\t\t\t\telse if (frag > 127)\n\t\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t\t    TI_TX_RING_BASE + 2048);\n\t\t\t\telse\n\t\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t\t    TI_TX_RING_BASE);\n\t\t\t\tf = &sc->ti_rdata->ti_tx_ring_nic[frag % 128];\n\t\t\t} else\n\t\t\t\tf = &sc->ti_rdata->ti_tx_ring[frag];\n\t\t\tif (sc->ti_cdata.ti_tx_chain[frag] != NULL)\n\t\t\t\tbreak;\n\t\t\tTI_HOSTADDR(f->ti_addr) = vtophys(mtod(m, vm_offset_t));\n\t\t\tf->ti_len = m->m_len;\n\t\t\tf->ti_flags = 0;\n#if NVLAN > 0\n\t\t\tif (ifv != NULL) {\n\t\t\t\tf->ti_flags |= TI_BDFLAG_VLAN_TAG;\n\t\t\t\tf->ti_vlan_tag = ifv->ifv_tag;\n\t\t\t} else {\n\t\t\t\tf->ti_vlan_tag = 0;\n\t\t\t}\n#endif\n\t\t\t/*\n\t\t\t * Sanity check: avoid coming within 16 descriptors\n\t\t\t * of the end of the ring.\n\t\t\t */\n\t\t\tif ((TI_TX_RING_CNT - (sc->ti_txcnt + cnt)) < 16)\n\t\t\t\treturn(ENOBUFS);\n\t\t\tcur = frag;\n\t\t\tTI_INC(frag, TI_TX_RING_CNT);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tif (m != NULL)\n\t\treturn(ENOBUFS);\n\n\tif (frag == sc->ti_tx_saved_considx)\n\t\treturn(ENOBUFS);\n\n\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\tsc->ti_rdata->ti_tx_ring_nic[cur % 128].ti_flags |=\n\t\t    TI_BDFLAG_END;\n\telse\n\t\tsc->ti_rdata->ti_tx_ring[cur].ti_flags |= TI_BDFLAG_END;\n\tsc->ti_cdata.ti_tx_chain[cur] = m_head;\n\tsc->ti_txcnt += cnt;\n\n\t*txidx = frag;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ti_encap",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TI_INC",
          "args": [
            "frag",
            "TI_TX_RING_CNT"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m, vm_offset_t)"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "vm_offset_t"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_HOSTADDR",
          "args": [
            "f->ti_addr"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_WINBASE",
            "TI_TX_RING_BASE"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_WINBASE",
            "TI_TX_RING_BASE + 2048"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_WINBASE",
            "TI_TX_RING_BASE + 4096"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_WINBASE",
            "TI_TX_RING_BASE + 6144"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_encap;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_encap(sc, m_head, txidx)\n\tstruct ti_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head;\n\tu_int32_t\t\t*txidx;\n{\n\tstruct ti_tx_desc\t*f = NULL;\n\tstruct mbuf\t\t*m;\n\tu_int32_t\t\tfrag, cur, cnt = 0;\n#if NVLAN > 0\n\tstruct ifvlan\t\t*ifv = NULL;\n\n\tif ((m_head->m_flags & (M_PROTO1|M_PKTHDR)) == (M_PROTO1|M_PKTHDR) &&\n\t    m_head->m_pkthdr.rcvif != NULL &&\n\t    m_head->m_pkthdr.rcvif->if_type == IFT_8021_VLAN)\n\t\tifv = m_head->m_pkthdr.rcvif->if_softc;\n#endif\n\n\tm = m_head;\n\tcur = frag = *txidx;\n\n\t/*\n \t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n \t * of fragments or hit the end of the mbuf chain.\n\t */\n\tfor (m = m_head; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (sc->ti_hwrev == TI_HWREV_TIGON) {\n\t\t\t\tif (frag > 383)\n\t\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t\t    TI_TX_RING_BASE + 6144);\n\t\t\t\telse if (frag > 255)\n\t\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t\t    TI_TX_RING_BASE + 4096);\n\t\t\t\telse if (frag > 127)\n\t\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t\t    TI_TX_RING_BASE + 2048);\n\t\t\t\telse\n\t\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t\t    TI_TX_RING_BASE);\n\t\t\t\tf = &sc->ti_rdata->ti_tx_ring_nic[frag % 128];\n\t\t\t} else\n\t\t\t\tf = &sc->ti_rdata->ti_tx_ring[frag];\n\t\t\tif (sc->ti_cdata.ti_tx_chain[frag] != NULL)\n\t\t\t\tbreak;\n\t\t\tTI_HOSTADDR(f->ti_addr) = vtophys(mtod(m, vm_offset_t));\n\t\t\tf->ti_len = m->m_len;\n\t\t\tf->ti_flags = 0;\n#if NVLAN > 0\n\t\t\tif (ifv != NULL) {\n\t\t\t\tf->ti_flags |= TI_BDFLAG_VLAN_TAG;\n\t\t\t\tf->ti_vlan_tag = ifv->ifv_tag;\n\t\t\t} else {\n\t\t\t\tf->ti_vlan_tag = 0;\n\t\t\t}\n#endif\n\t\t\t/*\n\t\t\t * Sanity check: avoid coming within 16 descriptors\n\t\t\t * of the end of the ring.\n\t\t\t */\n\t\t\tif ((TI_TX_RING_CNT - (sc->ti_txcnt + cnt)) < 16)\n\t\t\t\treturn(ENOBUFS);\n\t\t\tcur = frag;\n\t\t\tTI_INC(frag, TI_TX_RING_CNT);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tif (m != NULL)\n\t\treturn(ENOBUFS);\n\n\tif (frag == sc->ti_tx_saved_considx)\n\t\treturn(ENOBUFS);\n\n\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\tsc->ti_rdata->ti_tx_ring_nic[cur % 128].ti_flags |=\n\t\t    TI_BDFLAG_END;\n\telse\n\t\tsc->ti_rdata->ti_tx_ring[cur].ti_flags |= TI_BDFLAG_END;\n\tsc->ti_cdata.ti_tx_chain[cur] = m_head;\n\tsc->ti_txcnt += cnt;\n\n\t*txidx = frag;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "ti_stats_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "1929-1944",
    "snippet": "void ti_stats_update(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tifp->if_collisions +=\n\t   (sc->ti_rdata->ti_info.ti_stats.dot3StatsSingleCollisionFrames +\n\t   sc->ti_rdata->ti_info.ti_stats.dot3StatsMultipleCollisionFrames +\n\t   sc->ti_rdata->ti_info.ti_stats.dot3StatsExcessiveCollisions +\n\t   sc->ti_rdata->ti_info.ti_stats.dot3StatsLateCollisions) -\n\t   ifp->if_collisions;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_stats_update",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_stats_update;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_stats_update(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tifp->if_collisions +=\n\t   (sc->ti_rdata->ti_info.ti_stats.dot3StatsSingleCollisionFrames +\n\t   sc->ti_rdata->ti_info.ti_stats.dot3StatsMultipleCollisionFrames +\n\t   sc->ti_rdata->ti_info.ti_stats.dot3StatsExcessiveCollisions +\n\t   sc->ti_rdata->ti_info.ti_stats.dot3StatsLateCollisions) -\n\t   ifp->if_collisions;\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "1888-1927",
    "snippet": "int ti_intr(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct ti_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\tclaimed = 0;\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\n#ifdef notdef\n\t/* Avoid this for now -- checking this register is expensive. */\n\t/* Make sure this is really our interrupt. */\n\tif (!(CSR_READ_4(sc, TI_MISC_HOST_CTL) & TI_MHC_INTSTATE))\n\t\treturn;\n#endif\n\n\t/* Ack interrupt and stop others from occuring. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);\n\n\tif (ifp->if_flags & IFF_RUNNING) {\n\t\tclaimed = 1;\n\n\t\t/* Check RX return ring producer/consumer */\n\t\tti_rxeof(sc);\n\n\t\t/* Check TX ring producer/consumer */\n\t\tti_txeof(sc);\n\t}\n\n\tti_handle_events(sc);\n\n\t/* Re-enable interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 0);\n\n\tif (ifp->if_flags & IFF_RUNNING && ifp->if_snd.ifq_head != NULL)\n\t\tti_start(ifp);\n\n\treturn (claimed);\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_txeof",
      "void ti_rxeof",
      "int ti_intr",
      "void ti_start",
      "void ti_handle_events",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ti_start",
          "args": [
            "ifp"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "ti_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "2041-2087",
          "snippet": "void ti_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct ti_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tu_int32_t\t\tprodidx = 0;\n\n\tsc = ifp->if_softc;\n\n\tprodidx = CSR_READ_4(sc, TI_MB_SENDPROD_IDX);\n\n\twhile(sc->ti_cdata.ti_tx_chain[prodidx] == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Pack the data into the transmit ring. If we\n\t\t * don't have room, set the OACTIVE flag and wait\n\t\t * for the NIC to drain the ring.\n\t\t */\n\t\tif (ti_encap(sc, m_head, &prodidx)) {\n\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m_head);\n#endif\n\t}\n\n\t/* Transmit */\n\tCSR_WRITE_4(sc, TI_MB_SENDPROD_IDX, prodidx);\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int ti_encap",
            "void ti_start",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_encap;\nvoid ti_start;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct ti_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tu_int32_t\t\tprodidx = 0;\n\n\tsc = ifp->if_softc;\n\n\tprodidx = CSR_READ_4(sc, TI_MB_SENDPROD_IDX);\n\n\twhile(sc->ti_cdata.ti_tx_chain[prodidx] == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Pack the data into the transmit ring. If we\n\t\t * don't have room, set the OACTIVE flag and wait\n\t\t * for the NIC to drain the ring.\n\t\t */\n\t\tif (ti_encap(sc, m_head, &prodidx)) {\n\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m_head);\n#endif\n\t}\n\n\t/* Transmit */\n\tCSR_WRITE_4(sc, TI_MB_SENDPROD_IDX, prodidx);\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_MB_HOSTINTR",
            "0"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ti_handle_events",
          "args": [
            "sc"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "ti_handle_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "481-527",
          "snippet": "void ti_handle_events(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ti_event_desc\t*e;\n\n\tif (sc->ti_rdata->ti_event_ring == NULL)\n\t\treturn;\n\n\twhile (sc->ti_ev_saved_considx != sc->ti_ev_prodidx.ti_idx) {\n\t\te = &sc->ti_rdata->ti_event_ring[sc->ti_ev_saved_considx];\n\t\tswitch(e->ti_event) {\n\t\tcase TI_EV_LINKSTAT_CHANGED:\n\t\t\tsc->ti_linkstat = e->ti_code;\n\t\t\tbreak;\n\t\tcase TI_EV_ERROR:\n\t\t\tif (e->ti_code == TI_EV_CODE_ERR_INVAL_CMD)\n\t\t\t\tprintf(\"%s: invalid command\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname);\n\t\t\telse if (e->ti_code == TI_EV_CODE_ERR_UNIMP_CMD)\n\t\t\t\tprintf(\"%s: unknown command\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname);\n\t\t\telse if (e->ti_code == TI_EV_CODE_ERR_BADCFG)\n\t\t\t\tprintf(\"%s: bad config data\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname);\n\t\t\tbreak;\n\t\tcase TI_EV_FIRMWARE_UP:\n\t\t\tti_init2(sc);\n\t\t\tbreak;\n\t\tcase TI_EV_STATS_UPDATED:\n\t\t\tti_stats_update(sc);\n\t\t\tbreak;\n\t\tcase TI_EV_RESET_JUMBO_RING:\n\t\tcase TI_EV_MCAST_UPDATED:\n\t\t\t/* Who cares. */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"%s: unknown event: %d\\n\",\n\t\t\t    sc->sc_dv.dv_xname, e->ti_event);\n\t\t\tbreak;\n\t\t}\n\t\t/* Advance the consumer index. */\n\t\tTI_INC(sc->ti_ev_saved_considx, TI_EVENT_RING_CNT);\n\t\tCSR_WRITE_4(sc, TI_GCR_EVENTCONS_IDX, sc->ti_ev_saved_considx);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_stats_update",
            "void ti_init2",
            "void ti_handle_events",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_stats_update;\nvoid ti_init2;\nvoid ti_handle_events;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_handle_events(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ti_event_desc\t*e;\n\n\tif (sc->ti_rdata->ti_event_ring == NULL)\n\t\treturn;\n\n\twhile (sc->ti_ev_saved_considx != sc->ti_ev_prodidx.ti_idx) {\n\t\te = &sc->ti_rdata->ti_event_ring[sc->ti_ev_saved_considx];\n\t\tswitch(e->ti_event) {\n\t\tcase TI_EV_LINKSTAT_CHANGED:\n\t\t\tsc->ti_linkstat = e->ti_code;\n\t\t\tbreak;\n\t\tcase TI_EV_ERROR:\n\t\t\tif (e->ti_code == TI_EV_CODE_ERR_INVAL_CMD)\n\t\t\t\tprintf(\"%s: invalid command\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname);\n\t\t\telse if (e->ti_code == TI_EV_CODE_ERR_UNIMP_CMD)\n\t\t\t\tprintf(\"%s: unknown command\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname);\n\t\t\telse if (e->ti_code == TI_EV_CODE_ERR_BADCFG)\n\t\t\t\tprintf(\"%s: bad config data\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname);\n\t\t\tbreak;\n\t\tcase TI_EV_FIRMWARE_UP:\n\t\t\tti_init2(sc);\n\t\t\tbreak;\n\t\tcase TI_EV_STATS_UPDATED:\n\t\t\tti_stats_update(sc);\n\t\t\tbreak;\n\t\tcase TI_EV_RESET_JUMBO_RING:\n\t\tcase TI_EV_MCAST_UPDATED:\n\t\t\t/* Who cares. */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"%s: unknown event: %d\\n\",\n\t\t\t    sc->sc_dv.dv_xname, e->ti_event);\n\t\t\tbreak;\n\t\t}\n\t\t/* Advance the consumer index. */\n\t\tTI_INC(sc->ti_ev_saved_considx, TI_EVENT_RING_CNT);\n\t\tCSR_WRITE_4(sc, TI_GCR_EVENTCONS_IDX, sc->ti_ev_saved_considx);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_txeof",
          "args": [
            "sc"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "ti_txeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "1839-1886",
          "snippet": "void ti_txeof(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ti_tx_desc\t*cur_tx = NULL;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * Go through our tx ring and free mbufs for those\n\t * frames that have been sent.\n\t */\n\twhile (sc->ti_tx_saved_considx != sc->ti_tx_considx.ti_idx) {\n\t\tu_int32_t\t\tidx = 0;\n\n\t\tidx = sc->ti_tx_saved_considx;\n\t\tif (sc->ti_hwrev == TI_HWREV_TIGON) {\n\t\t\tif (idx > 383)\n\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t    TI_TX_RING_BASE + 6144);\n\t\t\telse if (idx > 255)\n\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t    TI_TX_RING_BASE + 4096);\n\t\t\telse if (idx > 127)\n\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t    TI_TX_RING_BASE + 2048);\n\t\t\telse\n\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t    TI_TX_RING_BASE);\n\t\t\tcur_tx = &sc->ti_rdata->ti_tx_ring_nic[idx % 128];\n\t\t} else\n\t\t\tcur_tx = &sc->ti_rdata->ti_tx_ring[idx];\n\t\tif (cur_tx->ti_flags & TI_BDFLAG_END)\n\t\t\tifp->if_opackets++;\n\t\tif (sc->ti_cdata.ti_tx_chain[idx] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_tx_chain[idx]);\n\t\t\tsc->ti_cdata.ti_tx_chain[idx] = NULL;\n\t\t}\n\t\tsc->ti_txcnt--;\n\t\tTI_INC(sc->ti_tx_saved_considx, TI_TX_RING_CNT);\n\t\tifp->if_timer = 0;\n\t}\n\n\tif (cur_tx != NULL)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_txeof",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_txeof;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_txeof(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ti_tx_desc\t*cur_tx = NULL;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * Go through our tx ring and free mbufs for those\n\t * frames that have been sent.\n\t */\n\twhile (sc->ti_tx_saved_considx != sc->ti_tx_considx.ti_idx) {\n\t\tu_int32_t\t\tidx = 0;\n\n\t\tidx = sc->ti_tx_saved_considx;\n\t\tif (sc->ti_hwrev == TI_HWREV_TIGON) {\n\t\t\tif (idx > 383)\n\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t    TI_TX_RING_BASE + 6144);\n\t\t\telse if (idx > 255)\n\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t    TI_TX_RING_BASE + 4096);\n\t\t\telse if (idx > 127)\n\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t    TI_TX_RING_BASE + 2048);\n\t\t\telse\n\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t    TI_TX_RING_BASE);\n\t\t\tcur_tx = &sc->ti_rdata->ti_tx_ring_nic[idx % 128];\n\t\t} else\n\t\t\tcur_tx = &sc->ti_rdata->ti_tx_ring[idx];\n\t\tif (cur_tx->ti_flags & TI_BDFLAG_END)\n\t\t\tifp->if_opackets++;\n\t\tif (sc->ti_cdata.ti_tx_chain[idx] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_tx_chain[idx]);\n\t\t\tsc->ti_cdata.ti_tx_chain[idx] = NULL;\n\t\t}\n\t\tsc->ti_txcnt--;\n\t\tTI_INC(sc->ti_tx_saved_considx, TI_TX_RING_CNT);\n\t\tifp->if_timer = 0;\n\t}\n\n\tif (cur_tx != NULL)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_rxeof",
          "args": [
            "sc"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "ti_rxeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "1712-1837",
          "snippet": "void ti_rxeof(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct ti_cmd_desc\tcmd;\n\n\tifp = &sc->arpcom.ac_if;\n\n\twhile(sc->ti_rx_saved_considx != sc->ti_return_prodidx.ti_idx) {\n\t\tstruct ti_rx_desc\t*cur_rx;\n\t\tu_int32_t\t\trxidx;\n\t\tstruct ether_header\t*eh;\n\t\tstruct mbuf\t\t*m = NULL;\n#if NVLAN > 0\n\t\tu_int16_t\t\tvlan_tag = 0;\n\t\tint\t\t\thave_tag = 0;\n#endif\n#ifdef TI_CSUM_OFFLOAD\n\t\tstruct ip\t\t*ip;\n#endif\n\n\t\tcur_rx =\n\t\t    &sc->ti_rdata->ti_rx_return_ring[sc->ti_rx_saved_considx];\n\t\trxidx = cur_rx->ti_idx;\n\t\tTI_INC(sc->ti_rx_saved_considx, TI_RETURN_RING_CNT);\n\n#if NVLAN > 0\n\t\tif (cur_rx->ti_flags & TI_BDFLAG_VLAN_TAG) {\n\t\t\thave_tag = 1;\n\t\t\tvlan_tag = cur_rx->ti_vlan_tag;\n\t\t}\n#endif\n\n\t\tif (cur_rx->ti_flags & TI_BDFLAG_JUMBO_RING) {\n\t\t\tTI_INC(sc->ti_jumbo, TI_JUMBO_RX_RING_CNT);\n\t\t\tm = sc->ti_cdata.ti_rx_jumbo_chain[rxidx];\n\t\t\tsc->ti_cdata.ti_rx_jumbo_chain[rxidx] = NULL;\n\t\t\tif (cur_rx->ti_flags & TI_BDFLAG_ERROR) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_jumbo(sc, sc->ti_jumbo, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ti_newbuf_jumbo(sc, sc->ti_jumbo, NULL) == ENOBUFS) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_jumbo(sc, sc->ti_jumbo, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (cur_rx->ti_flags & TI_BDFLAG_MINI_RING) {\n\t\t\tTI_INC(sc->ti_mini, TI_MINI_RX_RING_CNT);\n\t\t\tm = sc->ti_cdata.ti_rx_mini_chain[rxidx];\n\t\t\tsc->ti_cdata.ti_rx_mini_chain[rxidx] = NULL;\n\t\t\tif (cur_rx->ti_flags & TI_BDFLAG_ERROR) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_mini(sc, sc->ti_mini, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ti_newbuf_mini(sc, sc->ti_mini, NULL) == ENOBUFS) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_mini(sc, sc->ti_mini, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tTI_INC(sc->ti_std, TI_STD_RX_RING_CNT);\n\t\t\tm = sc->ti_cdata.ti_rx_std_chain[rxidx];\n\t\t\tsc->ti_cdata.ti_rx_std_chain[rxidx] = NULL;\n\t\t\tif (cur_rx->ti_flags & TI_BDFLAG_ERROR) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_std(sc, sc->ti_std, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ti_newbuf_std(sc, sc->ti_std, NULL) == ENOBUFS) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_std(sc, sc->ti_std, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tm->m_pkthdr.len = m->m_len = cur_rx->ti_len;\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n\n#if NBPFILTER > 0\n\t\t/*\n\t \t * Handle BPF listeners. Let the BPF user see the packet.\n\t \t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\n#ifdef TI_CSUM_OFFLOAD\n\t\tip = mtod(m, struct ip *);\n\t\tif (!(cur_rx->ti_tcp_udp_cksum ^ 0xFFFF) &&\n\t\t    !(ip->ip_off & htons(IP_MF | IP_OFFMASK | IP_RF)))\n\t\t\tm->m_flags |= M_HWCKSUM;\n#endif\n\n#if NVLAN > 0\n\t\t/*\n\t\t * If we received a packet with a vlan tag, pass it\n\t\t * to vlan_input() instead of ether_input().\n\t\t */\n\t\tif (have_tag) {\n\t\t\tif (vlan_input_tag(eh, m, vlan_tag) < 0)\n\t\t\t\tifp->if_data.ifi_noproto++;\n\t\t\thave_tag = vlan_tag = 0;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tether_input(ifp, eh, m);\n\t}\n\n\t/* Only necessary on the Tigon 1. */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\tCSR_WRITE_4(sc, TI_GCR_RXRETURNCONS_IDX,\n\t\t    sc->ti_rx_saved_considx);\n\n\tTI_UPDATE_STDPROD(sc, sc->ti_std);\n\tTI_UPDATE_MINIPROD(sc, sc->ti_mini);\n\tTI_UPDATE_JUMBOPROD(sc, sc->ti_jumbo);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_rxeof",
            "int ti_newbuf_std",
            "int ti_newbuf_mini",
            "int ti_newbuf_jumbo",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_rxeof;\nint ti_newbuf_std;\nint ti_newbuf_mini;\nint ti_newbuf_jumbo;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_rxeof(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct ti_cmd_desc\tcmd;\n\n\tifp = &sc->arpcom.ac_if;\n\n\twhile(sc->ti_rx_saved_considx != sc->ti_return_prodidx.ti_idx) {\n\t\tstruct ti_rx_desc\t*cur_rx;\n\t\tu_int32_t\t\trxidx;\n\t\tstruct ether_header\t*eh;\n\t\tstruct mbuf\t\t*m = NULL;\n#if NVLAN > 0\n\t\tu_int16_t\t\tvlan_tag = 0;\n\t\tint\t\t\thave_tag = 0;\n#endif\n#ifdef TI_CSUM_OFFLOAD\n\t\tstruct ip\t\t*ip;\n#endif\n\n\t\tcur_rx =\n\t\t    &sc->ti_rdata->ti_rx_return_ring[sc->ti_rx_saved_considx];\n\t\trxidx = cur_rx->ti_idx;\n\t\tTI_INC(sc->ti_rx_saved_considx, TI_RETURN_RING_CNT);\n\n#if NVLAN > 0\n\t\tif (cur_rx->ti_flags & TI_BDFLAG_VLAN_TAG) {\n\t\t\thave_tag = 1;\n\t\t\tvlan_tag = cur_rx->ti_vlan_tag;\n\t\t}\n#endif\n\n\t\tif (cur_rx->ti_flags & TI_BDFLAG_JUMBO_RING) {\n\t\t\tTI_INC(sc->ti_jumbo, TI_JUMBO_RX_RING_CNT);\n\t\t\tm = sc->ti_cdata.ti_rx_jumbo_chain[rxidx];\n\t\t\tsc->ti_cdata.ti_rx_jumbo_chain[rxidx] = NULL;\n\t\t\tif (cur_rx->ti_flags & TI_BDFLAG_ERROR) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_jumbo(sc, sc->ti_jumbo, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ti_newbuf_jumbo(sc, sc->ti_jumbo, NULL) == ENOBUFS) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_jumbo(sc, sc->ti_jumbo, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (cur_rx->ti_flags & TI_BDFLAG_MINI_RING) {\n\t\t\tTI_INC(sc->ti_mini, TI_MINI_RX_RING_CNT);\n\t\t\tm = sc->ti_cdata.ti_rx_mini_chain[rxidx];\n\t\t\tsc->ti_cdata.ti_rx_mini_chain[rxidx] = NULL;\n\t\t\tif (cur_rx->ti_flags & TI_BDFLAG_ERROR) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_mini(sc, sc->ti_mini, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ti_newbuf_mini(sc, sc->ti_mini, NULL) == ENOBUFS) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_mini(sc, sc->ti_mini, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tTI_INC(sc->ti_std, TI_STD_RX_RING_CNT);\n\t\t\tm = sc->ti_cdata.ti_rx_std_chain[rxidx];\n\t\t\tsc->ti_cdata.ti_rx_std_chain[rxidx] = NULL;\n\t\t\tif (cur_rx->ti_flags & TI_BDFLAG_ERROR) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_std(sc, sc->ti_std, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ti_newbuf_std(sc, sc->ti_std, NULL) == ENOBUFS) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_std(sc, sc->ti_std, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tm->m_pkthdr.len = m->m_len = cur_rx->ti_len;\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n\n#if NBPFILTER > 0\n\t\t/*\n\t \t * Handle BPF listeners. Let the BPF user see the packet.\n\t \t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\n#ifdef TI_CSUM_OFFLOAD\n\t\tip = mtod(m, struct ip *);\n\t\tif (!(cur_rx->ti_tcp_udp_cksum ^ 0xFFFF) &&\n\t\t    !(ip->ip_off & htons(IP_MF | IP_OFFMASK | IP_RF)))\n\t\t\tm->m_flags |= M_HWCKSUM;\n#endif\n\n#if NVLAN > 0\n\t\t/*\n\t\t * If we received a packet with a vlan tag, pass it\n\t\t * to vlan_input() instead of ether_input().\n\t\t */\n\t\tif (have_tag) {\n\t\t\tif (vlan_input_tag(eh, m, vlan_tag) < 0)\n\t\t\t\tifp->if_data.ifi_noproto++;\n\t\t\thave_tag = vlan_tag = 0;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tether_input(ifp, eh, m);\n\t}\n\n\t/* Only necessary on the Tigon 1. */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\tCSR_WRITE_4(sc, TI_GCR_RXRETURNCONS_IDX,\n\t\t    sc->ti_rx_saved_considx);\n\n\tTI_UPDATE_STDPROD(sc, sc->ti_std);\n\tTI_UPDATE_MINIPROD(sc, sc->ti_mini);\n\tTI_UPDATE_JUMBOPROD(sc, sc->ti_jumbo);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_MB_HOSTINTR",
            "1"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TI_MISC_HOST_CTL"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_txeof;\nvoid ti_rxeof;\nint ti_intr;\nvoid ti_start;\nvoid ti_handle_events;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_intr(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct ti_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\tclaimed = 0;\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\n#ifdef notdef\n\t/* Avoid this for now -- checking this register is expensive. */\n\t/* Make sure this is really our interrupt. */\n\tif (!(CSR_READ_4(sc, TI_MISC_HOST_CTL) & TI_MHC_INTSTATE))\n\t\treturn;\n#endif\n\n\t/* Ack interrupt and stop others from occuring. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);\n\n\tif (ifp->if_flags & IFF_RUNNING) {\n\t\tclaimed = 1;\n\n\t\t/* Check RX return ring producer/consumer */\n\t\tti_rxeof(sc);\n\n\t\t/* Check TX ring producer/consumer */\n\t\tti_txeof(sc);\n\t}\n\n\tti_handle_events(sc);\n\n\t/* Re-enable interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 0);\n\n\tif (ifp->if_flags & IFF_RUNNING && ifp->if_snd.ifq_head != NULL)\n\t\tti_start(ifp);\n\n\treturn (claimed);\n}"
  },
  {
    "function_name": "ti_txeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "1839-1886",
    "snippet": "void ti_txeof(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ti_tx_desc\t*cur_tx = NULL;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * Go through our tx ring and free mbufs for those\n\t * frames that have been sent.\n\t */\n\twhile (sc->ti_tx_saved_considx != sc->ti_tx_considx.ti_idx) {\n\t\tu_int32_t\t\tidx = 0;\n\n\t\tidx = sc->ti_tx_saved_considx;\n\t\tif (sc->ti_hwrev == TI_HWREV_TIGON) {\n\t\t\tif (idx > 383)\n\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t    TI_TX_RING_BASE + 6144);\n\t\t\telse if (idx > 255)\n\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t    TI_TX_RING_BASE + 4096);\n\t\t\telse if (idx > 127)\n\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t    TI_TX_RING_BASE + 2048);\n\t\t\telse\n\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t    TI_TX_RING_BASE);\n\t\t\tcur_tx = &sc->ti_rdata->ti_tx_ring_nic[idx % 128];\n\t\t} else\n\t\t\tcur_tx = &sc->ti_rdata->ti_tx_ring[idx];\n\t\tif (cur_tx->ti_flags & TI_BDFLAG_END)\n\t\t\tifp->if_opackets++;\n\t\tif (sc->ti_cdata.ti_tx_chain[idx] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_tx_chain[idx]);\n\t\t\tsc->ti_cdata.ti_tx_chain[idx] = NULL;\n\t\t}\n\t\tsc->ti_txcnt--;\n\t\tTI_INC(sc->ti_tx_saved_considx, TI_TX_RING_CNT);\n\t\tifp->if_timer = 0;\n\t}\n\n\tif (cur_tx != NULL)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_txeof",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TI_INC",
          "args": [
            "sc->ti_tx_saved_considx",
            "TI_TX_RING_CNT"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->ti_cdata.ti_tx_chain[idx]"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_WINBASE",
            "TI_TX_RING_BASE"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_WINBASE",
            "TI_TX_RING_BASE + 2048"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_WINBASE",
            "TI_TX_RING_BASE + 4096"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_WINBASE",
            "TI_TX_RING_BASE + 6144"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_txeof;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_txeof(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ti_tx_desc\t*cur_tx = NULL;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * Go through our tx ring and free mbufs for those\n\t * frames that have been sent.\n\t */\n\twhile (sc->ti_tx_saved_considx != sc->ti_tx_considx.ti_idx) {\n\t\tu_int32_t\t\tidx = 0;\n\n\t\tidx = sc->ti_tx_saved_considx;\n\t\tif (sc->ti_hwrev == TI_HWREV_TIGON) {\n\t\t\tif (idx > 383)\n\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t    TI_TX_RING_BASE + 6144);\n\t\t\telse if (idx > 255)\n\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t    TI_TX_RING_BASE + 4096);\n\t\t\telse if (idx > 127)\n\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t    TI_TX_RING_BASE + 2048);\n\t\t\telse\n\t\t\t\tCSR_WRITE_4(sc, TI_WINBASE,\n\t\t\t\t    TI_TX_RING_BASE);\n\t\t\tcur_tx = &sc->ti_rdata->ti_tx_ring_nic[idx % 128];\n\t\t} else\n\t\t\tcur_tx = &sc->ti_rdata->ti_tx_ring[idx];\n\t\tif (cur_tx->ti_flags & TI_BDFLAG_END)\n\t\t\tifp->if_opackets++;\n\t\tif (sc->ti_cdata.ti_tx_chain[idx] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_tx_chain[idx]);\n\t\t\tsc->ti_cdata.ti_tx_chain[idx] = NULL;\n\t\t}\n\t\tsc->ti_txcnt--;\n\t\tTI_INC(sc->ti_tx_saved_considx, TI_TX_RING_CNT);\n\t\tifp->if_timer = 0;\n\t}\n\n\tif (cur_tx != NULL)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_rxeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "1712-1837",
    "snippet": "void ti_rxeof(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct ti_cmd_desc\tcmd;\n\n\tifp = &sc->arpcom.ac_if;\n\n\twhile(sc->ti_rx_saved_considx != sc->ti_return_prodidx.ti_idx) {\n\t\tstruct ti_rx_desc\t*cur_rx;\n\t\tu_int32_t\t\trxidx;\n\t\tstruct ether_header\t*eh;\n\t\tstruct mbuf\t\t*m = NULL;\n#if NVLAN > 0\n\t\tu_int16_t\t\tvlan_tag = 0;\n\t\tint\t\t\thave_tag = 0;\n#endif\n#ifdef TI_CSUM_OFFLOAD\n\t\tstruct ip\t\t*ip;\n#endif\n\n\t\tcur_rx =\n\t\t    &sc->ti_rdata->ti_rx_return_ring[sc->ti_rx_saved_considx];\n\t\trxidx = cur_rx->ti_idx;\n\t\tTI_INC(sc->ti_rx_saved_considx, TI_RETURN_RING_CNT);\n\n#if NVLAN > 0\n\t\tif (cur_rx->ti_flags & TI_BDFLAG_VLAN_TAG) {\n\t\t\thave_tag = 1;\n\t\t\tvlan_tag = cur_rx->ti_vlan_tag;\n\t\t}\n#endif\n\n\t\tif (cur_rx->ti_flags & TI_BDFLAG_JUMBO_RING) {\n\t\t\tTI_INC(sc->ti_jumbo, TI_JUMBO_RX_RING_CNT);\n\t\t\tm = sc->ti_cdata.ti_rx_jumbo_chain[rxidx];\n\t\t\tsc->ti_cdata.ti_rx_jumbo_chain[rxidx] = NULL;\n\t\t\tif (cur_rx->ti_flags & TI_BDFLAG_ERROR) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_jumbo(sc, sc->ti_jumbo, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ti_newbuf_jumbo(sc, sc->ti_jumbo, NULL) == ENOBUFS) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_jumbo(sc, sc->ti_jumbo, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (cur_rx->ti_flags & TI_BDFLAG_MINI_RING) {\n\t\t\tTI_INC(sc->ti_mini, TI_MINI_RX_RING_CNT);\n\t\t\tm = sc->ti_cdata.ti_rx_mini_chain[rxidx];\n\t\t\tsc->ti_cdata.ti_rx_mini_chain[rxidx] = NULL;\n\t\t\tif (cur_rx->ti_flags & TI_BDFLAG_ERROR) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_mini(sc, sc->ti_mini, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ti_newbuf_mini(sc, sc->ti_mini, NULL) == ENOBUFS) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_mini(sc, sc->ti_mini, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tTI_INC(sc->ti_std, TI_STD_RX_RING_CNT);\n\t\t\tm = sc->ti_cdata.ti_rx_std_chain[rxidx];\n\t\t\tsc->ti_cdata.ti_rx_std_chain[rxidx] = NULL;\n\t\t\tif (cur_rx->ti_flags & TI_BDFLAG_ERROR) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_std(sc, sc->ti_std, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ti_newbuf_std(sc, sc->ti_std, NULL) == ENOBUFS) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_std(sc, sc->ti_std, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tm->m_pkthdr.len = m->m_len = cur_rx->ti_len;\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n\n#if NBPFILTER > 0\n\t\t/*\n\t \t * Handle BPF listeners. Let the BPF user see the packet.\n\t \t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\n#ifdef TI_CSUM_OFFLOAD\n\t\tip = mtod(m, struct ip *);\n\t\tif (!(cur_rx->ti_tcp_udp_cksum ^ 0xFFFF) &&\n\t\t    !(ip->ip_off & htons(IP_MF | IP_OFFMASK | IP_RF)))\n\t\t\tm->m_flags |= M_HWCKSUM;\n#endif\n\n#if NVLAN > 0\n\t\t/*\n\t\t * If we received a packet with a vlan tag, pass it\n\t\t * to vlan_input() instead of ether_input().\n\t\t */\n\t\tif (have_tag) {\n\t\t\tif (vlan_input_tag(eh, m, vlan_tag) < 0)\n\t\t\t\tifp->if_data.ifi_noproto++;\n\t\t\thave_tag = vlan_tag = 0;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tether_input(ifp, eh, m);\n\t}\n\n\t/* Only necessary on the Tigon 1. */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\tCSR_WRITE_4(sc, TI_GCR_RXRETURNCONS_IDX,\n\t\t    sc->ti_rx_saved_considx);\n\n\tTI_UPDATE_STDPROD(sc, sc->ti_std);\n\tTI_UPDATE_MINIPROD(sc, sc->ti_mini);\n\tTI_UPDATE_JUMBOPROD(sc, sc->ti_jumbo);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_rxeof",
      "int ti_newbuf_std",
      "int ti_newbuf_mini",
      "int ti_newbuf_jumbo",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TI_UPDATE_JUMBOPROD",
          "args": [
            "sc",
            "sc->ti_jumbo"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_UPDATE_MINIPROD",
          "args": [
            "sc",
            "sc->ti_mini"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_UPDATE_STDPROD",
          "args": [
            "sc",
            "sc->ti_std"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_RXRETURNCONS_IDX",
            "sc->ti_rx_saved_considx"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vlan_input_tag",
          "args": [
            "eh",
            "m",
            "vlan_tag"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "IP_MF | IP_OFFMASK | IP_RF"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structip *"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "sizeof(struct ether_header)"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ti_newbuf_std",
          "args": [
            "sc",
            "sc->ti_std",
            "m"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "ti_newbuf_std",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "724-768",
          "snippet": "int ti_newbuf_std(sc, i, m)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct ti_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: mbuf allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: cluster allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\tm_freem(m_new);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tsc->ti_cdata.ti_rx_std_chain[i] = m_new;\n\tr = &sc->ti_rdata->ti_rx_std_ring[i];\n\tTI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));\n\tr->ti_type = TI_BDTYPE_RECV_BD;\n#ifdef TI_CSUM_OFFLOAD\n\tr->ti_flags = TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;\n#else\n\tr->ti_flags = 0;\n#endif\n\tr->ti_len = MCLBYTES;\n\tr->ti_idx = i;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int ti_newbuf_std",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_newbuf_std;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_newbuf_std(sc, i, m)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct ti_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: mbuf allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: cluster allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\tm_freem(m_new);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tsc->ti_cdata.ti_rx_std_chain[i] = m_new;\n\tr = &sc->ti_rdata->ti_rx_std_ring[i];\n\tTI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));\n\tr->ti_type = TI_BDTYPE_RECV_BD;\n#ifdef TI_CSUM_OFFLOAD\n\tr->ti_flags = TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;\n#else\n\tr->ti_flags = 0;\n#endif\n\tr->ti_len = MCLBYTES;\n\tr->ti_idx = i;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TI_INC",
          "args": [
            "sc->ti_std",
            "TI_STD_RX_RING_CNT"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ti_newbuf_mini",
          "args": [
            "sc",
            "sc->ti_mini",
            "m"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "ti_newbuf_mini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "774-809",
          "snippet": "int ti_newbuf_mini(sc, i, m)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct ti_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: mbuf allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MHLEN;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_data = m_new->m_pktdat;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MHLEN;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tr = &sc->ti_rdata->ti_rx_mini_ring[i];\n\tsc->ti_cdata.ti_rx_mini_chain[i] = m_new;\n\tTI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));\n\tr->ti_type = TI_BDTYPE_RECV_BD;\n\tr->ti_flags = TI_BDFLAG_MINI_RING;\n#ifdef TI_CSUM_OFFLOAD\n\tr->ti_flags |= TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;\n#endif\n\tr->ti_len = m_new->m_len;\n\tr->ti_idx = i;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int ti_newbuf_mini",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_newbuf_mini;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_newbuf_mini(sc, i, m)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct ti_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: mbuf allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MHLEN;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_data = m_new->m_pktdat;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MHLEN;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tr = &sc->ti_rdata->ti_rx_mini_ring[i];\n\tsc->ti_cdata.ti_rx_mini_chain[i] = m_new;\n\tTI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));\n\tr->ti_type = TI_BDTYPE_RECV_BD;\n\tr->ti_flags = TI_BDFLAG_MINI_RING;\n#ifdef TI_CSUM_OFFLOAD\n\tr->ti_flags |= TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;\n#endif\n\tr->ti_len = m_new->m_len;\n\tr->ti_idx = i;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TI_INC",
          "args": [
            "sc->ti_mini",
            "TI_MINI_RX_RING_CNT"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ti_newbuf_jumbo",
          "args": [
            "sc",
            "sc->ti_jumbo",
            "m"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "ti_newbuf_jumbo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "815-872",
          "snippet": "int ti_newbuf_jumbo(sc, i, m)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct ti_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tcaddr_t\t\t\t*buf = NULL;\n\n\t\t/* Allocate the mbuf. */\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: mbuf allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\t/* Allocate the jumbo buffer */\n\t\tbuf = ti_jalloc(sc);\n\t\tif (buf == NULL) {\n\t\t\tm_freem(m_new);\n\t\t\tprintf(\"%s: jumbo allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\t/* Attach the buffer to the mbuf. */\n\t\tm_new->m_data = m_new->m_ext.ext_buf = (void *)buf;\n\t\tm_new->m_flags |= M_EXT;\n\t\tm_new->m_len = m_new->m_pkthdr.len =\n\t\t    m_new->m_ext.ext_size = TI_JUMBO_FRAMELEN;\n\t\tm_new->m_ext.ext_free = ti_jfree;\n\t\tm_new->m_ext.ext_ref = ti_jref;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t\tm_new->m_ext.ext_size = TI_JUMBO_FRAMELEN;\n\t}\n\n\tm_new->m_ext.ext_handle = sc;\n\n\tm_adj(m_new, ETHER_ALIGN);\n\t/* Set up the descriptor. */\n\tr = &sc->ti_rdata->ti_rx_jumbo_ring[i];\n\tsc->ti_cdata.ti_rx_jumbo_chain[i] = m_new;\n\tTI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));\n\tr->ti_type = TI_BDTYPE_RECV_JUMBO_BD;\n\tr->ti_flags = TI_BDFLAG_JUMBO_RING;\n#ifdef TI_CSUM_OFFLOAD\n\tr->ti_flags |= TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;\n#endif\n\tr->ti_len = m_new->m_len;\n\tr->ti_idx = i;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void *ti_jalloc",
            "void ti_jfree",
            "void ti_jref",
            "int ti_newbuf_jumbo",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid *ti_jalloc;\nvoid ti_jfree;\nvoid ti_jref;\nint ti_newbuf_jumbo;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_newbuf_jumbo(sc, i, m)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct ti_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tcaddr_t\t\t\t*buf = NULL;\n\n\t\t/* Allocate the mbuf. */\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: mbuf allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\t/* Allocate the jumbo buffer */\n\t\tbuf = ti_jalloc(sc);\n\t\tif (buf == NULL) {\n\t\t\tm_freem(m_new);\n\t\t\tprintf(\"%s: jumbo allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\t/* Attach the buffer to the mbuf. */\n\t\tm_new->m_data = m_new->m_ext.ext_buf = (void *)buf;\n\t\tm_new->m_flags |= M_EXT;\n\t\tm_new->m_len = m_new->m_pkthdr.len =\n\t\t    m_new->m_ext.ext_size = TI_JUMBO_FRAMELEN;\n\t\tm_new->m_ext.ext_free = ti_jfree;\n\t\tm_new->m_ext.ext_ref = ti_jref;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t\tm_new->m_ext.ext_size = TI_JUMBO_FRAMELEN;\n\t}\n\n\tm_new->m_ext.ext_handle = sc;\n\n\tm_adj(m_new, ETHER_ALIGN);\n\t/* Set up the descriptor. */\n\tr = &sc->ti_rdata->ti_rx_jumbo_ring[i];\n\tsc->ti_cdata.ti_rx_jumbo_chain[i] = m_new;\n\tTI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));\n\tr->ti_type = TI_BDTYPE_RECV_JUMBO_BD;\n\tr->ti_flags = TI_BDFLAG_JUMBO_RING;\n#ifdef TI_CSUM_OFFLOAD\n\tr->ti_flags |= TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;\n#endif\n\tr->ti_len = m_new->m_len;\n\tr->ti_idx = i;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TI_INC",
          "args": [
            "sc->ti_jumbo",
            "TI_JUMBO_RX_RING_CNT"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_INC",
          "args": [
            "sc->ti_rx_saved_considx",
            "TI_RETURN_RING_CNT"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_rxeof;\nint ti_newbuf_std;\nint ti_newbuf_mini;\nint ti_newbuf_jumbo;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_rxeof(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct ti_cmd_desc\tcmd;\n\n\tifp = &sc->arpcom.ac_if;\n\n\twhile(sc->ti_rx_saved_considx != sc->ti_return_prodidx.ti_idx) {\n\t\tstruct ti_rx_desc\t*cur_rx;\n\t\tu_int32_t\t\trxidx;\n\t\tstruct ether_header\t*eh;\n\t\tstruct mbuf\t\t*m = NULL;\n#if NVLAN > 0\n\t\tu_int16_t\t\tvlan_tag = 0;\n\t\tint\t\t\thave_tag = 0;\n#endif\n#ifdef TI_CSUM_OFFLOAD\n\t\tstruct ip\t\t*ip;\n#endif\n\n\t\tcur_rx =\n\t\t    &sc->ti_rdata->ti_rx_return_ring[sc->ti_rx_saved_considx];\n\t\trxidx = cur_rx->ti_idx;\n\t\tTI_INC(sc->ti_rx_saved_considx, TI_RETURN_RING_CNT);\n\n#if NVLAN > 0\n\t\tif (cur_rx->ti_flags & TI_BDFLAG_VLAN_TAG) {\n\t\t\thave_tag = 1;\n\t\t\tvlan_tag = cur_rx->ti_vlan_tag;\n\t\t}\n#endif\n\n\t\tif (cur_rx->ti_flags & TI_BDFLAG_JUMBO_RING) {\n\t\t\tTI_INC(sc->ti_jumbo, TI_JUMBO_RX_RING_CNT);\n\t\t\tm = sc->ti_cdata.ti_rx_jumbo_chain[rxidx];\n\t\t\tsc->ti_cdata.ti_rx_jumbo_chain[rxidx] = NULL;\n\t\t\tif (cur_rx->ti_flags & TI_BDFLAG_ERROR) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_jumbo(sc, sc->ti_jumbo, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ti_newbuf_jumbo(sc, sc->ti_jumbo, NULL) == ENOBUFS) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_jumbo(sc, sc->ti_jumbo, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (cur_rx->ti_flags & TI_BDFLAG_MINI_RING) {\n\t\t\tTI_INC(sc->ti_mini, TI_MINI_RX_RING_CNT);\n\t\t\tm = sc->ti_cdata.ti_rx_mini_chain[rxidx];\n\t\t\tsc->ti_cdata.ti_rx_mini_chain[rxidx] = NULL;\n\t\t\tif (cur_rx->ti_flags & TI_BDFLAG_ERROR) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_mini(sc, sc->ti_mini, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ti_newbuf_mini(sc, sc->ti_mini, NULL) == ENOBUFS) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_mini(sc, sc->ti_mini, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tTI_INC(sc->ti_std, TI_STD_RX_RING_CNT);\n\t\t\tm = sc->ti_cdata.ti_rx_std_chain[rxidx];\n\t\t\tsc->ti_cdata.ti_rx_std_chain[rxidx] = NULL;\n\t\t\tif (cur_rx->ti_flags & TI_BDFLAG_ERROR) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_std(sc, sc->ti_std, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ti_newbuf_std(sc, sc->ti_std, NULL) == ENOBUFS) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tti_newbuf_std(sc, sc->ti_std, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tm->m_pkthdr.len = m->m_len = cur_rx->ti_len;\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n\n#if NBPFILTER > 0\n\t\t/*\n\t \t * Handle BPF listeners. Let the BPF user see the packet.\n\t \t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\n#ifdef TI_CSUM_OFFLOAD\n\t\tip = mtod(m, struct ip *);\n\t\tif (!(cur_rx->ti_tcp_udp_cksum ^ 0xFFFF) &&\n\t\t    !(ip->ip_off & htons(IP_MF | IP_OFFMASK | IP_RF)))\n\t\t\tm->m_flags |= M_HWCKSUM;\n#endif\n\n#if NVLAN > 0\n\t\t/*\n\t\t * If we received a packet with a vlan tag, pass it\n\t\t * to vlan_input() instead of ether_input().\n\t\t */\n\t\tif (have_tag) {\n\t\t\tif (vlan_input_tag(eh, m, vlan_tag) < 0)\n\t\t\t\tifp->if_data.ifi_noproto++;\n\t\t\thave_tag = vlan_tag = 0;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tether_input(ifp, eh, m);\n\t}\n\n\t/* Only necessary on the Tigon 1. */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\tCSR_WRITE_4(sc, TI_GCR_RXRETURNCONS_IDX,\n\t\t    sc->ti_rx_saved_considx);\n\n\tTI_UPDATE_STDPROD(sc, sc->ti_std);\n\tTI_UPDATE_MINIPROD(sc, sc->ti_mini);\n\tTI_UPDATE_JUMBOPROD(sc, sc->ti_jumbo);\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "1515-1699",
    "snippet": "void\nti_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct ti_softc *sc = (struct ti_softc *)self;\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr = NULL;\n\tbus_addr_t iobase;\n\tbus_size_t iosize;\n\tbus_dma_segment_t seg;\n\tbus_dmamap_t dmamap;\n\tint s, rseg;\n\tu_int32_t command;\n\tstruct ifnet *ifp;\n\tcaddr_t kva;\n\n\ts = splimp();\n\n\t/*\n\t * Map control/status registers.\n\t */\n\tcommand = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\tcommand |= PCI_COMMAND_MEM_ENABLE | PCI_COMMAND_MASTER_ENABLE;\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);\n\tcommand = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\n\tif (!(command & PCI_COMMAND_MEM_ENABLE)) {\n\t\tprintf(\"%s: failed to enable memory mapping!\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\t\tfree(sc, M_DEVBUF);\n\t\tgoto fail;\n\t}\n\tif (pci_mem_find(pc, pa->pa_tag, TI_PCI_LOMEM, &iobase, &iosize, NULL)) {\n\t\tprintf(\": can't find mem space\\n\");\n\t\tgoto fail;\n\t}\n\tif (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->ti_bhandle)) {\n\t\tprintf(\": can't map mem space\\n\");\n\t\tgoto fail;\n\t}\n\tsc->ti_btag = pa->pa_memt;\n\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\tgoto fail;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->ti_intrhand = pci_intr_establish(pc, ih, IPL_NET, ti_intr, sc,\n\t    self->dv_xname);\n\tif (sc->ti_intrhand == NULL) {\n\t\tprintf(\": couldn't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (ti_chipinit(sc)) {\n\t\tprintf(\"%s: chip initialization failed\\n\", sc->sc_dv.dv_xname);\n\t\tgoto fail;\n\t}\n\n\t/* Zero out the NIC's on-board SRAM. */\n\tti_mem(sc, 0x2000, 0x100000 - 0x2000,  NULL);\n\n\t/* Init again -- zeroing memory may have clobbered some registers. */\n\tif (ti_chipinit(sc)) {\n\t\tprintf(\"%s: chip initialization failed\\n\", sc->sc_dv.dv_xname);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * Get station address from the EEPROM. Note: the manual states\n\t * that the MAC address is at offset 0x8c, however the data is\n\t * stored as two longwords (since that's how it's loaded into\n\t * the NIC). This means the MAC address is actually preceeded\n\t * by two zero bytes. We need to skip over those.\n\t */\n\tif (ti_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,\n\t\t\t\tTI_EE_MAC_OFFSET + 2, ETHER_ADDR_LEN)) {\n\t\tprintf(\"%s: failed to read station address\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\t\tfree(sc, M_DEVBUF);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * A Tigon chip was detected. Inform the world.\n\t */\n\tprintf(\": %s address %s\\n\", intrstr,\n\t     ether_sprintf(sc->arpcom.ac_enaddr));\n\n\t/* Allocate the general information block and ring buffers. */\n\tsc->sc_dmatag = pa->pa_dmat;\n\tif (bus_dmamem_alloc(sc->sc_dmatag, sizeof(struct ti_ring_data),\n\t    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't alloc rx buffers\\n\", sc->sc_dv.dv_xname);\n\t\tgoto fail;\n\t}\n\tif (bus_dmamem_map(sc->sc_dmatag, &seg, rseg,\n\t    sizeof(struct ti_ring_data), &kva, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't map dma buffers (%d bytes)\\n\",\n\t\t       sc->sc_dv.dv_xname, sizeof(struct ti_ring_data));\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\tgoto fail;\n\t}\n\tif (bus_dmamap_create(sc->sc_dmatag, sizeof(struct ti_ring_data), 1,\n\t    sizeof(struct ti_ring_data), 0, BUS_DMA_NOWAIT, &dmamap)) {\n\t\tprintf(\"%s: can't create dma map\\n\", sc->sc_dv.dv_xname);\n\t\tbus_dmamem_unmap(sc->sc_dmatag, kva,\n\t\t    sizeof(struct ti_ring_data));\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\tgoto fail;\n\t}\n\tif (bus_dmamap_load(sc->sc_dmatag, dmamap, kva,\n\t    sizeof(struct ti_ring_data), NULL, BUS_DMA_NOWAIT)) {\n\t\tbus_dmamap_destroy(sc->sc_dmatag, dmamap);\n\t\tbus_dmamem_unmap(sc->sc_dmatag, kva,\n\t\t    sizeof(struct ti_ring_data));\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\tgoto fail;\n\t}\n\tsc->ti_rdata = (struct ti_ring_data *)kva;\n\tbzero(sc->ti_rdata, sizeof(struct ti_ring_data));\n\n\t/* Try to allocate memory for jumbo buffers. */\n\tif (ti_alloc_jumbo_mem(sc)) {\n\t\tprintf(\"%s: jumbo buffer allocation failed\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\t\tgoto fail;\n\t}\n\n\t/* Set default tuneable values. */\n\tsc->ti_stat_ticks = 2 * TI_TICKS_PER_SEC;\n\tsc->ti_rx_coal_ticks = TI_TICKS_PER_SEC / 5000;\n\tsc->ti_tx_coal_ticks = TI_TICKS_PER_SEC / 500;\n\tsc->ti_rx_max_coal_bds = 64;\n\tsc->ti_tx_max_coal_bds = 128;\n\tsc->ti_tx_buf_ratio = 21;\n\n\t/* Set up ifnet structure */\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = ti_ioctl;\n\tifp->if_output = ether_output;\n\tifp->if_start = ti_start;\n\tifp->if_watchdog = ti_watchdog;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_snd.ifq_maxlen = TI_TX_RING_CNT - 1;\n\tbcopy(sc->sc_dv.dv_xname, ifp->if_xname, IFNAMSIZ);\n\n\t/* Set up ifmedia support. */\n\tifmedia_init(&sc->ifmedia, IFM_IMASK, ti_ifmedia_upd, ti_ifmedia_sts);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_FL, 0, NULL);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_FL|IFM_FDX, 0, NULL);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_FX, 0, NULL);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_FX|IFM_FDX, 0, NULL);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_1000_SX, 0, NULL);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_1000_SX|IFM_FDX, 0, NULL);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);\n\tifmedia_set(&sc->ifmedia, IFM_ETHER|IFM_AUTO);\n\n\t/*\n\t * Call MI attach routines.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->arpcom.ac_if.if_bpf, ifp,\n\t    DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\n\tshutdownhook_establish(ti_shutdown, sc);\n\nfail:\n\tsplx(s);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_attach",
      "int ti_intr",
      "void ti_start",
      "int ti_ioctl",
      "void ti_watchdog",
      "void ti_shutdown",
      "int ti_ifmedia_upd",
      "void ti_ifmedia_sts",
      "int ti_read_eeprom",
      "void ti_mem",
      "int ti_alloc_jumbo_mem",
      "int ti_chipinit",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "ti_shutdown",
            "sc"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&sc->arpcom.ac_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_AUTO"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_AUTO",
            "0",
            "NULL"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_1000_SX|IFM_FDX",
            "0",
            "NULL"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_1000_SX",
            "0",
            "NULL"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_100_FX|IFM_FDX",
            "0",
            "NULL"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_100_FX",
            "0",
            "NULL"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_10_FL|IFM_FDX",
            "0",
            "NULL"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_10_FL",
            "0",
            "NULL"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->ifmedia",
            "IFM_IMASK",
            "ti_ifmedia_upd",
            "ti_ifmedia_sts"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dv.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: jumbo buffer allocation failed\\n\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_alloc_jumbo_mem",
          "args": [
            "sc"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "ti_alloc_jumbo_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "552-620",
          "snippet": "int ti_alloc_jumbo_mem(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tcaddr_t ptr, kva;\n\tbus_dma_segment_t seg;\n\tbus_dmamap_t dmamap;\n\tint i, rseg;\n\tstruct ti_jpool_entry *entry;\n\n\t/* Grab a big chunk o' storage. */\n\tif (bus_dmamem_alloc(sc->sc_dmatag, TI_JMEM, PAGE_SIZE, 0,\n\t    &seg, 1, &rseg, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't alloc rx buffers\\n\", sc->sc_dv.dv_xname);\n\t\treturn (ENOBUFS);\n\t}\n\tif (bus_dmamem_map(sc->sc_dmatag, &seg, rseg, TI_JMEM, &kva,\n\t    BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't map dma buffers (%d bytes)\\n\",\n\t\t    sc->sc_dv.dv_xname, TI_JMEM);\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\treturn (ENOBUFS);\n\t}\n\tif (bus_dmamap_create(sc->sc_dmatag, TI_JMEM, 1,\n\t    TI_JMEM, 0, BUS_DMA_NOWAIT, &dmamap)) {\n\t\tprintf(\"%s: can't create dma map\\n\", sc->sc_dv.dv_xname);\n\t\tbus_dmamem_unmap(sc->sc_dmatag, kva, TI_JMEM);\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\treturn (ENOBUFS);\n\t}\n\tif (bus_dmamap_load(sc->sc_dmatag, dmamap, kva, TI_JMEM,\n\t    NULL, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't load dma map\\n\", sc->sc_dv.dv_xname);\n\t\tbus_dmamap_destroy(sc->sc_dmatag, dmamap);\n\t\tbus_dmamem_unmap(sc->sc_dmatag, kva, TI_JMEM);\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\treturn (ENOBUFS);\n\t}\n\tsc->ti_cdata.ti_jumbo_buf = (caddr_t)kva;\n\n\tLIST_INIT(&sc->ti_jfree_listhead);\n\tLIST_INIT(&sc->ti_jinuse_listhead);\n\n\t/*\n\t * Now divide it up into 9K pieces and save the addresses\n\t * in an array.\n\t */\n\tptr = sc->ti_cdata.ti_jumbo_buf;\n\tfor (i = 0; i < TI_JSLOTS; i++) {\n\t\tsc->ti_cdata.ti_jslots[i].ti_buf = ptr;\n\t\tsc->ti_cdata.ti_jslots[i].ti_inuse = 0;\n\t\tptr += TI_JLEN;\n\t\tentry = malloc(sizeof(struct ti_jpool_entry), \n\t\t\t       M_DEVBUF, M_NOWAIT);\n\t\tif (entry == NULL) {\n\t\t\tbus_dmamap_unload(sc->sc_dmatag, dmamap);\n\t\t\tbus_dmamap_destroy(sc->sc_dmatag, dmamap);\n\t\t\tbus_dmamem_unmap(sc->sc_dmatag, kva, TI_JMEM);\n\t\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\t\tsc->ti_cdata.ti_jumbo_buf = NULL;\n\t\t\tprintf(\"%s: no memory for jumbo buffer queue\\n\",\n\t\t\t    sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tentry->slot = i;\n\t\tLIST_INSERT_HEAD(&sc->ti_jfree_listhead, entry, jpool_entries);\n\t}\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int ti_alloc_jumbo_mem",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_alloc_jumbo_mem;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_alloc_jumbo_mem(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tcaddr_t ptr, kva;\n\tbus_dma_segment_t seg;\n\tbus_dmamap_t dmamap;\n\tint i, rseg;\n\tstruct ti_jpool_entry *entry;\n\n\t/* Grab a big chunk o' storage. */\n\tif (bus_dmamem_alloc(sc->sc_dmatag, TI_JMEM, PAGE_SIZE, 0,\n\t    &seg, 1, &rseg, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't alloc rx buffers\\n\", sc->sc_dv.dv_xname);\n\t\treturn (ENOBUFS);\n\t}\n\tif (bus_dmamem_map(sc->sc_dmatag, &seg, rseg, TI_JMEM, &kva,\n\t    BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't map dma buffers (%d bytes)\\n\",\n\t\t    sc->sc_dv.dv_xname, TI_JMEM);\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\treturn (ENOBUFS);\n\t}\n\tif (bus_dmamap_create(sc->sc_dmatag, TI_JMEM, 1,\n\t    TI_JMEM, 0, BUS_DMA_NOWAIT, &dmamap)) {\n\t\tprintf(\"%s: can't create dma map\\n\", sc->sc_dv.dv_xname);\n\t\tbus_dmamem_unmap(sc->sc_dmatag, kva, TI_JMEM);\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\treturn (ENOBUFS);\n\t}\n\tif (bus_dmamap_load(sc->sc_dmatag, dmamap, kva, TI_JMEM,\n\t    NULL, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't load dma map\\n\", sc->sc_dv.dv_xname);\n\t\tbus_dmamap_destroy(sc->sc_dmatag, dmamap);\n\t\tbus_dmamem_unmap(sc->sc_dmatag, kva, TI_JMEM);\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\treturn (ENOBUFS);\n\t}\n\tsc->ti_cdata.ti_jumbo_buf = (caddr_t)kva;\n\n\tLIST_INIT(&sc->ti_jfree_listhead);\n\tLIST_INIT(&sc->ti_jinuse_listhead);\n\n\t/*\n\t * Now divide it up into 9K pieces and save the addresses\n\t * in an array.\n\t */\n\tptr = sc->ti_cdata.ti_jumbo_buf;\n\tfor (i = 0; i < TI_JSLOTS; i++) {\n\t\tsc->ti_cdata.ti_jslots[i].ti_buf = ptr;\n\t\tsc->ti_cdata.ti_jslots[i].ti_inuse = 0;\n\t\tptr += TI_JLEN;\n\t\tentry = malloc(sizeof(struct ti_jpool_entry), \n\t\t\t       M_DEVBUF, M_NOWAIT);\n\t\tif (entry == NULL) {\n\t\t\tbus_dmamap_unload(sc->sc_dmatag, dmamap);\n\t\t\tbus_dmamap_destroy(sc->sc_dmatag, dmamap);\n\t\t\tbus_dmamem_unmap(sc->sc_dmatag, kva, TI_JMEM);\n\t\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\t\tsc->ti_cdata.ti_jumbo_buf = NULL;\n\t\t\tprintf(\"%s: no memory for jumbo buffer queue\\n\",\n\t\t\t    sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tentry->slot = i;\n\t\tLIST_INSERT_HEAD(&sc->ti_jfree_listhead, entry, jpool_entries);\n\t}\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->ti_rdata",
            "sizeof(struct ti_ring_data)"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "sc->sc_dmatag",
            "&seg",
            "rseg"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "sc->sc_dmatag",
            "kva",
            "sizeof(struct ti_ring_data)"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_destroy",
          "args": [
            "sc->sc_dmatag",
            "dmamap"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "sc->sc_dmatag",
            "dmamap",
            "kva",
            "sizeof(struct ti_ring_data)",
            "NULL",
            "BUS_DMA_NOWAIT"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "sc->sc_dmatag",
            "&seg",
            "rseg"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "sc->sc_dmatag",
            "kva",
            "sizeof(struct ti_ring_data)"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "sc->sc_dmatag",
            "sizeof(struct ti_ring_data)",
            "1",
            "sizeof(struct ti_ring_data)",
            "0",
            "BUS_DMA_NOWAIT",
            "&dmamap"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "sc->sc_dmatag",
            "&seg",
            "rseg"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_map",
          "args": [
            "sc->sc_dmatag",
            "&seg",
            "rseg",
            "sizeof(struct ti_ring_data)",
            "&kva",
            "BUS_DMA_NOWAIT"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_alloc",
          "args": [
            "sc->sc_dmatag",
            "sizeof(struct ti_ring_data)",
            "PAGE_SIZE",
            "0",
            "&seg",
            "1",
            "&rseg",
            "BUS_DMA_NOWAIT"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->arpcom.ac_enaddr"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sc",
            "M_DEVBUF"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "ti_free_tx_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "981-999",
          "snippet": "void ti_free_tx_ring(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tif (sc->ti_rdata->ti_tx_ring == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < TI_TX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_tx_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_tx_chain[i]);\n\t\t\tsc->ti_cdata.ti_tx_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_tx_ring[i],\n\t\t    sizeof(struct ti_tx_desc));\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_free_tx_ring",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_free_tx_ring;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_free_tx_ring(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tif (sc->ti_rdata->ti_tx_ring == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < TI_TX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_tx_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_tx_chain[i]);\n\t\t\tsc->ti_cdata.ti_tx_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_tx_ring[i],\n\t\t    sizeof(struct ti_tx_desc));\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_read_eeprom",
          "args": [
            "sc",
            "(caddr_t)&sc->arpcom.ac_enaddr",
            "TI_EE_MAC_OFFSET + 2",
            "ETHER_ADDR_LEN"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "ti_read_eeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "310-327",
          "snippet": "int ti_read_eeprom(sc, dest, off, cnt)\n\tstruct ti_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n{\n\tint\t\t\terr = 0, i;\n\tu_int8_t\t\tbyte = 0;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\terr = ti_eeprom_getbyte(sc, off + i, &byte);\n\t\tif (err)\n\t\t\tbreak;\n\t\t*(dest + i) = byte;\n\t}\n\n\treturn(err ? 1 : 0);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t ti_eeprom_getbyte",
            "int ti_read_eeprom",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t ti_eeprom_getbyte;\nint ti_read_eeprom;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_read_eeprom(sc, dest, off, cnt)\n\tstruct ti_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n{\n\tint\t\t\terr = 0, i;\n\tu_int8_t\t\tbyte = 0;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\terr = ti_eeprom_getbyte(sc, off + i, &byte);\n\t\tif (err)\n\t\t\tbreak;\n\t\t*(dest + i) = byte;\n\t}\n\n\treturn(err ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_chipinit",
          "args": [
            "sc"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "ti_chipinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "1169-1306",
          "snippet": "int ti_chipinit(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tu_int32_t\t\tcacheline;\n\tu_int32_t\t\tpci_writemax = 0;\n\n\t/* Initialize link to down state. */\n\tsc->ti_linkstat = TI_EV_CODE_LINK_DOWN;\n\n\t/* Set endianness before we access any non-PCI registers. */\n#if BYTE_ORDER == BIG_ENDIAN\n\tCSR_WRITE_4(sc, TI_MISC_HOST_CTL,\n\t    TI_MHC_BIGENDIAN_INIT | (TI_MHC_BIGENDIAN_INIT << 24));\n#else\n\tCSR_WRITE_4(sc, TI_MISC_HOST_CTL,\n\t    TI_MHC_LITTLEENDIAN_INIT | (TI_MHC_LITTLEENDIAN_INIT << 24));\n#endif\n\n\t/* Check the ROM failed bit to see if self-tests passed. */\n\tif (CSR_READ_4(sc, TI_CPU_STATE) & TI_CPUSTATE_ROMFAIL) {\n\t\tprintf(\"%s: board self-diagnostics failed!\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\t\treturn(ENODEV);\n\t}\n\n\t/* Halt the CPU. */\n\tTI_SETBIT(sc, TI_CPU_STATE, TI_CPUSTATE_HALT);\n\n\t/* Figure out the hardware revision. */\n\tswitch(CSR_READ_4(sc, TI_MISC_HOST_CTL) & TI_MHC_CHIP_REV_MASK) {\n\tcase TI_REV_TIGON_I:\n\t\tsc->ti_hwrev = TI_HWREV_TIGON;\n\t\tbreak;\n\tcase TI_REV_TIGON_II:\n\t\tsc->ti_hwrev = TI_HWREV_TIGON_II;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unsupported chip revision\\n\", sc->sc_dv.dv_xname);\n\t\treturn(ENODEV);\n\t}\n\n\t/* Do special setup for Tigon 2. */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II) {\n\t\tTI_SETBIT(sc, TI_CPU_CTL_B, TI_CPUSTATE_HALT);\n\t\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_SRAM_BANK_256K);\n\t\tTI_SETBIT(sc, TI_MISC_CONF, TI_MCR_SRAM_SYNCHRONOUS);\n\t}\n\n\t/* Set up the PCI state register. */\n\tCSR_WRITE_4(sc, TI_PCI_STATE, TI_PCI_READ_CMD|TI_PCI_WRITE_CMD);\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II) {\n\t\tTI_SETBIT(sc, TI_PCI_STATE, TI_PCISTATE_USE_MEM_RD_MULT);\n\t}\n\n\t/* Clear the read/write max DMA parameters. */\n\tTI_CLRBIT(sc, TI_PCI_STATE, (TI_PCISTATE_WRITE_MAXDMA|\n\t    TI_PCISTATE_READ_MAXDMA));\n\n\t/* Get cache line size. */\n\tcacheline = CSR_READ_4(sc, TI_PCI_BIST) & 0xFF;\n\n\t/*\n\t * If the system has set enabled the PCI memory write\n\t * and invalidate command in the command register, set\n\t * the write max parameter accordingly. This is necessary\n\t * to use MWI with the Tigon 2.\n\t */\n\tif (CSR_READ_4(sc, TI_PCI_CMDSTAT) & PCIM_CMD_MWIEN) {\n\t\tswitch(cacheline) {\n\t\tcase 1:\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\tcase 32:\n\t\tcase 64:\n\t\t\tbreak;\n\t\tdefault:\n\t\t/* Disable PCI memory write and invalidate. */\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: cache line size %d not \"\n\t\t\t\t    \"supported; disabling PCI MWI\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname, cacheline);\n\t\t\tCSR_WRITE_4(sc, TI_PCI_CMDSTAT, CSR_READ_4(sc,\n\t\t\t    TI_PCI_CMDSTAT) & ~PCIM_CMD_MWIEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef __brokenalpha__\n\t/*\n\t * From the Alteon sample driver:\n\t * Must insure that we do not cross an 8K (bytes) boundary\n\t * for DMA reads.  Our highest limit is 1K bytes.  This is a \n\t * restriction on some ALPHA platforms with early revision \n\t * 21174 PCI chipsets, such as the AlphaPC 164lx \n\t */\n\tTI_SETBIT(sc, TI_PCI_STATE, pci_writemax|TI_PCI_READMAX_1024);\n#else\n\tTI_SETBIT(sc, TI_PCI_STATE, pci_writemax);\n#endif\n\n\t/* This sets the min dma param all the way up (0xff). */\n\tTI_SETBIT(sc, TI_PCI_STATE, TI_PCISTATE_MINDMA);\n\n\t/* Configure DMA variables. */\n#if BYTE_ORDER == BIG_ENDIAN\n\tCSR_WRITE_4(sc, TI_GCR_OPMODE, TI_OPMODE_BYTESWAP_BD |\n\t    TI_OPMODE_BYTESWAP_DATA | TI_OPMODE_WORDSWAP_BD |\n\t    TI_OPMODE_WARN_ENB | TI_OPMODE_FATAL_ENB |\n\t    TI_OPMODE_DONT_FRAG_JUMBO);\n#else\n\tCSR_WRITE_4(sc, TI_GCR_OPMODE, TI_OPMODE_BYTESWAP_DATA|\n\t    TI_OPMODE_WORDSWAP_BD|TI_OPMODE_DONT_FRAG_JUMBO|\n\t    TI_OPMODE_WARN_ENB|TI_OPMODE_FATAL_ENB);\n#endif\n\n\t/*\n\t * Only allow 1 DMA channel to be active at a time.\n\t * I don't think this is a good idea, but without it\n\t * the firmware racks up lots of nicDmaReadRingFull\n\t * errors.\n\t */\n#ifndef TI_CSUM_OFFLOAD\n\tTI_SETBIT(sc, TI_GCR_OPMODE, TI_OPMODE_1_DMA_ACTIVE);\n#endif\n\n\t/* Recommended settings from Tigon manual. */\n\tCSR_WRITE_4(sc, TI_GCR_DMA_WRITECFG, TI_DMA_STATE_THRESH_8W);\n\tCSR_WRITE_4(sc, TI_GCR_DMA_READCFG, TI_DMA_STATE_THRESH_8W);\n\n\tif (ti_64bitslot_war(sc)) {\n\t\tprintf(\"%s: bios thinks we're in a 64 bit slot, \"\n\t\t    \"but we aren't\", sc->sc_dv.dv_xname);\n\t\treturn(EINVAL);\n\t}\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define bootverbose\t1"
          ],
          "globals_used": [
            "int ti_64bitslot_war",
            "int ti_chipinit",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define bootverbose\t1\n\nint ti_64bitslot_war;\nint ti_chipinit;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_chipinit(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tu_int32_t\t\tcacheline;\n\tu_int32_t\t\tpci_writemax = 0;\n\n\t/* Initialize link to down state. */\n\tsc->ti_linkstat = TI_EV_CODE_LINK_DOWN;\n\n\t/* Set endianness before we access any non-PCI registers. */\n#if BYTE_ORDER == BIG_ENDIAN\n\tCSR_WRITE_4(sc, TI_MISC_HOST_CTL,\n\t    TI_MHC_BIGENDIAN_INIT | (TI_MHC_BIGENDIAN_INIT << 24));\n#else\n\tCSR_WRITE_4(sc, TI_MISC_HOST_CTL,\n\t    TI_MHC_LITTLEENDIAN_INIT | (TI_MHC_LITTLEENDIAN_INIT << 24));\n#endif\n\n\t/* Check the ROM failed bit to see if self-tests passed. */\n\tif (CSR_READ_4(sc, TI_CPU_STATE) & TI_CPUSTATE_ROMFAIL) {\n\t\tprintf(\"%s: board self-diagnostics failed!\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\t\treturn(ENODEV);\n\t}\n\n\t/* Halt the CPU. */\n\tTI_SETBIT(sc, TI_CPU_STATE, TI_CPUSTATE_HALT);\n\n\t/* Figure out the hardware revision. */\n\tswitch(CSR_READ_4(sc, TI_MISC_HOST_CTL) & TI_MHC_CHIP_REV_MASK) {\n\tcase TI_REV_TIGON_I:\n\t\tsc->ti_hwrev = TI_HWREV_TIGON;\n\t\tbreak;\n\tcase TI_REV_TIGON_II:\n\t\tsc->ti_hwrev = TI_HWREV_TIGON_II;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unsupported chip revision\\n\", sc->sc_dv.dv_xname);\n\t\treturn(ENODEV);\n\t}\n\n\t/* Do special setup for Tigon 2. */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II) {\n\t\tTI_SETBIT(sc, TI_CPU_CTL_B, TI_CPUSTATE_HALT);\n\t\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_SRAM_BANK_256K);\n\t\tTI_SETBIT(sc, TI_MISC_CONF, TI_MCR_SRAM_SYNCHRONOUS);\n\t}\n\n\t/* Set up the PCI state register. */\n\tCSR_WRITE_4(sc, TI_PCI_STATE, TI_PCI_READ_CMD|TI_PCI_WRITE_CMD);\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II) {\n\t\tTI_SETBIT(sc, TI_PCI_STATE, TI_PCISTATE_USE_MEM_RD_MULT);\n\t}\n\n\t/* Clear the read/write max DMA parameters. */\n\tTI_CLRBIT(sc, TI_PCI_STATE, (TI_PCISTATE_WRITE_MAXDMA|\n\t    TI_PCISTATE_READ_MAXDMA));\n\n\t/* Get cache line size. */\n\tcacheline = CSR_READ_4(sc, TI_PCI_BIST) & 0xFF;\n\n\t/*\n\t * If the system has set enabled the PCI memory write\n\t * and invalidate command in the command register, set\n\t * the write max parameter accordingly. This is necessary\n\t * to use MWI with the Tigon 2.\n\t */\n\tif (CSR_READ_4(sc, TI_PCI_CMDSTAT) & PCIM_CMD_MWIEN) {\n\t\tswitch(cacheline) {\n\t\tcase 1:\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\tcase 32:\n\t\tcase 64:\n\t\t\tbreak;\n\t\tdefault:\n\t\t/* Disable PCI memory write and invalidate. */\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: cache line size %d not \"\n\t\t\t\t    \"supported; disabling PCI MWI\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname, cacheline);\n\t\t\tCSR_WRITE_4(sc, TI_PCI_CMDSTAT, CSR_READ_4(sc,\n\t\t\t    TI_PCI_CMDSTAT) & ~PCIM_CMD_MWIEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef __brokenalpha__\n\t/*\n\t * From the Alteon sample driver:\n\t * Must insure that we do not cross an 8K (bytes) boundary\n\t * for DMA reads.  Our highest limit is 1K bytes.  This is a \n\t * restriction on some ALPHA platforms with early revision \n\t * 21174 PCI chipsets, such as the AlphaPC 164lx \n\t */\n\tTI_SETBIT(sc, TI_PCI_STATE, pci_writemax|TI_PCI_READMAX_1024);\n#else\n\tTI_SETBIT(sc, TI_PCI_STATE, pci_writemax);\n#endif\n\n\t/* This sets the min dma param all the way up (0xff). */\n\tTI_SETBIT(sc, TI_PCI_STATE, TI_PCISTATE_MINDMA);\n\n\t/* Configure DMA variables. */\n#if BYTE_ORDER == BIG_ENDIAN\n\tCSR_WRITE_4(sc, TI_GCR_OPMODE, TI_OPMODE_BYTESWAP_BD |\n\t    TI_OPMODE_BYTESWAP_DATA | TI_OPMODE_WORDSWAP_BD |\n\t    TI_OPMODE_WARN_ENB | TI_OPMODE_FATAL_ENB |\n\t    TI_OPMODE_DONT_FRAG_JUMBO);\n#else\n\tCSR_WRITE_4(sc, TI_GCR_OPMODE, TI_OPMODE_BYTESWAP_DATA|\n\t    TI_OPMODE_WORDSWAP_BD|TI_OPMODE_DONT_FRAG_JUMBO|\n\t    TI_OPMODE_WARN_ENB|TI_OPMODE_FATAL_ENB);\n#endif\n\n\t/*\n\t * Only allow 1 DMA channel to be active at a time.\n\t * I don't think this is a good idea, but without it\n\t * the firmware racks up lots of nicDmaReadRingFull\n\t * errors.\n\t */\n#ifndef TI_CSUM_OFFLOAD\n\tTI_SETBIT(sc, TI_GCR_OPMODE, TI_OPMODE_1_DMA_ACTIVE);\n#endif\n\n\t/* Recommended settings from Tigon manual. */\n\tCSR_WRITE_4(sc, TI_GCR_DMA_WRITECFG, TI_DMA_STATE_THRESH_8W);\n\tCSR_WRITE_4(sc, TI_GCR_DMA_READCFG, TI_DMA_STATE_THRESH_8W);\n\n\tif (ti_64bitslot_war(sc)) {\n\t\tprintf(\"%s: bios thinks we're in a 64 bit slot, \"\n\t\t    \"but we aren't\", sc->sc_dv.dv_xname);\n\t\treturn(EINVAL);\n\t}\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_mem",
          "args": [
            "sc",
            "0x2000",
            "0x100000 - 0x2000",
            "NULL"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "ti_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "333-365",
          "snippet": "void ti_mem(sc, addr, len, buf)\n\tstruct ti_softc\t\t*sc;\n\tu_int32_t\t\taddr, len;\n\tcaddr_t\t\t\tbuf;\n{\n\tint\t\t\tsegptr, segsize, cnt;\n\tcaddr_t\t\t\tti_winbase, ptr;\n\n\tsegptr = addr;\n\tcnt = len;\n\tti_winbase = (caddr_t)(sc->ti_bhandle + TI_WINDOW);\n\tptr = buf;\n\n\twhile(cnt) {\n\t\tif (cnt < TI_WINLEN)\n\t\t\tsegsize = cnt;\n\t\telse\n\t\t\tsegsize = TI_WINLEN - (segptr % TI_WINLEN);\n\t\tCSR_WRITE_4(sc, TI_WINBASE, (segptr & ~(TI_WINLEN - 1)));\n\t\tif (buf == NULL)\n\t\t\tbzero((char *)ti_winbase + (segptr &\n\t\t\t    (TI_WINLEN - 1)), segsize);\n\t\telse {\n\t\t\tbcopy((char *)ptr, (char *)ti_winbase +\n\t\t\t    (segptr & (TI_WINLEN - 1)), segsize);\n\t\t\tptr += segsize;\n\t\t}\n\t\tsegptr += segsize;\n\t\tcnt -= segsize;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_mem",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_mem;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_mem(sc, addr, len, buf)\n\tstruct ti_softc\t\t*sc;\n\tu_int32_t\t\taddr, len;\n\tcaddr_t\t\t\tbuf;\n{\n\tint\t\t\tsegptr, segsize, cnt;\n\tcaddr_t\t\t\tti_winbase, ptr;\n\n\tsegptr = addr;\n\tcnt = len;\n\tti_winbase = (caddr_t)(sc->ti_bhandle + TI_WINDOW);\n\tptr = buf;\n\n\twhile(cnt) {\n\t\tif (cnt < TI_WINLEN)\n\t\t\tsegsize = cnt;\n\t\telse\n\t\t\tsegsize = TI_WINLEN - (segptr % TI_WINLEN);\n\t\tCSR_WRITE_4(sc, TI_WINBASE, (segptr & ~(TI_WINLEN - 1)));\n\t\tif (buf == NULL)\n\t\t\tbzero((char *)ti_winbase + (segptr &\n\t\t\t    (TI_WINLEN - 1)), segsize);\n\t\telse {\n\t\t\tbcopy((char *)ptr, (char *)ti_winbase +\n\t\t\t    (segptr & (TI_WINLEN - 1)), segsize);\n\t\t\tptr += segsize;\n\t\t}\n\t\tsegptr += segsize;\n\t\tcnt -= segsize;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pc",
            "ih",
            "IPL_NET",
            "ti_intr",
            "sc",
            "self->dv_xname"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pc",
            "ih"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&ih"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "pa->pa_memt",
            "iobase",
            "iosize",
            "0",
            "&sc->ti_bhandle"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_mem_find",
          "args": [
            "pc",
            "pa->pa_tag",
            "TI_PCI_LOMEM",
            "&iobase",
            "&iosize",
            "NULL"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mem_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "197-208",
          "snippet": "int\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_mem_find;\n\nint\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG",
            "command"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_attach;\nint ti_intr;\nvoid ti_start;\nint ti_ioctl;\nvoid ti_watchdog;\nvoid ti_shutdown;\nint ti_ifmedia_upd;\nvoid ti_ifmedia_sts;\nint ti_read_eeprom;\nvoid ti_mem;\nint ti_alloc_jumbo_mem;\nint ti_chipinit;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid\nti_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct ti_softc *sc = (struct ti_softc *)self;\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr = NULL;\n\tbus_addr_t iobase;\n\tbus_size_t iosize;\n\tbus_dma_segment_t seg;\n\tbus_dmamap_t dmamap;\n\tint s, rseg;\n\tu_int32_t command;\n\tstruct ifnet *ifp;\n\tcaddr_t kva;\n\n\ts = splimp();\n\n\t/*\n\t * Map control/status registers.\n\t */\n\tcommand = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\tcommand |= PCI_COMMAND_MEM_ENABLE | PCI_COMMAND_MASTER_ENABLE;\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);\n\tcommand = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\n\tif (!(command & PCI_COMMAND_MEM_ENABLE)) {\n\t\tprintf(\"%s: failed to enable memory mapping!\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\t\tfree(sc, M_DEVBUF);\n\t\tgoto fail;\n\t}\n\tif (pci_mem_find(pc, pa->pa_tag, TI_PCI_LOMEM, &iobase, &iosize, NULL)) {\n\t\tprintf(\": can't find mem space\\n\");\n\t\tgoto fail;\n\t}\n\tif (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->ti_bhandle)) {\n\t\tprintf(\": can't map mem space\\n\");\n\t\tgoto fail;\n\t}\n\tsc->ti_btag = pa->pa_memt;\n\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\tgoto fail;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->ti_intrhand = pci_intr_establish(pc, ih, IPL_NET, ti_intr, sc,\n\t    self->dv_xname);\n\tif (sc->ti_intrhand == NULL) {\n\t\tprintf(\": couldn't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (ti_chipinit(sc)) {\n\t\tprintf(\"%s: chip initialization failed\\n\", sc->sc_dv.dv_xname);\n\t\tgoto fail;\n\t}\n\n\t/* Zero out the NIC's on-board SRAM. */\n\tti_mem(sc, 0x2000, 0x100000 - 0x2000,  NULL);\n\n\t/* Init again -- zeroing memory may have clobbered some registers. */\n\tif (ti_chipinit(sc)) {\n\t\tprintf(\"%s: chip initialization failed\\n\", sc->sc_dv.dv_xname);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * Get station address from the EEPROM. Note: the manual states\n\t * that the MAC address is at offset 0x8c, however the data is\n\t * stored as two longwords (since that's how it's loaded into\n\t * the NIC). This means the MAC address is actually preceeded\n\t * by two zero bytes. We need to skip over those.\n\t */\n\tif (ti_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,\n\t\t\t\tTI_EE_MAC_OFFSET + 2, ETHER_ADDR_LEN)) {\n\t\tprintf(\"%s: failed to read station address\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\t\tfree(sc, M_DEVBUF);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * A Tigon chip was detected. Inform the world.\n\t */\n\tprintf(\": %s address %s\\n\", intrstr,\n\t     ether_sprintf(sc->arpcom.ac_enaddr));\n\n\t/* Allocate the general information block and ring buffers. */\n\tsc->sc_dmatag = pa->pa_dmat;\n\tif (bus_dmamem_alloc(sc->sc_dmatag, sizeof(struct ti_ring_data),\n\t    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't alloc rx buffers\\n\", sc->sc_dv.dv_xname);\n\t\tgoto fail;\n\t}\n\tif (bus_dmamem_map(sc->sc_dmatag, &seg, rseg,\n\t    sizeof(struct ti_ring_data), &kva, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't map dma buffers (%d bytes)\\n\",\n\t\t       sc->sc_dv.dv_xname, sizeof(struct ti_ring_data));\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\tgoto fail;\n\t}\n\tif (bus_dmamap_create(sc->sc_dmatag, sizeof(struct ti_ring_data), 1,\n\t    sizeof(struct ti_ring_data), 0, BUS_DMA_NOWAIT, &dmamap)) {\n\t\tprintf(\"%s: can't create dma map\\n\", sc->sc_dv.dv_xname);\n\t\tbus_dmamem_unmap(sc->sc_dmatag, kva,\n\t\t    sizeof(struct ti_ring_data));\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\tgoto fail;\n\t}\n\tif (bus_dmamap_load(sc->sc_dmatag, dmamap, kva,\n\t    sizeof(struct ti_ring_data), NULL, BUS_DMA_NOWAIT)) {\n\t\tbus_dmamap_destroy(sc->sc_dmatag, dmamap);\n\t\tbus_dmamem_unmap(sc->sc_dmatag, kva,\n\t\t    sizeof(struct ti_ring_data));\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\tgoto fail;\n\t}\n\tsc->ti_rdata = (struct ti_ring_data *)kva;\n\tbzero(sc->ti_rdata, sizeof(struct ti_ring_data));\n\n\t/* Try to allocate memory for jumbo buffers. */\n\tif (ti_alloc_jumbo_mem(sc)) {\n\t\tprintf(\"%s: jumbo buffer allocation failed\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\t\tgoto fail;\n\t}\n\n\t/* Set default tuneable values. */\n\tsc->ti_stat_ticks = 2 * TI_TICKS_PER_SEC;\n\tsc->ti_rx_coal_ticks = TI_TICKS_PER_SEC / 5000;\n\tsc->ti_tx_coal_ticks = TI_TICKS_PER_SEC / 500;\n\tsc->ti_rx_max_coal_bds = 64;\n\tsc->ti_tx_max_coal_bds = 128;\n\tsc->ti_tx_buf_ratio = 21;\n\n\t/* Set up ifnet structure */\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = ti_ioctl;\n\tifp->if_output = ether_output;\n\tifp->if_start = ti_start;\n\tifp->if_watchdog = ti_watchdog;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_snd.ifq_maxlen = TI_TX_RING_CNT - 1;\n\tbcopy(sc->sc_dv.dv_xname, ifp->if_xname, IFNAMSIZ);\n\n\t/* Set up ifmedia support. */\n\tifmedia_init(&sc->ifmedia, IFM_IMASK, ti_ifmedia_upd, ti_ifmedia_sts);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_FL, 0, NULL);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_FL|IFM_FDX, 0, NULL);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_FX, 0, NULL);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_FX|IFM_FDX, 0, NULL);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_1000_SX, 0, NULL);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_1000_SX|IFM_FDX, 0, NULL);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);\n\tifmedia_set(&sc->ifmedia, IFM_ETHER|IFM_AUTO);\n\n\t/*\n\t * Call MI attach routines.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->arpcom.ac_if.if_bpf, ifp,\n\t    DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\n\tshutdownhook_establish(ti_shutdown, sc);\n\nfail:\n\tsplx(s);\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "1482-1512",
    "snippet": "int\nti_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = (struct pci_attach_args *)aux;\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_NETGEAR &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NETGEAR_GA620)\n\t\treturn (1);\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ALTEON &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALTEON_ACENIC)\n\t\treturn (1);\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_3COM &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_3COM_3C985)\n\t\treturn (1);\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SGI &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SGI_TIGON)\n\t\treturn (1);\n\n\t/* This is really a Farallon board, they used the wrong vendorid */\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_DEC &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DEC_PN9000SX)\n\t\treturn (1);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ti_probe"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_probe;\n\nint\nti_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = (struct pci_attach_args *)aux;\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_NETGEAR &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NETGEAR_GA620)\n\t\treturn (1);\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ALTEON &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALTEON_ACENIC)\n\t\treturn (1);\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_3COM &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_3COM_3C985)\n\t\treturn (1);\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SGI &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SGI_TIGON)\n\t\treturn (1);\n\n\t/* This is really a Farallon board, they used the wrong vendorid */\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_DEC &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DEC_PN9000SX)\n\t\treturn (1);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "ti_gibinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "1312-1476",
    "snippet": "int ti_gibinit(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ti_rcb\t\t*rcb;\n\tint\t\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Disable interrupts for now. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);\n\n\t/* Tell the chip where to find the general information block. */\n\tCSR_WRITE_4(sc, TI_GCR_GENINFO_HI, 0);\n\tCSR_WRITE_4(sc, TI_GCR_GENINFO_LO, vtophys(&sc->ti_rdata->ti_info));\n\n\t/* Load the firmware into SRAM. */\n\tti_loadfw(sc);\n\n\t/* Set up the contents of the general info and ring control blocks. */\n\n\t/* Set up the event ring and producer pointer. */\n\trcb = &sc->ti_rdata->ti_info.ti_ev_rcb;\n\n\tTI_HOSTADDR(rcb->ti_hostaddr) = vtophys(&sc->ti_rdata->ti_event_ring);\n\trcb->ti_flags = 0;\n\tTI_HOSTADDR(sc->ti_rdata->ti_info.ti_ev_prodidx_ptr) =\n\t    vtophys(&sc->ti_ev_prodidx);\n\tsc->ti_ev_prodidx.ti_idx = 0;\n\tCSR_WRITE_4(sc, TI_GCR_EVENTCONS_IDX, 0);\n\tsc->ti_ev_saved_considx = 0;\n\n\t/* Set up the command ring and producer mailbox. */\n\trcb = &sc->ti_rdata->ti_info.ti_cmd_rcb;\n\n\tsc->ti_rdata->ti_cmd_ring =\n\t    (struct ti_cmd_desc *)(sc->ti_bhandle + TI_GCR_CMDRING);\n\tTI_HOSTADDR(rcb->ti_hostaddr) = TI_GCR_NIC_ADDR(TI_GCR_CMDRING);\n\trcb->ti_flags = 0;\n\trcb->ti_max_len = 0;\n\tfor (i = 0; i < TI_CMD_RING_CNT; i++) {\n\t\tCSR_WRITE_4(sc, TI_GCR_CMDRING + (i * 4), 0);\n\t}\n\tCSR_WRITE_4(sc, TI_GCR_CMDCONS_IDX, 0);\n\tCSR_WRITE_4(sc, TI_MB_CMDPROD_IDX, 0);\n\tsc->ti_cmd_saved_prodidx = 0;\n\n\t/*\n\t * Assign the address of the stats refresh buffer.\n\t * We re-use the current stats buffer for this to\n\t * conserve memory.\n\t */\n\tTI_HOSTADDR(sc->ti_rdata->ti_info.ti_refresh_stats_ptr) =\n\t    vtophys(&sc->ti_rdata->ti_info.ti_stats);\n\n\t/* Set up the standard receive ring. */\n\trcb = &sc->ti_rdata->ti_info.ti_std_rx_rcb;\n\tTI_HOSTADDR(rcb->ti_hostaddr) = vtophys(&sc->ti_rdata->ti_rx_std_ring);\n\trcb->ti_max_len = TI_FRAMELEN;\n\trcb->ti_flags = 0;\n#ifdef TI_CSUM_OFFLOAD\n\trcb->ti_flags |= TI_RCB_FLAG_TCP_UDP_CKSUM|TI_RCB_FLAG_IP_CKSUM;\n#endif\n#if NVLAN > 0\n\trcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;\n#endif\n\n\t/* Set up the jumbo receive ring. */\n\trcb = &sc->ti_rdata->ti_info.ti_jumbo_rx_rcb;\n\tTI_HOSTADDR(rcb->ti_hostaddr) =\n\t    vtophys(&sc->ti_rdata->ti_rx_jumbo_ring);\n\trcb->ti_max_len = TI_JUMBO_FRAMELEN;\n\trcb->ti_flags = 0;\n#ifdef TI_CSUM_OFFLOAD\n\trcb->ti_flags |= TI_RCB_FLAG_TCP_UDP_CKSUM|TI_RCB_FLAG_IP_CKSUM;\n#endif\n#if NVLAN > 0\n\trcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;\n#endif\n\n\t/*\n\t * Set up the mini ring. Only activated on the\n\t * Tigon 2 but the slot in the config block is\n\t * still there on the Tigon 1.\n\t */\n\trcb = &sc->ti_rdata->ti_info.ti_mini_rx_rcb;\n\tTI_HOSTADDR(rcb->ti_hostaddr) =\n\t    vtophys(&sc->ti_rdata->ti_rx_mini_ring);\n\trcb->ti_max_len = MHLEN - ETHER_ALIGN;\n\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\trcb->ti_flags = TI_RCB_FLAG_RING_DISABLED;\n\telse\n\t\trcb->ti_flags = 0;\n#ifdef TI_CSUM_OFFLOAD\n\trcb->ti_flags |= TI_RCB_FLAG_TCP_UDP_CKSUM|TI_RCB_FLAG_IP_CKSUM;\n#endif\n#if NVLAN > 0\n\trcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;\n#endif\n\n\t/*\n\t * Set up the receive return ring.\n\t */\n\trcb = &sc->ti_rdata->ti_info.ti_return_rcb;\n\tTI_HOSTADDR(rcb->ti_hostaddr) =\n\t    vtophys(&sc->ti_rdata->ti_rx_return_ring);\n\trcb->ti_flags = 0;\n\trcb->ti_max_len = TI_RETURN_RING_CNT;\n\tTI_HOSTADDR(sc->ti_rdata->ti_info.ti_return_prodidx_ptr) =\n\t    vtophys(&sc->ti_return_prodidx);\n\n\t/*\n\t * Set up the tx ring. Note: for the Tigon 2, we have the option\n\t * of putting the transmit ring in the host's address space and\n\t * letting the chip DMA it instead of leaving the ring in the NIC's\n\t * memory and accessing it through the shared memory region. We\n\t * do this for the Tigon 2, but it doesn't work on the Tigon 1,\n\t * so we have to revert to the shared memory scheme if we detect\n\t * a Tigon 1 chip.\n\t */\n\tCSR_WRITE_4(sc, TI_WINBASE, TI_TX_RING_BASE);\n\tif (sc->ti_hwrev == TI_HWREV_TIGON) {\n\t\tsc->ti_rdata->ti_tx_ring_nic =\n\t\t    (struct ti_tx_desc *)(sc->ti_bhandle + TI_WINDOW);\n\t}\n\tbzero((char *)sc->ti_rdata->ti_tx_ring,\n\t    TI_TX_RING_CNT * sizeof(struct ti_tx_desc));\n\trcb = &sc->ti_rdata->ti_info.ti_tx_rcb;\n\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\trcb->ti_flags = 0;\n\telse\n\t\trcb->ti_flags = TI_RCB_FLAG_HOST_RING;\n#if NVLAN > 0\n\trcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;\n#endif\n\trcb->ti_max_len = TI_TX_RING_CNT;\n\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\tTI_HOSTADDR(rcb->ti_hostaddr) = TI_TX_RING_BASE;\n\telse\n\t\tTI_HOSTADDR(rcb->ti_hostaddr) =\n\t\t    vtophys(&sc->ti_rdata->ti_tx_ring);\n\tTI_HOSTADDR(sc->ti_rdata->ti_info.ti_tx_considx_ptr) =\n\t    vtophys(&sc->ti_tx_considx);\n\n\t/* Set up tuneables */\n\tif (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))\n\t\tCSR_WRITE_4(sc, TI_GCR_RX_COAL_TICKS,\n\t\t    (sc->ti_rx_coal_ticks / 10));\n\telse\n\t\tCSR_WRITE_4(sc, TI_GCR_RX_COAL_TICKS, sc->ti_rx_coal_ticks);\n\tCSR_WRITE_4(sc, TI_GCR_TX_COAL_TICKS, sc->ti_tx_coal_ticks);\n\tCSR_WRITE_4(sc, TI_GCR_STAT_TICKS, sc->ti_stat_ticks);\n\tCSR_WRITE_4(sc, TI_GCR_RX_MAX_COAL_BD, sc->ti_rx_max_coal_bds);\n\tCSR_WRITE_4(sc, TI_GCR_TX_MAX_COAL_BD, sc->ti_tx_max_coal_bds);\n\tCSR_WRITE_4(sc, TI_GCR_TX_BUFFER_RATIO, sc->ti_tx_buf_ratio);\n\n\t/* Turn interrupts on. */\n\tCSR_WRITE_4(sc, TI_GCR_MASK_INTRS, 0);\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 0);\n\n\t/* Start CPU. */\n\tTI_CLRBIT(sc, TI_CPU_STATE, (TI_CPUSTATE_HALT|TI_CPUSTATE_STEP));\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_loadfw",
      "int ti_gibinit",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TI_CLRBIT",
          "args": [
            "sc",
            "TI_CPU_STATE",
            "(TI_CPUSTATE_HALT|TI_CPUSTATE_STEP)"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_MB_HOSTINTR",
            "0"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_MASK_INTRS",
            "0"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_TX_BUFFER_RATIO",
            "sc->ti_tx_buf_ratio"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_TX_MAX_COAL_BD",
            "sc->ti_tx_max_coal_bds"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_RX_MAX_COAL_BD",
            "sc->ti_rx_max_coal_bds"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_STAT_TICKS",
            "sc->ti_stat_ticks"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_TX_COAL_TICKS",
            "sc->ti_tx_coal_ticks"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_RX_COAL_TICKS",
            "sc->ti_rx_coal_ticks"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_RX_COAL_TICKS",
            "(sc->ti_rx_coal_ticks / 10)"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->ti_tx_considx"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_HOSTADDR",
          "args": [
            "sc->ti_rdata->ti_info.ti_tx_considx_ptr"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->ti_rdata->ti_tx_ring"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_HOSTADDR",
          "args": [
            "rcb->ti_hostaddr"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_HOSTADDR",
          "args": [
            "rcb->ti_hostaddr"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)sc->ti_rdata->ti_tx_ring",
            "TI_TX_RING_CNT * sizeof(struct ti_tx_desc)"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_WINBASE",
            "TI_TX_RING_BASE"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->ti_return_prodidx"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_HOSTADDR",
          "args": [
            "sc->ti_rdata->ti_info.ti_return_prodidx_ptr"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->ti_rdata->ti_rx_return_ring"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_HOSTADDR",
          "args": [
            "rcb->ti_hostaddr"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->ti_rdata->ti_rx_mini_ring"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_HOSTADDR",
          "args": [
            "rcb->ti_hostaddr"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->ti_rdata->ti_rx_jumbo_ring"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_HOSTADDR",
          "args": [
            "rcb->ti_hostaddr"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->ti_rdata->ti_rx_std_ring"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_HOSTADDR",
          "args": [
            "rcb->ti_hostaddr"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->ti_rdata->ti_info.ti_stats"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_HOSTADDR",
          "args": [
            "sc->ti_rdata->ti_info.ti_refresh_stats_ptr"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_MB_CMDPROD_IDX",
            "0"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_CMDCONS_IDX",
            "0"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_CMDRING + (i * 4)",
            "0"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_GCR_NIC_ADDR",
          "args": [
            "TI_GCR_CMDRING"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_HOSTADDR",
          "args": [
            "rcb->ti_hostaddr"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_EVENTCONS_IDX",
            "0"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->ti_ev_prodidx"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_HOSTADDR",
          "args": [
            "sc->ti_rdata->ti_info.ti_ev_prodidx_ptr"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->ti_rdata->ti_event_ring"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_HOSTADDR",
          "args": [
            "rcb->ti_hostaddr"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ti_loadfw",
          "args": [
            "sc"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "ti_loadfw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "372-425",
          "snippet": "void ti_loadfw(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tswitch(sc->ti_hwrev) {\n\tcase TI_HWREV_TIGON:\n\t\tif (tigonFwReleaseMajor != TI_FIRMWARE_MAJOR ||\n\t\t    tigonFwReleaseMinor != TI_FIRMWARE_MINOR ||\n\t\t    tigonFwReleaseFix != TI_FIRMWARE_FIX) {\n\t\t\tprintf(\"%s: firmware revision mismatch; want \"\n\t\t\t    \"%d.%d.%d, got %d.%d.%d\\n\", sc->sc_dv.dv_xname,\n\t\t\t    TI_FIRMWARE_MAJOR, TI_FIRMWARE_MINOR,\n\t\t\t    TI_FIRMWARE_FIX, tigonFwReleaseMajor,\n\t\t\t    tigonFwReleaseMinor, tigonFwReleaseFix);\n\t\t\treturn;\n\t\t}\n\t\tti_mem(sc, tigonFwTextAddr, tigonFwTextLen,\n\t\t    (caddr_t)tigonFwText);\n\t\tti_mem(sc, tigonFwDataAddr, tigonFwDataLen,\n\t\t    (caddr_t)tigonFwData);\n\t\tti_mem(sc, tigonFwRodataAddr, tigonFwRodataLen,\n\t\t    (caddr_t)tigonFwRodata);\n\t\tti_mem(sc, tigonFwBssAddr, tigonFwBssLen, NULL);\n\t\tti_mem(sc, tigonFwSbssAddr, tigonFwSbssLen, NULL);\n\t\tCSR_WRITE_4(sc, TI_CPU_PROGRAM_COUNTER, tigonFwStartAddr);\n\t\tbreak;\n\tcase TI_HWREV_TIGON_II:\n\t\tif (tigon2FwReleaseMajor != TI_FIRMWARE_MAJOR ||\n\t\t    tigon2FwReleaseMinor != TI_FIRMWARE_MINOR ||\n\t\t    tigon2FwReleaseFix != TI_FIRMWARE_FIX) {\n\t\t\tprintf(\"%s: firmware revision mismatch; want \"\n\t\t\t    \"%d.%d.%d, got %d.%d.%d\\n\", sc->sc_dv.dv_xname,\n\t\t\t    TI_FIRMWARE_MAJOR, TI_FIRMWARE_MINOR,\n\t\t\t    TI_FIRMWARE_FIX, tigon2FwReleaseMajor,\n\t\t\t    tigon2FwReleaseMinor, tigon2FwReleaseFix);\n\t\t\treturn;\n\t\t}\n\t\tti_mem(sc, tigon2FwTextAddr, tigon2FwTextLen,\n\t\t    (caddr_t)tigon2FwText);\n\t\tti_mem(sc, tigon2FwDataAddr, tigon2FwDataLen,\n\t\t    (caddr_t)tigon2FwData);\n\t\tti_mem(sc, tigon2FwRodataAddr, tigon2FwRodataLen,\n\t\t    (caddr_t)tigon2FwRodata);\n\t\tti_mem(sc, tigon2FwBssAddr, tigon2FwBssLen, NULL);\n\t\tti_mem(sc, tigon2FwSbssAddr, tigon2FwSbssLen, NULL);\n\t\tCSR_WRITE_4(sc, TI_CPU_PROGRAM_COUNTER, tigon2FwStartAddr);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: can't load firmware: unknown hardware rev\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\t\tbreak;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_mem",
            "void ti_loadfw",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_mem;\nvoid ti_loadfw;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_loadfw(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tswitch(sc->ti_hwrev) {\n\tcase TI_HWREV_TIGON:\n\t\tif (tigonFwReleaseMajor != TI_FIRMWARE_MAJOR ||\n\t\t    tigonFwReleaseMinor != TI_FIRMWARE_MINOR ||\n\t\t    tigonFwReleaseFix != TI_FIRMWARE_FIX) {\n\t\t\tprintf(\"%s: firmware revision mismatch; want \"\n\t\t\t    \"%d.%d.%d, got %d.%d.%d\\n\", sc->sc_dv.dv_xname,\n\t\t\t    TI_FIRMWARE_MAJOR, TI_FIRMWARE_MINOR,\n\t\t\t    TI_FIRMWARE_FIX, tigonFwReleaseMajor,\n\t\t\t    tigonFwReleaseMinor, tigonFwReleaseFix);\n\t\t\treturn;\n\t\t}\n\t\tti_mem(sc, tigonFwTextAddr, tigonFwTextLen,\n\t\t    (caddr_t)tigonFwText);\n\t\tti_mem(sc, tigonFwDataAddr, tigonFwDataLen,\n\t\t    (caddr_t)tigonFwData);\n\t\tti_mem(sc, tigonFwRodataAddr, tigonFwRodataLen,\n\t\t    (caddr_t)tigonFwRodata);\n\t\tti_mem(sc, tigonFwBssAddr, tigonFwBssLen, NULL);\n\t\tti_mem(sc, tigonFwSbssAddr, tigonFwSbssLen, NULL);\n\t\tCSR_WRITE_4(sc, TI_CPU_PROGRAM_COUNTER, tigonFwStartAddr);\n\t\tbreak;\n\tcase TI_HWREV_TIGON_II:\n\t\tif (tigon2FwReleaseMajor != TI_FIRMWARE_MAJOR ||\n\t\t    tigon2FwReleaseMinor != TI_FIRMWARE_MINOR ||\n\t\t    tigon2FwReleaseFix != TI_FIRMWARE_FIX) {\n\t\t\tprintf(\"%s: firmware revision mismatch; want \"\n\t\t\t    \"%d.%d.%d, got %d.%d.%d\\n\", sc->sc_dv.dv_xname,\n\t\t\t    TI_FIRMWARE_MAJOR, TI_FIRMWARE_MINOR,\n\t\t\t    TI_FIRMWARE_FIX, tigon2FwReleaseMajor,\n\t\t\t    tigon2FwReleaseMinor, tigon2FwReleaseFix);\n\t\t\treturn;\n\t\t}\n\t\tti_mem(sc, tigon2FwTextAddr, tigon2FwTextLen,\n\t\t    (caddr_t)tigon2FwText);\n\t\tti_mem(sc, tigon2FwDataAddr, tigon2FwDataLen,\n\t\t    (caddr_t)tigon2FwData);\n\t\tti_mem(sc, tigon2FwRodataAddr, tigon2FwRodataLen,\n\t\t    (caddr_t)tigon2FwRodata);\n\t\tti_mem(sc, tigon2FwBssAddr, tigon2FwBssLen, NULL);\n\t\tti_mem(sc, tigon2FwSbssAddr, tigon2FwSbssLen, NULL);\n\t\tCSR_WRITE_4(sc, TI_CPU_PROGRAM_COUNTER, tigon2FwStartAddr);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: can't load firmware: unknown hardware rev\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\t\tbreak;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_GENINFO_LO",
            "vtophys(&sc->ti_rdata->ti_info)"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->ti_rdata->ti_info"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_GENINFO_HI",
            "0"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_MB_HOSTINTR",
            "1"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_loadfw;\nint ti_gibinit;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_gibinit(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ti_rcb\t\t*rcb;\n\tint\t\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Disable interrupts for now. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);\n\n\t/* Tell the chip where to find the general information block. */\n\tCSR_WRITE_4(sc, TI_GCR_GENINFO_HI, 0);\n\tCSR_WRITE_4(sc, TI_GCR_GENINFO_LO, vtophys(&sc->ti_rdata->ti_info));\n\n\t/* Load the firmware into SRAM. */\n\tti_loadfw(sc);\n\n\t/* Set up the contents of the general info and ring control blocks. */\n\n\t/* Set up the event ring and producer pointer. */\n\trcb = &sc->ti_rdata->ti_info.ti_ev_rcb;\n\n\tTI_HOSTADDR(rcb->ti_hostaddr) = vtophys(&sc->ti_rdata->ti_event_ring);\n\trcb->ti_flags = 0;\n\tTI_HOSTADDR(sc->ti_rdata->ti_info.ti_ev_prodidx_ptr) =\n\t    vtophys(&sc->ti_ev_prodidx);\n\tsc->ti_ev_prodidx.ti_idx = 0;\n\tCSR_WRITE_4(sc, TI_GCR_EVENTCONS_IDX, 0);\n\tsc->ti_ev_saved_considx = 0;\n\n\t/* Set up the command ring and producer mailbox. */\n\trcb = &sc->ti_rdata->ti_info.ti_cmd_rcb;\n\n\tsc->ti_rdata->ti_cmd_ring =\n\t    (struct ti_cmd_desc *)(sc->ti_bhandle + TI_GCR_CMDRING);\n\tTI_HOSTADDR(rcb->ti_hostaddr) = TI_GCR_NIC_ADDR(TI_GCR_CMDRING);\n\trcb->ti_flags = 0;\n\trcb->ti_max_len = 0;\n\tfor (i = 0; i < TI_CMD_RING_CNT; i++) {\n\t\tCSR_WRITE_4(sc, TI_GCR_CMDRING + (i * 4), 0);\n\t}\n\tCSR_WRITE_4(sc, TI_GCR_CMDCONS_IDX, 0);\n\tCSR_WRITE_4(sc, TI_MB_CMDPROD_IDX, 0);\n\tsc->ti_cmd_saved_prodidx = 0;\n\n\t/*\n\t * Assign the address of the stats refresh buffer.\n\t * We re-use the current stats buffer for this to\n\t * conserve memory.\n\t */\n\tTI_HOSTADDR(sc->ti_rdata->ti_info.ti_refresh_stats_ptr) =\n\t    vtophys(&sc->ti_rdata->ti_info.ti_stats);\n\n\t/* Set up the standard receive ring. */\n\trcb = &sc->ti_rdata->ti_info.ti_std_rx_rcb;\n\tTI_HOSTADDR(rcb->ti_hostaddr) = vtophys(&sc->ti_rdata->ti_rx_std_ring);\n\trcb->ti_max_len = TI_FRAMELEN;\n\trcb->ti_flags = 0;\n#ifdef TI_CSUM_OFFLOAD\n\trcb->ti_flags |= TI_RCB_FLAG_TCP_UDP_CKSUM|TI_RCB_FLAG_IP_CKSUM;\n#endif\n#if NVLAN > 0\n\trcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;\n#endif\n\n\t/* Set up the jumbo receive ring. */\n\trcb = &sc->ti_rdata->ti_info.ti_jumbo_rx_rcb;\n\tTI_HOSTADDR(rcb->ti_hostaddr) =\n\t    vtophys(&sc->ti_rdata->ti_rx_jumbo_ring);\n\trcb->ti_max_len = TI_JUMBO_FRAMELEN;\n\trcb->ti_flags = 0;\n#ifdef TI_CSUM_OFFLOAD\n\trcb->ti_flags |= TI_RCB_FLAG_TCP_UDP_CKSUM|TI_RCB_FLAG_IP_CKSUM;\n#endif\n#if NVLAN > 0\n\trcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;\n#endif\n\n\t/*\n\t * Set up the mini ring. Only activated on the\n\t * Tigon 2 but the slot in the config block is\n\t * still there on the Tigon 1.\n\t */\n\trcb = &sc->ti_rdata->ti_info.ti_mini_rx_rcb;\n\tTI_HOSTADDR(rcb->ti_hostaddr) =\n\t    vtophys(&sc->ti_rdata->ti_rx_mini_ring);\n\trcb->ti_max_len = MHLEN - ETHER_ALIGN;\n\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\trcb->ti_flags = TI_RCB_FLAG_RING_DISABLED;\n\telse\n\t\trcb->ti_flags = 0;\n#ifdef TI_CSUM_OFFLOAD\n\trcb->ti_flags |= TI_RCB_FLAG_TCP_UDP_CKSUM|TI_RCB_FLAG_IP_CKSUM;\n#endif\n#if NVLAN > 0\n\trcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;\n#endif\n\n\t/*\n\t * Set up the receive return ring.\n\t */\n\trcb = &sc->ti_rdata->ti_info.ti_return_rcb;\n\tTI_HOSTADDR(rcb->ti_hostaddr) =\n\t    vtophys(&sc->ti_rdata->ti_rx_return_ring);\n\trcb->ti_flags = 0;\n\trcb->ti_max_len = TI_RETURN_RING_CNT;\n\tTI_HOSTADDR(sc->ti_rdata->ti_info.ti_return_prodidx_ptr) =\n\t    vtophys(&sc->ti_return_prodidx);\n\n\t/*\n\t * Set up the tx ring. Note: for the Tigon 2, we have the option\n\t * of putting the transmit ring in the host's address space and\n\t * letting the chip DMA it instead of leaving the ring in the NIC's\n\t * memory and accessing it through the shared memory region. We\n\t * do this for the Tigon 2, but it doesn't work on the Tigon 1,\n\t * so we have to revert to the shared memory scheme if we detect\n\t * a Tigon 1 chip.\n\t */\n\tCSR_WRITE_4(sc, TI_WINBASE, TI_TX_RING_BASE);\n\tif (sc->ti_hwrev == TI_HWREV_TIGON) {\n\t\tsc->ti_rdata->ti_tx_ring_nic =\n\t\t    (struct ti_tx_desc *)(sc->ti_bhandle + TI_WINDOW);\n\t}\n\tbzero((char *)sc->ti_rdata->ti_tx_ring,\n\t    TI_TX_RING_CNT * sizeof(struct ti_tx_desc));\n\trcb = &sc->ti_rdata->ti_info.ti_tx_rcb;\n\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\trcb->ti_flags = 0;\n\telse\n\t\trcb->ti_flags = TI_RCB_FLAG_HOST_RING;\n#if NVLAN > 0\n\trcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;\n#endif\n\trcb->ti_max_len = TI_TX_RING_CNT;\n\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\tTI_HOSTADDR(rcb->ti_hostaddr) = TI_TX_RING_BASE;\n\telse\n\t\tTI_HOSTADDR(rcb->ti_hostaddr) =\n\t\t    vtophys(&sc->ti_rdata->ti_tx_ring);\n\tTI_HOSTADDR(sc->ti_rdata->ti_info.ti_tx_considx_ptr) =\n\t    vtophys(&sc->ti_tx_considx);\n\n\t/* Set up tuneables */\n\tif (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))\n\t\tCSR_WRITE_4(sc, TI_GCR_RX_COAL_TICKS,\n\t\t    (sc->ti_rx_coal_ticks / 10));\n\telse\n\t\tCSR_WRITE_4(sc, TI_GCR_RX_COAL_TICKS, sc->ti_rx_coal_ticks);\n\tCSR_WRITE_4(sc, TI_GCR_TX_COAL_TICKS, sc->ti_tx_coal_ticks);\n\tCSR_WRITE_4(sc, TI_GCR_STAT_TICKS, sc->ti_stat_ticks);\n\tCSR_WRITE_4(sc, TI_GCR_RX_MAX_COAL_BD, sc->ti_rx_max_coal_bds);\n\tCSR_WRITE_4(sc, TI_GCR_TX_MAX_COAL_BD, sc->ti_tx_max_coal_bds);\n\tCSR_WRITE_4(sc, TI_GCR_TX_BUFFER_RATIO, sc->ti_tx_buf_ratio);\n\n\t/* Turn interrupts on. */\n\tCSR_WRITE_4(sc, TI_GCR_MASK_INTRS, 0);\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 0);\n\n\t/* Start CPU. */\n\tTI_CLRBIT(sc, TI_CPU_STATE, (TI_CPUSTATE_HALT|TI_CPUSTATE_STEP));\n\n\treturn(0);\n}"
  },
  {
    "function_name": "ti_chipinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "1169-1306",
    "snippet": "int ti_chipinit(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tu_int32_t\t\tcacheline;\n\tu_int32_t\t\tpci_writemax = 0;\n\n\t/* Initialize link to down state. */\n\tsc->ti_linkstat = TI_EV_CODE_LINK_DOWN;\n\n\t/* Set endianness before we access any non-PCI registers. */\n#if BYTE_ORDER == BIG_ENDIAN\n\tCSR_WRITE_4(sc, TI_MISC_HOST_CTL,\n\t    TI_MHC_BIGENDIAN_INIT | (TI_MHC_BIGENDIAN_INIT << 24));\n#else\n\tCSR_WRITE_4(sc, TI_MISC_HOST_CTL,\n\t    TI_MHC_LITTLEENDIAN_INIT | (TI_MHC_LITTLEENDIAN_INIT << 24));\n#endif\n\n\t/* Check the ROM failed bit to see if self-tests passed. */\n\tif (CSR_READ_4(sc, TI_CPU_STATE) & TI_CPUSTATE_ROMFAIL) {\n\t\tprintf(\"%s: board self-diagnostics failed!\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\t\treturn(ENODEV);\n\t}\n\n\t/* Halt the CPU. */\n\tTI_SETBIT(sc, TI_CPU_STATE, TI_CPUSTATE_HALT);\n\n\t/* Figure out the hardware revision. */\n\tswitch(CSR_READ_4(sc, TI_MISC_HOST_CTL) & TI_MHC_CHIP_REV_MASK) {\n\tcase TI_REV_TIGON_I:\n\t\tsc->ti_hwrev = TI_HWREV_TIGON;\n\t\tbreak;\n\tcase TI_REV_TIGON_II:\n\t\tsc->ti_hwrev = TI_HWREV_TIGON_II;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unsupported chip revision\\n\", sc->sc_dv.dv_xname);\n\t\treturn(ENODEV);\n\t}\n\n\t/* Do special setup for Tigon 2. */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II) {\n\t\tTI_SETBIT(sc, TI_CPU_CTL_B, TI_CPUSTATE_HALT);\n\t\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_SRAM_BANK_256K);\n\t\tTI_SETBIT(sc, TI_MISC_CONF, TI_MCR_SRAM_SYNCHRONOUS);\n\t}\n\n\t/* Set up the PCI state register. */\n\tCSR_WRITE_4(sc, TI_PCI_STATE, TI_PCI_READ_CMD|TI_PCI_WRITE_CMD);\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II) {\n\t\tTI_SETBIT(sc, TI_PCI_STATE, TI_PCISTATE_USE_MEM_RD_MULT);\n\t}\n\n\t/* Clear the read/write max DMA parameters. */\n\tTI_CLRBIT(sc, TI_PCI_STATE, (TI_PCISTATE_WRITE_MAXDMA|\n\t    TI_PCISTATE_READ_MAXDMA));\n\n\t/* Get cache line size. */\n\tcacheline = CSR_READ_4(sc, TI_PCI_BIST) & 0xFF;\n\n\t/*\n\t * If the system has set enabled the PCI memory write\n\t * and invalidate command in the command register, set\n\t * the write max parameter accordingly. This is necessary\n\t * to use MWI with the Tigon 2.\n\t */\n\tif (CSR_READ_4(sc, TI_PCI_CMDSTAT) & PCIM_CMD_MWIEN) {\n\t\tswitch(cacheline) {\n\t\tcase 1:\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\tcase 32:\n\t\tcase 64:\n\t\t\tbreak;\n\t\tdefault:\n\t\t/* Disable PCI memory write and invalidate. */\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: cache line size %d not \"\n\t\t\t\t    \"supported; disabling PCI MWI\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname, cacheline);\n\t\t\tCSR_WRITE_4(sc, TI_PCI_CMDSTAT, CSR_READ_4(sc,\n\t\t\t    TI_PCI_CMDSTAT) & ~PCIM_CMD_MWIEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef __brokenalpha__\n\t/*\n\t * From the Alteon sample driver:\n\t * Must insure that we do not cross an 8K (bytes) boundary\n\t * for DMA reads.  Our highest limit is 1K bytes.  This is a \n\t * restriction on some ALPHA platforms with early revision \n\t * 21174 PCI chipsets, such as the AlphaPC 164lx \n\t */\n\tTI_SETBIT(sc, TI_PCI_STATE, pci_writemax|TI_PCI_READMAX_1024);\n#else\n\tTI_SETBIT(sc, TI_PCI_STATE, pci_writemax);\n#endif\n\n\t/* This sets the min dma param all the way up (0xff). */\n\tTI_SETBIT(sc, TI_PCI_STATE, TI_PCISTATE_MINDMA);\n\n\t/* Configure DMA variables. */\n#if BYTE_ORDER == BIG_ENDIAN\n\tCSR_WRITE_4(sc, TI_GCR_OPMODE, TI_OPMODE_BYTESWAP_BD |\n\t    TI_OPMODE_BYTESWAP_DATA | TI_OPMODE_WORDSWAP_BD |\n\t    TI_OPMODE_WARN_ENB | TI_OPMODE_FATAL_ENB |\n\t    TI_OPMODE_DONT_FRAG_JUMBO);\n#else\n\tCSR_WRITE_4(sc, TI_GCR_OPMODE, TI_OPMODE_BYTESWAP_DATA|\n\t    TI_OPMODE_WORDSWAP_BD|TI_OPMODE_DONT_FRAG_JUMBO|\n\t    TI_OPMODE_WARN_ENB|TI_OPMODE_FATAL_ENB);\n#endif\n\n\t/*\n\t * Only allow 1 DMA channel to be active at a time.\n\t * I don't think this is a good idea, but without it\n\t * the firmware racks up lots of nicDmaReadRingFull\n\t * errors.\n\t */\n#ifndef TI_CSUM_OFFLOAD\n\tTI_SETBIT(sc, TI_GCR_OPMODE, TI_OPMODE_1_DMA_ACTIVE);\n#endif\n\n\t/* Recommended settings from Tigon manual. */\n\tCSR_WRITE_4(sc, TI_GCR_DMA_WRITECFG, TI_DMA_STATE_THRESH_8W);\n\tCSR_WRITE_4(sc, TI_GCR_DMA_READCFG, TI_DMA_STATE_THRESH_8W);\n\n\tif (ti_64bitslot_war(sc)) {\n\t\tprintf(\"%s: bios thinks we're in a 64 bit slot, \"\n\t\t    \"but we aren't\", sc->sc_dv.dv_xname);\n\t\treturn(EINVAL);\n\t}\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define bootverbose\t1"
    ],
    "globals_used": [
      "int ti_64bitslot_war",
      "int ti_chipinit",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: bios thinks we're in a 64 bit slot, \"\n\t\t    \"but we aren't\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_64bitslot_war",
          "args": [
            "sc"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "ti_64bitslot_war",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "1144-1163",
          "snippet": "int ti_64bitslot_war(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tif (!(CSR_READ_4(sc, TI_PCI_STATE) & TI_PCISTATE_32BIT_BUS)) {\n\t\tCSR_WRITE_4(sc, 0x600, 0);\n\t\tCSR_WRITE_4(sc, 0x604, 0);\n\t\tCSR_WRITE_4(sc, 0x600, 0x5555AAAA);\n\t\tif (CSR_READ_4(sc, 0x604) == 0x5555AAAA) {\n\t\t\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\t\t\treturn(EINVAL);\n\t\t\telse {\n\t\t\t\tTI_SETBIT(sc, TI_PCI_STATE,\n\t\t\t\t    TI_PCISTATE_32BIT_BUS);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int ti_64bitslot_war",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_64bitslot_war;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_64bitslot_war(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tif (!(CSR_READ_4(sc, TI_PCI_STATE) & TI_PCISTATE_32BIT_BUS)) {\n\t\tCSR_WRITE_4(sc, 0x600, 0);\n\t\tCSR_WRITE_4(sc, 0x604, 0);\n\t\tCSR_WRITE_4(sc, 0x600, 0x5555AAAA);\n\t\tif (CSR_READ_4(sc, 0x604) == 0x5555AAAA) {\n\t\t\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\t\t\treturn(EINVAL);\n\t\t\telse {\n\t\t\t\tTI_SETBIT(sc, TI_PCI_STATE,\n\t\t\t\t    TI_PCISTATE_32BIT_BUS);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_DMA_READCFG",
            "TI_DMA_STATE_THRESH_8W"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_DMA_WRITECFG",
            "TI_DMA_STATE_THRESH_8W"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_SETBIT",
          "args": [
            "sc",
            "TI_GCR_OPMODE",
            "TI_OPMODE_1_DMA_ACTIVE"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_OPMODE",
            "TI_OPMODE_BYTESWAP_DATA|\n\t    TI_OPMODE_WORDSWAP_BD|TI_OPMODE_DONT_FRAG_JUMBO|\n\t    TI_OPMODE_WARN_ENB|TI_OPMODE_FATAL_ENB"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_OPMODE",
            "TI_OPMODE_BYTESWAP_BD |\n\t    TI_OPMODE_BYTESWAP_DATA | TI_OPMODE_WORDSWAP_BD |\n\t    TI_OPMODE_WARN_ENB | TI_OPMODE_FATAL_ENB |\n\t    TI_OPMODE_DONT_FRAG_JUMBO"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_SETBIT",
          "args": [
            "sc",
            "TI_PCI_STATE",
            "TI_PCISTATE_MINDMA"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_SETBIT",
          "args": [
            "sc",
            "TI_PCI_STATE",
            "pci_writemax"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_SETBIT",
          "args": [
            "sc",
            "TI_PCI_STATE",
            "pci_writemax|TI_PCI_READMAX_1024"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_PCI_CMDSTAT",
            "CSR_READ_4(sc,\n\t\t\t    TI_PCI_CMDSTAT) & ~PCIM_CMD_MWIEN"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TI_PCI_CMDSTAT"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TI_PCI_CMDSTAT"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TI_PCI_BIST"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_CLRBIT",
          "args": [
            "sc",
            "TI_PCI_STATE",
            "(TI_PCISTATE_WRITE_MAXDMA|\n\t    TI_PCISTATE_READ_MAXDMA)"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_SETBIT",
          "args": [
            "sc",
            "TI_PCI_STATE",
            "TI_PCISTATE_USE_MEM_RD_MULT"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_PCI_STATE",
            "TI_PCI_READ_CMD|TI_PCI_WRITE_CMD"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_SETBIT",
          "args": [
            "sc",
            "TI_MISC_CONF",
            "TI_MCR_SRAM_SYNCHRONOUS"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_SETBIT",
          "args": [
            "sc",
            "TI_MISC_LOCAL_CTL",
            "TI_MLC_SRAM_BANK_256K"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_SETBIT",
          "args": [
            "sc",
            "TI_CPU_CTL_B",
            "TI_CPUSTATE_HALT"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TI_MISC_HOST_CTL"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_SETBIT",
          "args": [
            "sc",
            "TI_CPU_STATE",
            "TI_CPUSTATE_HALT"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TI_CPU_STATE"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_MISC_HOST_CTL",
            "TI_MHC_LITTLEENDIAN_INIT | (TI_MHC_LITTLEENDIAN_INIT << 24)"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_MISC_HOST_CTL",
            "TI_MHC_BIGENDIAN_INIT | (TI_MHC_BIGENDIAN_INIT << 24)"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define bootverbose\t1\n\nint ti_64bitslot_war;\nint ti_chipinit;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_chipinit(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tu_int32_t\t\tcacheline;\n\tu_int32_t\t\tpci_writemax = 0;\n\n\t/* Initialize link to down state. */\n\tsc->ti_linkstat = TI_EV_CODE_LINK_DOWN;\n\n\t/* Set endianness before we access any non-PCI registers. */\n#if BYTE_ORDER == BIG_ENDIAN\n\tCSR_WRITE_4(sc, TI_MISC_HOST_CTL,\n\t    TI_MHC_BIGENDIAN_INIT | (TI_MHC_BIGENDIAN_INIT << 24));\n#else\n\tCSR_WRITE_4(sc, TI_MISC_HOST_CTL,\n\t    TI_MHC_LITTLEENDIAN_INIT | (TI_MHC_LITTLEENDIAN_INIT << 24));\n#endif\n\n\t/* Check the ROM failed bit to see if self-tests passed. */\n\tif (CSR_READ_4(sc, TI_CPU_STATE) & TI_CPUSTATE_ROMFAIL) {\n\t\tprintf(\"%s: board self-diagnostics failed!\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\t\treturn(ENODEV);\n\t}\n\n\t/* Halt the CPU. */\n\tTI_SETBIT(sc, TI_CPU_STATE, TI_CPUSTATE_HALT);\n\n\t/* Figure out the hardware revision. */\n\tswitch(CSR_READ_4(sc, TI_MISC_HOST_CTL) & TI_MHC_CHIP_REV_MASK) {\n\tcase TI_REV_TIGON_I:\n\t\tsc->ti_hwrev = TI_HWREV_TIGON;\n\t\tbreak;\n\tcase TI_REV_TIGON_II:\n\t\tsc->ti_hwrev = TI_HWREV_TIGON_II;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unsupported chip revision\\n\", sc->sc_dv.dv_xname);\n\t\treturn(ENODEV);\n\t}\n\n\t/* Do special setup for Tigon 2. */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II) {\n\t\tTI_SETBIT(sc, TI_CPU_CTL_B, TI_CPUSTATE_HALT);\n\t\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_SRAM_BANK_256K);\n\t\tTI_SETBIT(sc, TI_MISC_CONF, TI_MCR_SRAM_SYNCHRONOUS);\n\t}\n\n\t/* Set up the PCI state register. */\n\tCSR_WRITE_4(sc, TI_PCI_STATE, TI_PCI_READ_CMD|TI_PCI_WRITE_CMD);\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II) {\n\t\tTI_SETBIT(sc, TI_PCI_STATE, TI_PCISTATE_USE_MEM_RD_MULT);\n\t}\n\n\t/* Clear the read/write max DMA parameters. */\n\tTI_CLRBIT(sc, TI_PCI_STATE, (TI_PCISTATE_WRITE_MAXDMA|\n\t    TI_PCISTATE_READ_MAXDMA));\n\n\t/* Get cache line size. */\n\tcacheline = CSR_READ_4(sc, TI_PCI_BIST) & 0xFF;\n\n\t/*\n\t * If the system has set enabled the PCI memory write\n\t * and invalidate command in the command register, set\n\t * the write max parameter accordingly. This is necessary\n\t * to use MWI with the Tigon 2.\n\t */\n\tif (CSR_READ_4(sc, TI_PCI_CMDSTAT) & PCIM_CMD_MWIEN) {\n\t\tswitch(cacheline) {\n\t\tcase 1:\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\tcase 32:\n\t\tcase 64:\n\t\t\tbreak;\n\t\tdefault:\n\t\t/* Disable PCI memory write and invalidate. */\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: cache line size %d not \"\n\t\t\t\t    \"supported; disabling PCI MWI\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname, cacheline);\n\t\t\tCSR_WRITE_4(sc, TI_PCI_CMDSTAT, CSR_READ_4(sc,\n\t\t\t    TI_PCI_CMDSTAT) & ~PCIM_CMD_MWIEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef __brokenalpha__\n\t/*\n\t * From the Alteon sample driver:\n\t * Must insure that we do not cross an 8K (bytes) boundary\n\t * for DMA reads.  Our highest limit is 1K bytes.  This is a \n\t * restriction on some ALPHA platforms with early revision \n\t * 21174 PCI chipsets, such as the AlphaPC 164lx \n\t */\n\tTI_SETBIT(sc, TI_PCI_STATE, pci_writemax|TI_PCI_READMAX_1024);\n#else\n\tTI_SETBIT(sc, TI_PCI_STATE, pci_writemax);\n#endif\n\n\t/* This sets the min dma param all the way up (0xff). */\n\tTI_SETBIT(sc, TI_PCI_STATE, TI_PCISTATE_MINDMA);\n\n\t/* Configure DMA variables. */\n#if BYTE_ORDER == BIG_ENDIAN\n\tCSR_WRITE_4(sc, TI_GCR_OPMODE, TI_OPMODE_BYTESWAP_BD |\n\t    TI_OPMODE_BYTESWAP_DATA | TI_OPMODE_WORDSWAP_BD |\n\t    TI_OPMODE_WARN_ENB | TI_OPMODE_FATAL_ENB |\n\t    TI_OPMODE_DONT_FRAG_JUMBO);\n#else\n\tCSR_WRITE_4(sc, TI_GCR_OPMODE, TI_OPMODE_BYTESWAP_DATA|\n\t    TI_OPMODE_WORDSWAP_BD|TI_OPMODE_DONT_FRAG_JUMBO|\n\t    TI_OPMODE_WARN_ENB|TI_OPMODE_FATAL_ENB);\n#endif\n\n\t/*\n\t * Only allow 1 DMA channel to be active at a time.\n\t * I don't think this is a good idea, but without it\n\t * the firmware racks up lots of nicDmaReadRingFull\n\t * errors.\n\t */\n#ifndef TI_CSUM_OFFLOAD\n\tTI_SETBIT(sc, TI_GCR_OPMODE, TI_OPMODE_1_DMA_ACTIVE);\n#endif\n\n\t/* Recommended settings from Tigon manual. */\n\tCSR_WRITE_4(sc, TI_GCR_DMA_WRITECFG, TI_DMA_STATE_THRESH_8W);\n\tCSR_WRITE_4(sc, TI_GCR_DMA_READCFG, TI_DMA_STATE_THRESH_8W);\n\n\tif (ti_64bitslot_war(sc)) {\n\t\tprintf(\"%s: bios thinks we're in a 64 bit slot, \"\n\t\t    \"but we aren't\", sc->sc_dv.dv_xname);\n\t\treturn(EINVAL);\n\t}\n\n\treturn(0);\n}"
  },
  {
    "function_name": "ti_64bitslot_war",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "1144-1163",
    "snippet": "int ti_64bitslot_war(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tif (!(CSR_READ_4(sc, TI_PCI_STATE) & TI_PCISTATE_32BIT_BUS)) {\n\t\tCSR_WRITE_4(sc, 0x600, 0);\n\t\tCSR_WRITE_4(sc, 0x604, 0);\n\t\tCSR_WRITE_4(sc, 0x600, 0x5555AAAA);\n\t\tif (CSR_READ_4(sc, 0x604) == 0x5555AAAA) {\n\t\t\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\t\t\treturn(EINVAL);\n\t\t\telse {\n\t\t\t\tTI_SETBIT(sc, TI_PCI_STATE,\n\t\t\t\t    TI_PCISTATE_32BIT_BUS);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ti_64bitslot_war",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TI_SETBIT",
          "args": [
            "sc",
            "TI_PCI_STATE",
            "TI_PCISTATE_32BIT_BUS"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "0x604"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "0x600",
            "0x5555AAAA"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "0x604",
            "0"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "0x600",
            "0"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TI_PCI_STATE"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_64bitslot_war;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_64bitslot_war(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tif (!(CSR_READ_4(sc, TI_PCI_STATE) & TI_PCISTATE_32BIT_BUS)) {\n\t\tCSR_WRITE_4(sc, 0x600, 0);\n\t\tCSR_WRITE_4(sc, 0x604, 0);\n\t\tCSR_WRITE_4(sc, 0x600, 0x5555AAAA);\n\t\tif (CSR_READ_4(sc, 0x604) == 0x5555AAAA) {\n\t\t\tif (sc->ti_hwrev == TI_HWREV_TIGON)\n\t\t\t\treturn(EINVAL);\n\t\t\telse {\n\t\t\t\tTI_SETBIT(sc, TI_PCI_STATE,\n\t\t\t\t    TI_PCISTATE_32BIT_BUS);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn(0);\n}"
  },
  {
    "function_name": "ti_setmulti",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "1087-1136",
    "snippet": "void ti_setmulti(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tstruct ti_cmd_desc\tcmd;\n\tstruct ti_mc_entry\t*mc;\n\tu_int32_t\t\tintrs;\n\tstruct ti_mc_entry *p;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tif (ifp->if_flags & IFF_ALLMULTI) {\n\t\tTI_DO_CMD(TI_CMD_SET_ALLMULTI, TI_CMD_CODE_ALLMULTI_ENB, 0);\n\t\treturn;\n\t} else {\n\t\tTI_DO_CMD(TI_CMD_SET_ALLMULTI, TI_CMD_CODE_ALLMULTI_DIS, 0);\n\t}\n\n\t/* Disable interrupts. */\n\tintrs = CSR_READ_4(sc, TI_MB_HOSTINTR);\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);\n\n\t/* First, zot all the existing filters. */\n\tp = LIST_FIRST(&sc->ti_mc_listhead);\n\twhile (p != NULL) {\n\t\tmc = p;\n\t\tti_del_mcast(sc, &mc->mc_addr);\n\t\tp = LIST_FIRST(&sc->ti_mc_listhead);\n\t\tLIST_REMOVE(mc, mc_entries);\n\t\tp = LIST_NEXT(p, mc_entries);\n\t\tfree(mc, M_DEVBUF);\n\t}\n\n\t/* Now program new ones. */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tmc = malloc(sizeof(struct ti_mc_entry), M_DEVBUF, M_NOWAIT);\n\t\tbcopy(enm->enm_addrlo, (char *)&mc->mc_addr, ETHER_ADDR_LEN);\n\t\tLIST_INSERT_HEAD(&sc->ti_mc_listhead, mc, mc_entries);\n\t\tti_add_mcast(sc, &mc->mc_addr);\n\t}\n\n\t/* Re-enable interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, intrs);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_add_mcast",
      "void ti_del_mcast",
      "void ti_setmulti",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_MB_HOSTINTR",
            "intrs"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ti_add_mcast",
          "args": [
            "sc",
            "&mc->mc_addr"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "ti_add_mcast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "1015-1042",
          "snippet": "void ti_add_mcast(sc, addr)\n\tstruct ti_softc\t\t*sc;\n\tstruct ether_addr\t*addr;\n{\n\tstruct ti_cmd_desc\tcmd;\n\tu_int16_t\t\t*m;\n\tu_int32_t\t\text[2] = {0, 0};\n\n\tm = (u_int16_t *)&addr->ether_addr_octet[0];\n\n\tswitch(sc->ti_hwrev) {\n\tcase TI_HWREV_TIGON:\n\t\tCSR_WRITE_4(sc, TI_GCR_MAR0, htons(m[0]));\n\t\tCSR_WRITE_4(sc, TI_GCR_MAR1, (htons(m[1]) << 16) | htons(m[2]));\n\t\tTI_DO_CMD(TI_CMD_ADD_MCAST_ADDR, 0, 0);\n\t\tbreak;\n\tcase TI_HWREV_TIGON_II:\n\t\text[0] = htons(m[0]);\n\t\text[1] = (htons(m[1]) << 16) | htons(m[2]);\n\t\tTI_DO_CMD_EXT(TI_CMD_EXT_ADD_MCAST, 0, 0, (caddr_t)&ext, 2);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown hwrev\\n\", sc->sc_dv.dv_xname);\n\t\tbreak;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_add_mcast",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_add_mcast;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_add_mcast(sc, addr)\n\tstruct ti_softc\t\t*sc;\n\tstruct ether_addr\t*addr;\n{\n\tstruct ti_cmd_desc\tcmd;\n\tu_int16_t\t\t*m;\n\tu_int32_t\t\text[2] = {0, 0};\n\n\tm = (u_int16_t *)&addr->ether_addr_octet[0];\n\n\tswitch(sc->ti_hwrev) {\n\tcase TI_HWREV_TIGON:\n\t\tCSR_WRITE_4(sc, TI_GCR_MAR0, htons(m[0]));\n\t\tCSR_WRITE_4(sc, TI_GCR_MAR1, (htons(m[1]) << 16) | htons(m[2]));\n\t\tTI_DO_CMD(TI_CMD_ADD_MCAST_ADDR, 0, 0);\n\t\tbreak;\n\tcase TI_HWREV_TIGON_II:\n\t\text[0] = htons(m[0]);\n\t\text[1] = (htons(m[1]) << 16) | htons(m[2]);\n\t\tTI_DO_CMD_EXT(TI_CMD_EXT_ADD_MCAST, 0, 0, (caddr_t)&ext, 2);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown hwrev\\n\", sc->sc_dv.dv_xname);\n\t\tbreak;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_INSERT_HEAD",
          "args": [
            "&sc->ti_mc_listhead",
            "mc",
            "mc_entries"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "enm->enm_addrlo",
            "(char *)&mc->mc_addr",
            "ETHER_ADDR_LEN"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct ti_mc_entry)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "ac",
            "enm"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mc",
            "M_DEVBUF"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "ti_free_tx_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "981-999",
          "snippet": "void ti_free_tx_ring(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tif (sc->ti_rdata->ti_tx_ring == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < TI_TX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_tx_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_tx_chain[i]);\n\t\t\tsc->ti_cdata.ti_tx_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_tx_ring[i],\n\t\t    sizeof(struct ti_tx_desc));\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_free_tx_ring",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_free_tx_ring;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_free_tx_ring(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tif (sc->ti_rdata->ti_tx_ring == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < TI_TX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_tx_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_tx_chain[i]);\n\t\t\tsc->ti_cdata.ti_tx_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_tx_ring[i],\n\t\t    sizeof(struct ti_tx_desc));\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "p",
            "mc_entries"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_REMOVE",
          "args": [
            "mc",
            "mc_entries"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->ti_mc_listhead"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ti_del_mcast",
          "args": [
            "sc",
            "&mc->mc_addr"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "ti_del_mcast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "1044-1071",
          "snippet": "void ti_del_mcast(sc, addr)\n\tstruct ti_softc\t\t*sc;\n\tstruct ether_addr\t*addr;\n{\n\tstruct ti_cmd_desc\tcmd;\n\tu_int16_t\t\t*m;\n\tu_int32_t\t\text[2] = {0, 0};\n\n\tm = (u_int16_t *)&addr->ether_addr_octet[0];\n\n\tswitch(sc->ti_hwrev) {\n\tcase TI_HWREV_TIGON:\n\t\tCSR_WRITE_4(sc, TI_GCR_MAR0, htons(m[0]));\n\t\tCSR_WRITE_4(sc, TI_GCR_MAR1, (htons(m[1]) << 16) | htons(m[2]));\n\t\tTI_DO_CMD(TI_CMD_DEL_MCAST_ADDR, 0, 0);\n\t\tbreak;\n\tcase TI_HWREV_TIGON_II:\n\t\text[0] = htons(m[0]);\n\t\text[1] = (htons(m[1]) << 16) | htons(m[2]);\n\t\tTI_DO_CMD_EXT(TI_CMD_EXT_DEL_MCAST, 0, 0, (caddr_t)&ext, 2);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown hwrev\\n\", sc->sc_dv.dv_xname);\n\t\tbreak;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_del_mcast",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_del_mcast;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_del_mcast(sc, addr)\n\tstruct ti_softc\t\t*sc;\n\tstruct ether_addr\t*addr;\n{\n\tstruct ti_cmd_desc\tcmd;\n\tu_int16_t\t\t*m;\n\tu_int32_t\t\text[2] = {0, 0};\n\n\tm = (u_int16_t *)&addr->ether_addr_octet[0];\n\n\tswitch(sc->ti_hwrev) {\n\tcase TI_HWREV_TIGON:\n\t\tCSR_WRITE_4(sc, TI_GCR_MAR0, htons(m[0]));\n\t\tCSR_WRITE_4(sc, TI_GCR_MAR1, (htons(m[1]) << 16) | htons(m[2]));\n\t\tTI_DO_CMD(TI_CMD_DEL_MCAST_ADDR, 0, 0);\n\t\tbreak;\n\tcase TI_HWREV_TIGON_II:\n\t\text[0] = htons(m[0]);\n\t\text[1] = (htons(m[1]) << 16) | htons(m[2]);\n\t\tTI_DO_CMD_EXT(TI_CMD_EXT_DEL_MCAST, 0, 0, (caddr_t)&ext, 2);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown hwrev\\n\", sc->sc_dv.dv_xname);\n\t\tbreak;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->ti_mc_listhead"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_MB_HOSTINTR",
            "1"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TI_MB_HOSTINTR"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_DO_CMD",
          "args": [
            "TI_CMD_SET_ALLMULTI",
            "TI_CMD_CODE_ALLMULTI_DIS",
            "0"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_DO_CMD",
          "args": [
            "TI_CMD_SET_ALLMULTI",
            "TI_CMD_CODE_ALLMULTI_ENB",
            "0"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_add_mcast;\nvoid ti_del_mcast;\nvoid ti_setmulti;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_setmulti(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tstruct ti_cmd_desc\tcmd;\n\tstruct ti_mc_entry\t*mc;\n\tu_int32_t\t\tintrs;\n\tstruct ti_mc_entry *p;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tif (ifp->if_flags & IFF_ALLMULTI) {\n\t\tTI_DO_CMD(TI_CMD_SET_ALLMULTI, TI_CMD_CODE_ALLMULTI_ENB, 0);\n\t\treturn;\n\t} else {\n\t\tTI_DO_CMD(TI_CMD_SET_ALLMULTI, TI_CMD_CODE_ALLMULTI_DIS, 0);\n\t}\n\n\t/* Disable interrupts. */\n\tintrs = CSR_READ_4(sc, TI_MB_HOSTINTR);\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);\n\n\t/* First, zot all the existing filters. */\n\tp = LIST_FIRST(&sc->ti_mc_listhead);\n\twhile (p != NULL) {\n\t\tmc = p;\n\t\tti_del_mcast(sc, &mc->mc_addr);\n\t\tp = LIST_FIRST(&sc->ti_mc_listhead);\n\t\tLIST_REMOVE(mc, mc_entries);\n\t\tp = LIST_NEXT(p, mc_entries);\n\t\tfree(mc, M_DEVBUF);\n\t}\n\n\t/* Now program new ones. */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tmc = malloc(sizeof(struct ti_mc_entry), M_DEVBUF, M_NOWAIT);\n\t\tbcopy(enm->enm_addrlo, (char *)&mc->mc_addr, ETHER_ADDR_LEN);\n\t\tLIST_INSERT_HEAD(&sc->ti_mc_listhead, mc, mc_entries);\n\t\tti_add_mcast(sc, &mc->mc_addr);\n\t}\n\n\t/* Re-enable interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, intrs);\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_del_mcast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "1044-1071",
    "snippet": "void ti_del_mcast(sc, addr)\n\tstruct ti_softc\t\t*sc;\n\tstruct ether_addr\t*addr;\n{\n\tstruct ti_cmd_desc\tcmd;\n\tu_int16_t\t\t*m;\n\tu_int32_t\t\text[2] = {0, 0};\n\n\tm = (u_int16_t *)&addr->ether_addr_octet[0];\n\n\tswitch(sc->ti_hwrev) {\n\tcase TI_HWREV_TIGON:\n\t\tCSR_WRITE_4(sc, TI_GCR_MAR0, htons(m[0]));\n\t\tCSR_WRITE_4(sc, TI_GCR_MAR1, (htons(m[1]) << 16) | htons(m[2]));\n\t\tTI_DO_CMD(TI_CMD_DEL_MCAST_ADDR, 0, 0);\n\t\tbreak;\n\tcase TI_HWREV_TIGON_II:\n\t\text[0] = htons(m[0]);\n\t\text[1] = (htons(m[1]) << 16) | htons(m[2]);\n\t\tTI_DO_CMD_EXT(TI_CMD_EXT_DEL_MCAST, 0, 0, (caddr_t)&ext, 2);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown hwrev\\n\", sc->sc_dv.dv_xname);\n\t\tbreak;\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_del_mcast",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unknown hwrev\\n\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TI_DO_CMD_EXT",
          "args": [
            "TI_CMD_EXT_DEL_MCAST",
            "0",
            "0",
            "(caddr_t)&ext",
            "2"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "m[2]"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "m[1]"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "m[0]"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_DO_CMD",
          "args": [
            "TI_CMD_DEL_MCAST_ADDR",
            "0",
            "0"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_MAR1",
            "(htons(m[1]) << 16) | htons(m[2])"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "m[2]"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "m[1]"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_MAR0",
            "htons(m[0])"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "m[0]"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_del_mcast;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_del_mcast(sc, addr)\n\tstruct ti_softc\t\t*sc;\n\tstruct ether_addr\t*addr;\n{\n\tstruct ti_cmd_desc\tcmd;\n\tu_int16_t\t\t*m;\n\tu_int32_t\t\text[2] = {0, 0};\n\n\tm = (u_int16_t *)&addr->ether_addr_octet[0];\n\n\tswitch(sc->ti_hwrev) {\n\tcase TI_HWREV_TIGON:\n\t\tCSR_WRITE_4(sc, TI_GCR_MAR0, htons(m[0]));\n\t\tCSR_WRITE_4(sc, TI_GCR_MAR1, (htons(m[1]) << 16) | htons(m[2]));\n\t\tTI_DO_CMD(TI_CMD_DEL_MCAST_ADDR, 0, 0);\n\t\tbreak;\n\tcase TI_HWREV_TIGON_II:\n\t\text[0] = htons(m[0]);\n\t\text[1] = (htons(m[1]) << 16) | htons(m[2]);\n\t\tTI_DO_CMD_EXT(TI_CMD_EXT_DEL_MCAST, 0, 0, (caddr_t)&ext, 2);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown hwrev\\n\", sc->sc_dv.dv_xname);\n\t\tbreak;\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_add_mcast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "1015-1042",
    "snippet": "void ti_add_mcast(sc, addr)\n\tstruct ti_softc\t\t*sc;\n\tstruct ether_addr\t*addr;\n{\n\tstruct ti_cmd_desc\tcmd;\n\tu_int16_t\t\t*m;\n\tu_int32_t\t\text[2] = {0, 0};\n\n\tm = (u_int16_t *)&addr->ether_addr_octet[0];\n\n\tswitch(sc->ti_hwrev) {\n\tcase TI_HWREV_TIGON:\n\t\tCSR_WRITE_4(sc, TI_GCR_MAR0, htons(m[0]));\n\t\tCSR_WRITE_4(sc, TI_GCR_MAR1, (htons(m[1]) << 16) | htons(m[2]));\n\t\tTI_DO_CMD(TI_CMD_ADD_MCAST_ADDR, 0, 0);\n\t\tbreak;\n\tcase TI_HWREV_TIGON_II:\n\t\text[0] = htons(m[0]);\n\t\text[1] = (htons(m[1]) << 16) | htons(m[2]);\n\t\tTI_DO_CMD_EXT(TI_CMD_EXT_ADD_MCAST, 0, 0, (caddr_t)&ext, 2);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown hwrev\\n\", sc->sc_dv.dv_xname);\n\t\tbreak;\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_add_mcast",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unknown hwrev\\n\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TI_DO_CMD_EXT",
          "args": [
            "TI_CMD_EXT_ADD_MCAST",
            "0",
            "0",
            "(caddr_t)&ext",
            "2"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "m[2]"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "m[1]"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "m[0]"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_DO_CMD",
          "args": [
            "TI_CMD_ADD_MCAST_ADDR",
            "0",
            "0"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_MAR1",
            "(htons(m[1]) << 16) | htons(m[2])"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "m[2]"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "m[1]"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_MAR0",
            "htons(m[0])"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "m[0]"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_add_mcast;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_add_mcast(sc, addr)\n\tstruct ti_softc\t\t*sc;\n\tstruct ether_addr\t*addr;\n{\n\tstruct ti_cmd_desc\tcmd;\n\tu_int16_t\t\t*m;\n\tu_int32_t\t\text[2] = {0, 0};\n\n\tm = (u_int16_t *)&addr->ether_addr_octet[0];\n\n\tswitch(sc->ti_hwrev) {\n\tcase TI_HWREV_TIGON:\n\t\tCSR_WRITE_4(sc, TI_GCR_MAR0, htons(m[0]));\n\t\tCSR_WRITE_4(sc, TI_GCR_MAR1, (htons(m[1]) << 16) | htons(m[2]));\n\t\tTI_DO_CMD(TI_CMD_ADD_MCAST_ADDR, 0, 0);\n\t\tbreak;\n\tcase TI_HWREV_TIGON_II:\n\t\text[0] = htons(m[0]);\n\t\text[1] = (htons(m[1]) << 16) | htons(m[2]);\n\t\tTI_DO_CMD_EXT(TI_CMD_EXT_ADD_MCAST, 0, 0, (caddr_t)&ext, 2);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown hwrev\\n\", sc->sc_dv.dv_xname);\n\t\tbreak;\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_init_tx_ring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "1001-1008",
    "snippet": "int ti_init_tx_ring(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tsc->ti_txcnt = 0;\n\tsc->ti_tx_saved_considx = 0;\n\tCSR_WRITE_4(sc, TI_MB_SENDPROD_IDX, 0);\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ti_init_tx_ring",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_MB_SENDPROD_IDX",
            "0"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_init_tx_ring;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_init_tx_ring(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tsc->ti_txcnt = 0;\n\tsc->ti_tx_saved_considx = 0;\n\tCSR_WRITE_4(sc, TI_MB_SENDPROD_IDX, 0);\n\treturn(0);\n}"
  },
  {
    "function_name": "ti_free_tx_ring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "981-999",
    "snippet": "void ti_free_tx_ring(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tif (sc->ti_rdata->ti_tx_ring == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < TI_TX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_tx_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_tx_chain[i]);\n\t\t\tsc->ti_cdata.ti_tx_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_tx_ring[i],\n\t\t    sizeof(struct ti_tx_desc));\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_free_tx_ring",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&sc->ti_rdata->ti_tx_ring[i]",
            "sizeof(struct ti_tx_desc)"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->ti_cdata.ti_tx_chain[i]"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_free_tx_ring;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_free_tx_ring(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tif (sc->ti_rdata->ti_tx_ring == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < TI_TX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_tx_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_tx_chain[i]);\n\t\t\tsc->ti_cdata.ti_tx_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_tx_ring[i],\n\t\t    sizeof(struct ti_tx_desc));\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_free_rx_ring_mini",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "964-979",
    "snippet": "void ti_free_rx_ring_mini(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_MINI_RX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_rx_mini_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_rx_mini_chain[i]);\n\t\t\tsc->ti_cdata.ti_rx_mini_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_rx_mini_ring[i],\n\t\t    sizeof(struct ti_rx_desc));\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_free_rx_ring_mini",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&sc->ti_rdata->ti_rx_mini_ring[i]",
            "sizeof(struct ti_rx_desc)"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->ti_cdata.ti_rx_mini_chain[i]"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_free_rx_ring_mini;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_free_rx_ring_mini(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_MINI_RX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_rx_mini_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_rx_mini_chain[i]);\n\t\t\tsc->ti_cdata.ti_rx_mini_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_rx_mini_ring[i],\n\t\t    sizeof(struct ti_rx_desc));\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_init_rx_ring_mini",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "948-962",
    "snippet": "int ti_init_rx_ring_mini(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_MSLOTS; i++) {\n\t\tif (ti_newbuf_mini(sc, i, NULL) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t};\n\n\tTI_UPDATE_MINIPROD(sc, i - 1);\n\tsc->ti_mini = i - 1;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ti_newbuf_mini",
      "int ti_init_rx_ring_mini",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TI_UPDATE_MINIPROD",
          "args": [
            "sc",
            "i - 1"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ti_newbuf_mini",
          "args": [
            "sc",
            "i",
            "NULL"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "ti_newbuf_mini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "774-809",
          "snippet": "int ti_newbuf_mini(sc, i, m)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct ti_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: mbuf allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MHLEN;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_data = m_new->m_pktdat;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MHLEN;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tr = &sc->ti_rdata->ti_rx_mini_ring[i];\n\tsc->ti_cdata.ti_rx_mini_chain[i] = m_new;\n\tTI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));\n\tr->ti_type = TI_BDTYPE_RECV_BD;\n\tr->ti_flags = TI_BDFLAG_MINI_RING;\n#ifdef TI_CSUM_OFFLOAD\n\tr->ti_flags |= TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;\n#endif\n\tr->ti_len = m_new->m_len;\n\tr->ti_idx = i;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int ti_newbuf_mini",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_newbuf_mini;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_newbuf_mini(sc, i, m)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct ti_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: mbuf allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MHLEN;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_data = m_new->m_pktdat;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MHLEN;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tr = &sc->ti_rdata->ti_rx_mini_ring[i];\n\tsc->ti_cdata.ti_rx_mini_chain[i] = m_new;\n\tTI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));\n\tr->ti_type = TI_BDTYPE_RECV_BD;\n\tr->ti_flags = TI_BDFLAG_MINI_RING;\n#ifdef TI_CSUM_OFFLOAD\n\tr->ti_flags |= TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;\n#endif\n\tr->ti_len = m_new->m_len;\n\tr->ti_idx = i;\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_newbuf_mini;\nint ti_init_rx_ring_mini;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_init_rx_ring_mini(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_MSLOTS; i++) {\n\t\tif (ti_newbuf_mini(sc, i, NULL) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t};\n\n\tTI_UPDATE_MINIPROD(sc, i - 1);\n\tsc->ti_mini = i - 1;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "ti_free_rx_ring_jumbo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "931-946",
    "snippet": "void ti_free_rx_ring_jumbo(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_JUMBO_RX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_rx_jumbo_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_rx_jumbo_chain[i]);\n\t\t\tsc->ti_cdata.ti_rx_jumbo_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_rx_jumbo_ring[i],\n\t\t    sizeof(struct ti_rx_desc));\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_free_rx_ring_jumbo",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&sc->ti_rdata->ti_rx_jumbo_ring[i]",
            "sizeof(struct ti_rx_desc)"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->ti_cdata.ti_rx_jumbo_chain[i]"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_free_rx_ring_jumbo;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_free_rx_ring_jumbo(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_JUMBO_RX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_rx_jumbo_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_rx_jumbo_chain[i]);\n\t\t\tsc->ti_cdata.ti_rx_jumbo_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_rx_jumbo_ring[i],\n\t\t    sizeof(struct ti_rx_desc));\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_init_rx_ring_jumbo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "914-929",
    "snippet": "int ti_init_rx_ring_jumbo(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ti_cmd_desc\tcmd;\n\n\tfor (i = 0; i < (TI_JSLOTS - 20); i++) {\n\t\tif (ti_newbuf_jumbo(sc, i, NULL) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t};\n\n\tTI_UPDATE_JUMBOPROD(sc, i - 1);\n\tsc->ti_jumbo = i - 1;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ti_newbuf_jumbo",
      "int ti_init_rx_ring_jumbo",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TI_UPDATE_JUMBOPROD",
          "args": [
            "sc",
            "i - 1"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ti_newbuf_jumbo",
          "args": [
            "sc",
            "i",
            "NULL"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "ti_newbuf_jumbo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "815-872",
          "snippet": "int ti_newbuf_jumbo(sc, i, m)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct ti_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tcaddr_t\t\t\t*buf = NULL;\n\n\t\t/* Allocate the mbuf. */\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: mbuf allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\t/* Allocate the jumbo buffer */\n\t\tbuf = ti_jalloc(sc);\n\t\tif (buf == NULL) {\n\t\t\tm_freem(m_new);\n\t\t\tprintf(\"%s: jumbo allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\t/* Attach the buffer to the mbuf. */\n\t\tm_new->m_data = m_new->m_ext.ext_buf = (void *)buf;\n\t\tm_new->m_flags |= M_EXT;\n\t\tm_new->m_len = m_new->m_pkthdr.len =\n\t\t    m_new->m_ext.ext_size = TI_JUMBO_FRAMELEN;\n\t\tm_new->m_ext.ext_free = ti_jfree;\n\t\tm_new->m_ext.ext_ref = ti_jref;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t\tm_new->m_ext.ext_size = TI_JUMBO_FRAMELEN;\n\t}\n\n\tm_new->m_ext.ext_handle = sc;\n\n\tm_adj(m_new, ETHER_ALIGN);\n\t/* Set up the descriptor. */\n\tr = &sc->ti_rdata->ti_rx_jumbo_ring[i];\n\tsc->ti_cdata.ti_rx_jumbo_chain[i] = m_new;\n\tTI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));\n\tr->ti_type = TI_BDTYPE_RECV_JUMBO_BD;\n\tr->ti_flags = TI_BDFLAG_JUMBO_RING;\n#ifdef TI_CSUM_OFFLOAD\n\tr->ti_flags |= TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;\n#endif\n\tr->ti_len = m_new->m_len;\n\tr->ti_idx = i;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void *ti_jalloc",
            "void ti_jfree",
            "void ti_jref",
            "int ti_newbuf_jumbo",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid *ti_jalloc;\nvoid ti_jfree;\nvoid ti_jref;\nint ti_newbuf_jumbo;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_newbuf_jumbo(sc, i, m)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct ti_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tcaddr_t\t\t\t*buf = NULL;\n\n\t\t/* Allocate the mbuf. */\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: mbuf allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\t/* Allocate the jumbo buffer */\n\t\tbuf = ti_jalloc(sc);\n\t\tif (buf == NULL) {\n\t\t\tm_freem(m_new);\n\t\t\tprintf(\"%s: jumbo allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\t/* Attach the buffer to the mbuf. */\n\t\tm_new->m_data = m_new->m_ext.ext_buf = (void *)buf;\n\t\tm_new->m_flags |= M_EXT;\n\t\tm_new->m_len = m_new->m_pkthdr.len =\n\t\t    m_new->m_ext.ext_size = TI_JUMBO_FRAMELEN;\n\t\tm_new->m_ext.ext_free = ti_jfree;\n\t\tm_new->m_ext.ext_ref = ti_jref;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t\tm_new->m_ext.ext_size = TI_JUMBO_FRAMELEN;\n\t}\n\n\tm_new->m_ext.ext_handle = sc;\n\n\tm_adj(m_new, ETHER_ALIGN);\n\t/* Set up the descriptor. */\n\tr = &sc->ti_rdata->ti_rx_jumbo_ring[i];\n\tsc->ti_cdata.ti_rx_jumbo_chain[i] = m_new;\n\tTI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));\n\tr->ti_type = TI_BDTYPE_RECV_JUMBO_BD;\n\tr->ti_flags = TI_BDFLAG_JUMBO_RING;\n#ifdef TI_CSUM_OFFLOAD\n\tr->ti_flags |= TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;\n#endif\n\tr->ti_len = m_new->m_len;\n\tr->ti_idx = i;\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_newbuf_jumbo;\nint ti_init_rx_ring_jumbo;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_init_rx_ring_jumbo(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ti_cmd_desc\tcmd;\n\n\tfor (i = 0; i < (TI_JSLOTS - 20); i++) {\n\t\tif (ti_newbuf_jumbo(sc, i, NULL) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t};\n\n\tTI_UPDATE_JUMBOPROD(sc, i - 1);\n\tsc->ti_jumbo = i - 1;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "ti_free_rx_ring_std",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "897-912",
    "snippet": "void ti_free_rx_ring_std(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_STD_RX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_rx_std_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_rx_std_chain[i]);\n\t\t\tsc->ti_cdata.ti_rx_std_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_rx_std_ring[i],\n\t\t    sizeof(struct ti_rx_desc));\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_free_rx_ring_std",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&sc->ti_rdata->ti_rx_std_ring[i]",
            "sizeof(struct ti_rx_desc)"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->ti_cdata.ti_rx_std_chain[i]"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_free_rx_ring_std;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_free_rx_ring_std(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_STD_RX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_rx_std_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_rx_std_chain[i]);\n\t\t\tsc->ti_cdata.ti_rx_std_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_rx_std_ring[i],\n\t\t    sizeof(struct ti_rx_desc));\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_init_rx_ring_std",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "880-895",
    "snippet": "int ti_init_rx_ring_std(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ti_cmd_desc\tcmd;\n\n\tfor (i = 0; i < TI_SSLOTS; i++) {\n\t\tif (ti_newbuf_std(sc, i, NULL) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t};\n\n\tTI_UPDATE_STDPROD(sc, i - 1);\n\tsc->ti_std = i - 1;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ti_newbuf_std",
      "int ti_init_rx_ring_std",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TI_UPDATE_STDPROD",
          "args": [
            "sc",
            "i - 1"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ti_newbuf_std",
          "args": [
            "sc",
            "i",
            "NULL"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "ti_newbuf_std",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "724-768",
          "snippet": "int ti_newbuf_std(sc, i, m)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct ti_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: mbuf allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: cluster allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\tm_freem(m_new);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tsc->ti_cdata.ti_rx_std_chain[i] = m_new;\n\tr = &sc->ti_rdata->ti_rx_std_ring[i];\n\tTI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));\n\tr->ti_type = TI_BDTYPE_RECV_BD;\n#ifdef TI_CSUM_OFFLOAD\n\tr->ti_flags = TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;\n#else\n\tr->ti_flags = 0;\n#endif\n\tr->ti_len = MCLBYTES;\n\tr->ti_idx = i;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int ti_newbuf_std",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_newbuf_std;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_newbuf_std(sc, i, m)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct ti_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: mbuf allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: cluster allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\tm_freem(m_new);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tsc->ti_cdata.ti_rx_std_chain[i] = m_new;\n\tr = &sc->ti_rdata->ti_rx_std_ring[i];\n\tTI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));\n\tr->ti_type = TI_BDTYPE_RECV_BD;\n#ifdef TI_CSUM_OFFLOAD\n\tr->ti_flags = TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;\n#else\n\tr->ti_flags = 0;\n#endif\n\tr->ti_len = MCLBYTES;\n\tr->ti_idx = i;\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_newbuf_std;\nint ti_init_rx_ring_std;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_init_rx_ring_std(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ti_cmd_desc\tcmd;\n\n\tfor (i = 0; i < TI_SSLOTS; i++) {\n\t\tif (ti_newbuf_std(sc, i, NULL) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t};\n\n\tTI_UPDATE_STDPROD(sc, i - 1);\n\tsc->ti_std = i - 1;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "ti_newbuf_jumbo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "815-872",
    "snippet": "int ti_newbuf_jumbo(sc, i, m)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct ti_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tcaddr_t\t\t\t*buf = NULL;\n\n\t\t/* Allocate the mbuf. */\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: mbuf allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\t/* Allocate the jumbo buffer */\n\t\tbuf = ti_jalloc(sc);\n\t\tif (buf == NULL) {\n\t\t\tm_freem(m_new);\n\t\t\tprintf(\"%s: jumbo allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\t/* Attach the buffer to the mbuf. */\n\t\tm_new->m_data = m_new->m_ext.ext_buf = (void *)buf;\n\t\tm_new->m_flags |= M_EXT;\n\t\tm_new->m_len = m_new->m_pkthdr.len =\n\t\t    m_new->m_ext.ext_size = TI_JUMBO_FRAMELEN;\n\t\tm_new->m_ext.ext_free = ti_jfree;\n\t\tm_new->m_ext.ext_ref = ti_jref;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t\tm_new->m_ext.ext_size = TI_JUMBO_FRAMELEN;\n\t}\n\n\tm_new->m_ext.ext_handle = sc;\n\n\tm_adj(m_new, ETHER_ALIGN);\n\t/* Set up the descriptor. */\n\tr = &sc->ti_rdata->ti_rx_jumbo_ring[i];\n\tsc->ti_cdata.ti_rx_jumbo_chain[i] = m_new;\n\tTI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));\n\tr->ti_type = TI_BDTYPE_RECV_JUMBO_BD;\n\tr->ti_flags = TI_BDFLAG_JUMBO_RING;\n#ifdef TI_CSUM_OFFLOAD\n\tr->ti_flags |= TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;\n#endif\n\tr->ti_len = m_new->m_len;\n\tr->ti_idx = i;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void *ti_jalloc",
      "void ti_jfree",
      "void ti_jref",
      "int ti_newbuf_jumbo",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m_new, caddr_t)"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m_new",
            "caddr_t"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_HOSTADDR",
          "args": [
            "r->ti_addr"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m_new",
            "ETHER_ALIGN"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: jumbo allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_new"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ti_jalloc",
          "args": [
            "sc"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m_new",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid *ti_jalloc;\nvoid ti_jfree;\nvoid ti_jref;\nint ti_newbuf_jumbo;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_newbuf_jumbo(sc, i, m)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct ti_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tcaddr_t\t\t\t*buf = NULL;\n\n\t\t/* Allocate the mbuf. */\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: mbuf allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\t/* Allocate the jumbo buffer */\n\t\tbuf = ti_jalloc(sc);\n\t\tif (buf == NULL) {\n\t\t\tm_freem(m_new);\n\t\t\tprintf(\"%s: jumbo allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\t/* Attach the buffer to the mbuf. */\n\t\tm_new->m_data = m_new->m_ext.ext_buf = (void *)buf;\n\t\tm_new->m_flags |= M_EXT;\n\t\tm_new->m_len = m_new->m_pkthdr.len =\n\t\t    m_new->m_ext.ext_size = TI_JUMBO_FRAMELEN;\n\t\tm_new->m_ext.ext_free = ti_jfree;\n\t\tm_new->m_ext.ext_ref = ti_jref;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t\tm_new->m_ext.ext_size = TI_JUMBO_FRAMELEN;\n\t}\n\n\tm_new->m_ext.ext_handle = sc;\n\n\tm_adj(m_new, ETHER_ALIGN);\n\t/* Set up the descriptor. */\n\tr = &sc->ti_rdata->ti_rx_jumbo_ring[i];\n\tsc->ti_cdata.ti_rx_jumbo_chain[i] = m_new;\n\tTI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));\n\tr->ti_type = TI_BDTYPE_RECV_JUMBO_BD;\n\tr->ti_flags = TI_BDFLAG_JUMBO_RING;\n#ifdef TI_CSUM_OFFLOAD\n\tr->ti_flags |= TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;\n#endif\n\tr->ti_len = m_new->m_len;\n\tr->ti_idx = i;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "ti_newbuf_mini",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "774-809",
    "snippet": "int ti_newbuf_mini(sc, i, m)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct ti_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: mbuf allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MHLEN;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_data = m_new->m_pktdat;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MHLEN;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tr = &sc->ti_rdata->ti_rx_mini_ring[i];\n\tsc->ti_cdata.ti_rx_mini_chain[i] = m_new;\n\tTI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));\n\tr->ti_type = TI_BDTYPE_RECV_BD;\n\tr->ti_flags = TI_BDFLAG_MINI_RING;\n#ifdef TI_CSUM_OFFLOAD\n\tr->ti_flags |= TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;\n#endif\n\tr->ti_len = m_new->m_len;\n\tr->ti_idx = i;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ti_newbuf_mini",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m_new, caddr_t)"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m_new",
            "caddr_t"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_HOSTADDR",
          "args": [
            "r->ti_addr"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m_new",
            "ETHER_ALIGN"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: mbuf allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m_new",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_newbuf_mini;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_newbuf_mini(sc, i, m)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct ti_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: mbuf allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MHLEN;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_data = m_new->m_pktdat;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MHLEN;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tr = &sc->ti_rdata->ti_rx_mini_ring[i];\n\tsc->ti_cdata.ti_rx_mini_chain[i] = m_new;\n\tTI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));\n\tr->ti_type = TI_BDTYPE_RECV_BD;\n\tr->ti_flags = TI_BDFLAG_MINI_RING;\n#ifdef TI_CSUM_OFFLOAD\n\tr->ti_flags |= TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;\n#endif\n\tr->ti_len = m_new->m_len;\n\tr->ti_idx = i;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "ti_newbuf_std",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "724-768",
    "snippet": "int ti_newbuf_std(sc, i, m)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct ti_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: mbuf allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: cluster allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\tm_freem(m_new);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tsc->ti_cdata.ti_rx_std_chain[i] = m_new;\n\tr = &sc->ti_rdata->ti_rx_std_ring[i];\n\tTI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));\n\tr->ti_type = TI_BDTYPE_RECV_BD;\n#ifdef TI_CSUM_OFFLOAD\n\tr->ti_flags = TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;\n#else\n\tr->ti_flags = 0;\n#endif\n\tr->ti_len = MCLBYTES;\n\tr->ti_idx = i;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ti_newbuf_std",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m_new, caddr_t)"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m_new",
            "caddr_t"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_HOSTADDR",
          "args": [
            "r->ti_addr"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m_new",
            "ETHER_ALIGN"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_new"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: cluster allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m_new",
            "M_DONTWAIT"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m_new",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_newbuf_std;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_newbuf_std(sc, i, m)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct ti_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: mbuf allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: cluster allocation failed \"\n\t\t\t    \"-- packet dropped!\\n\", sc->sc_dv.dv_xname);\n\t\t\tm_freem(m_new);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tsc->ti_cdata.ti_rx_std_chain[i] = m_new;\n\tr = &sc->ti_rdata->ti_rx_std_ring[i];\n\tTI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));\n\tr->ti_type = TI_BDTYPE_RECV_BD;\n#ifdef TI_CSUM_OFFLOAD\n\tr->ti_flags = TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;\n#else\n\tr->ti_flags = 0;\n#endif\n\tr->ti_len = MCLBYTES;\n\tr->ti_idx = i;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "ti_jfree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "681-719",
    "snippet": "void\nti_jfree(m)\n\tstruct mbuf *m;\n{\n\tcaddr_t buf = m->m_ext.ext_buf;\n\tu_int size = m->m_ext.ext_size;\n\tstruct ti_softc *sc;\n\tint i;\n\tstruct ti_jpool_entry *entry;\n\n\t/* Extract the softc struct pointer. */\n\tsc = (struct ti_softc *)m->m_ext.ext_handle;\n\n\tif (sc == NULL)\n\t\tpanic(\"ti_jfree: can't find softc pointer!\");\n\n\tif (size != TI_JUMBO_FRAMELEN)\n\t\tpanic(\"ti_jfree: freeing buffer of wrong size!\");\n\n\t/* calculate the slot this buffer belongs to */\n\ti = ((vaddr_t)buf - (vaddr_t)sc->ti_cdata.ti_jumbo_buf) / TI_JLEN;\n\n\tif ((i < 0) || (i >= TI_JSLOTS))\n\t\tpanic(\"ti_jfree: asked to free buffer that we don't manage!\");\n\telse if (sc->ti_cdata.ti_jslots[i].ti_inuse == 0)\n\t\tpanic(\"ti_jfree: buffer already free!\");\n\telse {\n\t\tsc->ti_cdata.ti_jslots[i].ti_inuse--;\n\t\tif(sc->ti_cdata.ti_jslots[i].ti_inuse == 0) {\n\t\t\tentry = LIST_FIRST(&sc->ti_jinuse_listhead);\n\t\t\tif (entry == NULL)\n\t\t\t\tpanic(\"ti_jfree: buffer not in use!\");\n\t\t\tentry->slot = i;\n\t\t\tLIST_REMOVE(entry, jpool_entries);\n\t\t\tLIST_INSERT_HEAD(&sc->ti_jfree_listhead, \n\t\t\t\t\t  entry, jpool_entries);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_jfree",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIST_INSERT_HEAD",
          "args": [
            "&sc->ti_jfree_listhead",
            "entry",
            "jpool_entries"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_REMOVE",
          "args": [
            "entry",
            "jpool_entries"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ti_jfree: buffer not in use!\""
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->ti_jinuse_listhead"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ti_jfree: buffer already free!\""
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ti_jfree: asked to free buffer that we don't manage!\""
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ti_jfree: freeing buffer of wrong size!\""
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ti_jfree: can't find softc pointer!\""
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_jfree;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid\nti_jfree(m)\n\tstruct mbuf *m;\n{\n\tcaddr_t buf = m->m_ext.ext_buf;\n\tu_int size = m->m_ext.ext_size;\n\tstruct ti_softc *sc;\n\tint i;\n\tstruct ti_jpool_entry *entry;\n\n\t/* Extract the softc struct pointer. */\n\tsc = (struct ti_softc *)m->m_ext.ext_handle;\n\n\tif (sc == NULL)\n\t\tpanic(\"ti_jfree: can't find softc pointer!\");\n\n\tif (size != TI_JUMBO_FRAMELEN)\n\t\tpanic(\"ti_jfree: freeing buffer of wrong size!\");\n\n\t/* calculate the slot this buffer belongs to */\n\ti = ((vaddr_t)buf - (vaddr_t)sc->ti_cdata.ti_jumbo_buf) / TI_JLEN;\n\n\tif ((i < 0) || (i >= TI_JSLOTS))\n\t\tpanic(\"ti_jfree: asked to free buffer that we don't manage!\");\n\telse if (sc->ti_cdata.ti_jslots[i].ti_inuse == 0)\n\t\tpanic(\"ti_jfree: buffer already free!\");\n\telse {\n\t\tsc->ti_cdata.ti_jslots[i].ti_inuse--;\n\t\tif(sc->ti_cdata.ti_jslots[i].ti_inuse == 0) {\n\t\t\tentry = LIST_FIRST(&sc->ti_jinuse_listhead);\n\t\t\tif (entry == NULL)\n\t\t\t\tpanic(\"ti_jfree: buffer not in use!\");\n\t\t\tentry->slot = i;\n\t\t\tLIST_REMOVE(entry, jpool_entries);\n\t\t\tLIST_INSERT_HEAD(&sc->ti_jfree_listhead, \n\t\t\t\t\t  entry, jpool_entries);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ti_jref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "648-676",
    "snippet": "void\nti_jref(m)\n\tstruct mbuf *m;\n{\n\tcaddr_t buf = m->m_ext.ext_buf;\n\tu_int size = m->m_ext.ext_size;\n\tstruct ti_softc *sc;\n\tregister int i;\n\n\t/* Extract the softc struct pointer. */\n\tsc = (struct ti_softc *)m->m_ext.ext_handle;\n\n\tif (sc == NULL)\n\t\tpanic(\"ti_jref: can't find softc pointer!\");\n\n\tif (size != TI_JUMBO_FRAMELEN)\n\t\tpanic(\"ti_jref: adjusting refcount of buf of wrong size!\");\n\n\t/* calculate the slot this buffer belongs to */\n\ti = ((vaddr_t)buf - (vaddr_t)sc->ti_cdata.ti_jumbo_buf) / TI_JLEN;\n\n\tif ((i < 0) || (i >= TI_JSLOTS))\n\t\tpanic(\"ti_jref: asked to reference buffer \"\n\t\t    \"that we don't manage!\");\n\telse if (sc->ti_cdata.ti_jslots[i].ti_inuse == 0)\n\t\tpanic(\"ti_jref: buffer already free!\");\n\telse\n\t\tsc->ti_cdata.ti_jslots[i].ti_inuse++;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_jref",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ti_jref: buffer already free!\""
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ti_jref: asked to reference buffer \"\n\t\t    \"that we don't manage!\""
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ti_jref: adjusting refcount of buf of wrong size!\""
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ti_jref: can't find softc pointer!\""
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_jref;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid\nti_jref(m)\n\tstruct mbuf *m;\n{\n\tcaddr_t buf = m->m_ext.ext_buf;\n\tu_int size = m->m_ext.ext_size;\n\tstruct ti_softc *sc;\n\tregister int i;\n\n\t/* Extract the softc struct pointer. */\n\tsc = (struct ti_softc *)m->m_ext.ext_handle;\n\n\tif (sc == NULL)\n\t\tpanic(\"ti_jref: can't find softc pointer!\");\n\n\tif (size != TI_JUMBO_FRAMELEN)\n\t\tpanic(\"ti_jref: adjusting refcount of buf of wrong size!\");\n\n\t/* calculate the slot this buffer belongs to */\n\ti = ((vaddr_t)buf - (vaddr_t)sc->ti_cdata.ti_jumbo_buf) / TI_JLEN;\n\n\tif ((i < 0) || (i >= TI_JSLOTS))\n\t\tpanic(\"ti_jref: asked to reference buffer \"\n\t\t    \"that we don't manage!\");\n\telse if (sc->ti_cdata.ti_jslots[i].ti_inuse == 0)\n\t\tpanic(\"ti_jref: buffer already free!\");\n\telse\n\t\tsc->ti_cdata.ti_jslots[i].ti_inuse++;\n}"
  },
  {
    "function_name": "ti_alloc_jumbo_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "552-620",
    "snippet": "int ti_alloc_jumbo_mem(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tcaddr_t ptr, kva;\n\tbus_dma_segment_t seg;\n\tbus_dmamap_t dmamap;\n\tint i, rseg;\n\tstruct ti_jpool_entry *entry;\n\n\t/* Grab a big chunk o' storage. */\n\tif (bus_dmamem_alloc(sc->sc_dmatag, TI_JMEM, PAGE_SIZE, 0,\n\t    &seg, 1, &rseg, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't alloc rx buffers\\n\", sc->sc_dv.dv_xname);\n\t\treturn (ENOBUFS);\n\t}\n\tif (bus_dmamem_map(sc->sc_dmatag, &seg, rseg, TI_JMEM, &kva,\n\t    BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't map dma buffers (%d bytes)\\n\",\n\t\t    sc->sc_dv.dv_xname, TI_JMEM);\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\treturn (ENOBUFS);\n\t}\n\tif (bus_dmamap_create(sc->sc_dmatag, TI_JMEM, 1,\n\t    TI_JMEM, 0, BUS_DMA_NOWAIT, &dmamap)) {\n\t\tprintf(\"%s: can't create dma map\\n\", sc->sc_dv.dv_xname);\n\t\tbus_dmamem_unmap(sc->sc_dmatag, kva, TI_JMEM);\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\treturn (ENOBUFS);\n\t}\n\tif (bus_dmamap_load(sc->sc_dmatag, dmamap, kva, TI_JMEM,\n\t    NULL, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't load dma map\\n\", sc->sc_dv.dv_xname);\n\t\tbus_dmamap_destroy(sc->sc_dmatag, dmamap);\n\t\tbus_dmamem_unmap(sc->sc_dmatag, kva, TI_JMEM);\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\treturn (ENOBUFS);\n\t}\n\tsc->ti_cdata.ti_jumbo_buf = (caddr_t)kva;\n\n\tLIST_INIT(&sc->ti_jfree_listhead);\n\tLIST_INIT(&sc->ti_jinuse_listhead);\n\n\t/*\n\t * Now divide it up into 9K pieces and save the addresses\n\t * in an array.\n\t */\n\tptr = sc->ti_cdata.ti_jumbo_buf;\n\tfor (i = 0; i < TI_JSLOTS; i++) {\n\t\tsc->ti_cdata.ti_jslots[i].ti_buf = ptr;\n\t\tsc->ti_cdata.ti_jslots[i].ti_inuse = 0;\n\t\tptr += TI_JLEN;\n\t\tentry = malloc(sizeof(struct ti_jpool_entry), \n\t\t\t       M_DEVBUF, M_NOWAIT);\n\t\tif (entry == NULL) {\n\t\t\tbus_dmamap_unload(sc->sc_dmatag, dmamap);\n\t\t\tbus_dmamap_destroy(sc->sc_dmatag, dmamap);\n\t\t\tbus_dmamem_unmap(sc->sc_dmatag, kva, TI_JMEM);\n\t\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\t\tsc->ti_cdata.ti_jumbo_buf = NULL;\n\t\t\tprintf(\"%s: no memory for jumbo buffer queue\\n\",\n\t\t\t    sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tentry->slot = i;\n\t\tLIST_INSERT_HEAD(&sc->ti_jfree_listhead, entry, jpool_entries);\n\t}\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ti_alloc_jumbo_mem",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIST_INSERT_HEAD",
          "args": [
            "&sc->ti_jfree_listhead",
            "entry",
            "jpool_entries"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: no memory for jumbo buffer queue\\n\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "sc->sc_dmatag",
            "&seg",
            "rseg"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "sc->sc_dmatag",
            "kva",
            "TI_JMEM"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_destroy",
          "args": [
            "sc->sc_dmatag",
            "dmamap"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_unload",
          "args": [
            "sc->sc_dmatag",
            "dmamap"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct ti_jpool_entry)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_INIT",
          "args": [
            "&sc->ti_jinuse_listhead"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INIT",
          "args": [
            "&sc->ti_jfree_listhead"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "sc->sc_dmatag",
            "&seg",
            "rseg"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "sc->sc_dmatag",
            "kva",
            "TI_JMEM"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_destroy",
          "args": [
            "sc->sc_dmatag",
            "dmamap"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "sc->sc_dmatag",
            "dmamap",
            "kva",
            "TI_JMEM",
            "NULL",
            "BUS_DMA_NOWAIT"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "sc->sc_dmatag",
            "&seg",
            "rseg"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "sc->sc_dmatag",
            "kva",
            "TI_JMEM"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "sc->sc_dmatag",
            "TI_JMEM",
            "1",
            "TI_JMEM",
            "0",
            "BUS_DMA_NOWAIT",
            "&dmamap"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "sc->sc_dmatag",
            "&seg",
            "rseg"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_map",
          "args": [
            "sc->sc_dmatag",
            "&seg",
            "rseg",
            "TI_JMEM",
            "&kva",
            "BUS_DMA_NOWAIT"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_alloc",
          "args": [
            "sc->sc_dmatag",
            "TI_JMEM",
            "PAGE_SIZE",
            "0",
            "&seg",
            "1",
            "&rseg",
            "BUS_DMA_NOWAIT"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ti_alloc_jumbo_mem;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_alloc_jumbo_mem(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tcaddr_t ptr, kva;\n\tbus_dma_segment_t seg;\n\tbus_dmamap_t dmamap;\n\tint i, rseg;\n\tstruct ti_jpool_entry *entry;\n\n\t/* Grab a big chunk o' storage. */\n\tif (bus_dmamem_alloc(sc->sc_dmatag, TI_JMEM, PAGE_SIZE, 0,\n\t    &seg, 1, &rseg, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't alloc rx buffers\\n\", sc->sc_dv.dv_xname);\n\t\treturn (ENOBUFS);\n\t}\n\tif (bus_dmamem_map(sc->sc_dmatag, &seg, rseg, TI_JMEM, &kva,\n\t    BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't map dma buffers (%d bytes)\\n\",\n\t\t    sc->sc_dv.dv_xname, TI_JMEM);\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\treturn (ENOBUFS);\n\t}\n\tif (bus_dmamap_create(sc->sc_dmatag, TI_JMEM, 1,\n\t    TI_JMEM, 0, BUS_DMA_NOWAIT, &dmamap)) {\n\t\tprintf(\"%s: can't create dma map\\n\", sc->sc_dv.dv_xname);\n\t\tbus_dmamem_unmap(sc->sc_dmatag, kva, TI_JMEM);\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\treturn (ENOBUFS);\n\t}\n\tif (bus_dmamap_load(sc->sc_dmatag, dmamap, kva, TI_JMEM,\n\t    NULL, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't load dma map\\n\", sc->sc_dv.dv_xname);\n\t\tbus_dmamap_destroy(sc->sc_dmatag, dmamap);\n\t\tbus_dmamem_unmap(sc->sc_dmatag, kva, TI_JMEM);\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\treturn (ENOBUFS);\n\t}\n\tsc->ti_cdata.ti_jumbo_buf = (caddr_t)kva;\n\n\tLIST_INIT(&sc->ti_jfree_listhead);\n\tLIST_INIT(&sc->ti_jinuse_listhead);\n\n\t/*\n\t * Now divide it up into 9K pieces and save the addresses\n\t * in an array.\n\t */\n\tptr = sc->ti_cdata.ti_jumbo_buf;\n\tfor (i = 0; i < TI_JSLOTS; i++) {\n\t\tsc->ti_cdata.ti_jslots[i].ti_buf = ptr;\n\t\tsc->ti_cdata.ti_jslots[i].ti_inuse = 0;\n\t\tptr += TI_JLEN;\n\t\tentry = malloc(sizeof(struct ti_jpool_entry), \n\t\t\t       M_DEVBUF, M_NOWAIT);\n\t\tif (entry == NULL) {\n\t\t\tbus_dmamap_unload(sc->sc_dmatag, dmamap);\n\t\t\tbus_dmamap_destroy(sc->sc_dmatag, dmamap);\n\t\t\tbus_dmamem_unmap(sc->sc_dmatag, kva, TI_JMEM);\n\t\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\t\tsc->ti_cdata.ti_jumbo_buf = NULL;\n\t\t\tprintf(\"%s: no memory for jumbo buffer queue\\n\",\n\t\t\t    sc->sc_dv.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tentry->slot = i;\n\t\tLIST_INSERT_HEAD(&sc->ti_jfree_listhead, entry, jpool_entries);\n\t}\n\n\treturn(0);\n}"
  },
  {
    "function_name": "ti_handle_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "481-527",
    "snippet": "void ti_handle_events(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ti_event_desc\t*e;\n\n\tif (sc->ti_rdata->ti_event_ring == NULL)\n\t\treturn;\n\n\twhile (sc->ti_ev_saved_considx != sc->ti_ev_prodidx.ti_idx) {\n\t\te = &sc->ti_rdata->ti_event_ring[sc->ti_ev_saved_considx];\n\t\tswitch(e->ti_event) {\n\t\tcase TI_EV_LINKSTAT_CHANGED:\n\t\t\tsc->ti_linkstat = e->ti_code;\n\t\t\tbreak;\n\t\tcase TI_EV_ERROR:\n\t\t\tif (e->ti_code == TI_EV_CODE_ERR_INVAL_CMD)\n\t\t\t\tprintf(\"%s: invalid command\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname);\n\t\t\telse if (e->ti_code == TI_EV_CODE_ERR_UNIMP_CMD)\n\t\t\t\tprintf(\"%s: unknown command\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname);\n\t\t\telse if (e->ti_code == TI_EV_CODE_ERR_BADCFG)\n\t\t\t\tprintf(\"%s: bad config data\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname);\n\t\t\tbreak;\n\t\tcase TI_EV_FIRMWARE_UP:\n\t\t\tti_init2(sc);\n\t\t\tbreak;\n\t\tcase TI_EV_STATS_UPDATED:\n\t\t\tti_stats_update(sc);\n\t\t\tbreak;\n\t\tcase TI_EV_RESET_JUMBO_RING:\n\t\tcase TI_EV_MCAST_UPDATED:\n\t\t\t/* Who cares. */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"%s: unknown event: %d\\n\",\n\t\t\t    sc->sc_dv.dv_xname, e->ti_event);\n\t\t\tbreak;\n\t\t}\n\t\t/* Advance the consumer index. */\n\t\tTI_INC(sc->ti_ev_saved_considx, TI_EVENT_RING_CNT);\n\t\tCSR_WRITE_4(sc, TI_GCR_EVENTCONS_IDX, sc->ti_ev_saved_considx);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_stats_update",
      "void ti_init2",
      "void ti_handle_events",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_EVENTCONS_IDX",
            "sc->ti_ev_saved_considx"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_INC",
          "args": [
            "sc->ti_ev_saved_considx",
            "TI_EVENT_RING_CNT"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unknown event: %d\\n\"",
            "sc->sc_dv.dv_xname",
            "e->ti_event"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_stats_update",
          "args": [
            "sc"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "ti_stats_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "1929-1944",
          "snippet": "void ti_stats_update(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tifp->if_collisions +=\n\t   (sc->ti_rdata->ti_info.ti_stats.dot3StatsSingleCollisionFrames +\n\t   sc->ti_rdata->ti_info.ti_stats.dot3StatsMultipleCollisionFrames +\n\t   sc->ti_rdata->ti_info.ti_stats.dot3StatsExcessiveCollisions +\n\t   sc->ti_rdata->ti_info.ti_stats.dot3StatsLateCollisions) -\n\t   ifp->if_collisions;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_stats_update",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_stats_update;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_stats_update(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tifp->if_collisions +=\n\t   (sc->ti_rdata->ti_info.ti_stats.dot3StatsSingleCollisionFrames +\n\t   sc->ti_rdata->ti_info.ti_stats.dot3StatsMultipleCollisionFrames +\n\t   sc->ti_rdata->ti_info.ti_stats.dot3StatsExcessiveCollisions +\n\t   sc->ti_rdata->ti_info.ti_stats.dot3StatsLateCollisions) -\n\t   ifp->if_collisions;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ti_init2",
          "args": [
            "sc"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "ti_init2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "2112-2195",
          "snippet": "void ti_init2(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ti_cmd_desc\tcmd;\n\tstruct ifnet\t\t*ifp;\n\tu_int16_t\t\t*m;\n\tstruct ifmedia\t\t*ifm;\n\tint\t\t\ttmp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Specify MTU and interface index. */\n\tCSR_WRITE_4(sc, TI_GCR_IFINDEX, sc->sc_dv.dv_unit);\n\tCSR_WRITE_4(sc, TI_GCR_IFMTU, ifp->if_mtu +\n\t    ETHER_HDR_LEN + ETHER_CRC_LEN);\n\tTI_DO_CMD(TI_CMD_UPDATE_GENCOM, 0, 0);\n\n\t/* Load our MAC address. */\n\tm = (u_int16_t *)&sc->arpcom.ac_enaddr[0];\n\tCSR_WRITE_4(sc, TI_GCR_PAR0, htons(m[0]));\n\tCSR_WRITE_4(sc, TI_GCR_PAR1, (htons(m[1]) << 16) | htons(m[2]));\n\tTI_DO_CMD(TI_CMD_SET_MAC_ADDR, 0, 0);\n\n\t/* Enable or disable promiscuous mode as needed. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tTI_DO_CMD(TI_CMD_SET_PROMISC_MODE, TI_CMD_CODE_PROMISC_ENB, 0);\n\t} else {\n\t\tTI_DO_CMD(TI_CMD_SET_PROMISC_MODE, TI_CMD_CODE_PROMISC_DIS, 0);\n\t}\n\n\t/* Program multicast filter. */\n\tti_setmulti(sc);\n\n\t/*\n\t * If this is a Tigon 1, we should tell the\n\t * firmware to use software packet filtering.\n\t */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON) {\n\t\tTI_DO_CMD(TI_CMD_FDR_FILTERING, TI_CMD_CODE_FILT_ENB, 0);\n\t}\n\n\t/* Init RX ring. */\n\tti_init_rx_ring_std(sc);\n\n\t/* Init jumbo RX ring. */\n\tif (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))\n\t\tti_init_rx_ring_jumbo(sc);\n\n\t/*\n\t * If this is a Tigon 2, we can also configure the\n\t * mini ring.\n\t */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II)\n\t\tti_init_rx_ring_mini(sc);\n\n\tCSR_WRITE_4(sc, TI_GCR_RXRETURNCONS_IDX, 0);\n\tsc->ti_rx_saved_considx = 0;\n\n\t/* Init TX ring. */\n\tti_init_tx_ring(sc);\n\n\t/* Tell firmware we're alive. */\n\tTI_DO_CMD(TI_CMD_HOST_STATE, TI_CMD_CODE_STACK_UP, 0);\n\n\t/* Enable host interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 0);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Make sure to set media properly. We have to do this\n\t * here since we have to issue commands in order to set\n\t * the link negotiation and we can't issue commands until\n\t * the firmware is running.\n\t */\n\tifm = &sc->ifmedia;\n\ttmp = ifm->ifm_media;\n\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\tti_ifmedia_upd(ifp);\n\tifm->ifm_media = tmp;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_init2",
            "int ti_ifmedia_upd",
            "void ti_setmulti",
            "int ti_init_rx_ring_std",
            "int ti_init_rx_ring_jumbo",
            "int ti_init_rx_ring_mini",
            "int ti_init_tx_ring",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_init2;\nint ti_ifmedia_upd;\nvoid ti_setmulti;\nint ti_init_rx_ring_std;\nint ti_init_rx_ring_jumbo;\nint ti_init_rx_ring_mini;\nint ti_init_tx_ring;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_init2(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ti_cmd_desc\tcmd;\n\tstruct ifnet\t\t*ifp;\n\tu_int16_t\t\t*m;\n\tstruct ifmedia\t\t*ifm;\n\tint\t\t\ttmp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Specify MTU and interface index. */\n\tCSR_WRITE_4(sc, TI_GCR_IFINDEX, sc->sc_dv.dv_unit);\n\tCSR_WRITE_4(sc, TI_GCR_IFMTU, ifp->if_mtu +\n\t    ETHER_HDR_LEN + ETHER_CRC_LEN);\n\tTI_DO_CMD(TI_CMD_UPDATE_GENCOM, 0, 0);\n\n\t/* Load our MAC address. */\n\tm = (u_int16_t *)&sc->arpcom.ac_enaddr[0];\n\tCSR_WRITE_4(sc, TI_GCR_PAR0, htons(m[0]));\n\tCSR_WRITE_4(sc, TI_GCR_PAR1, (htons(m[1]) << 16) | htons(m[2]));\n\tTI_DO_CMD(TI_CMD_SET_MAC_ADDR, 0, 0);\n\n\t/* Enable or disable promiscuous mode as needed. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tTI_DO_CMD(TI_CMD_SET_PROMISC_MODE, TI_CMD_CODE_PROMISC_ENB, 0);\n\t} else {\n\t\tTI_DO_CMD(TI_CMD_SET_PROMISC_MODE, TI_CMD_CODE_PROMISC_DIS, 0);\n\t}\n\n\t/* Program multicast filter. */\n\tti_setmulti(sc);\n\n\t/*\n\t * If this is a Tigon 1, we should tell the\n\t * firmware to use software packet filtering.\n\t */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON) {\n\t\tTI_DO_CMD(TI_CMD_FDR_FILTERING, TI_CMD_CODE_FILT_ENB, 0);\n\t}\n\n\t/* Init RX ring. */\n\tti_init_rx_ring_std(sc);\n\n\t/* Init jumbo RX ring. */\n\tif (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))\n\t\tti_init_rx_ring_jumbo(sc);\n\n\t/*\n\t * If this is a Tigon 2, we can also configure the\n\t * mini ring.\n\t */\n\tif (sc->ti_hwrev == TI_HWREV_TIGON_II)\n\t\tti_init_rx_ring_mini(sc);\n\n\tCSR_WRITE_4(sc, TI_GCR_RXRETURNCONS_IDX, 0);\n\tsc->ti_rx_saved_considx = 0;\n\n\t/* Init TX ring. */\n\tti_init_tx_ring(sc);\n\n\t/* Tell firmware we're alive. */\n\tTI_DO_CMD(TI_CMD_HOST_STATE, TI_CMD_CODE_STACK_UP, 0);\n\n\t/* Enable host interrupts. */\n\tCSR_WRITE_4(sc, TI_MB_HOSTINTR, 0);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Make sure to set media properly. We have to do this\n\t * here since we have to issue commands in order to set\n\t * the link negotiation and we can't issue commands until\n\t * the firmware is running.\n\t */\n\tifm = &sc->ifmedia;\n\ttmp = ifm->ifm_media;\n\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\tti_ifmedia_upd(ifp);\n\tifm->ifm_media = tmp;\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_stats_update;\nvoid ti_init2;\nvoid ti_handle_events;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_handle_events(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tstruct ti_event_desc\t*e;\n\n\tif (sc->ti_rdata->ti_event_ring == NULL)\n\t\treturn;\n\n\twhile (sc->ti_ev_saved_considx != sc->ti_ev_prodidx.ti_idx) {\n\t\te = &sc->ti_rdata->ti_event_ring[sc->ti_ev_saved_considx];\n\t\tswitch(e->ti_event) {\n\t\tcase TI_EV_LINKSTAT_CHANGED:\n\t\t\tsc->ti_linkstat = e->ti_code;\n\t\t\tbreak;\n\t\tcase TI_EV_ERROR:\n\t\t\tif (e->ti_code == TI_EV_CODE_ERR_INVAL_CMD)\n\t\t\t\tprintf(\"%s: invalid command\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname);\n\t\t\telse if (e->ti_code == TI_EV_CODE_ERR_UNIMP_CMD)\n\t\t\t\tprintf(\"%s: unknown command\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname);\n\t\t\telse if (e->ti_code == TI_EV_CODE_ERR_BADCFG)\n\t\t\t\tprintf(\"%s: bad config data\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname);\n\t\t\tbreak;\n\t\tcase TI_EV_FIRMWARE_UP:\n\t\t\tti_init2(sc);\n\t\t\tbreak;\n\t\tcase TI_EV_STATS_UPDATED:\n\t\t\tti_stats_update(sc);\n\t\t\tbreak;\n\t\tcase TI_EV_RESET_JUMBO_RING:\n\t\tcase TI_EV_MCAST_UPDATED:\n\t\t\t/* Who cares. */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"%s: unknown event: %d\\n\",\n\t\t\t    sc->sc_dv.dv_xname, e->ti_event);\n\t\t\tbreak;\n\t\t}\n\t\t/* Advance the consumer index. */\n\t\tTI_INC(sc->ti_ev_saved_considx, TI_EVENT_RING_CNT);\n\t\tCSR_WRITE_4(sc, TI_GCR_EVENTCONS_IDX, sc->ti_ev_saved_considx);\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_cmd_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "452-476",
    "snippet": "void ti_cmd_ext(sc, cmd, arg, len)\n\tstruct ti_softc\t\t*sc;\n\tstruct ti_cmd_desc\t*cmd;\n\tcaddr_t\t\t\targ;\n\tint\t\t\tlen;\n{\n\tu_int32_t\t\tindex;\n\tregister int\t\ti;\n\n\tif (sc->ti_rdata->ti_cmd_ring == NULL)\n\t\treturn;\n\n\tindex = sc->ti_cmd_saved_prodidx;\n\tCSR_WRITE_4(sc, TI_GCR_CMDRING + (index * 4), *(u_int32_t *)(cmd));\n\tTI_INC(index, TI_CMD_RING_CNT);\n\tfor (i = 0; i < len; i++) {\n\t\tCSR_WRITE_4(sc, TI_GCR_CMDRING + (index * 4),\n\t\t    *(u_int32_t *)(&arg[i * 4]));\n\t\tTI_INC(index, TI_CMD_RING_CNT);\n\t}\n\tCSR_WRITE_4(sc, TI_MB_CMDPROD_IDX, index);\n\tsc->ti_cmd_saved_prodidx = index;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_cmd_ext",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_MB_CMDPROD_IDX",
            "index"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_INC",
          "args": [
            "index",
            "TI_CMD_RING_CNT"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_CMDRING + (index * 4)",
            "*(u_int32_t *)(&arg[i * 4])"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_INC",
          "args": [
            "index",
            "TI_CMD_RING_CNT"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_CMDRING + (index * 4)",
            "*(u_int32_t *)(cmd)"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_cmd_ext;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_cmd_ext(sc, cmd, arg, len)\n\tstruct ti_softc\t\t*sc;\n\tstruct ti_cmd_desc\t*cmd;\n\tcaddr_t\t\t\targ;\n\tint\t\t\tlen;\n{\n\tu_int32_t\t\tindex;\n\tregister int\t\ti;\n\n\tif (sc->ti_rdata->ti_cmd_ring == NULL)\n\t\treturn;\n\n\tindex = sc->ti_cmd_saved_prodidx;\n\tCSR_WRITE_4(sc, TI_GCR_CMDRING + (index * 4), *(u_int32_t *)(cmd));\n\tTI_INC(index, TI_CMD_RING_CNT);\n\tfor (i = 0; i < len; i++) {\n\t\tCSR_WRITE_4(sc, TI_GCR_CMDRING + (index * 4),\n\t\t    *(u_int32_t *)(&arg[i * 4]));\n\t\tTI_INC(index, TI_CMD_RING_CNT);\n\t}\n\tCSR_WRITE_4(sc, TI_MB_CMDPROD_IDX, index);\n\tsc->ti_cmd_saved_prodidx = index;\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "430-446",
    "snippet": "void ti_cmd(sc, cmd)\n\tstruct ti_softc\t\t*sc;\n\tstruct ti_cmd_desc\t*cmd;\n{\n\tu_int32_t\t\tindex;\n\n\tif (sc->ti_rdata->ti_cmd_ring == NULL)\n\t\treturn;\n\n\tindex = sc->ti_cmd_saved_prodidx;\n\tCSR_WRITE_4(sc, TI_GCR_CMDRING + (index * 4), *(u_int32_t *)(cmd));\n\tTI_INC(index, TI_CMD_RING_CNT);\n\tCSR_WRITE_4(sc, TI_MB_CMDPROD_IDX, index);\n\tsc->ti_cmd_saved_prodidx = index;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_cmd",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_MB_CMDPROD_IDX",
            "index"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_INC",
          "args": [
            "index",
            "TI_CMD_RING_CNT"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_GCR_CMDRING + (index * 4)",
            "*(u_int32_t *)(cmd)"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_cmd;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_cmd(sc, cmd)\n\tstruct ti_softc\t\t*sc;\n\tstruct ti_cmd_desc\t*cmd;\n{\n\tu_int32_t\t\tindex;\n\n\tif (sc->ti_rdata->ti_cmd_ring == NULL)\n\t\treturn;\n\n\tindex = sc->ti_cmd_saved_prodidx;\n\tCSR_WRITE_4(sc, TI_GCR_CMDRING + (index * 4), *(u_int32_t *)(cmd));\n\tTI_INC(index, TI_CMD_RING_CNT);\n\tCSR_WRITE_4(sc, TI_MB_CMDPROD_IDX, index);\n\tsc->ti_cmd_saved_prodidx = index;\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_loadfw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "372-425",
    "snippet": "void ti_loadfw(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tswitch(sc->ti_hwrev) {\n\tcase TI_HWREV_TIGON:\n\t\tif (tigonFwReleaseMajor != TI_FIRMWARE_MAJOR ||\n\t\t    tigonFwReleaseMinor != TI_FIRMWARE_MINOR ||\n\t\t    tigonFwReleaseFix != TI_FIRMWARE_FIX) {\n\t\t\tprintf(\"%s: firmware revision mismatch; want \"\n\t\t\t    \"%d.%d.%d, got %d.%d.%d\\n\", sc->sc_dv.dv_xname,\n\t\t\t    TI_FIRMWARE_MAJOR, TI_FIRMWARE_MINOR,\n\t\t\t    TI_FIRMWARE_FIX, tigonFwReleaseMajor,\n\t\t\t    tigonFwReleaseMinor, tigonFwReleaseFix);\n\t\t\treturn;\n\t\t}\n\t\tti_mem(sc, tigonFwTextAddr, tigonFwTextLen,\n\t\t    (caddr_t)tigonFwText);\n\t\tti_mem(sc, tigonFwDataAddr, tigonFwDataLen,\n\t\t    (caddr_t)tigonFwData);\n\t\tti_mem(sc, tigonFwRodataAddr, tigonFwRodataLen,\n\t\t    (caddr_t)tigonFwRodata);\n\t\tti_mem(sc, tigonFwBssAddr, tigonFwBssLen, NULL);\n\t\tti_mem(sc, tigonFwSbssAddr, tigonFwSbssLen, NULL);\n\t\tCSR_WRITE_4(sc, TI_CPU_PROGRAM_COUNTER, tigonFwStartAddr);\n\t\tbreak;\n\tcase TI_HWREV_TIGON_II:\n\t\tif (tigon2FwReleaseMajor != TI_FIRMWARE_MAJOR ||\n\t\t    tigon2FwReleaseMinor != TI_FIRMWARE_MINOR ||\n\t\t    tigon2FwReleaseFix != TI_FIRMWARE_FIX) {\n\t\t\tprintf(\"%s: firmware revision mismatch; want \"\n\t\t\t    \"%d.%d.%d, got %d.%d.%d\\n\", sc->sc_dv.dv_xname,\n\t\t\t    TI_FIRMWARE_MAJOR, TI_FIRMWARE_MINOR,\n\t\t\t    TI_FIRMWARE_FIX, tigon2FwReleaseMajor,\n\t\t\t    tigon2FwReleaseMinor, tigon2FwReleaseFix);\n\t\t\treturn;\n\t\t}\n\t\tti_mem(sc, tigon2FwTextAddr, tigon2FwTextLen,\n\t\t    (caddr_t)tigon2FwText);\n\t\tti_mem(sc, tigon2FwDataAddr, tigon2FwDataLen,\n\t\t    (caddr_t)tigon2FwData);\n\t\tti_mem(sc, tigon2FwRodataAddr, tigon2FwRodataLen,\n\t\t    (caddr_t)tigon2FwRodata);\n\t\tti_mem(sc, tigon2FwBssAddr, tigon2FwBssLen, NULL);\n\t\tti_mem(sc, tigon2FwSbssAddr, tigon2FwSbssLen, NULL);\n\t\tCSR_WRITE_4(sc, TI_CPU_PROGRAM_COUNTER, tigon2FwStartAddr);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: can't load firmware: unknown hardware rev\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\t\tbreak;\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_mem",
      "void ti_loadfw",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: can't load firmware: unknown hardware rev\\n\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_CPU_PROGRAM_COUNTER",
            "tigon2FwStartAddr"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ti_mem",
          "args": [
            "sc",
            "tigon2FwSbssAddr",
            "tigon2FwSbssLen",
            "NULL"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "ti_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "333-365",
          "snippet": "void ti_mem(sc, addr, len, buf)\n\tstruct ti_softc\t\t*sc;\n\tu_int32_t\t\taddr, len;\n\tcaddr_t\t\t\tbuf;\n{\n\tint\t\t\tsegptr, segsize, cnt;\n\tcaddr_t\t\t\tti_winbase, ptr;\n\n\tsegptr = addr;\n\tcnt = len;\n\tti_winbase = (caddr_t)(sc->ti_bhandle + TI_WINDOW);\n\tptr = buf;\n\n\twhile(cnt) {\n\t\tif (cnt < TI_WINLEN)\n\t\t\tsegsize = cnt;\n\t\telse\n\t\t\tsegsize = TI_WINLEN - (segptr % TI_WINLEN);\n\t\tCSR_WRITE_4(sc, TI_WINBASE, (segptr & ~(TI_WINLEN - 1)));\n\t\tif (buf == NULL)\n\t\t\tbzero((char *)ti_winbase + (segptr &\n\t\t\t    (TI_WINLEN - 1)), segsize);\n\t\telse {\n\t\t\tbcopy((char *)ptr, (char *)ti_winbase +\n\t\t\t    (segptr & (TI_WINLEN - 1)), segsize);\n\t\t\tptr += segsize;\n\t\t}\n\t\tsegptr += segsize;\n\t\tcnt -= segsize;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_mem",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_mem;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_mem(sc, addr, len, buf)\n\tstruct ti_softc\t\t*sc;\n\tu_int32_t\t\taddr, len;\n\tcaddr_t\t\t\tbuf;\n{\n\tint\t\t\tsegptr, segsize, cnt;\n\tcaddr_t\t\t\tti_winbase, ptr;\n\n\tsegptr = addr;\n\tcnt = len;\n\tti_winbase = (caddr_t)(sc->ti_bhandle + TI_WINDOW);\n\tptr = buf;\n\n\twhile(cnt) {\n\t\tif (cnt < TI_WINLEN)\n\t\t\tsegsize = cnt;\n\t\telse\n\t\t\tsegsize = TI_WINLEN - (segptr % TI_WINLEN);\n\t\tCSR_WRITE_4(sc, TI_WINBASE, (segptr & ~(TI_WINLEN - 1)));\n\t\tif (buf == NULL)\n\t\t\tbzero((char *)ti_winbase + (segptr &\n\t\t\t    (TI_WINLEN - 1)), segsize);\n\t\telse {\n\t\t\tbcopy((char *)ptr, (char *)ti_winbase +\n\t\t\t    (segptr & (TI_WINLEN - 1)), segsize);\n\t\t\tptr += segsize;\n\t\t}\n\t\tsegptr += segsize;\n\t\tcnt -= segsize;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_CPU_PROGRAM_COUNTER",
            "tigonFwStartAddr"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_mem;\nvoid ti_loadfw;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_loadfw(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tswitch(sc->ti_hwrev) {\n\tcase TI_HWREV_TIGON:\n\t\tif (tigonFwReleaseMajor != TI_FIRMWARE_MAJOR ||\n\t\t    tigonFwReleaseMinor != TI_FIRMWARE_MINOR ||\n\t\t    tigonFwReleaseFix != TI_FIRMWARE_FIX) {\n\t\t\tprintf(\"%s: firmware revision mismatch; want \"\n\t\t\t    \"%d.%d.%d, got %d.%d.%d\\n\", sc->sc_dv.dv_xname,\n\t\t\t    TI_FIRMWARE_MAJOR, TI_FIRMWARE_MINOR,\n\t\t\t    TI_FIRMWARE_FIX, tigonFwReleaseMajor,\n\t\t\t    tigonFwReleaseMinor, tigonFwReleaseFix);\n\t\t\treturn;\n\t\t}\n\t\tti_mem(sc, tigonFwTextAddr, tigonFwTextLen,\n\t\t    (caddr_t)tigonFwText);\n\t\tti_mem(sc, tigonFwDataAddr, tigonFwDataLen,\n\t\t    (caddr_t)tigonFwData);\n\t\tti_mem(sc, tigonFwRodataAddr, tigonFwRodataLen,\n\t\t    (caddr_t)tigonFwRodata);\n\t\tti_mem(sc, tigonFwBssAddr, tigonFwBssLen, NULL);\n\t\tti_mem(sc, tigonFwSbssAddr, tigonFwSbssLen, NULL);\n\t\tCSR_WRITE_4(sc, TI_CPU_PROGRAM_COUNTER, tigonFwStartAddr);\n\t\tbreak;\n\tcase TI_HWREV_TIGON_II:\n\t\tif (tigon2FwReleaseMajor != TI_FIRMWARE_MAJOR ||\n\t\t    tigon2FwReleaseMinor != TI_FIRMWARE_MINOR ||\n\t\t    tigon2FwReleaseFix != TI_FIRMWARE_FIX) {\n\t\t\tprintf(\"%s: firmware revision mismatch; want \"\n\t\t\t    \"%d.%d.%d, got %d.%d.%d\\n\", sc->sc_dv.dv_xname,\n\t\t\t    TI_FIRMWARE_MAJOR, TI_FIRMWARE_MINOR,\n\t\t\t    TI_FIRMWARE_FIX, tigon2FwReleaseMajor,\n\t\t\t    tigon2FwReleaseMinor, tigon2FwReleaseFix);\n\t\t\treturn;\n\t\t}\n\t\tti_mem(sc, tigon2FwTextAddr, tigon2FwTextLen,\n\t\t    (caddr_t)tigon2FwText);\n\t\tti_mem(sc, tigon2FwDataAddr, tigon2FwDataLen,\n\t\t    (caddr_t)tigon2FwData);\n\t\tti_mem(sc, tigon2FwRodataAddr, tigon2FwRodataLen,\n\t\t    (caddr_t)tigon2FwRodata);\n\t\tti_mem(sc, tigon2FwBssAddr, tigon2FwBssLen, NULL);\n\t\tti_mem(sc, tigon2FwSbssAddr, tigon2FwSbssLen, NULL);\n\t\tCSR_WRITE_4(sc, TI_CPU_PROGRAM_COUNTER, tigon2FwStartAddr);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: can't load firmware: unknown hardware rev\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\t\tbreak;\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "333-365",
    "snippet": "void ti_mem(sc, addr, len, buf)\n\tstruct ti_softc\t\t*sc;\n\tu_int32_t\t\taddr, len;\n\tcaddr_t\t\t\tbuf;\n{\n\tint\t\t\tsegptr, segsize, cnt;\n\tcaddr_t\t\t\tti_winbase, ptr;\n\n\tsegptr = addr;\n\tcnt = len;\n\tti_winbase = (caddr_t)(sc->ti_bhandle + TI_WINDOW);\n\tptr = buf;\n\n\twhile(cnt) {\n\t\tif (cnt < TI_WINLEN)\n\t\t\tsegsize = cnt;\n\t\telse\n\t\t\tsegsize = TI_WINLEN - (segptr % TI_WINLEN);\n\t\tCSR_WRITE_4(sc, TI_WINBASE, (segptr & ~(TI_WINLEN - 1)));\n\t\tif (buf == NULL)\n\t\t\tbzero((char *)ti_winbase + (segptr &\n\t\t\t    (TI_WINLEN - 1)), segsize);\n\t\telse {\n\t\t\tbcopy((char *)ptr, (char *)ti_winbase +\n\t\t\t    (segptr & (TI_WINLEN - 1)), segsize);\n\t\t\tptr += segsize;\n\t\t}\n\t\tsegptr += segsize;\n\t\tcnt -= segsize;\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ti_mem",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(char *)ptr",
            "(char *)ti_winbase +\n\t\t\t    (segptr & (TI_WINLEN - 1))",
            "segsize"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)ti_winbase + (segptr &\n\t\t\t    (TI_WINLEN - 1))",
            "segsize"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TI_WINBASE",
            "(segptr & ~(TI_WINLEN - 1))"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->ti_bhandle + TI_WINDOW"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_mem;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_mem(sc, addr, len, buf)\n\tstruct ti_softc\t\t*sc;\n\tu_int32_t\t\taddr, len;\n\tcaddr_t\t\t\tbuf;\n{\n\tint\t\t\tsegptr, segsize, cnt;\n\tcaddr_t\t\t\tti_winbase, ptr;\n\n\tsegptr = addr;\n\tcnt = len;\n\tti_winbase = (caddr_t)(sc->ti_bhandle + TI_WINDOW);\n\tptr = buf;\n\n\twhile(cnt) {\n\t\tif (cnt < TI_WINLEN)\n\t\t\tsegsize = cnt;\n\t\telse\n\t\t\tsegsize = TI_WINLEN - (segptr % TI_WINLEN);\n\t\tCSR_WRITE_4(sc, TI_WINBASE, (segptr & ~(TI_WINLEN - 1)));\n\t\tif (buf == NULL)\n\t\t\tbzero((char *)ti_winbase + (segptr &\n\t\t\t    (TI_WINLEN - 1)), segsize);\n\t\telse {\n\t\t\tbcopy((char *)ptr, (char *)ti_winbase +\n\t\t\t    (segptr & (TI_WINLEN - 1)), segsize);\n\t\t\tptr += segsize;\n\t\t}\n\t\tsegptr += segsize;\n\t\tcnt -= segsize;\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "ti_read_eeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "310-327",
    "snippet": "int ti_read_eeprom(sc, dest, off, cnt)\n\tstruct ti_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n{\n\tint\t\t\terr = 0, i;\n\tu_int8_t\t\tbyte = 0;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\terr = ti_eeprom_getbyte(sc, off + i, &byte);\n\t\tif (err)\n\t\t\tbreak;\n\t\t*(dest + i) = byte;\n\t}\n\n\treturn(err ? 1 : 0);\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int8_t ti_eeprom_getbyte",
      "int ti_read_eeprom",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ti_eeprom_getbyte",
          "args": [
            "sc",
            "off + i",
            "&byte"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "ti_eeprom_getbyte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "236-305",
          "snippet": "u_int8_t ti_eeprom_getbyte(sc, addr, dest)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\taddr;\n\tu_int8_t\t\t*dest;\n{\n\tregister int\t\ti;\n\tu_int8_t\t\tbyte = 0;\n\n\tEEPROM_START;\n\n\t/*\n\t * Send write control code to EEPROM.\n\t */\n\tif (ti_eeprom_putbyte(sc, EEPROM_CTL_WRITE)) {\n\t\tprintf(\"%s: failed to send write command, status: %x\\n\",\n\t\t    sc->sc_dv.dv_xname, CSR_READ_4(sc, TI_MISC_LOCAL_CTL));\n\t\treturn(1);\n\t}\n\n\t/*\n\t * Send first byte of address of byte we want to read.\n\t */\n\tif (ti_eeprom_putbyte(sc, (addr >> 8) & 0xFF)) {\n\t\tprintf(\"%s: failed to send address, status: %x\\n\",\n\t\t    sc->sc_dv.dv_xname, CSR_READ_4(sc, TI_MISC_LOCAL_CTL));\n\t\treturn(1);\n\t}\n\t/*\n\t * Send second byte address of byte we want to read.\n\t */\n\tif (ti_eeprom_putbyte(sc, addr & 0xFF)) {\n\t\tprintf(\"%s: failed to send address, status: %x\\n\",\n\t\t    sc->sc_dv.dv_xname, CSR_READ_4(sc, TI_MISC_LOCAL_CTL));\n\t\treturn(1);\n\t}\n\n\tEEPROM_STOP;\n\tEEPROM_START;\n\t/*\n\t * Send read control code to EEPROM.\n\t */\n\tif (ti_eeprom_putbyte(sc, EEPROM_CTL_READ)) {\n\t\tprintf(\"%s: failed to send read command, status: %x\\n\",\n\t\t    sc->sc_dv.dv_xname, CSR_READ_4(sc, TI_MISC_LOCAL_CTL));\n\t\treturn(1);\n\t}\n\n\t/*\n\t * Start reading bits from EEPROM.\n\t */\n\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_TXEN);\n\tfor (i = 0x80; i; i >>= 1) {\n\t\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\t\tDELAY(1);\n\t\tif (CSR_READ_4(sc, TI_MISC_LOCAL_CTL) & TI_MLC_EE_DIN)\n\t\t\tbyte |= i;\n\t\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\t\tDELAY(1);\n\t}\n\n\tEEPROM_STOP;\n\n\t/*\n\t * No ACK generated for read, so just return byte.\n\t */\n\n\t*dest = byte;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int32_t ti_eeprom_putbyte",
            "u_int8_t ti_eeprom_getbyte",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t ti_eeprom_putbyte;\nu_int8_t ti_eeprom_getbyte;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nu_int8_t ti_eeprom_getbyte(sc, addr, dest)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\taddr;\n\tu_int8_t\t\t*dest;\n{\n\tregister int\t\ti;\n\tu_int8_t\t\tbyte = 0;\n\n\tEEPROM_START;\n\n\t/*\n\t * Send write control code to EEPROM.\n\t */\n\tif (ti_eeprom_putbyte(sc, EEPROM_CTL_WRITE)) {\n\t\tprintf(\"%s: failed to send write command, status: %x\\n\",\n\t\t    sc->sc_dv.dv_xname, CSR_READ_4(sc, TI_MISC_LOCAL_CTL));\n\t\treturn(1);\n\t}\n\n\t/*\n\t * Send first byte of address of byte we want to read.\n\t */\n\tif (ti_eeprom_putbyte(sc, (addr >> 8) & 0xFF)) {\n\t\tprintf(\"%s: failed to send address, status: %x\\n\",\n\t\t    sc->sc_dv.dv_xname, CSR_READ_4(sc, TI_MISC_LOCAL_CTL));\n\t\treturn(1);\n\t}\n\t/*\n\t * Send second byte address of byte we want to read.\n\t */\n\tif (ti_eeprom_putbyte(sc, addr & 0xFF)) {\n\t\tprintf(\"%s: failed to send address, status: %x\\n\",\n\t\t    sc->sc_dv.dv_xname, CSR_READ_4(sc, TI_MISC_LOCAL_CTL));\n\t\treturn(1);\n\t}\n\n\tEEPROM_STOP;\n\tEEPROM_START;\n\t/*\n\t * Send read control code to EEPROM.\n\t */\n\tif (ti_eeprom_putbyte(sc, EEPROM_CTL_READ)) {\n\t\tprintf(\"%s: failed to send read command, status: %x\\n\",\n\t\t    sc->sc_dv.dv_xname, CSR_READ_4(sc, TI_MISC_LOCAL_CTL));\n\t\treturn(1);\n\t}\n\n\t/*\n\t * Start reading bits from EEPROM.\n\t */\n\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_TXEN);\n\tfor (i = 0x80; i; i >>= 1) {\n\t\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\t\tDELAY(1);\n\t\tif (CSR_READ_4(sc, TI_MISC_LOCAL_CTL) & TI_MLC_EE_DIN)\n\t\t\tbyte |= i;\n\t\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\t\tDELAY(1);\n\t}\n\n\tEEPROM_STOP;\n\n\t/*\n\t * No ACK generated for read, so just return byte.\n\t */\n\n\t*dest = byte;\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t ti_eeprom_getbyte;\nint ti_read_eeprom;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nint ti_read_eeprom(sc, dest, off, cnt)\n\tstruct ti_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n{\n\tint\t\t\terr = 0, i;\n\tu_int8_t\t\tbyte = 0;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\terr = ti_eeprom_getbyte(sc, off + i, &byte);\n\t\tif (err)\n\t\t\tbreak;\n\t\t*(dest + i) = byte;\n\t}\n\n\treturn(err ? 1 : 0);\n}"
  },
  {
    "function_name": "ti_eeprom_getbyte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "236-305",
    "snippet": "u_int8_t ti_eeprom_getbyte(sc, addr, dest)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\taddr;\n\tu_int8_t\t\t*dest;\n{\n\tregister int\t\ti;\n\tu_int8_t\t\tbyte = 0;\n\n\tEEPROM_START;\n\n\t/*\n\t * Send write control code to EEPROM.\n\t */\n\tif (ti_eeprom_putbyte(sc, EEPROM_CTL_WRITE)) {\n\t\tprintf(\"%s: failed to send write command, status: %x\\n\",\n\t\t    sc->sc_dv.dv_xname, CSR_READ_4(sc, TI_MISC_LOCAL_CTL));\n\t\treturn(1);\n\t}\n\n\t/*\n\t * Send first byte of address of byte we want to read.\n\t */\n\tif (ti_eeprom_putbyte(sc, (addr >> 8) & 0xFF)) {\n\t\tprintf(\"%s: failed to send address, status: %x\\n\",\n\t\t    sc->sc_dv.dv_xname, CSR_READ_4(sc, TI_MISC_LOCAL_CTL));\n\t\treturn(1);\n\t}\n\t/*\n\t * Send second byte address of byte we want to read.\n\t */\n\tif (ti_eeprom_putbyte(sc, addr & 0xFF)) {\n\t\tprintf(\"%s: failed to send address, status: %x\\n\",\n\t\t    sc->sc_dv.dv_xname, CSR_READ_4(sc, TI_MISC_LOCAL_CTL));\n\t\treturn(1);\n\t}\n\n\tEEPROM_STOP;\n\tEEPROM_START;\n\t/*\n\t * Send read control code to EEPROM.\n\t */\n\tif (ti_eeprom_putbyte(sc, EEPROM_CTL_READ)) {\n\t\tprintf(\"%s: failed to send read command, status: %x\\n\",\n\t\t    sc->sc_dv.dv_xname, CSR_READ_4(sc, TI_MISC_LOCAL_CTL));\n\t\treturn(1);\n\t}\n\n\t/*\n\t * Start reading bits from EEPROM.\n\t */\n\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_TXEN);\n\tfor (i = 0x80; i; i >>= 1) {\n\t\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\t\tDELAY(1);\n\t\tif (CSR_READ_4(sc, TI_MISC_LOCAL_CTL) & TI_MLC_EE_DIN)\n\t\t\tbyte |= i;\n\t\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\t\tDELAY(1);\n\t}\n\n\tEEPROM_STOP;\n\n\t/*\n\t * No ACK generated for read, so just return byte.\n\t */\n\n\t*dest = byte;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int32_t ti_eeprom_putbyte",
      "u_int8_t ti_eeprom_getbyte",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_CLRBIT",
          "args": [
            "sc",
            "TI_MISC_LOCAL_CTL",
            "TI_MLC_EE_CLK"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TI_MISC_LOCAL_CTL"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_SETBIT",
          "args": [
            "sc",
            "TI_MISC_LOCAL_CTL",
            "TI_MLC_EE_CLK"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_CLRBIT",
          "args": [
            "sc",
            "TI_MISC_LOCAL_CTL",
            "TI_MLC_EE_TXEN"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: failed to send read command, status: %x\\n\"",
            "sc->sc_dv.dv_xname",
            "CSR_READ_4(sc, TI_MISC_LOCAL_CTL)"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TI_MISC_LOCAL_CTL"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ti_eeprom_putbyte",
          "args": [
            "sc",
            "EEPROM_CTL_READ"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "ti_eeprom_putbyte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "190-229",
          "snippet": "u_int32_t ti_eeprom_putbyte(sc, byte)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\tbyte;\n{\n\tregister int\t\ti, ack = 0;\n\n\t/*\n\t * Make sure we're in TX mode.\n\t */\n\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_TXEN);\n\n\t/*\n\t * Feed in each bit and stobe the clock.\n\t */\n\tfor (i = 0x80; i; i >>= 1) {\n\t\tif (byte & i) {\n\t\t\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_DOUT);\n\t\t} else {\n\t\t\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_DOUT);\n\t\t}\n\t\tDELAY(1);\n\t\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\t\tDELAY(1);\n\t\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\t}\n\n\t/*\n\t * Turn off TX mode.\n\t */\n\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_TXEN);\n\n\t/*\n\t * Check for ack.\n\t */\n\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\tack = CSR_READ_4(sc, TI_MISC_LOCAL_CTL) & TI_MLC_EE_DIN;\n\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\n\treturn(ack);\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int32_t ti_eeprom_putbyte",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t ti_eeprom_putbyte;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nu_int32_t ti_eeprom_putbyte(sc, byte)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\tbyte;\n{\n\tregister int\t\ti, ack = 0;\n\n\t/*\n\t * Make sure we're in TX mode.\n\t */\n\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_TXEN);\n\n\t/*\n\t * Feed in each bit and stobe the clock.\n\t */\n\tfor (i = 0x80; i; i >>= 1) {\n\t\tif (byte & i) {\n\t\t\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_DOUT);\n\t\t} else {\n\t\t\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_DOUT);\n\t\t}\n\t\tDELAY(1);\n\t\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\t\tDELAY(1);\n\t\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\t}\n\n\t/*\n\t * Turn off TX mode.\n\t */\n\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_TXEN);\n\n\t/*\n\t * Check for ack.\n\t */\n\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\tack = CSR_READ_4(sc, TI_MISC_LOCAL_CTL) & TI_MLC_EE_DIN;\n\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\n\treturn(ack);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TI_MISC_LOCAL_CTL"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TI_MISC_LOCAL_CTL"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TI_MISC_LOCAL_CTL"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t ti_eeprom_putbyte;\nu_int8_t ti_eeprom_getbyte;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nu_int8_t ti_eeprom_getbyte(sc, addr, dest)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\taddr;\n\tu_int8_t\t\t*dest;\n{\n\tregister int\t\ti;\n\tu_int8_t\t\tbyte = 0;\n\n\tEEPROM_START;\n\n\t/*\n\t * Send write control code to EEPROM.\n\t */\n\tif (ti_eeprom_putbyte(sc, EEPROM_CTL_WRITE)) {\n\t\tprintf(\"%s: failed to send write command, status: %x\\n\",\n\t\t    sc->sc_dv.dv_xname, CSR_READ_4(sc, TI_MISC_LOCAL_CTL));\n\t\treturn(1);\n\t}\n\n\t/*\n\t * Send first byte of address of byte we want to read.\n\t */\n\tif (ti_eeprom_putbyte(sc, (addr >> 8) & 0xFF)) {\n\t\tprintf(\"%s: failed to send address, status: %x\\n\",\n\t\t    sc->sc_dv.dv_xname, CSR_READ_4(sc, TI_MISC_LOCAL_CTL));\n\t\treturn(1);\n\t}\n\t/*\n\t * Send second byte address of byte we want to read.\n\t */\n\tif (ti_eeprom_putbyte(sc, addr & 0xFF)) {\n\t\tprintf(\"%s: failed to send address, status: %x\\n\",\n\t\t    sc->sc_dv.dv_xname, CSR_READ_4(sc, TI_MISC_LOCAL_CTL));\n\t\treturn(1);\n\t}\n\n\tEEPROM_STOP;\n\tEEPROM_START;\n\t/*\n\t * Send read control code to EEPROM.\n\t */\n\tif (ti_eeprom_putbyte(sc, EEPROM_CTL_READ)) {\n\t\tprintf(\"%s: failed to send read command, status: %x\\n\",\n\t\t    sc->sc_dv.dv_xname, CSR_READ_4(sc, TI_MISC_LOCAL_CTL));\n\t\treturn(1);\n\t}\n\n\t/*\n\t * Start reading bits from EEPROM.\n\t */\n\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_TXEN);\n\tfor (i = 0x80; i; i >>= 1) {\n\t\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\t\tDELAY(1);\n\t\tif (CSR_READ_4(sc, TI_MISC_LOCAL_CTL) & TI_MLC_EE_DIN)\n\t\t\tbyte |= i;\n\t\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\t\tDELAY(1);\n\t}\n\n\tEEPROM_STOP;\n\n\t/*\n\t * No ACK generated for read, so just return byte.\n\t */\n\n\t*dest = byte;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "ti_eeprom_putbyte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
    "lines": "190-229",
    "snippet": "u_int32_t ti_eeprom_putbyte(sc, byte)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\tbyte;\n{\n\tregister int\t\ti, ack = 0;\n\n\t/*\n\t * Make sure we're in TX mode.\n\t */\n\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_TXEN);\n\n\t/*\n\t * Feed in each bit and stobe the clock.\n\t */\n\tfor (i = 0x80; i; i >>= 1) {\n\t\tif (byte & i) {\n\t\t\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_DOUT);\n\t\t} else {\n\t\t\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_DOUT);\n\t\t}\n\t\tDELAY(1);\n\t\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\t\tDELAY(1);\n\t\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\t}\n\n\t/*\n\t * Turn off TX mode.\n\t */\n\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_TXEN);\n\n\t/*\n\t * Check for ack.\n\t */\n\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\tack = CSR_READ_4(sc, TI_MISC_LOCAL_CTL) & TI_MLC_EE_DIN;\n\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\n\treturn(ack);\n}",
    "includes": [
      "#include <dev/pci/ti_fw2.h>",
      "#include <dev/pci/ti_fw.h>",
      "#include <dev/pci/if_tireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int32_t ti_eeprom_putbyte",
      "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TI_CLRBIT",
          "args": [
            "sc",
            "TI_MISC_LOCAL_CTL",
            "TI_MLC_EE_CLK"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TI_MISC_LOCAL_CTL"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_SETBIT",
          "args": [
            "sc",
            "TI_MISC_LOCAL_CTL",
            "TI_MLC_EE_CLK"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_CLRBIT",
          "args": [
            "sc",
            "TI_MISC_LOCAL_CTL",
            "TI_MLC_EE_TXEN"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_CLRBIT",
          "args": [
            "sc",
            "TI_MISC_LOCAL_CTL",
            "TI_MLC_EE_CLK"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_SETBIT",
          "args": [
            "sc",
            "TI_MISC_LOCAL_CTL",
            "TI_MLC_EE_CLK"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_CLRBIT",
          "args": [
            "sc",
            "TI_MISC_LOCAL_CTL",
            "TI_MLC_EE_DOUT"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_SETBIT",
          "args": [
            "sc",
            "TI_MISC_LOCAL_CTL",
            "TI_MLC_EE_DOUT"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TI_SETBIT",
          "args": [
            "sc",
            "TI_MISC_LOCAL_CTL",
            "TI_MLC_EE_TXEN"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t ti_eeprom_putbyte;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nu_int32_t ti_eeprom_putbyte(sc, byte)\n\tstruct ti_softc\t\t*sc;\n\tint\t\t\tbyte;\n{\n\tregister int\t\ti, ack = 0;\n\n\t/*\n\t * Make sure we're in TX mode.\n\t */\n\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_TXEN);\n\n\t/*\n\t * Feed in each bit and stobe the clock.\n\t */\n\tfor (i = 0x80; i; i >>= 1) {\n\t\tif (byte & i) {\n\t\t\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_DOUT);\n\t\t} else {\n\t\t\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_DOUT);\n\t\t}\n\t\tDELAY(1);\n\t\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\t\tDELAY(1);\n\t\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\t}\n\n\t/*\n\t * Turn off TX mode.\n\t */\n\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_TXEN);\n\n\t/*\n\t * Check for ack.\n\t */\n\tTI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\tack = CSR_READ_4(sc, TI_MISC_LOCAL_CTL) & TI_MLC_EE_DIN;\n\tTI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);\n\n\treturn(ack);\n}"
  }
]