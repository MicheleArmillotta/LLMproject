[
  {
    "function_name": "raster_textn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_text.c",
    "lines": "78-224",
    "snippet": "int\nraster_textn( r, x, y, rop, rf, text, n )\n    register struct raster* r;\n    int x, y;\n    int rop;\n    struct raster_font* rf;\n    unsigned char* text;\n    int n;\n    {\n    int clip;\n    int x1, y1;\n    struct raster_char* c;\n    struct raster* charrast;\n    int i;\n    register unsigned char ch;\n    int thisx, thisy;\n    int phase;\n\n    /* Check whether we can avoid clipping. */\n    clip = 0;\n    if ( rf->flags & RASFONT_FIXEDWIDTH &&\n\t rf->flags & RASFONT_NOVERTICALMOVEMENT )\n\t{\n\t/* This font is well-behaved, we can compute the extent cheaply. */\n\tc = &(rf->chars['@']);\n\tcharrast = c->r;\n\tif ( x + c->homex < 0 || y + c->homey < 0 ||\n\t     x + c->homex + n * c->nextx > r->width ||\n\t     y + c->homey + charrast->height > r->height )\n\t    clip = 1;\n\t}\n    else\n\t{\n\t/* Got to step through the string to compute the extent. */\n\tfor ( i = 0, x1 = x, y1 = y;\n\t      i < n;\n\t      ++i, x1 += c->nextx, y1 += c->nexty )\n\t    {\n\t    c = &(rf->chars[text[i]]);\n\t    charrast = c->r;\n\t    if ( charrast != (struct raster*) 0 )\n\t\t{\n\t\tif ( x1 + c->homex < 0 || y1 + c->homey < 0 ||\n\t\t     x1 + c->homex + charrast->width > r->width ||\n\t\t     y1 + c->homey + charrast->height > r->height )\n\t\t    {\n\t\t    clip = 1;\n\t\t    break;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n    /* Now display the text. */\n    for ( i = 0, x1 = x, y1 = y;\n\t  i < n;\n\t  ++i, x1 += c->nextx, y1 += c->nexty )\n\t{\n\tch = text[i];\n\tc = &(rf->chars[ch]);\n\tcharrast = c->r;\n\tif ( charrast != (struct raster*) 0 )\n\t    {\n\t    thisx = x1 + c->homex;\n\t    thisy = y1 + c->homey;\n\n\t    phase = 0;\n#ifdef COLORFONT_CACHE\n\t    if ( r->depth == 8 )\n\t\t{\n\t\t/* Initialize color font cache if necessary. */\n\t\tif ( rf->cache == (struct raster_fontcache*) -1 )\n\t\t    {\n\t\t    int c;\n\n\t\t    rf->cache = (struct raster_fontcache*)\n\t\t\tNEW( sizeof(struct raster_fontcache) );\n\t\t    if ( rf->cache != (struct raster_fontcache*) 0 )\n\t\t\tfor ( c = 0; c < 256; ++c )\n\t\t\t    rf->cache->cr[c] = (struct raster*) 0;\n\t\t    }\n\n\t\tif ( rf->cache != (struct raster_fontcache*) 0 )\n\t\t    {\n\t\t    int color;\n\t\t    struct raster* cr;\n\n\t\t    color = RAS_GETCOLOR( rop );\n\t\t    cr = rf->cache->cr[ch];\n\t\t    /* Is this character cached yet? */\n\t\t    if ( cr != (struct raster*) 0 )\n\t\t\t{\n\t\t\t/* Yes, but is it the right color? */\n\t\t\tif ( rf->cache->color[ch] == color )\n\t\t\t    {\n\t\t\t    /* Yes - switch rasters. */\n\t\t\t    charrast = cr;\n\t\t\t    }\n\t\t\telse\n\t\t\t    {\n\t\t\t    /* No, re-draw it. */\n\t\t\t    if ( raster_op_noclip(\n\t\t\t\t cr, 0, 0, charrast->width,\n\t\t\t\t charrast->height, rop, charrast, 0, 0 ) == 0 )\n\t\t\t\t{\n\t\t\t\trf->cache->color[ch] = color;\n\t\t\t\tcharrast = cr;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    else\n\t\t\t{\n\t\t\t/* It's not cached, so cache it. */\n\t\t\tcr = raster_alloc(\n\t\t\t    charrast->width, charrast->height, 8 );\n\t\t\tif ( cr != (struct raster*) 0 )\n\t\t\t    if ( raster_op_noclip(\n\t\t\t\t cr, 0, 0, charrast->width, charrast->height,\n\t\t\t\t rop, charrast, 0, 0 ) == 0 )\n\t\t\t\t{\n\t\t\t\trf->cache->color[ch] = color;\n\t\t\t\tcharrast = rf->cache->cr[ch] = cr;\n\t\t\t\t}\n\t\t\t}\n\t\t    }\n\t\t}\n#endif /*COLORFONT_CACHE*/\n\n\t    if ( clip )\n\t\t{\n\t\tif ( raster_op(\n\t\t\t r, thisx, thisy, charrast->width, charrast->height,\n\t\t\t rop, charrast, phase, 0 ) < 0 )\n\t\t    return -1;\n\t\t}\n\t    else\n\t\t{\n\t\tif ( raster_op_noclip(\n\t\t\t r, thisx, thisy, charrast->width, charrast->height,\n\t\t\t rop, charrast, phase, 0 ) < 0 )\n\t\t    return -1;\n\t\t}\n\t    }\n\t}\n\n    return 0;\n    }",
    "includes": [
      "#include <malloc.h>",
      "#include \"raster.h\"",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include <sys/malloc.h>",
      "#include <dev/rcons/raster.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raster_op_noclip",
          "args": [
            "r",
            "thisx",
            "thisy",
            "charrast->width",
            "charrast->height",
            "rop",
            "charrast",
            "phase",
            "0"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "raster_op_noclip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "595-754",
          "snippet": "int\nraster_op_noclip( dst, dx, dy, w, h, rop, src, sx, sy )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    struct raster* src;\n    int sx, sy;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( src->depth == 1 )\n\t{\n\t/* One-bit to ? blit. */\n\tif ( dst->depth == 1 )\n\t    {\n\t    /* One to one blit. */\n\t    u_int32_t* srclin1;\n\t    u_int32_t* dstlin1;\n\t    int srcleftignore, srcrightignore, srclongs;\n\t    int dstleftignore, dstrightignore, dstlongs;\n\n\t    srclin1 = RAS_ADDR( src, sx, sy );\n\t    dstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t    /* Special-case full-width to full-width copies. */\n\t    if ( op == RAS_SRC && src->width == w && dst->width == w &&\n\t\t src->linelongs == dst->linelongs && src->linelongs == w >> 5 )\n\t\t{\n\t\tbcopy(\n\t\t    (char*) srclin1, (char*) dstlin1,\n\t\t    h * src->linelongs * sizeof(u_int32_t) );\n\t\treturn 0;\n\t\t}\n#endif /*BCOPY_FASTER*/\n\n\t    srcleftignore = ( sx & 31 );\n\t    srclongs = ( srcleftignore + w + 31 ) >> 5;\n\t    srcrightignore = ( srclongs * 32 - w - srcleftignore ) & 31;\n\t    dstleftignore = ( dx & 31 );\n\t    dstlongs = ( dstleftignore + w + 31 ) >> 5;\n\t    dstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\t    return raster_blit(\n\t\tsrc, srclin1, srcleftignore, srcrightignore, srclongs,\n\t\tdst, dstlin1, dstleftignore, dstrightignore, dstlongs, h, op );\n\t    }\n\n\telse\n\t    {\n\t    /* One to eight, using the color in the rop.  This could\n\t    ** probably be sped up by handling each four-bit source nybble\n\t    ** as a group, indexing into a 16-element runtime-constructed\n\t    ** table of longwords.\n\t    */\n\t    u_int32_t* srclin1;\n\t    u_int32_t* dstlin1;\n\t    u_int32_t* srclin2;\n\t    u_int32_t* srclin;\n\t    u_int32_t* dstlin;\n\t    register u_int32_t* srclong;\n\t    register u_int32_t* dstlong;\n\t    register u_int32_t color, dl;\n\t    register int srcbit, dstbyte, i;\n\n\t    color = RAS_GETCOLOR( rop );\n\t    if ( color == 0 )\n\t\tcolor = 255;\n\n\t    /* Make 32 bits of color so we can do the ROP without shifting. */\n\t    color |= ( color << 24 ) | ( color << 16 ) | ( color << 8 );\n\n\t    /* Don't have to worry about overlapping blits here. */\n\t    srclin1 = RAS_ADDR( src, sx, sy );\n\t    srclin2 = srclin1 + h * src->linelongs;\n\t    dstlin1 = RAS_ADDR( dst, dx, dy );\n\t    srclin = srclin1;\n\t    dstlin = dstlin1;\n\t    while ( srclin != srclin2 )\n\t\t{\n\t\tsrclong = srclin;\n\t\tsrcbit = sx & 31;\n\t\tdstlong = dstlin;\n\t\tdstbyte = dx & 3;\n\t\ti = w;\n\n\t\t/* WARNING: this code is KNOWN TO FAIL on Sun 3's / CG2's. */\n\t\tROP_SRCDSTCOLOR(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( i > 0 )\n\t\t\t    {\n\t\t\t    dl = *dstlong;,\n\t\t/*s*/       *srclong & raster_bitmask[srcbit],\n\t\t/*d*/       dl,\n\t\t/*c*/       color,\n\t\t/*pst*/     *dstlong = ( *dstlong & ~bytemask[dstbyte] ) |\n\t\t\t\t       ( dl & bytemask[dstbyte] );\n\t\t\t    if ( srcbit == 31 )\n\t\t\t\t{\n\t\t\t\tsrcbit = 0;\n\t\t\t\t++srclong;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t\t++srcbit;\n\t\t\t    if ( dstbyte == 3 )\n\t\t\t\t{\n\t\t\t\tdstbyte = 0;\n\t\t\t\t++dstlong;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t\t++dstbyte;\n\t\t\t    --i;\n\t\t\t    } )\n\n\t\tsrclin += src->linelongs;\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}\n\n    else\n\t{\n\t/* Eight to eight blit. */\n\tu_int32_t* srclin1;\n\tu_int32_t* dstlin1;\n\tint srcleftignore, srcrightignore, srclongs;\n\tint dstleftignore, dstrightignore, dstlongs;\n\n\tif ( dst->depth != 8 )\n\t    return -1;\t\t/* depth mismatch */\n\n\tsrclin1 = RAS_ADDR( src, sx, sy );\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width to full-width copies. */\n\tif ( op == RAS_SRC && src->width == w && dst->width == w &&\n\t     src->linelongs == dst->linelongs && src->linelongs == w >> 2 )\n\t    {\n\t    bcopy( (char*) srclin1, (char*) dstlin1,\n\t\t   h * src->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tsrcleftignore = ( sx & 3 ) * 8;\n\tsrclongs = ( srcleftignore + w * 8 + 31 ) >> 5;\n\tsrcrightignore = ( srclongs * 32 - w * 8 - srcleftignore ) & 31;\n\tdstleftignore = ( dx & 3 ) * 8;\n\tdstlongs = ( dstleftignore + w * 8 + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w * 8 - dstleftignore ) & 31;\n\n\treturn raster_blit(\n\t    src, srclin1, srcleftignore, srcrightignore, srclongs,\n\t    dst, dstlin1, dstleftignore, dstrightignore, dstlongs, h, op );\n\t}\n\n    return 0;\n    }",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int raster_blit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nstatic int raster_blit;\n\nint\nraster_op_noclip( dst, dx, dy, w, h, rop, src, sx, sy )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    struct raster* src;\n    int sx, sy;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( src->depth == 1 )\n\t{\n\t/* One-bit to ? blit. */\n\tif ( dst->depth == 1 )\n\t    {\n\t    /* One to one blit. */\n\t    u_int32_t* srclin1;\n\t    u_int32_t* dstlin1;\n\t    int srcleftignore, srcrightignore, srclongs;\n\t    int dstleftignore, dstrightignore, dstlongs;\n\n\t    srclin1 = RAS_ADDR( src, sx, sy );\n\t    dstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t    /* Special-case full-width to full-width copies. */\n\t    if ( op == RAS_SRC && src->width == w && dst->width == w &&\n\t\t src->linelongs == dst->linelongs && src->linelongs == w >> 5 )\n\t\t{\n\t\tbcopy(\n\t\t    (char*) srclin1, (char*) dstlin1,\n\t\t    h * src->linelongs * sizeof(u_int32_t) );\n\t\treturn 0;\n\t\t}\n#endif /*BCOPY_FASTER*/\n\n\t    srcleftignore = ( sx & 31 );\n\t    srclongs = ( srcleftignore + w + 31 ) >> 5;\n\t    srcrightignore = ( srclongs * 32 - w - srcleftignore ) & 31;\n\t    dstleftignore = ( dx & 31 );\n\t    dstlongs = ( dstleftignore + w + 31 ) >> 5;\n\t    dstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\t    return raster_blit(\n\t\tsrc, srclin1, srcleftignore, srcrightignore, srclongs,\n\t\tdst, dstlin1, dstleftignore, dstrightignore, dstlongs, h, op );\n\t    }\n\n\telse\n\t    {\n\t    /* One to eight, using the color in the rop.  This could\n\t    ** probably be sped up by handling each four-bit source nybble\n\t    ** as a group, indexing into a 16-element runtime-constructed\n\t    ** table of longwords.\n\t    */\n\t    u_int32_t* srclin1;\n\t    u_int32_t* dstlin1;\n\t    u_int32_t* srclin2;\n\t    u_int32_t* srclin;\n\t    u_int32_t* dstlin;\n\t    register u_int32_t* srclong;\n\t    register u_int32_t* dstlong;\n\t    register u_int32_t color, dl;\n\t    register int srcbit, dstbyte, i;\n\n\t    color = RAS_GETCOLOR( rop );\n\t    if ( color == 0 )\n\t\tcolor = 255;\n\n\t    /* Make 32 bits of color so we can do the ROP without shifting. */\n\t    color |= ( color << 24 ) | ( color << 16 ) | ( color << 8 );\n\n\t    /* Don't have to worry about overlapping blits here. */\n\t    srclin1 = RAS_ADDR( src, sx, sy );\n\t    srclin2 = srclin1 + h * src->linelongs;\n\t    dstlin1 = RAS_ADDR( dst, dx, dy );\n\t    srclin = srclin1;\n\t    dstlin = dstlin1;\n\t    while ( srclin != srclin2 )\n\t\t{\n\t\tsrclong = srclin;\n\t\tsrcbit = sx & 31;\n\t\tdstlong = dstlin;\n\t\tdstbyte = dx & 3;\n\t\ti = w;\n\n\t\t/* WARNING: this code is KNOWN TO FAIL on Sun 3's / CG2's. */\n\t\tROP_SRCDSTCOLOR(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( i > 0 )\n\t\t\t    {\n\t\t\t    dl = *dstlong;,\n\t\t/*s*/       *srclong & raster_bitmask[srcbit],\n\t\t/*d*/       dl,\n\t\t/*c*/       color,\n\t\t/*pst*/     *dstlong = ( *dstlong & ~bytemask[dstbyte] ) |\n\t\t\t\t       ( dl & bytemask[dstbyte] );\n\t\t\t    if ( srcbit == 31 )\n\t\t\t\t{\n\t\t\t\tsrcbit = 0;\n\t\t\t\t++srclong;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t\t++srcbit;\n\t\t\t    if ( dstbyte == 3 )\n\t\t\t\t{\n\t\t\t\tdstbyte = 0;\n\t\t\t\t++dstlong;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t\t++dstbyte;\n\t\t\t    --i;\n\t\t\t    } )\n\n\t\tsrclin += src->linelongs;\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}\n\n    else\n\t{\n\t/* Eight to eight blit. */\n\tu_int32_t* srclin1;\n\tu_int32_t* dstlin1;\n\tint srcleftignore, srcrightignore, srclongs;\n\tint dstleftignore, dstrightignore, dstlongs;\n\n\tif ( dst->depth != 8 )\n\t    return -1;\t\t/* depth mismatch */\n\n\tsrclin1 = RAS_ADDR( src, sx, sy );\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width to full-width copies. */\n\tif ( op == RAS_SRC && src->width == w && dst->width == w &&\n\t     src->linelongs == dst->linelongs && src->linelongs == w >> 2 )\n\t    {\n\t    bcopy( (char*) srclin1, (char*) dstlin1,\n\t\t   h * src->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tsrcleftignore = ( sx & 3 ) * 8;\n\tsrclongs = ( srcleftignore + w * 8 + 31 ) >> 5;\n\tsrcrightignore = ( srclongs * 32 - w * 8 - srcleftignore ) & 31;\n\tdstleftignore = ( dx & 3 ) * 8;\n\tdstlongs = ( dstleftignore + w * 8 + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w * 8 - dstleftignore ) & 31;\n\n\treturn raster_blit(\n\t    src, srclin1, srcleftignore, srcrightignore, srclongs,\n\t    dst, dstlin1, dstleftignore, dstrightignore, dstlongs, h, op );\n\t}\n\n    return 0;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "raster_op",
          "args": [
            "r",
            "thisx",
            "thisy",
            "charrast->width",
            "charrast->height",
            "rop",
            "charrast",
            "phase",
            "0"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "raster_op_nosrc_noclip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "759-860",
          "snippet": "int\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nint\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "raster_alloc",
          "args": [
            "charrast->width",
            "charrast->height",
            "8"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAS_GETCOLOR",
          "args": [
            "rop"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW",
          "args": [
            "sizeof(struct raster_fontcache)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <malloc.h>\n#include \"raster.h\"\n#include <string.h>\n#include <sys/types.h>\n#include <sys/malloc.h>\n#include <dev/rcons/raster.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nraster_textn( r, x, y, rop, rf, text, n )\n    register struct raster* r;\n    int x, y;\n    int rop;\n    struct raster_font* rf;\n    unsigned char* text;\n    int n;\n    {\n    int clip;\n    int x1, y1;\n    struct raster_char* c;\n    struct raster* charrast;\n    int i;\n    register unsigned char ch;\n    int thisx, thisy;\n    int phase;\n\n    /* Check whether we can avoid clipping. */\n    clip = 0;\n    if ( rf->flags & RASFONT_FIXEDWIDTH &&\n\t rf->flags & RASFONT_NOVERTICALMOVEMENT )\n\t{\n\t/* This font is well-behaved, we can compute the extent cheaply. */\n\tc = &(rf->chars['@']);\n\tcharrast = c->r;\n\tif ( x + c->homex < 0 || y + c->homey < 0 ||\n\t     x + c->homex + n * c->nextx > r->width ||\n\t     y + c->homey + charrast->height > r->height )\n\t    clip = 1;\n\t}\n    else\n\t{\n\t/* Got to step through the string to compute the extent. */\n\tfor ( i = 0, x1 = x, y1 = y;\n\t      i < n;\n\t      ++i, x1 += c->nextx, y1 += c->nexty )\n\t    {\n\t    c = &(rf->chars[text[i]]);\n\t    charrast = c->r;\n\t    if ( charrast != (struct raster*) 0 )\n\t\t{\n\t\tif ( x1 + c->homex < 0 || y1 + c->homey < 0 ||\n\t\t     x1 + c->homex + charrast->width > r->width ||\n\t\t     y1 + c->homey + charrast->height > r->height )\n\t\t    {\n\t\t    clip = 1;\n\t\t    break;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n    /* Now display the text. */\n    for ( i = 0, x1 = x, y1 = y;\n\t  i < n;\n\t  ++i, x1 += c->nextx, y1 += c->nexty )\n\t{\n\tch = text[i];\n\tc = &(rf->chars[ch]);\n\tcharrast = c->r;\n\tif ( charrast != (struct raster*) 0 )\n\t    {\n\t    thisx = x1 + c->homex;\n\t    thisy = y1 + c->homey;\n\n\t    phase = 0;\n#ifdef COLORFONT_CACHE\n\t    if ( r->depth == 8 )\n\t\t{\n\t\t/* Initialize color font cache if necessary. */\n\t\tif ( rf->cache == (struct raster_fontcache*) -1 )\n\t\t    {\n\t\t    int c;\n\n\t\t    rf->cache = (struct raster_fontcache*)\n\t\t\tNEW( sizeof(struct raster_fontcache) );\n\t\t    if ( rf->cache != (struct raster_fontcache*) 0 )\n\t\t\tfor ( c = 0; c < 256; ++c )\n\t\t\t    rf->cache->cr[c] = (struct raster*) 0;\n\t\t    }\n\n\t\tif ( rf->cache != (struct raster_fontcache*) 0 )\n\t\t    {\n\t\t    int color;\n\t\t    struct raster* cr;\n\n\t\t    color = RAS_GETCOLOR( rop );\n\t\t    cr = rf->cache->cr[ch];\n\t\t    /* Is this character cached yet? */\n\t\t    if ( cr != (struct raster*) 0 )\n\t\t\t{\n\t\t\t/* Yes, but is it the right color? */\n\t\t\tif ( rf->cache->color[ch] == color )\n\t\t\t    {\n\t\t\t    /* Yes - switch rasters. */\n\t\t\t    charrast = cr;\n\t\t\t    }\n\t\t\telse\n\t\t\t    {\n\t\t\t    /* No, re-draw it. */\n\t\t\t    if ( raster_op_noclip(\n\t\t\t\t cr, 0, 0, charrast->width,\n\t\t\t\t charrast->height, rop, charrast, 0, 0 ) == 0 )\n\t\t\t\t{\n\t\t\t\trf->cache->color[ch] = color;\n\t\t\t\tcharrast = cr;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    else\n\t\t\t{\n\t\t\t/* It's not cached, so cache it. */\n\t\t\tcr = raster_alloc(\n\t\t\t    charrast->width, charrast->height, 8 );\n\t\t\tif ( cr != (struct raster*) 0 )\n\t\t\t    if ( raster_op_noclip(\n\t\t\t\t cr, 0, 0, charrast->width, charrast->height,\n\t\t\t\t rop, charrast, 0, 0 ) == 0 )\n\t\t\t\t{\n\t\t\t\trf->cache->color[ch] = color;\n\t\t\t\tcharrast = rf->cache->cr[ch] = cr;\n\t\t\t\t}\n\t\t\t}\n\t\t    }\n\t\t}\n#endif /*COLORFONT_CACHE*/\n\n\t    if ( clip )\n\t\t{\n\t\tif ( raster_op(\n\t\t\t r, thisx, thisy, charrast->width, charrast->height,\n\t\t\t rop, charrast, phase, 0 ) < 0 )\n\t\t    return -1;\n\t\t}\n\t    else\n\t\t{\n\t\tif ( raster_op_noclip(\n\t\t\t r, thisx, thisy, charrast->width, charrast->height,\n\t\t\t rop, charrast, phase, 0 ) < 0 )\n\t\t    return -1;\n\t\t}\n\t    }\n\t}\n\n    return 0;\n    }"
  },
  {
    "function_name": "raster_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_text.c",
    "lines": "66-75",
    "snippet": "int\nraster_text( r, x, y, rop, rf, text )\n    register struct raster* r;\n    int x, y;\n    int rop;\n    struct raster_font* rf;\n    unsigned char* text;\n    {\n    return raster_textn( r, x, y, rop, rf, text, strlen( text ) );\n    }",
    "includes": [
      "#include <malloc.h>",
      "#include \"raster.h\"",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include <sys/malloc.h>",
      "#include <dev/rcons/raster.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raster_textn",
          "args": [
            "r",
            "x",
            "y",
            "rop",
            "rf",
            "text",
            "strlen( text )"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "raster_textn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_text.c",
          "lines": "78-224",
          "snippet": "int\nraster_textn( r, x, y, rop, rf, text, n )\n    register struct raster* r;\n    int x, y;\n    int rop;\n    struct raster_font* rf;\n    unsigned char* text;\n    int n;\n    {\n    int clip;\n    int x1, y1;\n    struct raster_char* c;\n    struct raster* charrast;\n    int i;\n    register unsigned char ch;\n    int thisx, thisy;\n    int phase;\n\n    /* Check whether we can avoid clipping. */\n    clip = 0;\n    if ( rf->flags & RASFONT_FIXEDWIDTH &&\n\t rf->flags & RASFONT_NOVERTICALMOVEMENT )\n\t{\n\t/* This font is well-behaved, we can compute the extent cheaply. */\n\tc = &(rf->chars['@']);\n\tcharrast = c->r;\n\tif ( x + c->homex < 0 || y + c->homey < 0 ||\n\t     x + c->homex + n * c->nextx > r->width ||\n\t     y + c->homey + charrast->height > r->height )\n\t    clip = 1;\n\t}\n    else\n\t{\n\t/* Got to step through the string to compute the extent. */\n\tfor ( i = 0, x1 = x, y1 = y;\n\t      i < n;\n\t      ++i, x1 += c->nextx, y1 += c->nexty )\n\t    {\n\t    c = &(rf->chars[text[i]]);\n\t    charrast = c->r;\n\t    if ( charrast != (struct raster*) 0 )\n\t\t{\n\t\tif ( x1 + c->homex < 0 || y1 + c->homey < 0 ||\n\t\t     x1 + c->homex + charrast->width > r->width ||\n\t\t     y1 + c->homey + charrast->height > r->height )\n\t\t    {\n\t\t    clip = 1;\n\t\t    break;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n    /* Now display the text. */\n    for ( i = 0, x1 = x, y1 = y;\n\t  i < n;\n\t  ++i, x1 += c->nextx, y1 += c->nexty )\n\t{\n\tch = text[i];\n\tc = &(rf->chars[ch]);\n\tcharrast = c->r;\n\tif ( charrast != (struct raster*) 0 )\n\t    {\n\t    thisx = x1 + c->homex;\n\t    thisy = y1 + c->homey;\n\n\t    phase = 0;\n#ifdef COLORFONT_CACHE\n\t    if ( r->depth == 8 )\n\t\t{\n\t\t/* Initialize color font cache if necessary. */\n\t\tif ( rf->cache == (struct raster_fontcache*) -1 )\n\t\t    {\n\t\t    int c;\n\n\t\t    rf->cache = (struct raster_fontcache*)\n\t\t\tNEW( sizeof(struct raster_fontcache) );\n\t\t    if ( rf->cache != (struct raster_fontcache*) 0 )\n\t\t\tfor ( c = 0; c < 256; ++c )\n\t\t\t    rf->cache->cr[c] = (struct raster*) 0;\n\t\t    }\n\n\t\tif ( rf->cache != (struct raster_fontcache*) 0 )\n\t\t    {\n\t\t    int color;\n\t\t    struct raster* cr;\n\n\t\t    color = RAS_GETCOLOR( rop );\n\t\t    cr = rf->cache->cr[ch];\n\t\t    /* Is this character cached yet? */\n\t\t    if ( cr != (struct raster*) 0 )\n\t\t\t{\n\t\t\t/* Yes, but is it the right color? */\n\t\t\tif ( rf->cache->color[ch] == color )\n\t\t\t    {\n\t\t\t    /* Yes - switch rasters. */\n\t\t\t    charrast = cr;\n\t\t\t    }\n\t\t\telse\n\t\t\t    {\n\t\t\t    /* No, re-draw it. */\n\t\t\t    if ( raster_op_noclip(\n\t\t\t\t cr, 0, 0, charrast->width,\n\t\t\t\t charrast->height, rop, charrast, 0, 0 ) == 0 )\n\t\t\t\t{\n\t\t\t\trf->cache->color[ch] = color;\n\t\t\t\tcharrast = cr;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    else\n\t\t\t{\n\t\t\t/* It's not cached, so cache it. */\n\t\t\tcr = raster_alloc(\n\t\t\t    charrast->width, charrast->height, 8 );\n\t\t\tif ( cr != (struct raster*) 0 )\n\t\t\t    if ( raster_op_noclip(\n\t\t\t\t cr, 0, 0, charrast->width, charrast->height,\n\t\t\t\t rop, charrast, 0, 0 ) == 0 )\n\t\t\t\t{\n\t\t\t\trf->cache->color[ch] = color;\n\t\t\t\tcharrast = rf->cache->cr[ch] = cr;\n\t\t\t\t}\n\t\t\t}\n\t\t    }\n\t\t}\n#endif /*COLORFONT_CACHE*/\n\n\t    if ( clip )\n\t\t{\n\t\tif ( raster_op(\n\t\t\t r, thisx, thisy, charrast->width, charrast->height,\n\t\t\t rop, charrast, phase, 0 ) < 0 )\n\t\t    return -1;\n\t\t}\n\t    else\n\t\t{\n\t\tif ( raster_op_noclip(\n\t\t\t r, thisx, thisy, charrast->width, charrast->height,\n\t\t\t rop, charrast, phase, 0 ) < 0 )\n\t\t    return -1;\n\t\t}\n\t    }\n\t}\n\n    return 0;\n    }",
          "includes": [
            "#include <malloc.h>",
            "#include \"raster.h\"",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include <sys/malloc.h>",
            "#include <dev/rcons/raster.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include \"raster.h\"\n#include <string.h>\n#include <sys/types.h>\n#include <sys/malloc.h>\n#include <dev/rcons/raster.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nraster_textn( r, x, y, rop, rf, text, n )\n    register struct raster* r;\n    int x, y;\n    int rop;\n    struct raster_font* rf;\n    unsigned char* text;\n    int n;\n    {\n    int clip;\n    int x1, y1;\n    struct raster_char* c;\n    struct raster* charrast;\n    int i;\n    register unsigned char ch;\n    int thisx, thisy;\n    int phase;\n\n    /* Check whether we can avoid clipping. */\n    clip = 0;\n    if ( rf->flags & RASFONT_FIXEDWIDTH &&\n\t rf->flags & RASFONT_NOVERTICALMOVEMENT )\n\t{\n\t/* This font is well-behaved, we can compute the extent cheaply. */\n\tc = &(rf->chars['@']);\n\tcharrast = c->r;\n\tif ( x + c->homex < 0 || y + c->homey < 0 ||\n\t     x + c->homex + n * c->nextx > r->width ||\n\t     y + c->homey + charrast->height > r->height )\n\t    clip = 1;\n\t}\n    else\n\t{\n\t/* Got to step through the string to compute the extent. */\n\tfor ( i = 0, x1 = x, y1 = y;\n\t      i < n;\n\t      ++i, x1 += c->nextx, y1 += c->nexty )\n\t    {\n\t    c = &(rf->chars[text[i]]);\n\t    charrast = c->r;\n\t    if ( charrast != (struct raster*) 0 )\n\t\t{\n\t\tif ( x1 + c->homex < 0 || y1 + c->homey < 0 ||\n\t\t     x1 + c->homex + charrast->width > r->width ||\n\t\t     y1 + c->homey + charrast->height > r->height )\n\t\t    {\n\t\t    clip = 1;\n\t\t    break;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n    /* Now display the text. */\n    for ( i = 0, x1 = x, y1 = y;\n\t  i < n;\n\t  ++i, x1 += c->nextx, y1 += c->nexty )\n\t{\n\tch = text[i];\n\tc = &(rf->chars[ch]);\n\tcharrast = c->r;\n\tif ( charrast != (struct raster*) 0 )\n\t    {\n\t    thisx = x1 + c->homex;\n\t    thisy = y1 + c->homey;\n\n\t    phase = 0;\n#ifdef COLORFONT_CACHE\n\t    if ( r->depth == 8 )\n\t\t{\n\t\t/* Initialize color font cache if necessary. */\n\t\tif ( rf->cache == (struct raster_fontcache*) -1 )\n\t\t    {\n\t\t    int c;\n\n\t\t    rf->cache = (struct raster_fontcache*)\n\t\t\tNEW( sizeof(struct raster_fontcache) );\n\t\t    if ( rf->cache != (struct raster_fontcache*) 0 )\n\t\t\tfor ( c = 0; c < 256; ++c )\n\t\t\t    rf->cache->cr[c] = (struct raster*) 0;\n\t\t    }\n\n\t\tif ( rf->cache != (struct raster_fontcache*) 0 )\n\t\t    {\n\t\t    int color;\n\t\t    struct raster* cr;\n\n\t\t    color = RAS_GETCOLOR( rop );\n\t\t    cr = rf->cache->cr[ch];\n\t\t    /* Is this character cached yet? */\n\t\t    if ( cr != (struct raster*) 0 )\n\t\t\t{\n\t\t\t/* Yes, but is it the right color? */\n\t\t\tif ( rf->cache->color[ch] == color )\n\t\t\t    {\n\t\t\t    /* Yes - switch rasters. */\n\t\t\t    charrast = cr;\n\t\t\t    }\n\t\t\telse\n\t\t\t    {\n\t\t\t    /* No, re-draw it. */\n\t\t\t    if ( raster_op_noclip(\n\t\t\t\t cr, 0, 0, charrast->width,\n\t\t\t\t charrast->height, rop, charrast, 0, 0 ) == 0 )\n\t\t\t\t{\n\t\t\t\trf->cache->color[ch] = color;\n\t\t\t\tcharrast = cr;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    else\n\t\t\t{\n\t\t\t/* It's not cached, so cache it. */\n\t\t\tcr = raster_alloc(\n\t\t\t    charrast->width, charrast->height, 8 );\n\t\t\tif ( cr != (struct raster*) 0 )\n\t\t\t    if ( raster_op_noclip(\n\t\t\t\t cr, 0, 0, charrast->width, charrast->height,\n\t\t\t\t rop, charrast, 0, 0 ) == 0 )\n\t\t\t\t{\n\t\t\t\trf->cache->color[ch] = color;\n\t\t\t\tcharrast = rf->cache->cr[ch] = cr;\n\t\t\t\t}\n\t\t\t}\n\t\t    }\n\t\t}\n#endif /*COLORFONT_CACHE*/\n\n\t    if ( clip )\n\t\t{\n\t\tif ( raster_op(\n\t\t\t r, thisx, thisy, charrast->width, charrast->height,\n\t\t\t rop, charrast, phase, 0 ) < 0 )\n\t\t    return -1;\n\t\t}\n\t    else\n\t\t{\n\t\tif ( raster_op_noclip(\n\t\t\t r, thisx, thisy, charrast->width, charrast->height,\n\t\t\t rop, charrast, phase, 0 ) < 0 )\n\t\t    return -1;\n\t\t}\n\t    }\n\t}\n\n    return 0;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "text"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <malloc.h>\n#include \"raster.h\"\n#include <string.h>\n#include <sys/types.h>\n#include <sys/malloc.h>\n#include <dev/rcons/raster.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nraster_text( r, x, y, rop, rf, text )\n    register struct raster* r;\n    int x, y;\n    int rop;\n    struct raster_font* rf;\n    unsigned char* text;\n    {\n    return raster_textn( r, x, y, rop, rf, text, strlen( text ) );\n    }"
  }
]