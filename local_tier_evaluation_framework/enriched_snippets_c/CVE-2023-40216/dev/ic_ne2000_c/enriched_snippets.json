[
  {
    "function_name": "ne2000_writemem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ne2000.c",
    "lines": "717-770",
    "snippet": "void\nne2000_writemem(nict, nich, asict, asich, src, dst, len, useword)\n\tbus_space_tag_t nict;\n\tbus_space_handle_t nich;\n\tbus_space_tag_t asict;\n\tbus_space_handle_t asich;\n\tu_int8_t *src;\n\tint dst;\n\tsize_t len;\n\tint useword;\n{\n\tint maxwait = 100;\t/* about 120us */\n\n\t/* Select page 0 registers. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Reset remote DMA complete flag. */\n\tbus_space_write_1(nict, nich, ED_P0_ISR, ED_ISR_RDC);\n\n\t/* Set up DMA byte count. */\n\tbus_space_write_1(nict, nich, ED_P0_RBCR0, len);\n\tbus_space_write_1(nict, nich, ED_P0_RBCR1, len >> 8);\n\n\t/* Set up destination address in NIC mem. */\n\tbus_space_write_1(nict, nich, ED_P0_RSAR0, dst);\n\tbus_space_write_1(nict, nich, ED_P0_RSAR1, dst >> 8);\n\n\t/* Set remote DMA write. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (useword)\n#ifdef __NetBSD__\n\t\tbus_space_write_multi_stream_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    (u_int16_t *)src, len >> 1);\n#else\n\t\tbus_space_write_raw_multi_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    src, len);\n#endif\n\telse\n\t\tbus_space_write_multi_1(asict, asich, NE2000_ASIC_DATA,\n\t\t    src, len);\n\n\t/*\n\t * Wait for remote DMA to complete.  This is necessary because on the\n\t * transmit side, data is handled internally by the NIC in bursts, and\n\t * we can't start another remote DMA until this one completes.  Not\n\t * waiting causes really bad things to happen - like the NIC wedging\n\t * the bus.\n\t */\n\twhile (((bus_space_read_1(nict, nich, ED_P0_ISR) & ED_ISR_RDC) !=\n\t    ED_ISR_RDC) && --maxwait);\n}",
    "includes": [
      "#include <dev/ic/ne2000var.h>",
      "#include <dev/ic/ne2000reg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tbus_space_write_multi_stream_2\tbus_space_write_multi_2"
    ],
    "globals_used": [
      "void\tne2000_writemem"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_ISR"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_raw_multi_2",
          "args": [
            "asict",
            "asich",
            "NE2000_ASIC_DATA",
            "src",
            "len"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_multi_stream_2",
          "args": [
            "asict",
            "asich",
            "NE2000_ASIC_DATA",
            "(u_int16_t *)src",
            "len >> 1"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_CR",
            "ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_RSAR1",
            "dst >> 8"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_RSAR0",
            "dst"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_RBCR1",
            "len >> 8"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_RBCR0",
            "len"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_ISR",
            "ED_ISR_RDC"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_CR",
            "ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ne2000var.h>\n#include <dev/ic/ne2000reg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tbus_space_write_multi_stream_2\tbus_space_write_multi_2\n\nvoid\tne2000_writemem;\n\nvoid\nne2000_writemem(nict, nich, asict, asich, src, dst, len, useword)\n\tbus_space_tag_t nict;\n\tbus_space_handle_t nich;\n\tbus_space_tag_t asict;\n\tbus_space_handle_t asich;\n\tu_int8_t *src;\n\tint dst;\n\tsize_t len;\n\tint useword;\n{\n\tint maxwait = 100;\t/* about 120us */\n\n\t/* Select page 0 registers. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Reset remote DMA complete flag. */\n\tbus_space_write_1(nict, nich, ED_P0_ISR, ED_ISR_RDC);\n\n\t/* Set up DMA byte count. */\n\tbus_space_write_1(nict, nich, ED_P0_RBCR0, len);\n\tbus_space_write_1(nict, nich, ED_P0_RBCR1, len >> 8);\n\n\t/* Set up destination address in NIC mem. */\n\tbus_space_write_1(nict, nich, ED_P0_RSAR0, dst);\n\tbus_space_write_1(nict, nich, ED_P0_RSAR1, dst >> 8);\n\n\t/* Set remote DMA write. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (useword)\n#ifdef __NetBSD__\n\t\tbus_space_write_multi_stream_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    (u_int16_t *)src, len >> 1);\n#else\n\t\tbus_space_write_raw_multi_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    src, len);\n#endif\n\telse\n\t\tbus_space_write_multi_1(asict, asich, NE2000_ASIC_DATA,\n\t\t    src, len);\n\n\t/*\n\t * Wait for remote DMA to complete.  This is necessary because on the\n\t * transmit side, data is handled internally by the NIC in bursts, and\n\t * we can't start another remote DMA until this one completes.  Not\n\t * waiting causes really bad things to happen - like the NIC wedging\n\t * the bus.\n\t */\n\twhile (((bus_space_read_1(nict, nich, ED_P0_ISR) & ED_ISR_RDC) !=\n\t    ED_ISR_RDC) && --maxwait);\n}"
  },
  {
    "function_name": "ne2000_readmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ne2000.c",
    "lines": "669-711",
    "snippet": "void\nne2000_readmem(nict, nich, asict, asich, src, dst, amount, useword)\n\tbus_space_tag_t nict;\n\tbus_space_handle_t nich;\n\tbus_space_tag_t asict;\n\tbus_space_handle_t asich;\n\tint src;\n\tu_int8_t *dst;\n\tsize_t amount;\n\tint useword;\n{\n\n\t/* Select page 0 registers. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Round up to a word. */\n\tif (amount & 1)\n\t\t++amount;\n\n\t/* Set up DMA byte count. */\n\tbus_space_write_1(nict, nich, ED_P0_RBCR0, amount);\n\tbus_space_write_1(nict, nich, ED_P0_RBCR1, amount >> 8);\n\n\t/* Set up source address in NIC mem. */\n\tbus_space_write_1(nict, nich, ED_P0_RSAR0, src);\n\tbus_space_write_1(nict, nich, ED_P0_RSAR1, src >> 8);\n\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (useword)\n#ifdef __NetBSD__\n\t\tbus_space_read_multi_stream_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    (u_int16_t *)dst, amount >> 1);\n#else\n\t\tbus_space_read_raw_multi_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    dst, amount);\n#endif\n\telse\n\t\tbus_space_read_multi_1(asict, asich, NE2000_ASIC_DATA,\n\t\t    dst, amount);\n}",
    "includes": [
      "#include <dev/ic/ne2000var.h>",
      "#include <dev/ic/ne2000reg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tbus_space_read_multi_stream_2\tbus_space_read_multi_2"
    ],
    "globals_used": [
      "void\tne2000_readmem"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_raw_multi_2",
          "args": [
            "asict",
            "asich",
            "NE2000_ASIC_DATA",
            "dst",
            "amount"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_multi_stream_2",
          "args": [
            "asict",
            "asich",
            "NE2000_ASIC_DATA",
            "(u_int16_t *)dst",
            "amount >> 1"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_CR",
            "ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_RSAR1",
            "src >> 8"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_RSAR0",
            "src"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_RBCR1",
            "amount >> 8"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_RBCR0",
            "amount"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_CR",
            "ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ne2000var.h>\n#include <dev/ic/ne2000reg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tbus_space_read_multi_stream_2\tbus_space_read_multi_2\n\nvoid\tne2000_readmem;\n\nvoid\nne2000_readmem(nict, nich, asict, asich, src, dst, amount, useword)\n\tbus_space_tag_t nict;\n\tbus_space_handle_t nich;\n\tbus_space_tag_t asict;\n\tbus_space_handle_t asich;\n\tint src;\n\tu_int8_t *dst;\n\tsize_t amount;\n\tint useword;\n{\n\n\t/* Select page 0 registers. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Round up to a word. */\n\tif (amount & 1)\n\t\t++amount;\n\n\t/* Set up DMA byte count. */\n\tbus_space_write_1(nict, nich, ED_P0_RBCR0, amount);\n\tbus_space_write_1(nict, nich, ED_P0_RBCR1, amount >> 8);\n\n\t/* Set up source address in NIC mem. */\n\tbus_space_write_1(nict, nich, ED_P0_RSAR0, src);\n\tbus_space_write_1(nict, nich, ED_P0_RSAR1, src >> 8);\n\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (useword)\n#ifdef __NetBSD__\n\t\tbus_space_read_multi_stream_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    (u_int16_t *)dst, amount >> 1);\n#else\n\t\tbus_space_read_raw_multi_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    dst, amount);\n#endif\n\telse\n\t\tbus_space_read_multi_1(asict, asich, NE2000_ASIC_DATA,\n\t\t    dst, amount);\n}"
  },
  {
    "function_name": "ne2000_test_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ne2000.c",
    "lines": "655-662",
    "snippet": "int\nne2000_test_mem(sc)\n\tstruct dp8390_softc *sc;\n{\n\n\t/* Noop. */\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/ne2000var.h>",
      "#include <dev/ic/ne2000reg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tne2000_test_mem"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/ne2000var.h>\n#include <dev/ic/ne2000reg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tne2000_test_mem;\n\nint\nne2000_test_mem(sc)\n\tstruct dp8390_softc *sc;\n{\n\n\t/* Noop. */\n\treturn (0);\n}"
  },
  {
    "function_name": "ne2000_read_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ne2000.c",
    "lines": "639-653",
    "snippet": "void\nne2000_read_hdr(sc, buf, hdr)\n\tstruct dp8390_softc *sc;\n\tint buf;\n\tstruct dp8390_ring *hdr;\n{\n\tstruct ne2000_softc *nsc = (struct ne2000_softc *)sc;\n\n\tne2000_readmem(sc->sc_regt, sc->sc_regh, nsc->sc_asict, nsc->sc_asich,\n\t    buf, (u_int8_t *)hdr, sizeof(struct dp8390_ring),\n\t    (nsc->sc_type != NE2000_TYPE_NE1000));\n#if BYTE_ORDER == BIG_ENDIAN\n\thdr->count = swap16(hdr->count);\n#endif\n}",
    "includes": [
      "#include <dev/ic/ne2000var.h>",
      "#include <dev/ic/ne2000reg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tne2000_read_hdr",
      "void\tne2000_readmem"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap16",
          "args": [
            "hdr->count"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ne2000_readmem",
          "args": [
            "sc->sc_regt",
            "sc->sc_regh",
            "nsc->sc_asict",
            "nsc->sc_asich",
            "buf",
            "(u_int8_t *)hdr",
            "sizeof(struct dp8390_ring)",
            "(nsc->sc_type != NE2000_TYPE_NE1000)"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "ne2000_readmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ne2000.c",
          "lines": "669-711",
          "snippet": "void\nne2000_readmem(nict, nich, asict, asich, src, dst, amount, useword)\n\tbus_space_tag_t nict;\n\tbus_space_handle_t nich;\n\tbus_space_tag_t asict;\n\tbus_space_handle_t asich;\n\tint src;\n\tu_int8_t *dst;\n\tsize_t amount;\n\tint useword;\n{\n\n\t/* Select page 0 registers. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Round up to a word. */\n\tif (amount & 1)\n\t\t++amount;\n\n\t/* Set up DMA byte count. */\n\tbus_space_write_1(nict, nich, ED_P0_RBCR0, amount);\n\tbus_space_write_1(nict, nich, ED_P0_RBCR1, amount >> 8);\n\n\t/* Set up source address in NIC mem. */\n\tbus_space_write_1(nict, nich, ED_P0_RSAR0, src);\n\tbus_space_write_1(nict, nich, ED_P0_RSAR1, src >> 8);\n\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (useword)\n#ifdef __NetBSD__\n\t\tbus_space_read_multi_stream_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    (u_int16_t *)dst, amount >> 1);\n#else\n\t\tbus_space_read_raw_multi_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    dst, amount);\n#endif\n\telse\n\t\tbus_space_read_multi_1(asict, asich, NE2000_ASIC_DATA,\n\t\t    dst, amount);\n}",
          "includes": [
            "#include <dev/ic/ne2000var.h>",
            "#include <dev/ic/ne2000reg.h>",
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tbus_space_read_multi_stream_2\tbus_space_read_multi_2"
          ],
          "globals_used": [
            "void\tne2000_readmem"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ne2000var.h>\n#include <dev/ic/ne2000reg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tbus_space_read_multi_stream_2\tbus_space_read_multi_2\n\nvoid\tne2000_readmem;\n\nvoid\nne2000_readmem(nict, nich, asict, asich, src, dst, amount, useword)\n\tbus_space_tag_t nict;\n\tbus_space_handle_t nich;\n\tbus_space_tag_t asict;\n\tbus_space_handle_t asich;\n\tint src;\n\tu_int8_t *dst;\n\tsize_t amount;\n\tint useword;\n{\n\n\t/* Select page 0 registers. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Round up to a word. */\n\tif (amount & 1)\n\t\t++amount;\n\n\t/* Set up DMA byte count. */\n\tbus_space_write_1(nict, nich, ED_P0_RBCR0, amount);\n\tbus_space_write_1(nict, nich, ED_P0_RBCR1, amount >> 8);\n\n\t/* Set up source address in NIC mem. */\n\tbus_space_write_1(nict, nich, ED_P0_RSAR0, src);\n\tbus_space_write_1(nict, nich, ED_P0_RSAR1, src >> 8);\n\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (useword)\n#ifdef __NetBSD__\n\t\tbus_space_read_multi_stream_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    (u_int16_t *)dst, amount >> 1);\n#else\n\t\tbus_space_read_raw_multi_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    dst, amount);\n#endif\n\telse\n\t\tbus_space_read_multi_1(asict, asich, NE2000_ASIC_DATA,\n\t\t    dst, amount);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/ne2000var.h>\n#include <dev/ic/ne2000reg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tne2000_read_hdr;\nvoid\tne2000_readmem;\n\nvoid\nne2000_read_hdr(sc, buf, hdr)\n\tstruct dp8390_softc *sc;\n\tint buf;\n\tstruct dp8390_ring *hdr;\n{\n\tstruct ne2000_softc *nsc = (struct ne2000_softc *)sc;\n\n\tne2000_readmem(sc->sc_regt, sc->sc_regh, nsc->sc_asict, nsc->sc_asich,\n\t    buf, (u_int8_t *)hdr, sizeof(struct dp8390_ring),\n\t    (nsc->sc_type != NE2000_TYPE_NE1000));\n#if BYTE_ORDER == BIG_ENDIAN\n\thdr->count = swap16(hdr->count);\n#endif\n}"
  },
  {
    "function_name": "ne2000_ring_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ne2000.c",
    "lines": "605-637",
    "snippet": "int\nne2000_ring_copy(sc, src, dst, amount)\n\tstruct dp8390_softc *sc;\n\tint src;\n\tcaddr_t dst;\n\tu_short amount;\n{\n\tstruct ne2000_softc *nsc = (struct ne2000_softc *)sc;\n\tbus_space_tag_t nict = sc->sc_regt;\n\tbus_space_handle_t nich = sc->sc_regh;\n\tbus_space_tag_t asict = nsc->sc_asict;\n\tbus_space_handle_t asich = nsc->sc_asich;\n\tu_short tmp_amount;\n\tint useword = (nsc->sc_type != NE2000_TYPE_NE1000);\n\n\t/* Does copy wrap to lower addr in ring buffer? */\n\tif (src + amount > sc->mem_end) {\n\t\ttmp_amount = sc->mem_end - src;\n\n\t\t/* Copy amount up to end of NIC memory. */\n\t\tne2000_readmem(nict, nich, asict, asich, src,\n\t\t    (u_int8_t *)dst, tmp_amount, useword);\n\n\t\tamount -= tmp_amount;\n\t\tsrc = sc->mem_ring;\n\t\tdst += tmp_amount;\n\t}\n\n\tne2000_readmem(nict, nich, asict, asich, src, (u_int8_t *)dst,\n\t    amount, useword);\n\n\treturn (src + amount);\n}",
    "includes": [
      "#include <dev/ic/ne2000var.h>",
      "#include <dev/ic/ne2000reg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tne2000_ring_copy",
      "void\tne2000_readmem"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ne2000_readmem",
          "args": [
            "nict",
            "nich",
            "asict",
            "asich",
            "src",
            "(u_int8_t *)dst",
            "amount",
            "useword"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "ne2000_readmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ne2000.c",
          "lines": "669-711",
          "snippet": "void\nne2000_readmem(nict, nich, asict, asich, src, dst, amount, useword)\n\tbus_space_tag_t nict;\n\tbus_space_handle_t nich;\n\tbus_space_tag_t asict;\n\tbus_space_handle_t asich;\n\tint src;\n\tu_int8_t *dst;\n\tsize_t amount;\n\tint useword;\n{\n\n\t/* Select page 0 registers. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Round up to a word. */\n\tif (amount & 1)\n\t\t++amount;\n\n\t/* Set up DMA byte count. */\n\tbus_space_write_1(nict, nich, ED_P0_RBCR0, amount);\n\tbus_space_write_1(nict, nich, ED_P0_RBCR1, amount >> 8);\n\n\t/* Set up source address in NIC mem. */\n\tbus_space_write_1(nict, nich, ED_P0_RSAR0, src);\n\tbus_space_write_1(nict, nich, ED_P0_RSAR1, src >> 8);\n\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (useword)\n#ifdef __NetBSD__\n\t\tbus_space_read_multi_stream_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    (u_int16_t *)dst, amount >> 1);\n#else\n\t\tbus_space_read_raw_multi_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    dst, amount);\n#endif\n\telse\n\t\tbus_space_read_multi_1(asict, asich, NE2000_ASIC_DATA,\n\t\t    dst, amount);\n}",
          "includes": [
            "#include <dev/ic/ne2000var.h>",
            "#include <dev/ic/ne2000reg.h>",
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tbus_space_read_multi_stream_2\tbus_space_read_multi_2"
          ],
          "globals_used": [
            "void\tne2000_readmem"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ne2000var.h>\n#include <dev/ic/ne2000reg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tbus_space_read_multi_stream_2\tbus_space_read_multi_2\n\nvoid\tne2000_readmem;\n\nvoid\nne2000_readmem(nict, nich, asict, asich, src, dst, amount, useword)\n\tbus_space_tag_t nict;\n\tbus_space_handle_t nich;\n\tbus_space_tag_t asict;\n\tbus_space_handle_t asich;\n\tint src;\n\tu_int8_t *dst;\n\tsize_t amount;\n\tint useword;\n{\n\n\t/* Select page 0 registers. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Round up to a word. */\n\tif (amount & 1)\n\t\t++amount;\n\n\t/* Set up DMA byte count. */\n\tbus_space_write_1(nict, nich, ED_P0_RBCR0, amount);\n\tbus_space_write_1(nict, nich, ED_P0_RBCR1, amount >> 8);\n\n\t/* Set up source address in NIC mem. */\n\tbus_space_write_1(nict, nich, ED_P0_RSAR0, src);\n\tbus_space_write_1(nict, nich, ED_P0_RSAR1, src >> 8);\n\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (useword)\n#ifdef __NetBSD__\n\t\tbus_space_read_multi_stream_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    (u_int16_t *)dst, amount >> 1);\n#else\n\t\tbus_space_read_raw_multi_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    dst, amount);\n#endif\n\telse\n\t\tbus_space_read_multi_1(asict, asich, NE2000_ASIC_DATA,\n\t\t    dst, amount);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/ne2000var.h>\n#include <dev/ic/ne2000reg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tne2000_ring_copy;\nvoid\tne2000_readmem;\n\nint\nne2000_ring_copy(sc, src, dst, amount)\n\tstruct dp8390_softc *sc;\n\tint src;\n\tcaddr_t dst;\n\tu_short amount;\n{\n\tstruct ne2000_softc *nsc = (struct ne2000_softc *)sc;\n\tbus_space_tag_t nict = sc->sc_regt;\n\tbus_space_handle_t nich = sc->sc_regh;\n\tbus_space_tag_t asict = nsc->sc_asict;\n\tbus_space_handle_t asich = nsc->sc_asich;\n\tu_short tmp_amount;\n\tint useword = (nsc->sc_type != NE2000_TYPE_NE1000);\n\n\t/* Does copy wrap to lower addr in ring buffer? */\n\tif (src + amount > sc->mem_end) {\n\t\ttmp_amount = sc->mem_end - src;\n\n\t\t/* Copy amount up to end of NIC memory. */\n\t\tne2000_readmem(nict, nich, asict, asich, src,\n\t\t    (u_int8_t *)dst, tmp_amount, useword);\n\n\t\tamount -= tmp_amount;\n\t\tsrc = sc->mem_ring;\n\t\tdst += tmp_amount;\n\t}\n\n\tne2000_readmem(nict, nich, asict, asich, src, (u_int8_t *)dst,\n\t    amount, useword);\n\n\treturn (src + amount);\n}"
  },
  {
    "function_name": "ne2000_write_mbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ne2000.c",
    "lines": "435-598",
    "snippet": "int\nne2000_write_mbuf(sc, m, buf)\n\tstruct dp8390_softc *sc;\n\tstruct mbuf *m;\n\tint buf;\n{\n\tstruct ne2000_softc *nsc = (struct ne2000_softc *)sc;\n\tbus_space_tag_t nict = sc->sc_regt;\n\tbus_space_handle_t nich = sc->sc_regh;\n\tbus_space_tag_t asict = nsc->sc_asict;\n\tbus_space_handle_t asich = nsc->sc_asich;\n\tint savelen;\n\tint maxwait = 100;\t/* about 120us */\n\n\tsavelen = m->m_pkthdr.len;\n\n\t/* Select page 0 registers. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Reset remote DMA complete flag. */\n\tbus_space_write_1(nict, nich, ED_P0_ISR, ED_ISR_RDC);\n\n\t/* Set up DMA byte count. */\n\tbus_space_write_1(nict, nich, ED_P0_RBCR0, savelen);\n\tbus_space_write_1(nict, nich, ED_P0_RBCR1, savelen >> 8);\n\n\t/* Set up destination address in NIC mem. */\n\tbus_space_write_1(nict, nich, ED_P0_RSAR0, buf);\n\tbus_space_write_1(nict, nich, ED_P0_RSAR1, buf >> 8);\n\n\t/* Set remote DMA write. */\n\tbus_space_write_1(nict, nich,\n\t    ED_P0_CR, ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/*\n\t * Transfer the mbuf chain to the NIC memory.  NE2000 cards\n\t * require that data be transferred as words, and only words,\n\t * so that case requires some extra code to patch over odd-length\n\t * mbufs.\n\t */\n\tif (nsc->sc_type == NE2000_TYPE_NE1000) {\n\t\t/* NE1000s are easy. */\n\t\tfor (; m != 0; m = m->m_next) {\n\t\t\tif (m->m_len) {\n\t\t\t\tbus_space_write_multi_1(asict, asich,\n\t\t\t\t    NE2000_ASIC_DATA, mtod(m, u_int8_t *),\n\t\t\t\t    m->m_len);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* NE2000s are a bit trickier. */\n\t\tu_int8_t *data, savebyte[2];\n\t\tint l, leftover;\n#ifdef DIAGNOSTIC\n\t\tu_int8_t *lim;\n#endif\n\t\t/* Start out with no leftover data. */\n\t\tleftover = 0;\n\t\tsavebyte[0] = savebyte[1] = 0;\n\n\t\tfor (; m != 0; m = m->m_next) {\n\t\t\tl = m->m_len;\n\t\t\tif (l == 0)\n\t\t\t\tcontinue;\n\t\t\tdata = mtod(m, u_int8_t *);\n#ifdef DIAGNOSTIC\n\t\t\tlim = data + l;\n#endif\n\t\t\twhile (l > 0) {\n\t\t\t\tif (leftover) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Data left over (from mbuf or\n\t\t\t\t\t * realignment).  Buffer the next\n\t\t\t\t\t * byte, and write it and the\n\t\t\t\t\t * leftover data out.\n\t\t\t\t\t */\n\t\t\t\t\tsavebyte[1] = *data++;\n\t\t\t\t\tl--;\n#ifdef __NetBSD__\n\t\t\t\t\tbus_space_write_stream_2(asict, asich,\n\t\t\t\t\t    NE2000_ASIC_DATA,\n\t\t\t\t\t    *(u_int16_t *)savebyte);\n#else\n\t\t\t\t\tbus_space_write_raw_multi_2(asict,\n\t\t\t\t\t    asich, NE2000_ASIC_DATA,\n\t\t\t\t\t    savebyte, 2);\n#endif\n\t\t\t\t\tleftover = 0;\n#ifdef i386\n#define ALIGNED_POINTER(p,t)\t1\n#endif\n#ifdef alpha\n#define ALIGNED_POINTER(p,t)\t((((u_long)(p)) & (sizeof(t)-1)) == 0)\n#endif\n\t\t\t\t} else if (ALIGNED_POINTER(data,\n\t\t\t\t\t   u_int16_t) == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Unaligned data; buffer the next\n\t\t\t\t\t * byte.\n\t\t\t\t\t */\n\t\t\t\t\tsavebyte[0] = *data++;\n\t\t\t\t\tl--;\n\t\t\t\t\tleftover = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Aligned data; output contiguous\n\t\t\t\t\t * words as much as we can, then\n\t\t\t\t\t * buffer the remaining byte, if any.\n\t\t\t\t\t */\n\t\t\t\t\tleftover = l & 1;\n\t\t\t\t\tl &= ~1;\n#ifdef __NetBSD__\n\t\t\t\t\tbus_space_write_multi_stream_2(asict,\n\t\t\t\t\t    asich, NE2000_ASIC_DATA,\n\t\t\t\t\t    (u_int16_t *)data, l >> 1);\n#else\n\t\t\t\t\tbus_space_write_raw_multi_2(asict,\n\t\t\t\t\t    asich, NE2000_ASIC_DATA, data, l);\n#endif\n\t\t\t\t\tdata += l;\n\t\t\t\t\tif (leftover)\n\t\t\t\t\t\tsavebyte[0] = *data++;\n\t\t\t\t\tl = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (l < 0)\n\t\t\t\tpanic(\"ne2000_write_mbuf: negative len\");\n#ifdef DIAGNOSTIC\n\t\t\tif (data != lim)\n\t\t\t\tpanic(\"ne2000_write_mbuf: data != lim\");\n#endif\n\t\t}\n\t\tif (leftover) {\n\t\t\tsavebyte[1] = 0;\n#ifdef __NetBSD__\n\t\t\tbus_space_write_stream_2(asict, asich, NE2000_ASIC_DATA,\n\t\t\t    *(u_int16_t *)savebyte);\n#else\n\t\t\tbus_space_write_raw_multi_2(asict, asich,\n\t\t\t    NE2000_ASIC_DATA, savebyte, 2);\n#endif\n\t\t}\n\t}\n\n\t/*\n\t * Wait for remote DMA to complete.  This is necessary because on the\n\t * transmit side, data is handled internally by the NIC in bursts, and\n\t * we can't start another remote DMA until this one completes.  Not\n\t * waiting causes really bad things to happen - like the NIC wedging\n\t * the bus.\n\t */\n\twhile (((bus_space_read_1(nict, nich, ED_P0_ISR) & ED_ISR_RDC) !=\n\t    ED_ISR_RDC) && --maxwait);\n\n\tif (maxwait == 0) {\n\t\tlog(LOG_WARNING,\n\t\t    \"%s: remote transmit DMA failed to complete\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tdp8390_reset(sc);\n\t}\n\n\treturn (savelen);\n}",
    "includes": [
      "#include <dev/ic/ne2000var.h>",
      "#include <dev/ic/ne2000reg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tbus_space_write_multi_stream_2\tbus_space_write_multi_2",
      "#define\tbus_space_write_stream_2\tbus_space_write_2"
    ],
    "globals_used": [
      "int\tne2000_write_mbuf"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dp8390_reset",
          "args": [
            "sc"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "197-207",
          "snippet": "void\ndp8390_reset(sc)\n\tstruct dp8390_softc *sc;\n{\n\tint     s;\n\n\ts = splnet();\n\tdp8390_stop(sc);\n\tdp8390_init(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_reset(sc)\n\tstruct dp8390_softc *sc;\n{\n\tint     s;\n\n\ts = splnet();\n\tdp8390_stop(sc);\n\tdp8390_init(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_WARNING",
            "\"%s: remote transmit DMA failed to complete\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_ISR"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_raw_multi_2",
          "args": [
            "asict",
            "asich",
            "NE2000_ASIC_DATA",
            "savebyte",
            "2"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_stream_2",
          "args": [
            "asict",
            "asich",
            "NE2000_ASIC_DATA",
            "*(u_int16_t *)savebyte"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ne2000_write_mbuf: data != lim\""
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ne2000_write_mbuf: negative len\""
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_raw_multi_2",
          "args": [
            "asict",
            "asich",
            "NE2000_ASIC_DATA",
            "data",
            "l"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_multi_stream_2",
          "args": [
            "asict",
            "asich",
            "NE2000_ASIC_DATA",
            "(u_int16_t *)data",
            "l >> 1"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGNED_POINTER",
          "args": [
            "data",
            "u_int16_t"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_raw_multi_2",
          "args": [
            "asict",
            "asich",
            "NE2000_ASIC_DATA",
            "savebyte",
            "2"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_stream_2",
          "args": [
            "asict",
            "asich",
            "NE2000_ASIC_DATA",
            "*(u_int16_t *)savebyte"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int8_t*"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_multi_1",
          "args": [
            "asict",
            "asich",
            "NE2000_ASIC_DATA",
            "mtod(m, u_int8_t *)",
            "m->m_len"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int8_t*"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_CR",
            "ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_RSAR1",
            "buf >> 8"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_RSAR0",
            "buf"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_RBCR1",
            "savelen >> 8"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_RBCR0",
            "savelen"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_ISR",
            "ED_ISR_RDC"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_CR",
            "ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ne2000var.h>\n#include <dev/ic/ne2000reg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tbus_space_write_multi_stream_2\tbus_space_write_multi_2\n#define\tbus_space_write_stream_2\tbus_space_write_2\n\nint\tne2000_write_mbuf;\n\nint\nne2000_write_mbuf(sc, m, buf)\n\tstruct dp8390_softc *sc;\n\tstruct mbuf *m;\n\tint buf;\n{\n\tstruct ne2000_softc *nsc = (struct ne2000_softc *)sc;\n\tbus_space_tag_t nict = sc->sc_regt;\n\tbus_space_handle_t nich = sc->sc_regh;\n\tbus_space_tag_t asict = nsc->sc_asict;\n\tbus_space_handle_t asich = nsc->sc_asich;\n\tint savelen;\n\tint maxwait = 100;\t/* about 120us */\n\n\tsavelen = m->m_pkthdr.len;\n\n\t/* Select page 0 registers. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Reset remote DMA complete flag. */\n\tbus_space_write_1(nict, nich, ED_P0_ISR, ED_ISR_RDC);\n\n\t/* Set up DMA byte count. */\n\tbus_space_write_1(nict, nich, ED_P0_RBCR0, savelen);\n\tbus_space_write_1(nict, nich, ED_P0_RBCR1, savelen >> 8);\n\n\t/* Set up destination address in NIC mem. */\n\tbus_space_write_1(nict, nich, ED_P0_RSAR0, buf);\n\tbus_space_write_1(nict, nich, ED_P0_RSAR1, buf >> 8);\n\n\t/* Set remote DMA write. */\n\tbus_space_write_1(nict, nich,\n\t    ED_P0_CR, ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/*\n\t * Transfer the mbuf chain to the NIC memory.  NE2000 cards\n\t * require that data be transferred as words, and only words,\n\t * so that case requires some extra code to patch over odd-length\n\t * mbufs.\n\t */\n\tif (nsc->sc_type == NE2000_TYPE_NE1000) {\n\t\t/* NE1000s are easy. */\n\t\tfor (; m != 0; m = m->m_next) {\n\t\t\tif (m->m_len) {\n\t\t\t\tbus_space_write_multi_1(asict, asich,\n\t\t\t\t    NE2000_ASIC_DATA, mtod(m, u_int8_t *),\n\t\t\t\t    m->m_len);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* NE2000s are a bit trickier. */\n\t\tu_int8_t *data, savebyte[2];\n\t\tint l, leftover;\n#ifdef DIAGNOSTIC\n\t\tu_int8_t *lim;\n#endif\n\t\t/* Start out with no leftover data. */\n\t\tleftover = 0;\n\t\tsavebyte[0] = savebyte[1] = 0;\n\n\t\tfor (; m != 0; m = m->m_next) {\n\t\t\tl = m->m_len;\n\t\t\tif (l == 0)\n\t\t\t\tcontinue;\n\t\t\tdata = mtod(m, u_int8_t *);\n#ifdef DIAGNOSTIC\n\t\t\tlim = data + l;\n#endif\n\t\t\twhile (l > 0) {\n\t\t\t\tif (leftover) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Data left over (from mbuf or\n\t\t\t\t\t * realignment).  Buffer the next\n\t\t\t\t\t * byte, and write it and the\n\t\t\t\t\t * leftover data out.\n\t\t\t\t\t */\n\t\t\t\t\tsavebyte[1] = *data++;\n\t\t\t\t\tl--;\n#ifdef __NetBSD__\n\t\t\t\t\tbus_space_write_stream_2(asict, asich,\n\t\t\t\t\t    NE2000_ASIC_DATA,\n\t\t\t\t\t    *(u_int16_t *)savebyte);\n#else\n\t\t\t\t\tbus_space_write_raw_multi_2(asict,\n\t\t\t\t\t    asich, NE2000_ASIC_DATA,\n\t\t\t\t\t    savebyte, 2);\n#endif\n\t\t\t\t\tleftover = 0;\n#ifdef i386\n#define ALIGNED_POINTER(p,t)\t1\n#endif\n#ifdef alpha\n#define ALIGNED_POINTER(p,t)\t((((u_long)(p)) & (sizeof(t)-1)) == 0)\n#endif\n\t\t\t\t} else if (ALIGNED_POINTER(data,\n\t\t\t\t\t   u_int16_t) == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Unaligned data; buffer the next\n\t\t\t\t\t * byte.\n\t\t\t\t\t */\n\t\t\t\t\tsavebyte[0] = *data++;\n\t\t\t\t\tl--;\n\t\t\t\t\tleftover = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Aligned data; output contiguous\n\t\t\t\t\t * words as much as we can, then\n\t\t\t\t\t * buffer the remaining byte, if any.\n\t\t\t\t\t */\n\t\t\t\t\tleftover = l & 1;\n\t\t\t\t\tl &= ~1;\n#ifdef __NetBSD__\n\t\t\t\t\tbus_space_write_multi_stream_2(asict,\n\t\t\t\t\t    asich, NE2000_ASIC_DATA,\n\t\t\t\t\t    (u_int16_t *)data, l >> 1);\n#else\n\t\t\t\t\tbus_space_write_raw_multi_2(asict,\n\t\t\t\t\t    asich, NE2000_ASIC_DATA, data, l);\n#endif\n\t\t\t\t\tdata += l;\n\t\t\t\t\tif (leftover)\n\t\t\t\t\t\tsavebyte[0] = *data++;\n\t\t\t\t\tl = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (l < 0)\n\t\t\t\tpanic(\"ne2000_write_mbuf: negative len\");\n#ifdef DIAGNOSTIC\n\t\t\tif (data != lim)\n\t\t\t\tpanic(\"ne2000_write_mbuf: data != lim\");\n#endif\n\t\t}\n\t\tif (leftover) {\n\t\t\tsavebyte[1] = 0;\n#ifdef __NetBSD__\n\t\t\tbus_space_write_stream_2(asict, asich, NE2000_ASIC_DATA,\n\t\t\t    *(u_int16_t *)savebyte);\n#else\n\t\t\tbus_space_write_raw_multi_2(asict, asich,\n\t\t\t    NE2000_ASIC_DATA, savebyte, 2);\n#endif\n\t\t}\n\t}\n\n\t/*\n\t * Wait for remote DMA to complete.  This is necessary because on the\n\t * transmit side, data is handled internally by the NIC in bursts, and\n\t * we can't start another remote DMA until this one completes.  Not\n\t * waiting causes really bad things to happen - like the NIC wedging\n\t * the bus.\n\t */\n\twhile (((bus_space_read_1(nict, nich, ED_P0_ISR) & ED_ISR_RDC) !=\n\t    ED_ISR_RDC) && --maxwait);\n\n\tif (maxwait == 0) {\n\t\tlog(LOG_WARNING,\n\t\t    \"%s: remote transmit DMA failed to complete\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tdp8390_reset(sc);\n\t}\n\n\treturn (savelen);\n}"
  },
  {
    "function_name": "ne2000_detect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ne2000.c",
    "lines": "266-429",
    "snippet": "int\nne2000_detect(nsc)\n\tstruct ne2000_softc *nsc;\n{\n\tstruct dp8390_softc *dsc = &nsc->sc_dp8390;\n\tbus_space_tag_t nict = dsc->sc_regt;\n\tbus_space_handle_t nich = dsc->sc_regh;\n\tbus_space_tag_t asict = nsc->sc_asict;\n\tbus_space_handle_t asich = nsc->sc_asich;\n\tstatic u_int8_t test_pattern[32] = \"THIS is A memory TEST pattern\";\n\tu_int8_t test_buffer[32], tmp;\n\tint i, rv = 0;\n\n\t/* Reset the board. */\n#ifdef GWETHER\n\tbus_space_write_1(asict, asich, NE2000_ASIC_RESET, 0);\n\tdelay(200);\n#endif /* GWETHER */\n\ttmp = bus_space_read_1(asict, asich, NE2000_ASIC_RESET);\n\tdelay(10000);\n\n\t/*\n\t * I don't know if this is necessary; probably cruft leftover from\n\t * Clarkson packet driver code. Doesn't do a thing on the boards I've\n\t * tested. -DG [note that a outb(0x84, 0) seems to work here, and is\n\t * non-invasive...but some boards don't seem to reset and I don't have\n\t * complete documentation on what the 'right' thing to do is...so we do\n\t * the invasive thing for now.  Yuck.]\n\t */\n\tbus_space_write_1(asict, asich, NE2000_ASIC_RESET, tmp);\n\tdelay(5000);\n\n\t/*\n\t * This is needed because some NE clones apparently don't reset the\n\t * NIC properly (or the NIC chip doesn't reset fully on power-up).\n\t * XXX - this makes the probe invasive!  Done against my better\n\t * judgement.  -DLG\n\t */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tdelay(5000);\n\n\t/*\n\t * Generic probe routine for testing for the existance of a DS8390.\n\t * Must be performed  after the NIC has just been reset.  This\n\t * works by looking at certain register values that are guaranteed\n\t * to be initialized a certain way after power-up or reset.\n\t *\n\t * Specifically:\n\t *\n\t *\tRegister\t\treset bits\tset bits\n\t *\t--------\t\t----------\t--------\n\t *\tCR\t\t\tTXP, STA\tRD2, STP\n\t *\tISR\t\t\t\t\tRST\n\t *\tIMR\t\t\t<all>\n\t *\tDCR\t\t\t\t\tLAS\n\t *\tTCR\t\t\tLB1, LB0\n\t *\n\t * We only look at CR and ISR, however, since looking at the others\n\t * would require changing register pages, which would be intrusive\n\t * if this isn't an 8390.\n\t */\n\n\ttmp = bus_space_read_1(nict, nich, ED_P0_CR);\n\tif ((tmp & (ED_CR_RD2 | ED_CR_TXP | ED_CR_STA | ED_CR_STP)) !=\n\t    (ED_CR_RD2 | ED_CR_STP))\n\t\tgoto out;\n\n\ttmp = bus_space_read_1(nict, nich, ED_P0_ISR);\n\tif ((tmp & ED_ISR_RST) != ED_ISR_RST)\n\t\tgoto out;\n\n\tbus_space_write_1(nict, nich,\n\t    ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tfor (i = 0; i < 100; i++) {\n\t\tif ((bus_space_read_1(nict, nich, ED_P0_ISR) & ED_ISR_RST) ==\n\t\t    ED_ISR_RST) {\n\t\t\t/* Ack the reset bit. */\n\t\t\tbus_space_write_1(nict, nich, ED_P0_ISR, ED_ISR_RST);\n\t\t\tbreak;\n\t\t}\n\t\tdelay(100);\n\t}\n\n#if 0\n\t/* XXX */\n\tif (i == 100)\n\t\tgoto out;\n#endif\n\n\t/*\n\t * Test the ability to read and write to the NIC memory.  This has\n\t * the side effect of determining if this is an NE1000 or an NE2000.\n\t */\n\n\t/*\n\t * This prevents packets from being stored in the NIC memory when\n\t * the readmem routine turns on the start bit in the CR.\n\t */\n\tbus_space_write_1(nict, nich, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Temporarily initialize DCR for byte operations. */\n\tbus_space_write_1(nict, nich, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\n\tbus_space_write_1(nict, nich, ED_P0_PSTART, 8192 >> ED_PAGE_SHIFT);\n\tbus_space_write_1(nict, nich, ED_P0_PSTOP, 16384 >> ED_PAGE_SHIFT);\n\n\t/*\n\t * Write a test pattern in byte mode.  If this fails, then there\n\t * probably isn't any memory at 8k - which likely means that the\n\t * board is an NE2000.\n\t */\n\tne2000_writemem(nict, nich, asict, asich, test_pattern, 8192,\n\t    sizeof(test_pattern), 0);\n\tne2000_readmem(nict, nich, asict, asich, 8192, test_buffer,\n\t    sizeof(test_buffer), 0);\n\n\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern))) {\n\t\t/* not an NE1000 - try NE2000 */\n\t\tbus_space_write_1(nict, nich, ED_P0_DCR,\n\t\t    ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS);\n\t\tbus_space_write_1(nict, nich, ED_P0_PSTART,\n\t\t    16384 >> ED_PAGE_SHIFT);\n\t\tbus_space_write_1(nict, nich, ED_P0_PSTOP,\n\t\t    32768 >> ED_PAGE_SHIFT);\n\n\t\t/*\n\t\t * Write the test pattern in word mode.  If this also fails,\n\t\t * then we don't know what this board is.\n\t\t */\n\t\tne2000_writemem(nict, nich, asict, asich, test_pattern, 16384,\n\t\t    sizeof(test_pattern), 1);\n\t\tne2000_readmem(nict, nich, asict, asich, 16384, test_buffer,\n\t\t    sizeof(test_buffer), 1);\n\n\t\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern)))\n\t\t\tgoto out;\t/* not an NE2000 either */\n\n\t\trv = NE2000_TYPE_NE2000;\n\t} else {\n\t\ttmp = 0;\n\t\tfor (i = 4; i < 12; i++)\n\t\t\ttmp += bus_space_read_1(asict, asich, i);\n\n\t\tif (tmp == 0xff) {\n\t\t\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\t\t\tdsc->sc_arpcom.ac_enaddr[i] =\n\t\t\t\t\tbus_space_read_1(asict, asich, i + 4);\n\n\t\t\trv = NE2000_TYPE_DL10019;\n\t\t} else {\n\t\t\t/* We're an NE1000. */\n\t\t\trv = NE2000_TYPE_NE1000;\n\t\t}\n\t}\n\n\t/* Clear any pending interrupts that might have occurred above. */\n\tbus_space_write_1(nict, nich, ED_P0_ISR, 0xff);\n\n out:\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/ic/ne2000var.h>",
      "#include <dev/ic/ne2000reg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tne2000_writemem",
      "void\tne2000_readmem"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_ISR",
            "0xff"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "i + 4"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "i"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "test_pattern",
            "test_buffer",
            "sizeof(test_pattern)"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ne2000_readmem",
          "args": [
            "nict",
            "nich",
            "asict",
            "asich",
            "16384",
            "test_buffer",
            "sizeof(test_buffer)",
            "1"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "ne2000_readmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ne2000.c",
          "lines": "669-711",
          "snippet": "void\nne2000_readmem(nict, nich, asict, asich, src, dst, amount, useword)\n\tbus_space_tag_t nict;\n\tbus_space_handle_t nich;\n\tbus_space_tag_t asict;\n\tbus_space_handle_t asich;\n\tint src;\n\tu_int8_t *dst;\n\tsize_t amount;\n\tint useword;\n{\n\n\t/* Select page 0 registers. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Round up to a word. */\n\tif (amount & 1)\n\t\t++amount;\n\n\t/* Set up DMA byte count. */\n\tbus_space_write_1(nict, nich, ED_P0_RBCR0, amount);\n\tbus_space_write_1(nict, nich, ED_P0_RBCR1, amount >> 8);\n\n\t/* Set up source address in NIC mem. */\n\tbus_space_write_1(nict, nich, ED_P0_RSAR0, src);\n\tbus_space_write_1(nict, nich, ED_P0_RSAR1, src >> 8);\n\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (useword)\n#ifdef __NetBSD__\n\t\tbus_space_read_multi_stream_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    (u_int16_t *)dst, amount >> 1);\n#else\n\t\tbus_space_read_raw_multi_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    dst, amount);\n#endif\n\telse\n\t\tbus_space_read_multi_1(asict, asich, NE2000_ASIC_DATA,\n\t\t    dst, amount);\n}",
          "includes": [
            "#include <dev/ic/ne2000var.h>",
            "#include <dev/ic/ne2000reg.h>",
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tbus_space_read_multi_stream_2\tbus_space_read_multi_2"
          ],
          "globals_used": [
            "void\tne2000_readmem"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ne2000var.h>\n#include <dev/ic/ne2000reg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tbus_space_read_multi_stream_2\tbus_space_read_multi_2\n\nvoid\tne2000_readmem;\n\nvoid\nne2000_readmem(nict, nich, asict, asich, src, dst, amount, useword)\n\tbus_space_tag_t nict;\n\tbus_space_handle_t nich;\n\tbus_space_tag_t asict;\n\tbus_space_handle_t asich;\n\tint src;\n\tu_int8_t *dst;\n\tsize_t amount;\n\tint useword;\n{\n\n\t/* Select page 0 registers. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Round up to a word. */\n\tif (amount & 1)\n\t\t++amount;\n\n\t/* Set up DMA byte count. */\n\tbus_space_write_1(nict, nich, ED_P0_RBCR0, amount);\n\tbus_space_write_1(nict, nich, ED_P0_RBCR1, amount >> 8);\n\n\t/* Set up source address in NIC mem. */\n\tbus_space_write_1(nict, nich, ED_P0_RSAR0, src);\n\tbus_space_write_1(nict, nich, ED_P0_RSAR1, src >> 8);\n\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (useword)\n#ifdef __NetBSD__\n\t\tbus_space_read_multi_stream_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    (u_int16_t *)dst, amount >> 1);\n#else\n\t\tbus_space_read_raw_multi_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    dst, amount);\n#endif\n\telse\n\t\tbus_space_read_multi_1(asict, asich, NE2000_ASIC_DATA,\n\t\t    dst, amount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ne2000_writemem",
          "args": [
            "nict",
            "nich",
            "asict",
            "asich",
            "test_pattern",
            "16384",
            "sizeof(test_pattern)",
            "1"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "ne2000_writemem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ne2000.c",
          "lines": "717-770",
          "snippet": "void\nne2000_writemem(nict, nich, asict, asich, src, dst, len, useword)\n\tbus_space_tag_t nict;\n\tbus_space_handle_t nich;\n\tbus_space_tag_t asict;\n\tbus_space_handle_t asich;\n\tu_int8_t *src;\n\tint dst;\n\tsize_t len;\n\tint useword;\n{\n\tint maxwait = 100;\t/* about 120us */\n\n\t/* Select page 0 registers. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Reset remote DMA complete flag. */\n\tbus_space_write_1(nict, nich, ED_P0_ISR, ED_ISR_RDC);\n\n\t/* Set up DMA byte count. */\n\tbus_space_write_1(nict, nich, ED_P0_RBCR0, len);\n\tbus_space_write_1(nict, nich, ED_P0_RBCR1, len >> 8);\n\n\t/* Set up destination address in NIC mem. */\n\tbus_space_write_1(nict, nich, ED_P0_RSAR0, dst);\n\tbus_space_write_1(nict, nich, ED_P0_RSAR1, dst >> 8);\n\n\t/* Set remote DMA write. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (useword)\n#ifdef __NetBSD__\n\t\tbus_space_write_multi_stream_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    (u_int16_t *)src, len >> 1);\n#else\n\t\tbus_space_write_raw_multi_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    src, len);\n#endif\n\telse\n\t\tbus_space_write_multi_1(asict, asich, NE2000_ASIC_DATA,\n\t\t    src, len);\n\n\t/*\n\t * Wait for remote DMA to complete.  This is necessary because on the\n\t * transmit side, data is handled internally by the NIC in bursts, and\n\t * we can't start another remote DMA until this one completes.  Not\n\t * waiting causes really bad things to happen - like the NIC wedging\n\t * the bus.\n\t */\n\twhile (((bus_space_read_1(nict, nich, ED_P0_ISR) & ED_ISR_RDC) !=\n\t    ED_ISR_RDC) && --maxwait);\n}",
          "includes": [
            "#include <dev/ic/ne2000var.h>",
            "#include <dev/ic/ne2000reg.h>",
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tbus_space_write_multi_stream_2\tbus_space_write_multi_2"
          ],
          "globals_used": [
            "void\tne2000_writemem"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ne2000var.h>\n#include <dev/ic/ne2000reg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tbus_space_write_multi_stream_2\tbus_space_write_multi_2\n\nvoid\tne2000_writemem;\n\nvoid\nne2000_writemem(nict, nich, asict, asich, src, dst, len, useword)\n\tbus_space_tag_t nict;\n\tbus_space_handle_t nich;\n\tbus_space_tag_t asict;\n\tbus_space_handle_t asich;\n\tu_int8_t *src;\n\tint dst;\n\tsize_t len;\n\tint useword;\n{\n\tint maxwait = 100;\t/* about 120us */\n\n\t/* Select page 0 registers. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Reset remote DMA complete flag. */\n\tbus_space_write_1(nict, nich, ED_P0_ISR, ED_ISR_RDC);\n\n\t/* Set up DMA byte count. */\n\tbus_space_write_1(nict, nich, ED_P0_RBCR0, len);\n\tbus_space_write_1(nict, nich, ED_P0_RBCR1, len >> 8);\n\n\t/* Set up destination address in NIC mem. */\n\tbus_space_write_1(nict, nich, ED_P0_RSAR0, dst);\n\tbus_space_write_1(nict, nich, ED_P0_RSAR1, dst >> 8);\n\n\t/* Set remote DMA write. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (useword)\n#ifdef __NetBSD__\n\t\tbus_space_write_multi_stream_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    (u_int16_t *)src, len >> 1);\n#else\n\t\tbus_space_write_raw_multi_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    src, len);\n#endif\n\telse\n\t\tbus_space_write_multi_1(asict, asich, NE2000_ASIC_DATA,\n\t\t    src, len);\n\n\t/*\n\t * Wait for remote DMA to complete.  This is necessary because on the\n\t * transmit side, data is handled internally by the NIC in bursts, and\n\t * we can't start another remote DMA until this one completes.  Not\n\t * waiting causes really bad things to happen - like the NIC wedging\n\t * the bus.\n\t */\n\twhile (((bus_space_read_1(nict, nich, ED_P0_ISR) & ED_ISR_RDC) !=\n\t    ED_ISR_RDC) && --maxwait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_PSTOP",
            "32768 >> ED_PAGE_SHIFT"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_PSTART",
            "16384 >> ED_PAGE_SHIFT"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_DCR",
            "ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "test_pattern",
            "test_buffer",
            "sizeof(test_pattern)"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_PSTOP",
            "16384 >> ED_PAGE_SHIFT"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_PSTART",
            "8192 >> ED_PAGE_SHIFT"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_DCR",
            "ED_DCR_FT1 | ED_DCR_LS"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_RCR",
            "ED_RCR_MON"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_ISR",
            "ED_ISR_RST"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_ISR"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_CR",
            "ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_ISR"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_CR"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_CR",
            "ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "NE2000_ASIC_RESET",
            "tmp"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "NE2000_ASIC_RESET"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "NE2000_ASIC_RESET",
            "0"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ne2000var.h>\n#include <dev/ic/ne2000reg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tne2000_writemem;\nvoid\tne2000_readmem;\n\nint\nne2000_detect(nsc)\n\tstruct ne2000_softc *nsc;\n{\n\tstruct dp8390_softc *dsc = &nsc->sc_dp8390;\n\tbus_space_tag_t nict = dsc->sc_regt;\n\tbus_space_handle_t nich = dsc->sc_regh;\n\tbus_space_tag_t asict = nsc->sc_asict;\n\tbus_space_handle_t asich = nsc->sc_asich;\n\tstatic u_int8_t test_pattern[32] = \"THIS is A memory TEST pattern\";\n\tu_int8_t test_buffer[32], tmp;\n\tint i, rv = 0;\n\n\t/* Reset the board. */\n#ifdef GWETHER\n\tbus_space_write_1(asict, asich, NE2000_ASIC_RESET, 0);\n\tdelay(200);\n#endif /* GWETHER */\n\ttmp = bus_space_read_1(asict, asich, NE2000_ASIC_RESET);\n\tdelay(10000);\n\n\t/*\n\t * I don't know if this is necessary; probably cruft leftover from\n\t * Clarkson packet driver code. Doesn't do a thing on the boards I've\n\t * tested. -DG [note that a outb(0x84, 0) seems to work here, and is\n\t * non-invasive...but some boards don't seem to reset and I don't have\n\t * complete documentation on what the 'right' thing to do is...so we do\n\t * the invasive thing for now.  Yuck.]\n\t */\n\tbus_space_write_1(asict, asich, NE2000_ASIC_RESET, tmp);\n\tdelay(5000);\n\n\t/*\n\t * This is needed because some NE clones apparently don't reset the\n\t * NIC properly (or the NIC chip doesn't reset fully on power-up).\n\t * XXX - this makes the probe invasive!  Done against my better\n\t * judgement.  -DLG\n\t */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tdelay(5000);\n\n\t/*\n\t * Generic probe routine for testing for the existance of a DS8390.\n\t * Must be performed  after the NIC has just been reset.  This\n\t * works by looking at certain register values that are guaranteed\n\t * to be initialized a certain way after power-up or reset.\n\t *\n\t * Specifically:\n\t *\n\t *\tRegister\t\treset bits\tset bits\n\t *\t--------\t\t----------\t--------\n\t *\tCR\t\t\tTXP, STA\tRD2, STP\n\t *\tISR\t\t\t\t\tRST\n\t *\tIMR\t\t\t<all>\n\t *\tDCR\t\t\t\t\tLAS\n\t *\tTCR\t\t\tLB1, LB0\n\t *\n\t * We only look at CR and ISR, however, since looking at the others\n\t * would require changing register pages, which would be intrusive\n\t * if this isn't an 8390.\n\t */\n\n\ttmp = bus_space_read_1(nict, nich, ED_P0_CR);\n\tif ((tmp & (ED_CR_RD2 | ED_CR_TXP | ED_CR_STA | ED_CR_STP)) !=\n\t    (ED_CR_RD2 | ED_CR_STP))\n\t\tgoto out;\n\n\ttmp = bus_space_read_1(nict, nich, ED_P0_ISR);\n\tif ((tmp & ED_ISR_RST) != ED_ISR_RST)\n\t\tgoto out;\n\n\tbus_space_write_1(nict, nich,\n\t    ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tfor (i = 0; i < 100; i++) {\n\t\tif ((bus_space_read_1(nict, nich, ED_P0_ISR) & ED_ISR_RST) ==\n\t\t    ED_ISR_RST) {\n\t\t\t/* Ack the reset bit. */\n\t\t\tbus_space_write_1(nict, nich, ED_P0_ISR, ED_ISR_RST);\n\t\t\tbreak;\n\t\t}\n\t\tdelay(100);\n\t}\n\n#if 0\n\t/* XXX */\n\tif (i == 100)\n\t\tgoto out;\n#endif\n\n\t/*\n\t * Test the ability to read and write to the NIC memory.  This has\n\t * the side effect of determining if this is an NE1000 or an NE2000.\n\t */\n\n\t/*\n\t * This prevents packets from being stored in the NIC memory when\n\t * the readmem routine turns on the start bit in the CR.\n\t */\n\tbus_space_write_1(nict, nich, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Temporarily initialize DCR for byte operations. */\n\tbus_space_write_1(nict, nich, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\n\tbus_space_write_1(nict, nich, ED_P0_PSTART, 8192 >> ED_PAGE_SHIFT);\n\tbus_space_write_1(nict, nich, ED_P0_PSTOP, 16384 >> ED_PAGE_SHIFT);\n\n\t/*\n\t * Write a test pattern in byte mode.  If this fails, then there\n\t * probably isn't any memory at 8k - which likely means that the\n\t * board is an NE2000.\n\t */\n\tne2000_writemem(nict, nich, asict, asich, test_pattern, 8192,\n\t    sizeof(test_pattern), 0);\n\tne2000_readmem(nict, nich, asict, asich, 8192, test_buffer,\n\t    sizeof(test_buffer), 0);\n\n\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern))) {\n\t\t/* not an NE1000 - try NE2000 */\n\t\tbus_space_write_1(nict, nich, ED_P0_DCR,\n\t\t    ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS);\n\t\tbus_space_write_1(nict, nich, ED_P0_PSTART,\n\t\t    16384 >> ED_PAGE_SHIFT);\n\t\tbus_space_write_1(nict, nich, ED_P0_PSTOP,\n\t\t    32768 >> ED_PAGE_SHIFT);\n\n\t\t/*\n\t\t * Write the test pattern in word mode.  If this also fails,\n\t\t * then we don't know what this board is.\n\t\t */\n\t\tne2000_writemem(nict, nich, asict, asich, test_pattern, 16384,\n\t\t    sizeof(test_pattern), 1);\n\t\tne2000_readmem(nict, nich, asict, asich, 16384, test_buffer,\n\t\t    sizeof(test_buffer), 1);\n\n\t\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern)))\n\t\t\tgoto out;\t/* not an NE2000 either */\n\n\t\trv = NE2000_TYPE_NE2000;\n\t} else {\n\t\ttmp = 0;\n\t\tfor (i = 4; i < 12; i++)\n\t\t\ttmp += bus_space_read_1(asict, asich, i);\n\n\t\tif (tmp == 0xff) {\n\t\t\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\t\t\tdsc->sc_arpcom.ac_enaddr[i] =\n\t\t\t\t\tbus_space_read_1(asict, asich, i + 4);\n\n\t\t\trv = NE2000_TYPE_DL10019;\n\t\t} else {\n\t\t\t/* We're an NE1000. */\n\t\t\trv = NE2000_TYPE_NE1000;\n\t\t}\n\t}\n\n\t/* Clear any pending interrupts that might have occurred above. */\n\tbus_space_write_1(nict, nich, ED_P0_ISR, 0xff);\n\n out:\n\treturn (rv);\n}"
  },
  {
    "function_name": "ne2000_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ne2000.c",
    "lines": "105-261",
    "snippet": "void\nne2000_attach(nsc, myea, media, nmedia, defmedia)\n\tstruct ne2000_softc *nsc;\n\tu_int8_t *myea;\n\tint *media, nmedia, defmedia;\n{\n\tstruct dp8390_softc *dsc = &nsc->sc_dp8390;\n\tbus_space_tag_t nict = dsc->sc_regt;\n\tbus_space_handle_t nich = dsc->sc_regh;\n\tbus_space_tag_t asict = nsc->sc_asict;\n\tbus_space_handle_t asich = nsc->sc_asich;\n\tu_int8_t romdata[16];\n\tint memsize, i, useword;\n\n\t/*\n\t * Detect it again; this gives us the memory size.\n\t */\n\tnsc->sc_type = ne2000_detect(nsc);\n\tif (nsc->sc_type == 0) {\n\t\tprintf(\"%s: where did the card go?\\n\", dsc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tuseword = (nsc->sc_type != NE2000_TYPE_NE1000);\n\n\tdsc->cr_proto = ED_CR_RD2;\n\n\t/*\n\t * DCR gets:\n\t *\n\t *\tFIFO threshold to 8, No auto-init Remote DMA,\n\t *\tbyte order=80x86.\n\t *\n\t * NE1000 gets byte-wide DMA, NE2000 gets word-wide DMA.\n\t */\n\tdsc->dcr_reg = ED_DCR_FT1 | ED_DCR_LS |\n\t    (nsc->sc_type != NE2000_TYPE_NE1000 ? ED_DCR_WTS : 0);\n\n\tdsc->test_mem = ne2000_test_mem;\n\tdsc->ring_copy = ne2000_ring_copy;\n\tdsc->write_mbuf = ne2000_write_mbuf;\n\tdsc->read_hdr = ne2000_read_hdr;\n\n\t/* Registers are linear. */\n\tfor (i = 0; i < 16; i++)\n\t\tdsc->sc_reg_map[i] = i;\n\n\t/*\n\t * 8k of memory plus an additional 8k if an NE2000.\n\t */\n\tmemsize = 8192 + (nsc->sc_type != NE2000_TYPE_NE1000 ? 8192 : 0);\n\n\t/*\n\t * NIC memory doens't start at zero on an NE board.\n\t * The start address is tied to the bus width.\n\t * (It happens to be computed the same way as mem size.)\n\t */\n\tdsc->mem_start = memsize;\n\n#ifdef GWETHER\n\t{\n\t\tint x, mstart = 0;\n\t\tint8_t pbuf0[ED_PAGE_SIZE], pbuf[ED_PAGE_SIZE],\n\t\t    tbuf[ED_PAGE_SIZE];\n\n\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\tpbuf0[i] = 0;\n\n\t\t/* Search for the start of RAM. */\n\t\tfor (x = 1; x < 256; x++) {\n\t\t\tne2000_writemem(nict, nich, asict, asich, pbuf0,\n\t\t\t    x << ED_PAGE_SHIFT, ED_PAGE_SIZE, useword);\n\t\t\tne2000_readmem(nict, nich, asict, asich,\n\t\t\t    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE, useword);\n\t\t\tif (bcmp(pbuf0, tbuf, ED_PAGE_SIZE) == 0) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\tne2000_writemem(nict, nich, asict, asich,\n\t\t\t\t    pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE,\n\t\t\t\t    useword);\n\t\t\t\tne2000_readmem(nict, nich, asict, asich,\n\t\t\t\t    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE,\n\t\t\t\t    useword);\n\t\t\t\tif (bcmp(pbuf, tbuf, ED_PAGE_SIZE) == 0) {\n\t\t\t\t\tmstart = x << ED_PAGE_SHIFT;\n\t\t\t\t\tmemsize = ED_PAGE_SIZE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mstart == 0) {\n\t\t\tprintf(\"%s: cannot find start of RAM\\n\",\n\t\t\t    dsc->sc_dev.dv_xname);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Search for the end of RAM. */\n\t\tfor (++x; x < 256; x++) {\n\t\t\tne2000_writemem(nict, nich, asict, asich, pbuf0,\n\t\t\t    x << ED_PAGE_SHIFT, ED_PAGE_SIZE, useword);\n\t\t\tne2000_readmem(nict, nich, asict, asich,\n\t\t\t    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE, useword);\n\t\t\tif (bcmp(pbuf0, tbuf, ED_PAGE_SIZE) == 0) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\tne2000_writemem(nict, nich, asict, asich,\n\t\t\t\t    pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE,\n\t\t\t\t    useword);\n\t\t\t\tne2000_readmem(nict, nich, asict, asich,\n\t\t\t\t    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE,\n\t\t\t\t    useword);\n\t\t\t\tif (bcmp(pbuf, tbuf, ED_PAGE_SIZE) == 0)\n\t\t\t\t\tmemsize += ED_PAGE_SIZE;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\n\t\tprintf(\"%s: RAM start 0x%x, size %d\\n\",\n\t\t    dsc->sc_dev.dv_xname, mstart, memsize);\n\n\t\tdsc->mem_start = mstart;\n\t}\n#endif /* GWETHER */\n\n\tdsc->mem_size = memsize;\n\n\tif (myea == NULL && nsc->sc_type != NE2000_TYPE_DL10019) {\n\t\t/* Read the station address. */\n\t\tne2000_readmem(nict, nich, asict, asich, 0, romdata,\n\t\t    sizeof(romdata), useword);\n\t\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n#ifdef __NetBSD__\n\t\t\tdsc->sc_enaddr[i] = romdata[i * (useword ? 2 : 1)];\n#else\n\t\t\tdsc->sc_arpcom.ac_enaddr[i] =\n\t\t\t\tromdata[i * (useword ? 2 : 1)];\n#endif\n\t}\n\n\t/* Clear any pending interrupts that might have occurred above. */\n\tbus_space_write_1(nict, nich, ED_P0_ISR, 0xff);\n\n\tif (dp8390_config(dsc, media, nmedia, defmedia)) {\n\t\tprintf(\"%s: setup failed\\n\", dsc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/*\n\t * We need to compute mem_ring a bit differently; override the\n\t * value set up in dp8390_config().\n\t */\n\tdsc->mem_ring =\n\t    dsc->mem_start + ((dsc->txb_cnt * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n}",
    "includes": [
      "#include <dev/ic/ne2000var.h>",
      "#include <dev/ic/ne2000reg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tne2000_write_mbuf",
      "int\tne2000_ring_copy",
      "void\tne2000_read_hdr",
      "int\tne2000_test_mem",
      "void\tne2000_writemem",
      "void\tne2000_readmem"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: setup failed\\n\"",
            "dsc->sc_dev.dv_xname"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp8390_config",
          "args": [
            "dsc",
            "media",
            "nmedia",
            "defmedia"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "86-158",
          "snippet": "int\ndp8390_config(sc, media, nmedia, defmedia)\n\tstruct dp8390_softc *sc;\n\tint *media, nmedia, defmedia;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i, rv;\n\n\trv = 1;\n\n\tif (!sc->test_mem)\n\t\tsc->test_mem = dp8390_test_mem;\n\n\t/* Allocate one xmit buffer if < 16k, two buffers otherwise. */\n\tif ((sc->mem_size < 16384) ||\n\t    (sc->sc_flags & DP8390_NO_MULTI_BUFFERING))\n\t\tsc->txb_cnt = 1;\n\telse if (sc->mem_size < 8192 * 3)\n\t\tsc->txb_cnt = 2;\n\telse\n\t\tsc->txb_cnt = 3;\n\n\tsc->tx_page_start = sc->mem_start >> ED_PAGE_SHIFT;\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (sc->mem_size >> ED_PAGE_SHIFT);\n\tsc->mem_ring = sc->mem_start + (sc->rec_page_start << ED_PAGE_SHIFT);\n\tsc->mem_end = sc->mem_start + sc->mem_size;\n\n\t/* Now zero memory and verify that it is clear. */\n\tif ((*sc->test_mem)(sc))\n\t\tgoto out;\n\n\t/* Set interface to stopped condition (reset). */\n\tdp8390_stop(sc);\n\n\t/* Initialize ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = dp8390_start;\n\tifp->if_ioctl = dp8390_ioctl;\n\tif (!ifp->if_watchdog)\n\t\tifp->if_watchdog = dp8390_watchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\t/* Initialize media goo. */\n\tifmedia_init(&sc->sc_media, 0, dp8390_mediachange, dp8390_mediastatus);\n\tif (media != NULL) {\n\t\tfor (i = 0; i < nmedia; i++)\n\t\t\tifmedia_add(&sc->sc_media, media[i], 0, NULL);\n\t\tifmedia_set(&sc->sc_media, defmedia);\n\t} else {\n\t\tifmedia_add(&sc->sc_media, IFM_ETHER|IFM_MANUAL, 0, NULL);\n\t\tifmedia_set(&sc->sc_media, IFM_ETHER|IFM_MANUAL);\n\t}\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\tsizeof(struct ether_header));\n#endif\n\n\t/* Print additional info when attached. */\n\tprintf(\"%s: address %s\\n\", sc->sc_dev.dv_xname,\n\t    ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\trv = 0;\nout:\n\treturn (rv);\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\tdp8390_test_mem",
            "int\tdp8390_mediachange",
            "void\tdp8390_mediastatus",
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int\t\tdp8390_test_mem;\nint\tdp8390_mediachange;\nvoid\tdp8390_mediastatus;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nint\ndp8390_config(sc, media, nmedia, defmedia)\n\tstruct dp8390_softc *sc;\n\tint *media, nmedia, defmedia;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i, rv;\n\n\trv = 1;\n\n\tif (!sc->test_mem)\n\t\tsc->test_mem = dp8390_test_mem;\n\n\t/* Allocate one xmit buffer if < 16k, two buffers otherwise. */\n\tif ((sc->mem_size < 16384) ||\n\t    (sc->sc_flags & DP8390_NO_MULTI_BUFFERING))\n\t\tsc->txb_cnt = 1;\n\telse if (sc->mem_size < 8192 * 3)\n\t\tsc->txb_cnt = 2;\n\telse\n\t\tsc->txb_cnt = 3;\n\n\tsc->tx_page_start = sc->mem_start >> ED_PAGE_SHIFT;\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (sc->mem_size >> ED_PAGE_SHIFT);\n\tsc->mem_ring = sc->mem_start + (sc->rec_page_start << ED_PAGE_SHIFT);\n\tsc->mem_end = sc->mem_start + sc->mem_size;\n\n\t/* Now zero memory and verify that it is clear. */\n\tif ((*sc->test_mem)(sc))\n\t\tgoto out;\n\n\t/* Set interface to stopped condition (reset). */\n\tdp8390_stop(sc);\n\n\t/* Initialize ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = dp8390_start;\n\tifp->if_ioctl = dp8390_ioctl;\n\tif (!ifp->if_watchdog)\n\t\tifp->if_watchdog = dp8390_watchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\t/* Initialize media goo. */\n\tifmedia_init(&sc->sc_media, 0, dp8390_mediachange, dp8390_mediastatus);\n\tif (media != NULL) {\n\t\tfor (i = 0; i < nmedia; i++)\n\t\t\tifmedia_add(&sc->sc_media, media[i], 0, NULL);\n\t\tifmedia_set(&sc->sc_media, defmedia);\n\t} else {\n\t\tifmedia_add(&sc->sc_media, IFM_ETHER|IFM_MANUAL, 0, NULL);\n\t\tifmedia_set(&sc->sc_media, IFM_ETHER|IFM_MANUAL);\n\t}\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\tsizeof(struct ether_header));\n#endif\n\n\t/* Print additional info when attached. */\n\tprintf(\"%s: address %s\\n\", sc->sc_dev.dv_xname,\n\t    ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\trv = 0;\nout:\n\treturn (rv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_ISR",
            "0xff"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ne2000_readmem",
          "args": [
            "nict",
            "nich",
            "asict",
            "asich",
            "0",
            "romdata",
            "sizeof(romdata)",
            "useword"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "ne2000_readmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ne2000.c",
          "lines": "669-711",
          "snippet": "void\nne2000_readmem(nict, nich, asict, asich, src, dst, amount, useword)\n\tbus_space_tag_t nict;\n\tbus_space_handle_t nich;\n\tbus_space_tag_t asict;\n\tbus_space_handle_t asich;\n\tint src;\n\tu_int8_t *dst;\n\tsize_t amount;\n\tint useword;\n{\n\n\t/* Select page 0 registers. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Round up to a word. */\n\tif (amount & 1)\n\t\t++amount;\n\n\t/* Set up DMA byte count. */\n\tbus_space_write_1(nict, nich, ED_P0_RBCR0, amount);\n\tbus_space_write_1(nict, nich, ED_P0_RBCR1, amount >> 8);\n\n\t/* Set up source address in NIC mem. */\n\tbus_space_write_1(nict, nich, ED_P0_RSAR0, src);\n\tbus_space_write_1(nict, nich, ED_P0_RSAR1, src >> 8);\n\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (useword)\n#ifdef __NetBSD__\n\t\tbus_space_read_multi_stream_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    (u_int16_t *)dst, amount >> 1);\n#else\n\t\tbus_space_read_raw_multi_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    dst, amount);\n#endif\n\telse\n\t\tbus_space_read_multi_1(asict, asich, NE2000_ASIC_DATA,\n\t\t    dst, amount);\n}",
          "includes": [
            "#include <dev/ic/ne2000var.h>",
            "#include <dev/ic/ne2000reg.h>",
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tbus_space_read_multi_stream_2\tbus_space_read_multi_2"
          ],
          "globals_used": [
            "void\tne2000_readmem"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ne2000var.h>\n#include <dev/ic/ne2000reg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tbus_space_read_multi_stream_2\tbus_space_read_multi_2\n\nvoid\tne2000_readmem;\n\nvoid\nne2000_readmem(nict, nich, asict, asich, src, dst, amount, useword)\n\tbus_space_tag_t nict;\n\tbus_space_handle_t nich;\n\tbus_space_tag_t asict;\n\tbus_space_handle_t asich;\n\tint src;\n\tu_int8_t *dst;\n\tsize_t amount;\n\tint useword;\n{\n\n\t/* Select page 0 registers. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Round up to a word. */\n\tif (amount & 1)\n\t\t++amount;\n\n\t/* Set up DMA byte count. */\n\tbus_space_write_1(nict, nich, ED_P0_RBCR0, amount);\n\tbus_space_write_1(nict, nich, ED_P0_RBCR1, amount >> 8);\n\n\t/* Set up source address in NIC mem. */\n\tbus_space_write_1(nict, nich, ED_P0_RSAR0, src);\n\tbus_space_write_1(nict, nich, ED_P0_RSAR1, src >> 8);\n\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (useword)\n#ifdef __NetBSD__\n\t\tbus_space_read_multi_stream_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    (u_int16_t *)dst, amount >> 1);\n#else\n\t\tbus_space_read_raw_multi_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    dst, amount);\n#endif\n\telse\n\t\tbus_space_read_multi_1(asict, asich, NE2000_ASIC_DATA,\n\t\t    dst, amount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "pbuf",
            "tbuf",
            "ED_PAGE_SIZE"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ne2000_writemem",
          "args": [
            "nict",
            "nich",
            "asict",
            "asich",
            "pbuf",
            "x << ED_PAGE_SHIFT",
            "ED_PAGE_SIZE",
            "useword"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "ne2000_writemem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ne2000.c",
          "lines": "717-770",
          "snippet": "void\nne2000_writemem(nict, nich, asict, asich, src, dst, len, useword)\n\tbus_space_tag_t nict;\n\tbus_space_handle_t nich;\n\tbus_space_tag_t asict;\n\tbus_space_handle_t asich;\n\tu_int8_t *src;\n\tint dst;\n\tsize_t len;\n\tint useword;\n{\n\tint maxwait = 100;\t/* about 120us */\n\n\t/* Select page 0 registers. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Reset remote DMA complete flag. */\n\tbus_space_write_1(nict, nich, ED_P0_ISR, ED_ISR_RDC);\n\n\t/* Set up DMA byte count. */\n\tbus_space_write_1(nict, nich, ED_P0_RBCR0, len);\n\tbus_space_write_1(nict, nich, ED_P0_RBCR1, len >> 8);\n\n\t/* Set up destination address in NIC mem. */\n\tbus_space_write_1(nict, nich, ED_P0_RSAR0, dst);\n\tbus_space_write_1(nict, nich, ED_P0_RSAR1, dst >> 8);\n\n\t/* Set remote DMA write. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (useword)\n#ifdef __NetBSD__\n\t\tbus_space_write_multi_stream_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    (u_int16_t *)src, len >> 1);\n#else\n\t\tbus_space_write_raw_multi_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    src, len);\n#endif\n\telse\n\t\tbus_space_write_multi_1(asict, asich, NE2000_ASIC_DATA,\n\t\t    src, len);\n\n\t/*\n\t * Wait for remote DMA to complete.  This is necessary because on the\n\t * transmit side, data is handled internally by the NIC in bursts, and\n\t * we can't start another remote DMA until this one completes.  Not\n\t * waiting causes really bad things to happen - like the NIC wedging\n\t * the bus.\n\t */\n\twhile (((bus_space_read_1(nict, nich, ED_P0_ISR) & ED_ISR_RDC) !=\n\t    ED_ISR_RDC) && --maxwait);\n}",
          "includes": [
            "#include <dev/ic/ne2000var.h>",
            "#include <dev/ic/ne2000reg.h>",
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tbus_space_write_multi_stream_2\tbus_space_write_multi_2"
          ],
          "globals_used": [
            "void\tne2000_writemem"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ne2000var.h>\n#include <dev/ic/ne2000reg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tbus_space_write_multi_stream_2\tbus_space_write_multi_2\n\nvoid\tne2000_writemem;\n\nvoid\nne2000_writemem(nict, nich, asict, asich, src, dst, len, useword)\n\tbus_space_tag_t nict;\n\tbus_space_handle_t nich;\n\tbus_space_tag_t asict;\n\tbus_space_handle_t asich;\n\tu_int8_t *src;\n\tint dst;\n\tsize_t len;\n\tint useword;\n{\n\tint maxwait = 100;\t/* about 120us */\n\n\t/* Select page 0 registers. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Reset remote DMA complete flag. */\n\tbus_space_write_1(nict, nich, ED_P0_ISR, ED_ISR_RDC);\n\n\t/* Set up DMA byte count. */\n\tbus_space_write_1(nict, nich, ED_P0_RBCR0, len);\n\tbus_space_write_1(nict, nich, ED_P0_RBCR1, len >> 8);\n\n\t/* Set up destination address in NIC mem. */\n\tbus_space_write_1(nict, nich, ED_P0_RSAR0, dst);\n\tbus_space_write_1(nict, nich, ED_P0_RSAR1, dst >> 8);\n\n\t/* Set remote DMA write. */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (useword)\n#ifdef __NetBSD__\n\t\tbus_space_write_multi_stream_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    (u_int16_t *)src, len >> 1);\n#else\n\t\tbus_space_write_raw_multi_2(asict, asich, NE2000_ASIC_DATA,\n\t\t    src, len);\n#endif\n\telse\n\t\tbus_space_write_multi_1(asict, asich, NE2000_ASIC_DATA,\n\t\t    src, len);\n\n\t/*\n\t * Wait for remote DMA to complete.  This is necessary because on the\n\t * transmit side, data is handled internally by the NIC in bursts, and\n\t * we can't start another remote DMA until this one completes.  Not\n\t * waiting causes really bad things to happen - like the NIC wedging\n\t * the bus.\n\t */\n\twhile (((bus_space_read_1(nict, nich, ED_P0_ISR) & ED_ISR_RDC) !=\n\t    ED_ISR_RDC) && --maxwait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "pbuf0",
            "tbuf",
            "ED_PAGE_SIZE"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "pbuf",
            "tbuf",
            "ED_PAGE_SIZE"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "pbuf0",
            "tbuf",
            "ED_PAGE_SIZE"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ne2000_detect",
          "args": [
            "nsc"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "ne2000_detect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ne2000.c",
          "lines": "266-429",
          "snippet": "int\nne2000_detect(nsc)\n\tstruct ne2000_softc *nsc;\n{\n\tstruct dp8390_softc *dsc = &nsc->sc_dp8390;\n\tbus_space_tag_t nict = dsc->sc_regt;\n\tbus_space_handle_t nich = dsc->sc_regh;\n\tbus_space_tag_t asict = nsc->sc_asict;\n\tbus_space_handle_t asich = nsc->sc_asich;\n\tstatic u_int8_t test_pattern[32] = \"THIS is A memory TEST pattern\";\n\tu_int8_t test_buffer[32], tmp;\n\tint i, rv = 0;\n\n\t/* Reset the board. */\n#ifdef GWETHER\n\tbus_space_write_1(asict, asich, NE2000_ASIC_RESET, 0);\n\tdelay(200);\n#endif /* GWETHER */\n\ttmp = bus_space_read_1(asict, asich, NE2000_ASIC_RESET);\n\tdelay(10000);\n\n\t/*\n\t * I don't know if this is necessary; probably cruft leftover from\n\t * Clarkson packet driver code. Doesn't do a thing on the boards I've\n\t * tested. -DG [note that a outb(0x84, 0) seems to work here, and is\n\t * non-invasive...but some boards don't seem to reset and I don't have\n\t * complete documentation on what the 'right' thing to do is...so we do\n\t * the invasive thing for now.  Yuck.]\n\t */\n\tbus_space_write_1(asict, asich, NE2000_ASIC_RESET, tmp);\n\tdelay(5000);\n\n\t/*\n\t * This is needed because some NE clones apparently don't reset the\n\t * NIC properly (or the NIC chip doesn't reset fully on power-up).\n\t * XXX - this makes the probe invasive!  Done against my better\n\t * judgement.  -DLG\n\t */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tdelay(5000);\n\n\t/*\n\t * Generic probe routine for testing for the existance of a DS8390.\n\t * Must be performed  after the NIC has just been reset.  This\n\t * works by looking at certain register values that are guaranteed\n\t * to be initialized a certain way after power-up or reset.\n\t *\n\t * Specifically:\n\t *\n\t *\tRegister\t\treset bits\tset bits\n\t *\t--------\t\t----------\t--------\n\t *\tCR\t\t\tTXP, STA\tRD2, STP\n\t *\tISR\t\t\t\t\tRST\n\t *\tIMR\t\t\t<all>\n\t *\tDCR\t\t\t\t\tLAS\n\t *\tTCR\t\t\tLB1, LB0\n\t *\n\t * We only look at CR and ISR, however, since looking at the others\n\t * would require changing register pages, which would be intrusive\n\t * if this isn't an 8390.\n\t */\n\n\ttmp = bus_space_read_1(nict, nich, ED_P0_CR);\n\tif ((tmp & (ED_CR_RD2 | ED_CR_TXP | ED_CR_STA | ED_CR_STP)) !=\n\t    (ED_CR_RD2 | ED_CR_STP))\n\t\tgoto out;\n\n\ttmp = bus_space_read_1(nict, nich, ED_P0_ISR);\n\tif ((tmp & ED_ISR_RST) != ED_ISR_RST)\n\t\tgoto out;\n\n\tbus_space_write_1(nict, nich,\n\t    ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tfor (i = 0; i < 100; i++) {\n\t\tif ((bus_space_read_1(nict, nich, ED_P0_ISR) & ED_ISR_RST) ==\n\t\t    ED_ISR_RST) {\n\t\t\t/* Ack the reset bit. */\n\t\t\tbus_space_write_1(nict, nich, ED_P0_ISR, ED_ISR_RST);\n\t\t\tbreak;\n\t\t}\n\t\tdelay(100);\n\t}\n\n#if 0\n\t/* XXX */\n\tif (i == 100)\n\t\tgoto out;\n#endif\n\n\t/*\n\t * Test the ability to read and write to the NIC memory.  This has\n\t * the side effect of determining if this is an NE1000 or an NE2000.\n\t */\n\n\t/*\n\t * This prevents packets from being stored in the NIC memory when\n\t * the readmem routine turns on the start bit in the CR.\n\t */\n\tbus_space_write_1(nict, nich, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Temporarily initialize DCR for byte operations. */\n\tbus_space_write_1(nict, nich, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\n\tbus_space_write_1(nict, nich, ED_P0_PSTART, 8192 >> ED_PAGE_SHIFT);\n\tbus_space_write_1(nict, nich, ED_P0_PSTOP, 16384 >> ED_PAGE_SHIFT);\n\n\t/*\n\t * Write a test pattern in byte mode.  If this fails, then there\n\t * probably isn't any memory at 8k - which likely means that the\n\t * board is an NE2000.\n\t */\n\tne2000_writemem(nict, nich, asict, asich, test_pattern, 8192,\n\t    sizeof(test_pattern), 0);\n\tne2000_readmem(nict, nich, asict, asich, 8192, test_buffer,\n\t    sizeof(test_buffer), 0);\n\n\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern))) {\n\t\t/* not an NE1000 - try NE2000 */\n\t\tbus_space_write_1(nict, nich, ED_P0_DCR,\n\t\t    ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS);\n\t\tbus_space_write_1(nict, nich, ED_P0_PSTART,\n\t\t    16384 >> ED_PAGE_SHIFT);\n\t\tbus_space_write_1(nict, nich, ED_P0_PSTOP,\n\t\t    32768 >> ED_PAGE_SHIFT);\n\n\t\t/*\n\t\t * Write the test pattern in word mode.  If this also fails,\n\t\t * then we don't know what this board is.\n\t\t */\n\t\tne2000_writemem(nict, nich, asict, asich, test_pattern, 16384,\n\t\t    sizeof(test_pattern), 1);\n\t\tne2000_readmem(nict, nich, asict, asich, 16384, test_buffer,\n\t\t    sizeof(test_buffer), 1);\n\n\t\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern)))\n\t\t\tgoto out;\t/* not an NE2000 either */\n\n\t\trv = NE2000_TYPE_NE2000;\n\t} else {\n\t\ttmp = 0;\n\t\tfor (i = 4; i < 12; i++)\n\t\t\ttmp += bus_space_read_1(asict, asich, i);\n\n\t\tif (tmp == 0xff) {\n\t\t\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\t\t\tdsc->sc_arpcom.ac_enaddr[i] =\n\t\t\t\t\tbus_space_read_1(asict, asich, i + 4);\n\n\t\t\trv = NE2000_TYPE_DL10019;\n\t\t} else {\n\t\t\t/* We're an NE1000. */\n\t\t\trv = NE2000_TYPE_NE1000;\n\t\t}\n\t}\n\n\t/* Clear any pending interrupts that might have occurred above. */\n\tbus_space_write_1(nict, nich, ED_P0_ISR, 0xff);\n\n out:\n\treturn (rv);\n}",
          "includes": [
            "#include <dev/ic/ne2000var.h>",
            "#include <dev/ic/ne2000reg.h>",
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tne2000_writemem",
            "void\tne2000_readmem"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ne2000var.h>\n#include <dev/ic/ne2000reg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tne2000_writemem;\nvoid\tne2000_readmem;\n\nint\nne2000_detect(nsc)\n\tstruct ne2000_softc *nsc;\n{\n\tstruct dp8390_softc *dsc = &nsc->sc_dp8390;\n\tbus_space_tag_t nict = dsc->sc_regt;\n\tbus_space_handle_t nich = dsc->sc_regh;\n\tbus_space_tag_t asict = nsc->sc_asict;\n\tbus_space_handle_t asich = nsc->sc_asich;\n\tstatic u_int8_t test_pattern[32] = \"THIS is A memory TEST pattern\";\n\tu_int8_t test_buffer[32], tmp;\n\tint i, rv = 0;\n\n\t/* Reset the board. */\n#ifdef GWETHER\n\tbus_space_write_1(asict, asich, NE2000_ASIC_RESET, 0);\n\tdelay(200);\n#endif /* GWETHER */\n\ttmp = bus_space_read_1(asict, asich, NE2000_ASIC_RESET);\n\tdelay(10000);\n\n\t/*\n\t * I don't know if this is necessary; probably cruft leftover from\n\t * Clarkson packet driver code. Doesn't do a thing on the boards I've\n\t * tested. -DG [note that a outb(0x84, 0) seems to work here, and is\n\t * non-invasive...but some boards don't seem to reset and I don't have\n\t * complete documentation on what the 'right' thing to do is...so we do\n\t * the invasive thing for now.  Yuck.]\n\t */\n\tbus_space_write_1(asict, asich, NE2000_ASIC_RESET, tmp);\n\tdelay(5000);\n\n\t/*\n\t * This is needed because some NE clones apparently don't reset the\n\t * NIC properly (or the NIC chip doesn't reset fully on power-up).\n\t * XXX - this makes the probe invasive!  Done against my better\n\t * judgement.  -DLG\n\t */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tdelay(5000);\n\n\t/*\n\t * Generic probe routine for testing for the existance of a DS8390.\n\t * Must be performed  after the NIC has just been reset.  This\n\t * works by looking at certain register values that are guaranteed\n\t * to be initialized a certain way after power-up or reset.\n\t *\n\t * Specifically:\n\t *\n\t *\tRegister\t\treset bits\tset bits\n\t *\t--------\t\t----------\t--------\n\t *\tCR\t\t\tTXP, STA\tRD2, STP\n\t *\tISR\t\t\t\t\tRST\n\t *\tIMR\t\t\t<all>\n\t *\tDCR\t\t\t\t\tLAS\n\t *\tTCR\t\t\tLB1, LB0\n\t *\n\t * We only look at CR and ISR, however, since looking at the others\n\t * would require changing register pages, which would be intrusive\n\t * if this isn't an 8390.\n\t */\n\n\ttmp = bus_space_read_1(nict, nich, ED_P0_CR);\n\tif ((tmp & (ED_CR_RD2 | ED_CR_TXP | ED_CR_STA | ED_CR_STP)) !=\n\t    (ED_CR_RD2 | ED_CR_STP))\n\t\tgoto out;\n\n\ttmp = bus_space_read_1(nict, nich, ED_P0_ISR);\n\tif ((tmp & ED_ISR_RST) != ED_ISR_RST)\n\t\tgoto out;\n\n\tbus_space_write_1(nict, nich,\n\t    ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tfor (i = 0; i < 100; i++) {\n\t\tif ((bus_space_read_1(nict, nich, ED_P0_ISR) & ED_ISR_RST) ==\n\t\t    ED_ISR_RST) {\n\t\t\t/* Ack the reset bit. */\n\t\t\tbus_space_write_1(nict, nich, ED_P0_ISR, ED_ISR_RST);\n\t\t\tbreak;\n\t\t}\n\t\tdelay(100);\n\t}\n\n#if 0\n\t/* XXX */\n\tif (i == 100)\n\t\tgoto out;\n#endif\n\n\t/*\n\t * Test the ability to read and write to the NIC memory.  This has\n\t * the side effect of determining if this is an NE1000 or an NE2000.\n\t */\n\n\t/*\n\t * This prevents packets from being stored in the NIC memory when\n\t * the readmem routine turns on the start bit in the CR.\n\t */\n\tbus_space_write_1(nict, nich, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Temporarily initialize DCR for byte operations. */\n\tbus_space_write_1(nict, nich, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\n\tbus_space_write_1(nict, nich, ED_P0_PSTART, 8192 >> ED_PAGE_SHIFT);\n\tbus_space_write_1(nict, nich, ED_P0_PSTOP, 16384 >> ED_PAGE_SHIFT);\n\n\t/*\n\t * Write a test pattern in byte mode.  If this fails, then there\n\t * probably isn't any memory at 8k - which likely means that the\n\t * board is an NE2000.\n\t */\n\tne2000_writemem(nict, nich, asict, asich, test_pattern, 8192,\n\t    sizeof(test_pattern), 0);\n\tne2000_readmem(nict, nich, asict, asich, 8192, test_buffer,\n\t    sizeof(test_buffer), 0);\n\n\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern))) {\n\t\t/* not an NE1000 - try NE2000 */\n\t\tbus_space_write_1(nict, nich, ED_P0_DCR,\n\t\t    ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS);\n\t\tbus_space_write_1(nict, nich, ED_P0_PSTART,\n\t\t    16384 >> ED_PAGE_SHIFT);\n\t\tbus_space_write_1(nict, nich, ED_P0_PSTOP,\n\t\t    32768 >> ED_PAGE_SHIFT);\n\n\t\t/*\n\t\t * Write the test pattern in word mode.  If this also fails,\n\t\t * then we don't know what this board is.\n\t\t */\n\t\tne2000_writemem(nict, nich, asict, asich, test_pattern, 16384,\n\t\t    sizeof(test_pattern), 1);\n\t\tne2000_readmem(nict, nich, asict, asich, 16384, test_buffer,\n\t\t    sizeof(test_buffer), 1);\n\n\t\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern)))\n\t\t\tgoto out;\t/* not an NE2000 either */\n\n\t\trv = NE2000_TYPE_NE2000;\n\t} else {\n\t\ttmp = 0;\n\t\tfor (i = 4; i < 12; i++)\n\t\t\ttmp += bus_space_read_1(asict, asich, i);\n\n\t\tif (tmp == 0xff) {\n\t\t\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\t\t\tdsc->sc_arpcom.ac_enaddr[i] =\n\t\t\t\t\tbus_space_read_1(asict, asich, i + 4);\n\n\t\t\trv = NE2000_TYPE_DL10019;\n\t\t} else {\n\t\t\t/* We're an NE1000. */\n\t\t\trv = NE2000_TYPE_NE1000;\n\t\t}\n\t}\n\n\t/* Clear any pending interrupts that might have occurred above. */\n\tbus_space_write_1(nict, nich, ED_P0_ISR, 0xff);\n\n out:\n\treturn (rv);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/ne2000var.h>\n#include <dev/ic/ne2000reg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tne2000_write_mbuf;\nint\tne2000_ring_copy;\nvoid\tne2000_read_hdr;\nint\tne2000_test_mem;\nvoid\tne2000_writemem;\nvoid\tne2000_readmem;\n\nvoid\nne2000_attach(nsc, myea, media, nmedia, defmedia)\n\tstruct ne2000_softc *nsc;\n\tu_int8_t *myea;\n\tint *media, nmedia, defmedia;\n{\n\tstruct dp8390_softc *dsc = &nsc->sc_dp8390;\n\tbus_space_tag_t nict = dsc->sc_regt;\n\tbus_space_handle_t nich = dsc->sc_regh;\n\tbus_space_tag_t asict = nsc->sc_asict;\n\tbus_space_handle_t asich = nsc->sc_asich;\n\tu_int8_t romdata[16];\n\tint memsize, i, useword;\n\n\t/*\n\t * Detect it again; this gives us the memory size.\n\t */\n\tnsc->sc_type = ne2000_detect(nsc);\n\tif (nsc->sc_type == 0) {\n\t\tprintf(\"%s: where did the card go?\\n\", dsc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tuseword = (nsc->sc_type != NE2000_TYPE_NE1000);\n\n\tdsc->cr_proto = ED_CR_RD2;\n\n\t/*\n\t * DCR gets:\n\t *\n\t *\tFIFO threshold to 8, No auto-init Remote DMA,\n\t *\tbyte order=80x86.\n\t *\n\t * NE1000 gets byte-wide DMA, NE2000 gets word-wide DMA.\n\t */\n\tdsc->dcr_reg = ED_DCR_FT1 | ED_DCR_LS |\n\t    (nsc->sc_type != NE2000_TYPE_NE1000 ? ED_DCR_WTS : 0);\n\n\tdsc->test_mem = ne2000_test_mem;\n\tdsc->ring_copy = ne2000_ring_copy;\n\tdsc->write_mbuf = ne2000_write_mbuf;\n\tdsc->read_hdr = ne2000_read_hdr;\n\n\t/* Registers are linear. */\n\tfor (i = 0; i < 16; i++)\n\t\tdsc->sc_reg_map[i] = i;\n\n\t/*\n\t * 8k of memory plus an additional 8k if an NE2000.\n\t */\n\tmemsize = 8192 + (nsc->sc_type != NE2000_TYPE_NE1000 ? 8192 : 0);\n\n\t/*\n\t * NIC memory doens't start at zero on an NE board.\n\t * The start address is tied to the bus width.\n\t * (It happens to be computed the same way as mem size.)\n\t */\n\tdsc->mem_start = memsize;\n\n#ifdef GWETHER\n\t{\n\t\tint x, mstart = 0;\n\t\tint8_t pbuf0[ED_PAGE_SIZE], pbuf[ED_PAGE_SIZE],\n\t\t    tbuf[ED_PAGE_SIZE];\n\n\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\tpbuf0[i] = 0;\n\n\t\t/* Search for the start of RAM. */\n\t\tfor (x = 1; x < 256; x++) {\n\t\t\tne2000_writemem(nict, nich, asict, asich, pbuf0,\n\t\t\t    x << ED_PAGE_SHIFT, ED_PAGE_SIZE, useword);\n\t\t\tne2000_readmem(nict, nich, asict, asich,\n\t\t\t    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE, useword);\n\t\t\tif (bcmp(pbuf0, tbuf, ED_PAGE_SIZE) == 0) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\tne2000_writemem(nict, nich, asict, asich,\n\t\t\t\t    pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE,\n\t\t\t\t    useword);\n\t\t\t\tne2000_readmem(nict, nich, asict, asich,\n\t\t\t\t    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE,\n\t\t\t\t    useword);\n\t\t\t\tif (bcmp(pbuf, tbuf, ED_PAGE_SIZE) == 0) {\n\t\t\t\t\tmstart = x << ED_PAGE_SHIFT;\n\t\t\t\t\tmemsize = ED_PAGE_SIZE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mstart == 0) {\n\t\t\tprintf(\"%s: cannot find start of RAM\\n\",\n\t\t\t    dsc->sc_dev.dv_xname);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Search for the end of RAM. */\n\t\tfor (++x; x < 256; x++) {\n\t\t\tne2000_writemem(nict, nich, asict, asich, pbuf0,\n\t\t\t    x << ED_PAGE_SHIFT, ED_PAGE_SIZE, useword);\n\t\t\tne2000_readmem(nict, nich, asict, asich,\n\t\t\t    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE, useword);\n\t\t\tif (bcmp(pbuf0, tbuf, ED_PAGE_SIZE) == 0) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\tne2000_writemem(nict, nich, asict, asich,\n\t\t\t\t    pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE,\n\t\t\t\t    useword);\n\t\t\t\tne2000_readmem(nict, nich, asict, asich,\n\t\t\t\t    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE,\n\t\t\t\t    useword);\n\t\t\t\tif (bcmp(pbuf, tbuf, ED_PAGE_SIZE) == 0)\n\t\t\t\t\tmemsize += ED_PAGE_SIZE;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\n\t\tprintf(\"%s: RAM start 0x%x, size %d\\n\",\n\t\t    dsc->sc_dev.dv_xname, mstart, memsize);\n\n\t\tdsc->mem_start = mstart;\n\t}\n#endif /* GWETHER */\n\n\tdsc->mem_size = memsize;\n\n\tif (myea == NULL && nsc->sc_type != NE2000_TYPE_DL10019) {\n\t\t/* Read the station address. */\n\t\tne2000_readmem(nict, nich, asict, asich, 0, romdata,\n\t\t    sizeof(romdata), useword);\n\t\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n#ifdef __NetBSD__\n\t\t\tdsc->sc_enaddr[i] = romdata[i * (useword ? 2 : 1)];\n#else\n\t\t\tdsc->sc_arpcom.ac_enaddr[i] =\n\t\t\t\tromdata[i * (useword ? 2 : 1)];\n#endif\n\t}\n\n\t/* Clear any pending interrupts that might have occurred above. */\n\tbus_space_write_1(nict, nich, ED_P0_ISR, 0xff);\n\n\tif (dp8390_config(dsc, media, nmedia, defmedia)) {\n\t\tprintf(\"%s: setup failed\\n\", dsc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/*\n\t * We need to compute mem_ring a bit differently; override the\n\t * value set up in dp8390_config().\n\t */\n\tdsc->mem_ring =\n\t    dsc->mem_start + ((dsc->txb_cnt * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n}"
  }
]