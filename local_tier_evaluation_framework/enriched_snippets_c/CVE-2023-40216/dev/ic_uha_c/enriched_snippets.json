[
  {
    "function_name": "uha_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/uha.c",
    "lines": "529-558",
    "snippet": "void\nuha_timeout(arg)\n\tvoid *arg;\n{\n\tstruct uha_mscp *mscp = arg;\n\tstruct scsi_xfer *xs = mscp->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct uha_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\tif (mscp->flags & MSCP_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tmscp->xs->error = XS_TIMEOUT;\n\t\tmscp->timeout = UHA_ABORT_TIMEOUT;\n\t\tmscp->flags |= MSCP_ABORT;\n\t\t(sc->start_mbox)(sc, mscp);\n\t}\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tUHA_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
    ],
    "globals_used": [
      "uha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));",
      "uha_init_mscp __P((struct uha_softc *, struct uha_mscp *));",
      "struct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;",
      "int flags;",
      "struct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "mscp"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "sc_link"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tUHA_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\nuha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));\nuha_init_mscp __P((struct uha_softc *, struct uha_mscp *));\nstruct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;\nint flags;\nstruct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;\n\nvoid\nuha_timeout(arg)\n\tvoid *arg;\n{\n\tstruct uha_mscp *mscp = arg;\n\tstruct scsi_xfer *xs = mscp->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct uha_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\tif (mscp->flags & MSCP_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tmscp->xs->error = XS_TIMEOUT;\n\t\tmscp->timeout = UHA_ABORT_TIMEOUT;\n\t\tmscp->flags |= MSCP_ABORT;\n\t\t(sc->start_mbox)(sc, mscp);\n\t}\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "uha_scsi_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/uha.c",
    "lines": "358-527",
    "snippet": "int\nuha_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct uha_softc *sc = sc_link->adapter_softc;\n\tstruct uha_mscp *mscp;\n\tstruct uha_dma_seg *sg;\n\tint seg;\t\t/* scatter gather seg being worked on */\n\tu_long thiskv, thisphys, nextphys;\n\tint bytes_this_seg, bytes_this_page, datalen, flags;\n\tint s;\n\n\tSC_DEBUG(sc_link, SDEV_DB2, (\"uha_scsi_cmd\\n\"));\n\t/*\n\t * get a mscp (mbox-out) to use. If the transfer\n\t * is from a buf (possibly from interrupt time)\n\t * then we can't allow it to sleep\n\t */\n\tflags = xs->flags;\n\tif ((mscp = uha_get_mscp(sc, flags)) == NULL) {\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn (TRY_AGAIN_LATER);\n\t}\n\tmscp->xs = xs;\n\tmscp->timeout = xs->timeout;\n\n\t/*\n\t * Put all the arguments for the xfer in the mscp\n\t */\n\tif (flags & SCSI_RESET) {\n\t\tmscp->opcode = UHA_SDR;\n\t\tmscp->ca = 0x01;\n\t} else {\n\t\tmscp->opcode = UHA_TSP;\n\t\t/* XXX Not for tapes. */\n\t\tmscp->ca = 0x01;\n\t\tbcopy(xs->cmd, &mscp->scsi_cmd, mscp->scsi_cmd_length);\n\t}\n\tmscp->xdir = UHA_SDET;\n\tmscp->dcn = 0x00;\n\tmscp->chan = 0x00;\n\tmscp->target = sc_link->target;\n\tmscp->lun = sc_link->lun;\n\tmscp->scsi_cmd_length = xs->cmdlen;\n\tmscp->sense_ptr = KVTOPHYS(&mscp->mscp_sense);\n\tmscp->req_sense_length = sizeof(mscp->mscp_sense);\n\tmscp->host_stat = 0x00;\n\tmscp->target_stat = 0x00;\n\n\tif (xs->datalen) {\n\t\tsg = mscp->uha_dma;\n\t\tseg = 0;\n#ifdef\tTFS\n\t\tif (flags & SCSI_DATA_UIO) {\n\t\t\tstruct iovec *iovp;\n\t\t\tiovp = ((struct uio *) xs->data)->uio_iov;\n\t\t\tdatalen = ((struct uio *) xs->data)->uio_iovcnt;\n\t\t\txs->datalen = 0;\n\t\t\twhile (datalen && seg < UHA_NSEG) {\n\t\t\t\tsg->seg_addr = (physaddr)iovp->iov_base;\n\t\t\t\tsg->seg_len = iovp->iov_len;\n\t\t\t\txs->datalen += iovp->iov_len;\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"(0x%x@0x%x)\",\n\t\t\t\t    iovp->iov_len, iovp->iov_base));\n\t\t\t\tsg++;\n\t\t\t\tiovp++;\n\t\t\t\tseg++;\n\t\t\t\tdatalen--;\n\t\t\t}\n\t\t} else\n#endif /*TFS */\n\t\t{\n\t\t\t/*\n\t\t\t * Set up the scatter gather block\n\t\t\t */\n\t\t\tSC_DEBUG(sc_link, SDEV_DB4,\n\t\t\t    (\"%d @0x%x:- \", xs->datalen, xs->data));\n\t\t\tdatalen = xs->datalen;\n\t\t\tthiskv = (int) xs->data;\n\t\t\tthisphys = KVTOPHYS(thiskv);\n\n\t\t\twhile (datalen && seg < UHA_NSEG) {\n\t\t\t\tbytes_this_seg = 0;\n\n\t\t\t\t/* put in the base address */\n\t\t\t\tsg->seg_addr = thisphys;\n\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"0x%x\", thisphys));\n\n\t\t\t\t/* do it at least once */\n\t\t\t\tnextphys = thisphys;\n\t\t\t\twhile (datalen && thisphys == nextphys) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This page is contiguous (physically)\n\t\t\t\t\t * with the the last, just extend the\n\t\t\t\t\t * length\n\t\t\t\t\t */\n\t\t\t\t\t/* how far to the end of the page */\n\t\t\t\t\tnextphys = (thisphys & ~PGOFSET) + NBPG;\n\t\t\t\t\tbytes_this_page = nextphys - thisphys;\n\t\t\t\t\t/**** or the data ****/\n\t\t\t\t\tbytes_this_page = min(bytes_this_page,\n\t\t\t\t\t\t\t      datalen);\n\t\t\t\t\tbytes_this_seg += bytes_this_page;\n\t\t\t\t\tdatalen -= bytes_this_page;\n\n\t\t\t\t\t/* get more ready for the next page */\n\t\t\t\t\tthiskv = (thiskv & ~PGOFSET) + NBPG;\n\t\t\t\t\tif (datalen)\n\t\t\t\t\t\tthisphys = KVTOPHYS(thiskv);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * next page isn't contiguous, finish the seg\n\t\t\t\t */\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4,\n\t\t\t\t    (\"(0x%x)\", bytes_this_seg));\n\t\t\t\tsg->seg_len = bytes_this_seg;\n\t\t\t\tsg++;\n\t\t\t\tseg++;\n\t\t\t}\n\t\t}\n\t\t/* end of iov/kv decision */\n\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"\\n\"));\n\t\tif (datalen) {\n\t\t\t/*\n\t\t\t * there's still data, must have run out of segs!\n\t\t\t */\n\t\t\tprintf(\"%s: uha_scsi_cmd, more than %d dma segs\\n\",\n\t\t\t    sc->sc_dev.dv_xname, UHA_NSEG);\n\t\t\tgoto bad;\n\t\t}\n\t\tmscp->data_addr = KVTOPHYS(mscp->uha_dma);\n\t\tmscp->data_length = xs->datalen;\n\t\tmscp->sgth = 0x01;\n\t\tmscp->sg_num = seg;\n\t} else {\t\t/* No data xfer, use non S/G values */\n\t\tmscp->data_addr = (physaddr)0;\n\t\tmscp->data_length = 0;\n\t\tmscp->sgth = 0x00;\n\t\tmscp->sg_num = 0;\n\t}\n\tmscp->link_id = 0;\n\tmscp->link_addr = (physaddr)0;\n\n\ts = splbio();\n\t(sc->start_mbox)(sc, mscp);\n\tsplx(s);\n\n\t/*\n\t * Usually return SUCCESSFULLY QUEUED\n\t */\n\tif ((flags & SCSI_POLL) == 0)\n\t\treturn (SUCCESSFULLY_QUEUED);\n\n\t/*\n\t * If we can't use interrupts, poll on completion\n\t */\n\tif ((sc->poll)(sc, xs, mscp->timeout)) {\n\t\tuha_timeout(mscp);\n\t\tif ((sc->poll)(sc, xs, mscp->timeout))\n\t\t\tuha_timeout(mscp);\n\t}\n\treturn (COMPLETE);\n\nbad:\n\txs->error = XS_DRIVER_STUFFUP;\n\tuha_free_mscp(sc, mscp);\n\treturn (COMPLETE);\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));",
      "void uha_free_mscp",
      "uha_init_mscp __P((struct uha_softc *, struct uha_mscp *));",
      "struct uha_mscp *uha_get_mscp",
      "int uha_scsi_cmd",
      "struct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;",
      "int flags;",
      "struct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uha_free_mscp",
          "args": [
            "sc",
            "mscp"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "uha_free_mscp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/uha.c",
          "lines": "177-197",
          "snippet": "void\nuha_free_mscp(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\tint s;\n\n\ts = splbio();\n\n\tuha_reset_mscp(sc, mscp);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_mscp, mscp, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (mscp->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_mscp);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/uhavar.h>",
            "#include <dev/ic/uhareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));",
            "void uha_free_mscp",
            "uha_init_mscp __P((struct uha_softc *, struct uha_mscp *));",
            "struct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;",
            "struct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nuha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));\nvoid uha_free_mscp;\nuha_init_mscp __P((struct uha_softc *, struct uha_mscp *));\nstruct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;\nstruct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;\n\nvoid\nuha_free_mscp(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\tint s;\n\n\ts = splbio();\n\n\tuha_reset_mscp(sc, mscp);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_mscp, mscp, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (mscp->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_mscp);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uha_timeout",
          "args": [
            "mscp"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "uha_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/uha.c",
          "lines": "529-558",
          "snippet": "void\nuha_timeout(arg)\n\tvoid *arg;\n{\n\tstruct uha_mscp *mscp = arg;\n\tstruct scsi_xfer *xs = mscp->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct uha_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\tif (mscp->flags & MSCP_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tmscp->xs->error = XS_TIMEOUT;\n\t\tmscp->timeout = UHA_ABORT_TIMEOUT;\n\t\tmscp->flags |= MSCP_ABORT;\n\t\t(sc->start_mbox)(sc, mscp);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/uhavar.h>",
            "#include <dev/ic/uhareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tUHA_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
          ],
          "globals_used": [
            "uha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));",
            "uha_init_mscp __P((struct uha_softc *, struct uha_mscp *));",
            "struct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;",
            "int flags;",
            "struct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tUHA_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\nuha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));\nuha_init_mscp __P((struct uha_softc *, struct uha_mscp *));\nstruct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;\nint flags;\nstruct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;\n\nvoid\nuha_timeout(arg)\n\tvoid *arg;\n{\n\tstruct uha_mscp *mscp = arg;\n\tstruct scsi_xfer *xs = mscp->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct uha_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\tif (mscp->flags & MSCP_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tmscp->xs->error = XS_TIMEOUT;\n\t\tmscp->timeout = UHA_ABORT_TIMEOUT;\n\t\tmscp->flags |= MSCP_ABORT;\n\t\t(sc->start_mbox)(sc, mscp);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "xs",
            "mscp->timeout"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "xs",
            "mscp->timeout"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "mscp"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "mscp->uha_dma"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: uha_scsi_cmd, more than %d dma segs\\n\"",
            "sc->sc_dev.dv_xname",
            "UHA_NSEG"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SC_DEBUGN",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"\\n\")"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUGN",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"(0x%x)\", bytes_this_seg)"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "thiskv"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bytes_this_page",
            "datalen"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "uhaminphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/uha.c",
          "lines": "344-352",
          "snippet": "void\nuhaminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((UHA_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((UHA_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}",
          "includes": [
            "#include <dev/ic/uhavar.h>",
            "#include <dev/ic/uhareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void uhaminphys"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid uhaminphys;\n\nvoid\nuhaminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((UHA_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((UHA_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SC_DEBUGN",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"0x%x\", thisphys)"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "thiskv"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUG",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"%d @0x%x:- \", xs->datalen, xs->data)"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUGN",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"(0x%x@0x%x)\",\n\t\t\t\t    iovp->iov_len, iovp->iov_base)"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "&mscp->mscp_sense"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "xs->cmd",
            "&mscp->scsi_cmd",
            "mscp->scsi_cmd_length"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "uha_get_mscp",
          "args": [
            "sc",
            "flags"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUG",
          "args": [
            "sc_link",
            "SDEV_DB2",
            "(\"uha_scsi_cmd\\n\")"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nuha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));\nvoid uha_free_mscp;\nuha_init_mscp __P((struct uha_softc *, struct uha_mscp *));\nstruct uha_mscp *uha_get_mscp;\nint uha_scsi_cmd;\nstruct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;\nint flags;\nstruct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;\n\nint\nuha_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct uha_softc *sc = sc_link->adapter_softc;\n\tstruct uha_mscp *mscp;\n\tstruct uha_dma_seg *sg;\n\tint seg;\t\t/* scatter gather seg being worked on */\n\tu_long thiskv, thisphys, nextphys;\n\tint bytes_this_seg, bytes_this_page, datalen, flags;\n\tint s;\n\n\tSC_DEBUG(sc_link, SDEV_DB2, (\"uha_scsi_cmd\\n\"));\n\t/*\n\t * get a mscp (mbox-out) to use. If the transfer\n\t * is from a buf (possibly from interrupt time)\n\t * then we can't allow it to sleep\n\t */\n\tflags = xs->flags;\n\tif ((mscp = uha_get_mscp(sc, flags)) == NULL) {\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn (TRY_AGAIN_LATER);\n\t}\n\tmscp->xs = xs;\n\tmscp->timeout = xs->timeout;\n\n\t/*\n\t * Put all the arguments for the xfer in the mscp\n\t */\n\tif (flags & SCSI_RESET) {\n\t\tmscp->opcode = UHA_SDR;\n\t\tmscp->ca = 0x01;\n\t} else {\n\t\tmscp->opcode = UHA_TSP;\n\t\t/* XXX Not for tapes. */\n\t\tmscp->ca = 0x01;\n\t\tbcopy(xs->cmd, &mscp->scsi_cmd, mscp->scsi_cmd_length);\n\t}\n\tmscp->xdir = UHA_SDET;\n\tmscp->dcn = 0x00;\n\tmscp->chan = 0x00;\n\tmscp->target = sc_link->target;\n\tmscp->lun = sc_link->lun;\n\tmscp->scsi_cmd_length = xs->cmdlen;\n\tmscp->sense_ptr = KVTOPHYS(&mscp->mscp_sense);\n\tmscp->req_sense_length = sizeof(mscp->mscp_sense);\n\tmscp->host_stat = 0x00;\n\tmscp->target_stat = 0x00;\n\n\tif (xs->datalen) {\n\t\tsg = mscp->uha_dma;\n\t\tseg = 0;\n#ifdef\tTFS\n\t\tif (flags & SCSI_DATA_UIO) {\n\t\t\tstruct iovec *iovp;\n\t\t\tiovp = ((struct uio *) xs->data)->uio_iov;\n\t\t\tdatalen = ((struct uio *) xs->data)->uio_iovcnt;\n\t\t\txs->datalen = 0;\n\t\t\twhile (datalen && seg < UHA_NSEG) {\n\t\t\t\tsg->seg_addr = (physaddr)iovp->iov_base;\n\t\t\t\tsg->seg_len = iovp->iov_len;\n\t\t\t\txs->datalen += iovp->iov_len;\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"(0x%x@0x%x)\",\n\t\t\t\t    iovp->iov_len, iovp->iov_base));\n\t\t\t\tsg++;\n\t\t\t\tiovp++;\n\t\t\t\tseg++;\n\t\t\t\tdatalen--;\n\t\t\t}\n\t\t} else\n#endif /*TFS */\n\t\t{\n\t\t\t/*\n\t\t\t * Set up the scatter gather block\n\t\t\t */\n\t\t\tSC_DEBUG(sc_link, SDEV_DB4,\n\t\t\t    (\"%d @0x%x:- \", xs->datalen, xs->data));\n\t\t\tdatalen = xs->datalen;\n\t\t\tthiskv = (int) xs->data;\n\t\t\tthisphys = KVTOPHYS(thiskv);\n\n\t\t\twhile (datalen && seg < UHA_NSEG) {\n\t\t\t\tbytes_this_seg = 0;\n\n\t\t\t\t/* put in the base address */\n\t\t\t\tsg->seg_addr = thisphys;\n\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"0x%x\", thisphys));\n\n\t\t\t\t/* do it at least once */\n\t\t\t\tnextphys = thisphys;\n\t\t\t\twhile (datalen && thisphys == nextphys) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This page is contiguous (physically)\n\t\t\t\t\t * with the the last, just extend the\n\t\t\t\t\t * length\n\t\t\t\t\t */\n\t\t\t\t\t/* how far to the end of the page */\n\t\t\t\t\tnextphys = (thisphys & ~PGOFSET) + NBPG;\n\t\t\t\t\tbytes_this_page = nextphys - thisphys;\n\t\t\t\t\t/**** or the data ****/\n\t\t\t\t\tbytes_this_page = min(bytes_this_page,\n\t\t\t\t\t\t\t      datalen);\n\t\t\t\t\tbytes_this_seg += bytes_this_page;\n\t\t\t\t\tdatalen -= bytes_this_page;\n\n\t\t\t\t\t/* get more ready for the next page */\n\t\t\t\t\tthiskv = (thiskv & ~PGOFSET) + NBPG;\n\t\t\t\t\tif (datalen)\n\t\t\t\t\t\tthisphys = KVTOPHYS(thiskv);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * next page isn't contiguous, finish the seg\n\t\t\t\t */\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4,\n\t\t\t\t    (\"(0x%x)\", bytes_this_seg));\n\t\t\t\tsg->seg_len = bytes_this_seg;\n\t\t\t\tsg++;\n\t\t\t\tseg++;\n\t\t\t}\n\t\t}\n\t\t/* end of iov/kv decision */\n\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"\\n\"));\n\t\tif (datalen) {\n\t\t\t/*\n\t\t\t * there's still data, must have run out of segs!\n\t\t\t */\n\t\t\tprintf(\"%s: uha_scsi_cmd, more than %d dma segs\\n\",\n\t\t\t    sc->sc_dev.dv_xname, UHA_NSEG);\n\t\t\tgoto bad;\n\t\t}\n\t\tmscp->data_addr = KVTOPHYS(mscp->uha_dma);\n\t\tmscp->data_length = xs->datalen;\n\t\tmscp->sgth = 0x01;\n\t\tmscp->sg_num = seg;\n\t} else {\t\t/* No data xfer, use non S/G values */\n\t\tmscp->data_addr = (physaddr)0;\n\t\tmscp->data_length = 0;\n\t\tmscp->sgth = 0x00;\n\t\tmscp->sg_num = 0;\n\t}\n\tmscp->link_id = 0;\n\tmscp->link_addr = (physaddr)0;\n\n\ts = splbio();\n\t(sc->start_mbox)(sc, mscp);\n\tsplx(s);\n\n\t/*\n\t * Usually return SUCCESSFULLY QUEUED\n\t */\n\tif ((flags & SCSI_POLL) == 0)\n\t\treturn (SUCCESSFULLY_QUEUED);\n\n\t/*\n\t * If we can't use interrupts, poll on completion\n\t */\n\tif ((sc->poll)(sc, xs, mscp->timeout)) {\n\t\tuha_timeout(mscp);\n\t\tif ((sc->poll)(sc, xs, mscp->timeout))\n\t\t\tuha_timeout(mscp);\n\t}\n\treturn (COMPLETE);\n\nbad:\n\txs->error = XS_DRIVER_STUFFUP;\n\tuha_free_mscp(sc, mscp);\n\treturn (COMPLETE);\n}"
  },
  {
    "function_name": "uhaminphys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/uha.c",
    "lines": "344-352",
    "snippet": "void\nuhaminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((UHA_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((UHA_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void uhaminphys"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "minphys",
          "args": [
            "bp"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "uhaminphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/uha.c",
          "lines": "344-352",
          "snippet": "void\nuhaminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((UHA_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((UHA_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid uhaminphys;\n\nvoid\nuhaminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((UHA_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((UHA_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}"
  },
  {
    "function_name": "uha_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/uha.c",
    "lines": "291-342",
    "snippet": "void\nuha_done(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs = mscp->xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"uha_done\\n\"));\n\t/*\n\t * Otherwise, put the results of the operation\n\t * into the xfer and call whoever started it\n\t */\n\tif ((mscp->flags & MSCP_ALLOC) == 0) {\n\t\tprintf(\"%s: exiting ccb not allocated!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n\tif (xs->error == XS_NOERROR) {\n\t\tif (mscp->host_stat != UHA_NO_ERR) {\n\t\t\tswitch (mscp->host_stat) {\n\t\t\tcase UHA_SBUS_TIMEOUT:\t\t/* No response */\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: host_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, mscp->host_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else if (mscp->target_stat != SCSI_OK) {\n\t\t\tswitch (mscp->target_stat) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = &mscp->mscp_sense;\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: target_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, mscp->target_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t}\n\tuha_free_mscp(sc, mscp);\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));",
      "void uha_free_mscp",
      "uha_init_mscp __P((struct uha_softc *, struct uha_mscp *));",
      "struct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;",
      "int flags;",
      "struct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uha_free_mscp",
          "args": [
            "sc",
            "mscp"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "uha_free_mscp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/uha.c",
          "lines": "177-197",
          "snippet": "void\nuha_free_mscp(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\tint s;\n\n\ts = splbio();\n\n\tuha_reset_mscp(sc, mscp);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_mscp, mscp, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (mscp->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_mscp);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/uhavar.h>",
            "#include <dev/ic/uhareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));",
            "void uha_free_mscp",
            "uha_init_mscp __P((struct uha_softc *, struct uha_mscp *));",
            "struct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;",
            "struct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nuha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));\nvoid uha_free_mscp;\nuha_init_mscp __P((struct uha_softc *, struct uha_mscp *));\nstruct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;\nstruct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;\n\nvoid\nuha_free_mscp(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\tint s;\n\n\ts = splbio();\n\n\tuha_reset_mscp(sc, mscp);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_mscp, mscp, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (mscp->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_mscp);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: target_stat %x\\n\"",
            "sc->sc_dev.dv_xname",
            "mscp->target_stat"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debugger",
          "args": [],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUG",
          "args": [
            "xs->sc_link",
            "SDEV_DB2",
            "(\"uha_done\\n\")"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nuha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));\nvoid uha_free_mscp;\nuha_init_mscp __P((struct uha_softc *, struct uha_mscp *));\nstruct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;\nint flags;\nstruct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;\n\nvoid\nuha_done(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs = mscp->xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"uha_done\\n\"));\n\t/*\n\t * Otherwise, put the results of the operation\n\t * into the xfer and call whoever started it\n\t */\n\tif ((mscp->flags & MSCP_ALLOC) == 0) {\n\t\tprintf(\"%s: exiting ccb not allocated!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n\tif (xs->error == XS_NOERROR) {\n\t\tif (mscp->host_stat != UHA_NO_ERR) {\n\t\t\tswitch (mscp->host_stat) {\n\t\t\tcase UHA_SBUS_TIMEOUT:\t\t/* No response */\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: host_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, mscp->host_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else if (mscp->target_stat != SCSI_OK) {\n\t\t\tswitch (mscp->target_stat) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = &mscp->mscp_sense;\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: target_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, mscp->target_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t}\n\tuha_free_mscp(sc, mscp);\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n}"
  },
  {
    "function_name": "uha_init_mscp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/uha.c",
    "lines": "199-216",
    "snippet": "integrate void\nuha_init_mscp(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\tint hashnum;\n\n\tbzero(mscp, sizeof(struct uha_mscp));\n\t/*\n\t * put in the phystokv hash table\n\t * Never gets taken out.\n\t */\n\tmscp->hashkey = KVTOPHYS(mscp);\n\thashnum = MSCP_HASH(mscp->hashkey);\n\tmscp->nexthash = sc->sc_mscphash[hashnum];\n\tsc->sc_mscphash[hashnum] = mscp;\n\tuha_reset_mscp(sc, mscp);\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tintegrate\tstatic inline",
      "#define\tintegrate"
    ],
    "globals_used": [
      "integrate void",
      "uha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));",
      "integrate void",
      "uha_init_mscp __P((struct uha_softc *, struct uha_mscp *));",
      "struct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;",
      "struct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uha_reset_mscp",
          "args": [
            "sc",
            "mscp"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "uha_reset_mscp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/uha.c",
          "lines": "165-172",
          "snippet": "integrate void\nuha_reset_mscp(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\n\tmscp->flags = 0;\n}",
          "includes": [
            "#include <dev/ic/uhavar.h>",
            "#include <dev/ic/uhareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tintegrate\tstatic inline",
            "#define\tintegrate"
          ],
          "globals_used": [
            "integrate void",
            "uha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));",
            "integrate void",
            "uha_init_mscp __P((struct uha_softc *, struct uha_mscp *));",
            "struct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;",
            "int flags;",
            "struct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\nuha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));\nintegrate void;\nuha_init_mscp __P((struct uha_softc *, struct uha_mscp *));\nstruct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;\nint flags;\nstruct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;\n\nintegrate void\nuha_reset_mscp(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\n\tmscp->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSCP_HASH",
          "args": [
            "mscp->hashkey"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "mscp"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "mscp",
            "sizeof(struct uha_mscp)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\nuha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));\nintegrate void;\nuha_init_mscp __P((struct uha_softc *, struct uha_mscp *));\nstruct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;\nstruct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;\n\nintegrate void\nuha_init_mscp(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\tint hashnum;\n\n\tbzero(mscp, sizeof(struct uha_mscp));\n\t/*\n\t * put in the phystokv hash table\n\t * Never gets taken out.\n\t */\n\tmscp->hashkey = KVTOPHYS(mscp);\n\thashnum = MSCP_HASH(mscp->hashkey);\n\tmscp->nexthash = sc->sc_mscphash[hashnum];\n\tsc->sc_mscphash[hashnum] = mscp;\n\tuha_reset_mscp(sc, mscp);\n}"
  },
  {
    "function_name": "uha_free_mscp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/uha.c",
    "lines": "177-197",
    "snippet": "void\nuha_free_mscp(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\tint s;\n\n\ts = splbio();\n\n\tuha_reset_mscp(sc, mscp);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_mscp, mscp, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (mscp->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_mscp);\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));",
      "void uha_free_mscp",
      "uha_init_mscp __P((struct uha_softc *, struct uha_mscp *));",
      "struct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;",
      "struct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&sc->sc_free_mscp"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "rln_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "171-214",
          "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&sc->sc_free_mscp",
            "mscp",
            "chain"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uha_reset_mscp",
          "args": [
            "sc",
            "mscp"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "uha_reset_mscp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/uha.c",
          "lines": "165-172",
          "snippet": "integrate void\nuha_reset_mscp(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\n\tmscp->flags = 0;\n}",
          "includes": [
            "#include <dev/ic/uhavar.h>",
            "#include <dev/ic/uhareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tintegrate\tstatic inline",
            "#define\tintegrate"
          ],
          "globals_used": [
            "integrate void",
            "uha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));",
            "integrate void",
            "uha_init_mscp __P((struct uha_softc *, struct uha_mscp *));",
            "struct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;",
            "int flags;",
            "struct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\nuha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));\nintegrate void;\nuha_init_mscp __P((struct uha_softc *, struct uha_mscp *));\nstruct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;\nint flags;\nstruct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;\n\nintegrate void\nuha_reset_mscp(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\n\tmscp->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nuha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));\nvoid uha_free_mscp;\nuha_init_mscp __P((struct uha_softc *, struct uha_mscp *));\nstruct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;\nstruct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;\n\nvoid\nuha_free_mscp(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\tint s;\n\n\ts = splbio();\n\n\tuha_reset_mscp(sc, mscp);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_mscp, mscp, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (mscp->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_mscp);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "uha_reset_mscp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/uha.c",
    "lines": "165-172",
    "snippet": "integrate void\nuha_reset_mscp(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\n\tmscp->flags = 0;\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tintegrate\tstatic inline",
      "#define\tintegrate"
    ],
    "globals_used": [
      "integrate void",
      "uha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));",
      "integrate void",
      "uha_init_mscp __P((struct uha_softc *, struct uha_mscp *));",
      "struct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;",
      "int flags;",
      "struct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\nuha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));\nintegrate void;\nuha_init_mscp __P((struct uha_softc *, struct uha_mscp *));\nstruct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;\nint flags;\nstruct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;\n\nintegrate void\nuha_reset_mscp(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\n\tmscp->flags = 0;\n}"
  },
  {
    "function_name": "uha_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/uha.c",
    "lines": "135-163",
    "snippet": "void\nuha_attach(sc)\n\tstruct uha_softc *sc;\n{\n\n\t(sc->init)(sc);\n\tTAILQ_INIT(&sc->sc_free_mscp);\n\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n#ifndef __OpenBSD__\n\tsc->sc_link.channel = SCSI_CHANNEL_ONLY_ONE;\n#endif\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->sc_scsi_dev;\n\tsc->sc_link.adapter = &uha_switch;\n\tsc->sc_link.device = &uha_dev;\n\tsc->sc_link.openings = 2;\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n#ifdef __OpenBSD__\n\tconfig_found(&sc->sc_dev, &sc->sc_link, uhaprint);\n#else\n\tconfig_found(&sc->sc_dev, &sc->sc_link, scsiprint);\n#endif\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct scsi_adapter uha_switch = {\n\tuha_scsi_cmd,\n\tuhaminphys,\n\t0,\n\t0,\n};",
      "struct scsi_device uha_dev = {\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};",
      "struct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;",
      "struct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "&sc->sc_dev",
            "&sc->sc_link",
            "scsiprint"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "&sc->sc_dev",
            "&sc->sc_link",
            "uhaprint"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->sc_free_mscp"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstruct scsi_adapter uha_switch = {\n\tuha_scsi_cmd,\n\tuhaminphys,\n\t0,\n\t0,\n};\nstruct scsi_device uha_dev = {\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};\nstruct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;\nstruct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;\n\nvoid\nuha_attach(sc)\n\tstruct uha_softc *sc;\n{\n\n\t(sc->init)(sc);\n\tTAILQ_INIT(&sc->sc_free_mscp);\n\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n#ifndef __OpenBSD__\n\tsc->sc_link.channel = SCSI_CHANNEL_ONLY_ONE;\n#endif\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->sc_scsi_dev;\n\tsc->sc_link.adapter = &uha_switch;\n\tsc->sc_link.device = &uha_dev;\n\tsc->sc_link.openings = 2;\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n#ifdef __OpenBSD__\n\tconfig_found(&sc->sc_dev, &sc->sc_link, uhaprint);\n#else\n\tconfig_found(&sc->sc_dev, &sc->sc_link, scsiprint);\n#endif\n}"
  },
  {
    "function_name": "uhaprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/uha.c",
    "lines": "120-129",
    "snippet": "int\nuhaprint(aux, name)\n\tvoid *aux;\n\tconst char *name;\n{\n\n\tif (name != NULL)\n\t\tprintf(\"%s: scsibus \", name);\n\treturn UNCONF;\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: scsibus \"",
            "name"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\nuhaprint(aux, name)\n\tvoid *aux;\n\tconst char *name;\n{\n\n\tif (name != NULL)\n\t\tprintf(\"%s: scsibus \", name);\n\treturn UNCONF;\n}"
  }
]