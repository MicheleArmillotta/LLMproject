[
  {
    "function_name": "wdc_atapi_reset_2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "1508-1536",
    "snippet": "int\nwdc_atapi_reset_2(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\t\n\tif (timeout) {\n\t\tprintf(\"%s:%d:%d: reset failed\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t    xfer->drive);\n\t\tsc_xfer->error = XS_SELTIMEOUT;\n\t\twdc_reset_channel(drvp);\n\t\t\n\t\txfer->next = wdc_atapi_done;\n\t\treturn (GOTO_NEXT);\n\t}\n\n\twdc_atapi_update_status(chp);\n\n\tif (chp->ch_status & (WDCS_BSY | WDCS_DRQ)) {\n\t\treturn (CONTINUE_POLL);\n\t}\n\n\txfer->next = wdc_atapi_done;\n\treturn (GOTO_NEXT);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define GOTO_NEXT 1",
      "#define CONTINUE_POLL 0"
    ],
    "globals_used": [
      "int   wdc_atapi_done",
      "int   wdc_atapi_reset_2",
      "void wdc_atapi_update_status",
      "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdc_atapi_update_status",
          "args": [
            "chp"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_atapi_update_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
          "lines": "733-747",
          "snippet": "void\nwdc_atapi_update_status(chp)\n\tstruct channel_softc *chp;\n{\n\tchp->ch_status = CHP_READ_REG(chp, wdr_status);\n\n\tif (chp->ch_status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n\n\t\tchp->ch_status = CHP_READ_REG(chp, wdr_status);\n\t}\n\n\tif ((chp->ch_status & (WDCS_BSY | WDCS_ERR)) == WDCS_ERR)\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n}",
          "includes": [
            "#include <dev/atapiscsi/atapiconf.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_tape.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/reboot.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void wdc_atapi_update_status"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wdc_atapi_update_status;\n\nvoid\nwdc_atapi_update_status(chp)\n\tstruct channel_softc *chp;\n{\n\tchp->ch_status = CHP_READ_REG(chp, wdr_status);\n\n\tif (chp->ch_status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n\n\t\tchp->ch_status = CHP_READ_REG(chp, wdr_status);\n\t}\n\n\tif ((chp->ch_status & (WDCS_BSY | WDCS_ERR)) == WDCS_ERR)\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_reset_channel",
          "args": [
            "drvp"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_reset_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "774-786",
          "snippet": "void wdc_reset_channel(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tint drive;\n\tWDCDEBUG_PRINT((\"ata_reset_channel %s:%d for drive %d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),\n\t    DEBUG_FUNCS);\n\t(void) wdcreset(chp, VERBOSE);\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tchp->ch_drive[drive].state = 0;\n\t}\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nvoid wdc_reset_channel(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tint drive;\n\tWDCDEBUG_PRINT((\"ata_reset_channel %s:%d for drive %d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),\n\t    DEBUG_FUNCS);\n\t(void) wdcreset(chp, VERBOSE);\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tchp->ch_drive[drive].state = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s:%d:%d: reset failed\\n\"",
            "chp->wdc->sc_dev.dv_xname",
            "chp->channel",
            "xfer->drive"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GOTO_NEXT 1\n#define CONTINUE_POLL 0\n\nint   wdc_atapi_done;\nint   wdc_atapi_reset_2;\nvoid wdc_atapi_update_status;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_reset_2(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\t\n\tif (timeout) {\n\t\tprintf(\"%s:%d:%d: reset failed\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t    xfer->drive);\n\t\tsc_xfer->error = XS_SELTIMEOUT;\n\t\twdc_reset_channel(drvp);\n\t\t\n\t\txfer->next = wdc_atapi_done;\n\t\treturn (GOTO_NEXT);\n\t}\n\n\twdc_atapi_update_status(chp);\n\n\tif (chp->ch_status & (WDCS_BSY | WDCS_DRQ)) {\n\t\treturn (CONTINUE_POLL);\n\t}\n\n\txfer->next = wdc_atapi_done;\n\treturn (GOTO_NEXT);\n}"
  },
  {
    "function_name": "wdc_atapi_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "1488-1506",
    "snippet": "int\nwdc_atapi_reset(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\n\twdccommandshort(chp, xfer->drive, ATAPI_SOFT_RESET);\n\tdrvp->state = 0;\n\n\t/* Some ATAPI devices need extra time to find their\n\t   brains after a reset\n\t */\n\txfer->next = wdc_atapi_reset_2;\n\txfer->delay = 10;\n\txfer->timeout = ATAPI_RESET_WAIT;\n\treturn (GOTO_NEXT);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define GOTO_NEXT 1",
      "#define ATAPI_RESET_WAIT 2000"
    ],
    "globals_used": [
      "int   wdc_atapi_reset",
      "int   wdc_atapi_reset_2",
      "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdccommandshort",
          "args": [
            "chp",
            "xfer->drive",
            "ATAPI_SOFT_RESET"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "wdccommandshort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1534-1548",
          "snippet": "void\nwdccommandshort(chp, drive, command)\n\tstruct channel_softc *chp;\n\tint drive;\n\tint command;\n{\n\n\tWDCDEBUG_PRINT((\"wdccommandshort %s:%d:%d command 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive, command),\n\t    DEBUG_FUNCS);\n\n\t/* Select drive. */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\tCHP_WRITE_REG(chp, wdr_command, command);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nvoid\nwdccommandshort(chp, drive, command)\n\tstruct channel_softc *chp;\n\tint drive;\n\tint command;\n{\n\n\tWDCDEBUG_PRINT((\"wdccommandshort %s:%d:%d command 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive, command),\n\t    DEBUG_FUNCS);\n\n\t/* Select drive. */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\tCHP_WRITE_REG(chp, wdr_command, command);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GOTO_NEXT 1\n#define ATAPI_RESET_WAIT 2000\n\nint   wdc_atapi_reset;\nint   wdc_atapi_reset_2;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_reset(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\n\twdccommandshort(chp, xfer->drive, ATAPI_SOFT_RESET);\n\tdrvp->state = 0;\n\n\t/* Some ATAPI devices need extra time to find their\n\t   brains after a reset\n\t */\n\txfer->next = wdc_atapi_reset_2;\n\txfer->delay = 10;\n\txfer->timeout = ATAPI_RESET_WAIT;\n\treturn (GOTO_NEXT);\n}"
  },
  {
    "function_name": "wdc_atapi_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "1453-1485",
    "snippet": "int\nwdc_atapi_done(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tint doing_dma = xfer->c_flags & C_DMA;\n\n\tWDCDEBUG_PRINT((\"wdc_atapi_done %s:%d:%d: flags 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t    (u_int)xfer->c_flags), DEBUG_XFERS);\n\n\tsc_xfer->flags |= ITSDONE;\n\tif (drvp->n_dmaerrs ||\n\t    (sc_xfer->error != XS_NOERROR && sc_xfer->error != XS_SENSE &&\n\t    sc_xfer->error != XS_SHORTSENSE)) {\n#if 0\n\t\tprintf(\"wdc_atapi_done: sc_xfer->error %d\\n\", sc_xfer->error);\n#endif\n\t\tdrvp->n_dmaerrs = 0;\n\t\tif (doing_dma)\n\t\t\twdc_downgrade_mode(drvp);\n\t}\n\n\tif (!(xfer->c_flags & C_POLL)) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_done: scsi_done\\n\"), DEBUG_XFERS);\n\t\tscsi_done(sc_xfer);\n\t}\n\n\treturn (DONE);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DONE 2",
      "#define DEBUG_XFERS  0x02"
    ],
    "globals_used": [
      "int   wdc_atapi_done",
      "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "sc_xfer"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_atapi_done: scsi_done\\n\")",
            "DEBUG_XFERS"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_downgrade_mode",
          "args": [
            "drvp"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_downgrade_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1252-1304",
          "snippet": "int\nwdc_downgrade_mode(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint cf_flags = drvp->cf_flags;\n\n\t/* if drive or controller don't know its mode, we can't do much */\n\tif ((drvp->drive_flags & DRIVE_MODE) == 0 ||\n\t    (wdc->cap & WDC_CAPABILITY_MODE) == 0)\n\t\treturn 0;\n\t/* current drive mode was set by a config flag, let it this way */\n\tif ((cf_flags & ATA_CONFIG_PIO_SET) ||\n\t    (cf_flags & ATA_CONFIG_DMA_SET) ||\n\t    (cf_flags & ATA_CONFIG_UDMA_SET))\n\t\treturn 0;\n\n\t/*\n\t * If we were using Ultra-DMA mode > 2, downgrade to mode 2 first.\n\t * Maybe we didn't properly notice the cable type\n\t */\n\tif ((drvp->drive_flags & DRIVE_UDMA) && drvp->UDMA_mode >= 2) {\n\t\tdrvp->UDMA_mode = (drvp->UDMA_mode == 2) ? 1 : 2;\n\t\tprintf(\"%s: transfer error, downgrading to Ultra-DMA mode %d\\n\",\n\t\t    drvp->drive_name, drvp->UDMA_mode);\n\t} else \tif ((drvp->drive_flags & DRIVE_UDMA) &&\n\t    (drvp->drive_flags & DRIVE_DMAERR) == 0) {\n\t\t/* \n\t\t * If we were using ultra-DMA, don't downgrade to\n\t\t * multiword DMA if we noticed a CRC error. It has\n\t\t * been noticed that CRC errors in ultra-DMA lead to\n\t\t * silent data corruption in multiword DMA.  Data\n\t\t * corruption is less likely to occur in PIO mode.  \n\t\t */\n\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\tdrvp->drive_flags |= DRIVE_DMA;\n\t\tdrvp->DMA_mode = drvp->DMA_cap;\n\t\tprintf(\"%s: transfer error, downgrading to DMA mode %d\\n\",\n\t\t    drvp->drive_name, drvp->DMA_mode);\n\t} else if (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA)) {\n\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\tdrvp->PIO_mode = drvp->PIO_cap;\n\t\tprintf(\"%s: transfer error, downgrading to PIO mode %d\\n\",\n\t\t    drvp->drive_name, drvp->PIO_mode);\n\t} else /* already using PIO, can't downgrade */\n\t\treturn 0;\n\n\twdc->set_modes(chp);\n\t/* reset the channel, which will schedule all drives for setup */\n\twdc_reset_channel(drvp);\n\treturn 1;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nwdc_downgrade_mode(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint cf_flags = drvp->cf_flags;\n\n\t/* if drive or controller don't know its mode, we can't do much */\n\tif ((drvp->drive_flags & DRIVE_MODE) == 0 ||\n\t    (wdc->cap & WDC_CAPABILITY_MODE) == 0)\n\t\treturn 0;\n\t/* current drive mode was set by a config flag, let it this way */\n\tif ((cf_flags & ATA_CONFIG_PIO_SET) ||\n\t    (cf_flags & ATA_CONFIG_DMA_SET) ||\n\t    (cf_flags & ATA_CONFIG_UDMA_SET))\n\t\treturn 0;\n\n\t/*\n\t * If we were using Ultra-DMA mode > 2, downgrade to mode 2 first.\n\t * Maybe we didn't properly notice the cable type\n\t */\n\tif ((drvp->drive_flags & DRIVE_UDMA) && drvp->UDMA_mode >= 2) {\n\t\tdrvp->UDMA_mode = (drvp->UDMA_mode == 2) ? 1 : 2;\n\t\tprintf(\"%s: transfer error, downgrading to Ultra-DMA mode %d\\n\",\n\t\t    drvp->drive_name, drvp->UDMA_mode);\n\t} else \tif ((drvp->drive_flags & DRIVE_UDMA) &&\n\t    (drvp->drive_flags & DRIVE_DMAERR) == 0) {\n\t\t/* \n\t\t * If we were using ultra-DMA, don't downgrade to\n\t\t * multiword DMA if we noticed a CRC error. It has\n\t\t * been noticed that CRC errors in ultra-DMA lead to\n\t\t * silent data corruption in multiword DMA.  Data\n\t\t * corruption is less likely to occur in PIO mode.  \n\t\t */\n\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\tdrvp->drive_flags |= DRIVE_DMA;\n\t\tdrvp->DMA_mode = drvp->DMA_cap;\n\t\tprintf(\"%s: transfer error, downgrading to DMA mode %d\\n\",\n\t\t    drvp->drive_name, drvp->DMA_mode);\n\t} else if (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA)) {\n\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\tdrvp->PIO_mode = drvp->PIO_cap;\n\t\tprintf(\"%s: transfer error, downgrading to PIO mode %d\\n\",\n\t\t    drvp->drive_name, drvp->PIO_mode);\n\t} else /* already using PIO, can't downgrade */\n\t\treturn 0;\n\n\twdc->set_modes(chp);\n\t/* reset the channel, which will schedule all drives for setup */\n\twdc_reset_channel(drvp);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"wdc_atapi_done: sc_xfer->error %d\\n\"",
            "sc_xfer->error"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_atapi_done %s:%d:%d: flags 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t    (u_int)xfer->c_flags)",
            "DEBUG_XFERS"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DONE 2\n#define DEBUG_XFERS  0x02\n\nint   wdc_atapi_done;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_done(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tint doing_dma = xfer->c_flags & C_DMA;\n\n\tWDCDEBUG_PRINT((\"wdc_atapi_done %s:%d:%d: flags 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t    (u_int)xfer->c_flags), DEBUG_XFERS);\n\n\tsc_xfer->flags |= ITSDONE;\n\tif (drvp->n_dmaerrs ||\n\t    (sc_xfer->error != XS_NOERROR && sc_xfer->error != XS_SENSE &&\n\t    sc_xfer->error != XS_SHORTSENSE)) {\n#if 0\n\t\tprintf(\"wdc_atapi_done: sc_xfer->error %d\\n\", sc_xfer->error);\n#endif\n\t\tdrvp->n_dmaerrs = 0;\n\t\tif (doing_dma)\n\t\t\twdc_downgrade_mode(drvp);\n\t}\n\n\tif (!(xfer->c_flags & C_POLL)) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_done: scsi_done\\n\"), DEBUG_XFERS);\n\t\tscsi_done(sc_xfer);\n\t}\n\n\treturn (DONE);\n}"
  },
  {
    "function_name": "wdc_atapi_tape_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "1427-1450",
    "snippet": "int\nwdc_atapi_tape_done(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\n\tif (sc_xfer->error != XS_NOERROR) {\n\t\txfer->next = wdc_atapi_done;\n\t\treturn (GOTO_NEXT);\n\t}\n\n\t_lto3b(xfer->transfer_len,\n\t    ((struct scsi_rw_tape *)\n\t\tsc_xfer->cmd)->len);\n\n\txfer->c_bcount = sc_xfer->datalen;\n\txfer->c_done = NULL;\n\txfer->c_skip = 0;\n\n\txfer->next = wdc_atapi_real_start;\n\treturn (GOTO_NEXT);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define GOTO_NEXT 1"
    ],
    "globals_used": [
      "int   wdc_atapi_real_start",
      "int   wdc_atapi_done",
      "int   wdc_atapi_tape_done",
      "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_lto3b",
          "args": [
            "xfer->transfer_len",
            "((struct scsi_rw_tape *)\n\t\tsc_xfer->cmd)->len"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GOTO_NEXT 1\n\nint   wdc_atapi_real_start;\nint   wdc_atapi_done;\nint   wdc_atapi_tape_done;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_tape_done(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\n\tif (sc_xfer->error != XS_NOERROR) {\n\t\txfer->next = wdc_atapi_done;\n\t\treturn (GOTO_NEXT);\n\t}\n\n\t_lto3b(xfer->transfer_len,\n\t    ((struct scsi_rw_tape *)\n\t\tsc_xfer->cmd)->len);\n\n\txfer->c_bcount = sc_xfer->datalen;\n\txfer->c_done = NULL;\n\txfer->c_skip = 0;\n\n\txfer->next = wdc_atapi_real_start;\n\treturn (GOTO_NEXT);\n}"
  },
  {
    "function_name": "wdc_atapi_ctrl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "1264-1425",
    "snippet": "int\nwdc_atapi_ctrl(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tchar *errstring = NULL;\n\n\tswitch (drvp->state) {\n\tcase IDENTIFY:\n\tcase IDENTIFY_WAIT:\n\t\terrstring = \"IDENTIFY\";\n\t\tbreak;\n\t\t\n\tcase PIOMODE:\n\t\terrstring = \"Post IDENTIFY\";\n\t\tbreak;\n\n\tcase PIOMODE_WAIT:\n\t\terrstring = \"PIOMODE\";\n\t\tbreak;\n\tcase DMAMODE_WAIT:\n\t\terrstring = \"dmamode\";\n\t\tbreak;\n\tdefault:\n\t\terrstring = \"unknown state\";\n\t\tbreak;\n\t}\n\n\tif (timeout) {\n\t\tif (drvp->state != IDENTIFY)\n\t\t\tgoto timeout;\n\t\telse {\n#ifdef DIAGNOSTIC\n\t\t\tprintf (\"wdc_atapi_ctrl: timeout before IDENTIFY.\"\n\t\t\t    \"Should not happen\\n\");\n#endif\n\t\t\tsc_xfer->error = XS_DRIVER_STUFFUP;\n\t\t\txfer->next = wdc_atapi_done;\n\t\t\treturn (GOTO_NEXT);\n\t\t}\n\t}\n\n\twdc_atapi_update_status(chp);\n\n\tif (chp->ch_status & WDCS_BSY)\n\t\treturn (CONTINUE_POLL);\n\n\tif (!wdc_atapi_drive_selected(chp, xfer->drive))\n\t{\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\t\tdelay (1);\n\n\t\treturn (CONTINUE_POLL);\n\t}\n\n\n\txfer->claim_irq = 1;\n\n\tWDCDEBUG_PRINT((\"wdc_atapi_ctrl %s:%d:%d state %d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive, drvp->state),\n\t    DEBUG_INTR | DEBUG_FUNCS);\n\n\tswitch (drvp->state) {\n\t\t/* You need to send an ATAPI drive an ATAPI-specific\n\t\t   command to revive it after a hard reset. Identify\n\t\t   is about the most innocuous thing you can do\n\t\t   that's guaranteed to be there */\n\tcase IDENTIFY:\n\t\twdccommandshort(chp, drvp->drive, ATAPI_IDENTIFY_DEVICE);\n\t\tdrvp->state = IDENTIFY_WAIT;\n\t\txfer->timeout = ATAPI_CTRL_WAIT;\n\t\txfer->expect_irq = 1;\n\t\tbreak;\n\t\n\tcase IDENTIFY_WAIT:\n\t\t/* We don't really care if this operation failed.\n\t\t   It's just there to wake the drive from its stupor. */\n\t\tif (!(chp->ch_status & WDCS_ERR)) {\n\t\t\twdcbit_bucket(chp, 512);\n\t\n\t\t\txfer->timeout = 100;\n\t\t\tdrvp->state = PIOMODE;\n\t\t\tbreak;\n\t\t}\n\n\t\tdrvp->state = PIOMODE;\n\n\tcase PIOMODE:\npiomode:\n\t\t/* Don't try to set mode if controller can't be adjusted */\n\t\tif ((chp->wdc->cap & WDC_CAPABILITY_MODE) == 0)\n\t\t\tgoto ready;\n\t\t/* Also don't try if the drive didn't report its mode */\n\t\tif ((drvp->drive_flags & DRIVE_MODE) == 0)\n\t\t\tgoto ready;\n\t\twdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,\n\t\t    0x08 | drvp->PIO_mode, WDSF_SET_MODE);\n\t\tdrvp->state = PIOMODE_WAIT;\n\t\txfer->timeout = ATAPI_CTRL_WAIT;\n\t\txfer->expect_irq = 1;\n\t\tbreak;\n\tcase PIOMODE_WAIT:\n\t\tif (chp->ch_status & WDCS_ERR) {\n\t\t\tif (drvp->PIO_mode < 3) {\n\t\t\t\tdrvp->PIO_mode = 3;\n\t\t\t\tgoto piomode;\n\t\t\t} else {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t/* fall through */\n\n\tcase DMAMODE:\n\t\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\t\twdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,\n\t\t\t    0x40 | drvp->UDMA_mode, WDSF_SET_MODE);\n\t\t} else if (drvp->drive_flags & DRIVE_DMA) {\n\t\t\twdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,\n\t\t\t    0x20 | drvp->DMA_mode, WDSF_SET_MODE);\n\t\t} else {\n\t\t\tgoto ready;\n\t\t}\n\t\tdrvp->state = DMAMODE_WAIT;\n\n\t\txfer->timeout = ATAPI_CTRL_WAIT;\n\t\txfer->expect_irq = 1;\n\t\tbreak;\n\n\tcase DMAMODE_WAIT:\n\t\tif (chp->ch_status & WDCS_ERR)\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t/* fall through */\n\n\tcase READY:\n\tready:\n\t\tdrvp->state = READY;\n\t\txfer->next = wdc_atapi_real_start;\n\t\tbreak;\n\t}\n\treturn (GOTO_NEXT);\n\ntimeout:\n\tprintf(\"%s:%d:%d: %s timed out\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, errstring);\n\tsc_xfer->error = XS_TIMEOUT;\n\txfer->next = wdc_atapi_reset;\n\treturn (GOTO_NEXT);\n\nerror:\n\tprintf(\"%s:%d:%d: %s \",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t    errstring);\n\tprintf(\"error (0x%x)\\n\", chp->ch_error);\n\n\tsc_xfer->error = XS_DRIVER_STUFFUP;\n\n\txfer->next = wdc_atapi_reset;\n\treturn (GOTO_NEXT);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define GOTO_NEXT 1",
      "#define CONTINUE_POLL 0",
      "#define ATAPI_CTRL_WAIT 4000",
      "#define DEBUG_FUNCS  0x08",
      "#define DEBUG_INTR   0x01"
    ],
    "globals_used": [
      "int   wdc_atapi_real_start",
      "int   wdc_atapi_ctrl",
      "int   wdc_atapi_done",
      "int   wdc_atapi_reset",
      "int wdc_atapi_drive_selected",
      "void wdc_atapi_update_status",
      "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"error (0x%x)\\n\"",
            "chp->ch_error"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdccommand",
          "args": [
            "chp",
            "drvp->drive",
            "SET_FEATURES",
            "0",
            "0",
            "0",
            "0x20 | drvp->DMA_mode",
            "WDSF_SET_MODE"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "wdccommandshort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1534-1548",
          "snippet": "void\nwdccommandshort(chp, drive, command)\n\tstruct channel_softc *chp;\n\tint drive;\n\tint command;\n{\n\n\tWDCDEBUG_PRINT((\"wdccommandshort %s:%d:%d command 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive, command),\n\t    DEBUG_FUNCS);\n\n\t/* Select drive. */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\tCHP_WRITE_REG(chp, wdr_command, command);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nvoid\nwdccommandshort(chp, drive, command)\n\tstruct channel_softc *chp;\n\tint drive;\n\tint command;\n{\n\n\tWDCDEBUG_PRINT((\"wdccommandshort %s:%d:%d command 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive, command),\n\t    DEBUG_FUNCS);\n\n\t/* Select drive. */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\tCHP_WRITE_REG(chp, wdr_command, command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdcbit_bucket",
          "args": [
            "chp",
            "512"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "wdcbit_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1672-1678",
          "snippet": "void\nwdcbit_bucket(chp, size)\n\tstruct channel_softc *chp; \n\tint size;\n{\n\tCHP_READ_RAW_MULTI_2(chp, NULL, size);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdcbit_bucket(chp, size)\n\tstruct channel_softc *chp; \n\tint size;\n{\n\tCHP_READ_RAW_MULTI_2(chp, NULL, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_atapi_ctrl %s:%d:%d state %d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive, drvp->state)",
            "DEBUG_INTR | DEBUG_FUNCS"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM | (xfer->drive << 4)"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_atapi_drive_selected",
          "args": [
            "chp",
            "xfer->drive"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_atapi_drive_selected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
          "lines": "544-552",
          "snippet": "int\nwdc_atapi_drive_selected(chp, drive)\n\tstruct channel_softc *chp;\n\tint drive;\n{\n\tu_int8_t reg = CHP_READ_REG(chp, wdr_sdh);\n\n\treturn ((reg & 0x10) == (drive << 4));\n}",
          "includes": [
            "#include <dev/atapiscsi/atapiconf.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_tape.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/reboot.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wdc_atapi_drive_selected"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wdc_atapi_drive_selected;\n\nint\nwdc_atapi_drive_selected(chp, drive)\n\tstruct channel_softc *chp;\n\tint drive;\n{\n\tu_int8_t reg = CHP_READ_REG(chp, wdr_sdh);\n\n\treturn ((reg & 0x10) == (drive << 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_atapi_update_status",
          "args": [
            "chp"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_atapi_update_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
          "lines": "733-747",
          "snippet": "void\nwdc_atapi_update_status(chp)\n\tstruct channel_softc *chp;\n{\n\tchp->ch_status = CHP_READ_REG(chp, wdr_status);\n\n\tif (chp->ch_status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n\n\t\tchp->ch_status = CHP_READ_REG(chp, wdr_status);\n\t}\n\n\tif ((chp->ch_status & (WDCS_BSY | WDCS_ERR)) == WDCS_ERR)\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n}",
          "includes": [
            "#include <dev/atapiscsi/atapiconf.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_tape.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/reboot.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void wdc_atapi_update_status"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wdc_atapi_update_status;\n\nvoid\nwdc_atapi_update_status(chp)\n\tstruct channel_softc *chp;\n{\n\tchp->ch_status = CHP_READ_REG(chp, wdr_status);\n\n\tif (chp->ch_status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n\n\t\tchp->ch_status = CHP_READ_REG(chp, wdr_status);\n\t}\n\n\tif ((chp->ch_status & (WDCS_BSY | WDCS_ERR)) == WDCS_ERR)\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GOTO_NEXT 1\n#define CONTINUE_POLL 0\n#define ATAPI_CTRL_WAIT 4000\n#define DEBUG_FUNCS  0x08\n#define DEBUG_INTR   0x01\n\nint   wdc_atapi_real_start;\nint   wdc_atapi_ctrl;\nint   wdc_atapi_done;\nint   wdc_atapi_reset;\nint wdc_atapi_drive_selected;\nvoid wdc_atapi_update_status;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_ctrl(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tchar *errstring = NULL;\n\n\tswitch (drvp->state) {\n\tcase IDENTIFY:\n\tcase IDENTIFY_WAIT:\n\t\terrstring = \"IDENTIFY\";\n\t\tbreak;\n\t\t\n\tcase PIOMODE:\n\t\terrstring = \"Post IDENTIFY\";\n\t\tbreak;\n\n\tcase PIOMODE_WAIT:\n\t\terrstring = \"PIOMODE\";\n\t\tbreak;\n\tcase DMAMODE_WAIT:\n\t\terrstring = \"dmamode\";\n\t\tbreak;\n\tdefault:\n\t\terrstring = \"unknown state\";\n\t\tbreak;\n\t}\n\n\tif (timeout) {\n\t\tif (drvp->state != IDENTIFY)\n\t\t\tgoto timeout;\n\t\telse {\n#ifdef DIAGNOSTIC\n\t\t\tprintf (\"wdc_atapi_ctrl: timeout before IDENTIFY.\"\n\t\t\t    \"Should not happen\\n\");\n#endif\n\t\t\tsc_xfer->error = XS_DRIVER_STUFFUP;\n\t\t\txfer->next = wdc_atapi_done;\n\t\t\treturn (GOTO_NEXT);\n\t\t}\n\t}\n\n\twdc_atapi_update_status(chp);\n\n\tif (chp->ch_status & WDCS_BSY)\n\t\treturn (CONTINUE_POLL);\n\n\tif (!wdc_atapi_drive_selected(chp, xfer->drive))\n\t{\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\t\tdelay (1);\n\n\t\treturn (CONTINUE_POLL);\n\t}\n\n\n\txfer->claim_irq = 1;\n\n\tWDCDEBUG_PRINT((\"wdc_atapi_ctrl %s:%d:%d state %d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive, drvp->state),\n\t    DEBUG_INTR | DEBUG_FUNCS);\n\n\tswitch (drvp->state) {\n\t\t/* You need to send an ATAPI drive an ATAPI-specific\n\t\t   command to revive it after a hard reset. Identify\n\t\t   is about the most innocuous thing you can do\n\t\t   that's guaranteed to be there */\n\tcase IDENTIFY:\n\t\twdccommandshort(chp, drvp->drive, ATAPI_IDENTIFY_DEVICE);\n\t\tdrvp->state = IDENTIFY_WAIT;\n\t\txfer->timeout = ATAPI_CTRL_WAIT;\n\t\txfer->expect_irq = 1;\n\t\tbreak;\n\t\n\tcase IDENTIFY_WAIT:\n\t\t/* We don't really care if this operation failed.\n\t\t   It's just there to wake the drive from its stupor. */\n\t\tif (!(chp->ch_status & WDCS_ERR)) {\n\t\t\twdcbit_bucket(chp, 512);\n\t\n\t\t\txfer->timeout = 100;\n\t\t\tdrvp->state = PIOMODE;\n\t\t\tbreak;\n\t\t}\n\n\t\tdrvp->state = PIOMODE;\n\n\tcase PIOMODE:\npiomode:\n\t\t/* Don't try to set mode if controller can't be adjusted */\n\t\tif ((chp->wdc->cap & WDC_CAPABILITY_MODE) == 0)\n\t\t\tgoto ready;\n\t\t/* Also don't try if the drive didn't report its mode */\n\t\tif ((drvp->drive_flags & DRIVE_MODE) == 0)\n\t\t\tgoto ready;\n\t\twdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,\n\t\t    0x08 | drvp->PIO_mode, WDSF_SET_MODE);\n\t\tdrvp->state = PIOMODE_WAIT;\n\t\txfer->timeout = ATAPI_CTRL_WAIT;\n\t\txfer->expect_irq = 1;\n\t\tbreak;\n\tcase PIOMODE_WAIT:\n\t\tif (chp->ch_status & WDCS_ERR) {\n\t\t\tif (drvp->PIO_mode < 3) {\n\t\t\t\tdrvp->PIO_mode = 3;\n\t\t\t\tgoto piomode;\n\t\t\t} else {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t/* fall through */\n\n\tcase DMAMODE:\n\t\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\t\twdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,\n\t\t\t    0x40 | drvp->UDMA_mode, WDSF_SET_MODE);\n\t\t} else if (drvp->drive_flags & DRIVE_DMA) {\n\t\t\twdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,\n\t\t\t    0x20 | drvp->DMA_mode, WDSF_SET_MODE);\n\t\t} else {\n\t\t\tgoto ready;\n\t\t}\n\t\tdrvp->state = DMAMODE_WAIT;\n\n\t\txfer->timeout = ATAPI_CTRL_WAIT;\n\t\txfer->expect_irq = 1;\n\t\tbreak;\n\n\tcase DMAMODE_WAIT:\n\t\tif (chp->ch_status & WDCS_ERR)\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t/* fall through */\n\n\tcase READY:\n\tready:\n\t\tdrvp->state = READY;\n\t\txfer->next = wdc_atapi_real_start;\n\t\tbreak;\n\t}\n\treturn (GOTO_NEXT);\n\ntimeout:\n\tprintf(\"%s:%d:%d: %s timed out\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, errstring);\n\tsc_xfer->error = XS_TIMEOUT;\n\txfer->next = wdc_atapi_reset;\n\treturn (GOTO_NEXT);\n\nerror:\n\tprintf(\"%s:%d:%d: %s \",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t    errstring);\n\tprintf(\"error (0x%x)\\n\", chp->ch_error);\n\n\tsc_xfer->error = XS_DRIVER_STUFFUP;\n\n\txfer->next = wdc_atapi_reset;\n\treturn (GOTO_NEXT);\n}"
  },
  {
    "function_name": "wdc_atapi_intr_for_us",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "1205-1262",
    "snippet": "int\nwdc_atapi_intr_for_us(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tstruct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;\n\n\tWDCDEBUG_PRINT((\"ATAPI_INTR\\n\"), DEBUG_INTR);\n\n\twdc_atapi_update_status(chp);\n\n\tif (timeout) {\n\t\tprintf(\"%s:%d:%d: device timeout, c_bcount=%d, c_skip=%d\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t\t    xfer->c_bcount, xfer->c_skip);\n\n\t\tif (xfer->c_flags & C_DMA)\n\t\t\tdrvp->n_dmaerrs++;\n\t\t\n\t\tsc_xfer->error = XS_TIMEOUT;\n\t\txfer->next = wdc_atapi_reset;\n\t\treturn (GOTO_NEXT);\n\t}\n\n\n\tif (chp->ch_status & WDCS_BSY)\n\t\treturn (CONTINUE_POLL);\n\n\tif (!wdc_atapi_drive_selected(chp, xfer->drive))\n\t{\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\t\tdelay (1);\n\n\t\treturn (CONTINUE_POLL);\n\t}\n\n\tif (as->protocol_phase != as_cmdout &&\n\t    (xfer->c_flags & C_MEDIA_ACCESS) &&\n\t    !(chp->ch_status & WDCS_DSC)) {\n\t\txfer->delay = 100;\n\t\treturn (CONTINUE_POLL);\n\t}\n\n\txfer->claim_irq = 1;\n\n\tif (chp->ch_status & WDCS_DRQ) {\n\t\tif (as->protocol_phase == as_cmdout)\n\t\t\treturn (wdc_atapi_intr_command(chp, xfer, timeout));\n\n\t\treturn (wdc_atapi_intr_data(chp, xfer, timeout));\n\t}\n\t\n\treturn (wdc_atapi_intr_complete(chp, xfer, timeout));\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define GOTO_NEXT 1",
      "#define CONTINUE_POLL 0",
      "#define DEBUG_INTR   0x01"
    ],
    "globals_used": [
      "int   wdc_atapi_intr_command",
      "int   wdc_atapi_intr_data",
      "int   wdc_atapi_intr_complete",
      "int   wdc_atapi_intr_for_us",
      "int   wdc_atapi_reset",
      "int wdc_atapi_drive_selected",
      "void wdc_atapi_update_status",
      "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdc_atapi_intr_complete",
          "args": [
            "chp",
            "xfer",
            "timeout"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_atapi_intr_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
          "lines": "1095-1203",
          "snippet": "int\nwdc_atapi_intr_complete(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tstruct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;\n\tint dma_err = 0;\n\tint dma_flags = wdc_atapi_dma_flags(xfer);\n\n\tWDCDEBUG_PRINT((\"PHASE_COMPLETED\\n\"), DEBUG_INTR);\n\n\t/* turn off DMA channel */\n\tif (as->protocol_phase == as_data &&\n\t    xfer->c_flags & C_DMA) {\n\t\tdma_err = (*chp->wdc->dma_finish)(chp->wdc->dma_arg,\n\t\t     chp->channel, xfer->drive, dma_flags);\n\n\t\t/* Assume everything was transferred */\n\t\txfer->c_bcount = 0;\n\t}\n\n\tas->protocol_phase = as_none;\n\n\tif (xfer->c_flags & C_SENSE) {\n\t\tif (chp->ch_status & WDCS_ERR) {\n\t\t\tif (chp->ch_error & WDCE_ABRT) {\n\t\t\t\tWDCDEBUG_PRINT((\"wdc_atapi_intr: request_sense aborted, \"\n\t\t\t\t\t\t\"calling wdc_atapi_done()\"\n\t\t\t\t\t), DEBUG_INTR);\n\t\t\t\txfer->next = wdc_atapi_done;\n\t\t\t\treturn (GOTO_NEXT);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * request sense failed ! it's not suppossed\n \t\t\t * to be possible\n\t\t\t */\n\n\t\t\tsc_xfer->error = XS_RESET;\n\t\t\txfer->next = wdc_atapi_reset;\n\t\t\treturn (GOTO_NEXT);\n\n\t\t} else if (xfer->c_bcount < sizeof(sc_xfer->sense)) {\n\t\t\t\t/* use the sense we just read */\n\t\t\tsc_xfer->error = XS_SENSE;\n\t\t} else {\n\t\t\t/*\n\t\t\t * command completed, but no data was read.\n\t\t\t * use the short sense we saved previsouly.\n\t\t\t */\n\t\t\tsc_xfer->error = XS_SHORTSENSE;\n\t\t}\n\t} else {\n\t\tsc_xfer->resid = xfer->c_bcount;\n\t\tif (chp->ch_status & WDCS_ERR) {\n\t\t\tif (!atapi_to_scsi_sense(sc_xfer, chp->ch_error) &&\n\t\t\t    (sc_xfer->sc_link->quirks &\n\t\t\t     ADEV_NOSENSE) == 0) {\n\t\t\t\t/*\n\t\t\t\t * let the driver issue a\n\t\t\t\t * 'request sense'\n\t\t\t\t */\n\t\t\t\txfer->databuf = &sc_xfer->sense;\n\t\t\t\txfer->c_bcount = sizeof(sc_xfer->sense);\n\t\t\t\txfer->c_skip = 0;\n\t\t\t\txfer->c_done = NULL;\n\t\t\t\txfer->c_flags |= C_SENSE;\n\t\t\t\txfer->next = wdc_atapi_real_start;\n\t\t\t\treturn (GOTO_NEXT);\n\t\t\t}\n\t\t}\t\t\n\t}\n\n        if (dma_err < 0) { \n\t\tdrvp->n_dmaerrs++;\n\t\tsc_xfer->error = XS_RESET;\n\n\t\txfer->next = wdc_atapi_reset;\n\t\treturn (GOTO_NEXT);\n\t}\n\t\t\t\n\n\tif (xfer->c_bcount != 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_intr: bcount value is \"\n\t\t\t\t\"%d after io\\n\", xfer->c_bcount), DEBUG_XFERS);\n\t}\n#ifdef DIAGNOSTIC\n\tif (xfer->c_bcount < 0) {\n\t\tprintf(\"wdc_atapi_intr warning: bcount value \"\n\t\t       \"is %d after io\\n\", xfer->c_bcount);\n\t}\n#endif\n\n\tWDCDEBUG_PRINT((\"wdc_atapi_intr: wdc_atapi_done() (end), error 0x%x \"\n\t\t\t\"\\n\", sc_xfer->error),\n\t\t       DEBUG_INTR);\n\n\n\tif (xfer->c_done) \n\t\txfer->next = xfer->c_done;\n\telse \n\t\txfer->next = wdc_atapi_done;\n\n\treturn (GOTO_NEXT);\n}",
          "includes": [
            "#include <dev/atapiscsi/atapiconf.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_tape.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/reboot.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define GOTO_NEXT 1",
            "#define DEBUG_XFERS  0x02",
            "#define DEBUG_INTR   0x01"
          ],
          "globals_used": [
            "int   wdc_atapi_real_start",
            "int   wdc_atapi_intr_complete",
            "int   wdc_atapi_dma_flags",
            "int   wdc_atapi_intr",
            "int   wdc_atapi_done",
            "int   wdc_atapi_reset",
            "int     atapi_to_scsi_sense",
            "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GOTO_NEXT 1\n#define DEBUG_XFERS  0x02\n#define DEBUG_INTR   0x01\n\nint   wdc_atapi_real_start;\nint   wdc_atapi_intr_complete;\nint   wdc_atapi_dma_flags;\nint   wdc_atapi_intr;\nint   wdc_atapi_done;\nint   wdc_atapi_reset;\nint     atapi_to_scsi_sense;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_intr_complete(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tstruct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;\n\tint dma_err = 0;\n\tint dma_flags = wdc_atapi_dma_flags(xfer);\n\n\tWDCDEBUG_PRINT((\"PHASE_COMPLETED\\n\"), DEBUG_INTR);\n\n\t/* turn off DMA channel */\n\tif (as->protocol_phase == as_data &&\n\t    xfer->c_flags & C_DMA) {\n\t\tdma_err = (*chp->wdc->dma_finish)(chp->wdc->dma_arg,\n\t\t     chp->channel, xfer->drive, dma_flags);\n\n\t\t/* Assume everything was transferred */\n\t\txfer->c_bcount = 0;\n\t}\n\n\tas->protocol_phase = as_none;\n\n\tif (xfer->c_flags & C_SENSE) {\n\t\tif (chp->ch_status & WDCS_ERR) {\n\t\t\tif (chp->ch_error & WDCE_ABRT) {\n\t\t\t\tWDCDEBUG_PRINT((\"wdc_atapi_intr: request_sense aborted, \"\n\t\t\t\t\t\t\"calling wdc_atapi_done()\"\n\t\t\t\t\t), DEBUG_INTR);\n\t\t\t\txfer->next = wdc_atapi_done;\n\t\t\t\treturn (GOTO_NEXT);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * request sense failed ! it's not suppossed\n \t\t\t * to be possible\n\t\t\t */\n\n\t\t\tsc_xfer->error = XS_RESET;\n\t\t\txfer->next = wdc_atapi_reset;\n\t\t\treturn (GOTO_NEXT);\n\n\t\t} else if (xfer->c_bcount < sizeof(sc_xfer->sense)) {\n\t\t\t\t/* use the sense we just read */\n\t\t\tsc_xfer->error = XS_SENSE;\n\t\t} else {\n\t\t\t/*\n\t\t\t * command completed, but no data was read.\n\t\t\t * use the short sense we saved previsouly.\n\t\t\t */\n\t\t\tsc_xfer->error = XS_SHORTSENSE;\n\t\t}\n\t} else {\n\t\tsc_xfer->resid = xfer->c_bcount;\n\t\tif (chp->ch_status & WDCS_ERR) {\n\t\t\tif (!atapi_to_scsi_sense(sc_xfer, chp->ch_error) &&\n\t\t\t    (sc_xfer->sc_link->quirks &\n\t\t\t     ADEV_NOSENSE) == 0) {\n\t\t\t\t/*\n\t\t\t\t * let the driver issue a\n\t\t\t\t * 'request sense'\n\t\t\t\t */\n\t\t\t\txfer->databuf = &sc_xfer->sense;\n\t\t\t\txfer->c_bcount = sizeof(sc_xfer->sense);\n\t\t\t\txfer->c_skip = 0;\n\t\t\t\txfer->c_done = NULL;\n\t\t\t\txfer->c_flags |= C_SENSE;\n\t\t\t\txfer->next = wdc_atapi_real_start;\n\t\t\t\treturn (GOTO_NEXT);\n\t\t\t}\n\t\t}\t\t\n\t}\n\n        if (dma_err < 0) { \n\t\tdrvp->n_dmaerrs++;\n\t\tsc_xfer->error = XS_RESET;\n\n\t\txfer->next = wdc_atapi_reset;\n\t\treturn (GOTO_NEXT);\n\t}\n\t\t\t\n\n\tif (xfer->c_bcount != 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_intr: bcount value is \"\n\t\t\t\t\"%d after io\\n\", xfer->c_bcount), DEBUG_XFERS);\n\t}\n#ifdef DIAGNOSTIC\n\tif (xfer->c_bcount < 0) {\n\t\tprintf(\"wdc_atapi_intr warning: bcount value \"\n\t\t       \"is %d after io\\n\", xfer->c_bcount);\n\t}\n#endif\n\n\tWDCDEBUG_PRINT((\"wdc_atapi_intr: wdc_atapi_done() (end), error 0x%x \"\n\t\t\t\"\\n\", sc_xfer->error),\n\t\t       DEBUG_INTR);\n\n\n\tif (xfer->c_done) \n\t\txfer->next = xfer->c_done;\n\telse \n\t\txfer->next = wdc_atapi_done;\n\n\treturn (GOTO_NEXT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_atapi_intr_data",
          "args": [
            "chp",
            "xfer",
            "timeout"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_atapi_intr_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
          "lines": "1010-1092",
          "snippet": "int\nwdc_atapi_intr_data(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tint len, ire;\n\tchar *message;\n\n\tlen = (CHP_READ_REG(chp, wdr_cyl_hi) << 8) |\n\t    CHP_READ_REG(chp, wdr_cyl_lo);\n\tire = CHP_READ_REG(chp, wdr_ireason);\n\n\tif ((message = wdc_atapi_in_data_phase(xfer, len, ire))) {\n\t\t/* The drive has dropped BSY before setting up the\n\t\t   registers correctly for DATA phase. This drive is\n\t\t   not compliant with ATA/ATAPI-4.\n\n\t\t   Give the drive 100ms to get its house in order\n\t\t   before we try again.  */\n\t\tif (!timeout) {\n\t\t\txfer->delay = 100;\n\t\t\treturn (CONTINUE_POLL);\t\n\t\t}\n\t}\n\n\tif (timeout) {\n\t\tprintf (\"wdc_atapi_intr_data: error: %s\\n\", message);\n\t\t\n\t\tsc_xfer->error = XS_RESET;\n\t\txfer->next = wdc_atapi_reset;\n\t\treturn (GOTO_NEXT);\n\t}\n\n\t\n\tif (xfer->c_bcount >= len) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_intr: c_bcount %d len %d \"\n\t\t    \"st 0x%x err 0x%x \"\n\t\t    \"ire 0x%x\\n\", xfer->c_bcount,\n\t\t    len, chp->ch_status, chp->ch_error, ire), DEBUG_INTR);\n\t\t\n\t\t/* Common case */\n\t\tif (sc_xfer->flags & SCSI_DATA_OUT)\n\t\t\twdc_output_bytes(drvp, (u_int8_t *)xfer->databuf +\n\t\t\t    xfer->c_skip, len);\n\t\telse\n\t\t\twdc_input_bytes(drvp, (u_int8_t *)xfer->databuf +\n\t\t\t    xfer->c_skip, len);\n\n\t\txfer->c_skip += len;\n\t\txfer->c_bcount -= len;\n\t} else {\n\t\t/* Exceptional case */\n\t\tif (sc_xfer->flags & SCSI_DATA_OUT) {\n\t\t\tprintf(\"wdc_atapi_intr: warning: write only \"\n\t\t\t    \"%d of %d requested bytes\\n\", xfer->c_bcount, len);\n\n\t\t\twdc_output_bytes(drvp, (u_int8_t *)xfer->databuf +\n\t\t\t    xfer->c_skip, xfer->c_bcount);\n\t\t\t \n\t\t\tCHP_WRITE_RAW_MULTI_2(chp, NULL, \n\t\t\t    len - xfer->c_bcount);\n\t\t} else {\n\t\t\tprintf(\"wdc_atapi_intr: warning: reading only \"\n\t\t\t    \"%d of %d bytes\\n\", xfer->c_bcount, len);\n\t\t\t \n\t\t\twdc_input_bytes(drvp,\n\t\t\t    (char *)xfer->databuf + xfer->c_skip,\n\t\t\t    xfer->c_bcount);\n\t\t\twdcbit_bucket(chp, len - xfer->c_bcount);\n\t\t}\n\n\t\txfer->c_skip += xfer->c_bcount;\n\t\txfer->c_bcount = 0;\n\t}\n\n\txfer->expect_irq = 1;\n\txfer->next = wdc_atapi_intr_for_us;\n\n\treturn (GOTO_NEXT);\n}",
          "includes": [
            "#include <dev/atapiscsi/atapiconf.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_tape.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/reboot.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define GOTO_NEXT 1",
            "#define CONTINUE_POLL 0",
            "#define DEBUG_INTR   0x01"
          ],
          "globals_used": [
            "int   wdc_atapi_intr_data",
            "int   wdc_atapi_intr_for_us",
            "char  *wdc_atapi_in_data_phase",
            "int   wdc_atapi_intr",
            "int   wdc_atapi_reset",
            "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;",
            "int len, ire;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GOTO_NEXT 1\n#define CONTINUE_POLL 0\n#define DEBUG_INTR   0x01\n\nint   wdc_atapi_intr_data;\nint   wdc_atapi_intr_for_us;\nchar  *wdc_atapi_in_data_phase;\nint   wdc_atapi_intr;\nint   wdc_atapi_reset;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\nint len, ire;\n\nint\nwdc_atapi_intr_data(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tint len, ire;\n\tchar *message;\n\n\tlen = (CHP_READ_REG(chp, wdr_cyl_hi) << 8) |\n\t    CHP_READ_REG(chp, wdr_cyl_lo);\n\tire = CHP_READ_REG(chp, wdr_ireason);\n\n\tif ((message = wdc_atapi_in_data_phase(xfer, len, ire))) {\n\t\t/* The drive has dropped BSY before setting up the\n\t\t   registers correctly for DATA phase. This drive is\n\t\t   not compliant with ATA/ATAPI-4.\n\n\t\t   Give the drive 100ms to get its house in order\n\t\t   before we try again.  */\n\t\tif (!timeout) {\n\t\t\txfer->delay = 100;\n\t\t\treturn (CONTINUE_POLL);\t\n\t\t}\n\t}\n\n\tif (timeout) {\n\t\tprintf (\"wdc_atapi_intr_data: error: %s\\n\", message);\n\t\t\n\t\tsc_xfer->error = XS_RESET;\n\t\txfer->next = wdc_atapi_reset;\n\t\treturn (GOTO_NEXT);\n\t}\n\n\t\n\tif (xfer->c_bcount >= len) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_intr: c_bcount %d len %d \"\n\t\t    \"st 0x%x err 0x%x \"\n\t\t    \"ire 0x%x\\n\", xfer->c_bcount,\n\t\t    len, chp->ch_status, chp->ch_error, ire), DEBUG_INTR);\n\t\t\n\t\t/* Common case */\n\t\tif (sc_xfer->flags & SCSI_DATA_OUT)\n\t\t\twdc_output_bytes(drvp, (u_int8_t *)xfer->databuf +\n\t\t\t    xfer->c_skip, len);\n\t\telse\n\t\t\twdc_input_bytes(drvp, (u_int8_t *)xfer->databuf +\n\t\t\t    xfer->c_skip, len);\n\n\t\txfer->c_skip += len;\n\t\txfer->c_bcount -= len;\n\t} else {\n\t\t/* Exceptional case */\n\t\tif (sc_xfer->flags & SCSI_DATA_OUT) {\n\t\t\tprintf(\"wdc_atapi_intr: warning: write only \"\n\t\t\t    \"%d of %d requested bytes\\n\", xfer->c_bcount, len);\n\n\t\t\twdc_output_bytes(drvp, (u_int8_t *)xfer->databuf +\n\t\t\t    xfer->c_skip, xfer->c_bcount);\n\t\t\t \n\t\t\tCHP_WRITE_RAW_MULTI_2(chp, NULL, \n\t\t\t    len - xfer->c_bcount);\n\t\t} else {\n\t\t\tprintf(\"wdc_atapi_intr: warning: reading only \"\n\t\t\t    \"%d of %d bytes\\n\", xfer->c_bcount, len);\n\t\t\t \n\t\t\twdc_input_bytes(drvp,\n\t\t\t    (char *)xfer->databuf + xfer->c_skip,\n\t\t\t    xfer->c_bcount);\n\t\t\twdcbit_bucket(chp, len - xfer->c_bcount);\n\t\t}\n\n\t\txfer->c_skip += xfer->c_bcount;\n\t\txfer->c_bcount = 0;\n\t}\n\n\txfer->expect_irq = 1;\n\txfer->next = wdc_atapi_intr_for_us;\n\n\treturn (GOTO_NEXT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_atapi_intr_command",
          "args": [
            "chp",
            "xfer",
            "timeout"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_atapi_intr_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
          "lines": "878-956",
          "snippet": "int\nwdc_atapi_intr_command(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tstruct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;\n\tint i;\n\tu_int8_t cmd[16];\n\tstruct scsi_sense *cmd_reqsense;\n\tint cmdlen = (drvp->atapi_cap & ACAP_LEN) ? 16 : 12;\n\tint  dma_flags;\n\n\tdma_flags = wdc_atapi_dma_flags(xfer);\n\n\tbzero(cmd, sizeof(cmd));\n\n\tif (xfer->c_flags & C_SENSE) {\n\t\tcmd_reqsense = (struct scsi_sense *)&cmd[0];\n\t\tcmd_reqsense->opcode = REQUEST_SENSE;\n\t\tcmd_reqsense->length = xfer->c_bcount;\n\t} else \n\t\tbcopy(sc_xfer->cmd, cmd, sc_xfer->cmdlen);\n\n\tfor (i = 0; i < 12; i++)\n\t\tWDCDEBUG_PRINT((\"%02x \", cmd[i]), DEBUG_INTR);\n\tWDCDEBUG_PRINT((\": PHASE_CMDOUT\\n\"), DEBUG_INTR);\n\n\t/* Init the DMA channel if necessary */\n\tif (xfer->c_flags & C_DMA) {\n\t\tif ((*chp->wdc->dma_init)(chp->wdc->dma_arg,\n\t\t    chp->channel, xfer->drive, xfer->databuf, \n\t\t    xfer->c_bcount, dma_flags) != 0) {\n\t\t\tsc_xfer->error = XS_DRIVER_STUFFUP;\n\n\t\t\txfer->next = wdc_atapi_done;\n\t\t\treturn (GOTO_NEXT);\n\t\t}\n\t}\n\n\twdc_output_bytes(drvp, cmd, cmdlen);\n\n\tif (xfer->c_bcount == 0)\n\t\tas->protocol_phase = as_completed;\n\telse\n\t\tas->protocol_phase = as_data;\n\n\t/* Start the DMA channel if necessary */\n\tif (xfer->c_flags & C_DMA) {\n\t\t(*chp->wdc->dma_start)(chp->wdc->dma_arg,\n\t\t    chp->channel, xfer->drive, \n\t\t    dma_flags);\n\t}\n\n\txfer->expect_irq = 1;\n\n\t/* If we read/write to a tape we will get into buffer\n\t   availability mode.  */\n\tif (drvp->atapi_cap & ACAP_DSC) {\n\t\tif ((sc_xfer->cmd->opcode == READ ||\n\t\t       sc_xfer->cmd->opcode == WRITE)) {\n\t\t\tdrvp->drive_flags |= DRIVE_DSCBA;\n\t\t\tWDCDEBUG_PRINT((\"set DSCBA\\n\"), DEBUG_DSC);\n\t\t} else if ((xfer->c_flags & C_MEDIA_ACCESS) &&\n\t\t    (drvp->drive_flags & DRIVE_DSCBA)) {\n\t\t\t/* Clause 3.2.4 of QIC-157 D.\n\n\t\t\t   Any media access command other than read or\n\t\t\t   write will switch DSC back to completion\n\t\t\t   mode */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DSCBA;\n\t\t\tWDCDEBUG_PRINT((\"clear DCSBA\\n\"), DEBUG_DSC);\n\t\t}\n\t}\n\n\treturn (GOTO_NEXT);\n}",
          "includes": [
            "#include <dev/atapiscsi/atapiconf.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_tape.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/reboot.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define GOTO_NEXT 1",
            "#define DEBUG_DSC    0x20",
            "#define DEBUG_INTR   0x01"
          ],
          "globals_used": [
            "int   wdc_atapi_intr_command",
            "int   wdc_atapi_dma_flags",
            "int   wdc_atapi_done",
            "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GOTO_NEXT 1\n#define DEBUG_DSC    0x20\n#define DEBUG_INTR   0x01\n\nint   wdc_atapi_intr_command;\nint   wdc_atapi_dma_flags;\nint   wdc_atapi_done;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_intr_command(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tstruct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;\n\tint i;\n\tu_int8_t cmd[16];\n\tstruct scsi_sense *cmd_reqsense;\n\tint cmdlen = (drvp->atapi_cap & ACAP_LEN) ? 16 : 12;\n\tint  dma_flags;\n\n\tdma_flags = wdc_atapi_dma_flags(xfer);\n\n\tbzero(cmd, sizeof(cmd));\n\n\tif (xfer->c_flags & C_SENSE) {\n\t\tcmd_reqsense = (struct scsi_sense *)&cmd[0];\n\t\tcmd_reqsense->opcode = REQUEST_SENSE;\n\t\tcmd_reqsense->length = xfer->c_bcount;\n\t} else \n\t\tbcopy(sc_xfer->cmd, cmd, sc_xfer->cmdlen);\n\n\tfor (i = 0; i < 12; i++)\n\t\tWDCDEBUG_PRINT((\"%02x \", cmd[i]), DEBUG_INTR);\n\tWDCDEBUG_PRINT((\": PHASE_CMDOUT\\n\"), DEBUG_INTR);\n\n\t/* Init the DMA channel if necessary */\n\tif (xfer->c_flags & C_DMA) {\n\t\tif ((*chp->wdc->dma_init)(chp->wdc->dma_arg,\n\t\t    chp->channel, xfer->drive, xfer->databuf, \n\t\t    xfer->c_bcount, dma_flags) != 0) {\n\t\t\tsc_xfer->error = XS_DRIVER_STUFFUP;\n\n\t\t\txfer->next = wdc_atapi_done;\n\t\t\treturn (GOTO_NEXT);\n\t\t}\n\t}\n\n\twdc_output_bytes(drvp, cmd, cmdlen);\n\n\tif (xfer->c_bcount == 0)\n\t\tas->protocol_phase = as_completed;\n\telse\n\t\tas->protocol_phase = as_data;\n\n\t/* Start the DMA channel if necessary */\n\tif (xfer->c_flags & C_DMA) {\n\t\t(*chp->wdc->dma_start)(chp->wdc->dma_arg,\n\t\t    chp->channel, xfer->drive, \n\t\t    dma_flags);\n\t}\n\n\txfer->expect_irq = 1;\n\n\t/* If we read/write to a tape we will get into buffer\n\t   availability mode.  */\n\tif (drvp->atapi_cap & ACAP_DSC) {\n\t\tif ((sc_xfer->cmd->opcode == READ ||\n\t\t       sc_xfer->cmd->opcode == WRITE)) {\n\t\t\tdrvp->drive_flags |= DRIVE_DSCBA;\n\t\t\tWDCDEBUG_PRINT((\"set DSCBA\\n\"), DEBUG_DSC);\n\t\t} else if ((xfer->c_flags & C_MEDIA_ACCESS) &&\n\t\t    (drvp->drive_flags & DRIVE_DSCBA)) {\n\t\t\t/* Clause 3.2.4 of QIC-157 D.\n\n\t\t\t   Any media access command other than read or\n\t\t\t   write will switch DSC back to completion\n\t\t\t   mode */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DSCBA;\n\t\t\tWDCDEBUG_PRINT((\"clear DCSBA\\n\"), DEBUG_DSC);\n\t\t}\n\t}\n\n\treturn (GOTO_NEXT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM | (xfer->drive << 4)"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_atapi_drive_selected",
          "args": [
            "chp",
            "xfer->drive"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_atapi_drive_selected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
          "lines": "544-552",
          "snippet": "int\nwdc_atapi_drive_selected(chp, drive)\n\tstruct channel_softc *chp;\n\tint drive;\n{\n\tu_int8_t reg = CHP_READ_REG(chp, wdr_sdh);\n\n\treturn ((reg & 0x10) == (drive << 4));\n}",
          "includes": [
            "#include <dev/atapiscsi/atapiconf.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_tape.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/reboot.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wdc_atapi_drive_selected"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wdc_atapi_drive_selected;\n\nint\nwdc_atapi_drive_selected(chp, drive)\n\tstruct channel_softc *chp;\n\tint drive;\n{\n\tu_int8_t reg = CHP_READ_REG(chp, wdr_sdh);\n\n\treturn ((reg & 0x10) == (drive << 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s:%d:%d: device timeout, c_bcount=%d, c_skip=%d\\n\"",
            "chp->wdc->sc_dev.dv_xname",
            "chp->channel",
            "xfer->drive",
            "xfer->c_bcount",
            "xfer->c_skip"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_atapi_update_status",
          "args": [
            "chp"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_atapi_update_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
          "lines": "733-747",
          "snippet": "void\nwdc_atapi_update_status(chp)\n\tstruct channel_softc *chp;\n{\n\tchp->ch_status = CHP_READ_REG(chp, wdr_status);\n\n\tif (chp->ch_status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n\n\t\tchp->ch_status = CHP_READ_REG(chp, wdr_status);\n\t}\n\n\tif ((chp->ch_status & (WDCS_BSY | WDCS_ERR)) == WDCS_ERR)\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n}",
          "includes": [
            "#include <dev/atapiscsi/atapiconf.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_tape.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/reboot.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void wdc_atapi_update_status"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wdc_atapi_update_status;\n\nvoid\nwdc_atapi_update_status(chp)\n\tstruct channel_softc *chp;\n{\n\tchp->ch_status = CHP_READ_REG(chp, wdr_status);\n\n\tif (chp->ch_status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n\n\t\tchp->ch_status = CHP_READ_REG(chp, wdr_status);\n\t}\n\n\tif ((chp->ch_status & (WDCS_BSY | WDCS_ERR)) == WDCS_ERR)\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"ATAPI_INTR\\n\")",
            "DEBUG_INTR"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GOTO_NEXT 1\n#define CONTINUE_POLL 0\n#define DEBUG_INTR   0x01\n\nint   wdc_atapi_intr_command;\nint   wdc_atapi_intr_data;\nint   wdc_atapi_intr_complete;\nint   wdc_atapi_intr_for_us;\nint   wdc_atapi_reset;\nint wdc_atapi_drive_selected;\nvoid wdc_atapi_update_status;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_intr_for_us(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tstruct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;\n\n\tWDCDEBUG_PRINT((\"ATAPI_INTR\\n\"), DEBUG_INTR);\n\n\twdc_atapi_update_status(chp);\n\n\tif (timeout) {\n\t\tprintf(\"%s:%d:%d: device timeout, c_bcount=%d, c_skip=%d\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t\t    xfer->c_bcount, xfer->c_skip);\n\n\t\tif (xfer->c_flags & C_DMA)\n\t\t\tdrvp->n_dmaerrs++;\n\t\t\n\t\tsc_xfer->error = XS_TIMEOUT;\n\t\txfer->next = wdc_atapi_reset;\n\t\treturn (GOTO_NEXT);\n\t}\n\n\n\tif (chp->ch_status & WDCS_BSY)\n\t\treturn (CONTINUE_POLL);\n\n\tif (!wdc_atapi_drive_selected(chp, xfer->drive))\n\t{\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\t\tdelay (1);\n\n\t\treturn (CONTINUE_POLL);\n\t}\n\n\tif (as->protocol_phase != as_cmdout &&\n\t    (xfer->c_flags & C_MEDIA_ACCESS) &&\n\t    !(chp->ch_status & WDCS_DSC)) {\n\t\txfer->delay = 100;\n\t\treturn (CONTINUE_POLL);\n\t}\n\n\txfer->claim_irq = 1;\n\n\tif (chp->ch_status & WDCS_DRQ) {\n\t\tif (as->protocol_phase == as_cmdout)\n\t\t\treturn (wdc_atapi_intr_command(chp, xfer, timeout));\n\n\t\treturn (wdc_atapi_intr_data(chp, xfer, timeout));\n\t}\n\t\n\treturn (wdc_atapi_intr_complete(chp, xfer, timeout));\n}"
  },
  {
    "function_name": "wdc_atapi_intr_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "1095-1203",
    "snippet": "int\nwdc_atapi_intr_complete(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tstruct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;\n\tint dma_err = 0;\n\tint dma_flags = wdc_atapi_dma_flags(xfer);\n\n\tWDCDEBUG_PRINT((\"PHASE_COMPLETED\\n\"), DEBUG_INTR);\n\n\t/* turn off DMA channel */\n\tif (as->protocol_phase == as_data &&\n\t    xfer->c_flags & C_DMA) {\n\t\tdma_err = (*chp->wdc->dma_finish)(chp->wdc->dma_arg,\n\t\t     chp->channel, xfer->drive, dma_flags);\n\n\t\t/* Assume everything was transferred */\n\t\txfer->c_bcount = 0;\n\t}\n\n\tas->protocol_phase = as_none;\n\n\tif (xfer->c_flags & C_SENSE) {\n\t\tif (chp->ch_status & WDCS_ERR) {\n\t\t\tif (chp->ch_error & WDCE_ABRT) {\n\t\t\t\tWDCDEBUG_PRINT((\"wdc_atapi_intr: request_sense aborted, \"\n\t\t\t\t\t\t\"calling wdc_atapi_done()\"\n\t\t\t\t\t), DEBUG_INTR);\n\t\t\t\txfer->next = wdc_atapi_done;\n\t\t\t\treturn (GOTO_NEXT);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * request sense failed ! it's not suppossed\n \t\t\t * to be possible\n\t\t\t */\n\n\t\t\tsc_xfer->error = XS_RESET;\n\t\t\txfer->next = wdc_atapi_reset;\n\t\t\treturn (GOTO_NEXT);\n\n\t\t} else if (xfer->c_bcount < sizeof(sc_xfer->sense)) {\n\t\t\t\t/* use the sense we just read */\n\t\t\tsc_xfer->error = XS_SENSE;\n\t\t} else {\n\t\t\t/*\n\t\t\t * command completed, but no data was read.\n\t\t\t * use the short sense we saved previsouly.\n\t\t\t */\n\t\t\tsc_xfer->error = XS_SHORTSENSE;\n\t\t}\n\t} else {\n\t\tsc_xfer->resid = xfer->c_bcount;\n\t\tif (chp->ch_status & WDCS_ERR) {\n\t\t\tif (!atapi_to_scsi_sense(sc_xfer, chp->ch_error) &&\n\t\t\t    (sc_xfer->sc_link->quirks &\n\t\t\t     ADEV_NOSENSE) == 0) {\n\t\t\t\t/*\n\t\t\t\t * let the driver issue a\n\t\t\t\t * 'request sense'\n\t\t\t\t */\n\t\t\t\txfer->databuf = &sc_xfer->sense;\n\t\t\t\txfer->c_bcount = sizeof(sc_xfer->sense);\n\t\t\t\txfer->c_skip = 0;\n\t\t\t\txfer->c_done = NULL;\n\t\t\t\txfer->c_flags |= C_SENSE;\n\t\t\t\txfer->next = wdc_atapi_real_start;\n\t\t\t\treturn (GOTO_NEXT);\n\t\t\t}\n\t\t}\t\t\n\t}\n\n        if (dma_err < 0) { \n\t\tdrvp->n_dmaerrs++;\n\t\tsc_xfer->error = XS_RESET;\n\n\t\txfer->next = wdc_atapi_reset;\n\t\treturn (GOTO_NEXT);\n\t}\n\t\t\t\n\n\tif (xfer->c_bcount != 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_intr: bcount value is \"\n\t\t\t\t\"%d after io\\n\", xfer->c_bcount), DEBUG_XFERS);\n\t}\n#ifdef DIAGNOSTIC\n\tif (xfer->c_bcount < 0) {\n\t\tprintf(\"wdc_atapi_intr warning: bcount value \"\n\t\t       \"is %d after io\\n\", xfer->c_bcount);\n\t}\n#endif\n\n\tWDCDEBUG_PRINT((\"wdc_atapi_intr: wdc_atapi_done() (end), error 0x%x \"\n\t\t\t\"\\n\", sc_xfer->error),\n\t\t       DEBUG_INTR);\n\n\n\tif (xfer->c_done) \n\t\txfer->next = xfer->c_done;\n\telse \n\t\txfer->next = wdc_atapi_done;\n\n\treturn (GOTO_NEXT);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define GOTO_NEXT 1",
      "#define DEBUG_XFERS  0x02",
      "#define DEBUG_INTR   0x01"
    ],
    "globals_used": [
      "int   wdc_atapi_real_start",
      "int   wdc_atapi_intr_complete",
      "int   wdc_atapi_dma_flags",
      "int   wdc_atapi_intr",
      "int   wdc_atapi_done",
      "int   wdc_atapi_reset",
      "int     atapi_to_scsi_sense",
      "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_atapi_intr: wdc_atapi_done() (end), error 0x%x \"\n\t\t\t\"\\n\", sc_xfer->error)",
            "DEBUG_INTR"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"wdc_atapi_intr warning: bcount value \"\n\t\t       \"is %d after io\\n\"",
            "xfer->c_bcount"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_atapi_intr: bcount value is \"\n\t\t\t\t\"%d after io\\n\", xfer->c_bcount)",
            "DEBUG_XFERS"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atapi_to_scsi_sense",
          "args": [
            "sc_xfer",
            "chp->ch_error"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "atapi_to_scsi_sense",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
          "lines": "499-540",
          "snippet": "int\natapi_to_scsi_sense(xfer, flags)\n\tstruct scsi_xfer *xfer;\n\tu_int8_t flags;\n{\n\tstruct scsi_sense_data *sense = &xfer->sense;\n\tint ret = 0;\n\n\txfer->error = XS_SHORTSENSE;\n\n\tsense->error_code = SSD_ERRCODE_VALID | 0x70;\n\tsense->flags = (flags >> 4);\n\n\tWDCDEBUG_PRINT((\"Atapi error: %d \", (flags >> 4)), DEBUG_ERRORS);\n\n\tif ((flags & 4) && (sense->flags == 0)) {\n\t\tsense->flags = SKEY_ABORTED_COMMAND;\n\t\tWDCDEBUG_PRINT((\"ABRT \"), DEBUG_ERRORS);\n\t\tret = 1;\n\t}\n\n\tif (flags & 0x1) {\n\t\tsense->flags |= SSD_ILI;\n\t\tWDCDEBUG_PRINT((\"ILI \"), DEBUG_ERRORS);\n\t}\n\n\tif (flags & 0x2) {\n\t\tsense->flags |= SSD_EOM;\n\t\tWDCDEBUG_PRINT((\"EOM \"), DEBUG_ERRORS);\n\t}\n\n\t/* Media change requested */\n\t/* Let's ignore these in version 1 */\n\tif (flags & 0x8) {\n\t\tWDCDEBUG_PRINT((\"MCR \"), DEBUG_ERRORS);\n\t\tif (sense->flags == 0)\n\t\t\txfer->error = XS_NOERROR;\n\t}\n\n\tWDCDEBUG_PRINT((\"\\n\"), DEBUG_ERRORS);\n\treturn (ret);\n}",
          "includes": [
            "#include <dev/atapiscsi/atapiconf.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_tape.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/reboot.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_ERRORS 0x80   /* Debug error handling code */"
          ],
          "globals_used": [
            "int     atapi_to_scsi_sense",
            "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_ERRORS 0x80   /* Debug error handling code */\n\nint     atapi_to_scsi_sense;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\natapi_to_scsi_sense(xfer, flags)\n\tstruct scsi_xfer *xfer;\n\tu_int8_t flags;\n{\n\tstruct scsi_sense_data *sense = &xfer->sense;\n\tint ret = 0;\n\n\txfer->error = XS_SHORTSENSE;\n\n\tsense->error_code = SSD_ERRCODE_VALID | 0x70;\n\tsense->flags = (flags >> 4);\n\n\tWDCDEBUG_PRINT((\"Atapi error: %d \", (flags >> 4)), DEBUG_ERRORS);\n\n\tif ((flags & 4) && (sense->flags == 0)) {\n\t\tsense->flags = SKEY_ABORTED_COMMAND;\n\t\tWDCDEBUG_PRINT((\"ABRT \"), DEBUG_ERRORS);\n\t\tret = 1;\n\t}\n\n\tif (flags & 0x1) {\n\t\tsense->flags |= SSD_ILI;\n\t\tWDCDEBUG_PRINT((\"ILI \"), DEBUG_ERRORS);\n\t}\n\n\tif (flags & 0x2) {\n\t\tsense->flags |= SSD_EOM;\n\t\tWDCDEBUG_PRINT((\"EOM \"), DEBUG_ERRORS);\n\t}\n\n\t/* Media change requested */\n\t/* Let's ignore these in version 1 */\n\tif (flags & 0x8) {\n\t\tWDCDEBUG_PRINT((\"MCR \"), DEBUG_ERRORS);\n\t\tif (sense->flags == 0)\n\t\t\txfer->error = XS_NOERROR;\n\t}\n\n\tWDCDEBUG_PRINT((\"\\n\"), DEBUG_ERRORS);\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_atapi_intr: request_sense aborted, \"\n\t\t\t\t\t\t\"calling wdc_atapi_done()\"\n\t\t\t\t\t)",
            "DEBUG_INTR"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "chp->wdc->dma_arg",
            "chp->channel",
            "xfer->drive",
            "dma_flags"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"PHASE_COMPLETED\\n\")",
            "DEBUG_INTR"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_atapi_dma_flags",
          "args": [
            "xfer"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_atapi_dma_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
          "lines": "864-876",
          "snippet": "int\nwdc_atapi_dma_flags(xfer)\n\tstruct wdc_xfer *xfer;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tint dma_flags;\n\n\tdma_flags = ((sc_xfer->flags & SCSI_DATA_IN) ||\n\t    (xfer->c_flags & C_SENSE)) ?  WDC_DMA_READ : 0;\n\tdma_flags |= (xfer->c_flags & C_POLL) ? WDC_DMA_POLL : 0;\n\n\treturn (dma_flags);\n}",
          "includes": [
            "#include <dev/atapiscsi/atapiconf.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_tape.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/reboot.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int   wdc_atapi_dma_flags",
            "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint   wdc_atapi_dma_flags;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_dma_flags(xfer)\n\tstruct wdc_xfer *xfer;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tint dma_flags;\n\n\tdma_flags = ((sc_xfer->flags & SCSI_DATA_IN) ||\n\t    (xfer->c_flags & C_SENSE)) ?  WDC_DMA_READ : 0;\n\tdma_flags |= (xfer->c_flags & C_POLL) ? WDC_DMA_POLL : 0;\n\n\treturn (dma_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GOTO_NEXT 1\n#define DEBUG_XFERS  0x02\n#define DEBUG_INTR   0x01\n\nint   wdc_atapi_real_start;\nint   wdc_atapi_intr_complete;\nint   wdc_atapi_dma_flags;\nint   wdc_atapi_intr;\nint   wdc_atapi_done;\nint   wdc_atapi_reset;\nint     atapi_to_scsi_sense;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_intr_complete(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tstruct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;\n\tint dma_err = 0;\n\tint dma_flags = wdc_atapi_dma_flags(xfer);\n\n\tWDCDEBUG_PRINT((\"PHASE_COMPLETED\\n\"), DEBUG_INTR);\n\n\t/* turn off DMA channel */\n\tif (as->protocol_phase == as_data &&\n\t    xfer->c_flags & C_DMA) {\n\t\tdma_err = (*chp->wdc->dma_finish)(chp->wdc->dma_arg,\n\t\t     chp->channel, xfer->drive, dma_flags);\n\n\t\t/* Assume everything was transferred */\n\t\txfer->c_bcount = 0;\n\t}\n\n\tas->protocol_phase = as_none;\n\n\tif (xfer->c_flags & C_SENSE) {\n\t\tif (chp->ch_status & WDCS_ERR) {\n\t\t\tif (chp->ch_error & WDCE_ABRT) {\n\t\t\t\tWDCDEBUG_PRINT((\"wdc_atapi_intr: request_sense aborted, \"\n\t\t\t\t\t\t\"calling wdc_atapi_done()\"\n\t\t\t\t\t), DEBUG_INTR);\n\t\t\t\txfer->next = wdc_atapi_done;\n\t\t\t\treturn (GOTO_NEXT);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * request sense failed ! it's not suppossed\n \t\t\t * to be possible\n\t\t\t */\n\n\t\t\tsc_xfer->error = XS_RESET;\n\t\t\txfer->next = wdc_atapi_reset;\n\t\t\treturn (GOTO_NEXT);\n\n\t\t} else if (xfer->c_bcount < sizeof(sc_xfer->sense)) {\n\t\t\t\t/* use the sense we just read */\n\t\t\tsc_xfer->error = XS_SENSE;\n\t\t} else {\n\t\t\t/*\n\t\t\t * command completed, but no data was read.\n\t\t\t * use the short sense we saved previsouly.\n\t\t\t */\n\t\t\tsc_xfer->error = XS_SHORTSENSE;\n\t\t}\n\t} else {\n\t\tsc_xfer->resid = xfer->c_bcount;\n\t\tif (chp->ch_status & WDCS_ERR) {\n\t\t\tif (!atapi_to_scsi_sense(sc_xfer, chp->ch_error) &&\n\t\t\t    (sc_xfer->sc_link->quirks &\n\t\t\t     ADEV_NOSENSE) == 0) {\n\t\t\t\t/*\n\t\t\t\t * let the driver issue a\n\t\t\t\t * 'request sense'\n\t\t\t\t */\n\t\t\t\txfer->databuf = &sc_xfer->sense;\n\t\t\t\txfer->c_bcount = sizeof(sc_xfer->sense);\n\t\t\t\txfer->c_skip = 0;\n\t\t\t\txfer->c_done = NULL;\n\t\t\t\txfer->c_flags |= C_SENSE;\n\t\t\t\txfer->next = wdc_atapi_real_start;\n\t\t\t\treturn (GOTO_NEXT);\n\t\t\t}\n\t\t}\t\t\n\t}\n\n        if (dma_err < 0) { \n\t\tdrvp->n_dmaerrs++;\n\t\tsc_xfer->error = XS_RESET;\n\n\t\txfer->next = wdc_atapi_reset;\n\t\treturn (GOTO_NEXT);\n\t}\n\t\t\t\n\n\tif (xfer->c_bcount != 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_intr: bcount value is \"\n\t\t\t\t\"%d after io\\n\", xfer->c_bcount), DEBUG_XFERS);\n\t}\n#ifdef DIAGNOSTIC\n\tif (xfer->c_bcount < 0) {\n\t\tprintf(\"wdc_atapi_intr warning: bcount value \"\n\t\t       \"is %d after io\\n\", xfer->c_bcount);\n\t}\n#endif\n\n\tWDCDEBUG_PRINT((\"wdc_atapi_intr: wdc_atapi_done() (end), error 0x%x \"\n\t\t\t\"\\n\", sc_xfer->error),\n\t\t       DEBUG_INTR);\n\n\n\tif (xfer->c_done) \n\t\txfer->next = xfer->c_done;\n\telse \n\t\txfer->next = wdc_atapi_done;\n\n\treturn (GOTO_NEXT);\n}"
  },
  {
    "function_name": "wdc_atapi_intr_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "1010-1092",
    "snippet": "int\nwdc_atapi_intr_data(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tint len, ire;\n\tchar *message;\n\n\tlen = (CHP_READ_REG(chp, wdr_cyl_hi) << 8) |\n\t    CHP_READ_REG(chp, wdr_cyl_lo);\n\tire = CHP_READ_REG(chp, wdr_ireason);\n\n\tif ((message = wdc_atapi_in_data_phase(xfer, len, ire))) {\n\t\t/* The drive has dropped BSY before setting up the\n\t\t   registers correctly for DATA phase. This drive is\n\t\t   not compliant with ATA/ATAPI-4.\n\n\t\t   Give the drive 100ms to get its house in order\n\t\t   before we try again.  */\n\t\tif (!timeout) {\n\t\t\txfer->delay = 100;\n\t\t\treturn (CONTINUE_POLL);\t\n\t\t}\n\t}\n\n\tif (timeout) {\n\t\tprintf (\"wdc_atapi_intr_data: error: %s\\n\", message);\n\t\t\n\t\tsc_xfer->error = XS_RESET;\n\t\txfer->next = wdc_atapi_reset;\n\t\treturn (GOTO_NEXT);\n\t}\n\n\t\n\tif (xfer->c_bcount >= len) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_intr: c_bcount %d len %d \"\n\t\t    \"st 0x%x err 0x%x \"\n\t\t    \"ire 0x%x\\n\", xfer->c_bcount,\n\t\t    len, chp->ch_status, chp->ch_error, ire), DEBUG_INTR);\n\t\t\n\t\t/* Common case */\n\t\tif (sc_xfer->flags & SCSI_DATA_OUT)\n\t\t\twdc_output_bytes(drvp, (u_int8_t *)xfer->databuf +\n\t\t\t    xfer->c_skip, len);\n\t\telse\n\t\t\twdc_input_bytes(drvp, (u_int8_t *)xfer->databuf +\n\t\t\t    xfer->c_skip, len);\n\n\t\txfer->c_skip += len;\n\t\txfer->c_bcount -= len;\n\t} else {\n\t\t/* Exceptional case */\n\t\tif (sc_xfer->flags & SCSI_DATA_OUT) {\n\t\t\tprintf(\"wdc_atapi_intr: warning: write only \"\n\t\t\t    \"%d of %d requested bytes\\n\", xfer->c_bcount, len);\n\n\t\t\twdc_output_bytes(drvp, (u_int8_t *)xfer->databuf +\n\t\t\t    xfer->c_skip, xfer->c_bcount);\n\t\t\t \n\t\t\tCHP_WRITE_RAW_MULTI_2(chp, NULL, \n\t\t\t    len - xfer->c_bcount);\n\t\t} else {\n\t\t\tprintf(\"wdc_atapi_intr: warning: reading only \"\n\t\t\t    \"%d of %d bytes\\n\", xfer->c_bcount, len);\n\t\t\t \n\t\t\twdc_input_bytes(drvp,\n\t\t\t    (char *)xfer->databuf + xfer->c_skip,\n\t\t\t    xfer->c_bcount);\n\t\t\twdcbit_bucket(chp, len - xfer->c_bcount);\n\t\t}\n\n\t\txfer->c_skip += xfer->c_bcount;\n\t\txfer->c_bcount = 0;\n\t}\n\n\txfer->expect_irq = 1;\n\txfer->next = wdc_atapi_intr_for_us;\n\n\treturn (GOTO_NEXT);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define GOTO_NEXT 1",
      "#define CONTINUE_POLL 0",
      "#define DEBUG_INTR   0x01"
    ],
    "globals_used": [
      "int   wdc_atapi_intr_data",
      "int   wdc_atapi_intr_for_us",
      "char  *wdc_atapi_in_data_phase",
      "int   wdc_atapi_intr",
      "int   wdc_atapi_reset",
      "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;",
      "int len, ire;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdcbit_bucket",
          "args": [
            "chp",
            "len - xfer->c_bcount"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "wdcbit_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1672-1678",
          "snippet": "void\nwdcbit_bucket(chp, size)\n\tstruct channel_softc *chp; \n\tint size;\n{\n\tCHP_READ_RAW_MULTI_2(chp, NULL, size);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdcbit_bucket(chp, size)\n\tstruct channel_softc *chp; \n\tint size;\n{\n\tCHP_READ_RAW_MULTI_2(chp, NULL, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_input_bytes",
          "args": [
            "drvp",
            "(char *)xfer->databuf + xfer->c_skip",
            "xfer->c_bcount"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_input_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1194-1222",
          "snippet": "void\nwdc_input_bytes(drvp, bytes, buflen)\n\tstruct ata_drive_datas *drvp;\n\tvoid *bytes;\n\tunsigned int buflen;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tunsigned int off = 0;\n\tunsigned int len = buflen, roundlen;\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\troundlen = len & ~3;\n\n\t\tCHP_READ_RAW_MULTI_4(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\n\t\toff += roundlen;\n\t\tlen -= roundlen;\n\t}\n\n\tif (len > 0) {\n\t\troundlen = (len + 1) & ~0x1;\n\n\t\tCHP_READ_RAW_MULTI_2(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_input_bytes(drvp, bytes, buflen)\n\tstruct ata_drive_datas *drvp;\n\tvoid *bytes;\n\tunsigned int buflen;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tunsigned int off = 0;\n\tunsigned int len = buflen, roundlen;\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\troundlen = len & ~3;\n\n\t\tCHP_READ_RAW_MULTI_4(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\n\t\toff += roundlen;\n\t\tlen -= roundlen;\n\t}\n\n\tif (len > 0) {\n\t\troundlen = (len + 1) & ~0x1;\n\n\t\tCHP_READ_RAW_MULTI_2(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"wdc_atapi_intr: warning: reading only \"\n\t\t\t    \"%d of %d bytes\\n\"",
            "xfer->c_bcount",
            "len"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_RAW_MULTI_2",
          "args": [
            "chp",
            "NULL",
            "len - xfer->c_bcount"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_output_bytes",
          "args": [
            "drvp",
            "(u_int8_t *)xfer->databuf +\n\t\t\t    xfer->c_skip",
            "xfer->c_bcount"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_output_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1164-1192",
          "snippet": "void\nwdc_output_bytes(drvp, bytes, buflen)\n\tstruct ata_drive_datas *drvp;\n\tvoid *bytes;\n\tunsigned int buflen;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tunsigned int off = 0;\n\tunsigned int len = buflen, roundlen;\t\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\troundlen = len & ~3;\n\n\t\tCHP_WRITE_RAW_MULTI_4(chp, \n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\n\t\toff += roundlen;\n\t\tlen -= roundlen;\n\t}\n\n\tif (len > 0) {\n\t\troundlen = (len + 1) & ~0x1;\n\n\t        CHP_WRITE_RAW_MULTI_2(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_output_bytes(drvp, bytes, buflen)\n\tstruct ata_drive_datas *drvp;\n\tvoid *bytes;\n\tunsigned int buflen;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tunsigned int off = 0;\n\tunsigned int len = buflen, roundlen;\t\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\troundlen = len & ~3;\n\n\t\tCHP_WRITE_RAW_MULTI_4(chp, \n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\n\t\toff += roundlen;\n\t\tlen -= roundlen;\n\t}\n\n\tif (len > 0) {\n\t\troundlen = (len + 1) & ~0x1;\n\n\t        CHP_WRITE_RAW_MULTI_2(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_atapi_intr: c_bcount %d len %d \"\n\t\t    \"st 0x%x err 0x%x \"\n\t\t    \"ire 0x%x\\n\", xfer->c_bcount,\n\t\t    len, chp->ch_status, chp->ch_error, ire)",
            "DEBUG_INTR"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_atapi_in_data_phase",
          "args": [
            "xfer",
            "len",
            "ire"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_ireason"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_cyl_lo"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_cyl_hi"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GOTO_NEXT 1\n#define CONTINUE_POLL 0\n#define DEBUG_INTR   0x01\n\nint   wdc_atapi_intr_data;\nint   wdc_atapi_intr_for_us;\nchar  *wdc_atapi_in_data_phase;\nint   wdc_atapi_intr;\nint   wdc_atapi_reset;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\nint len, ire;\n\nint\nwdc_atapi_intr_data(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tint len, ire;\n\tchar *message;\n\n\tlen = (CHP_READ_REG(chp, wdr_cyl_hi) << 8) |\n\t    CHP_READ_REG(chp, wdr_cyl_lo);\n\tire = CHP_READ_REG(chp, wdr_ireason);\n\n\tif ((message = wdc_atapi_in_data_phase(xfer, len, ire))) {\n\t\t/* The drive has dropped BSY before setting up the\n\t\t   registers correctly for DATA phase. This drive is\n\t\t   not compliant with ATA/ATAPI-4.\n\n\t\t   Give the drive 100ms to get its house in order\n\t\t   before we try again.  */\n\t\tif (!timeout) {\n\t\t\txfer->delay = 100;\n\t\t\treturn (CONTINUE_POLL);\t\n\t\t}\n\t}\n\n\tif (timeout) {\n\t\tprintf (\"wdc_atapi_intr_data: error: %s\\n\", message);\n\t\t\n\t\tsc_xfer->error = XS_RESET;\n\t\txfer->next = wdc_atapi_reset;\n\t\treturn (GOTO_NEXT);\n\t}\n\n\t\n\tif (xfer->c_bcount >= len) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_intr: c_bcount %d len %d \"\n\t\t    \"st 0x%x err 0x%x \"\n\t\t    \"ire 0x%x\\n\", xfer->c_bcount,\n\t\t    len, chp->ch_status, chp->ch_error, ire), DEBUG_INTR);\n\t\t\n\t\t/* Common case */\n\t\tif (sc_xfer->flags & SCSI_DATA_OUT)\n\t\t\twdc_output_bytes(drvp, (u_int8_t *)xfer->databuf +\n\t\t\t    xfer->c_skip, len);\n\t\telse\n\t\t\twdc_input_bytes(drvp, (u_int8_t *)xfer->databuf +\n\t\t\t    xfer->c_skip, len);\n\n\t\txfer->c_skip += len;\n\t\txfer->c_bcount -= len;\n\t} else {\n\t\t/* Exceptional case */\n\t\tif (sc_xfer->flags & SCSI_DATA_OUT) {\n\t\t\tprintf(\"wdc_atapi_intr: warning: write only \"\n\t\t\t    \"%d of %d requested bytes\\n\", xfer->c_bcount, len);\n\n\t\t\twdc_output_bytes(drvp, (u_int8_t *)xfer->databuf +\n\t\t\t    xfer->c_skip, xfer->c_bcount);\n\t\t\t \n\t\t\tCHP_WRITE_RAW_MULTI_2(chp, NULL, \n\t\t\t    len - xfer->c_bcount);\n\t\t} else {\n\t\t\tprintf(\"wdc_atapi_intr: warning: reading only \"\n\t\t\t    \"%d of %d bytes\\n\", xfer->c_bcount, len);\n\t\t\t \n\t\t\twdc_input_bytes(drvp,\n\t\t\t    (char *)xfer->databuf + xfer->c_skip,\n\t\t\t    xfer->c_bcount);\n\t\t\twdcbit_bucket(chp, len - xfer->c_bcount);\n\t\t}\n\n\t\txfer->c_skip += xfer->c_bcount;\n\t\txfer->c_bcount = 0;\n\t}\n\n\txfer->expect_irq = 1;\n\txfer->next = wdc_atapi_intr_for_us;\n\n\treturn (GOTO_NEXT);\n}"
  },
  {
    "function_name": "wdc_atapi_intr_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "878-956",
    "snippet": "int\nwdc_atapi_intr_command(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tstruct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;\n\tint i;\n\tu_int8_t cmd[16];\n\tstruct scsi_sense *cmd_reqsense;\n\tint cmdlen = (drvp->atapi_cap & ACAP_LEN) ? 16 : 12;\n\tint  dma_flags;\n\n\tdma_flags = wdc_atapi_dma_flags(xfer);\n\n\tbzero(cmd, sizeof(cmd));\n\n\tif (xfer->c_flags & C_SENSE) {\n\t\tcmd_reqsense = (struct scsi_sense *)&cmd[0];\n\t\tcmd_reqsense->opcode = REQUEST_SENSE;\n\t\tcmd_reqsense->length = xfer->c_bcount;\n\t} else \n\t\tbcopy(sc_xfer->cmd, cmd, sc_xfer->cmdlen);\n\n\tfor (i = 0; i < 12; i++)\n\t\tWDCDEBUG_PRINT((\"%02x \", cmd[i]), DEBUG_INTR);\n\tWDCDEBUG_PRINT((\": PHASE_CMDOUT\\n\"), DEBUG_INTR);\n\n\t/* Init the DMA channel if necessary */\n\tif (xfer->c_flags & C_DMA) {\n\t\tif ((*chp->wdc->dma_init)(chp->wdc->dma_arg,\n\t\t    chp->channel, xfer->drive, xfer->databuf, \n\t\t    xfer->c_bcount, dma_flags) != 0) {\n\t\t\tsc_xfer->error = XS_DRIVER_STUFFUP;\n\n\t\t\txfer->next = wdc_atapi_done;\n\t\t\treturn (GOTO_NEXT);\n\t\t}\n\t}\n\n\twdc_output_bytes(drvp, cmd, cmdlen);\n\n\tif (xfer->c_bcount == 0)\n\t\tas->protocol_phase = as_completed;\n\telse\n\t\tas->protocol_phase = as_data;\n\n\t/* Start the DMA channel if necessary */\n\tif (xfer->c_flags & C_DMA) {\n\t\t(*chp->wdc->dma_start)(chp->wdc->dma_arg,\n\t\t    chp->channel, xfer->drive, \n\t\t    dma_flags);\n\t}\n\n\txfer->expect_irq = 1;\n\n\t/* If we read/write to a tape we will get into buffer\n\t   availability mode.  */\n\tif (drvp->atapi_cap & ACAP_DSC) {\n\t\tif ((sc_xfer->cmd->opcode == READ ||\n\t\t       sc_xfer->cmd->opcode == WRITE)) {\n\t\t\tdrvp->drive_flags |= DRIVE_DSCBA;\n\t\t\tWDCDEBUG_PRINT((\"set DSCBA\\n\"), DEBUG_DSC);\n\t\t} else if ((xfer->c_flags & C_MEDIA_ACCESS) &&\n\t\t    (drvp->drive_flags & DRIVE_DSCBA)) {\n\t\t\t/* Clause 3.2.4 of QIC-157 D.\n\n\t\t\t   Any media access command other than read or\n\t\t\t   write will switch DSC back to completion\n\t\t\t   mode */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DSCBA;\n\t\t\tWDCDEBUG_PRINT((\"clear DCSBA\\n\"), DEBUG_DSC);\n\t\t}\n\t}\n\n\treturn (GOTO_NEXT);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define GOTO_NEXT 1",
      "#define DEBUG_DSC    0x20",
      "#define DEBUG_INTR   0x01"
    ],
    "globals_used": [
      "int   wdc_atapi_intr_command",
      "int   wdc_atapi_dma_flags",
      "int   wdc_atapi_done",
      "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"clear DCSBA\\n\")",
            "DEBUG_DSC"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"set DSCBA\\n\")",
            "DEBUG_DSC"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "chp->wdc->dma_arg",
            "chp->channel",
            "xfer->drive",
            "dma_flags"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_output_bytes",
          "args": [
            "drvp",
            "cmd",
            "cmdlen"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_output_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1164-1192",
          "snippet": "void\nwdc_output_bytes(drvp, bytes, buflen)\n\tstruct ata_drive_datas *drvp;\n\tvoid *bytes;\n\tunsigned int buflen;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tunsigned int off = 0;\n\tunsigned int len = buflen, roundlen;\t\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\troundlen = len & ~3;\n\n\t\tCHP_WRITE_RAW_MULTI_4(chp, \n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\n\t\toff += roundlen;\n\t\tlen -= roundlen;\n\t}\n\n\tif (len > 0) {\n\t\troundlen = (len + 1) & ~0x1;\n\n\t        CHP_WRITE_RAW_MULTI_2(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_output_bytes(drvp, bytes, buflen)\n\tstruct ata_drive_datas *drvp;\n\tvoid *bytes;\n\tunsigned int buflen;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tunsigned int off = 0;\n\tunsigned int len = buflen, roundlen;\t\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\troundlen = len & ~3;\n\n\t\tCHP_WRITE_RAW_MULTI_4(chp, \n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\n\t\toff += roundlen;\n\t\tlen -= roundlen;\n\t}\n\n\tif (len > 0) {\n\t\troundlen = (len + 1) & ~0x1;\n\n\t        CHP_WRITE_RAW_MULTI_2(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "chp->wdc->dma_arg",
            "chp->channel",
            "xfer->drive",
            "xfer->databuf",
            "xfer->c_bcount",
            "dma_flags"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\": PHASE_CMDOUT\\n\")",
            "DEBUG_INTR"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"%02x \", cmd[i])",
            "DEBUG_INTR"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc_xfer->cmd",
            "cmd",
            "sc_xfer->cmdlen"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "cmd",
            "sizeof(cmd)"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_atapi_dma_flags",
          "args": [
            "xfer"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_atapi_dma_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
          "lines": "864-876",
          "snippet": "int\nwdc_atapi_dma_flags(xfer)\n\tstruct wdc_xfer *xfer;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tint dma_flags;\n\n\tdma_flags = ((sc_xfer->flags & SCSI_DATA_IN) ||\n\t    (xfer->c_flags & C_SENSE)) ?  WDC_DMA_READ : 0;\n\tdma_flags |= (xfer->c_flags & C_POLL) ? WDC_DMA_POLL : 0;\n\n\treturn (dma_flags);\n}",
          "includes": [
            "#include <dev/atapiscsi/atapiconf.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_tape.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/reboot.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int   wdc_atapi_dma_flags",
            "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint   wdc_atapi_dma_flags;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_dma_flags(xfer)\n\tstruct wdc_xfer *xfer;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tint dma_flags;\n\n\tdma_flags = ((sc_xfer->flags & SCSI_DATA_IN) ||\n\t    (xfer->c_flags & C_SENSE)) ?  WDC_DMA_READ : 0;\n\tdma_flags |= (xfer->c_flags & C_POLL) ? WDC_DMA_POLL : 0;\n\n\treturn (dma_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GOTO_NEXT 1\n#define DEBUG_DSC    0x20\n#define DEBUG_INTR   0x01\n\nint   wdc_atapi_intr_command;\nint   wdc_atapi_dma_flags;\nint   wdc_atapi_done;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_intr_command(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tstruct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;\n\tint i;\n\tu_int8_t cmd[16];\n\tstruct scsi_sense *cmd_reqsense;\n\tint cmdlen = (drvp->atapi_cap & ACAP_LEN) ? 16 : 12;\n\tint  dma_flags;\n\n\tdma_flags = wdc_atapi_dma_flags(xfer);\n\n\tbzero(cmd, sizeof(cmd));\n\n\tif (xfer->c_flags & C_SENSE) {\n\t\tcmd_reqsense = (struct scsi_sense *)&cmd[0];\n\t\tcmd_reqsense->opcode = REQUEST_SENSE;\n\t\tcmd_reqsense->length = xfer->c_bcount;\n\t} else \n\t\tbcopy(sc_xfer->cmd, cmd, sc_xfer->cmdlen);\n\n\tfor (i = 0; i < 12; i++)\n\t\tWDCDEBUG_PRINT((\"%02x \", cmd[i]), DEBUG_INTR);\n\tWDCDEBUG_PRINT((\": PHASE_CMDOUT\\n\"), DEBUG_INTR);\n\n\t/* Init the DMA channel if necessary */\n\tif (xfer->c_flags & C_DMA) {\n\t\tif ((*chp->wdc->dma_init)(chp->wdc->dma_arg,\n\t\t    chp->channel, xfer->drive, xfer->databuf, \n\t\t    xfer->c_bcount, dma_flags) != 0) {\n\t\t\tsc_xfer->error = XS_DRIVER_STUFFUP;\n\n\t\t\txfer->next = wdc_atapi_done;\n\t\t\treturn (GOTO_NEXT);\n\t\t}\n\t}\n\n\twdc_output_bytes(drvp, cmd, cmdlen);\n\n\tif (xfer->c_bcount == 0)\n\t\tas->protocol_phase = as_completed;\n\telse\n\t\tas->protocol_phase = as_data;\n\n\t/* Start the DMA channel if necessary */\n\tif (xfer->c_flags & C_DMA) {\n\t\t(*chp->wdc->dma_start)(chp->wdc->dma_arg,\n\t\t    chp->channel, xfer->drive, \n\t\t    dma_flags);\n\t}\n\n\txfer->expect_irq = 1;\n\n\t/* If we read/write to a tape we will get into buffer\n\t   availability mode.  */\n\tif (drvp->atapi_cap & ACAP_DSC) {\n\t\tif ((sc_xfer->cmd->opcode == READ ||\n\t\t       sc_xfer->cmd->opcode == WRITE)) {\n\t\t\tdrvp->drive_flags |= DRIVE_DSCBA;\n\t\t\tWDCDEBUG_PRINT((\"set DSCBA\\n\"), DEBUG_DSC);\n\t\t} else if ((xfer->c_flags & C_MEDIA_ACCESS) &&\n\t\t    (drvp->drive_flags & DRIVE_DSCBA)) {\n\t\t\t/* Clause 3.2.4 of QIC-157 D.\n\n\t\t\t   Any media access command other than read or\n\t\t\t   write will switch DSC back to completion\n\t\t\t   mode */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DSCBA;\n\t\t\tWDCDEBUG_PRINT((\"clear DCSBA\\n\"), DEBUG_DSC);\n\t\t}\n\t}\n\n\treturn (GOTO_NEXT);\n}"
  },
  {
    "function_name": "wdc_atapi_dma_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "864-876",
    "snippet": "int\nwdc_atapi_dma_flags(xfer)\n\tstruct wdc_xfer *xfer;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tint dma_flags;\n\n\tdma_flags = ((sc_xfer->flags & SCSI_DATA_IN) ||\n\t    (xfer->c_flags & C_SENSE)) ?  WDC_DMA_READ : 0;\n\tdma_flags |= (xfer->c_flags & C_POLL) ? WDC_DMA_POLL : 0;\n\n\treturn (dma_flags);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int   wdc_atapi_dma_flags",
      "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint   wdc_atapi_dma_flags;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_dma_flags(xfer)\n\tstruct wdc_xfer *xfer;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tint dma_flags;\n\n\tdma_flags = ((sc_xfer->flags & SCSI_DATA_IN) ||\n\t    (xfer->c_flags & C_SENSE)) ?  WDC_DMA_READ : 0;\n\tdma_flags |= (xfer->c_flags & C_POLL) ? WDC_DMA_POLL : 0;\n\n\treturn (dma_flags);\n}"
  },
  {
    "function_name": "wdc_atapi_send_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "825-862",
    "snippet": "int\nwdc_atapi_send_packet(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tstruct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;\n\n\t/*\n\t * Even with WDCS_ERR, the device should accept a command packet\n\t * Limit length to what can be stuffed into the cylinder register\n\t * (16 bits).  Some CD-ROMs seem to interpret '0' as 65536,\n\t * but not all devices do that and it's not obvious from the\n\t * ATAPI spec that that behaviour should be expected.  If more\n\t * data is necessary, multiple data transfer phases will be done.\n\t */\n\n\twdccommand(chp, xfer->drive, ATAPI_PKT_CMD, \n\t    xfer->c_bcount <= 0xfffe ? xfer->c_bcount : 0xfffe,\n\t    0, 0, 0, \n\t    (xfer->c_flags & C_DMA) ? ATAPI_PKT_CMD_FTRE_DMA : 0);\n\n\tas->protocol_phase = as_cmdout;\n\tas->retries = 0;\n\n\tDELAY(1);\n\n\txfer->next = wdc_atapi_intr_for_us;\n\txfer->timeout = sc_xfer->timeout;\n\n\tif ((drvp->atapi_cap & ATAPI_CFG_DRQ_MASK) == ATAPI_CFG_IRQ_DRQ) {\n\t\t/* We expect an IRQ to tell us of the next state */\n\t\txfer->expect_irq = 1;\n\t}\n\treturn (GOTO_NEXT);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define GOTO_NEXT 1"
    ],
    "globals_used": [
      "int   wdc_atapi_intr_for_us",
      "int   wdc_atapi_send_packet",
      "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdccommand",
          "args": [
            "chp",
            "xfer->drive",
            "ATAPI_PKT_CMD",
            "xfer->c_bcount <= 0xfffe ? xfer->c_bcount : 0xfffe",
            "0",
            "0",
            "0",
            "(xfer->c_flags & C_DMA) ? ATAPI_PKT_CMD_FTRE_DMA : 0"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "wdccommandshort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1534-1548",
          "snippet": "void\nwdccommandshort(chp, drive, command)\n\tstruct channel_softc *chp;\n\tint drive;\n\tint command;\n{\n\n\tWDCDEBUG_PRINT((\"wdccommandshort %s:%d:%d command 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive, command),\n\t    DEBUG_FUNCS);\n\n\t/* Select drive. */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\tCHP_WRITE_REG(chp, wdr_command, command);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nvoid\nwdccommandshort(chp, drive, command)\n\tstruct channel_softc *chp;\n\tint drive;\n\tint command;\n{\n\n\tWDCDEBUG_PRINT((\"wdccommandshort %s:%d:%d command 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive, command),\n\t    DEBUG_FUNCS);\n\n\t/* Select drive. */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\tCHP_WRITE_REG(chp, wdr_command, command);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GOTO_NEXT 1\n\nint   wdc_atapi_intr_for_us;\nint   wdc_atapi_send_packet;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_send_packet(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tstruct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;\n\n\t/*\n\t * Even with WDCS_ERR, the device should accept a command packet\n\t * Limit length to what can be stuffed into the cylinder register\n\t * (16 bits).  Some CD-ROMs seem to interpret '0' as 65536,\n\t * but not all devices do that and it's not obvious from the\n\t * ATAPI spec that that behaviour should be expected.  If more\n\t * data is necessary, multiple data transfer phases will be done.\n\t */\n\n\twdccommand(chp, xfer->drive, ATAPI_PKT_CMD, \n\t    xfer->c_bcount <= 0xfffe ? xfer->c_bcount : 0xfffe,\n\t    0, 0, 0, \n\t    (xfer->c_flags & C_DMA) ? ATAPI_PKT_CMD_FTRE_DMA : 0);\n\n\tas->protocol_phase = as_cmdout;\n\tas->retries = 0;\n\n\tDELAY(1);\n\n\txfer->next = wdc_atapi_intr_for_us;\n\txfer->timeout = sc_xfer->timeout;\n\n\tif ((drvp->atapi_cap & ATAPI_CFG_DRQ_MASK) == ATAPI_CFG_IRQ_DRQ) {\n\t\t/* We expect an IRQ to tell us of the next state */\n\t\txfer->expect_irq = 1;\n\t}\n\treturn (GOTO_NEXT);\n}"
  },
  {
    "function_name": "wdc_atapi_real_start_2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "784-822",
    "snippet": "int\nwdc_atapi_real_start_2(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\n\tif (timeout) {\n\t\tprintf(\"wdc_atapi_start: not ready, st = %02x\\n\",\n\t\t    chp->ch_status);\n\n\t\tsc_xfer->error = XS_TIMEOUT;\n\t\txfer->next = wdc_atapi_reset;\n\t\treturn (GOTO_NEXT);\n\t} else {\n\t\twdc_atapi_update_status(chp);\n\t\t\n\t\tif (chp->ch_status & WDCS_BSY)\n\t\t\treturn (CONTINUE_POLL);\n\t}\n    \n\t/* Do control operations specially. */\n\tif (drvp->state < READY) {\n\t\tif (drvp->state != IDENTIFY) {\n\t\t\tprintf(\"%s:%d:%d: bad state %d in wdc_atapi_start\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive, drvp->state);\n\t\t\tpanic(\"wdc_atapi_start: bad state\");\n\t\t}\n\n\t\txfer->next = wdc_atapi_ctrl;\n\t\treturn (GOTO_NEXT);\n\t}\n\n\txfer->next = wdc_atapi_send_packet;\n\treturn (GOTO_NEXT);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define GOTO_NEXT 1",
      "#define CONTINUE_POLL 0"
    ],
    "globals_used": [
      "void  wdc_atapi_start",
      "int   wdc_atapi_real_start_2",
      "int   wdc_atapi_send_packet",
      "int   wdc_atapi_ctrl",
      "int   wdc_atapi_reset",
      "void wdc_atapi_update_status",
      "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wdc_atapi_start: bad state\""
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s:%d:%d: bad state %d in wdc_atapi_start\\n\"",
            "chp->wdc->sc_dev.dv_xname",
            "chp->channel",
            "xfer->drive",
            "drvp->state"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_atapi_update_status",
          "args": [
            "chp"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_atapi_update_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
          "lines": "733-747",
          "snippet": "void\nwdc_atapi_update_status(chp)\n\tstruct channel_softc *chp;\n{\n\tchp->ch_status = CHP_READ_REG(chp, wdr_status);\n\n\tif (chp->ch_status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n\n\t\tchp->ch_status = CHP_READ_REG(chp, wdr_status);\n\t}\n\n\tif ((chp->ch_status & (WDCS_BSY | WDCS_ERR)) == WDCS_ERR)\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n}",
          "includes": [
            "#include <dev/atapiscsi/atapiconf.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_tape.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/reboot.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void wdc_atapi_update_status"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wdc_atapi_update_status;\n\nvoid\nwdc_atapi_update_status(chp)\n\tstruct channel_softc *chp;\n{\n\tchp->ch_status = CHP_READ_REG(chp, wdr_status);\n\n\tif (chp->ch_status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n\n\t\tchp->ch_status = CHP_READ_REG(chp, wdr_status);\n\t}\n\n\tif ((chp->ch_status & (WDCS_BSY | WDCS_ERR)) == WDCS_ERR)\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GOTO_NEXT 1\n#define CONTINUE_POLL 0\n\nvoid  wdc_atapi_start;\nint   wdc_atapi_real_start_2;\nint   wdc_atapi_send_packet;\nint   wdc_atapi_ctrl;\nint   wdc_atapi_reset;\nvoid wdc_atapi_update_status;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_real_start_2(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\n\tif (timeout) {\n\t\tprintf(\"wdc_atapi_start: not ready, st = %02x\\n\",\n\t\t    chp->ch_status);\n\n\t\tsc_xfer->error = XS_TIMEOUT;\n\t\txfer->next = wdc_atapi_reset;\n\t\treturn (GOTO_NEXT);\n\t} else {\n\t\twdc_atapi_update_status(chp);\n\t\t\n\t\tif (chp->ch_status & WDCS_BSY)\n\t\t\treturn (CONTINUE_POLL);\n\t}\n    \n\t/* Do control operations specially. */\n\tif (drvp->state < READY) {\n\t\tif (drvp->state != IDENTIFY) {\n\t\t\tprintf(\"%s:%d:%d: bad state %d in wdc_atapi_start\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive, drvp->state);\n\t\t\tpanic(\"wdc_atapi_start: bad state\");\n\t\t}\n\n\t\txfer->next = wdc_atapi_ctrl;\n\t\treturn (GOTO_NEXT);\n\t}\n\n\txfer->next = wdc_atapi_send_packet;\n\treturn (GOTO_NEXT);\n}"
  },
  {
    "function_name": "wdc_atapi_real_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "749-781",
    "snippet": "int\nwdc_atapi_real_start(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n#ifdef WDCDEBUG\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n#endif\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\n\tWDCDEBUG_PRINT((\"wdc_atapi_start %s:%d:%d, scsi flags 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive,\n\t    sc_xfer->flags), DEBUG_XFERS);\n\n\t/* Adjust C_DMA, it may have changed if we are requesting sense */\n\tif (!(xfer->c_flags & C_POLL) && \n\t    (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA)) &&\n\t    (xfer->c_bcount > 0 || (xfer->c_flags & C_SENSE)))\n\t\txfer->c_flags |= C_DMA;\n\telse\n\t\txfer->c_flags &= ~C_DMA;\n\n\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\n\tDELAY(1);\n\n\txfer->next = wdc_atapi_real_start_2;\n\txfer->timeout = ATAPI_DELAY;\n\n\treturn (GOTO_NEXT);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define GOTO_NEXT 1",
      "#define ATAPI_DELAY 10",
      "#define DEBUG_XFERS  0x02"
    ],
    "globals_used": [
      "void  wdc_atapi_start",
      "int   wdc_atapi_real_start",
      "int   wdc_atapi_real_start_2",
      "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM | (xfer->drive << 4)"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_atapi_start %s:%d:%d, scsi flags 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive,\n\t    sc_xfer->flags)",
            "DEBUG_XFERS"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GOTO_NEXT 1\n#define ATAPI_DELAY 10\n#define DEBUG_XFERS  0x02\n\nvoid  wdc_atapi_start;\nint   wdc_atapi_real_start;\nint   wdc_atapi_real_start_2;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_real_start(chp, xfer, timeout)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint timeout;\n{\n#ifdef WDCDEBUG\n\tstruct scsi_xfer *sc_xfer = xfer->cmd;\n#endif\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\n\tWDCDEBUG_PRINT((\"wdc_atapi_start %s:%d:%d, scsi flags 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive,\n\t    sc_xfer->flags), DEBUG_XFERS);\n\n\t/* Adjust C_DMA, it may have changed if we are requesting sense */\n\tif (!(xfer->c_flags & C_POLL) && \n\t    (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA)) &&\n\t    (xfer->c_bcount > 0 || (xfer->c_flags & C_SENSE)))\n\t\txfer->c_flags |= C_DMA;\n\telse\n\t\txfer->c_flags &= ~C_DMA;\n\n\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\n\tDELAY(1);\n\n\txfer->next = wdc_atapi_real_start_2;\n\txfer->timeout = ATAPI_DELAY;\n\n\treturn (GOTO_NEXT);\n}"
  },
  {
    "function_name": "wdc_atapi_update_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "733-747",
    "snippet": "void\nwdc_atapi_update_status(chp)\n\tstruct channel_softc *chp;\n{\n\tchp->ch_status = CHP_READ_REG(chp, wdr_status);\n\n\tif (chp->ch_status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n\n\t\tchp->ch_status = CHP_READ_REG(chp, wdr_status);\n\t}\n\n\tif ((chp->ch_status & (WDCS_BSY | WDCS_ERR)) == WDCS_ERR)\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void wdc_atapi_update_status"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_error"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_status"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM | 0x10"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_status"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wdc_atapi_update_status;\n\nvoid\nwdc_atapi_update_status(chp)\n\tstruct channel_softc *chp;\n{\n\tchp->ch_status = CHP_READ_REG(chp, wdr_status);\n\n\tif (chp->ch_status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n\n\t\tchp->ch_status = CHP_READ_REG(chp, wdr_status);\n\t}\n\n\tif ((chp->ch_status & (WDCS_BSY | WDCS_ERR)) == WDCS_ERR)\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n}"
  },
  {
    "function_name": "wdc_atapi_the_machine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "657-728",
    "snippet": "int\nwdc_atapi_the_machine(chp, xfer, ctxt)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\t\n\tenum atapi_context ctxt;\n{\n\tint idx = 0, ret;\n\tint claim_irq = 0;\n\textern int ticks;\n\tint timeout_delay = hz / 10;\n\n\tif (xfer->c_flags & C_POLL) {\n\t\tif (ctxt != ctxt_process) \n\t\t\treturn (0);\n\n\t\twdc_atapi_the_poll_machine(chp, xfer);\n\t\treturn (0);\n\t}\n\n do_op:\n\tidx++;\n\n\txfer->timeout = -1;\n\txfer->claim_irq = 0;\n\txfer->delay = 0;\n\n\tret = (xfer->next)(chp, xfer, \n\t\t\t   xfer->endticks && (ticks - xfer->endticks >= 0));\n\n\tif (xfer->timeout != -1) \n\t\txfer->endticks = max((xfer->timeout * 1000) / hz, 1) + ticks;\n\n\tif (xfer->claim_irq) claim_irq = xfer->claim_irq;\n\n\tif (xfer->delay) timeout_delay = max(xfer->delay * hz / 1000, 1);\n\n\tswitch (ret) {\n\tcase GOTO_NEXT:\n\t\tif (xfer->expect_irq) {\n\t\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t\t\txfer->expect_irq = 0;\n\t\t\ttimeout(wdctimeout, chp, xfer->endticks - ticks);\n\n\t\t\treturn (claim_irq);\n\t\t}\n\n\t\tif (xfer->delay)\n\t\t\tbreak;\n\n\t\tgoto do_op;\n\n\tcase CONTINUE_POLL:\n\t\tif (xfer->delay) break;\n\t\tif (idx >= 50) break;\n\n\t\tDELAY(1);\n\t\tgoto do_op;\n\n\tcase DONE:\n\t\tif (xfer->c_flags & C_POLL_MACHINE)\n\t\t\tuntimeout (wdc_atapi_timer_handler, xfer);\n\n\t\twdc_free_xfer(chp, xfer);\n\t\twdcstart(chp);\n\n\t\treturn (claim_irq);\n\t}\n\n\ttimeout(wdc_atapi_timer_handler, xfer, timeout_delay);\n\txfer->c_flags |= C_POLL_MACHINE;\n\treturn (claim_irq);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DONE 2",
      "#define GOTO_NEXT 1",
      "#define CONTINUE_POLL 0"
    ],
    "globals_used": [
      "void  wdc_atapi_timer_handler",
      "int wdc_atapi_the_machine",
      "int wdc_atapi_the_poll_machine",
      "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "wdc_atapi_timer_handler",
            "xfer",
            "timeout_delay"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdcstart",
          "args": [
            "chp"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "wdcstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "664-710",
          "snippet": "void\nwdcstart(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_xfer *xfer;\n\n#ifdef WDC_DIAGNOSTIC\n\tint spl1, spl2;\n\n\tspl1 = splbio();\n\tspl2 = splbio();\n\tif (spl2 != spl1) {\n\t\tprintf(\"wdcstart: not at splbio()\\n\");\n\t\tpanic(\"wdcstart\");\n\t}\n\tsplx(spl2);\n\tsplx(spl1);\n#endif /* WDC_DIAGNOSTIC */\n\n\t/* is there a xfer ? */\n\tif ((xfer = chp->ch_queue->sc_xfer.tqh_first) == NULL) {\n\t\treturn;\n\t}\n\n\t/* adjust chp, in case we have a shared queue */\n\tchp = xfer->chp;\n\n\tif ((chp->ch_flags & WDCF_ACTIVE) != 0 ) {\n\t\treturn; /* channel already active */\n\t}\n#ifdef DIAGNOSTIC\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0)\n\t\tpanic(\"wdcstart: channel waiting for irq\\n\");\n#endif\n\tif (chp->wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\tif (!(chp->wdc->claim_hw)(chp, 0))\n\t\t\treturn;\n\n\tWDCDEBUG_PRINT((\"wdcstart: xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\tchp->ch_flags |= WDCF_ACTIVE;\n\tif (chp->ch_drive[xfer->drive].drive_flags & DRIVE_RESET) {\n\t\tchp->ch_drive[xfer->drive].drive_flags &= ~DRIVE_RESET;\n\t\tchp->ch_drive[xfer->drive].state = 0;\n\t}\n\txfer->c_start(chp, xfer);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_XFERS  0x02"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_XFERS  0x02\n\nvoid\nwdcstart(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_xfer *xfer;\n\n#ifdef WDC_DIAGNOSTIC\n\tint spl1, spl2;\n\n\tspl1 = splbio();\n\tspl2 = splbio();\n\tif (spl2 != spl1) {\n\t\tprintf(\"wdcstart: not at splbio()\\n\");\n\t\tpanic(\"wdcstart\");\n\t}\n\tsplx(spl2);\n\tsplx(spl1);\n#endif /* WDC_DIAGNOSTIC */\n\n\t/* is there a xfer ? */\n\tif ((xfer = chp->ch_queue->sc_xfer.tqh_first) == NULL) {\n\t\treturn;\n\t}\n\n\t/* adjust chp, in case we have a shared queue */\n\tchp = xfer->chp;\n\n\tif ((chp->ch_flags & WDCF_ACTIVE) != 0 ) {\n\t\treturn; /* channel already active */\n\t}\n#ifdef DIAGNOSTIC\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0)\n\t\tpanic(\"wdcstart: channel waiting for irq\\n\");\n#endif\n\tif (chp->wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\tif (!(chp->wdc->claim_hw)(chp, 0))\n\t\t\treturn;\n\n\tWDCDEBUG_PRINT((\"wdcstart: xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\tchp->ch_flags |= WDCF_ACTIVE;\n\tif (chp->ch_drive[xfer->drive].drive_flags & DRIVE_RESET) {\n\t\tchp->ch_drive[xfer->drive].drive_flags &= ~DRIVE_RESET;\n\t\tchp->ch_drive[xfer->drive].state = 0;\n\t}\n\txfer->c_start(chp, xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_free_xfer",
          "args": [
            "chp",
            "xfer"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1617-1633",
          "snippet": "void\nwdc_free_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint s;\n\n\tif (wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\t(*wdc->free_hw)(chp);\n\ts = splbio();\n\tchp->ch_flags &= ~WDCF_ACTIVE;\n\tTAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);\n\txfer->c_flags &= ~C_INUSE;\n\tLIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_free_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint s;\n\n\tif (wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\t(*wdc->free_hw)(chp);\n\ts = splbio();\n\tchp->ch_flags &= ~WDCF_ACTIVE;\n\tTAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);\n\txfer->c_flags &= ~C_INUSE;\n\tLIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "wdc_atapi_timer_handler",
            "xfer"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "xfer->delay * hz / 1000",
            "1"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_setmaxtags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5620-5630",
          "snippet": "static void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define MAX_LUN     (8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define MAX_LUN     (8)\n\nstatic void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "chp",
            "xfer",
            "xfer->endticks && (ticks - xfer->endticks >= 0)"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_atapi_the_poll_machine",
          "args": [
            "chp",
            "xfer"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_atapi_the_poll_machine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
          "lines": "612-655",
          "snippet": "int\nwdc_atapi_the_poll_machine(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\t\n{\n\tint  idx = 0, ret;\n\tint  current_timeout = 10;\n\n\txfer->timeout = -1;\n\n\twhile (1) {\n\t\tidx++;\n\n\t\txfer->timeout = -1;\n\t\txfer->delay = 0;\n\t\txfer->expect_irq = 0;\n\n\t\tret = (xfer->next)(chp, xfer, (current_timeout * 1000 <= idx));\n\n\t\tif (xfer->timeout != -1) {\n\t\t\tcurrent_timeout = xfer->timeout;\n\t\t\tidx = 0;\n\t\t}\n\n\t\tif (xfer->delay != 0) {\n\t\t\tdelay (1000 * xfer->delay);\n\t\t\tidx += 1000 * xfer->delay;\n\t\t}\n\n\t\tswitch (ret) {\n\t\tcase GOTO_NEXT:\n\t\t\tbreak;\n\t\t\t\n\t        case CONTINUE_POLL:\n\t\t\tDELAY(1);\n\t\t\tbreak;\n\n\t\tcase DONE:\n\t\t\twdc_free_xfer(chp, xfer);\n\t\t\twdcstart(chp);\n\t\t\treturn (0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/atapiscsi/atapiconf.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_tape.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/reboot.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DONE 2",
            "#define GOTO_NEXT 1",
            "#define CONTINUE_POLL 0"
          ],
          "globals_used": [
            "int wdc_atapi_the_poll_machine",
            "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DONE 2\n#define GOTO_NEXT 1\n#define CONTINUE_POLL 0\n\nint wdc_atapi_the_poll_machine;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_the_poll_machine(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\t\n{\n\tint  idx = 0, ret;\n\tint  current_timeout = 10;\n\n\txfer->timeout = -1;\n\n\twhile (1) {\n\t\tidx++;\n\n\t\txfer->timeout = -1;\n\t\txfer->delay = 0;\n\t\txfer->expect_irq = 0;\n\n\t\tret = (xfer->next)(chp, xfer, (current_timeout * 1000 <= idx));\n\n\t\tif (xfer->timeout != -1) {\n\t\t\tcurrent_timeout = xfer->timeout;\n\t\t\tidx = 0;\n\t\t}\n\n\t\tif (xfer->delay != 0) {\n\t\t\tdelay (1000 * xfer->delay);\n\t\t\tidx += 1000 * xfer->delay;\n\t\t}\n\n\t\tswitch (ret) {\n\t\tcase GOTO_NEXT:\n\t\t\tbreak;\n\t\t\t\n\t        case CONTINUE_POLL:\n\t\t\tDELAY(1);\n\t\t\tbreak;\n\n\t\tcase DONE:\n\t\t\twdc_free_xfer(chp, xfer);\n\t\t\twdcstart(chp);\n\t\t\treturn (0);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DONE 2\n#define GOTO_NEXT 1\n#define CONTINUE_POLL 0\n\nvoid  wdc_atapi_timer_handler;\nint wdc_atapi_the_machine;\nint wdc_atapi_the_poll_machine;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_the_machine(chp, xfer, ctxt)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\t\n\tenum atapi_context ctxt;\n{\n\tint idx = 0, ret;\n\tint claim_irq = 0;\n\textern int ticks;\n\tint timeout_delay = hz / 10;\n\n\tif (xfer->c_flags & C_POLL) {\n\t\tif (ctxt != ctxt_process) \n\t\t\treturn (0);\n\n\t\twdc_atapi_the_poll_machine(chp, xfer);\n\t\treturn (0);\n\t}\n\n do_op:\n\tidx++;\n\n\txfer->timeout = -1;\n\txfer->claim_irq = 0;\n\txfer->delay = 0;\n\n\tret = (xfer->next)(chp, xfer, \n\t\t\t   xfer->endticks && (ticks - xfer->endticks >= 0));\n\n\tif (xfer->timeout != -1) \n\t\txfer->endticks = max((xfer->timeout * 1000) / hz, 1) + ticks;\n\n\tif (xfer->claim_irq) claim_irq = xfer->claim_irq;\n\n\tif (xfer->delay) timeout_delay = max(xfer->delay * hz / 1000, 1);\n\n\tswitch (ret) {\n\tcase GOTO_NEXT:\n\t\tif (xfer->expect_irq) {\n\t\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t\t\txfer->expect_irq = 0;\n\t\t\ttimeout(wdctimeout, chp, xfer->endticks - ticks);\n\n\t\t\treturn (claim_irq);\n\t\t}\n\n\t\tif (xfer->delay)\n\t\t\tbreak;\n\n\t\tgoto do_op;\n\n\tcase CONTINUE_POLL:\n\t\tif (xfer->delay) break;\n\t\tif (idx >= 50) break;\n\n\t\tDELAY(1);\n\t\tgoto do_op;\n\n\tcase DONE:\n\t\tif (xfer->c_flags & C_POLL_MACHINE)\n\t\t\tuntimeout (wdc_atapi_timer_handler, xfer);\n\n\t\twdc_free_xfer(chp, xfer);\n\t\twdcstart(chp);\n\n\t\treturn (claim_irq);\n\t}\n\n\ttimeout(wdc_atapi_timer_handler, xfer, timeout_delay);\n\txfer->c_flags |= C_POLL_MACHINE;\n\treturn (claim_irq);\n}"
  },
  {
    "function_name": "wdc_atapi_the_poll_machine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "612-655",
    "snippet": "int\nwdc_atapi_the_poll_machine(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\t\n{\n\tint  idx = 0, ret;\n\tint  current_timeout = 10;\n\n\txfer->timeout = -1;\n\n\twhile (1) {\n\t\tidx++;\n\n\t\txfer->timeout = -1;\n\t\txfer->delay = 0;\n\t\txfer->expect_irq = 0;\n\n\t\tret = (xfer->next)(chp, xfer, (current_timeout * 1000 <= idx));\n\n\t\tif (xfer->timeout != -1) {\n\t\t\tcurrent_timeout = xfer->timeout;\n\t\t\tidx = 0;\n\t\t}\n\n\t\tif (xfer->delay != 0) {\n\t\t\tdelay (1000 * xfer->delay);\n\t\t\tidx += 1000 * xfer->delay;\n\t\t}\n\n\t\tswitch (ret) {\n\t\tcase GOTO_NEXT:\n\t\t\tbreak;\n\t\t\t\n\t        case CONTINUE_POLL:\n\t\t\tDELAY(1);\n\t\t\tbreak;\n\n\t\tcase DONE:\n\t\t\twdc_free_xfer(chp, xfer);\n\t\t\twdcstart(chp);\n\t\t\treturn (0);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DONE 2",
      "#define GOTO_NEXT 1",
      "#define CONTINUE_POLL 0"
    ],
    "globals_used": [
      "int wdc_atapi_the_poll_machine",
      "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdcstart",
          "args": [
            "chp"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "wdcstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "664-710",
          "snippet": "void\nwdcstart(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_xfer *xfer;\n\n#ifdef WDC_DIAGNOSTIC\n\tint spl1, spl2;\n\n\tspl1 = splbio();\n\tspl2 = splbio();\n\tif (spl2 != spl1) {\n\t\tprintf(\"wdcstart: not at splbio()\\n\");\n\t\tpanic(\"wdcstart\");\n\t}\n\tsplx(spl2);\n\tsplx(spl1);\n#endif /* WDC_DIAGNOSTIC */\n\n\t/* is there a xfer ? */\n\tif ((xfer = chp->ch_queue->sc_xfer.tqh_first) == NULL) {\n\t\treturn;\n\t}\n\n\t/* adjust chp, in case we have a shared queue */\n\tchp = xfer->chp;\n\n\tif ((chp->ch_flags & WDCF_ACTIVE) != 0 ) {\n\t\treturn; /* channel already active */\n\t}\n#ifdef DIAGNOSTIC\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0)\n\t\tpanic(\"wdcstart: channel waiting for irq\\n\");\n#endif\n\tif (chp->wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\tif (!(chp->wdc->claim_hw)(chp, 0))\n\t\t\treturn;\n\n\tWDCDEBUG_PRINT((\"wdcstart: xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\tchp->ch_flags |= WDCF_ACTIVE;\n\tif (chp->ch_drive[xfer->drive].drive_flags & DRIVE_RESET) {\n\t\tchp->ch_drive[xfer->drive].drive_flags &= ~DRIVE_RESET;\n\t\tchp->ch_drive[xfer->drive].state = 0;\n\t}\n\txfer->c_start(chp, xfer);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_XFERS  0x02"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_XFERS  0x02\n\nvoid\nwdcstart(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_xfer *xfer;\n\n#ifdef WDC_DIAGNOSTIC\n\tint spl1, spl2;\n\n\tspl1 = splbio();\n\tspl2 = splbio();\n\tif (spl2 != spl1) {\n\t\tprintf(\"wdcstart: not at splbio()\\n\");\n\t\tpanic(\"wdcstart\");\n\t}\n\tsplx(spl2);\n\tsplx(spl1);\n#endif /* WDC_DIAGNOSTIC */\n\n\t/* is there a xfer ? */\n\tif ((xfer = chp->ch_queue->sc_xfer.tqh_first) == NULL) {\n\t\treturn;\n\t}\n\n\t/* adjust chp, in case we have a shared queue */\n\tchp = xfer->chp;\n\n\tif ((chp->ch_flags & WDCF_ACTIVE) != 0 ) {\n\t\treturn; /* channel already active */\n\t}\n#ifdef DIAGNOSTIC\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0)\n\t\tpanic(\"wdcstart: channel waiting for irq\\n\");\n#endif\n\tif (chp->wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\tif (!(chp->wdc->claim_hw)(chp, 0))\n\t\t\treturn;\n\n\tWDCDEBUG_PRINT((\"wdcstart: xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\tchp->ch_flags |= WDCF_ACTIVE;\n\tif (chp->ch_drive[xfer->drive].drive_flags & DRIVE_RESET) {\n\t\tchp->ch_drive[xfer->drive].drive_flags &= ~DRIVE_RESET;\n\t\tchp->ch_drive[xfer->drive].state = 0;\n\t}\n\txfer->c_start(chp, xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_free_xfer",
          "args": [
            "chp",
            "xfer"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1617-1633",
          "snippet": "void\nwdc_free_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint s;\n\n\tif (wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\t(*wdc->free_hw)(chp);\n\ts = splbio();\n\tchp->ch_flags &= ~WDCF_ACTIVE;\n\tTAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);\n\txfer->c_flags &= ~C_INUSE;\n\tLIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_free_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint s;\n\n\tif (wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\t(*wdc->free_hw)(chp);\n\ts = splbio();\n\tchp->ch_flags &= ~WDCF_ACTIVE;\n\tTAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);\n\txfer->c_flags &= ~C_INUSE;\n\tLIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000 * xfer->delay"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "chp",
            "xfer",
            "(current_timeout * 1000 <= idx)"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DONE 2\n#define GOTO_NEXT 1\n#define CONTINUE_POLL 0\n\nint wdc_atapi_the_poll_machine;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_the_poll_machine(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\t\n{\n\tint  idx = 0, ret;\n\tint  current_timeout = 10;\n\n\txfer->timeout = -1;\n\n\twhile (1) {\n\t\tidx++;\n\n\t\txfer->timeout = -1;\n\t\txfer->delay = 0;\n\t\txfer->expect_irq = 0;\n\n\t\tret = (xfer->next)(chp, xfer, (current_timeout * 1000 <= idx));\n\n\t\tif (xfer->timeout != -1) {\n\t\t\tcurrent_timeout = xfer->timeout;\n\t\t\tidx = 0;\n\t\t}\n\n\t\tif (xfer->delay != 0) {\n\t\t\tdelay (1000 * xfer->delay);\n\t\t\tidx += 1000 * xfer->delay;\n\t\t}\n\n\t\tswitch (ret) {\n\t\tcase GOTO_NEXT:\n\t\t\tbreak;\n\t\t\t\n\t        case CONTINUE_POLL:\n\t\t\tDELAY(1);\n\t\t\tbreak;\n\n\t\tcase DONE:\n\t\t\twdc_free_xfer(chp, xfer);\n\t\t\twdcstart(chp);\n\t\t\treturn (0);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "wdc_atapi_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "593-606",
    "snippet": "int\nwdc_atapi_intr(chp, xfer, irq)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint irq;\n{\n\t/* XXX we should consider an alternate signaling regime here */\n\tif (xfer->c_flags & C_TIMEOU) {\n\t\txfer->c_flags &= ~C_TIMEOU;\n\t\treturn (wdc_atapi_the_machine(chp, xfer, ctxt_timer));\n\t}\n\n\treturn (wdc_atapi_the_machine(chp, xfer, ctxt_interrupt));\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int   wdc_atapi_intr",
      "int wdc_atapi_the_machine",
      "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdc_atapi_the_machine",
          "args": [
            "chp",
            "xfer",
            "ctxt_interrupt"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_atapi_the_machine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
          "lines": "657-728",
          "snippet": "int\nwdc_atapi_the_machine(chp, xfer, ctxt)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\t\n\tenum atapi_context ctxt;\n{\n\tint idx = 0, ret;\n\tint claim_irq = 0;\n\textern int ticks;\n\tint timeout_delay = hz / 10;\n\n\tif (xfer->c_flags & C_POLL) {\n\t\tif (ctxt != ctxt_process) \n\t\t\treturn (0);\n\n\t\twdc_atapi_the_poll_machine(chp, xfer);\n\t\treturn (0);\n\t}\n\n do_op:\n\tidx++;\n\n\txfer->timeout = -1;\n\txfer->claim_irq = 0;\n\txfer->delay = 0;\n\n\tret = (xfer->next)(chp, xfer, \n\t\t\t   xfer->endticks && (ticks - xfer->endticks >= 0));\n\n\tif (xfer->timeout != -1) \n\t\txfer->endticks = max((xfer->timeout * 1000) / hz, 1) + ticks;\n\n\tif (xfer->claim_irq) claim_irq = xfer->claim_irq;\n\n\tif (xfer->delay) timeout_delay = max(xfer->delay * hz / 1000, 1);\n\n\tswitch (ret) {\n\tcase GOTO_NEXT:\n\t\tif (xfer->expect_irq) {\n\t\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t\t\txfer->expect_irq = 0;\n\t\t\ttimeout(wdctimeout, chp, xfer->endticks - ticks);\n\n\t\t\treturn (claim_irq);\n\t\t}\n\n\t\tif (xfer->delay)\n\t\t\tbreak;\n\n\t\tgoto do_op;\n\n\tcase CONTINUE_POLL:\n\t\tif (xfer->delay) break;\n\t\tif (idx >= 50) break;\n\n\t\tDELAY(1);\n\t\tgoto do_op;\n\n\tcase DONE:\n\t\tif (xfer->c_flags & C_POLL_MACHINE)\n\t\t\tuntimeout (wdc_atapi_timer_handler, xfer);\n\n\t\twdc_free_xfer(chp, xfer);\n\t\twdcstart(chp);\n\n\t\treturn (claim_irq);\n\t}\n\n\ttimeout(wdc_atapi_timer_handler, xfer, timeout_delay);\n\txfer->c_flags |= C_POLL_MACHINE;\n\treturn (claim_irq);\n}",
          "includes": [
            "#include <dev/atapiscsi/atapiconf.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_tape.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/reboot.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DONE 2",
            "#define GOTO_NEXT 1",
            "#define CONTINUE_POLL 0"
          ],
          "globals_used": [
            "void  wdc_atapi_timer_handler",
            "int wdc_atapi_the_machine",
            "int wdc_atapi_the_poll_machine",
            "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DONE 2\n#define GOTO_NEXT 1\n#define CONTINUE_POLL 0\n\nvoid  wdc_atapi_timer_handler;\nint wdc_atapi_the_machine;\nint wdc_atapi_the_poll_machine;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_the_machine(chp, xfer, ctxt)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\t\n\tenum atapi_context ctxt;\n{\n\tint idx = 0, ret;\n\tint claim_irq = 0;\n\textern int ticks;\n\tint timeout_delay = hz / 10;\n\n\tif (xfer->c_flags & C_POLL) {\n\t\tif (ctxt != ctxt_process) \n\t\t\treturn (0);\n\n\t\twdc_atapi_the_poll_machine(chp, xfer);\n\t\treturn (0);\n\t}\n\n do_op:\n\tidx++;\n\n\txfer->timeout = -1;\n\txfer->claim_irq = 0;\n\txfer->delay = 0;\n\n\tret = (xfer->next)(chp, xfer, \n\t\t\t   xfer->endticks && (ticks - xfer->endticks >= 0));\n\n\tif (xfer->timeout != -1) \n\t\txfer->endticks = max((xfer->timeout * 1000) / hz, 1) + ticks;\n\n\tif (xfer->claim_irq) claim_irq = xfer->claim_irq;\n\n\tif (xfer->delay) timeout_delay = max(xfer->delay * hz / 1000, 1);\n\n\tswitch (ret) {\n\tcase GOTO_NEXT:\n\t\tif (xfer->expect_irq) {\n\t\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t\t\txfer->expect_irq = 0;\n\t\t\ttimeout(wdctimeout, chp, xfer->endticks - ticks);\n\n\t\t\treturn (claim_irq);\n\t\t}\n\n\t\tif (xfer->delay)\n\t\t\tbreak;\n\n\t\tgoto do_op;\n\n\tcase CONTINUE_POLL:\n\t\tif (xfer->delay) break;\n\t\tif (idx >= 50) break;\n\n\t\tDELAY(1);\n\t\tgoto do_op;\n\n\tcase DONE:\n\t\tif (xfer->c_flags & C_POLL_MACHINE)\n\t\t\tuntimeout (wdc_atapi_timer_handler, xfer);\n\n\t\twdc_free_xfer(chp, xfer);\n\t\twdcstart(chp);\n\n\t\treturn (claim_irq);\n\t}\n\n\ttimeout(wdc_atapi_timer_handler, xfer, timeout_delay);\n\txfer->c_flags |= C_POLL_MACHINE;\n\treturn (claim_irq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint   wdc_atapi_intr;\nint wdc_atapi_the_machine;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_intr(chp, xfer, irq)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint irq;\n{\n\t/* XXX we should consider an alternate signaling regime here */\n\tif (xfer->c_flags & C_TIMEOU) {\n\t\txfer->c_flags &= ~C_TIMEOU;\n\t\treturn (wdc_atapi_the_machine(chp, xfer, ctxt_timer));\n\t}\n\n\treturn (wdc_atapi_the_machine(chp, xfer, ctxt_interrupt));\n}"
  },
  {
    "function_name": "wdc_atapi_timer_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "576-590",
    "snippet": "void\nwdc_atapi_timer_handler(arg)\n\tvoid *arg;\n{\n\tstruct wdc_xfer *xfer = arg;\n\tstruct channel_softc *chp = xfer->chp;\n\tint s;\n\n\txfer->c_flags &= ~C_POLL_MACHINE;\n\n\t/* There is a race here between us and the interrupt */\n\ts = splbio();\n\twdc_atapi_the_machine(chp, xfer, ctxt_timer);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void  wdc_atapi_timer_handler",
      "int wdc_atapi_the_machine",
      "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_atapi_the_machine",
          "args": [
            "chp",
            "xfer",
            "ctxt_timer"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_atapi_the_machine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
          "lines": "657-728",
          "snippet": "int\nwdc_atapi_the_machine(chp, xfer, ctxt)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\t\n\tenum atapi_context ctxt;\n{\n\tint idx = 0, ret;\n\tint claim_irq = 0;\n\textern int ticks;\n\tint timeout_delay = hz / 10;\n\n\tif (xfer->c_flags & C_POLL) {\n\t\tif (ctxt != ctxt_process) \n\t\t\treturn (0);\n\n\t\twdc_atapi_the_poll_machine(chp, xfer);\n\t\treturn (0);\n\t}\n\n do_op:\n\tidx++;\n\n\txfer->timeout = -1;\n\txfer->claim_irq = 0;\n\txfer->delay = 0;\n\n\tret = (xfer->next)(chp, xfer, \n\t\t\t   xfer->endticks && (ticks - xfer->endticks >= 0));\n\n\tif (xfer->timeout != -1) \n\t\txfer->endticks = max((xfer->timeout * 1000) / hz, 1) + ticks;\n\n\tif (xfer->claim_irq) claim_irq = xfer->claim_irq;\n\n\tif (xfer->delay) timeout_delay = max(xfer->delay * hz / 1000, 1);\n\n\tswitch (ret) {\n\tcase GOTO_NEXT:\n\t\tif (xfer->expect_irq) {\n\t\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t\t\txfer->expect_irq = 0;\n\t\t\ttimeout(wdctimeout, chp, xfer->endticks - ticks);\n\n\t\t\treturn (claim_irq);\n\t\t}\n\n\t\tif (xfer->delay)\n\t\t\tbreak;\n\n\t\tgoto do_op;\n\n\tcase CONTINUE_POLL:\n\t\tif (xfer->delay) break;\n\t\tif (idx >= 50) break;\n\n\t\tDELAY(1);\n\t\tgoto do_op;\n\n\tcase DONE:\n\t\tif (xfer->c_flags & C_POLL_MACHINE)\n\t\t\tuntimeout (wdc_atapi_timer_handler, xfer);\n\n\t\twdc_free_xfer(chp, xfer);\n\t\twdcstart(chp);\n\n\t\treturn (claim_irq);\n\t}\n\n\ttimeout(wdc_atapi_timer_handler, xfer, timeout_delay);\n\txfer->c_flags |= C_POLL_MACHINE;\n\treturn (claim_irq);\n}",
          "includes": [
            "#include <dev/atapiscsi/atapiconf.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_tape.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/reboot.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DONE 2",
            "#define GOTO_NEXT 1",
            "#define CONTINUE_POLL 0"
          ],
          "globals_used": [
            "void  wdc_atapi_timer_handler",
            "int wdc_atapi_the_machine",
            "int wdc_atapi_the_poll_machine",
            "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DONE 2\n#define GOTO_NEXT 1\n#define CONTINUE_POLL 0\n\nvoid  wdc_atapi_timer_handler;\nint wdc_atapi_the_machine;\nint wdc_atapi_the_poll_machine;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_the_machine(chp, xfer, ctxt)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\t\n\tenum atapi_context ctxt;\n{\n\tint idx = 0, ret;\n\tint claim_irq = 0;\n\textern int ticks;\n\tint timeout_delay = hz / 10;\n\n\tif (xfer->c_flags & C_POLL) {\n\t\tif (ctxt != ctxt_process) \n\t\t\treturn (0);\n\n\t\twdc_atapi_the_poll_machine(chp, xfer);\n\t\treturn (0);\n\t}\n\n do_op:\n\tidx++;\n\n\txfer->timeout = -1;\n\txfer->claim_irq = 0;\n\txfer->delay = 0;\n\n\tret = (xfer->next)(chp, xfer, \n\t\t\t   xfer->endticks && (ticks - xfer->endticks >= 0));\n\n\tif (xfer->timeout != -1) \n\t\txfer->endticks = max((xfer->timeout * 1000) / hz, 1) + ticks;\n\n\tif (xfer->claim_irq) claim_irq = xfer->claim_irq;\n\n\tif (xfer->delay) timeout_delay = max(xfer->delay * hz / 1000, 1);\n\n\tswitch (ret) {\n\tcase GOTO_NEXT:\n\t\tif (xfer->expect_irq) {\n\t\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t\t\txfer->expect_irq = 0;\n\t\t\ttimeout(wdctimeout, chp, xfer->endticks - ticks);\n\n\t\t\treturn (claim_irq);\n\t\t}\n\n\t\tif (xfer->delay)\n\t\t\tbreak;\n\n\t\tgoto do_op;\n\n\tcase CONTINUE_POLL:\n\t\tif (xfer->delay) break;\n\t\tif (idx >= 50) break;\n\n\t\tDELAY(1);\n\t\tgoto do_op;\n\n\tcase DONE:\n\t\tif (xfer->c_flags & C_POLL_MACHINE)\n\t\t\tuntimeout (wdc_atapi_timer_handler, xfer);\n\n\t\twdc_free_xfer(chp, xfer);\n\t\twdcstart(chp);\n\n\t\treturn (claim_irq);\n\t}\n\n\ttimeout(wdc_atapi_timer_handler, xfer, timeout_delay);\n\txfer->c_flags |= C_POLL_MACHINE;\n\treturn (claim_irq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid  wdc_atapi_timer_handler;\nint wdc_atapi_the_machine;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nvoid\nwdc_atapi_timer_handler(arg)\n\tvoid *arg;\n{\n\tstruct wdc_xfer *xfer = arg;\n\tstruct channel_softc *chp = xfer->chp;\n\tint s;\n\n\txfer->c_flags &= ~C_POLL_MACHINE;\n\n\t/* There is a race here between us and the interrupt */\n\ts = splbio();\n\twdc_atapi_the_machine(chp, xfer, ctxt_timer);\n\tsplx(s);\n}"
  },
  {
    "function_name": "wdc_atapi_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "565-573",
    "snippet": "void\nwdc_atapi_start(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\txfer->next = wdc_atapi_real_start;\n\n\twdc_atapi_the_machine(chp, xfer, ctxt_process);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void  wdc_atapi_start",
      "int   wdc_atapi_real_start",
      "int wdc_atapi_the_machine",
      "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdc_atapi_the_machine",
          "args": [
            "chp",
            "xfer",
            "ctxt_process"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_atapi_the_machine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
          "lines": "657-728",
          "snippet": "int\nwdc_atapi_the_machine(chp, xfer, ctxt)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\t\n\tenum atapi_context ctxt;\n{\n\tint idx = 0, ret;\n\tint claim_irq = 0;\n\textern int ticks;\n\tint timeout_delay = hz / 10;\n\n\tif (xfer->c_flags & C_POLL) {\n\t\tif (ctxt != ctxt_process) \n\t\t\treturn (0);\n\n\t\twdc_atapi_the_poll_machine(chp, xfer);\n\t\treturn (0);\n\t}\n\n do_op:\n\tidx++;\n\n\txfer->timeout = -1;\n\txfer->claim_irq = 0;\n\txfer->delay = 0;\n\n\tret = (xfer->next)(chp, xfer, \n\t\t\t   xfer->endticks && (ticks - xfer->endticks >= 0));\n\n\tif (xfer->timeout != -1) \n\t\txfer->endticks = max((xfer->timeout * 1000) / hz, 1) + ticks;\n\n\tif (xfer->claim_irq) claim_irq = xfer->claim_irq;\n\n\tif (xfer->delay) timeout_delay = max(xfer->delay * hz / 1000, 1);\n\n\tswitch (ret) {\n\tcase GOTO_NEXT:\n\t\tif (xfer->expect_irq) {\n\t\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t\t\txfer->expect_irq = 0;\n\t\t\ttimeout(wdctimeout, chp, xfer->endticks - ticks);\n\n\t\t\treturn (claim_irq);\n\t\t}\n\n\t\tif (xfer->delay)\n\t\t\tbreak;\n\n\t\tgoto do_op;\n\n\tcase CONTINUE_POLL:\n\t\tif (xfer->delay) break;\n\t\tif (idx >= 50) break;\n\n\t\tDELAY(1);\n\t\tgoto do_op;\n\n\tcase DONE:\n\t\tif (xfer->c_flags & C_POLL_MACHINE)\n\t\t\tuntimeout (wdc_atapi_timer_handler, xfer);\n\n\t\twdc_free_xfer(chp, xfer);\n\t\twdcstart(chp);\n\n\t\treturn (claim_irq);\n\t}\n\n\ttimeout(wdc_atapi_timer_handler, xfer, timeout_delay);\n\txfer->c_flags |= C_POLL_MACHINE;\n\treturn (claim_irq);\n}",
          "includes": [
            "#include <dev/atapiscsi/atapiconf.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_tape.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/reboot.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DONE 2",
            "#define GOTO_NEXT 1",
            "#define CONTINUE_POLL 0"
          ],
          "globals_used": [
            "void  wdc_atapi_timer_handler",
            "int wdc_atapi_the_machine",
            "int wdc_atapi_the_poll_machine",
            "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DONE 2\n#define GOTO_NEXT 1\n#define CONTINUE_POLL 0\n\nvoid  wdc_atapi_timer_handler;\nint wdc_atapi_the_machine;\nint wdc_atapi_the_poll_machine;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_the_machine(chp, xfer, ctxt)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\t\n\tenum atapi_context ctxt;\n{\n\tint idx = 0, ret;\n\tint claim_irq = 0;\n\textern int ticks;\n\tint timeout_delay = hz / 10;\n\n\tif (xfer->c_flags & C_POLL) {\n\t\tif (ctxt != ctxt_process) \n\t\t\treturn (0);\n\n\t\twdc_atapi_the_poll_machine(chp, xfer);\n\t\treturn (0);\n\t}\n\n do_op:\n\tidx++;\n\n\txfer->timeout = -1;\n\txfer->claim_irq = 0;\n\txfer->delay = 0;\n\n\tret = (xfer->next)(chp, xfer, \n\t\t\t   xfer->endticks && (ticks - xfer->endticks >= 0));\n\n\tif (xfer->timeout != -1) \n\t\txfer->endticks = max((xfer->timeout * 1000) / hz, 1) + ticks;\n\n\tif (xfer->claim_irq) claim_irq = xfer->claim_irq;\n\n\tif (xfer->delay) timeout_delay = max(xfer->delay * hz / 1000, 1);\n\n\tswitch (ret) {\n\tcase GOTO_NEXT:\n\t\tif (xfer->expect_irq) {\n\t\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t\t\txfer->expect_irq = 0;\n\t\t\ttimeout(wdctimeout, chp, xfer->endticks - ticks);\n\n\t\t\treturn (claim_irq);\n\t\t}\n\n\t\tif (xfer->delay)\n\t\t\tbreak;\n\n\t\tgoto do_op;\n\n\tcase CONTINUE_POLL:\n\t\tif (xfer->delay) break;\n\t\tif (idx >= 50) break;\n\n\t\tDELAY(1);\n\t\tgoto do_op;\n\n\tcase DONE:\n\t\tif (xfer->c_flags & C_POLL_MACHINE)\n\t\t\tuntimeout (wdc_atapi_timer_handler, xfer);\n\n\t\twdc_free_xfer(chp, xfer);\n\t\twdcstart(chp);\n\n\t\treturn (claim_irq);\n\t}\n\n\ttimeout(wdc_atapi_timer_handler, xfer, timeout_delay);\n\txfer->c_flags |= C_POLL_MACHINE;\n\treturn (claim_irq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid  wdc_atapi_start;\nint   wdc_atapi_real_start;\nint wdc_atapi_the_machine;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nvoid\nwdc_atapi_start(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\txfer->next = wdc_atapi_real_start;\n\n\twdc_atapi_the_machine(chp, xfer, ctxt_process);\n}"
  },
  {
    "function_name": "wdc_atapi_drive_selected",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "544-552",
    "snippet": "int\nwdc_atapi_drive_selected(chp, drive)\n\tstruct channel_softc *chp;\n\tint drive;\n{\n\tu_int8_t reg = CHP_READ_REG(chp, wdr_sdh);\n\n\treturn ((reg & 0x10) == (drive << 4));\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int wdc_atapi_drive_selected"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_sdh"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wdc_atapi_drive_selected;\n\nint\nwdc_atapi_drive_selected(chp, drive)\n\tstruct channel_softc *chp;\n\tint drive;\n{\n\tu_int8_t reg = CHP_READ_REG(chp, wdr_sdh);\n\n\treturn ((reg & 0x10) == (drive << 4));\n}"
  },
  {
    "function_name": "atapi_to_scsi_sense",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "499-540",
    "snippet": "int\natapi_to_scsi_sense(xfer, flags)\n\tstruct scsi_xfer *xfer;\n\tu_int8_t flags;\n{\n\tstruct scsi_sense_data *sense = &xfer->sense;\n\tint ret = 0;\n\n\txfer->error = XS_SHORTSENSE;\n\n\tsense->error_code = SSD_ERRCODE_VALID | 0x70;\n\tsense->flags = (flags >> 4);\n\n\tWDCDEBUG_PRINT((\"Atapi error: %d \", (flags >> 4)), DEBUG_ERRORS);\n\n\tif ((flags & 4) && (sense->flags == 0)) {\n\t\tsense->flags = SKEY_ABORTED_COMMAND;\n\t\tWDCDEBUG_PRINT((\"ABRT \"), DEBUG_ERRORS);\n\t\tret = 1;\n\t}\n\n\tif (flags & 0x1) {\n\t\tsense->flags |= SSD_ILI;\n\t\tWDCDEBUG_PRINT((\"ILI \"), DEBUG_ERRORS);\n\t}\n\n\tif (flags & 0x2) {\n\t\tsense->flags |= SSD_EOM;\n\t\tWDCDEBUG_PRINT((\"EOM \"), DEBUG_ERRORS);\n\t}\n\n\t/* Media change requested */\n\t/* Let's ignore these in version 1 */\n\tif (flags & 0x8) {\n\t\tWDCDEBUG_PRINT((\"MCR \"), DEBUG_ERRORS);\n\t\tif (sense->flags == 0)\n\t\t\txfer->error = XS_NOERROR;\n\t}\n\n\tWDCDEBUG_PRINT((\"\\n\"), DEBUG_ERRORS);\n\treturn (ret);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_ERRORS 0x80   /* Debug error handling code */"
    ],
    "globals_used": [
      "int     atapi_to_scsi_sense",
      "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"\\n\")",
            "DEBUG_ERRORS"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"MCR \")",
            "DEBUG_ERRORS"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"EOM \")",
            "DEBUG_ERRORS"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"ILI \")",
            "DEBUG_ERRORS"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"ABRT \")",
            "DEBUG_ERRORS"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"Atapi error: %d \", (flags >> 4))",
            "DEBUG_ERRORS"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_ERRORS 0x80   /* Debug error handling code */\n\nint     atapi_to_scsi_sense;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\natapi_to_scsi_sense(xfer, flags)\n\tstruct scsi_xfer *xfer;\n\tu_int8_t flags;\n{\n\tstruct scsi_sense_data *sense = &xfer->sense;\n\tint ret = 0;\n\n\txfer->error = XS_SHORTSENSE;\n\n\tsense->error_code = SSD_ERRCODE_VALID | 0x70;\n\tsense->flags = (flags >> 4);\n\n\tWDCDEBUG_PRINT((\"Atapi error: %d \", (flags >> 4)), DEBUG_ERRORS);\n\n\tif ((flags & 4) && (sense->flags == 0)) {\n\t\tsense->flags = SKEY_ABORTED_COMMAND;\n\t\tWDCDEBUG_PRINT((\"ABRT \"), DEBUG_ERRORS);\n\t\tret = 1;\n\t}\n\n\tif (flags & 0x1) {\n\t\tsense->flags |= SSD_ILI;\n\t\tWDCDEBUG_PRINT((\"ILI \"), DEBUG_ERRORS);\n\t}\n\n\tif (flags & 0x2) {\n\t\tsense->flags |= SSD_EOM;\n\t\tWDCDEBUG_PRINT((\"EOM \"), DEBUG_ERRORS);\n\t}\n\n\t/* Media change requested */\n\t/* Let's ignore these in version 1 */\n\tif (flags & 0x8) {\n\t\tWDCDEBUG_PRINT((\"MCR \"), DEBUG_ERRORS);\n\t\tif (sense->flags == 0)\n\t\t\txfer->error = XS_NOERROR;\n\t}\n\n\tWDCDEBUG_PRINT((\"\\n\"), DEBUG_ERRORS);\n\treturn (ret);\n}"
  },
  {
    "function_name": "wdc_atapi_send_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "393-491",
    "snippet": "int\nwdc_atapi_send_cmd(sc_xfer)\n\tstruct scsi_xfer *sc_xfer;\n{\n\tstruct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;\n\tint drive = sc_xfer->sc_link->target;\n\tstruct channel_softc *chp = as->chp;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\tstruct wdc_xfer *xfer;\n\tint flags = sc_xfer->flags;\n\tint s, ret;\n\n\tWDCDEBUG_PRINT((\"wdc_atapi_send_cmd %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive), DEBUG_XFERS);\n\n\tif (drive > 1 || !(drvp->drive_flags & DRIVE_ATAPI)) {\n\t\tsc_xfer->error = XS_DRIVER_STUFFUP;\n\t\treturn (COMPLETE);\n\t}\n\n\txfer = wdc_get_xfer(flags & SCSI_NOSLEEP ? WDC_NOSLEEP : WDC_CANSLEEP);\n\tif (xfer == NULL) {\n\t\treturn (TRY_AGAIN_LATER);\n\t}\n\tif (sc_xfer->flags & SCSI_POLL)\n\t\txfer->c_flags |= C_POLL;\n\txfer->drive = drive;\n\txfer->c_flags |= C_ATAPI;\n\txfer->cmd = sc_xfer;\n\txfer->databuf = sc_xfer->data;\n\txfer->c_bcount = sc_xfer->datalen;\n\txfer->c_start = wdc_atapi_start;\n\txfer->c_intr = wdc_atapi_intr;\n\n\ts = splbio();\n\n\tif (drvp->atapi_cap & ACAP_DSC) {\n\t\tWDCDEBUG_PRINT((\"about to send cmd %x \", sc_xfer->cmd->opcode),\n\t\t    DEBUG_DSC);\n\t\tswitch (sc_xfer->cmd->opcode) {\n\t\tcase READ:\n\t\tcase WRITE:\n\t\t\txfer->c_flags |= C_MEDIA_ACCESS;\n\n\t\t\t/* If we are not in buffer availability mode,\n\t\t\t   we limit the first request to 0 bytes, which\n\t\t\t   gets us into buffer availability mode without\n\t\t\t   holding the bus.  */\n\t\t\tif (!(drvp->drive_flags & DRIVE_DSCBA)) {\n\t\t\t\txfer->c_bcount = 0;\n\t\t\t\txfer->transfer_len = \n\t\t\t\t  _3btol(((struct scsi_rw_tape *)\n\t\t\t\t\t  sc_xfer->cmd)->len);\n\t\t\t\t_lto3b(0,\n\t\t\t\t    ((struct scsi_rw_tape *)\n\t\t\t\t    sc_xfer->cmd)->len);\n\t\t\t\txfer->c_done = wdc_atapi_tape_done;\n\t\t\t\tWDCDEBUG_PRINT(\n\t\t\t\t    (\"R/W in completion mode, do 0 blocks\\n\"),\n\t\t\t\t    DEBUG_DSC);\n\t\t\t} else\n\t\t\t\tWDCDEBUG_PRINT((\"R/W %d blocks %d bytes\\n\",\n\t\t\t\t    _3btol(((struct scsi_rw_tape *)\t\n\t\t\t\t\tsc_xfer->cmd)->len), \n\t\t\t\t    sc_xfer->datalen),\n\t\t\t\t    DEBUG_DSC);\n\n\t\t\t/* DSC will change to buffer availability mode.\n\t\t\t   We reflect this in wdc_atapi_intr.  */\n\t\t\tbreak;\n\n\t\tcase ERASE:\t\t/* Media access commands */\n\t\tcase LOAD:\n\t\tcase REWIND:\n\t\tcase SPACE:\n\t\tcase WRITE_FILEMARKS:\n#if 0\n\t\tcase LOCATE:\n\t\tcase READ_POSITION:\n#endif\n\n\t\t\txfer->c_flags |= C_MEDIA_ACCESS;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWDCDEBUG_PRINT((\"no media access\\n\"), DEBUG_DSC);\n\t\t}\n\t}\n\n\twdc_exec_xfer(chp, xfer);\n#ifdef DIAGNOSTIC\n\tif ((xfer->c_flags & C_POLL) != 0 &&\n\t    (sc_xfer->flags & ITSDONE) == 0)\n\t\tpanic(\"wdc_atapi_send_cmd: polled command not done\");\n#endif\n\tret = (sc_xfer->flags & ITSDONE) ? COMPLETE : SUCCESSFULLY_QUEUED;\n\tsplx(s);\n\treturn (ret);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_DSC    0x20",
      "#define DEBUG_XFERS  0x02"
    ],
    "globals_used": [
      "void  wdc_atapi_start",
      "int   wdc_atapi_intr",
      "int   wdc_atapi_send_cmd",
      "int   wdc_atapi_tape_done",
      "char *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wdc_atapi_send_cmd: polled command not done\""
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_exec_xfer",
          "args": [
            "chp",
            "xfer"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_exec_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1552-1577",
          "snippet": "void\nwdc_exec_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tWDCDEBUG_PRINT((\"wdc_exec_xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\n\t/* complete xfer setup */\n\txfer->chp = chp;\n\n\t/*\n\t * If we are a polled command, and the list is not empty,\n\t * we are doing a dump. Drop the list to allow the polled command\n\t * to complete, we're going to reboot soon anyway.\n\t */\n\tif ((xfer->c_flags & C_POLL) != 0 &&\n\t    chp->ch_queue->sc_xfer.tqh_first != NULL) {\n\t\tTAILQ_INIT(&chp->ch_queue->sc_xfer);\n\t}\n\t/* insert at the end of command list */\n\tTAILQ_INSERT_TAIL(&chp->ch_queue->sc_xfer,xfer , c_xferchain);\n\tWDCDEBUG_PRINT((\"wdcstart from wdc_exec_xfer, flags 0x%x\\n\",\n\t    chp->ch_flags), DEBUG_XFERS);\n\twdcstart(chp);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_XFERS  0x02"
          ],
          "globals_used": [
            "struct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_XFERS  0x02\n\nstruct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;\n\nvoid\nwdc_exec_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tWDCDEBUG_PRINT((\"wdc_exec_xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\n\t/* complete xfer setup */\n\txfer->chp = chp;\n\n\t/*\n\t * If we are a polled command, and the list is not empty,\n\t * we are doing a dump. Drop the list to allow the polled command\n\t * to complete, we're going to reboot soon anyway.\n\t */\n\tif ((xfer->c_flags & C_POLL) != 0 &&\n\t    chp->ch_queue->sc_xfer.tqh_first != NULL) {\n\t\tTAILQ_INIT(&chp->ch_queue->sc_xfer);\n\t}\n\t/* insert at the end of command list */\n\tTAILQ_INSERT_TAIL(&chp->ch_queue->sc_xfer,xfer , c_xferchain);\n\tWDCDEBUG_PRINT((\"wdcstart from wdc_exec_xfer, flags 0x%x\\n\",\n\t    chp->ch_flags), DEBUG_XFERS);\n\twdcstart(chp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"no media access\\n\")",
            "DEBUG_DSC"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"R/W %d blocks %d bytes\\n\",\n\t\t\t\t    _3btol(((struct scsi_rw_tape *)\t\n\t\t\t\t\tsc_xfer->cmd)->len), \n\t\t\t\t    sc_xfer->datalen)",
            "DEBUG_DSC"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_3btol",
          "args": [
            "((struct scsi_rw_tape *)\t\n\t\t\t\t\tsc_xfer->cmd)->len"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"R/W in completion mode, do 0 blocks\\n\")",
            "DEBUG_DSC"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_lto3b",
          "args": [
            "0",
            "((struct scsi_rw_tape *)\n\t\t\t\t    sc_xfer->cmd)->len"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_3btol",
          "args": [
            "((struct scsi_rw_tape *)\n\t\t\t\t\t  sc_xfer->cmd)->len"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"about to send cmd %x \", sc_xfer->cmd->opcode)",
            "DEBUG_DSC"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_get_xfer",
          "args": [
            "flags & SCSI_NOSLEEP ? WDC_NOSLEEP : WDC_CANSLEEP"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_atapi_send_cmd %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive)",
            "DEBUG_XFERS"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_DSC    0x20\n#define DEBUG_XFERS  0x02\n\nvoid  wdc_atapi_start;\nint   wdc_atapi_intr;\nint   wdc_atapi_send_cmd;\nint   wdc_atapi_tape_done;\nchar *\nwdc_atapi_in_data_phase(xfer, len, ire)\n\tstruct wdc_xfer *xfer;\n\nint\nwdc_atapi_send_cmd(sc_xfer)\n\tstruct scsi_xfer *sc_xfer;\n{\n\tstruct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;\n\tint drive = sc_xfer->sc_link->target;\n\tstruct channel_softc *chp = as->chp;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\tstruct wdc_xfer *xfer;\n\tint flags = sc_xfer->flags;\n\tint s, ret;\n\n\tWDCDEBUG_PRINT((\"wdc_atapi_send_cmd %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive), DEBUG_XFERS);\n\n\tif (drive > 1 || !(drvp->drive_flags & DRIVE_ATAPI)) {\n\t\tsc_xfer->error = XS_DRIVER_STUFFUP;\n\t\treturn (COMPLETE);\n\t}\n\n\txfer = wdc_get_xfer(flags & SCSI_NOSLEEP ? WDC_NOSLEEP : WDC_CANSLEEP);\n\tif (xfer == NULL) {\n\t\treturn (TRY_AGAIN_LATER);\n\t}\n\tif (sc_xfer->flags & SCSI_POLL)\n\t\txfer->c_flags |= C_POLL;\n\txfer->drive = drive;\n\txfer->c_flags |= C_ATAPI;\n\txfer->cmd = sc_xfer;\n\txfer->databuf = sc_xfer->data;\n\txfer->c_bcount = sc_xfer->datalen;\n\txfer->c_start = wdc_atapi_start;\n\txfer->c_intr = wdc_atapi_intr;\n\n\ts = splbio();\n\n\tif (drvp->atapi_cap & ACAP_DSC) {\n\t\tWDCDEBUG_PRINT((\"about to send cmd %x \", sc_xfer->cmd->opcode),\n\t\t    DEBUG_DSC);\n\t\tswitch (sc_xfer->cmd->opcode) {\n\t\tcase READ:\n\t\tcase WRITE:\n\t\t\txfer->c_flags |= C_MEDIA_ACCESS;\n\n\t\t\t/* If we are not in buffer availability mode,\n\t\t\t   we limit the first request to 0 bytes, which\n\t\t\t   gets us into buffer availability mode without\n\t\t\t   holding the bus.  */\n\t\t\tif (!(drvp->drive_flags & DRIVE_DSCBA)) {\n\t\t\t\txfer->c_bcount = 0;\n\t\t\t\txfer->transfer_len = \n\t\t\t\t  _3btol(((struct scsi_rw_tape *)\n\t\t\t\t\t  sc_xfer->cmd)->len);\n\t\t\t\t_lto3b(0,\n\t\t\t\t    ((struct scsi_rw_tape *)\n\t\t\t\t    sc_xfer->cmd)->len);\n\t\t\t\txfer->c_done = wdc_atapi_tape_done;\n\t\t\t\tWDCDEBUG_PRINT(\n\t\t\t\t    (\"R/W in completion mode, do 0 blocks\\n\"),\n\t\t\t\t    DEBUG_DSC);\n\t\t\t} else\n\t\t\t\tWDCDEBUG_PRINT((\"R/W %d blocks %d bytes\\n\",\n\t\t\t\t    _3btol(((struct scsi_rw_tape *)\t\n\t\t\t\t\tsc_xfer->cmd)->len), \n\t\t\t\t    sc_xfer->datalen),\n\t\t\t\t    DEBUG_DSC);\n\n\t\t\t/* DSC will change to buffer availability mode.\n\t\t\t   We reflect this in wdc_atapi_intr.  */\n\t\t\tbreak;\n\n\t\tcase ERASE:\t\t/* Media access commands */\n\t\tcase LOAD:\n\t\tcase REWIND:\n\t\tcase SPACE:\n\t\tcase WRITE_FILEMARKS:\n#if 0\n\t\tcase LOCATE:\n\t\tcase READ_POSITION:\n#endif\n\n\t\t\txfer->c_flags |= C_MEDIA_ACCESS;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWDCDEBUG_PRINT((\"no media access\\n\"), DEBUG_DSC);\n\t\t}\n\t}\n\n\twdc_exec_xfer(chp, xfer);\n#ifdef DIAGNOSTIC\n\tif ((xfer->c_flags & C_POLL) != 0 &&\n\t    (sc_xfer->flags & ITSDONE) == 0)\n\t\tpanic(\"wdc_atapi_send_cmd: polled command not done\");\n#endif\n\tret = (sc_xfer->flags & ITSDONE) ? COMPLETE : SUCCESSFULLY_QUEUED;\n\tsplx(s);\n\treturn (ret);\n}"
  },
  {
    "function_name": "wdc_atapi_get_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "329-391",
    "snippet": "int\nwdc_atapi_get_params(chp, drive, id)\n\tstruct channel_softc *chp;\n\tu_int8_t drive;\n\tstruct ataparams *id;\n{\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\tstruct wdc_command wdc_c;\n\tint retries = 3;\n\n\t/* if no ATAPI device detected at wdc attach time, skip */\n\t/*\n\t * XXX this will break scsireprobe if this is of any interest for\n\t * ATAPI devices one day.\n\t */\n\tif ((drvp->drive_flags & DRIVE_ATAPI) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_get_params: drive %d not present\\n\",\n\t\t    drive), DEBUG_PROBE);\n\t\treturn (-1);\n\t}\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\twdc_c.r_command = ATAPI_SOFT_RESET;\n\twdc_c.r_st_bmask = 0;\n\twdc_c.r_st_pmask = 0;\n\twdc_c.flags = at_poll;\n\twdc_c.timeout = ATAPI_RESET_WAIT;\n\tif (wdc_exec_command(drvp, &wdc_c) != WDC_COMPLETE) {\n\t\tprintf(\"wdc_atapi_get_params: ATAPI_SOFT_RESET failed for\"\n\t\t    \" drive %s:%d:%d: driver failed\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive);\n\t\tpanic(\"wdc_atapi_get_params\");\n\t}\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_get_params: ATAPI_SOFT_RESET \"\n\t\t    \"failed for drive %s:%d:%d: error 0x%x\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive, \n\t\t    wdc_c.r_error), DEBUG_PROBE);\n\t\treturn (-1);\n\t}\n\tdrvp->state = 0;\n\n\tCHP_READ_REG(chp, wdr_status);\n\t\n\t/* Some ATAPI devices need a bit more time after software reset. */\n\tdelay(5000);\n\n retry:\n\tif (ata_get_params(drvp, at_poll, id) != 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_get_params: ATAPI_IDENTIFY_DEVICE \"\n\t\t    \"failed for drive %s:%d:%d\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive), \n\t\t    DEBUG_PROBE);\n\n\t\tif (retries--) {\n\t\t\tdelay(100000);\n\t\t\tgoto retry;\n\t\t}\n\n\t\treturn (-1);\n\t}\n\n\treturn (COMPLETE);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define ATAPI_RESET_WAIT 2000",
      "#define DEBUG_PROBE  0x10"
    ],
    "globals_used": [
      "int\twdc_atapi_get_params"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100000"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_atapi_get_params: ATAPI_IDENTIFY_DEVICE \"\n\t\t    \"failed for drive %s:%d:%d\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive)",
            "DEBUG_PROBE"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ata_get_params",
          "args": [
            "drvp",
            "at_poll",
            "id"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "ata_get_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata.c",
          "lines": "59-149",
          "snippet": "int\nata_get_params(drvp, flags, prms)\n\tstruct ata_drive_datas *drvp;\n\tu_int8_t flags;\n\tstruct ataparams *prms;\n{\n\tchar tb[ATAPARAMS_SIZE];\n\tstruct wdc_command wdc_c;\n\n\tint i;\n\tu_int16_t *p;\n\n\tWDCDEBUG_PRINT((\"ata_get_parms\\n\"), DEBUG_FUNCS);\n\n\tbzero(tb, sizeof(tb));\n\tbzero(prms, sizeof(struct ataparams));\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\n\tif (drvp->drive_flags & DRIVE_ATA) {\n\t\twdc_c.r_command = WDCC_IDENTIFY;\n\t\twdc_c.r_st_bmask = WDCS_DRDY;\n\t\twdc_c.r_st_pmask = WDCS_DRQ;\n\t\twdc_c.timeout = 1000; /* 1s */\n\t} else if (drvp->drive_flags & DRIVE_ATAPI) {\n\t\twdc_c.r_command = ATAPI_IDENTIFY_DEVICE;\n\t\twdc_c.r_st_bmask = 0;\n\t\twdc_c.r_st_pmask = WDCS_DRQ;\n\t\twdc_c.timeout = 10000; /* 10s */\n\t} else {\n\t\treturn CMD_ERR;\n\t}\n\twdc_c.flags = AT_READ | flags;\n\twdc_c.data = tb;\n\twdc_c.bcount = ATAPARAMS_SIZE;\n\n\t{\n\t\tint ret;\n\t\tif ((ret = wdc_exec_command(drvp, &wdc_c)) != WDC_COMPLETE) {\n\t\t\tprintf (\"WDC_EXEC_COMMAND: %d\\n\");\n\t\t\treturn CMD_AGAIN;\n\t\t}\n\t}\n\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\treturn CMD_ERR;\n\t} else {\n#if BYTE_ORDER == BIG_ENDIAN\n\t\t/* All the fields in the params structure are 16-bit\n\t\t   integers except for the ID strings which are char\n\t\t   strings.  The 16-bit integers are currently in\n\t\t   memory in little-endian, regardless of architecture.\n\t\t   So, they need to be swapped on big-endian architectures\n\t\t   before they are accessed through the ataparams structure.\n\n\t\t   The swaps below avoid touching the char strings.\n\t\t*/\n\t\t  \n\t\tswap16_multi((u_int16_t *)tb, 10);\n\t\tswap16_multi((u_int16_t *)tb + 20, 3);\n\t\tswap16_multi((u_int16_t *)tb + 47, ATAPARAMS_SIZE / 2 - 47);\n#endif\n\t\t/* Read in parameter block. */\n\t\tbcopy(tb, prms, sizeof(struct ataparams));\n\n\t\t/*\n\t\t * Shuffle string byte order.\n\t\t * ATAPI Mitsumi and NEC drives don't need this.\n\t\t */\n\t\tif ((prms->atap_config & WDC_CFG_ATAPI_MASK) ==\n\t\t    WDC_CFG_ATAPI &&\n\t\t    ((prms->atap_model[0] == 'N' &&\n\t\t\tprms->atap_model[1] == 'E') ||\n\t\t     (prms->atap_model[0] == 'F' &&\n\t\t\t prms->atap_model[1] == 'X')))\n\t\t\treturn 0;\n\t\tfor (i = 0; i < sizeof(prms->atap_model); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_model + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\t\tfor (i = 0; i < sizeof(prms->atap_serial); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_serial + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\t\tfor (i = 0; i < sizeof(prms->atap_revision); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_revision + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\n\t\treturn CMD_OK;\n\t}\n}",
          "includes": [
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ATAPARAMS_SIZE 512",
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <dev/ic/wdcreg.h>\n#include <sys/syslog.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ATAPARAMS_SIZE 512\n#define DEBUG_FUNCS  0x08\n\nint\nata_get_params(drvp, flags, prms)\n\tstruct ata_drive_datas *drvp;\n\tu_int8_t flags;\n\tstruct ataparams *prms;\n{\n\tchar tb[ATAPARAMS_SIZE];\n\tstruct wdc_command wdc_c;\n\n\tint i;\n\tu_int16_t *p;\n\n\tWDCDEBUG_PRINT((\"ata_get_parms\\n\"), DEBUG_FUNCS);\n\n\tbzero(tb, sizeof(tb));\n\tbzero(prms, sizeof(struct ataparams));\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\n\tif (drvp->drive_flags & DRIVE_ATA) {\n\t\twdc_c.r_command = WDCC_IDENTIFY;\n\t\twdc_c.r_st_bmask = WDCS_DRDY;\n\t\twdc_c.r_st_pmask = WDCS_DRQ;\n\t\twdc_c.timeout = 1000; /* 1s */\n\t} else if (drvp->drive_flags & DRIVE_ATAPI) {\n\t\twdc_c.r_command = ATAPI_IDENTIFY_DEVICE;\n\t\twdc_c.r_st_bmask = 0;\n\t\twdc_c.r_st_pmask = WDCS_DRQ;\n\t\twdc_c.timeout = 10000; /* 10s */\n\t} else {\n\t\treturn CMD_ERR;\n\t}\n\twdc_c.flags = AT_READ | flags;\n\twdc_c.data = tb;\n\twdc_c.bcount = ATAPARAMS_SIZE;\n\n\t{\n\t\tint ret;\n\t\tif ((ret = wdc_exec_command(drvp, &wdc_c)) != WDC_COMPLETE) {\n\t\t\tprintf (\"WDC_EXEC_COMMAND: %d\\n\");\n\t\t\treturn CMD_AGAIN;\n\t\t}\n\t}\n\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\treturn CMD_ERR;\n\t} else {\n#if BYTE_ORDER == BIG_ENDIAN\n\t\t/* All the fields in the params structure are 16-bit\n\t\t   integers except for the ID strings which are char\n\t\t   strings.  The 16-bit integers are currently in\n\t\t   memory in little-endian, regardless of architecture.\n\t\t   So, they need to be swapped on big-endian architectures\n\t\t   before they are accessed through the ataparams structure.\n\n\t\t   The swaps below avoid touching the char strings.\n\t\t*/\n\t\t  \n\t\tswap16_multi((u_int16_t *)tb, 10);\n\t\tswap16_multi((u_int16_t *)tb + 20, 3);\n\t\tswap16_multi((u_int16_t *)tb + 47, ATAPARAMS_SIZE / 2 - 47);\n#endif\n\t\t/* Read in parameter block. */\n\t\tbcopy(tb, prms, sizeof(struct ataparams));\n\n\t\t/*\n\t\t * Shuffle string byte order.\n\t\t * ATAPI Mitsumi and NEC drives don't need this.\n\t\t */\n\t\tif ((prms->atap_config & WDC_CFG_ATAPI_MASK) ==\n\t\t    WDC_CFG_ATAPI &&\n\t\t    ((prms->atap_model[0] == 'N' &&\n\t\t\tprms->atap_model[1] == 'E') ||\n\t\t     (prms->atap_model[0] == 'F' &&\n\t\t\t prms->atap_model[1] == 'X')))\n\t\t\treturn 0;\n\t\tfor (i = 0; i < sizeof(prms->atap_model); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_model + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\t\tfor (i = 0; i < sizeof(prms->atap_serial); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_serial + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\t\tfor (i = 0; i < sizeof(prms->atap_revision); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_revision + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\n\t\treturn CMD_OK;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_status"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_atapi_get_params: ATAPI_SOFT_RESET \"\n\t\t    \"failed for drive %s:%d:%d: error 0x%x\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive, \n\t\t    wdc_c.r_error)",
            "DEBUG_PROBE"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wdc_atapi_get_params\""
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"wdc_atapi_get_params: ATAPI_SOFT_RESET failed for\"\n\t\t    \" drive %s:%d:%d: driver failed\\n\"",
            "chp->wdc->sc_dev.dv_xname",
            "chp->channel",
            "drive"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_exec_command",
          "args": [
            "drvp",
            "&wdc_c"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_exec_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1306-1369",
          "snippet": "int\nwdc_exec_command(drvp, wdc_c)\n\tstruct ata_drive_datas *drvp;\n\tstruct wdc_command *wdc_c;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_xfer *xfer;\n\tint s, ret;\n\n\tWDCDEBUG_PRINT((\"wdc_exec_command %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),\n\t    DEBUG_FUNCS);\n\n\t/* set up an xfer and queue. Wait for completion */\n\txfer = wdc_get_xfer(wdc_c->flags & AT_WAIT ? WDC_CANSLEEP :\n\t    WDC_NOSLEEP);\n\tif (xfer == NULL) {\n\t\treturn WDC_TRY_AGAIN;\n\t }\n\n\tif (wdc_c->flags & AT_POLL)\n\t\txfer->c_flags |= C_POLL;\n\txfer->drive = drvp->drive;\n\txfer->databuf = wdc_c->data;\n\txfer->c_bcount = wdc_c->bcount;\n\txfer->cmd = wdc_c;\n\txfer->c_start = __wdccommand_start;\n\txfer->c_intr = __wdccommand_intr;\n\txfer->c_kill_xfer = __wdccommand_done;\n\n\ts = splbio();\n\twdc_exec_xfer(chp, xfer);\n#ifdef DIAGNOSTIC\n\tif ((wdc_c->flags & AT_POLL) != 0 &&\n\t    (wdc_c->flags & AT_DONE) == 0)\n\t\tpanic(\"wdc_exec_command: polled command not done\\n\");\n#endif\n\tif (wdc_c->flags & AT_DONE) {\n\t\tret = WDC_COMPLETE;\n\t} else {\n\t\tif (wdc_c->flags & AT_WAIT) {\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command sleeping\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\twhile (!(wdc_c->flags & AT_DONE)) {\n\t\t\t\tint error;\n\t\t\t\terror = tsleep(wdc_c, PRIBIO, \"wdccmd\", 0);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tprintf (\"tsleep error: %d\\n\", error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command waking\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\tret = WDC_COMPLETE;\n\t\t} else {\n\t\t\tret = WDC_QUEUED;\n\t\t}\n\t}\n\tsplx(s);\n\treturn ret;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "void  __wdccommand_done",
            "void  __wdccommand_start",
            "int   __wdccommand_intr",
            "struct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nvoid  __wdccommand_done;\nvoid  __wdccommand_start;\nint   __wdccommand_intr;\nstruct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;\n\nint\nwdc_exec_command(drvp, wdc_c)\n\tstruct ata_drive_datas *drvp;\n\tstruct wdc_command *wdc_c;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_xfer *xfer;\n\tint s, ret;\n\n\tWDCDEBUG_PRINT((\"wdc_exec_command %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),\n\t    DEBUG_FUNCS);\n\n\t/* set up an xfer and queue. Wait for completion */\n\txfer = wdc_get_xfer(wdc_c->flags & AT_WAIT ? WDC_CANSLEEP :\n\t    WDC_NOSLEEP);\n\tif (xfer == NULL) {\n\t\treturn WDC_TRY_AGAIN;\n\t }\n\n\tif (wdc_c->flags & AT_POLL)\n\t\txfer->c_flags |= C_POLL;\n\txfer->drive = drvp->drive;\n\txfer->databuf = wdc_c->data;\n\txfer->c_bcount = wdc_c->bcount;\n\txfer->cmd = wdc_c;\n\txfer->c_start = __wdccommand_start;\n\txfer->c_intr = __wdccommand_intr;\n\txfer->c_kill_xfer = __wdccommand_done;\n\n\ts = splbio();\n\twdc_exec_xfer(chp, xfer);\n#ifdef DIAGNOSTIC\n\tif ((wdc_c->flags & AT_POLL) != 0 &&\n\t    (wdc_c->flags & AT_DONE) == 0)\n\t\tpanic(\"wdc_exec_command: polled command not done\\n\");\n#endif\n\tif (wdc_c->flags & AT_DONE) {\n\t\tret = WDC_COMPLETE;\n\t} else {\n\t\tif (wdc_c->flags & AT_WAIT) {\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command sleeping\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\twhile (!(wdc_c->flags & AT_DONE)) {\n\t\t\t\tint error;\n\t\t\t\terror = tsleep(wdc_c, PRIBIO, \"wdccmd\", 0);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tprintf (\"tsleep error: %d\\n\", error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command waking\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\tret = WDC_COMPLETE;\n\t\t} else {\n\t\t\tret = WDC_QUEUED;\n\t\t}\n\t}\n\tsplx(s);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&wdc_c",
            "sizeof(struct wdc_command)"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_atapi_get_params: drive %d not present\\n\",\n\t\t    drive)",
            "DEBUG_PROBE"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ATAPI_RESET_WAIT 2000\n#define DEBUG_PROBE  0x10\n\nint\twdc_atapi_get_params;\n\nint\nwdc_atapi_get_params(chp, drive, id)\n\tstruct channel_softc *chp;\n\tu_int8_t drive;\n\tstruct ataparams *id;\n{\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\tstruct wdc_command wdc_c;\n\tint retries = 3;\n\n\t/* if no ATAPI device detected at wdc attach time, skip */\n\t/*\n\t * XXX this will break scsireprobe if this is of any interest for\n\t * ATAPI devices one day.\n\t */\n\tif ((drvp->drive_flags & DRIVE_ATAPI) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_get_params: drive %d not present\\n\",\n\t\t    drive), DEBUG_PROBE);\n\t\treturn (-1);\n\t}\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\twdc_c.r_command = ATAPI_SOFT_RESET;\n\twdc_c.r_st_bmask = 0;\n\twdc_c.r_st_pmask = 0;\n\twdc_c.flags = at_poll;\n\twdc_c.timeout = ATAPI_RESET_WAIT;\n\tif (wdc_exec_command(drvp, &wdc_c) != WDC_COMPLETE) {\n\t\tprintf(\"wdc_atapi_get_params: ATAPI_SOFT_RESET failed for\"\n\t\t    \" drive %s:%d:%d: driver failed\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive);\n\t\tpanic(\"wdc_atapi_get_params\");\n\t}\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_get_params: ATAPI_SOFT_RESET \"\n\t\t    \"failed for drive %s:%d:%d: error 0x%x\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive, \n\t\t    wdc_c.r_error), DEBUG_PROBE);\n\t\treturn (-1);\n\t}\n\tdrvp->state = 0;\n\n\tCHP_READ_REG(chp, wdr_status);\n\t\n\t/* Some ATAPI devices need a bit more time after software reset. */\n\tdelay(5000);\n\n retry:\n\tif (ata_get_params(drvp, at_poll, id) != 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_get_params: ATAPI_IDENTIFY_DEVICE \"\n\t\t    \"failed for drive %s:%d:%d\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive), \n\t\t    DEBUG_PROBE);\n\n\t\tif (retries--) {\n\t\t\tdelay(100000);\n\t\t\tgoto retry;\n\t\t}\n\n\t\treturn (-1);\n\t}\n\n\treturn (COMPLETE);\n}"
  },
  {
    "function_name": "wdc_atapi_minphys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "321-327",
    "snippet": "void\nwdc_atapi_minphys (struct buf *bp)\n{\n\tif(bp->b_bcount > MAX_SIZE)\n\t\tbp->b_bcount = MAX_SIZE;\n\tminphys(bp);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MAX_SIZE MAXPHYS"
    ],
    "globals_used": [
      "void  wdc_atapi_minphys"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "minphys",
          "args": [
            "bp"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_atapi_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
          "lines": "321-327",
          "snippet": "void\nwdc_atapi_minphys (struct buf *bp)\n{\n\tif(bp->b_bcount > MAX_SIZE)\n\t\tbp->b_bcount = MAX_SIZE;\n\tminphys(bp);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MAX_SIZE MAXPHYS\n\nvoid  wdc_atapi_minphys;\n\nvoid\nwdc_atapi_minphys (struct buf *bp)\n{\n\tif(bp->b_bcount > MAX_SIZE)\n\t\tbp->b_bcount = MAX_SIZE;\n\tminphys(bp);\n}"
  },
  {
    "function_name": "wdc_atapibus_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "300-319",
    "snippet": "void\nwdc_atapibus_attach(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint channel = chp->channel;\n\tstruct ata_atapi_attach aa_link;\n\n\t/*\n\t * Fill in the adapter.\n\t */\n\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\taa_link.aa_type = T_ATAPI;\n\taa_link.aa_channel = channel;\n\taa_link.aa_openings = 1;\n\taa_link.aa_drv_data = NULL; \n\taa_link.aa_bus_private = chp;\n\n\t(void)config_found(&wdc->sc_dev, (void *)&aa_link, atapi_print);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "&wdc->sc_dev",
            "(void *)&aa_link",
            "atapi_print"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&aa_link",
            "sizeof(struct ata_atapi_attach)"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_atapibus_attach(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint channel = chp->channel;\n\tstruct ata_atapi_attach aa_link;\n\n\t/*\n\t * Fill in the adapter.\n\t */\n\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\taa_link.aa_type = T_ATAPI;\n\taa_link.aa_channel = channel;\n\taa_link.aa_openings = 1;\n\taa_link.aa_drv_data = NULL; \n\taa_link.aa_bus_private = chp;\n\n\t(void)config_found(&wdc->sc_dev, (void *)&aa_link, atapi_print);\n}"
  },
  {
    "function_name": "atapiscsi_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "212-298",
    "snippet": "void\natapiscsi_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n\n{\n\tstruct atapiscsi_softc *as = (struct atapiscsi_softc *)self;\n\tstruct ata_atapi_attach *aa_link = aux;\n\tstruct channel_softc *chp = aa_link->aa_bus_private;\n\tstruct ataparams ids;\n\tstruct ataparams *id = &ids;\n\tint drive;\n\n\tprintf(\"\\n\");\n\n\tas->chp = chp;\n\tas->sc_adapterlink.adapter_softc = as;\n\tas->sc_adapterlink.adapter_target = 7;\n\tas->sc_adapterlink.adapter_buswidth = 2;\n\tas->sc_adapterlink.adapter = &atapiscsi_switch;\n\tas->sc_adapterlink.device = &atapiscsi_dev;\n\tas->sc_adapterlink.openings = 1;\n\tas->sc_adapterlink.flags = SDEV_ATAPI;\n\tas->sc_adapterlink.quirks = SDEV_NOLUNS;\n\n\tfor (drive = 0; drive < 2 ; drive++ ) {\n\t\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\t\t\t\n\t\tif ((drvp->drive_flags & DRIVE_ATAPI) &&\n\t\t    (wdc_atapi_get_params(chp, drive, id) == COMPLETE)) {\n\t\t\t/* Temporarily, the device will be called\n\t\t\t   atapiscsi. */\n\t\t\tstrncpy(drvp->drive_name, as->sc_dev.dv_xname,\n\t\t\t    sizeof(drvp->drive_name) - 1);\n\t\t\tdrvp->cf_flags = as->sc_dev.dv_cfdata->cf_flags;\n\n\t\t\twdc_probe_caps(drvp, id); \n\n\t\t\tWDCDEBUG_PRINT(\n\t\t\t    (\"general config %04x capabilities %04x \",\n\t\t\t    id->atap_config, id->atap_capabilities1),\n\t\t\t    DEBUG_PROBE);\n\n\t\t\t/* Tape drives do funny DSC stuff */\n\t\t\tif (ATAPI_CFG_TYPE(id->atap_config) == \n\t\t\t    ATAPI_CFG_TYPE_SEQUENTIAL)\n\t\t\t\tdrvp->atapi_cap |= ACAP_DSC;\n\n\t\t\tif ((id->atap_config & ATAPI_CFG_CMD_MASK) ==\n\t\t\t    ATAPI_CFG_CMD_16)\n\t\t\t\tdrvp->atapi_cap |= ACAP_LEN;\n\n\t\t\tdrvp->atapi_cap |=\n\t\t\t    (id->atap_config & ATAPI_CFG_DRQ_MASK);\n\n\t\t\tWDCDEBUG_PRINT((\"driver caps %04x\\n\", drvp->atapi_cap),\n\t\t\t    DEBUG_PROBE);\n\t\t} else\n\t\t\tdrvp->drive_flags &= ~DRIVE_ATAPI;\n\t}\n\n\t\n\tas->sc_adapterlink.scsibus = (u_int8_t)-1;\n\n\tconfig_found((struct device *)as, \n\t\t     &as->sc_adapterlink, scsiprint);\n\n\tif (as->sc_adapterlink.scsibus != (u_int8_t)-1) {\n\t\tint bus = as->sc_adapterlink.scsibus;\n\n\t\tfor (drive = 0; drive < 2; drive++) {\n\t\t\textern struct cfdriver scsibus_cd;\n\n\t\t\tstruct scsibus_softc *scsi = scsibus_cd.cd_devs[bus];\n\t\t\tstruct scsi_link *link = scsi->sc_link[drive][0];\n\t\t\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\n\t\t\tif (!link) continue;\n\n\t\t\tstrncpy(drvp->drive_name, \n\t\t\t\t((struct device *)(link->device_softc))->dv_xname, \n\t\t\t\tsizeof(drvp->drive_name) - 1);\n\t\t\t\n\t\t\twdc_print_caps(drvp);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_PROBE  0x10"
    ],
    "globals_used": [
      "void\tatapiscsi_attach",
      "int\twdc_atapi_get_params",
      "static struct scsi_adapter atapiscsi_switch = \n{\n\twdc_atapi_send_cmd,\n\twdc_atapi_minphys,\n\tNULL,\n\tNULL,\n};",
      "static struct scsi_device atapiscsi_dev = \n{\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdc_print_caps",
          "args": [
            "drvp"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_print_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1224-1246",
          "snippet": "void\nwdc_print_caps(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n \tprintf(\"%s: can use \", drvp->drive_name);\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\tprintf(\"32-bit\");\n\t} else \n\t\tprintf(\"16-bit\");\n\n\tprintf(\", PIO mode %d\", drvp->PIO_cap);\n\n\tif (drvp->drive_flags & DRIVE_DMA) {\n\t\tprintf(\", DMA mode %d\", drvp->DMA_cap);\n\t}\n\n\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_cap);\n\t}\n\t\t\t\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_print_caps(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n \tprintf(\"%s: can use \", drvp->drive_name);\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\tprintf(\"32-bit\");\n\t} else \n\t\tprintf(\"16-bit\");\n\n\tprintf(\", PIO mode %d\", drvp->PIO_cap);\n\n\tif (drvp->drive_flags & DRIVE_DMA) {\n\t\tprintf(\", DMA mode %d\", drvp->DMA_cap);\n\t}\n\n\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_cap);\n\t}\n\t\t\t\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "drvp->drive_name",
            "((struct device *)(link->device_softc))->dv_xname",
            "sizeof(drvp->drive_name) - 1"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "(struct device *)as",
            "&as->sc_adapterlink",
            "scsiprint"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"driver caps %04x\\n\", drvp->atapi_cap)",
            "DEBUG_PROBE"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATAPI_CFG_TYPE",
          "args": [
            "id->atap_config"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"general config %04x capabilities %04x \",\n\t\t\t    id->atap_config, id->atap_capabilities1)",
            "DEBUG_PROBE"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_probe_caps",
          "args": [
            "drvp",
            "id"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_probe_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "987-1162",
          "snippet": "void\nwdc_probe_caps(drvp, params)\n\tstruct ata_drive_datas *drvp;\n\tstruct ataparams *params;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint i, printed;\n\tint cf_flags = drvp->cf_flags;\n\n\tif ((wdc->cap & (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==\n\t    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) {\n\t\tstruct ataparams params2;\n\n\t\t/*\n\t\t * Controller claims 16 and 32 bit transfers.\n\t\t * Re-do an IDENTIFY with 32-bit transfers,\n\t\t * and compare results.\n\t\t */\n\t\tdrvp->drive_flags |= DRIVE_CAP32;\n\t\tata_get_params(drvp, at_poll, &params2);\n\t\tif (bcmp(params, &params2, sizeof(struct ataparams)) != 0) {\n\t\t\t/* Not good. fall back to 16bits */\n\t\t\tdrvp->drive_flags &= ~DRIVE_CAP32;\n\t\t}\n\t}\n#if 0 /* Some ultra-DMA drives claims to only support ATA-3. sigh */\n\tif (params->atap_ata_major > 0x01 && \n\t    params->atap_ata_major != 0xffff) {\n\t\tfor (i = 14; i > 0; i--) {\n\t\t\tif (params->atap_ata_major & (1 << i)) {\n\t\t\t\tprintf(\"%sATA version %d\\n\", sep, i);\n\t\t\t\tdrvp->ata_vers = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else \n#endif\n\t/* An ATAPI device is at last PIO mode 3 */\n\tif (drvp->drive_flags & DRIVE_ATAPI)\n\t\tdrvp->PIO_mode = 3;\n\n\t/*\n\t * It's not in the specs, but it seems that some drive \n\t * returns 0xffff in atap_extensions when this field is invalid\n\t */\n\tif (params->atap_extensions != 0xffff &&\n\t    (params->atap_extensions & WDC_EXT_MODES)) {\n\t\tprinted = 0;\n\t\t/*\n\t\t * XXX some drives report something wrong here (they claim to\n\t\t * support PIO mode 8 !). As mode is coded on 3 bits in\n\t\t * SET FEATURE, limit it to 7 (so limit i to 4).\n\t\t * If higther mode than 7 is found, abort.\n\t\t */\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tif ((params->atap_piomode_supp & (1 << i)) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (i > 4) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * See if mode is accepted.\n\t\t\t * If the controller can't set its PIO mode,\n\t\t\t * assume the defaults are good, so don't try\n\t\t\t * to set it\n\t\t\t */\n\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) != 0)\n\t\t\t\tif (ata_set_mode(drvp, 0x08 | (i + 3),\n\t\t\t\t   at_poll) != CMD_OK)\n\t\t\t\t\tcontinue;\n\t\t\tif (!printed) { \n\t\t\t\tprinted = 1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If controller's driver can't set its PIO mode,\n\t\t\t * get the highter one for the drive.\n\t\t\t */\n\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) == 0 ||\n\t\t\t    wdc->PIO_cap >= i + 3) {\n\t\t\t\tdrvp->PIO_mode = i + 3;\n\t\t\t\tdrvp->PIO_cap = i + 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!printed) {\n\t\t\t/* \n\t\t\t * We didn't find a valid PIO mode.\n\t\t\t * Assume the values returned for DMA are buggy too\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\t\tdrvp->drive_flags |= DRIVE_MODE;\n\t\tprinted = 0;\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tif ((params->atap_dmamode_supp & (1 << i)) == 0)\n\t\t\t\tcontinue;\n\t\t\tif ((wdc->cap & WDC_CAPABILITY_DMA) &&\n\t\t\t    (wdc->cap & WDC_CAPABILITY_MODE))\n\t\t\t\tif (ata_set_mode(drvp, 0x20 | i, at_poll)\n\t\t\t\t    != CMD_OK)\n\t\t\t\t\tcontinue;\n\t\t\tif (!printed) {\n\t\t\t\tprinted = 1;\n\t\t\t}\n\t\t\tif (wdc->cap & WDC_CAPABILITY_DMA) {\n\t\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) &&\n\t\t\t\t    wdc->DMA_cap < i)\n\t\t\t\t\tcontinue;\n\t\t\t\tdrvp->DMA_mode = i;\n\t\t\t\tdrvp->DMA_cap = i;\n\t\t\t\tdrvp->drive_flags |= DRIVE_DMA;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (params->atap_extensions & WDC_EXT_UDMA_MODES) {\n\t\t\tfor (i = 7; i >= 0; i--) {\n\t\t\t\tif ((params->atap_udmamode_supp & (1 << i))\n\t\t\t\t    == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) &&\n\t\t\t\t    (wdc->cap & WDC_CAPABILITY_UDMA))\n\t\t\t\t\tif (ata_set_mode(drvp, 0x40 | i,\n\t\t\t\t\t    at_poll) != CMD_OK)\n\t\t\t\t\t\tcontinue;\n\t\t\t\tif (wdc->cap & WDC_CAPABILITY_UDMA) {\n\t\t\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) &&\n\t\t\t\t\t    wdc->UDMA_cap < i)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdrvp->UDMA_mode = i;\n\t\t\t\t\tdrvp->UDMA_cap = i;\n\t\t\t\t\tdrvp->drive_flags |= DRIVE_UDMA;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Try to guess ATA version here, if it didn't get reported */\n\tif (drvp->ata_vers == 0) {\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tdrvp->ata_vers = 4; /* should be at last ATA-4 */\n\t\telse if (drvp->PIO_cap > 2)\n\t\t\tdrvp->ata_vers = 2; /* should be at last ATA-2 */\n\t}\n\tif (cf_flags & ATA_CONFIG_PIO_SET) {\n\t\tdrvp->PIO_mode =\n\t\t    (cf_flags & ATA_CONFIG_PIO_MODES) >> ATA_CONFIG_PIO_OFF;\n\t\tdrvp->drive_flags |= DRIVE_MODE;\n\t}\n\tif ((wdc->cap & WDC_CAPABILITY_DMA) == 0) {\n\t\t/* don't care about DMA modes */\n\t\treturn;\n\t}\n\tif (cf_flags & ATA_CONFIG_DMA_SET) {\n\t\tif ((cf_flags & ATA_CONFIG_DMA_MODES) ==\n\t\t    ATA_CONFIG_DMA_DISABLE) {\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t} else {\n\t\t\tdrvp->DMA_mode = (cf_flags & ATA_CONFIG_DMA_MODES) >>\n\t\t\t    ATA_CONFIG_DMA_OFF;\n\t\t\tdrvp->drive_flags |= DRIVE_DMA | DRIVE_MODE;\n\t\t}\n\t}\n\tif (cf_flags & ATA_CONFIG_UDMA_SET) {\n\t\tif ((cf_flags & ATA_CONFIG_UDMA_MODES) ==\n\t\t    ATA_CONFIG_UDMA_DISABLE) {\n\t\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\t} else {\n\t\t\tdrvp->UDMA_mode = (cf_flags & ATA_CONFIG_UDMA_MODES) >>\n\t\t\t    ATA_CONFIG_UDMA_OFF;\n\t\t\tdrvp->drive_flags |= DRIVE_UDMA | DRIVE_MODE;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int at_poll = AT_POLL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint at_poll = AT_POLL;\n\nvoid\nwdc_probe_caps(drvp, params)\n\tstruct ata_drive_datas *drvp;\n\tstruct ataparams *params;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint i, printed;\n\tint cf_flags = drvp->cf_flags;\n\n\tif ((wdc->cap & (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==\n\t    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) {\n\t\tstruct ataparams params2;\n\n\t\t/*\n\t\t * Controller claims 16 and 32 bit transfers.\n\t\t * Re-do an IDENTIFY with 32-bit transfers,\n\t\t * and compare results.\n\t\t */\n\t\tdrvp->drive_flags |= DRIVE_CAP32;\n\t\tata_get_params(drvp, at_poll, &params2);\n\t\tif (bcmp(params, &params2, sizeof(struct ataparams)) != 0) {\n\t\t\t/* Not good. fall back to 16bits */\n\t\t\tdrvp->drive_flags &= ~DRIVE_CAP32;\n\t\t}\n\t}\n#if 0 /* Some ultra-DMA drives claims to only support ATA-3. sigh */\n\tif (params->atap_ata_major > 0x01 && \n\t    params->atap_ata_major != 0xffff) {\n\t\tfor (i = 14; i > 0; i--) {\n\t\t\tif (params->atap_ata_major & (1 << i)) {\n\t\t\t\tprintf(\"%sATA version %d\\n\", sep, i);\n\t\t\t\tdrvp->ata_vers = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else \n#endif\n\t/* An ATAPI device is at last PIO mode 3 */\n\tif (drvp->drive_flags & DRIVE_ATAPI)\n\t\tdrvp->PIO_mode = 3;\n\n\t/*\n\t * It's not in the specs, but it seems that some drive \n\t * returns 0xffff in atap_extensions when this field is invalid\n\t */\n\tif (params->atap_extensions != 0xffff &&\n\t    (params->atap_extensions & WDC_EXT_MODES)) {\n\t\tprinted = 0;\n\t\t/*\n\t\t * XXX some drives report something wrong here (they claim to\n\t\t * support PIO mode 8 !). As mode is coded on 3 bits in\n\t\t * SET FEATURE, limit it to 7 (so limit i to 4).\n\t\t * If higther mode than 7 is found, abort.\n\t\t */\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tif ((params->atap_piomode_supp & (1 << i)) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (i > 4) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * See if mode is accepted.\n\t\t\t * If the controller can't set its PIO mode,\n\t\t\t * assume the defaults are good, so don't try\n\t\t\t * to set it\n\t\t\t */\n\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) != 0)\n\t\t\t\tif (ata_set_mode(drvp, 0x08 | (i + 3),\n\t\t\t\t   at_poll) != CMD_OK)\n\t\t\t\t\tcontinue;\n\t\t\tif (!printed) { \n\t\t\t\tprinted = 1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If controller's driver can't set its PIO mode,\n\t\t\t * get the highter one for the drive.\n\t\t\t */\n\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) == 0 ||\n\t\t\t    wdc->PIO_cap >= i + 3) {\n\t\t\t\tdrvp->PIO_mode = i + 3;\n\t\t\t\tdrvp->PIO_cap = i + 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!printed) {\n\t\t\t/* \n\t\t\t * We didn't find a valid PIO mode.\n\t\t\t * Assume the values returned for DMA are buggy too\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\t\tdrvp->drive_flags |= DRIVE_MODE;\n\t\tprinted = 0;\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tif ((params->atap_dmamode_supp & (1 << i)) == 0)\n\t\t\t\tcontinue;\n\t\t\tif ((wdc->cap & WDC_CAPABILITY_DMA) &&\n\t\t\t    (wdc->cap & WDC_CAPABILITY_MODE))\n\t\t\t\tif (ata_set_mode(drvp, 0x20 | i, at_poll)\n\t\t\t\t    != CMD_OK)\n\t\t\t\t\tcontinue;\n\t\t\tif (!printed) {\n\t\t\t\tprinted = 1;\n\t\t\t}\n\t\t\tif (wdc->cap & WDC_CAPABILITY_DMA) {\n\t\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) &&\n\t\t\t\t    wdc->DMA_cap < i)\n\t\t\t\t\tcontinue;\n\t\t\t\tdrvp->DMA_mode = i;\n\t\t\t\tdrvp->DMA_cap = i;\n\t\t\t\tdrvp->drive_flags |= DRIVE_DMA;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (params->atap_extensions & WDC_EXT_UDMA_MODES) {\n\t\t\tfor (i = 7; i >= 0; i--) {\n\t\t\t\tif ((params->atap_udmamode_supp & (1 << i))\n\t\t\t\t    == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) &&\n\t\t\t\t    (wdc->cap & WDC_CAPABILITY_UDMA))\n\t\t\t\t\tif (ata_set_mode(drvp, 0x40 | i,\n\t\t\t\t\t    at_poll) != CMD_OK)\n\t\t\t\t\t\tcontinue;\n\t\t\t\tif (wdc->cap & WDC_CAPABILITY_UDMA) {\n\t\t\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) &&\n\t\t\t\t\t    wdc->UDMA_cap < i)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdrvp->UDMA_mode = i;\n\t\t\t\t\tdrvp->UDMA_cap = i;\n\t\t\t\t\tdrvp->drive_flags |= DRIVE_UDMA;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Try to guess ATA version here, if it didn't get reported */\n\tif (drvp->ata_vers == 0) {\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tdrvp->ata_vers = 4; /* should be at last ATA-4 */\n\t\telse if (drvp->PIO_cap > 2)\n\t\t\tdrvp->ata_vers = 2; /* should be at last ATA-2 */\n\t}\n\tif (cf_flags & ATA_CONFIG_PIO_SET) {\n\t\tdrvp->PIO_mode =\n\t\t    (cf_flags & ATA_CONFIG_PIO_MODES) >> ATA_CONFIG_PIO_OFF;\n\t\tdrvp->drive_flags |= DRIVE_MODE;\n\t}\n\tif ((wdc->cap & WDC_CAPABILITY_DMA) == 0) {\n\t\t/* don't care about DMA modes */\n\t\treturn;\n\t}\n\tif (cf_flags & ATA_CONFIG_DMA_SET) {\n\t\tif ((cf_flags & ATA_CONFIG_DMA_MODES) ==\n\t\t    ATA_CONFIG_DMA_DISABLE) {\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t} else {\n\t\t\tdrvp->DMA_mode = (cf_flags & ATA_CONFIG_DMA_MODES) >>\n\t\t\t    ATA_CONFIG_DMA_OFF;\n\t\t\tdrvp->drive_flags |= DRIVE_DMA | DRIVE_MODE;\n\t\t}\n\t}\n\tif (cf_flags & ATA_CONFIG_UDMA_SET) {\n\t\tif ((cf_flags & ATA_CONFIG_UDMA_MODES) ==\n\t\t    ATA_CONFIG_UDMA_DISABLE) {\n\t\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\t} else {\n\t\t\tdrvp->UDMA_mode = (cf_flags & ATA_CONFIG_UDMA_MODES) >>\n\t\t\t    ATA_CONFIG_UDMA_OFF;\n\t\t\tdrvp->drive_flags |= DRIVE_UDMA | DRIVE_MODE;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "drvp->drive_name",
            "as->sc_dev.dv_xname",
            "sizeof(drvp->drive_name) - 1"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_atapi_get_params",
          "args": [
            "chp",
            "drive",
            "id"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_atapi_get_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
          "lines": "329-391",
          "snippet": "int\nwdc_atapi_get_params(chp, drive, id)\n\tstruct channel_softc *chp;\n\tu_int8_t drive;\n\tstruct ataparams *id;\n{\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\tstruct wdc_command wdc_c;\n\tint retries = 3;\n\n\t/* if no ATAPI device detected at wdc attach time, skip */\n\t/*\n\t * XXX this will break scsireprobe if this is of any interest for\n\t * ATAPI devices one day.\n\t */\n\tif ((drvp->drive_flags & DRIVE_ATAPI) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_get_params: drive %d not present\\n\",\n\t\t    drive), DEBUG_PROBE);\n\t\treturn (-1);\n\t}\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\twdc_c.r_command = ATAPI_SOFT_RESET;\n\twdc_c.r_st_bmask = 0;\n\twdc_c.r_st_pmask = 0;\n\twdc_c.flags = at_poll;\n\twdc_c.timeout = ATAPI_RESET_WAIT;\n\tif (wdc_exec_command(drvp, &wdc_c) != WDC_COMPLETE) {\n\t\tprintf(\"wdc_atapi_get_params: ATAPI_SOFT_RESET failed for\"\n\t\t    \" drive %s:%d:%d: driver failed\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive);\n\t\tpanic(\"wdc_atapi_get_params\");\n\t}\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_get_params: ATAPI_SOFT_RESET \"\n\t\t    \"failed for drive %s:%d:%d: error 0x%x\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive, \n\t\t    wdc_c.r_error), DEBUG_PROBE);\n\t\treturn (-1);\n\t}\n\tdrvp->state = 0;\n\n\tCHP_READ_REG(chp, wdr_status);\n\t\n\t/* Some ATAPI devices need a bit more time after software reset. */\n\tdelay(5000);\n\n retry:\n\tif (ata_get_params(drvp, at_poll, id) != 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_get_params: ATAPI_IDENTIFY_DEVICE \"\n\t\t    \"failed for drive %s:%d:%d\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive), \n\t\t    DEBUG_PROBE);\n\n\t\tif (retries--) {\n\t\t\tdelay(100000);\n\t\t\tgoto retry;\n\t\t}\n\n\t\treturn (-1);\n\t}\n\n\treturn (COMPLETE);\n}",
          "includes": [
            "#include <dev/atapiscsi/atapiconf.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_tape.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/reboot.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ATAPI_RESET_WAIT 2000",
            "#define DEBUG_PROBE  0x10"
          ],
          "globals_used": [
            "int\twdc_atapi_get_params"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ATAPI_RESET_WAIT 2000\n#define DEBUG_PROBE  0x10\n\nint\twdc_atapi_get_params;\n\nint\nwdc_atapi_get_params(chp, drive, id)\n\tstruct channel_softc *chp;\n\tu_int8_t drive;\n\tstruct ataparams *id;\n{\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\tstruct wdc_command wdc_c;\n\tint retries = 3;\n\n\t/* if no ATAPI device detected at wdc attach time, skip */\n\t/*\n\t * XXX this will break scsireprobe if this is of any interest for\n\t * ATAPI devices one day.\n\t */\n\tif ((drvp->drive_flags & DRIVE_ATAPI) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_get_params: drive %d not present\\n\",\n\t\t    drive), DEBUG_PROBE);\n\t\treturn (-1);\n\t}\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\twdc_c.r_command = ATAPI_SOFT_RESET;\n\twdc_c.r_st_bmask = 0;\n\twdc_c.r_st_pmask = 0;\n\twdc_c.flags = at_poll;\n\twdc_c.timeout = ATAPI_RESET_WAIT;\n\tif (wdc_exec_command(drvp, &wdc_c) != WDC_COMPLETE) {\n\t\tprintf(\"wdc_atapi_get_params: ATAPI_SOFT_RESET failed for\"\n\t\t    \" drive %s:%d:%d: driver failed\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive);\n\t\tpanic(\"wdc_atapi_get_params\");\n\t}\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_get_params: ATAPI_SOFT_RESET \"\n\t\t    \"failed for drive %s:%d:%d: error 0x%x\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive, \n\t\t    wdc_c.r_error), DEBUG_PROBE);\n\t\treturn (-1);\n\t}\n\tdrvp->state = 0;\n\n\tCHP_READ_REG(chp, wdr_status);\n\t\n\t/* Some ATAPI devices need a bit more time after software reset. */\n\tdelay(5000);\n\n retry:\n\tif (ata_get_params(drvp, at_poll, id) != 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_atapi_get_params: ATAPI_IDENTIFY_DEVICE \"\n\t\t    \"failed for drive %s:%d:%d\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive), \n\t\t    DEBUG_PROBE);\n\n\t\tif (retries--) {\n\t\t\tdelay(100000);\n\t\t\tgoto retry;\n\t\t}\n\n\t\treturn (-1);\n\t}\n\n\treturn (COMPLETE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nvoid\tatapiscsi_attach;\nint\twdc_atapi_get_params;\nstatic struct scsi_adapter atapiscsi_switch = \n{\n\twdc_atapi_send_cmd,\n\twdc_atapi_minphys,\n\tNULL,\n\tNULL,\n};\nstatic struct scsi_device atapiscsi_dev = \n{\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n};\n\nvoid\natapiscsi_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n\n{\n\tstruct atapiscsi_softc *as = (struct atapiscsi_softc *)self;\n\tstruct ata_atapi_attach *aa_link = aux;\n\tstruct channel_softc *chp = aa_link->aa_bus_private;\n\tstruct ataparams ids;\n\tstruct ataparams *id = &ids;\n\tint drive;\n\n\tprintf(\"\\n\");\n\n\tas->chp = chp;\n\tas->sc_adapterlink.adapter_softc = as;\n\tas->sc_adapterlink.adapter_target = 7;\n\tas->sc_adapterlink.adapter_buswidth = 2;\n\tas->sc_adapterlink.adapter = &atapiscsi_switch;\n\tas->sc_adapterlink.device = &atapiscsi_dev;\n\tas->sc_adapterlink.openings = 1;\n\tas->sc_adapterlink.flags = SDEV_ATAPI;\n\tas->sc_adapterlink.quirks = SDEV_NOLUNS;\n\n\tfor (drive = 0; drive < 2 ; drive++ ) {\n\t\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\t\t\t\n\t\tif ((drvp->drive_flags & DRIVE_ATAPI) &&\n\t\t    (wdc_atapi_get_params(chp, drive, id) == COMPLETE)) {\n\t\t\t/* Temporarily, the device will be called\n\t\t\t   atapiscsi. */\n\t\t\tstrncpy(drvp->drive_name, as->sc_dev.dv_xname,\n\t\t\t    sizeof(drvp->drive_name) - 1);\n\t\t\tdrvp->cf_flags = as->sc_dev.dv_cfdata->cf_flags;\n\n\t\t\twdc_probe_caps(drvp, id); \n\n\t\t\tWDCDEBUG_PRINT(\n\t\t\t    (\"general config %04x capabilities %04x \",\n\t\t\t    id->atap_config, id->atap_capabilities1),\n\t\t\t    DEBUG_PROBE);\n\n\t\t\t/* Tape drives do funny DSC stuff */\n\t\t\tif (ATAPI_CFG_TYPE(id->atap_config) == \n\t\t\t    ATAPI_CFG_TYPE_SEQUENTIAL)\n\t\t\t\tdrvp->atapi_cap |= ACAP_DSC;\n\n\t\t\tif ((id->atap_config & ATAPI_CFG_CMD_MASK) ==\n\t\t\t    ATAPI_CFG_CMD_16)\n\t\t\t\tdrvp->atapi_cap |= ACAP_LEN;\n\n\t\t\tdrvp->atapi_cap |=\n\t\t\t    (id->atap_config & ATAPI_CFG_DRQ_MASK);\n\n\t\t\tWDCDEBUG_PRINT((\"driver caps %04x\\n\", drvp->atapi_cap),\n\t\t\t    DEBUG_PROBE);\n\t\t} else\n\t\t\tdrvp->drive_flags &= ~DRIVE_ATAPI;\n\t}\n\n\t\n\tas->sc_adapterlink.scsibus = (u_int8_t)-1;\n\n\tconfig_found((struct device *)as, \n\t\t     &as->sc_adapterlink, scsiprint);\n\n\tif (as->sc_adapterlink.scsibus != (u_int8_t)-1) {\n\t\tint bus = as->sc_adapterlink.scsibus;\n\n\t\tfor (drive = 0; drive < 2; drive++) {\n\t\t\textern struct cfdriver scsibus_cd;\n\n\t\t\tstruct scsibus_softc *scsi = scsibus_cd.cd_devs[bus];\n\t\t\tstruct scsi_link *link = scsi->sc_link[drive][0];\n\t\t\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\n\t\t\tif (!link) continue;\n\n\t\t\tstrncpy(drvp->drive_name, \n\t\t\t\t((struct device *)(link->device_softc))->dv_xname, \n\t\t\t\tsizeof(drvp->drive_name) - 1);\n\t\t\t\n\t\t\twdc_print_caps(drvp);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "atapiscsi_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
    "lines": "190-210",
    "snippet": "int\natapiscsi_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n\n{\n\tstruct ata_atapi_attach *aa_link = aux;\n\tstruct cfdata *cf = match;\n\n\tif (aa_link == NULL)\n\t\treturn (0);\n\n\tif (aa_link->aa_type != T_ATAPI)\n\t\treturn (0);\n\n\tif (cf->cf_loc[0] != aa_link->aa_channel &&\n\t    cf->cf_loc[0] != -1)\n\t\treturn (0);\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/atapiscsi/atapiconf.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_tape.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/reboot.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tatapiscsi_match"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tatapiscsi_match;\n\nint\natapiscsi_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n\n{\n\tstruct ata_atapi_attach *aa_link = aux;\n\tstruct cfdata *cf = match;\n\n\tif (aa_link == NULL)\n\t\treturn (0);\n\n\tif (aa_link->aa_type != T_ATAPI)\n\t\treturn (0);\n\n\tif (cf->cf_loc[0] != aa_link->aa_channel &&\n\t    cf->cf_loc[0] != -1)\n\t\treturn (0);\n\n\treturn (1);\n}"
  }
]