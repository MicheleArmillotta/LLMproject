[
  {
    "function_name": "trtcm_isa_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_trtcm_isa.c",
    "lines": "206-359",
    "snippet": "int\ntrtcm_isa_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct isa_attach_args\t*ia = aux;\n\tint\tbus = parent->dv_unit;\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tu_int\tmsize;\n\tint slot, iobase, irq, i, maddr, rsrccfg, pnpmode;\n\tu_int16_t vendor, model;\n\tstruct tcm_isa_done_probe *tcm;\n\tstatic int irqs[] = { 7, 15, 6, 11, 3, 10, 9, 5 };\n\n\tif (tcm_isa_probes_initialized == 0) {\n\t\tLIST_INIT(&tcm_isa_all_probes);\n\t\ttcm_isa_probes_initialized = 1;\n\t}\n\n\t/*\n\t * Probe this bus if we haven't done so already.\n\t */\n\tfor (tcm = tcm_isa_all_probes.lh_first; tcm != NULL;\n\t    tcm = tcm->tcm_link.le_next)\n\t\tif (tcm->tcm_bus == bus)\n\t\t\tgoto bus_probed;\n\n\t/*\n\t * Mark this bus so we don't probe it again.\n\t */\n\ttcm = (struct tcm_isa_done_probe *)\n\t    malloc(sizeof(struct tcm_isa_done_probe), M_DEVBUF, M_NOWAIT);\n\tif (tcm == NULL) {\n\t\tprintf(\"trtcm_isa_probe: can't allocate state storage\");\n\t\treturn 0;\n\t}\n\n\ttcm->tcm_bus = bus;\n\tLIST_INSERT_HEAD(&tcm_isa_all_probes, tcm, tcm_link);\n\n\t/*\n\t * Map the TokenLink ID port for the probe sequence.\n\t */\n\tif (bus_space_map(iot, ELINK_ID_PORT, 1, 0, &ioh)) {\n\t\tprintf(\"trtcm_isa_probe: can't map TokenLink ID port\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (slot = 0; slot < MAXTCMCARDS; slot++) {\n\t\tpnpmode = 0;\n\t\telink_reset(iot, ioh, bus);\n\t\telink_idseq(iot, ioh, TLINK_619_POLY);\n\n\t\t/* Untag all the adapters so they will talk to us. */\n\t\tif (slot == 0)\n\t\t\tbus_space_write_1(iot, ioh, 0, TAG_ADAPTER + 0);\n\n\t\tvendor = htons(tcmreadeeprom(iot, ioh, EEPROM_MFG_ID));\n\t\tif (vendor != MFG_ID)\n\t\t\tcontinue;\n\n\t\tmodel = htons(tcmreadeeprom(iot, ioh, EEPROM_PROD_ID));\n\t\tif (((model & 0xfff0) != 0x6190) &&\n\t\t    ((model & 0xfff0) != 0x3190)) { /* XXX hardcoded */\n#if 0\n\t\t\tprintf(\"trtcm: unknown model 0x%04x\\n\", model);\n#endif\n\t\t\tcontinue;\n\t\t}\n#ifdef TRTCMISADEBUG\n\t\ttcmdumpeeprom(iot, ioh);\n\n\t\tprintf(\"speed: %d\\n\", (tcmreadeeprom(iot,ioh,8) & 2) ? 4 : 16);\n#endif\n\n\t\trsrccfg = iobase = tcmreadeeprom(iot, ioh, EEPROM_RESOURCE_CFG);\n\t\tif (iobase & 0x20)\n\t\t\tiobase = tcmreadeeprom(iot, ioh, EEPROM_ADDR_CFG) & 1 ?\n\t\t\t    0xa20 : 0xa24;\n\t\telse\n\t\t\tiobase = (iobase & 0x1f) * 0x10 + 0x200;\n\n\t\tmaddr = ((tcmreadeeprom(iot, ioh, EEPROM_OEM_ADDR0) & 0xfc00)\n\t\t    << 3) + 0x80000;\n\t\tmsize = 65536 >> ((tcmreadeeprom(iot, ioh, 8) & 0x0c) >> 2);\n\n\t\tirq = tcmreadeeprom(iot, ioh, EEPROM_ADDR_CFG) & 0x180;\n\t\tirq |= (tcmreadeeprom(iot, ioh, EEPROM_RESOURCE_CFG) & 0x40);\n\t\tirq = irqs[irq >> 6];\n\n\t\t/* Tag card so it will not respond to contention again. */\n\t\tbus_space_write_1(iot, ioh, 0, TAG_ADAPTER + 1);\n\n\t\t/*\n\t\t * Don't attach a 3c319 in PnP mode.\n\t\t *\n\t\t * XXX Testing for the 13th bit in iobase being 0 might not\n\t\t * be the right thing to do, but the EEPROM of the 3C319 is\n\t\t * undocumented according to 3COM and this is one of the\n\t\t * three bits that changed when I put the card in PnP mode. -chb\n\t\t */\n\t\tif (((model & 0xffff0) == 0x3190) &&\n\t\t    ((rsrccfg & 0x1000) == 0)) {\n\t\t\tprintf(\"3COM 3C319 TokenLink Velocity in PnP mode\\n\");\n\t\t\tpnpmode = 1;\n\t\t}\n\t\telse {\n\t\t\t/*\n\t\t\t * XXX: this should probably not be done here\n\t\t\t * because it enables the drq/irq lines from\n\t\t\t * the board. Perhaps it should be done after\n\t\t\t * we have checked for irq/drq collisions?\n\t\t\t */\n\t\t\tbus_space_write_1(iot, ioh, 0,\n\t\t\t    ACTIVATE_ADAPTER_TO_CONFIG);\n\t\t}\n\t\ttcmaddcard(bus, iobase, irq, maddr, msize, model, pnpmode);\n\t}\n\tbus_space_unmap(iot, ioh, 1);\n\nbus_probed:\n\n\tfor (i = 0; i < ntcmcards; i++) {\n\t\tif (tcmcards[i].bus != bus)\n\t\t\tcontinue;\n\t\tif (tcmcards[i].available == 0)\n\t\t\tcontinue;\n\t\tif (ia->ia_iobase != IOBASEUNK &&\n\t\t    ia->ia_iobase != tcmcards[i].iobase)\n\t\t\tcontinue;\n\t\tif (ia->ia_irq != IRQUNK &&\n\t\t    ia->ia_irq != tcmcards[i].irq)\n\t\t\tcontinue;\n\t\tgoto good;\n\t}\n\treturn 0;\n\ngood:\n\ttcmcards[i].available = 0;\n\tif (tcmcards[i].pnpmode)\n\t\treturn -1;\t/* XXX Don't actually probe this card. */\n\tia->ia_iobase = tcmcards[i].iobase;\n\tia->ia_irq = tcmcards[i].irq;\n\t/* XXX probably right, but ...... */\n\tif (ia->ia_iobase == 0xa20 || ia->ia_iobase == 0x0a24)\n\t\tia->ia_iosize = 4;\n\telse\n\t\tia->ia_iosize = 16;\n\tia->ia_maddr = tcmcards[i].maddr;\n\tia->ia_msize = tcmcards[i].msize;\n\tia->ia_aux = (void *) tcmcards[i].model;\n\treturn 1;\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MAXTCMCARDS\t20\t/* if you have more than 20, you lose */"
    ],
    "globals_used": [
      "u_int16_t\ttcmreadeeprom",
      "int\ttrtcm_isa_probe",
      "static\tvoid tcmaddcard",
      "__P((int, int, int, int, u_int, int, int));",
      "static LIST_HEAD(, tcm_isa_done_probe) tcm_isa_all_probes;",
      "static int tcm_isa_probes_initialized;",
      "static struct tcmcard {\n\tint\tbus;\n\tint\tiobase;\n\tint\tirq;\n\tint\tmaddr;\n\tu_int\tmsize;\n\tlong\tmodel;\n\tchar\tavailable;\n\tchar\tpnpmode;\n} tcmcards[MAXTCMCARDS];",
      "static int ntcmcards = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh",
            "1"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcmaddcard",
          "args": [
            "bus",
            "iobase",
            "irq",
            "maddr",
            "msize",
            "model",
            "pnpmode"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "tcmaddcard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_trtcm_isa.c",
          "lines": "113-131",
          "snippet": "static void\ntcmaddcard(bus, iobase, irq, maddr, msize, model, pnpmode)\n\tint bus, iobase, irq, maddr;\n\tu_int msize;\n\tint model, pnpmode;\n{\n\n\tif (ntcmcards >= MAXTCMCARDS)\n\t\treturn;\n\ttcmcards[ntcmcards].bus = bus;\n\ttcmcards[ntcmcards].iobase = iobase;\n\ttcmcards[ntcmcards].irq = irq;\n\ttcmcards[ntcmcards].maddr = maddr;\n\ttcmcards[ntcmcards].msize = msize;\n\ttcmcards[ntcmcards].model = model;\n\ttcmcards[ntcmcards].available = 1;\n\ttcmcards[ntcmcards].pnpmode = pnpmode;\n\tntcmcards++;\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MAXTCMCARDS\t20\t/* if you have more than 20, you lose */"
          ],
          "globals_used": [
            "static\tvoid tcmaddcard",
            "__P((int, int, int, int, u_int, int, int));",
            "static struct tcmcard {\n\tint\tbus;\n\tint\tiobase;\n\tint\tirq;\n\tint\tmaddr;\n\tu_int\tmsize;\n\tlong\tmodel;\n\tchar\tavailable;\n\tchar\tpnpmode;\n} tcmcards[MAXTCMCARDS];",
            "static int ntcmcards = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MAXTCMCARDS\t20\t/* if you have more than 20, you lose */\n\nstatic\tvoid tcmaddcard;\n__P((int, int, int, int, u_int, int, int));\nstatic struct tcmcard {\n\tint\tbus;\n\tint\tiobase;\n\tint\tirq;\n\tint\tmaddr;\n\tu_int\tmsize;\n\tlong\tmodel;\n\tchar\tavailable;\n\tchar\tpnpmode;\n} tcmcards[MAXTCMCARDS];\nstatic int ntcmcards = 0;\n\nstatic void\ntcmaddcard(bus, iobase, irq, maddr, msize, model, pnpmode)\n\tint bus, iobase, irq, maddr;\n\tu_int msize;\n\tint model, pnpmode;\n{\n\n\tif (ntcmcards >= MAXTCMCARDS)\n\t\treturn;\n\ttcmcards[ntcmcards].bus = bus;\n\ttcmcards[ntcmcards].iobase = iobase;\n\ttcmcards[ntcmcards].irq = irq;\n\ttcmcards[ntcmcards].maddr = maddr;\n\ttcmcards[ntcmcards].msize = msize;\n\ttcmcards[ntcmcards].model = model;\n\ttcmcards[ntcmcards].available = 1;\n\ttcmcards[ntcmcards].pnpmode = pnpmode;\n\tntcmcards++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "0",
            "ACTIVATE_ADAPTER_TO_CONFIG"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"3COM 3C319 TokenLink Velocity in PnP mode\\n\""
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "0",
            "TAG_ADAPTER + 1"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcmreadeeprom",
          "args": [
            "iot",
            "ioh",
            "EEPROM_RESOURCE_CFG"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "tcmreadeeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_trtcm_isa.c",
          "lines": "149-163",
          "snippet": "u_int16_t\ntcmreadeeprom(iot, ioh, offset)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint offset;\n{\n\tu_int16_t data = 0;\n\tint i;\n\n\tbus_space_write_1(iot, ioh, 0, 0x80 + offset);\n\tdelay(1000);\n\tfor (i = 0; i < 16; i++)\n\t\tdata = (data << 1) | (bus_space_read_2(iot, ioh, 0) & 1);\n\treturn (data);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_int16_t\ttcmreadeeprom"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int16_t\ttcmreadeeprom;\n\nu_int16_t\ntcmreadeeprom(iot, ioh, offset)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint offset;\n{\n\tu_int16_t data = 0;\n\tint i;\n\n\tbus_space_write_1(iot, ioh, 0, 0x80 + offset);\n\tdelay(1000);\n\tfor (i = 0; i < 16; i++)\n\t\tdata = (data << 1) | (bus_space_read_2(iot, ioh, 0) & 1);\n\treturn (data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcmdumpeeprom",
          "args": [
            "iot",
            "ioh"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "tcmdumpeeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_trtcm_isa.c",
          "lines": "169-184",
          "snippet": "void\ntcmdumpeeprom(iot, ioh)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n{\n\tunsigned int off, val;\n\n\tprintf(\"EEPROM contents:\");\n\tfor (off=0; off < 32; off++) {\n\t\tval = tcmreadeeprom(iot, ioh, off);\n\t\tif ((off % 8) == 0)\n\t\t\tprintf(\"\\n\");\n\t\tprintf(\"%04x \", val);\n\t}\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_int16_t\ttcmreadeeprom"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int16_t\ttcmreadeeprom;\n\nvoid\ntcmdumpeeprom(iot, ioh)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n{\n\tunsigned int off, val;\n\n\tprintf(\"EEPROM contents:\");\n\tfor (off=0; off < 32; off++) {\n\t\tval = tcmreadeeprom(iot, ioh, off);\n\t\tif ((off % 8) == 0)\n\t\t\tprintf(\"\\n\");\n\t\tprintf(\"%04x \", val);\n\t}\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "tcmreadeeprom(iot, ioh, EEPROM_PROD_ID)"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "tcmreadeeprom(iot, ioh, EEPROM_MFG_ID)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "0",
            "TAG_ADAPTER + 0"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elink_idseq",
          "args": [
            "iot",
            "ioh",
            "TLINK_619_POLY"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "elink_idseq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/elink.c",
          "lines": "111-129",
          "snippet": "void\nelink_idseq(iot, ioh, p)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tregister u_char p;\n{\n\tregister int i;\n\tregister u_char c;\n\n\tc = 0xff;\n\tfor (i = 255; i; i--) {\n\t\tbus_space_write_1(iot, ioh, 0, c);\n\t\tif (c & 0x80) {\n\t\t\tc <<= 1;\n\t\t\tc ^= p;\n\t\t} else\n\t\t\tc <<= 1;\n\t}\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nelink_idseq(iot, ioh, p)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tregister u_char p;\n{\n\tregister int i;\n\tregister u_char c;\n\n\tc = 0xff;\n\tfor (i = 255; i; i--) {\n\t\tbus_space_write_1(iot, ioh, 0, c);\n\t\tif (c & 0x80) {\n\t\t\tc <<= 1;\n\t\t\tc ^= p;\n\t\t} else\n\t\t\tc <<= 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elink_reset",
          "args": [
            "iot",
            "ioh",
            "bus"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "elink_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/elink.c",
          "lines": "67-103",
          "snippet": "void\nelink_reset(iot, ioh, bus)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint bus;\n{\n\tstruct elink_done_reset *er;\n\n\tif (elink_all_resets_initialized == 0) {\n\t\tLIST_INIT(&elink_all_resets);\n\t\telink_all_resets_initialized = 1;\n\t}\n\n\t/*\n\t * Reset these cards if we haven't done so already.\n\t */\n\tfor (er = elink_all_resets.lh_first; er != NULL;\n\t    er = er->er_link.le_next)\n\t\tif (er->er_bus == bus)\n\t\t\tgoto out;\n\n\t/* Mark this bus so we don't do it again. */\n\ter = (struct elink_done_reset *)malloc(sizeof(struct elink_done_reset),\n\t    M_DEVBUF, M_NOWAIT);\n\tif (er == NULL)\n\t\tpanic(\"elink_reset: can't allocate state storage\");\n\n\ter->er_bus = bus;\n\tLIST_INSERT_HEAD(&elink_all_resets, er, er_link);\n\n\t/* Haven't reset the cards on this bus, yet. */\n\tbus_space_write_1(iot, ioh, 0, ELINK_RESET);\n\n out:\n\tbus_space_write_1(iot, ioh, 0, 0x00);\n\tbus_space_write_1(iot, ioh, 0, 0x00);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(, elink_done_reset) elink_all_resets;",
            "static int elink_all_resets_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic LIST_HEAD(, elink_done_reset) elink_all_resets;\nstatic int elink_all_resets_initialized;\n\nvoid\nelink_reset(iot, ioh, bus)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint bus;\n{\n\tstruct elink_done_reset *er;\n\n\tif (elink_all_resets_initialized == 0) {\n\t\tLIST_INIT(&elink_all_resets);\n\t\telink_all_resets_initialized = 1;\n\t}\n\n\t/*\n\t * Reset these cards if we haven't done so already.\n\t */\n\tfor (er = elink_all_resets.lh_first; er != NULL;\n\t    er = er->er_link.le_next)\n\t\tif (er->er_bus == bus)\n\t\t\tgoto out;\n\n\t/* Mark this bus so we don't do it again. */\n\ter = (struct elink_done_reset *)malloc(sizeof(struct elink_done_reset),\n\t    M_DEVBUF, M_NOWAIT);\n\tif (er == NULL)\n\t\tpanic(\"elink_reset: can't allocate state storage\");\n\n\ter->er_bus = bus;\n\tLIST_INSERT_HEAD(&elink_all_resets, er, er_link);\n\n\t/* Haven't reset the cards on this bus, yet. */\n\tbus_space_write_1(iot, ioh, 0, ELINK_RESET);\n\n out:\n\tbus_space_write_1(iot, ioh, 0, 0x00);\n\tbus_space_write_1(iot, ioh, 0, 0x00);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "ELINK_ID_PORT",
            "1",
            "0",
            "&ioh"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INSERT_HEAD",
          "args": [
            "&tcm_isa_all_probes",
            "tcm",
            "tcm_link"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct tcm_isa_done_probe)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_INIT",
          "args": [
            "&tcm_isa_all_probes"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MAXTCMCARDS\t20\t/* if you have more than 20, you lose */\n\nu_int16_t\ttcmreadeeprom;\nint\ttrtcm_isa_probe;\nstatic\tvoid tcmaddcard;\n__P((int, int, int, int, u_int, int, int));\nstatic LIST_HEAD(, tcm_isa_done_probe) tcm_isa_all_probes;\nstatic int tcm_isa_probes_initialized;\nstatic struct tcmcard {\n\tint\tbus;\n\tint\tiobase;\n\tint\tirq;\n\tint\tmaddr;\n\tu_int\tmsize;\n\tlong\tmodel;\n\tchar\tavailable;\n\tchar\tpnpmode;\n} tcmcards[MAXTCMCARDS];\nstatic int ntcmcards = 0;\n\nint\ntrtcm_isa_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct isa_attach_args\t*ia = aux;\n\tint\tbus = parent->dv_unit;\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tu_int\tmsize;\n\tint slot, iobase, irq, i, maddr, rsrccfg, pnpmode;\n\tu_int16_t vendor, model;\n\tstruct tcm_isa_done_probe *tcm;\n\tstatic int irqs[] = { 7, 15, 6, 11, 3, 10, 9, 5 };\n\n\tif (tcm_isa_probes_initialized == 0) {\n\t\tLIST_INIT(&tcm_isa_all_probes);\n\t\ttcm_isa_probes_initialized = 1;\n\t}\n\n\t/*\n\t * Probe this bus if we haven't done so already.\n\t */\n\tfor (tcm = tcm_isa_all_probes.lh_first; tcm != NULL;\n\t    tcm = tcm->tcm_link.le_next)\n\t\tif (tcm->tcm_bus == bus)\n\t\t\tgoto bus_probed;\n\n\t/*\n\t * Mark this bus so we don't probe it again.\n\t */\n\ttcm = (struct tcm_isa_done_probe *)\n\t    malloc(sizeof(struct tcm_isa_done_probe), M_DEVBUF, M_NOWAIT);\n\tif (tcm == NULL) {\n\t\tprintf(\"trtcm_isa_probe: can't allocate state storage\");\n\t\treturn 0;\n\t}\n\n\ttcm->tcm_bus = bus;\n\tLIST_INSERT_HEAD(&tcm_isa_all_probes, tcm, tcm_link);\n\n\t/*\n\t * Map the TokenLink ID port for the probe sequence.\n\t */\n\tif (bus_space_map(iot, ELINK_ID_PORT, 1, 0, &ioh)) {\n\t\tprintf(\"trtcm_isa_probe: can't map TokenLink ID port\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (slot = 0; slot < MAXTCMCARDS; slot++) {\n\t\tpnpmode = 0;\n\t\telink_reset(iot, ioh, bus);\n\t\telink_idseq(iot, ioh, TLINK_619_POLY);\n\n\t\t/* Untag all the adapters so they will talk to us. */\n\t\tif (slot == 0)\n\t\t\tbus_space_write_1(iot, ioh, 0, TAG_ADAPTER + 0);\n\n\t\tvendor = htons(tcmreadeeprom(iot, ioh, EEPROM_MFG_ID));\n\t\tif (vendor != MFG_ID)\n\t\t\tcontinue;\n\n\t\tmodel = htons(tcmreadeeprom(iot, ioh, EEPROM_PROD_ID));\n\t\tif (((model & 0xfff0) != 0x6190) &&\n\t\t    ((model & 0xfff0) != 0x3190)) { /* XXX hardcoded */\n#if 0\n\t\t\tprintf(\"trtcm: unknown model 0x%04x\\n\", model);\n#endif\n\t\t\tcontinue;\n\t\t}\n#ifdef TRTCMISADEBUG\n\t\ttcmdumpeeprom(iot, ioh);\n\n\t\tprintf(\"speed: %d\\n\", (tcmreadeeprom(iot,ioh,8) & 2) ? 4 : 16);\n#endif\n\n\t\trsrccfg = iobase = tcmreadeeprom(iot, ioh, EEPROM_RESOURCE_CFG);\n\t\tif (iobase & 0x20)\n\t\t\tiobase = tcmreadeeprom(iot, ioh, EEPROM_ADDR_CFG) & 1 ?\n\t\t\t    0xa20 : 0xa24;\n\t\telse\n\t\t\tiobase = (iobase & 0x1f) * 0x10 + 0x200;\n\n\t\tmaddr = ((tcmreadeeprom(iot, ioh, EEPROM_OEM_ADDR0) & 0xfc00)\n\t\t    << 3) + 0x80000;\n\t\tmsize = 65536 >> ((tcmreadeeprom(iot, ioh, 8) & 0x0c) >> 2);\n\n\t\tirq = tcmreadeeprom(iot, ioh, EEPROM_ADDR_CFG) & 0x180;\n\t\tirq |= (tcmreadeeprom(iot, ioh, EEPROM_RESOURCE_CFG) & 0x40);\n\t\tirq = irqs[irq >> 6];\n\n\t\t/* Tag card so it will not respond to contention again. */\n\t\tbus_space_write_1(iot, ioh, 0, TAG_ADAPTER + 1);\n\n\t\t/*\n\t\t * Don't attach a 3c319 in PnP mode.\n\t\t *\n\t\t * XXX Testing for the 13th bit in iobase being 0 might not\n\t\t * be the right thing to do, but the EEPROM of the 3C319 is\n\t\t * undocumented according to 3COM and this is one of the\n\t\t * three bits that changed when I put the card in PnP mode. -chb\n\t\t */\n\t\tif (((model & 0xffff0) == 0x3190) &&\n\t\t    ((rsrccfg & 0x1000) == 0)) {\n\t\t\tprintf(\"3COM 3C319 TokenLink Velocity in PnP mode\\n\");\n\t\t\tpnpmode = 1;\n\t\t}\n\t\telse {\n\t\t\t/*\n\t\t\t * XXX: this should probably not be done here\n\t\t\t * because it enables the drq/irq lines from\n\t\t\t * the board. Perhaps it should be done after\n\t\t\t * we have checked for irq/drq collisions?\n\t\t\t */\n\t\t\tbus_space_write_1(iot, ioh, 0,\n\t\t\t    ACTIVATE_ADAPTER_TO_CONFIG);\n\t\t}\n\t\ttcmaddcard(bus, iobase, irq, maddr, msize, model, pnpmode);\n\t}\n\tbus_space_unmap(iot, ioh, 1);\n\nbus_probed:\n\n\tfor (i = 0; i < ntcmcards; i++) {\n\t\tif (tcmcards[i].bus != bus)\n\t\t\tcontinue;\n\t\tif (tcmcards[i].available == 0)\n\t\t\tcontinue;\n\t\tif (ia->ia_iobase != IOBASEUNK &&\n\t\t    ia->ia_iobase != tcmcards[i].iobase)\n\t\t\tcontinue;\n\t\tif (ia->ia_irq != IRQUNK &&\n\t\t    ia->ia_irq != tcmcards[i].irq)\n\t\t\tcontinue;\n\t\tgoto good;\n\t}\n\treturn 0;\n\ngood:\n\ttcmcards[i].available = 0;\n\tif (tcmcards[i].pnpmode)\n\t\treturn -1;\t/* XXX Don't actually probe this card. */\n\tia->ia_iobase = tcmcards[i].iobase;\n\tia->ia_irq = tcmcards[i].irq;\n\t/* XXX probably right, but ...... */\n\tif (ia->ia_iobase == 0xa20 || ia->ia_iobase == 0x0a24)\n\t\tia->ia_iosize = 4;\n\telse\n\t\tia->ia_iosize = 16;\n\tia->ia_maddr = tcmcards[i].maddr;\n\tia->ia_msize = tcmcards[i].msize;\n\tia->ia_aux = (void *) tcmcards[i].model;\n\treturn 1;\n}"
  },
  {
    "function_name": "trtcm_isa_mediastatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_trtcm_isa.c",
    "lines": "194-202",
    "snippet": "void\ntrtcm_isa_mediastatus(sc, ifmr)\n\tstruct tr_softc *sc;\n\tstruct ifmediareq *ifmr;\n{\n\tstruct ifmedia\t*ifm = &sc->sc_media;\n\n\tifmr->ifm_active = ifm->ifm_cur->ifm_media;\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttrtcm_isa_mediastatus"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ttrtcm_isa_mediastatus;\n\nvoid\ntrtcm_isa_mediastatus(sc, ifmr)\n\tstruct tr_softc *sc;\n\tstruct ifmediareq *ifmr;\n{\n\tstruct ifmedia\t*ifm = &sc->sc_media;\n\n\tifmr->ifm_active = ifm->ifm_cur->ifm_media;\n}"
  },
  {
    "function_name": "trtcm_isa_mediachange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_trtcm_isa.c",
    "lines": "187-192",
    "snippet": "int\ntrtcm_isa_mediachange(sc)\n\tstruct tr_softc *sc;\n{\n\treturn EINVAL;\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ttrtcm_isa_mediachange"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ttrtcm_isa_mediachange;\n\nint\ntrtcm_isa_mediachange(sc)\n\tstruct tr_softc *sc;\n{\n\treturn EINVAL;\n}"
  },
  {
    "function_name": "tcmdumpeeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_trtcm_isa.c",
    "lines": "169-184",
    "snippet": "void\ntcmdumpeeprom(iot, ioh)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n{\n\tunsigned int off, val;\n\n\tprintf(\"EEPROM contents:\");\n\tfor (off=0; off < 32; off++) {\n\t\tval = tcmreadeeprom(iot, ioh, off);\n\t\tif ((off % 8) == 0)\n\t\t\tprintf(\"\\n\");\n\t\tprintf(\"%04x \", val);\n\t}\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_int16_t\ttcmreadeeprom"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcmreadeeprom",
          "args": [
            "iot",
            "ioh",
            "off"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "tcmreadeeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_trtcm_isa.c",
          "lines": "149-163",
          "snippet": "u_int16_t\ntcmreadeeprom(iot, ioh, offset)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint offset;\n{\n\tu_int16_t data = 0;\n\tint i;\n\n\tbus_space_write_1(iot, ioh, 0, 0x80 + offset);\n\tdelay(1000);\n\tfor (i = 0; i < 16; i++)\n\t\tdata = (data << 1) | (bus_space_read_2(iot, ioh, 0) & 1);\n\treturn (data);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_int16_t\ttcmreadeeprom"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int16_t\ttcmreadeeprom;\n\nu_int16_t\ntcmreadeeprom(iot, ioh, offset)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint offset;\n{\n\tu_int16_t data = 0;\n\tint i;\n\n\tbus_space_write_1(iot, ioh, 0, 0x80 + offset);\n\tdelay(1000);\n\tfor (i = 0; i < 16; i++)\n\t\tdata = (data << 1) | (bus_space_read_2(iot, ioh, 0) & 1);\n\treturn (data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int16_t\ttcmreadeeprom;\n\nvoid\ntcmdumpeeprom(iot, ioh)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n{\n\tunsigned int off, val;\n\n\tprintf(\"EEPROM contents:\");\n\tfor (off=0; off < 32; off++) {\n\t\tval = tcmreadeeprom(iot, ioh, off);\n\t\tif ((off % 8) == 0)\n\t\t\tprintf(\"\\n\");\n\t\tprintf(\"%04x \", val);\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "tcmreadeeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_trtcm_isa.c",
    "lines": "149-163",
    "snippet": "u_int16_t\ntcmreadeeprom(iot, ioh, offset)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint offset;\n{\n\tu_int16_t data = 0;\n\tint i;\n\n\tbus_space_write_1(iot, ioh, 0, 0x80 + offset);\n\tdelay(1000);\n\tfor (i = 0; i < 16; i++)\n\t\tdata = (data << 1) | (bus_space_read_2(iot, ioh, 0) & 1);\n\treturn (data);\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_int16_t\ttcmreadeeprom"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "0"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "0",
            "0x80 + offset"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int16_t\ttcmreadeeprom;\n\nu_int16_t\ntcmreadeeprom(iot, ioh, offset)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint offset;\n{\n\tu_int16_t data = 0;\n\tint i;\n\n\tbus_space_write_1(iot, ioh, 0, 0x80 + offset);\n\tdelay(1000);\n\tfor (i = 0; i < 16; i++)\n\t\tdata = (data << 1) | (bus_space_read_2(iot, ioh, 0) & 1);\n\treturn (data);\n}"
  },
  {
    "function_name": "tcmaddcard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_trtcm_isa.c",
    "lines": "113-131",
    "snippet": "static void\ntcmaddcard(bus, iobase, irq, maddr, msize, model, pnpmode)\n\tint bus, iobase, irq, maddr;\n\tu_int msize;\n\tint model, pnpmode;\n{\n\n\tif (ntcmcards >= MAXTCMCARDS)\n\t\treturn;\n\ttcmcards[ntcmcards].bus = bus;\n\ttcmcards[ntcmcards].iobase = iobase;\n\ttcmcards[ntcmcards].irq = irq;\n\ttcmcards[ntcmcards].maddr = maddr;\n\ttcmcards[ntcmcards].msize = msize;\n\ttcmcards[ntcmcards].model = model;\n\ttcmcards[ntcmcards].available = 1;\n\ttcmcards[ntcmcards].pnpmode = pnpmode;\n\tntcmcards++;\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MAXTCMCARDS\t20\t/* if you have more than 20, you lose */"
    ],
    "globals_used": [
      "static\tvoid tcmaddcard",
      "__P((int, int, int, int, u_int, int, int));",
      "static struct tcmcard {\n\tint\tbus;\n\tint\tiobase;\n\tint\tirq;\n\tint\tmaddr;\n\tu_int\tmsize;\n\tlong\tmodel;\n\tchar\tavailable;\n\tchar\tpnpmode;\n} tcmcards[MAXTCMCARDS];",
      "static int ntcmcards = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MAXTCMCARDS\t20\t/* if you have more than 20, you lose */\n\nstatic\tvoid tcmaddcard;\n__P((int, int, int, int, u_int, int, int));\nstatic struct tcmcard {\n\tint\tbus;\n\tint\tiobase;\n\tint\tirq;\n\tint\tmaddr;\n\tu_int\tmsize;\n\tlong\tmodel;\n\tchar\tavailable;\n\tchar\tpnpmode;\n} tcmcards[MAXTCMCARDS];\nstatic int ntcmcards = 0;\n\nstatic void\ntcmaddcard(bus, iobase, irq, maddr, msize, model, pnpmode)\n\tint bus, iobase, irq, maddr;\n\tu_int msize;\n\tint model, pnpmode;\n{\n\n\tif (ntcmcards >= MAXTCMCARDS)\n\t\treturn;\n\ttcmcards[ntcmcards].bus = bus;\n\ttcmcards[ntcmcards].iobase = iobase;\n\ttcmcards[ntcmcards].irq = irq;\n\ttcmcards[ntcmcards].maddr = maddr;\n\ttcmcards[ntcmcards].msize = msize;\n\ttcmcards[ntcmcards].model = model;\n\ttcmcards[ntcmcards].available = 1;\n\ttcmcards[ntcmcards].pnpmode = pnpmode;\n\tntcmcards++;\n}"
  }
]