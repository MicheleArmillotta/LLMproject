[
  {
    "function_name": "madunmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss_isa.c",
    "lines": "365-375",
    "snippet": "static void\nmadunmap(sc)\n    struct wss_softc *sc;\n{\n    if (sc->mad_chip_type == MAD_NONE)\n        return;\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh, MAD_NPORT);\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh1, MAD_LEN1);\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh2, MAD_LEN2);\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh3, MAD_LEN3);\n}",
    "includes": [
      "#include <dev/isa/madreg.h>",
      "#include <dev/isa/wssvar.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tmadunmap"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "sc->sc_iot",
            "sc->mad_ioh3",
            "MAD_LEN3"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "sc->sc_iot",
            "sc->mad_ioh2",
            "MAD_LEN2"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "sc->sc_iot",
            "sc->mad_ioh1",
            "MAD_LEN1"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "sc->sc_iot",
            "sc->mad_ioh",
            "MAD_NPORT"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tmadunmap;\n\nstatic void\nmadunmap(sc)\n    struct wss_softc *sc;\n{\n    if (sc->mad_chip_type == MAD_NONE)\n        return;\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh, MAD_NPORT);\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh1, MAD_LEN1);\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh2, MAD_LEN2);\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh3, MAD_LEN3);\n}"
  },
  {
    "function_name": "madprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss_isa.c",
    "lines": "294-363",
    "snippet": "static void\nmadprobe(sc, iobase)\n    struct wss_softc *sc;\n    int iobase;\n{\n    static int valid_ports[M_WSS_NPORTS] = \n        { M_WSS_PORT0, M_WSS_PORT1, M_WSS_PORT2, M_WSS_PORT3 };\n    int i;\n\n    /* Allocate bus space that the MAD chip wants */\n    if (bus_space_map(sc->sc_iot, MAD_BASE, MAD_NPORT, 0, &sc->mad_ioh))\n\tgoto bad0;\n    if (bus_space_map(sc->sc_iot, MAD_REG1, MAD_LEN1, 0, &sc->mad_ioh1))\n        goto bad1;\n    if (bus_space_map(sc->sc_iot, MAD_REG2, MAD_LEN2, 0, &sc->mad_ioh2))\n        goto bad2;\n    if (bus_space_map(sc->sc_iot, MAD_REG3, MAD_LEN3, 0, &sc->mad_ioh3))\n        goto bad3;\n\n    DPRINTF((\"mad: Detect using password = 0xE2\\n\"));\n    if (!detect_mad16(sc, MAD_82C928)) {\n\t/* No luck. Try different model */\n\tDPRINTF((\"mad: Detect using password = 0xE3\\n\"));\n\tif (!detect_mad16(sc, MAD_82C929))\n\t    goto bad;\n\tsc->mad_chip_type = MAD_82C929;\n\tDPRINTF((\"mad: 82C929 detected\\n\"));\n    } else {\n\tsc->mad_chip_type = MAD_82C928;\n\tif ((mad_read(sc, MC3_PORT) & 0x03) == 0x03) {\n\t    DPRINTF((\"mad: Mozart detected\\n\"));\n\t    sc->mad_chip_type = MAD_OTI601D;\n\t} else {\n\t    DPRINTF((\"mad: 82C928 detected?\\n\"));\n\t    sc->mad_chip_type = MAD_82C928;\n\t}\n    }\n\n#ifdef AUDIO_DEBUG\n    if (wssdebug)\n\tfor (i = MC1_PORT; i <= MC7_PORT; i++)\n\t    printf(\"mad: port %03x = %02x\\n\", i, mad_read(sc, i));\n#endif\n\n    /* Set the WSS address. */\n    for (i = 0; i < M_WSS_NPORTS; i++)\n\tif (valid_ports[i] == iobase)\n\t    break;\n    if (i >= M_WSS_NPORTS) {\t\t/* Not a valid port */\n\tprintf(\"mad: Bad WSS base address 0x%x\\n\", iobase);\n\tgoto bad;\n    }\n    sc->mad_ioindex = i;\n    /* enable WSS emulation at the I/O port, no joystick */\n    mad_write(sc, MC1_PORT, M_WSS_PORT_SELECT(i) | MC1_JOYDISABLE);\n    mad_write(sc, MC2_PORT, 0x03); /* ? */\n    mad_write(sc, MC3_PORT, 0xf0); /* Disable SB */\n    return;\n\nbad:\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh3, MAD_LEN3);\nbad3:\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh2, MAD_LEN2);\nbad2:\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh1, MAD_LEN1);\nbad1:\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh, MAD_NPORT);\nbad0:\n    sc->mad_chip_type = MAD_NONE;\n}",
    "includes": [
      "#include <dev/isa/madreg.h>",
      "#include <dev/isa/wssvar.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tmadprobe",
      "static int\tdetect_mad16"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "sc->sc_iot",
            "sc->mad_ioh",
            "MAD_NPORT"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "sc->sc_iot",
            "sc->mad_ioh1",
            "MAD_LEN1"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "sc->sc_iot",
            "sc->mad_ioh2",
            "MAD_LEN2"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "sc->sc_iot",
            "sc->mad_ioh3",
            "MAD_LEN3"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mad_write",
          "args": [
            "sc",
            "MC3_PORT",
            "0xf0"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "mad_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss.c",
          "lines": "395-422",
          "snippet": "void\nmad_write(sc, port, value)\n    struct wss_softc *sc;\n    int port;\n    int value;\n{\n    int pwd;\n    int s;\n\n    switch (sc->mad_chip_type) {\t/* Output password */\n    case MAD_82C928:\n    case MAD_OTI601D:\n\tpwd = M_PASSWD_928;\n\tbreak;\n    case MAD_82C929:\n\tpwd = M_PASSWD_929;\n\tbreak;\n    case MAD_82C931:\n\tpwd = M_PASSWD_931;\n\tbreak;\n    default:\n\tpanic(\"mad_write: Bad chip type=%d\", sc->mad_chip_type);\n    }\n    s = splaudio();\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, MC_PASSWD_REG, pwd);\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, port, value & 0xff);\n    splx(s);\n}",
          "includes": [
            "#include <dev/isa/madreg.h>",
            "#include <dev/isa/wssvar.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nmad_write(sc, port, value)\n    struct wss_softc *sc;\n    int port;\n    int value;\n{\n    int pwd;\n    int s;\n\n    switch (sc->mad_chip_type) {\t/* Output password */\n    case MAD_82C928:\n    case MAD_OTI601D:\n\tpwd = M_PASSWD_928;\n\tbreak;\n    case MAD_82C929:\n\tpwd = M_PASSWD_929;\n\tbreak;\n    case MAD_82C931:\n\tpwd = M_PASSWD_931;\n\tbreak;\n    default:\n\tpanic(\"mad_write: Bad chip type=%d\", sc->mad_chip_type);\n    }\n    s = splaudio();\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, MC_PASSWD_REG, pwd);\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, port, value & 0xff);\n    splx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_WSS_PORT_SELECT",
          "args": [
            "i"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"mad: Bad WSS base address 0x%x\\n\"",
            "iobase"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mad_read",
          "args": [
            "sc",
            "i"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "mad_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss.c",
          "lines": "365-393",
          "snippet": "u_int\nmad_read(sc, port)\n    struct wss_softc *sc;\n    int port;\n{\n    u_int tmp;\n    int pwd;\n    int s;\n    \n    switch (sc->mad_chip_type) {\t/* Output password */\n    case MAD_82C928:\n    case MAD_OTI601D:\n\tpwd = M_PASSWD_928;\n\tbreak;\n    case MAD_82C929:\n\tpwd = M_PASSWD_929;\n\tbreak;\n    case MAD_82C931:\n\tpwd = M_PASSWD_931;\n\tbreak;\n    default:\n\tpanic(\"mad_read: Bad chip type=%d\", sc->mad_chip_type);\n    }\n    s = splaudio();\t\t/* don't want an interrupt between outb&inb */\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, MC_PASSWD_REG, pwd);\n    tmp = bus_space_read_1(sc->sc_iot, sc->mad_ioh, port);\n    splx(s);\n    return tmp;\n}",
          "includes": [
            "#include <dev/isa/madreg.h>",
            "#include <dev/isa/wssvar.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int\nmad_read(sc, port)\n    struct wss_softc *sc;\n    int port;\n{\n    u_int tmp;\n    int pwd;\n    int s;\n    \n    switch (sc->mad_chip_type) {\t/* Output password */\n    case MAD_82C928:\n    case MAD_OTI601D:\n\tpwd = M_PASSWD_928;\n\tbreak;\n    case MAD_82C929:\n\tpwd = M_PASSWD_929;\n\tbreak;\n    case MAD_82C931:\n\tpwd = M_PASSWD_931;\n\tbreak;\n    default:\n\tpanic(\"mad_read: Bad chip type=%d\", sc->mad_chip_type);\n    }\n    s = splaudio();\t\t/* don't want an interrupt between outb&inb */\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, MC_PASSWD_REG, pwd);\n    tmp = bus_space_read_1(sc->sc_iot, sc->mad_ioh, port);\n    splx(s);\n    return tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"mad: 82C928 detected?\\n\")"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"mad: Mozart detected\\n\")"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"mad: 82C929 detected\\n\")"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "detect_mad16",
          "args": [
            "sc",
            "MAD_82C929"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "detect_mad16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss_isa.c",
          "lines": "253-292",
          "snippet": "static int\ndetect_mad16(sc, chip_type)\n    struct wss_softc *sc;\n    int chip_type;\n{\n    unsigned char tmp, tmp2;\n\n    sc->mad_chip_type = chip_type;\n    /*\n     * Check that reading a register doesn't return bus float (0xff)\n     * when the card is accessed using password. This may fail in case\n     * the card is in low power mode. Normally at least the power saving mode\n     * bit should be 0.\n     */\n    if ((tmp = mad_read(sc, MC1_PORT)) == 0xff) {\n\tDPRINTF((\"MC1_PORT returned 0xff\\n\"));\n\treturn 0;\n    }\n\n    /*\n     * Now check that the gate is closed on first I/O after writing\n     * the password. (This is how a MAD16 compatible card works).\n     */\n    if ((tmp2 = bus_space_read_1(sc->sc_iot, sc->mad_ioh, MC1_PORT)) == tmp)\t{\n\tDPRINTF((\"MC1_PORT didn't close after read (0x%02x)\\n\", tmp2));\n\treturn 0;\n    }\n\n    mad_write(sc, MC1_PORT, tmp ^ 0x80);\t/* Toggle a bit */\n\n    /* Compare the bit */\n    if ((tmp2 = mad_read(sc, MC1_PORT)) != (tmp ^ 0x80)) {\n\tmad_write(sc, MC1_PORT, tmp);\t/* Restore */\n\tDPRINTF((\"Bit revert test failed (0x%02x, 0x%02x)\\n\", tmp, tmp2));\n\treturn 0;\n    }\n\n    mad_write(sc, MC1_PORT, tmp);\t/* Restore */\n    return 1;\n}",
          "includes": [
            "#include <dev/isa/madreg.h>",
            "#include <dev/isa/wssvar.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tdetect_mad16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\tdetect_mad16;\n\nstatic int\ndetect_mad16(sc, chip_type)\n    struct wss_softc *sc;\n    int chip_type;\n{\n    unsigned char tmp, tmp2;\n\n    sc->mad_chip_type = chip_type;\n    /*\n     * Check that reading a register doesn't return bus float (0xff)\n     * when the card is accessed using password. This may fail in case\n     * the card is in low power mode. Normally at least the power saving mode\n     * bit should be 0.\n     */\n    if ((tmp = mad_read(sc, MC1_PORT)) == 0xff) {\n\tDPRINTF((\"MC1_PORT returned 0xff\\n\"));\n\treturn 0;\n    }\n\n    /*\n     * Now check that the gate is closed on first I/O after writing\n     * the password. (This is how a MAD16 compatible card works).\n     */\n    if ((tmp2 = bus_space_read_1(sc->sc_iot, sc->mad_ioh, MC1_PORT)) == tmp)\t{\n\tDPRINTF((\"MC1_PORT didn't close after read (0x%02x)\\n\", tmp2));\n\treturn 0;\n    }\n\n    mad_write(sc, MC1_PORT, tmp ^ 0x80);\t/* Toggle a bit */\n\n    /* Compare the bit */\n    if ((tmp2 = mad_read(sc, MC1_PORT)) != (tmp ^ 0x80)) {\n\tmad_write(sc, MC1_PORT, tmp);\t/* Restore */\n\tDPRINTF((\"Bit revert test failed (0x%02x, 0x%02x)\\n\", tmp, tmp2));\n\treturn 0;\n    }\n\n    mad_write(sc, MC1_PORT, tmp);\t/* Restore */\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"mad: Detect using password = 0xE3\\n\")"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"mad: Detect using password = 0xE2\\n\")"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "MAD_REG3",
            "MAD_LEN3",
            "0",
            "&sc->mad_ioh3"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "MAD_REG2",
            "MAD_LEN2",
            "0",
            "&sc->mad_ioh2"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "MAD_REG1",
            "MAD_LEN1",
            "0",
            "&sc->mad_ioh1"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "MAD_BASE",
            "MAD_NPORT",
            "0",
            "&sc->mad_ioh"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tmadprobe;\nstatic int\tdetect_mad16;\n\nstatic void\nmadprobe(sc, iobase)\n    struct wss_softc *sc;\n    int iobase;\n{\n    static int valid_ports[M_WSS_NPORTS] = \n        { M_WSS_PORT0, M_WSS_PORT1, M_WSS_PORT2, M_WSS_PORT3 };\n    int i;\n\n    /* Allocate bus space that the MAD chip wants */\n    if (bus_space_map(sc->sc_iot, MAD_BASE, MAD_NPORT, 0, &sc->mad_ioh))\n\tgoto bad0;\n    if (bus_space_map(sc->sc_iot, MAD_REG1, MAD_LEN1, 0, &sc->mad_ioh1))\n        goto bad1;\n    if (bus_space_map(sc->sc_iot, MAD_REG2, MAD_LEN2, 0, &sc->mad_ioh2))\n        goto bad2;\n    if (bus_space_map(sc->sc_iot, MAD_REG3, MAD_LEN3, 0, &sc->mad_ioh3))\n        goto bad3;\n\n    DPRINTF((\"mad: Detect using password = 0xE2\\n\"));\n    if (!detect_mad16(sc, MAD_82C928)) {\n\t/* No luck. Try different model */\n\tDPRINTF((\"mad: Detect using password = 0xE3\\n\"));\n\tif (!detect_mad16(sc, MAD_82C929))\n\t    goto bad;\n\tsc->mad_chip_type = MAD_82C929;\n\tDPRINTF((\"mad: 82C929 detected\\n\"));\n    } else {\n\tsc->mad_chip_type = MAD_82C928;\n\tif ((mad_read(sc, MC3_PORT) & 0x03) == 0x03) {\n\t    DPRINTF((\"mad: Mozart detected\\n\"));\n\t    sc->mad_chip_type = MAD_OTI601D;\n\t} else {\n\t    DPRINTF((\"mad: 82C928 detected?\\n\"));\n\t    sc->mad_chip_type = MAD_82C928;\n\t}\n    }\n\n#ifdef AUDIO_DEBUG\n    if (wssdebug)\n\tfor (i = MC1_PORT; i <= MC7_PORT; i++)\n\t    printf(\"mad: port %03x = %02x\\n\", i, mad_read(sc, i));\n#endif\n\n    /* Set the WSS address. */\n    for (i = 0; i < M_WSS_NPORTS; i++)\n\tif (valid_ports[i] == iobase)\n\t    break;\n    if (i >= M_WSS_NPORTS) {\t\t/* Not a valid port */\n\tprintf(\"mad: Bad WSS base address 0x%x\\n\", iobase);\n\tgoto bad;\n    }\n    sc->mad_ioindex = i;\n    /* enable WSS emulation at the I/O port, no joystick */\n    mad_write(sc, MC1_PORT, M_WSS_PORT_SELECT(i) | MC1_JOYDISABLE);\n    mad_write(sc, MC2_PORT, 0x03); /* ? */\n    mad_write(sc, MC3_PORT, 0xf0); /* Disable SB */\n    return;\n\nbad:\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh3, MAD_LEN3);\nbad3:\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh2, MAD_LEN2);\nbad2:\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh1, MAD_LEN1);\nbad1:\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh, MAD_NPORT);\nbad0:\n    sc->mad_chip_type = MAD_NONE;\n}"
  },
  {
    "function_name": "detect_mad16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss_isa.c",
    "lines": "253-292",
    "snippet": "static int\ndetect_mad16(sc, chip_type)\n    struct wss_softc *sc;\n    int chip_type;\n{\n    unsigned char tmp, tmp2;\n\n    sc->mad_chip_type = chip_type;\n    /*\n     * Check that reading a register doesn't return bus float (0xff)\n     * when the card is accessed using password. This may fail in case\n     * the card is in low power mode. Normally at least the power saving mode\n     * bit should be 0.\n     */\n    if ((tmp = mad_read(sc, MC1_PORT)) == 0xff) {\n\tDPRINTF((\"MC1_PORT returned 0xff\\n\"));\n\treturn 0;\n    }\n\n    /*\n     * Now check that the gate is closed on first I/O after writing\n     * the password. (This is how a MAD16 compatible card works).\n     */\n    if ((tmp2 = bus_space_read_1(sc->sc_iot, sc->mad_ioh, MC1_PORT)) == tmp)\t{\n\tDPRINTF((\"MC1_PORT didn't close after read (0x%02x)\\n\", tmp2));\n\treturn 0;\n    }\n\n    mad_write(sc, MC1_PORT, tmp ^ 0x80);\t/* Toggle a bit */\n\n    /* Compare the bit */\n    if ((tmp2 = mad_read(sc, MC1_PORT)) != (tmp ^ 0x80)) {\n\tmad_write(sc, MC1_PORT, tmp);\t/* Restore */\n\tDPRINTF((\"Bit revert test failed (0x%02x, 0x%02x)\\n\", tmp, tmp2));\n\treturn 0;\n    }\n\n    mad_write(sc, MC1_PORT, tmp);\t/* Restore */\n    return 1;\n}",
    "includes": [
      "#include <dev/isa/madreg.h>",
      "#include <dev/isa/wssvar.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tdetect_mad16"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mad_write",
          "args": [
            "sc",
            "MC1_PORT",
            "tmp"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "mad_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss.c",
          "lines": "395-422",
          "snippet": "void\nmad_write(sc, port, value)\n    struct wss_softc *sc;\n    int port;\n    int value;\n{\n    int pwd;\n    int s;\n\n    switch (sc->mad_chip_type) {\t/* Output password */\n    case MAD_82C928:\n    case MAD_OTI601D:\n\tpwd = M_PASSWD_928;\n\tbreak;\n    case MAD_82C929:\n\tpwd = M_PASSWD_929;\n\tbreak;\n    case MAD_82C931:\n\tpwd = M_PASSWD_931;\n\tbreak;\n    default:\n\tpanic(\"mad_write: Bad chip type=%d\", sc->mad_chip_type);\n    }\n    s = splaudio();\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, MC_PASSWD_REG, pwd);\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, port, value & 0xff);\n    splx(s);\n}",
          "includes": [
            "#include <dev/isa/madreg.h>",
            "#include <dev/isa/wssvar.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nmad_write(sc, port, value)\n    struct wss_softc *sc;\n    int port;\n    int value;\n{\n    int pwd;\n    int s;\n\n    switch (sc->mad_chip_type) {\t/* Output password */\n    case MAD_82C928:\n    case MAD_OTI601D:\n\tpwd = M_PASSWD_928;\n\tbreak;\n    case MAD_82C929:\n\tpwd = M_PASSWD_929;\n\tbreak;\n    case MAD_82C931:\n\tpwd = M_PASSWD_931;\n\tbreak;\n    default:\n\tpanic(\"mad_write: Bad chip type=%d\", sc->mad_chip_type);\n    }\n    s = splaudio();\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, MC_PASSWD_REG, pwd);\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, port, value & 0xff);\n    splx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"Bit revert test failed (0x%02x, 0x%02x)\\n\", tmp, tmp2)"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mad_read",
          "args": [
            "sc",
            "MC1_PORT"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "mad_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss.c",
          "lines": "365-393",
          "snippet": "u_int\nmad_read(sc, port)\n    struct wss_softc *sc;\n    int port;\n{\n    u_int tmp;\n    int pwd;\n    int s;\n    \n    switch (sc->mad_chip_type) {\t/* Output password */\n    case MAD_82C928:\n    case MAD_OTI601D:\n\tpwd = M_PASSWD_928;\n\tbreak;\n    case MAD_82C929:\n\tpwd = M_PASSWD_929;\n\tbreak;\n    case MAD_82C931:\n\tpwd = M_PASSWD_931;\n\tbreak;\n    default:\n\tpanic(\"mad_read: Bad chip type=%d\", sc->mad_chip_type);\n    }\n    s = splaudio();\t\t/* don't want an interrupt between outb&inb */\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, MC_PASSWD_REG, pwd);\n    tmp = bus_space_read_1(sc->sc_iot, sc->mad_ioh, port);\n    splx(s);\n    return tmp;\n}",
          "includes": [
            "#include <dev/isa/madreg.h>",
            "#include <dev/isa/wssvar.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int\nmad_read(sc, port)\n    struct wss_softc *sc;\n    int port;\n{\n    u_int tmp;\n    int pwd;\n    int s;\n    \n    switch (sc->mad_chip_type) {\t/* Output password */\n    case MAD_82C928:\n    case MAD_OTI601D:\n\tpwd = M_PASSWD_928;\n\tbreak;\n    case MAD_82C929:\n\tpwd = M_PASSWD_929;\n\tbreak;\n    case MAD_82C931:\n\tpwd = M_PASSWD_931;\n\tbreak;\n    default:\n\tpanic(\"mad_read: Bad chip type=%d\", sc->mad_chip_type);\n    }\n    s = splaudio();\t\t/* don't want an interrupt between outb&inb */\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, MC_PASSWD_REG, pwd);\n    tmp = bus_space_read_1(sc->sc_iot, sc->mad_ioh, port);\n    splx(s);\n    return tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"MC1_PORT didn't close after read (0x%02x)\\n\", tmp2)"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_iot",
            "sc->mad_ioh",
            "MC1_PORT"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"MC1_PORT returned 0xff\\n\")"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\tdetect_mad16;\n\nstatic int\ndetect_mad16(sc, chip_type)\n    struct wss_softc *sc;\n    int chip_type;\n{\n    unsigned char tmp, tmp2;\n\n    sc->mad_chip_type = chip_type;\n    /*\n     * Check that reading a register doesn't return bus float (0xff)\n     * when the card is accessed using password. This may fail in case\n     * the card is in low power mode. Normally at least the power saving mode\n     * bit should be 0.\n     */\n    if ((tmp = mad_read(sc, MC1_PORT)) == 0xff) {\n\tDPRINTF((\"MC1_PORT returned 0xff\\n\"));\n\treturn 0;\n    }\n\n    /*\n     * Now check that the gate is closed on first I/O after writing\n     * the password. (This is how a MAD16 compatible card works).\n     */\n    if ((tmp2 = bus_space_read_1(sc->sc_iot, sc->mad_ioh, MC1_PORT)) == tmp)\t{\n\tDPRINTF((\"MC1_PORT didn't close after read (0x%02x)\\n\", tmp2));\n\treturn 0;\n    }\n\n    mad_write(sc, MC1_PORT, tmp ^ 0x80);\t/* Toggle a bit */\n\n    /* Compare the bit */\n    if ((tmp2 = mad_read(sc, MC1_PORT)) != (tmp ^ 0x80)) {\n\tmad_write(sc, MC1_PORT, tmp);\t/* Restore */\n\tDPRINTF((\"Bit revert test failed (0x%02x, 0x%02x)\\n\", tmp, tmp2));\n\treturn 0;\n    }\n\n    mad_write(sc, MC1_PORT, tmp);\t/* Restore */\n    return 1;\n}"
  },
  {
    "function_name": "wss_isa_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss_isa.c",
    "lines": "200-217",
    "snippet": "void\nwss_isa_attach(parent, self, aux)\n    struct device *parent, *self;\n    void *aux;\n{\n    struct wss_softc *sc = (struct wss_softc *)self;\n    struct isa_attach_args *ia = (struct isa_attach_args *)aux;\n    \n    if (!wssfind(parent, sc, ia)) {\n        printf(\"%s: wssfind failed\\n\", sc->sc_dev.dv_xname);\n        return;\n    }\n\n    sc->sc_ic = ia->ia_ic;\n    sc->sc_ad1848.sc_isa = parent;\n\n    wssattach(sc);\n}",
    "includes": [
      "#include <dev/isa/madreg.h>",
      "#include <dev/isa/wssvar.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\twssfind",
      "void\t\twss_isa_attach",
      "void *aux;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wssattach",
          "args": [
            "sc"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "wssattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss.c",
          "lines": "120-156",
          "snippet": "void\nwssattach(sc)\n    struct wss_softc *sc;\n{\n    int version;\n    \n    madattach(sc);\n\n    sc->sc_ih = isa_intr_establish(sc->sc_ic, sc->wss_irq, IST_EDGE, IPL_AUDIO,\n        ad1848_intr, &sc->sc_ad1848, sc->sc_dev.dv_xname);\n\n    ad1848_attach(&sc->sc_ad1848);\n    \n    version = bus_space_read_1(sc->sc_iot, sc->sc_ioh, WSS_STATUS) & WSS_VERSMASK;\n    printf(\" (vers %d)\", version);\n    switch(sc->mad_chip_type) {\n    case MAD_82C928:\n\tprintf(\", 82C928\");\n\tbreak;\n    case MAD_OTI601D:\n\tprintf(\", OTI-601D\");\n\tbreak;\n    case MAD_82C929:\n\tprintf(\", 82C929\");\n\tbreak;\n    case MAD_82C931:\n\tprintf(\", 82C931\");\n\tbreak;\n    default:\n\tbreak;\n    }\n    printf(\"\\n\");\n\n    sc->sc_ad1848.parent = sc;\n\n    audio_attach_mi(&wss_hw_if, &sc->sc_ad1848, &sc->sc_dev);\n}",
          "includes": [
            "#include <dev/isa/madreg.h>",
            "#include <dev/isa/wssvar.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct audio_hw_if wss_hw_if = {\n\tad1848_open,\n\tad1848_close,\n\tNULL,\n\tad1848_query_encoding,\n\tad1848_set_params,\n\tad1848_round_blocksize,\n\tad1848_commit_settings,\n\tad1848_dma_init_output,\n\tad1848_dma_init_input,\n\tad1848_dma_output,\n\tad1848_dma_input,\n\tad1848_halt_out_dma,\n\tad1848_halt_in_dma,\n\tNULL,\n\twss_getdev,\n\tNULL,\n\twss_mixer_set_port,\n\twss_mixer_get_port,\n\twss_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tad1848_get_props,\n\tNULL,\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct audio_hw_if wss_hw_if = {\n\tad1848_open,\n\tad1848_close,\n\tNULL,\n\tad1848_query_encoding,\n\tad1848_set_params,\n\tad1848_round_blocksize,\n\tad1848_commit_settings,\n\tad1848_dma_init_output,\n\tad1848_dma_init_input,\n\tad1848_dma_output,\n\tad1848_dma_input,\n\tad1848_halt_out_dma,\n\tad1848_halt_in_dma,\n\tNULL,\n\twss_getdev,\n\tNULL,\n\twss_mixer_set_port,\n\twss_mixer_get_port,\n\twss_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tad1848_get_props,\n\tNULL,\n\tNULL\n};\n\nvoid\nwssattach(sc)\n    struct wss_softc *sc;\n{\n    int version;\n    \n    madattach(sc);\n\n    sc->sc_ih = isa_intr_establish(sc->sc_ic, sc->wss_irq, IST_EDGE, IPL_AUDIO,\n        ad1848_intr, &sc->sc_ad1848, sc->sc_dev.dv_xname);\n\n    ad1848_attach(&sc->sc_ad1848);\n    \n    version = bus_space_read_1(sc->sc_iot, sc->sc_ioh, WSS_STATUS) & WSS_VERSMASK;\n    printf(\" (vers %d)\", version);\n    switch(sc->mad_chip_type) {\n    case MAD_82C928:\n\tprintf(\", 82C928\");\n\tbreak;\n    case MAD_OTI601D:\n\tprintf(\", OTI-601D\");\n\tbreak;\n    case MAD_82C929:\n\tprintf(\", 82C929\");\n\tbreak;\n    case MAD_82C931:\n\tprintf(\", 82C931\");\n\tbreak;\n    default:\n\tbreak;\n    }\n    printf(\"\\n\");\n\n    sc->sc_ad1848.parent = sc;\n\n    audio_attach_mi(&wss_hw_if, &sc->sc_ad1848, &sc->sc_dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: wssfind failed\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wssfind",
          "args": [
            "parent",
            "sc",
            "ia"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "wssfind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss_isa.c",
          "lines": "124-194",
          "snippet": "static int\nwssfind(parent, sc, ia)\n    struct device *parent;\n    struct wss_softc *sc;\n    struct isa_attach_args *ia;\n{\n    static u_char interrupt_bits[12] = {\n\t-1, -1, -1, -1, -1, 0x0, -1, 0x08, -1, 0x10, 0x18, 0x20\n    };\n    static u_char dma_bits[4] = {1, 2, 0, 3};\n    \n    sc->sc_iot = ia->ia_iot;\n    if (sc->sc_dev.dv_cfdata->cf_flags & 1)\n\tmadprobe(sc, ia->ia_iobase);\n    else\n\tsc->mad_chip_type = MAD_NONE;\n\n    if (!WSS_BASE_VALID(ia->ia_iobase)) {\n\tDPRINTF((\"wss: configured iobase %x invalid\\n\", ia->ia_iobase));\n\tgoto bad1;\n    }\n\n    /* Map the ports upto the AD1848 port */\n    if (bus_space_map(sc->sc_iot, ia->ia_iobase, WSS_CODEC, 0, &sc->sc_ioh))\n\tgoto bad1;\n\n    sc->sc_ad1848.sc_iot = sc->sc_iot;\n\n    /* Is there an ad1848 chip at (WSS iobase + WSS_CODEC)? */\n    if (ad1848_mapprobe(&sc->sc_ad1848, ia->ia_iobase + WSS_CODEC) == 0)\n\tgoto bad;\n\t\n    ia->ia_iosize = WSS_NPORT;\n\n    /* Setup WSS interrupt and DMA */\n    if (!WSS_DRQ_VALID(ia->ia_drq)) {\n\tDPRINTF((\"wss: configured dma chan %d invalid\\n\", ia->ia_drq));\n\tgoto bad;\n    }\n    sc->wss_drq = ia->ia_drq;\n\n    if (sc->wss_drq != DRQUNK && !isa_drq_isfree(parent, sc->wss_drq))\n\t    goto bad;\n\n    if (!WSS_IRQ_VALID(ia->ia_irq)) {\n\tDPRINTF((\"wss: configured interrupt %d invalid\\n\", ia->ia_irq));\n\tgoto bad;\n    }\n\n    sc->wss_irq = ia->ia_irq;\n\n    if (sc->sc_ad1848.mode <= 1)\n\tia->ia_drq2 = DRQUNK;\n    sc->wss_recdrq = \n\tsc->sc_ad1848.mode > 1 && ia->ia_drq2 != DRQUNK ? \n\tia->ia_drq2 : ia->ia_drq;\n    if (sc->wss_recdrq != sc->wss_drq && !isa_drq_isfree(parent, sc->wss_recdrq))\n\tgoto bad;\n\n    /* XXX recdrq */\n    bus_space_write_1(sc->sc_iot, sc->sc_ioh, WSS_CONFIG,\n\t\t      (interrupt_bits[ia->ia_irq] | dma_bits[ia->ia_drq]));\n\n    return 1;\n\nbad:\n    bus_space_unmap(sc->sc_iot, sc->sc_ioh, WSS_CODEC);\nbad1:\n    madunmap(sc);\n    return 0;\n}",
          "includes": [
            "#include <dev/isa/madreg.h>",
            "#include <dev/isa/wssvar.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\twssfind",
            "static void\tmadprobe",
            "static void\tmadunmap"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\twssfind;\nstatic void\tmadprobe;\nstatic void\tmadunmap;\n\nstatic int\nwssfind(parent, sc, ia)\n    struct device *parent;\n    struct wss_softc *sc;\n    struct isa_attach_args *ia;\n{\n    static u_char interrupt_bits[12] = {\n\t-1, -1, -1, -1, -1, 0x0, -1, 0x08, -1, 0x10, 0x18, 0x20\n    };\n    static u_char dma_bits[4] = {1, 2, 0, 3};\n    \n    sc->sc_iot = ia->ia_iot;\n    if (sc->sc_dev.dv_cfdata->cf_flags & 1)\n\tmadprobe(sc, ia->ia_iobase);\n    else\n\tsc->mad_chip_type = MAD_NONE;\n\n    if (!WSS_BASE_VALID(ia->ia_iobase)) {\n\tDPRINTF((\"wss: configured iobase %x invalid\\n\", ia->ia_iobase));\n\tgoto bad1;\n    }\n\n    /* Map the ports upto the AD1848 port */\n    if (bus_space_map(sc->sc_iot, ia->ia_iobase, WSS_CODEC, 0, &sc->sc_ioh))\n\tgoto bad1;\n\n    sc->sc_ad1848.sc_iot = sc->sc_iot;\n\n    /* Is there an ad1848 chip at (WSS iobase + WSS_CODEC)? */\n    if (ad1848_mapprobe(&sc->sc_ad1848, ia->ia_iobase + WSS_CODEC) == 0)\n\tgoto bad;\n\t\n    ia->ia_iosize = WSS_NPORT;\n\n    /* Setup WSS interrupt and DMA */\n    if (!WSS_DRQ_VALID(ia->ia_drq)) {\n\tDPRINTF((\"wss: configured dma chan %d invalid\\n\", ia->ia_drq));\n\tgoto bad;\n    }\n    sc->wss_drq = ia->ia_drq;\n\n    if (sc->wss_drq != DRQUNK && !isa_drq_isfree(parent, sc->wss_drq))\n\t    goto bad;\n\n    if (!WSS_IRQ_VALID(ia->ia_irq)) {\n\tDPRINTF((\"wss: configured interrupt %d invalid\\n\", ia->ia_irq));\n\tgoto bad;\n    }\n\n    sc->wss_irq = ia->ia_irq;\n\n    if (sc->sc_ad1848.mode <= 1)\n\tia->ia_drq2 = DRQUNK;\n    sc->wss_recdrq = \n\tsc->sc_ad1848.mode > 1 && ia->ia_drq2 != DRQUNK ? \n\tia->ia_drq2 : ia->ia_drq;\n    if (sc->wss_recdrq != sc->wss_drq && !isa_drq_isfree(parent, sc->wss_recdrq))\n\tgoto bad;\n\n    /* XXX recdrq */\n    bus_space_write_1(sc->sc_iot, sc->sc_ioh, WSS_CONFIG,\n\t\t      (interrupt_bits[ia->ia_irq] | dma_bits[ia->ia_drq]));\n\n    return 1;\n\nbad:\n    bus_space_unmap(sc->sc_iot, sc->sc_ioh, WSS_CODEC);\nbad1:\n    madunmap(sc);\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\twssfind;\nvoid\t\twss_isa_attach;\nvoid *aux;\n\nvoid\nwss_isa_attach(parent, self, aux)\n    struct device *parent, *self;\n    void *aux;\n{\n    struct wss_softc *sc = (struct wss_softc *)self;\n    struct isa_attach_args *ia = (struct isa_attach_args *)aux;\n    \n    if (!wssfind(parent, sc, ia)) {\n        printf(\"%s: wssfind failed\\n\", sc->sc_dev.dv_xname);\n        return;\n    }\n\n    sc->sc_ic = ia->ia_ic;\n    sc->sc_ad1848.sc_isa = parent;\n\n    wssattach(sc);\n}"
  },
  {
    "function_name": "wssfind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss_isa.c",
    "lines": "124-194",
    "snippet": "static int\nwssfind(parent, sc, ia)\n    struct device *parent;\n    struct wss_softc *sc;\n    struct isa_attach_args *ia;\n{\n    static u_char interrupt_bits[12] = {\n\t-1, -1, -1, -1, -1, 0x0, -1, 0x08, -1, 0x10, 0x18, 0x20\n    };\n    static u_char dma_bits[4] = {1, 2, 0, 3};\n    \n    sc->sc_iot = ia->ia_iot;\n    if (sc->sc_dev.dv_cfdata->cf_flags & 1)\n\tmadprobe(sc, ia->ia_iobase);\n    else\n\tsc->mad_chip_type = MAD_NONE;\n\n    if (!WSS_BASE_VALID(ia->ia_iobase)) {\n\tDPRINTF((\"wss: configured iobase %x invalid\\n\", ia->ia_iobase));\n\tgoto bad1;\n    }\n\n    /* Map the ports upto the AD1848 port */\n    if (bus_space_map(sc->sc_iot, ia->ia_iobase, WSS_CODEC, 0, &sc->sc_ioh))\n\tgoto bad1;\n\n    sc->sc_ad1848.sc_iot = sc->sc_iot;\n\n    /* Is there an ad1848 chip at (WSS iobase + WSS_CODEC)? */\n    if (ad1848_mapprobe(&sc->sc_ad1848, ia->ia_iobase + WSS_CODEC) == 0)\n\tgoto bad;\n\t\n    ia->ia_iosize = WSS_NPORT;\n\n    /* Setup WSS interrupt and DMA */\n    if (!WSS_DRQ_VALID(ia->ia_drq)) {\n\tDPRINTF((\"wss: configured dma chan %d invalid\\n\", ia->ia_drq));\n\tgoto bad;\n    }\n    sc->wss_drq = ia->ia_drq;\n\n    if (sc->wss_drq != DRQUNK && !isa_drq_isfree(parent, sc->wss_drq))\n\t    goto bad;\n\n    if (!WSS_IRQ_VALID(ia->ia_irq)) {\n\tDPRINTF((\"wss: configured interrupt %d invalid\\n\", ia->ia_irq));\n\tgoto bad;\n    }\n\n    sc->wss_irq = ia->ia_irq;\n\n    if (sc->sc_ad1848.mode <= 1)\n\tia->ia_drq2 = DRQUNK;\n    sc->wss_recdrq = \n\tsc->sc_ad1848.mode > 1 && ia->ia_drq2 != DRQUNK ? \n\tia->ia_drq2 : ia->ia_drq;\n    if (sc->wss_recdrq != sc->wss_drq && !isa_drq_isfree(parent, sc->wss_recdrq))\n\tgoto bad;\n\n    /* XXX recdrq */\n    bus_space_write_1(sc->sc_iot, sc->sc_ioh, WSS_CONFIG,\n\t\t      (interrupt_bits[ia->ia_irq] | dma_bits[ia->ia_drq]));\n\n    return 1;\n\nbad:\n    bus_space_unmap(sc->sc_iot, sc->sc_ioh, WSS_CODEC);\nbad1:\n    madunmap(sc);\n    return 0;\n}",
    "includes": [
      "#include <dev/isa/madreg.h>",
      "#include <dev/isa/wssvar.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\twssfind",
      "static void\tmadprobe",
      "static void\tmadunmap"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "madunmap",
          "args": [
            "sc"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "madunmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss_isa.c",
          "lines": "365-375",
          "snippet": "static void\nmadunmap(sc)\n    struct wss_softc *sc;\n{\n    if (sc->mad_chip_type == MAD_NONE)\n        return;\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh, MAD_NPORT);\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh1, MAD_LEN1);\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh2, MAD_LEN2);\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh3, MAD_LEN3);\n}",
          "includes": [
            "#include <dev/isa/madreg.h>",
            "#include <dev/isa/wssvar.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tmadunmap"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tmadunmap;\n\nstatic void\nmadunmap(sc)\n    struct wss_softc *sc;\n{\n    if (sc->mad_chip_type == MAD_NONE)\n        return;\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh, MAD_NPORT);\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh1, MAD_LEN1);\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh2, MAD_LEN2);\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh3, MAD_LEN3);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "WSS_CODEC"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "WSS_CONFIG",
            "(interrupt_bits[ia->ia_irq] | dma_bits[ia->ia_drq])"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_drq_isfree",
          "args": [
            "parent",
            "sc->wss_recdrq"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "isa_drq_isfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "658-669",
          "snippet": "int\nisa_drq_isfree(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_drq_isfree: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\treturn ISA_DRQ_ISFREE(sc, chan);\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\n\nint\nisa_drq_isfree(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_drq_isfree: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\treturn ISA_DRQ_ISFREE(sc, chan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wss: configured interrupt %d invalid\\n\", ia->ia_irq)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSS_IRQ_VALID",
          "args": [
            "ia->ia_irq"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wss: configured dma chan %d invalid\\n\", ia->ia_drq)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSS_DRQ_VALID",
          "args": [
            "ia->ia_drq"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad1848_mapprobe",
          "args": [
            "&sc->sc_ad1848",
            "ia->ia_iobase + WSS_CODEC"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_mapprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "276-298",
          "snippet": "int\nad1848_mapprobe(sc, iobase)\n    struct ad1848_softc *sc;\n    int iobase;\n{\n    if (!AD1848_BASE_VALID(iobase)) {\n#ifdef AUDIO_DEBUG\n\tprintf(\"ad1848: configured iobase %04x invalid\\n\", iobase);\n#endif\n\treturn 0;\n    }\n\n    sc->sc_iooffs = 0;\n    /* Map the AD1848 ports */\n    if (bus_space_map(sc->sc_iot, iobase, AD1848_NPORT, 0, &sc->sc_ioh))\n\treturn 0;\n\n    if (!ad1848_probe(sc)) {\n\tbus_space_unmap(sc->sc_iot, sc->sc_ioh, AD1848_NPORT);\n\treturn 0;\n    } else\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nad1848_mapprobe(sc, iobase)\n    struct ad1848_softc *sc;\n    int iobase;\n{\n    if (!AD1848_BASE_VALID(iobase)) {\n#ifdef AUDIO_DEBUG\n\tprintf(\"ad1848: configured iobase %04x invalid\\n\", iobase);\n#endif\n\treturn 0;\n    }\n\n    sc->sc_iooffs = 0;\n    /* Map the AD1848 ports */\n    if (bus_space_map(sc->sc_iot, iobase, AD1848_NPORT, 0, &sc->sc_ioh))\n\treturn 0;\n\n    if (!ad1848_probe(sc)) {\n\tbus_space_unmap(sc->sc_iot, sc->sc_ioh, AD1848_NPORT);\n\treturn 0;\n    } else\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "ia->ia_iobase",
            "WSS_CODEC",
            "0",
            "&sc->sc_ioh"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wss: configured iobase %x invalid\\n\", ia->ia_iobase)"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSS_BASE_VALID",
          "args": [
            "ia->ia_iobase"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "madprobe",
          "args": [
            "sc",
            "ia->ia_iobase"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "madprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss_isa.c",
          "lines": "294-363",
          "snippet": "static void\nmadprobe(sc, iobase)\n    struct wss_softc *sc;\n    int iobase;\n{\n    static int valid_ports[M_WSS_NPORTS] = \n        { M_WSS_PORT0, M_WSS_PORT1, M_WSS_PORT2, M_WSS_PORT3 };\n    int i;\n\n    /* Allocate bus space that the MAD chip wants */\n    if (bus_space_map(sc->sc_iot, MAD_BASE, MAD_NPORT, 0, &sc->mad_ioh))\n\tgoto bad0;\n    if (bus_space_map(sc->sc_iot, MAD_REG1, MAD_LEN1, 0, &sc->mad_ioh1))\n        goto bad1;\n    if (bus_space_map(sc->sc_iot, MAD_REG2, MAD_LEN2, 0, &sc->mad_ioh2))\n        goto bad2;\n    if (bus_space_map(sc->sc_iot, MAD_REG3, MAD_LEN3, 0, &sc->mad_ioh3))\n        goto bad3;\n\n    DPRINTF((\"mad: Detect using password = 0xE2\\n\"));\n    if (!detect_mad16(sc, MAD_82C928)) {\n\t/* No luck. Try different model */\n\tDPRINTF((\"mad: Detect using password = 0xE3\\n\"));\n\tif (!detect_mad16(sc, MAD_82C929))\n\t    goto bad;\n\tsc->mad_chip_type = MAD_82C929;\n\tDPRINTF((\"mad: 82C929 detected\\n\"));\n    } else {\n\tsc->mad_chip_type = MAD_82C928;\n\tif ((mad_read(sc, MC3_PORT) & 0x03) == 0x03) {\n\t    DPRINTF((\"mad: Mozart detected\\n\"));\n\t    sc->mad_chip_type = MAD_OTI601D;\n\t} else {\n\t    DPRINTF((\"mad: 82C928 detected?\\n\"));\n\t    sc->mad_chip_type = MAD_82C928;\n\t}\n    }\n\n#ifdef AUDIO_DEBUG\n    if (wssdebug)\n\tfor (i = MC1_PORT; i <= MC7_PORT; i++)\n\t    printf(\"mad: port %03x = %02x\\n\", i, mad_read(sc, i));\n#endif\n\n    /* Set the WSS address. */\n    for (i = 0; i < M_WSS_NPORTS; i++)\n\tif (valid_ports[i] == iobase)\n\t    break;\n    if (i >= M_WSS_NPORTS) {\t\t/* Not a valid port */\n\tprintf(\"mad: Bad WSS base address 0x%x\\n\", iobase);\n\tgoto bad;\n    }\n    sc->mad_ioindex = i;\n    /* enable WSS emulation at the I/O port, no joystick */\n    mad_write(sc, MC1_PORT, M_WSS_PORT_SELECT(i) | MC1_JOYDISABLE);\n    mad_write(sc, MC2_PORT, 0x03); /* ? */\n    mad_write(sc, MC3_PORT, 0xf0); /* Disable SB */\n    return;\n\nbad:\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh3, MAD_LEN3);\nbad3:\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh2, MAD_LEN2);\nbad2:\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh1, MAD_LEN1);\nbad1:\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh, MAD_NPORT);\nbad0:\n    sc->mad_chip_type = MAD_NONE;\n}",
          "includes": [
            "#include <dev/isa/madreg.h>",
            "#include <dev/isa/wssvar.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tmadprobe",
            "static int\tdetect_mad16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tmadprobe;\nstatic int\tdetect_mad16;\n\nstatic void\nmadprobe(sc, iobase)\n    struct wss_softc *sc;\n    int iobase;\n{\n    static int valid_ports[M_WSS_NPORTS] = \n        { M_WSS_PORT0, M_WSS_PORT1, M_WSS_PORT2, M_WSS_PORT3 };\n    int i;\n\n    /* Allocate bus space that the MAD chip wants */\n    if (bus_space_map(sc->sc_iot, MAD_BASE, MAD_NPORT, 0, &sc->mad_ioh))\n\tgoto bad0;\n    if (bus_space_map(sc->sc_iot, MAD_REG1, MAD_LEN1, 0, &sc->mad_ioh1))\n        goto bad1;\n    if (bus_space_map(sc->sc_iot, MAD_REG2, MAD_LEN2, 0, &sc->mad_ioh2))\n        goto bad2;\n    if (bus_space_map(sc->sc_iot, MAD_REG3, MAD_LEN3, 0, &sc->mad_ioh3))\n        goto bad3;\n\n    DPRINTF((\"mad: Detect using password = 0xE2\\n\"));\n    if (!detect_mad16(sc, MAD_82C928)) {\n\t/* No luck. Try different model */\n\tDPRINTF((\"mad: Detect using password = 0xE3\\n\"));\n\tif (!detect_mad16(sc, MAD_82C929))\n\t    goto bad;\n\tsc->mad_chip_type = MAD_82C929;\n\tDPRINTF((\"mad: 82C929 detected\\n\"));\n    } else {\n\tsc->mad_chip_type = MAD_82C928;\n\tif ((mad_read(sc, MC3_PORT) & 0x03) == 0x03) {\n\t    DPRINTF((\"mad: Mozart detected\\n\"));\n\t    sc->mad_chip_type = MAD_OTI601D;\n\t} else {\n\t    DPRINTF((\"mad: 82C928 detected?\\n\"));\n\t    sc->mad_chip_type = MAD_82C928;\n\t}\n    }\n\n#ifdef AUDIO_DEBUG\n    if (wssdebug)\n\tfor (i = MC1_PORT; i <= MC7_PORT; i++)\n\t    printf(\"mad: port %03x = %02x\\n\", i, mad_read(sc, i));\n#endif\n\n    /* Set the WSS address. */\n    for (i = 0; i < M_WSS_NPORTS; i++)\n\tif (valid_ports[i] == iobase)\n\t    break;\n    if (i >= M_WSS_NPORTS) {\t\t/* Not a valid port */\n\tprintf(\"mad: Bad WSS base address 0x%x\\n\", iobase);\n\tgoto bad;\n    }\n    sc->mad_ioindex = i;\n    /* enable WSS emulation at the I/O port, no joystick */\n    mad_write(sc, MC1_PORT, M_WSS_PORT_SELECT(i) | MC1_JOYDISABLE);\n    mad_write(sc, MC2_PORT, 0x03); /* ? */\n    mad_write(sc, MC3_PORT, 0xf0); /* Disable SB */\n    return;\n\nbad:\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh3, MAD_LEN3);\nbad3:\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh2, MAD_LEN2);\nbad2:\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh1, MAD_LEN1);\nbad1:\n    bus_space_unmap(sc->sc_iot, sc->mad_ioh, MAD_NPORT);\nbad0:\n    sc->mad_chip_type = MAD_NONE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\twssfind;\nstatic void\tmadprobe;\nstatic void\tmadunmap;\n\nstatic int\nwssfind(parent, sc, ia)\n    struct device *parent;\n    struct wss_softc *sc;\n    struct isa_attach_args *ia;\n{\n    static u_char interrupt_bits[12] = {\n\t-1, -1, -1, -1, -1, 0x0, -1, 0x08, -1, 0x10, 0x18, 0x20\n    };\n    static u_char dma_bits[4] = {1, 2, 0, 3};\n    \n    sc->sc_iot = ia->ia_iot;\n    if (sc->sc_dev.dv_cfdata->cf_flags & 1)\n\tmadprobe(sc, ia->ia_iobase);\n    else\n\tsc->mad_chip_type = MAD_NONE;\n\n    if (!WSS_BASE_VALID(ia->ia_iobase)) {\n\tDPRINTF((\"wss: configured iobase %x invalid\\n\", ia->ia_iobase));\n\tgoto bad1;\n    }\n\n    /* Map the ports upto the AD1848 port */\n    if (bus_space_map(sc->sc_iot, ia->ia_iobase, WSS_CODEC, 0, &sc->sc_ioh))\n\tgoto bad1;\n\n    sc->sc_ad1848.sc_iot = sc->sc_iot;\n\n    /* Is there an ad1848 chip at (WSS iobase + WSS_CODEC)? */\n    if (ad1848_mapprobe(&sc->sc_ad1848, ia->ia_iobase + WSS_CODEC) == 0)\n\tgoto bad;\n\t\n    ia->ia_iosize = WSS_NPORT;\n\n    /* Setup WSS interrupt and DMA */\n    if (!WSS_DRQ_VALID(ia->ia_drq)) {\n\tDPRINTF((\"wss: configured dma chan %d invalid\\n\", ia->ia_drq));\n\tgoto bad;\n    }\n    sc->wss_drq = ia->ia_drq;\n\n    if (sc->wss_drq != DRQUNK && !isa_drq_isfree(parent, sc->wss_drq))\n\t    goto bad;\n\n    if (!WSS_IRQ_VALID(ia->ia_irq)) {\n\tDPRINTF((\"wss: configured interrupt %d invalid\\n\", ia->ia_irq));\n\tgoto bad;\n    }\n\n    sc->wss_irq = ia->ia_irq;\n\n    if (sc->sc_ad1848.mode <= 1)\n\tia->ia_drq2 = DRQUNK;\n    sc->wss_recdrq = \n\tsc->sc_ad1848.mode > 1 && ia->ia_drq2 != DRQUNK ? \n\tia->ia_drq2 : ia->ia_drq;\n    if (sc->wss_recdrq != sc->wss_drq && !isa_drq_isfree(parent, sc->wss_recdrq))\n\tgoto bad;\n\n    /* XXX recdrq */\n    bus_space_write_1(sc->sc_iot, sc->sc_ioh, WSS_CONFIG,\n\t\t      (interrupt_bits[ia->ia_irq] | dma_bits[ia->ia_drq]));\n\n    return 1;\n\nbad:\n    bus_space_unmap(sc->sc_iot, sc->sc_ioh, WSS_CODEC);\nbad1:\n    madunmap(sc);\n    return 0;\n}"
  }
]