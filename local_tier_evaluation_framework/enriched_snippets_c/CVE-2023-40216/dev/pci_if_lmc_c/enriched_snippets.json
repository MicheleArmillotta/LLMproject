[
  {
    "function_name": "lmc_initring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "1472-1481",
    "snippet": "void\nlmc_initring(lmc_softc_t * const sc, lmc_ringinfo_t * const ri,\n\t       tulip_desc_t *descs, int ndescs)\n{\n\tri->ri_max = ndescs;\n\tri->ri_first = descs;\n\tri->ri_last = ri->ri_first + ri->ri_max;\n\tbzero((caddr_t) ri->ri_first, sizeof(ri->ri_first[0]) * ri->ri_max);\n\tri->ri_last[-1].d_flag = TULIP_DFLAG_ENDRING;\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define d_flag u.bd_flag"
    ],
    "globals_used": [
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(caddr_t) ri->ri_first",
            "sizeof(ri->ri_first[0]) * ri->ri_max"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define d_flag u.bd_flag\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nvoid\nlmc_initring(lmc_softc_t * const sc, lmc_ringinfo_t * const ri,\n\t       tulip_desc_t *descs, int ndescs)\n{\n\tri->ri_max = ndescs;\n\tri->ri_first = descs;\n\tri->ri_last = ri->ri_first + ri->ri_max;\n\tbzero((caddr_t) ri->ri_first, sizeof(ri->ri_first[0]) * ri->ri_max);\n\tri->ri_last[-1].d_flag = TULIP_DFLAG_ENDRING;\n}"
  },
  {
    "function_name": "lmc_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "1420-1470",
    "snippet": "void\nlmc_attach(lmc_softc_t * const sc)\n{\n\tstruct ifnet * const ifp = &sc->lmc_if;\n\n\tifp->if_flags = IFF_POINTOPOINT | IFF_MULTICAST;\n\tifp->if_ioctl = lmc_ifioctl;\n\tifp->if_start = lmc_ifstart;\n\tifp->if_watchdog = lmc_watchdog;\n\tifp->if_timer = 1;\n\tifp->if_mtu = LMC_MTU;\n\n#if defined(__bsdi__)\n\tifp->if_type = IFT_NONE;\n\tifp->if_unit = (sc->lmc_dev.dv_unit);\n#endif\n  \n\tif_attach(ifp);\n\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\tsppp_attach((struct ifnet *)&sc->lmc_sppp);\n\tsc->lmc_sppp.pp_flags = PP_CISCO | PP_KEEPALIVE;\n#endif\n#if defined(__bsdi__)\n\tsc->lmc_p2pcom.p2p_mdmctl = lmc_mdmctl;\n\tsc->lmc_p2pcom.p2p_getmdm = lmc_getmdm;\n\tp2p_attach(&sc->lmc_p2pcom);\n#endif\n\n#if NBPFILTER > 0\n\tLMC_BPF_ATTACH(sc);\n#endif\n\n#if defined(__NetBSD__) && NRND > 0\n\trnd_attach_source(&sc->lmc_rndsource, sc->lmc_dev.dv_xname,\n\t\t\t  RND_TYPE_NET, 0);\n#endif\n\n\t/*\n\t * turn off those LEDs...\n\t */\n\tsc->lmc_miireg16 |= LMC_MII16_LED_ALL;\n\t/*\n\t * for DS3 & DS1 adapters light the green light, led2\n\t */\n\tif (sc->lmc_cardtype == LMC_CARDTYPE_DS3 ||\n\t    sc->lmc_cardtype == LMC_CARDTYPE_T1)\n\t\tlmc_led_on (sc, LMC_MII16_LED2);\n\telse\n\t\tlmc_led_on (sc, LMC_MII16_LED0 | LMC_MII16_LED2);\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);",
      "static ifnet_ret_t lmc_ifstart(struct ifnet *ifp);",
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lmc_led_on",
          "args": [
            "sc",
            "LMC_MII16_LED0 | LMC_MII16_LED2"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_led_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc_common.c",
          "lines": "193-198",
          "snippet": "void\nlmc_led_on(lmc_softc_t * const sc, u_int32_t led)\n{\n\tsc->lmc_miireg16 &= ~led;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmc_types.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmc_types.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nlmc_led_on(lmc_softc_t * const sc, u_int32_t led)\n{\n\tsc->lmc_miireg16 &= ~led;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rnd_attach_source",
          "args": [
            "&sc->lmc_rndsource",
            "sc->lmc_dev.dv_xname",
            "RND_TYPE_NET",
            "0"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_BPF_ATTACH",
          "args": [
            "sc"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p2p_attach",
          "args": [
            "&sc->lmc_p2pcom"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sppp_attach",
          "args": [
            "(struct ifnet *)&sc->lmc_sppp"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);\nstatic ifnet_ret_t lmc_ifstart(struct ifnet *ifp);\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nvoid\nlmc_attach(lmc_softc_t * const sc)\n{\n\tstruct ifnet * const ifp = &sc->lmc_if;\n\n\tifp->if_flags = IFF_POINTOPOINT | IFF_MULTICAST;\n\tifp->if_ioctl = lmc_ifioctl;\n\tifp->if_start = lmc_ifstart;\n\tifp->if_watchdog = lmc_watchdog;\n\tifp->if_timer = 1;\n\tifp->if_mtu = LMC_MTU;\n\n#if defined(__bsdi__)\n\tifp->if_type = IFT_NONE;\n\tifp->if_unit = (sc->lmc_dev.dv_unit);\n#endif\n  \n\tif_attach(ifp);\n\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\tsppp_attach((struct ifnet *)&sc->lmc_sppp);\n\tsc->lmc_sppp.pp_flags = PP_CISCO | PP_KEEPALIVE;\n#endif\n#if defined(__bsdi__)\n\tsc->lmc_p2pcom.p2p_mdmctl = lmc_mdmctl;\n\tsc->lmc_p2pcom.p2p_getmdm = lmc_getmdm;\n\tp2p_attach(&sc->lmc_p2pcom);\n#endif\n\n#if NBPFILTER > 0\n\tLMC_BPF_ATTACH(sc);\n#endif\n\n#if defined(__NetBSD__) && NRND > 0\n\trnd_attach_source(&sc->lmc_rndsource, sc->lmc_dev.dv_xname,\n\t\t\t  RND_TYPE_NET, 0);\n#endif\n\n\t/*\n\t * turn off those LEDs...\n\t */\n\tsc->lmc_miireg16 |= LMC_MII16_LED_ALL;\n\t/*\n\t * for DS3 & DS1 adapters light the green light, led2\n\t */\n\tif (sc->lmc_cardtype == LMC_CARDTYPE_DS3 ||\n\t    sc->lmc_cardtype == LMC_CARDTYPE_T1)\n\t\tlmc_led_on (sc, LMC_MII16_LED2);\n\telse\n\t\tlmc_led_on (sc, LMC_MII16_LED0 | LMC_MII16_LED2);\n}"
  },
  {
    "function_name": "lmc_mdmctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "1398-1413",
    "snippet": "int\nlmc_mdmctl(struct p2pcom *pp, int flag)\n{\n\tlmc_softc_t *sc = LMC_UNIT_TO_SOFTC(pp->p2p_if.if_unit);\n\n\tsc->lmc_media->set_link_status(sc, flag);\n\n\tif (flag)\n\t\tif ((sc->lmc_flags & LMC_IFUP) == 0)\n\t\t\tlmc_ifup(sc);\n\telse\n\t\tif ((sc->lmc_flags & LMC_IFUP) == LMC_IFUP)\n\t\t\tlmc_ifdown(sc);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lmc_ifdown",
          "args": [
            "sc"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_ifdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "577-589",
          "snippet": "static void\nlmc_ifdown(lmc_softc_t * const sc)\n{\n\tsc->lmc_if.if_timer = 0;\n\tsc->lmc_flags &= ~LMC_IFUP;\n\n\tsc->lmc_media->set_link_status(sc, LMC_LINK_DOWN);\n\tlmc_led_off(sc, LMC_MII16_LED_ALL);\n\n\tlmc_dec_reset(sc);\n\tlmc_reset(sc);\n\tsc->lmc_media->set_status(sc, NULL);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic void\nlmc_ifdown(lmc_softc_t * const sc)\n{\n\tsc->lmc_if.if_timer = 0;\n\tsc->lmc_flags &= ~LMC_IFUP;\n\n\tsc->lmc_media->set_link_status(sc, LMC_LINK_DOWN);\n\tlmc_led_off(sc, LMC_MII16_LED_ALL);\n\n\tlmc_dec_reset(sc);\n\tlmc_reset(sc);\n\tsc->lmc_media->set_status(sc, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmc_ifup",
          "args": [
            "sc"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_ifup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "530-571",
          "snippet": "static void\nlmc_ifup(lmc_softc_t * const sc)\n{\n\tsc->lmc_if.if_timer = 0;\n\n\tlmc_dec_reset(sc);\n\tlmc_reset(sc);\n\n\tsc->lmc_media->set_link_status(sc, LMC_LINK_UP);\n\tsc->lmc_media->set_status(sc, NULL);\n\n\tsc->lmc_flags |= LMC_IFUP;\n\n\t/*\n\t * for DS3 & DS1 adapters light the green light, led2\n\t */\n\tif (sc->lmc_cardtype == LMC_CARDTYPE_DS3 ||\n\t    sc->lmc_cardtype == LMC_CARDTYPE_T1)\n\t\tlmc_led_on (sc, LMC_MII16_LED2);\n\telse\n\t\tlmc_led_on (sc, LMC_MII16_LED0 | LMC_MII16_LED2);\n\n\t/*\n\t * select what interrupts we want to get\n\t */\n\tsc->lmc_intrmask |= (TULIP_STS_NORMALINTR\n\t\t\t       | TULIP_STS_RXINTR\n\t\t\t       | TULIP_STS_TXINTR\n\t\t\t       | TULIP_STS_ABNRMLINTR\n\t\t\t       | TULIP_STS_SYSERROR\n\t\t\t       | TULIP_STS_TXSTOPPED\n\t\t\t       | TULIP_STS_TXUNDERFLOW\n\t\t\t       | TULIP_STS_RXSTOPPED\n\t\t\t       );\n\tLMC_CSR_WRITE(sc, csr_intr, sc->lmc_intrmask);\n\n\tsc->lmc_cmdmode |= TULIP_CMD_TXRUN;\n\tsc->lmc_cmdmode |= TULIP_CMD_RXRUN;\n\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\n\tsc->lmc_if.if_timer = 1;\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic void\nlmc_ifup(lmc_softc_t * const sc)\n{\n\tsc->lmc_if.if_timer = 0;\n\n\tlmc_dec_reset(sc);\n\tlmc_reset(sc);\n\n\tsc->lmc_media->set_link_status(sc, LMC_LINK_UP);\n\tsc->lmc_media->set_status(sc, NULL);\n\n\tsc->lmc_flags |= LMC_IFUP;\n\n\t/*\n\t * for DS3 & DS1 adapters light the green light, led2\n\t */\n\tif (sc->lmc_cardtype == LMC_CARDTYPE_DS3 ||\n\t    sc->lmc_cardtype == LMC_CARDTYPE_T1)\n\t\tlmc_led_on (sc, LMC_MII16_LED2);\n\telse\n\t\tlmc_led_on (sc, LMC_MII16_LED0 | LMC_MII16_LED2);\n\n\t/*\n\t * select what interrupts we want to get\n\t */\n\tsc->lmc_intrmask |= (TULIP_STS_NORMALINTR\n\t\t\t       | TULIP_STS_RXINTR\n\t\t\t       | TULIP_STS_TXINTR\n\t\t\t       | TULIP_STS_ABNRMLINTR\n\t\t\t       | TULIP_STS_SYSERROR\n\t\t\t       | TULIP_STS_TXSTOPPED\n\t\t\t       | TULIP_STS_TXUNDERFLOW\n\t\t\t       | TULIP_STS_RXSTOPPED\n\t\t\t       );\n\tLMC_CSR_WRITE(sc, csr_intr, sc->lmc_intrmask);\n\n\tsc->lmc_cmdmode |= TULIP_CMD_TXRUN;\n\tsc->lmc_cmdmode |= TULIP_CMD_RXRUN;\n\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\n\tsc->lmc_if.if_timer = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->lmc_media->set_link_status",
          "args": [
            "sc",
            "flag"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_UNIT_TO_SOFTC",
          "args": [
            "pp->p2p_if.if_unit"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nint\nlmc_mdmctl(struct p2pcom *pp, int flag)\n{\n\tlmc_softc_t *sc = LMC_UNIT_TO_SOFTC(pp->p2p_if.if_unit);\n\n\tsc->lmc_media->set_link_status(sc, flag);\n\n\tif (flag)\n\t\tif ((sc->lmc_flags & LMC_IFUP) == 0)\n\t\t\tlmc_ifup(sc);\n\telse\n\t\tif ((sc->lmc_flags & LMC_IFUP) == LMC_IFUP)\n\t\t\tlmc_ifdown(sc);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "lmc_getmdm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "1384-1396",
    "snippet": "int\nlmc_getmdm(struct p2pcom *pp, caddr_t b)\n{\n\tlmc_softc_t *sc = LMC_UNIT_TO_SOFTC(pp->p2p_if.if_unit);\n\n\tif (sc->lmc_media->get_link_status(sc)) {\n\t\t*(int *)b = TIOCM_CAR;\n\t} else {\n\t\t*(int *)b = 0;\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->lmc_media->get_link_status",
          "args": [
            "sc"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_UNIT_TO_SOFTC",
          "args": [
            "pp->p2p_if.if_unit"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nint\nlmc_getmdm(struct p2pcom *pp, caddr_t b)\n{\n\tlmc_softc_t *sc = LMC_UNIT_TO_SOFTC(pp->p2p_if.if_unit);\n\n\tif (sc->lmc_media->get_link_status(sc)) {\n\t\t*(int *)b = TIOCM_CAR;\n\t} else {\n\t\t*(int *)b = 0;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "lmc_ifstart_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "1352-1380",
    "snippet": "static ifnet_ret_t\nlmc_ifstart_one(struct ifnet * const ifp)\n{\n\tlmc_softc_t * const sc = LMC_IFP_TO_SOFTC(ifp);\n\tstruct mbuf *m;\n\tstruct ifqueue *ifq;\n\n\tif ((sc->lmc_flags & LMC_IFUP) == 0)\n\t\treturn;\n\n\tifq = &sc->lmc_p2pcom.p2p_isnd;\n\n        m = ifq->ifq_head;\n    {\n\tif (m == NULL) {\n\t\tifq = &sc->lmc_if.if_snd;\n\t\tm = ifq->ifq_head;\n\t}\n\tif (m == NULL)\n\t\treturn 0;\n\tIF_DEQUEUE(ifq, m);\n\n\tm = lmc_txput(sc, m);\n    }\n\tif (m != NULL)\n\t\tIF_PREPEND(ifq, m);\n\n\tLMC_CSR_WRITE(sc, csr_txpoll, 1);\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);",
      "static ifnet_ret_t lmc_ifstart(struct ifnet *ifp);",
      "static struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);",
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LMC_CSR_WRITE",
          "args": [
            "sc",
            "csr_txpoll",
            "1"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_PREPEND",
          "args": [
            "ifq",
            "m"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmc_txput",
          "args": [
            "sc",
            "m"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_txput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "1004-1185",
          "snippet": "static struct mbuf *\nlmc_txput(lmc_softc_t * const sc, struct mbuf *m)\n{\n\tlmc_ringinfo_t * const ri = &sc->lmc_txinfo;\n\ttulip_desc_t *eop, *nextout;\n\tint segcnt, free;\n\tu_int32_t d_status;\n\tstruct mbuf *m0;\n\n#if defined(LMC_DEBUG)\n\tif ((sc->lmc_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\t\tprintf(LMC_PRINTF_FMT \": txput: tx not running\\n\",\n\t\t       LMC_PRINTF_ARGS);\n\t\tsc->lmc_flags |= LMC_WANTTXSTART;\n\t\tgoto finish;\n\t}\n#endif\n\n\t/*\n\t * Now we try to fill in our transmit descriptors.  This is\n\t * a bit reminiscent of going on the Ark two by two\n\t * since each descriptor for the TULIP can describe\n\t * two buffers.  So we advance through packet filling\n\t * each of the two entries at a time to fill each\n\t * descriptor.  Clear the first and last segment bits\n\t * in each descriptor (actually just clear everything\n\t * but the end-of-ring or chain bits) to make sure\n\t * we don't get messed up by previously sent packets.\n\t *\n\t * We may fail to put the entire packet on the ring if\n\t * there is either not enough ring entries free or if the\n\t * packet has more than MAX_TXSEG segments.  In the former\n\t * case we will just wait for the ring to empty.  In the\n\t * latter case we have to recopy.\n\t */\n again:\n\td_status = 0;\n\teop = nextout = ri->ri_nextout;\n\tm0 = m;\n\tsegcnt = 0;\n\tfree = ri->ri_free;\n\tdo {\n\t\tint len = m0->m_len;\n\t\tcaddr_t addr = mtod(m0, caddr_t);\n\t\tunsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));\n\n\t\twhile (len > 0) {\n\t\t\tunsigned slen = min(len, clsize);\n#ifdef BIG_PACKET\n\t\t\tint partial = 0;\n\t\t\tif (slen >= 2048)\n\t\t\t\tslen = 2040, partial = 1;\n#endif\n\t\t\tsegcnt++;\n\t\t\tif (segcnt > LMC_MAX_TXSEG) {\n\t\t\t\t/*\n\t\t\t\t * The packet exceeds the number of transmit\n\t\t\t\t * buffer entries that we can use for one\n\t\t\t\t * packet, so we have recopy it into one mbuf\n\t\t\t\t * and then try again.\n\t\t\t\t */\n\t\t\t\tm = lmc_mbuf_compress(m);\n\t\t\t\tif (m == NULL)\n\t\t\t\t\tgoto finish;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (segcnt & 1) {\n\t\t\t\tif (--free == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * See if there's any unclaimed space\n\t\t\t\t\t * in the transmit ring.\n\t\t\t\t\t */\n\t\t\t\t\tif ((free += lmc_tx_intr(sc)) == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * There's no more room but\n\t\t\t\t\t\t * since nothing has been\n\t\t\t\t\t\t * committed at this point,\n\t\t\t\t\t\t * just show output is active,\n\t\t\t\t\t\t * put back the mbuf and\n\t\t\t\t\t\t * return.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tsc->lmc_flags |= LMC_WANTTXSTART;\n\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\teop = nextout;\n\t\t\t\tif (++nextout == ri->ri_last)\n\t\t\t\t\tnextout = ri->ri_first;\n\t\t\t\teop->d_flag &= TULIP_DFLAG_ENDRING;\n\t\t\t\teop->d_flag |= TULIP_DFLAG_TxNOPADDING;\n\t\t\t\tif (sc->ictl.crc_length == 16)\n\t\t\t\t\teop->d_flag |= TULIP_DFLAG_TxHASCRC;\n\t\t\t\teop->d_status = d_status;\n\t\t\t\teop->d_addr1 = LMC_KVATOPHYS(sc, addr);\n\t\t\t\teop->d_length1 = slen;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t *  Fill in second half of descriptor\n\t\t\t\t */\n\t\t\t\teop->d_addr2 = LMC_KVATOPHYS(sc, addr);\n\t\t\t\teop->d_length2 = slen;\n\t\t\t}\n\t\t\td_status = TULIP_DSTS_OWNER;\n\t\t\tlen -= slen;\n\t\t\taddr += slen;\n#ifdef BIG_PACKET\n\t\t\tif (partial)\n\t\t\t\tcontinue;\n#endif\n\t\t\tclsize = CLBYTES;\n\t\t}\n\t} while ((m0 = m0->m_next) != NULL);\n\n\n\t/*\n\t * The descriptors have been filled in.  Now get ready\n\t * to transmit.\n\t */\n\tIF_ENQUEUE(&sc->lmc_txq, m);\n\tm = NULL;\n\n\t/*\n\t * Make sure the next descriptor after this packet is owned\n\t * by us since it may have been set up above if we ran out\n\t * of room in the ring.\n\t */\n\tnextout->d_status = 0;\n\n\t/*\n\t * If we only used the first segment of the last descriptor,\n\t * make sure the second segment will not be used.\n\t */\n\tif (segcnt & 1) {\n\t\teop->d_addr2 = 0;\n\t\teop->d_length2 = 0;\n\t}\n\n\t/*\n\t * Mark the last and first segments, indicate we want a transmit\n\t * complete interrupt, and tell it to transmit!\n\t */\n\teop->d_flag |= TULIP_DFLAG_TxLASTSEG | TULIP_DFLAG_TxWANTINTR;\n\n\t/*\n\t * Note that ri->ri_nextout is still the start of the packet\n\t * and until we set the OWNER bit, we can still back out of\n\t * everything we have done.\n\t */\n\tri->ri_nextout->d_flag |= TULIP_DFLAG_TxFIRSTSEG;\n\tri->ri_nextout->d_status = TULIP_DSTS_OWNER;\n\n\tLMC_CSR_WRITE(sc, csr_txpoll, 1);\n\n\t/*\n\t * This advances the ring for us.\n\t */\n\tri->ri_nextout = nextout;\n\tri->ri_free = free;\n\n\t/*\n\t * switch back to the single queueing ifstart.\n\t */\n\tsc->lmc_flags &= ~LMC_WANTTXSTART;\n\tsc->lmc_if.if_start = lmc_ifstart_one;\n\n\t/*\n\t * If we want a txstart, there must be not enough space in the\n\t * transmit ring.  So we want to enable transmit done interrupts\n\t * so we can immediately reclaim some space.  When the transmit\n\t * interrupt is posted, the interrupt handler will call tx_intr\n\t * to reclaim space and then txstart (since WANTTXSTART is set).\n\t * txstart will move the packet into the transmit ring and clear\n\t * WANTTXSTART thereby causing TXINTR to be cleared.\n\t */\n finish:\n\tif (sc->lmc_flags & LMC_WANTTXSTART) {\n\t\tsc->lmc_if.if_flags |= IFF_OACTIVE;\n\t\tsc->lmc_if.if_start = lmc_ifstart;\n\t}\n\n\treturn m;\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define d_flag u.bd_flag",
            "#define d_length2 u.bd_length2",
            "#define d_length1 u.bd_length1"
          ],
          "globals_used": [
            "static struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);",
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define d_flag u.bd_flag\n#define d_length2 u.bd_length2\n#define d_length1 u.bd_length1\n\nstatic struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic struct mbuf *\nlmc_txput(lmc_softc_t * const sc, struct mbuf *m)\n{\n\tlmc_ringinfo_t * const ri = &sc->lmc_txinfo;\n\ttulip_desc_t *eop, *nextout;\n\tint segcnt, free;\n\tu_int32_t d_status;\n\tstruct mbuf *m0;\n\n#if defined(LMC_DEBUG)\n\tif ((sc->lmc_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\t\tprintf(LMC_PRINTF_FMT \": txput: tx not running\\n\",\n\t\t       LMC_PRINTF_ARGS);\n\t\tsc->lmc_flags |= LMC_WANTTXSTART;\n\t\tgoto finish;\n\t}\n#endif\n\n\t/*\n\t * Now we try to fill in our transmit descriptors.  This is\n\t * a bit reminiscent of going on the Ark two by two\n\t * since each descriptor for the TULIP can describe\n\t * two buffers.  So we advance through packet filling\n\t * each of the two entries at a time to fill each\n\t * descriptor.  Clear the first and last segment bits\n\t * in each descriptor (actually just clear everything\n\t * but the end-of-ring or chain bits) to make sure\n\t * we don't get messed up by previously sent packets.\n\t *\n\t * We may fail to put the entire packet on the ring if\n\t * there is either not enough ring entries free or if the\n\t * packet has more than MAX_TXSEG segments.  In the former\n\t * case we will just wait for the ring to empty.  In the\n\t * latter case we have to recopy.\n\t */\n again:\n\td_status = 0;\n\teop = nextout = ri->ri_nextout;\n\tm0 = m;\n\tsegcnt = 0;\n\tfree = ri->ri_free;\n\tdo {\n\t\tint len = m0->m_len;\n\t\tcaddr_t addr = mtod(m0, caddr_t);\n\t\tunsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));\n\n\t\twhile (len > 0) {\n\t\t\tunsigned slen = min(len, clsize);\n#ifdef BIG_PACKET\n\t\t\tint partial = 0;\n\t\t\tif (slen >= 2048)\n\t\t\t\tslen = 2040, partial = 1;\n#endif\n\t\t\tsegcnt++;\n\t\t\tif (segcnt > LMC_MAX_TXSEG) {\n\t\t\t\t/*\n\t\t\t\t * The packet exceeds the number of transmit\n\t\t\t\t * buffer entries that we can use for one\n\t\t\t\t * packet, so we have recopy it into one mbuf\n\t\t\t\t * and then try again.\n\t\t\t\t */\n\t\t\t\tm = lmc_mbuf_compress(m);\n\t\t\t\tif (m == NULL)\n\t\t\t\t\tgoto finish;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (segcnt & 1) {\n\t\t\t\tif (--free == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * See if there's any unclaimed space\n\t\t\t\t\t * in the transmit ring.\n\t\t\t\t\t */\n\t\t\t\t\tif ((free += lmc_tx_intr(sc)) == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * There's no more room but\n\t\t\t\t\t\t * since nothing has been\n\t\t\t\t\t\t * committed at this point,\n\t\t\t\t\t\t * just show output is active,\n\t\t\t\t\t\t * put back the mbuf and\n\t\t\t\t\t\t * return.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tsc->lmc_flags |= LMC_WANTTXSTART;\n\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\teop = nextout;\n\t\t\t\tif (++nextout == ri->ri_last)\n\t\t\t\t\tnextout = ri->ri_first;\n\t\t\t\teop->d_flag &= TULIP_DFLAG_ENDRING;\n\t\t\t\teop->d_flag |= TULIP_DFLAG_TxNOPADDING;\n\t\t\t\tif (sc->ictl.crc_length == 16)\n\t\t\t\t\teop->d_flag |= TULIP_DFLAG_TxHASCRC;\n\t\t\t\teop->d_status = d_status;\n\t\t\t\teop->d_addr1 = LMC_KVATOPHYS(sc, addr);\n\t\t\t\teop->d_length1 = slen;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t *  Fill in second half of descriptor\n\t\t\t\t */\n\t\t\t\teop->d_addr2 = LMC_KVATOPHYS(sc, addr);\n\t\t\t\teop->d_length2 = slen;\n\t\t\t}\n\t\t\td_status = TULIP_DSTS_OWNER;\n\t\t\tlen -= slen;\n\t\t\taddr += slen;\n#ifdef BIG_PACKET\n\t\t\tif (partial)\n\t\t\t\tcontinue;\n#endif\n\t\t\tclsize = CLBYTES;\n\t\t}\n\t} while ((m0 = m0->m_next) != NULL);\n\n\n\t/*\n\t * The descriptors have been filled in.  Now get ready\n\t * to transmit.\n\t */\n\tIF_ENQUEUE(&sc->lmc_txq, m);\n\tm = NULL;\n\n\t/*\n\t * Make sure the next descriptor after this packet is owned\n\t * by us since it may have been set up above if we ran out\n\t * of room in the ring.\n\t */\n\tnextout->d_status = 0;\n\n\t/*\n\t * If we only used the first segment of the last descriptor,\n\t * make sure the second segment will not be used.\n\t */\n\tif (segcnt & 1) {\n\t\teop->d_addr2 = 0;\n\t\teop->d_length2 = 0;\n\t}\n\n\t/*\n\t * Mark the last and first segments, indicate we want a transmit\n\t * complete interrupt, and tell it to transmit!\n\t */\n\teop->d_flag |= TULIP_DFLAG_TxLASTSEG | TULIP_DFLAG_TxWANTINTR;\n\n\t/*\n\t * Note that ri->ri_nextout is still the start of the packet\n\t * and until we set the OWNER bit, we can still back out of\n\t * everything we have done.\n\t */\n\tri->ri_nextout->d_flag |= TULIP_DFLAG_TxFIRSTSEG;\n\tri->ri_nextout->d_status = TULIP_DSTS_OWNER;\n\n\tLMC_CSR_WRITE(sc, csr_txpoll, 1);\n\n\t/*\n\t * This advances the ring for us.\n\t */\n\tri->ri_nextout = nextout;\n\tri->ri_free = free;\n\n\t/*\n\t * switch back to the single queueing ifstart.\n\t */\n\tsc->lmc_flags &= ~LMC_WANTTXSTART;\n\tsc->lmc_if.if_start = lmc_ifstart_one;\n\n\t/*\n\t * If we want a txstart, there must be not enough space in the\n\t * transmit ring.  So we want to enable transmit done interrupts\n\t * so we can immediately reclaim some space.  When the transmit\n\t * interrupt is posted, the interrupt handler will call tx_intr\n\t * to reclaim space and then txstart (since WANTTXSTART is set).\n\t * txstart will move the packet into the transmit ring and clear\n\t * WANTTXSTART thereby causing TXINTR to be cleared.\n\t */\n finish:\n\tif (sc->lmc_flags & LMC_WANTTXSTART) {\n\t\tsc->lmc_if.if_flags |= IFF_OACTIVE;\n\t\tsc->lmc_if.if_start = lmc_ifstart;\n\t}\n\n\treturn m;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "ifq",
            "m"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_IFP_TO_SOFTC",
          "args": [
            "ifp"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);\nstatic ifnet_ret_t lmc_ifstart(struct ifnet *ifp);\nstatic struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic ifnet_ret_t\nlmc_ifstart_one(struct ifnet * const ifp)\n{\n\tlmc_softc_t * const sc = LMC_IFP_TO_SOFTC(ifp);\n\tstruct mbuf *m;\n\tstruct ifqueue *ifq;\n\n\tif ((sc->lmc_flags & LMC_IFUP) == 0)\n\t\treturn;\n\n\tifq = &sc->lmc_p2pcom.p2p_isnd;\n\n        m = ifq->ifq_head;\n    {\n\tif (m == NULL) {\n\t\tifq = &sc->lmc_if.if_snd;\n\t\tm = ifq->ifq_head;\n\t}\n\tif (m == NULL)\n\t\treturn 0;\n\tIF_DEQUEUE(ifq, m);\n\n\tm = lmc_txput(sc, m);\n    }\n\tif (m != NULL)\n\t\tIF_PREPEND(ifq, m);\n\n\tLMC_CSR_WRITE(sc, csr_txpoll, 1);\n}"
  },
  {
    "function_name": "lmc_ifstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "1320-1350",
    "snippet": "static ifnet_ret_t\nlmc_ifstart(struct ifnet * const ifp)\n{\n\tlmc_softc_t * const sc = LMC_IFP_TO_SOFTC(ifp);\n\tstruct mbuf *m;\n\tstruct ifqueue *ifq;\n\n\tif ((sc->lmc_flags & LMC_IFUP) == 0)\n\t\treturn;\n\n\tfor (;;) {\n\t\tifq = &sc->lmc_p2pcom.p2p_isnd;\n\n\t\tm = ifq->ifq_head;\n\t\tif (m == NULL) {\n\t\t\tifq = &sc->lmc_if.if_snd;\n\t\t\tm = ifq->ifq_head;\n\t\t}\n\t\tif (m == NULL)\n\t\t\tbreak;\n\t\tIF_DEQUEUE(ifq, m);\n\n\t\tm = lmc_txput(sc, m);\n\t\tif (m != NULL) {\n\t\t\tIF_PREPEND(ifq, m);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tLMC_CSR_WRITE(sc, csr_txpoll, 1);\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);",
      "static ifnet_ret_t lmc_ifstart(struct ifnet *ifp);",
      "static struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);",
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LMC_CSR_WRITE",
          "args": [
            "sc",
            "csr_txpoll",
            "1"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_PREPEND",
          "args": [
            "ifq",
            "m"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmc_txput",
          "args": [
            "sc",
            "m"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_txput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "1004-1185",
          "snippet": "static struct mbuf *\nlmc_txput(lmc_softc_t * const sc, struct mbuf *m)\n{\n\tlmc_ringinfo_t * const ri = &sc->lmc_txinfo;\n\ttulip_desc_t *eop, *nextout;\n\tint segcnt, free;\n\tu_int32_t d_status;\n\tstruct mbuf *m0;\n\n#if defined(LMC_DEBUG)\n\tif ((sc->lmc_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\t\tprintf(LMC_PRINTF_FMT \": txput: tx not running\\n\",\n\t\t       LMC_PRINTF_ARGS);\n\t\tsc->lmc_flags |= LMC_WANTTXSTART;\n\t\tgoto finish;\n\t}\n#endif\n\n\t/*\n\t * Now we try to fill in our transmit descriptors.  This is\n\t * a bit reminiscent of going on the Ark two by two\n\t * since each descriptor for the TULIP can describe\n\t * two buffers.  So we advance through packet filling\n\t * each of the two entries at a time to fill each\n\t * descriptor.  Clear the first and last segment bits\n\t * in each descriptor (actually just clear everything\n\t * but the end-of-ring or chain bits) to make sure\n\t * we don't get messed up by previously sent packets.\n\t *\n\t * We may fail to put the entire packet on the ring if\n\t * there is either not enough ring entries free or if the\n\t * packet has more than MAX_TXSEG segments.  In the former\n\t * case we will just wait for the ring to empty.  In the\n\t * latter case we have to recopy.\n\t */\n again:\n\td_status = 0;\n\teop = nextout = ri->ri_nextout;\n\tm0 = m;\n\tsegcnt = 0;\n\tfree = ri->ri_free;\n\tdo {\n\t\tint len = m0->m_len;\n\t\tcaddr_t addr = mtod(m0, caddr_t);\n\t\tunsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));\n\n\t\twhile (len > 0) {\n\t\t\tunsigned slen = min(len, clsize);\n#ifdef BIG_PACKET\n\t\t\tint partial = 0;\n\t\t\tif (slen >= 2048)\n\t\t\t\tslen = 2040, partial = 1;\n#endif\n\t\t\tsegcnt++;\n\t\t\tif (segcnt > LMC_MAX_TXSEG) {\n\t\t\t\t/*\n\t\t\t\t * The packet exceeds the number of transmit\n\t\t\t\t * buffer entries that we can use for one\n\t\t\t\t * packet, so we have recopy it into one mbuf\n\t\t\t\t * and then try again.\n\t\t\t\t */\n\t\t\t\tm = lmc_mbuf_compress(m);\n\t\t\t\tif (m == NULL)\n\t\t\t\t\tgoto finish;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (segcnt & 1) {\n\t\t\t\tif (--free == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * See if there's any unclaimed space\n\t\t\t\t\t * in the transmit ring.\n\t\t\t\t\t */\n\t\t\t\t\tif ((free += lmc_tx_intr(sc)) == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * There's no more room but\n\t\t\t\t\t\t * since nothing has been\n\t\t\t\t\t\t * committed at this point,\n\t\t\t\t\t\t * just show output is active,\n\t\t\t\t\t\t * put back the mbuf and\n\t\t\t\t\t\t * return.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tsc->lmc_flags |= LMC_WANTTXSTART;\n\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\teop = nextout;\n\t\t\t\tif (++nextout == ri->ri_last)\n\t\t\t\t\tnextout = ri->ri_first;\n\t\t\t\teop->d_flag &= TULIP_DFLAG_ENDRING;\n\t\t\t\teop->d_flag |= TULIP_DFLAG_TxNOPADDING;\n\t\t\t\tif (sc->ictl.crc_length == 16)\n\t\t\t\t\teop->d_flag |= TULIP_DFLAG_TxHASCRC;\n\t\t\t\teop->d_status = d_status;\n\t\t\t\teop->d_addr1 = LMC_KVATOPHYS(sc, addr);\n\t\t\t\teop->d_length1 = slen;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t *  Fill in second half of descriptor\n\t\t\t\t */\n\t\t\t\teop->d_addr2 = LMC_KVATOPHYS(sc, addr);\n\t\t\t\teop->d_length2 = slen;\n\t\t\t}\n\t\t\td_status = TULIP_DSTS_OWNER;\n\t\t\tlen -= slen;\n\t\t\taddr += slen;\n#ifdef BIG_PACKET\n\t\t\tif (partial)\n\t\t\t\tcontinue;\n#endif\n\t\t\tclsize = CLBYTES;\n\t\t}\n\t} while ((m0 = m0->m_next) != NULL);\n\n\n\t/*\n\t * The descriptors have been filled in.  Now get ready\n\t * to transmit.\n\t */\n\tIF_ENQUEUE(&sc->lmc_txq, m);\n\tm = NULL;\n\n\t/*\n\t * Make sure the next descriptor after this packet is owned\n\t * by us since it may have been set up above if we ran out\n\t * of room in the ring.\n\t */\n\tnextout->d_status = 0;\n\n\t/*\n\t * If we only used the first segment of the last descriptor,\n\t * make sure the second segment will not be used.\n\t */\n\tif (segcnt & 1) {\n\t\teop->d_addr2 = 0;\n\t\teop->d_length2 = 0;\n\t}\n\n\t/*\n\t * Mark the last and first segments, indicate we want a transmit\n\t * complete interrupt, and tell it to transmit!\n\t */\n\teop->d_flag |= TULIP_DFLAG_TxLASTSEG | TULIP_DFLAG_TxWANTINTR;\n\n\t/*\n\t * Note that ri->ri_nextout is still the start of the packet\n\t * and until we set the OWNER bit, we can still back out of\n\t * everything we have done.\n\t */\n\tri->ri_nextout->d_flag |= TULIP_DFLAG_TxFIRSTSEG;\n\tri->ri_nextout->d_status = TULIP_DSTS_OWNER;\n\n\tLMC_CSR_WRITE(sc, csr_txpoll, 1);\n\n\t/*\n\t * This advances the ring for us.\n\t */\n\tri->ri_nextout = nextout;\n\tri->ri_free = free;\n\n\t/*\n\t * switch back to the single queueing ifstart.\n\t */\n\tsc->lmc_flags &= ~LMC_WANTTXSTART;\n\tsc->lmc_if.if_start = lmc_ifstart_one;\n\n\t/*\n\t * If we want a txstart, there must be not enough space in the\n\t * transmit ring.  So we want to enable transmit done interrupts\n\t * so we can immediately reclaim some space.  When the transmit\n\t * interrupt is posted, the interrupt handler will call tx_intr\n\t * to reclaim space and then txstart (since WANTTXSTART is set).\n\t * txstart will move the packet into the transmit ring and clear\n\t * WANTTXSTART thereby causing TXINTR to be cleared.\n\t */\n finish:\n\tif (sc->lmc_flags & LMC_WANTTXSTART) {\n\t\tsc->lmc_if.if_flags |= IFF_OACTIVE;\n\t\tsc->lmc_if.if_start = lmc_ifstart;\n\t}\n\n\treturn m;\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define d_flag u.bd_flag",
            "#define d_length2 u.bd_length2",
            "#define d_length1 u.bd_length1"
          ],
          "globals_used": [
            "static struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);",
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define d_flag u.bd_flag\n#define d_length2 u.bd_length2\n#define d_length1 u.bd_length1\n\nstatic struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic struct mbuf *\nlmc_txput(lmc_softc_t * const sc, struct mbuf *m)\n{\n\tlmc_ringinfo_t * const ri = &sc->lmc_txinfo;\n\ttulip_desc_t *eop, *nextout;\n\tint segcnt, free;\n\tu_int32_t d_status;\n\tstruct mbuf *m0;\n\n#if defined(LMC_DEBUG)\n\tif ((sc->lmc_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\t\tprintf(LMC_PRINTF_FMT \": txput: tx not running\\n\",\n\t\t       LMC_PRINTF_ARGS);\n\t\tsc->lmc_flags |= LMC_WANTTXSTART;\n\t\tgoto finish;\n\t}\n#endif\n\n\t/*\n\t * Now we try to fill in our transmit descriptors.  This is\n\t * a bit reminiscent of going on the Ark two by two\n\t * since each descriptor for the TULIP can describe\n\t * two buffers.  So we advance through packet filling\n\t * each of the two entries at a time to fill each\n\t * descriptor.  Clear the first and last segment bits\n\t * in each descriptor (actually just clear everything\n\t * but the end-of-ring or chain bits) to make sure\n\t * we don't get messed up by previously sent packets.\n\t *\n\t * We may fail to put the entire packet on the ring if\n\t * there is either not enough ring entries free or if the\n\t * packet has more than MAX_TXSEG segments.  In the former\n\t * case we will just wait for the ring to empty.  In the\n\t * latter case we have to recopy.\n\t */\n again:\n\td_status = 0;\n\teop = nextout = ri->ri_nextout;\n\tm0 = m;\n\tsegcnt = 0;\n\tfree = ri->ri_free;\n\tdo {\n\t\tint len = m0->m_len;\n\t\tcaddr_t addr = mtod(m0, caddr_t);\n\t\tunsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));\n\n\t\twhile (len > 0) {\n\t\t\tunsigned slen = min(len, clsize);\n#ifdef BIG_PACKET\n\t\t\tint partial = 0;\n\t\t\tif (slen >= 2048)\n\t\t\t\tslen = 2040, partial = 1;\n#endif\n\t\t\tsegcnt++;\n\t\t\tif (segcnt > LMC_MAX_TXSEG) {\n\t\t\t\t/*\n\t\t\t\t * The packet exceeds the number of transmit\n\t\t\t\t * buffer entries that we can use for one\n\t\t\t\t * packet, so we have recopy it into one mbuf\n\t\t\t\t * and then try again.\n\t\t\t\t */\n\t\t\t\tm = lmc_mbuf_compress(m);\n\t\t\t\tif (m == NULL)\n\t\t\t\t\tgoto finish;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (segcnt & 1) {\n\t\t\t\tif (--free == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * See if there's any unclaimed space\n\t\t\t\t\t * in the transmit ring.\n\t\t\t\t\t */\n\t\t\t\t\tif ((free += lmc_tx_intr(sc)) == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * There's no more room but\n\t\t\t\t\t\t * since nothing has been\n\t\t\t\t\t\t * committed at this point,\n\t\t\t\t\t\t * just show output is active,\n\t\t\t\t\t\t * put back the mbuf and\n\t\t\t\t\t\t * return.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tsc->lmc_flags |= LMC_WANTTXSTART;\n\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\teop = nextout;\n\t\t\t\tif (++nextout == ri->ri_last)\n\t\t\t\t\tnextout = ri->ri_first;\n\t\t\t\teop->d_flag &= TULIP_DFLAG_ENDRING;\n\t\t\t\teop->d_flag |= TULIP_DFLAG_TxNOPADDING;\n\t\t\t\tif (sc->ictl.crc_length == 16)\n\t\t\t\t\teop->d_flag |= TULIP_DFLAG_TxHASCRC;\n\t\t\t\teop->d_status = d_status;\n\t\t\t\teop->d_addr1 = LMC_KVATOPHYS(sc, addr);\n\t\t\t\teop->d_length1 = slen;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t *  Fill in second half of descriptor\n\t\t\t\t */\n\t\t\t\teop->d_addr2 = LMC_KVATOPHYS(sc, addr);\n\t\t\t\teop->d_length2 = slen;\n\t\t\t}\n\t\t\td_status = TULIP_DSTS_OWNER;\n\t\t\tlen -= slen;\n\t\t\taddr += slen;\n#ifdef BIG_PACKET\n\t\t\tif (partial)\n\t\t\t\tcontinue;\n#endif\n\t\t\tclsize = CLBYTES;\n\t\t}\n\t} while ((m0 = m0->m_next) != NULL);\n\n\n\t/*\n\t * The descriptors have been filled in.  Now get ready\n\t * to transmit.\n\t */\n\tIF_ENQUEUE(&sc->lmc_txq, m);\n\tm = NULL;\n\n\t/*\n\t * Make sure the next descriptor after this packet is owned\n\t * by us since it may have been set up above if we ran out\n\t * of room in the ring.\n\t */\n\tnextout->d_status = 0;\n\n\t/*\n\t * If we only used the first segment of the last descriptor,\n\t * make sure the second segment will not be used.\n\t */\n\tif (segcnt & 1) {\n\t\teop->d_addr2 = 0;\n\t\teop->d_length2 = 0;\n\t}\n\n\t/*\n\t * Mark the last and first segments, indicate we want a transmit\n\t * complete interrupt, and tell it to transmit!\n\t */\n\teop->d_flag |= TULIP_DFLAG_TxLASTSEG | TULIP_DFLAG_TxWANTINTR;\n\n\t/*\n\t * Note that ri->ri_nextout is still the start of the packet\n\t * and until we set the OWNER bit, we can still back out of\n\t * everything we have done.\n\t */\n\tri->ri_nextout->d_flag |= TULIP_DFLAG_TxFIRSTSEG;\n\tri->ri_nextout->d_status = TULIP_DSTS_OWNER;\n\n\tLMC_CSR_WRITE(sc, csr_txpoll, 1);\n\n\t/*\n\t * This advances the ring for us.\n\t */\n\tri->ri_nextout = nextout;\n\tri->ri_free = free;\n\n\t/*\n\t * switch back to the single queueing ifstart.\n\t */\n\tsc->lmc_flags &= ~LMC_WANTTXSTART;\n\tsc->lmc_if.if_start = lmc_ifstart_one;\n\n\t/*\n\t * If we want a txstart, there must be not enough space in the\n\t * transmit ring.  So we want to enable transmit done interrupts\n\t * so we can immediately reclaim some space.  When the transmit\n\t * interrupt is posted, the interrupt handler will call tx_intr\n\t * to reclaim space and then txstart (since WANTTXSTART is set).\n\t * txstart will move the packet into the transmit ring and clear\n\t * WANTTXSTART thereby causing TXINTR to be cleared.\n\t */\n finish:\n\tif (sc->lmc_flags & LMC_WANTTXSTART) {\n\t\tsc->lmc_if.if_flags |= IFF_OACTIVE;\n\t\tsc->lmc_if.if_start = lmc_ifstart;\n\t}\n\n\treturn m;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "ifq",
            "m"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_IFP_TO_SOFTC",
          "args": [
            "ifp"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);\nstatic ifnet_ret_t lmc_ifstart(struct ifnet *ifp);\nstatic struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic ifnet_ret_t\nlmc_ifstart(struct ifnet * const ifp)\n{\n\tlmc_softc_t * const sc = LMC_IFP_TO_SOFTC(ifp);\n\tstruct mbuf *m;\n\tstruct ifqueue *ifq;\n\n\tif ((sc->lmc_flags & LMC_IFUP) == 0)\n\t\treturn;\n\n\tfor (;;) {\n\t\tifq = &sc->lmc_p2pcom.p2p_isnd;\n\n\t\tm = ifq->ifq_head;\n\t\tif (m == NULL) {\n\t\t\tifq = &sc->lmc_if.if_snd;\n\t\t\tm = ifq->ifq_head;\n\t\t}\n\t\tif (m == NULL)\n\t\t\tbreak;\n\t\tIF_DEQUEUE(ifq, m);\n\n\t\tm = lmc_txput(sc, m);\n\t\tif (m != NULL) {\n\t\t\tIF_PREPEND(ifq, m);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tLMC_CSR_WRITE(sc, csr_txpoll, 1);\n}"
  },
  {
    "function_name": "lmc_ifstart_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "1303-1316",
    "snippet": "static ifnet_ret_t\nlmc_ifstart_one(struct ifnet * const ifp)\n{\n\tlmc_softc_t * const sc = LMC_IFP_TO_SOFTC(ifp);\n\tstruct mbuf *m;\n\n\tif ((sc->lmc_flags & LMC_IFUP) && (sppp_isempty(ifp) == 0)) {\n\t\tm = sppp_dequeue(ifp);\n\t\tif ((m = lmc_txput(sc, m)) != NULL) {\n\t\t\tIF_PREPEND(&((struct sppp *)ifp)->pp_fastq, m);\n\t\t}\n\t\tLMC_CSR_WRITE(sc, csr_txpoll, 1);\n\t}\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);",
      "static ifnet_ret_t lmc_ifstart(struct ifnet *ifp);",
      "static struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);",
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LMC_CSR_WRITE",
          "args": [
            "sc",
            "csr_txpoll",
            "1"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_PREPEND",
          "args": [
            "&((struct sppp *)ifp)->pp_fastq",
            "m"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmc_txput",
          "args": [
            "sc",
            "m"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_txput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "1004-1185",
          "snippet": "static struct mbuf *\nlmc_txput(lmc_softc_t * const sc, struct mbuf *m)\n{\n\tlmc_ringinfo_t * const ri = &sc->lmc_txinfo;\n\ttulip_desc_t *eop, *nextout;\n\tint segcnt, free;\n\tu_int32_t d_status;\n\tstruct mbuf *m0;\n\n#if defined(LMC_DEBUG)\n\tif ((sc->lmc_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\t\tprintf(LMC_PRINTF_FMT \": txput: tx not running\\n\",\n\t\t       LMC_PRINTF_ARGS);\n\t\tsc->lmc_flags |= LMC_WANTTXSTART;\n\t\tgoto finish;\n\t}\n#endif\n\n\t/*\n\t * Now we try to fill in our transmit descriptors.  This is\n\t * a bit reminiscent of going on the Ark two by two\n\t * since each descriptor for the TULIP can describe\n\t * two buffers.  So we advance through packet filling\n\t * each of the two entries at a time to fill each\n\t * descriptor.  Clear the first and last segment bits\n\t * in each descriptor (actually just clear everything\n\t * but the end-of-ring or chain bits) to make sure\n\t * we don't get messed up by previously sent packets.\n\t *\n\t * We may fail to put the entire packet on the ring if\n\t * there is either not enough ring entries free or if the\n\t * packet has more than MAX_TXSEG segments.  In the former\n\t * case we will just wait for the ring to empty.  In the\n\t * latter case we have to recopy.\n\t */\n again:\n\td_status = 0;\n\teop = nextout = ri->ri_nextout;\n\tm0 = m;\n\tsegcnt = 0;\n\tfree = ri->ri_free;\n\tdo {\n\t\tint len = m0->m_len;\n\t\tcaddr_t addr = mtod(m0, caddr_t);\n\t\tunsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));\n\n\t\twhile (len > 0) {\n\t\t\tunsigned slen = min(len, clsize);\n#ifdef BIG_PACKET\n\t\t\tint partial = 0;\n\t\t\tif (slen >= 2048)\n\t\t\t\tslen = 2040, partial = 1;\n#endif\n\t\t\tsegcnt++;\n\t\t\tif (segcnt > LMC_MAX_TXSEG) {\n\t\t\t\t/*\n\t\t\t\t * The packet exceeds the number of transmit\n\t\t\t\t * buffer entries that we can use for one\n\t\t\t\t * packet, so we have recopy it into one mbuf\n\t\t\t\t * and then try again.\n\t\t\t\t */\n\t\t\t\tm = lmc_mbuf_compress(m);\n\t\t\t\tif (m == NULL)\n\t\t\t\t\tgoto finish;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (segcnt & 1) {\n\t\t\t\tif (--free == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * See if there's any unclaimed space\n\t\t\t\t\t * in the transmit ring.\n\t\t\t\t\t */\n\t\t\t\t\tif ((free += lmc_tx_intr(sc)) == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * There's no more room but\n\t\t\t\t\t\t * since nothing has been\n\t\t\t\t\t\t * committed at this point,\n\t\t\t\t\t\t * just show output is active,\n\t\t\t\t\t\t * put back the mbuf and\n\t\t\t\t\t\t * return.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tsc->lmc_flags |= LMC_WANTTXSTART;\n\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\teop = nextout;\n\t\t\t\tif (++nextout == ri->ri_last)\n\t\t\t\t\tnextout = ri->ri_first;\n\t\t\t\teop->d_flag &= TULIP_DFLAG_ENDRING;\n\t\t\t\teop->d_flag |= TULIP_DFLAG_TxNOPADDING;\n\t\t\t\tif (sc->ictl.crc_length == 16)\n\t\t\t\t\teop->d_flag |= TULIP_DFLAG_TxHASCRC;\n\t\t\t\teop->d_status = d_status;\n\t\t\t\teop->d_addr1 = LMC_KVATOPHYS(sc, addr);\n\t\t\t\teop->d_length1 = slen;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t *  Fill in second half of descriptor\n\t\t\t\t */\n\t\t\t\teop->d_addr2 = LMC_KVATOPHYS(sc, addr);\n\t\t\t\teop->d_length2 = slen;\n\t\t\t}\n\t\t\td_status = TULIP_DSTS_OWNER;\n\t\t\tlen -= slen;\n\t\t\taddr += slen;\n#ifdef BIG_PACKET\n\t\t\tif (partial)\n\t\t\t\tcontinue;\n#endif\n\t\t\tclsize = CLBYTES;\n\t\t}\n\t} while ((m0 = m0->m_next) != NULL);\n\n\n\t/*\n\t * The descriptors have been filled in.  Now get ready\n\t * to transmit.\n\t */\n\tIF_ENQUEUE(&sc->lmc_txq, m);\n\tm = NULL;\n\n\t/*\n\t * Make sure the next descriptor after this packet is owned\n\t * by us since it may have been set up above if we ran out\n\t * of room in the ring.\n\t */\n\tnextout->d_status = 0;\n\n\t/*\n\t * If we only used the first segment of the last descriptor,\n\t * make sure the second segment will not be used.\n\t */\n\tif (segcnt & 1) {\n\t\teop->d_addr2 = 0;\n\t\teop->d_length2 = 0;\n\t}\n\n\t/*\n\t * Mark the last and first segments, indicate we want a transmit\n\t * complete interrupt, and tell it to transmit!\n\t */\n\teop->d_flag |= TULIP_DFLAG_TxLASTSEG | TULIP_DFLAG_TxWANTINTR;\n\n\t/*\n\t * Note that ri->ri_nextout is still the start of the packet\n\t * and until we set the OWNER bit, we can still back out of\n\t * everything we have done.\n\t */\n\tri->ri_nextout->d_flag |= TULIP_DFLAG_TxFIRSTSEG;\n\tri->ri_nextout->d_status = TULIP_DSTS_OWNER;\n\n\tLMC_CSR_WRITE(sc, csr_txpoll, 1);\n\n\t/*\n\t * This advances the ring for us.\n\t */\n\tri->ri_nextout = nextout;\n\tri->ri_free = free;\n\n\t/*\n\t * switch back to the single queueing ifstart.\n\t */\n\tsc->lmc_flags &= ~LMC_WANTTXSTART;\n\tsc->lmc_if.if_start = lmc_ifstart_one;\n\n\t/*\n\t * If we want a txstart, there must be not enough space in the\n\t * transmit ring.  So we want to enable transmit done interrupts\n\t * so we can immediately reclaim some space.  When the transmit\n\t * interrupt is posted, the interrupt handler will call tx_intr\n\t * to reclaim space and then txstart (since WANTTXSTART is set).\n\t * txstart will move the packet into the transmit ring and clear\n\t * WANTTXSTART thereby causing TXINTR to be cleared.\n\t */\n finish:\n\tif (sc->lmc_flags & LMC_WANTTXSTART) {\n\t\tsc->lmc_if.if_flags |= IFF_OACTIVE;\n\t\tsc->lmc_if.if_start = lmc_ifstart;\n\t}\n\n\treturn m;\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define d_flag u.bd_flag",
            "#define d_length2 u.bd_length2",
            "#define d_length1 u.bd_length1"
          ],
          "globals_used": [
            "static struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);",
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define d_flag u.bd_flag\n#define d_length2 u.bd_length2\n#define d_length1 u.bd_length1\n\nstatic struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic struct mbuf *\nlmc_txput(lmc_softc_t * const sc, struct mbuf *m)\n{\n\tlmc_ringinfo_t * const ri = &sc->lmc_txinfo;\n\ttulip_desc_t *eop, *nextout;\n\tint segcnt, free;\n\tu_int32_t d_status;\n\tstruct mbuf *m0;\n\n#if defined(LMC_DEBUG)\n\tif ((sc->lmc_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\t\tprintf(LMC_PRINTF_FMT \": txput: tx not running\\n\",\n\t\t       LMC_PRINTF_ARGS);\n\t\tsc->lmc_flags |= LMC_WANTTXSTART;\n\t\tgoto finish;\n\t}\n#endif\n\n\t/*\n\t * Now we try to fill in our transmit descriptors.  This is\n\t * a bit reminiscent of going on the Ark two by two\n\t * since each descriptor for the TULIP can describe\n\t * two buffers.  So we advance through packet filling\n\t * each of the two entries at a time to fill each\n\t * descriptor.  Clear the first and last segment bits\n\t * in each descriptor (actually just clear everything\n\t * but the end-of-ring or chain bits) to make sure\n\t * we don't get messed up by previously sent packets.\n\t *\n\t * We may fail to put the entire packet on the ring if\n\t * there is either not enough ring entries free or if the\n\t * packet has more than MAX_TXSEG segments.  In the former\n\t * case we will just wait for the ring to empty.  In the\n\t * latter case we have to recopy.\n\t */\n again:\n\td_status = 0;\n\teop = nextout = ri->ri_nextout;\n\tm0 = m;\n\tsegcnt = 0;\n\tfree = ri->ri_free;\n\tdo {\n\t\tint len = m0->m_len;\n\t\tcaddr_t addr = mtod(m0, caddr_t);\n\t\tunsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));\n\n\t\twhile (len > 0) {\n\t\t\tunsigned slen = min(len, clsize);\n#ifdef BIG_PACKET\n\t\t\tint partial = 0;\n\t\t\tif (slen >= 2048)\n\t\t\t\tslen = 2040, partial = 1;\n#endif\n\t\t\tsegcnt++;\n\t\t\tif (segcnt > LMC_MAX_TXSEG) {\n\t\t\t\t/*\n\t\t\t\t * The packet exceeds the number of transmit\n\t\t\t\t * buffer entries that we can use for one\n\t\t\t\t * packet, so we have recopy it into one mbuf\n\t\t\t\t * and then try again.\n\t\t\t\t */\n\t\t\t\tm = lmc_mbuf_compress(m);\n\t\t\t\tif (m == NULL)\n\t\t\t\t\tgoto finish;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (segcnt & 1) {\n\t\t\t\tif (--free == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * See if there's any unclaimed space\n\t\t\t\t\t * in the transmit ring.\n\t\t\t\t\t */\n\t\t\t\t\tif ((free += lmc_tx_intr(sc)) == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * There's no more room but\n\t\t\t\t\t\t * since nothing has been\n\t\t\t\t\t\t * committed at this point,\n\t\t\t\t\t\t * just show output is active,\n\t\t\t\t\t\t * put back the mbuf and\n\t\t\t\t\t\t * return.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tsc->lmc_flags |= LMC_WANTTXSTART;\n\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\teop = nextout;\n\t\t\t\tif (++nextout == ri->ri_last)\n\t\t\t\t\tnextout = ri->ri_first;\n\t\t\t\teop->d_flag &= TULIP_DFLAG_ENDRING;\n\t\t\t\teop->d_flag |= TULIP_DFLAG_TxNOPADDING;\n\t\t\t\tif (sc->ictl.crc_length == 16)\n\t\t\t\t\teop->d_flag |= TULIP_DFLAG_TxHASCRC;\n\t\t\t\teop->d_status = d_status;\n\t\t\t\teop->d_addr1 = LMC_KVATOPHYS(sc, addr);\n\t\t\t\teop->d_length1 = slen;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t *  Fill in second half of descriptor\n\t\t\t\t */\n\t\t\t\teop->d_addr2 = LMC_KVATOPHYS(sc, addr);\n\t\t\t\teop->d_length2 = slen;\n\t\t\t}\n\t\t\td_status = TULIP_DSTS_OWNER;\n\t\t\tlen -= slen;\n\t\t\taddr += slen;\n#ifdef BIG_PACKET\n\t\t\tif (partial)\n\t\t\t\tcontinue;\n#endif\n\t\t\tclsize = CLBYTES;\n\t\t}\n\t} while ((m0 = m0->m_next) != NULL);\n\n\n\t/*\n\t * The descriptors have been filled in.  Now get ready\n\t * to transmit.\n\t */\n\tIF_ENQUEUE(&sc->lmc_txq, m);\n\tm = NULL;\n\n\t/*\n\t * Make sure the next descriptor after this packet is owned\n\t * by us since it may have been set up above if we ran out\n\t * of room in the ring.\n\t */\n\tnextout->d_status = 0;\n\n\t/*\n\t * If we only used the first segment of the last descriptor,\n\t * make sure the second segment will not be used.\n\t */\n\tif (segcnt & 1) {\n\t\teop->d_addr2 = 0;\n\t\teop->d_length2 = 0;\n\t}\n\n\t/*\n\t * Mark the last and first segments, indicate we want a transmit\n\t * complete interrupt, and tell it to transmit!\n\t */\n\teop->d_flag |= TULIP_DFLAG_TxLASTSEG | TULIP_DFLAG_TxWANTINTR;\n\n\t/*\n\t * Note that ri->ri_nextout is still the start of the packet\n\t * and until we set the OWNER bit, we can still back out of\n\t * everything we have done.\n\t */\n\tri->ri_nextout->d_flag |= TULIP_DFLAG_TxFIRSTSEG;\n\tri->ri_nextout->d_status = TULIP_DSTS_OWNER;\n\n\tLMC_CSR_WRITE(sc, csr_txpoll, 1);\n\n\t/*\n\t * This advances the ring for us.\n\t */\n\tri->ri_nextout = nextout;\n\tri->ri_free = free;\n\n\t/*\n\t * switch back to the single queueing ifstart.\n\t */\n\tsc->lmc_flags &= ~LMC_WANTTXSTART;\n\tsc->lmc_if.if_start = lmc_ifstart_one;\n\n\t/*\n\t * If we want a txstart, there must be not enough space in the\n\t * transmit ring.  So we want to enable transmit done interrupts\n\t * so we can immediately reclaim some space.  When the transmit\n\t * interrupt is posted, the interrupt handler will call tx_intr\n\t * to reclaim space and then txstart (since WANTTXSTART is set).\n\t * txstart will move the packet into the transmit ring and clear\n\t * WANTTXSTART thereby causing TXINTR to be cleared.\n\t */\n finish:\n\tif (sc->lmc_flags & LMC_WANTTXSTART) {\n\t\tsc->lmc_if.if_flags |= IFF_OACTIVE;\n\t\tsc->lmc_if.if_start = lmc_ifstart;\n\t}\n\n\treturn m;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sppp_dequeue",
          "args": [
            "ifp"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sppp_isempty",
          "args": [
            "ifp"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_IFP_TO_SOFTC",
          "args": [
            "ifp"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);\nstatic ifnet_ret_t lmc_ifstart(struct ifnet *ifp);\nstatic struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic ifnet_ret_t\nlmc_ifstart_one(struct ifnet * const ifp)\n{\n\tlmc_softc_t * const sc = LMC_IFP_TO_SOFTC(ifp);\n\tstruct mbuf *m;\n\n\tif ((sc->lmc_flags & LMC_IFUP) && (sppp_isempty(ifp) == 0)) {\n\t\tm = sppp_dequeue(ifp);\n\t\tif ((m = lmc_txput(sc, m)) != NULL) {\n\t\t\tIF_PREPEND(&((struct sppp *)ifp)->pp_fastq, m);\n\t\t}\n\t\tLMC_CSR_WRITE(sc, csr_txpoll, 1);\n\t}\n}"
  },
  {
    "function_name": "lmc_ifstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "1285-1301",
    "snippet": "static ifnet_ret_t\nlmc_ifstart(struct ifnet * const ifp)\n{\n\tlmc_softc_t * const sc = LMC_IFP_TO_SOFTC(ifp);\n\tstruct mbuf *m;\n\n\tif (sc->lmc_flags & LMC_IFUP) {\n\t\twhile (sppp_isempty(ifp) == 0) {\n\t\t\tm = sppp_dequeue(ifp);\n\t\t\tif ((m = lmc_txput(sc, m)) != NULL) {\n\t\t\t\tIF_PREPEND(&((struct sppp *)ifp)->pp_fastq, m);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tLMC_CSR_WRITE(sc, csr_txpoll, 1);\n\t}\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);",
      "static ifnet_ret_t lmc_ifstart(struct ifnet *ifp);",
      "static struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);",
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LMC_CSR_WRITE",
          "args": [
            "sc",
            "csr_txpoll",
            "1"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_PREPEND",
          "args": [
            "&((struct sppp *)ifp)->pp_fastq",
            "m"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmc_txput",
          "args": [
            "sc",
            "m"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_txput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "1004-1185",
          "snippet": "static struct mbuf *\nlmc_txput(lmc_softc_t * const sc, struct mbuf *m)\n{\n\tlmc_ringinfo_t * const ri = &sc->lmc_txinfo;\n\ttulip_desc_t *eop, *nextout;\n\tint segcnt, free;\n\tu_int32_t d_status;\n\tstruct mbuf *m0;\n\n#if defined(LMC_DEBUG)\n\tif ((sc->lmc_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\t\tprintf(LMC_PRINTF_FMT \": txput: tx not running\\n\",\n\t\t       LMC_PRINTF_ARGS);\n\t\tsc->lmc_flags |= LMC_WANTTXSTART;\n\t\tgoto finish;\n\t}\n#endif\n\n\t/*\n\t * Now we try to fill in our transmit descriptors.  This is\n\t * a bit reminiscent of going on the Ark two by two\n\t * since each descriptor for the TULIP can describe\n\t * two buffers.  So we advance through packet filling\n\t * each of the two entries at a time to fill each\n\t * descriptor.  Clear the first and last segment bits\n\t * in each descriptor (actually just clear everything\n\t * but the end-of-ring or chain bits) to make sure\n\t * we don't get messed up by previously sent packets.\n\t *\n\t * We may fail to put the entire packet on the ring if\n\t * there is either not enough ring entries free or if the\n\t * packet has more than MAX_TXSEG segments.  In the former\n\t * case we will just wait for the ring to empty.  In the\n\t * latter case we have to recopy.\n\t */\n again:\n\td_status = 0;\n\teop = nextout = ri->ri_nextout;\n\tm0 = m;\n\tsegcnt = 0;\n\tfree = ri->ri_free;\n\tdo {\n\t\tint len = m0->m_len;\n\t\tcaddr_t addr = mtod(m0, caddr_t);\n\t\tunsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));\n\n\t\twhile (len > 0) {\n\t\t\tunsigned slen = min(len, clsize);\n#ifdef BIG_PACKET\n\t\t\tint partial = 0;\n\t\t\tif (slen >= 2048)\n\t\t\t\tslen = 2040, partial = 1;\n#endif\n\t\t\tsegcnt++;\n\t\t\tif (segcnt > LMC_MAX_TXSEG) {\n\t\t\t\t/*\n\t\t\t\t * The packet exceeds the number of transmit\n\t\t\t\t * buffer entries that we can use for one\n\t\t\t\t * packet, so we have recopy it into one mbuf\n\t\t\t\t * and then try again.\n\t\t\t\t */\n\t\t\t\tm = lmc_mbuf_compress(m);\n\t\t\t\tif (m == NULL)\n\t\t\t\t\tgoto finish;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (segcnt & 1) {\n\t\t\t\tif (--free == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * See if there's any unclaimed space\n\t\t\t\t\t * in the transmit ring.\n\t\t\t\t\t */\n\t\t\t\t\tif ((free += lmc_tx_intr(sc)) == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * There's no more room but\n\t\t\t\t\t\t * since nothing has been\n\t\t\t\t\t\t * committed at this point,\n\t\t\t\t\t\t * just show output is active,\n\t\t\t\t\t\t * put back the mbuf and\n\t\t\t\t\t\t * return.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tsc->lmc_flags |= LMC_WANTTXSTART;\n\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\teop = nextout;\n\t\t\t\tif (++nextout == ri->ri_last)\n\t\t\t\t\tnextout = ri->ri_first;\n\t\t\t\teop->d_flag &= TULIP_DFLAG_ENDRING;\n\t\t\t\teop->d_flag |= TULIP_DFLAG_TxNOPADDING;\n\t\t\t\tif (sc->ictl.crc_length == 16)\n\t\t\t\t\teop->d_flag |= TULIP_DFLAG_TxHASCRC;\n\t\t\t\teop->d_status = d_status;\n\t\t\t\teop->d_addr1 = LMC_KVATOPHYS(sc, addr);\n\t\t\t\teop->d_length1 = slen;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t *  Fill in second half of descriptor\n\t\t\t\t */\n\t\t\t\teop->d_addr2 = LMC_KVATOPHYS(sc, addr);\n\t\t\t\teop->d_length2 = slen;\n\t\t\t}\n\t\t\td_status = TULIP_DSTS_OWNER;\n\t\t\tlen -= slen;\n\t\t\taddr += slen;\n#ifdef BIG_PACKET\n\t\t\tif (partial)\n\t\t\t\tcontinue;\n#endif\n\t\t\tclsize = CLBYTES;\n\t\t}\n\t} while ((m0 = m0->m_next) != NULL);\n\n\n\t/*\n\t * The descriptors have been filled in.  Now get ready\n\t * to transmit.\n\t */\n\tIF_ENQUEUE(&sc->lmc_txq, m);\n\tm = NULL;\n\n\t/*\n\t * Make sure the next descriptor after this packet is owned\n\t * by us since it may have been set up above if we ran out\n\t * of room in the ring.\n\t */\n\tnextout->d_status = 0;\n\n\t/*\n\t * If we only used the first segment of the last descriptor,\n\t * make sure the second segment will not be used.\n\t */\n\tif (segcnt & 1) {\n\t\teop->d_addr2 = 0;\n\t\teop->d_length2 = 0;\n\t}\n\n\t/*\n\t * Mark the last and first segments, indicate we want a transmit\n\t * complete interrupt, and tell it to transmit!\n\t */\n\teop->d_flag |= TULIP_DFLAG_TxLASTSEG | TULIP_DFLAG_TxWANTINTR;\n\n\t/*\n\t * Note that ri->ri_nextout is still the start of the packet\n\t * and until we set the OWNER bit, we can still back out of\n\t * everything we have done.\n\t */\n\tri->ri_nextout->d_flag |= TULIP_DFLAG_TxFIRSTSEG;\n\tri->ri_nextout->d_status = TULIP_DSTS_OWNER;\n\n\tLMC_CSR_WRITE(sc, csr_txpoll, 1);\n\n\t/*\n\t * This advances the ring for us.\n\t */\n\tri->ri_nextout = nextout;\n\tri->ri_free = free;\n\n\t/*\n\t * switch back to the single queueing ifstart.\n\t */\n\tsc->lmc_flags &= ~LMC_WANTTXSTART;\n\tsc->lmc_if.if_start = lmc_ifstart_one;\n\n\t/*\n\t * If we want a txstart, there must be not enough space in the\n\t * transmit ring.  So we want to enable transmit done interrupts\n\t * so we can immediately reclaim some space.  When the transmit\n\t * interrupt is posted, the interrupt handler will call tx_intr\n\t * to reclaim space and then txstart (since WANTTXSTART is set).\n\t * txstart will move the packet into the transmit ring and clear\n\t * WANTTXSTART thereby causing TXINTR to be cleared.\n\t */\n finish:\n\tif (sc->lmc_flags & LMC_WANTTXSTART) {\n\t\tsc->lmc_if.if_flags |= IFF_OACTIVE;\n\t\tsc->lmc_if.if_start = lmc_ifstart;\n\t}\n\n\treturn m;\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define d_flag u.bd_flag",
            "#define d_length2 u.bd_length2",
            "#define d_length1 u.bd_length1"
          ],
          "globals_used": [
            "static struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);",
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define d_flag u.bd_flag\n#define d_length2 u.bd_length2\n#define d_length1 u.bd_length1\n\nstatic struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic struct mbuf *\nlmc_txput(lmc_softc_t * const sc, struct mbuf *m)\n{\n\tlmc_ringinfo_t * const ri = &sc->lmc_txinfo;\n\ttulip_desc_t *eop, *nextout;\n\tint segcnt, free;\n\tu_int32_t d_status;\n\tstruct mbuf *m0;\n\n#if defined(LMC_DEBUG)\n\tif ((sc->lmc_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\t\tprintf(LMC_PRINTF_FMT \": txput: tx not running\\n\",\n\t\t       LMC_PRINTF_ARGS);\n\t\tsc->lmc_flags |= LMC_WANTTXSTART;\n\t\tgoto finish;\n\t}\n#endif\n\n\t/*\n\t * Now we try to fill in our transmit descriptors.  This is\n\t * a bit reminiscent of going on the Ark two by two\n\t * since each descriptor for the TULIP can describe\n\t * two buffers.  So we advance through packet filling\n\t * each of the two entries at a time to fill each\n\t * descriptor.  Clear the first and last segment bits\n\t * in each descriptor (actually just clear everything\n\t * but the end-of-ring or chain bits) to make sure\n\t * we don't get messed up by previously sent packets.\n\t *\n\t * We may fail to put the entire packet on the ring if\n\t * there is either not enough ring entries free or if the\n\t * packet has more than MAX_TXSEG segments.  In the former\n\t * case we will just wait for the ring to empty.  In the\n\t * latter case we have to recopy.\n\t */\n again:\n\td_status = 0;\n\teop = nextout = ri->ri_nextout;\n\tm0 = m;\n\tsegcnt = 0;\n\tfree = ri->ri_free;\n\tdo {\n\t\tint len = m0->m_len;\n\t\tcaddr_t addr = mtod(m0, caddr_t);\n\t\tunsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));\n\n\t\twhile (len > 0) {\n\t\t\tunsigned slen = min(len, clsize);\n#ifdef BIG_PACKET\n\t\t\tint partial = 0;\n\t\t\tif (slen >= 2048)\n\t\t\t\tslen = 2040, partial = 1;\n#endif\n\t\t\tsegcnt++;\n\t\t\tif (segcnt > LMC_MAX_TXSEG) {\n\t\t\t\t/*\n\t\t\t\t * The packet exceeds the number of transmit\n\t\t\t\t * buffer entries that we can use for one\n\t\t\t\t * packet, so we have recopy it into one mbuf\n\t\t\t\t * and then try again.\n\t\t\t\t */\n\t\t\t\tm = lmc_mbuf_compress(m);\n\t\t\t\tif (m == NULL)\n\t\t\t\t\tgoto finish;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (segcnt & 1) {\n\t\t\t\tif (--free == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * See if there's any unclaimed space\n\t\t\t\t\t * in the transmit ring.\n\t\t\t\t\t */\n\t\t\t\t\tif ((free += lmc_tx_intr(sc)) == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * There's no more room but\n\t\t\t\t\t\t * since nothing has been\n\t\t\t\t\t\t * committed at this point,\n\t\t\t\t\t\t * just show output is active,\n\t\t\t\t\t\t * put back the mbuf and\n\t\t\t\t\t\t * return.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tsc->lmc_flags |= LMC_WANTTXSTART;\n\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\teop = nextout;\n\t\t\t\tif (++nextout == ri->ri_last)\n\t\t\t\t\tnextout = ri->ri_first;\n\t\t\t\teop->d_flag &= TULIP_DFLAG_ENDRING;\n\t\t\t\teop->d_flag |= TULIP_DFLAG_TxNOPADDING;\n\t\t\t\tif (sc->ictl.crc_length == 16)\n\t\t\t\t\teop->d_flag |= TULIP_DFLAG_TxHASCRC;\n\t\t\t\teop->d_status = d_status;\n\t\t\t\teop->d_addr1 = LMC_KVATOPHYS(sc, addr);\n\t\t\t\teop->d_length1 = slen;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t *  Fill in second half of descriptor\n\t\t\t\t */\n\t\t\t\teop->d_addr2 = LMC_KVATOPHYS(sc, addr);\n\t\t\t\teop->d_length2 = slen;\n\t\t\t}\n\t\t\td_status = TULIP_DSTS_OWNER;\n\t\t\tlen -= slen;\n\t\t\taddr += slen;\n#ifdef BIG_PACKET\n\t\t\tif (partial)\n\t\t\t\tcontinue;\n#endif\n\t\t\tclsize = CLBYTES;\n\t\t}\n\t} while ((m0 = m0->m_next) != NULL);\n\n\n\t/*\n\t * The descriptors have been filled in.  Now get ready\n\t * to transmit.\n\t */\n\tIF_ENQUEUE(&sc->lmc_txq, m);\n\tm = NULL;\n\n\t/*\n\t * Make sure the next descriptor after this packet is owned\n\t * by us since it may have been set up above if we ran out\n\t * of room in the ring.\n\t */\n\tnextout->d_status = 0;\n\n\t/*\n\t * If we only used the first segment of the last descriptor,\n\t * make sure the second segment will not be used.\n\t */\n\tif (segcnt & 1) {\n\t\teop->d_addr2 = 0;\n\t\teop->d_length2 = 0;\n\t}\n\n\t/*\n\t * Mark the last and first segments, indicate we want a transmit\n\t * complete interrupt, and tell it to transmit!\n\t */\n\teop->d_flag |= TULIP_DFLAG_TxLASTSEG | TULIP_DFLAG_TxWANTINTR;\n\n\t/*\n\t * Note that ri->ri_nextout is still the start of the packet\n\t * and until we set the OWNER bit, we can still back out of\n\t * everything we have done.\n\t */\n\tri->ri_nextout->d_flag |= TULIP_DFLAG_TxFIRSTSEG;\n\tri->ri_nextout->d_status = TULIP_DSTS_OWNER;\n\n\tLMC_CSR_WRITE(sc, csr_txpoll, 1);\n\n\t/*\n\t * This advances the ring for us.\n\t */\n\tri->ri_nextout = nextout;\n\tri->ri_free = free;\n\n\t/*\n\t * switch back to the single queueing ifstart.\n\t */\n\tsc->lmc_flags &= ~LMC_WANTTXSTART;\n\tsc->lmc_if.if_start = lmc_ifstart_one;\n\n\t/*\n\t * If we want a txstart, there must be not enough space in the\n\t * transmit ring.  So we want to enable transmit done interrupts\n\t * so we can immediately reclaim some space.  When the transmit\n\t * interrupt is posted, the interrupt handler will call tx_intr\n\t * to reclaim space and then txstart (since WANTTXSTART is set).\n\t * txstart will move the packet into the transmit ring and clear\n\t * WANTTXSTART thereby causing TXINTR to be cleared.\n\t */\n finish:\n\tif (sc->lmc_flags & LMC_WANTTXSTART) {\n\t\tsc->lmc_if.if_flags |= IFF_OACTIVE;\n\t\tsc->lmc_if.if_start = lmc_ifstart;\n\t}\n\n\treturn m;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sppp_dequeue",
          "args": [
            "ifp"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sppp_isempty",
          "args": [
            "ifp"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_IFP_TO_SOFTC",
          "args": [
            "ifp"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);\nstatic ifnet_ret_t lmc_ifstart(struct ifnet *ifp);\nstatic struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic ifnet_ret_t\nlmc_ifstart(struct ifnet * const ifp)\n{\n\tlmc_softc_t * const sc = LMC_IFP_TO_SOFTC(ifp);\n\tstruct mbuf *m;\n\n\tif (sc->lmc_flags & LMC_IFUP) {\n\t\twhile (sppp_isempty(ifp) == 0) {\n\t\t\tm = sppp_dequeue(ifp);\n\t\t\tif ((m = lmc_txput(sc, m)) != NULL) {\n\t\t\t\tIF_PREPEND(&((struct sppp *)ifp)->pp_fastq, m);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tLMC_CSR_WRITE(sc, csr_txpoll, 1);\n\t}\n}"
  },
  {
    "function_name": "lmc_ifioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "1191-1278",
    "snippet": "static int\nlmc_ifioctl(struct ifnet * ifp, ioctl_cmd_t cmd, caddr_t data)\n{\n\tlmc_softc_t * const sc = LMC_IFP_TO_SOFTC(ifp);\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\tlmc_spl_t s;\n#endif\n\tstruct proc *p = curproc;\n\tint error = 0;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tu_int32_t new_state;\n\tu_int32_t old_state;\n\tlmc_ctl_t ctl;\n\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\ts = LMC_RAISESPL();\n#endif\n\n\tswitch (cmd) {\n\tcase LMCIOCGINFO:\n\t\terror = copyout(&sc->ictl, ifr->ifr_data, sizeof(lmc_ctl_t));\n\n\t\tgoto out;\n\t\tbreak;\n\n\tcase LMCIOCSINFO:\n\t\terror = suser(p->p_ucred, &p->p_acflag);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = copyin(ifr->ifr_data, &ctl, sizeof(lmc_ctl_t));\n\t\tif (error != 0)\n\t\t\tgoto out;\n\n\t\tsc->lmc_media->set_status(sc, &ctl);\n\n\t\tgoto out;\n\t\tbreak;\n\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\tcase SIOCSIFMTU:\n\t\t/*\n\t\t * Don't allow the MTU to get larger than we can handle\n\t\t */\n\t\tif (ifr->ifr_mtu > LMC_MTU) {\n\t\t\terror = EINVAL;\n\t\t\tgoto out;\n\t\t} else {\n                        ifp->if_mtu = ifr->ifr_mtu;\n\t\t}\n\t\tbreak;\n#endif\n\t}\n\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\t/*\n\t * call the sppp ioctl layer\n\t */\n\terror = sppp_ioctl(ifp, cmd, data);\n\tif (error != 0)\n\t\tgoto out;\n#endif\n\n#if defined(__bsdi__)\n\terror = p2p_ioctl(ifp, cmd, data);\n#endif\n\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\t/*\n\t * If we are transitioning from up to down or down to up, call\n\t * our init routine.\n\t */\n\tnew_state = ifp->if_flags & IFF_UP;\n\told_state = sc->lmc_flags & LMC_IFUP;\n\n\tif (new_state && !old_state)\n\t\tlmc_ifup(sc);\n\telse if (!new_state && old_state)\n\t\tlmc_ifdown(sc);\n#endif\n\n out:\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\tLMC_RESTORESPL(s);\n#endif\n\n\treturn error;\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);",
      "static ifnet_ret_t lmc_ifstart(struct ifnet *ifp);",
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LMC_RESTORESPL",
          "args": [
            "s"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmc_ifdown",
          "args": [
            "sc"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_ifdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "577-589",
          "snippet": "static void\nlmc_ifdown(lmc_softc_t * const sc)\n{\n\tsc->lmc_if.if_timer = 0;\n\tsc->lmc_flags &= ~LMC_IFUP;\n\n\tsc->lmc_media->set_link_status(sc, LMC_LINK_DOWN);\n\tlmc_led_off(sc, LMC_MII16_LED_ALL);\n\n\tlmc_dec_reset(sc);\n\tlmc_reset(sc);\n\tsc->lmc_media->set_status(sc, NULL);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic void\nlmc_ifdown(lmc_softc_t * const sc)\n{\n\tsc->lmc_if.if_timer = 0;\n\tsc->lmc_flags &= ~LMC_IFUP;\n\n\tsc->lmc_media->set_link_status(sc, LMC_LINK_DOWN);\n\tlmc_led_off(sc, LMC_MII16_LED_ALL);\n\n\tlmc_dec_reset(sc);\n\tlmc_reset(sc);\n\tsc->lmc_media->set_status(sc, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmc_ifup",
          "args": [
            "sc"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_ifup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "530-571",
          "snippet": "static void\nlmc_ifup(lmc_softc_t * const sc)\n{\n\tsc->lmc_if.if_timer = 0;\n\n\tlmc_dec_reset(sc);\n\tlmc_reset(sc);\n\n\tsc->lmc_media->set_link_status(sc, LMC_LINK_UP);\n\tsc->lmc_media->set_status(sc, NULL);\n\n\tsc->lmc_flags |= LMC_IFUP;\n\n\t/*\n\t * for DS3 & DS1 adapters light the green light, led2\n\t */\n\tif (sc->lmc_cardtype == LMC_CARDTYPE_DS3 ||\n\t    sc->lmc_cardtype == LMC_CARDTYPE_T1)\n\t\tlmc_led_on (sc, LMC_MII16_LED2);\n\telse\n\t\tlmc_led_on (sc, LMC_MII16_LED0 | LMC_MII16_LED2);\n\n\t/*\n\t * select what interrupts we want to get\n\t */\n\tsc->lmc_intrmask |= (TULIP_STS_NORMALINTR\n\t\t\t       | TULIP_STS_RXINTR\n\t\t\t       | TULIP_STS_TXINTR\n\t\t\t       | TULIP_STS_ABNRMLINTR\n\t\t\t       | TULIP_STS_SYSERROR\n\t\t\t       | TULIP_STS_TXSTOPPED\n\t\t\t       | TULIP_STS_TXUNDERFLOW\n\t\t\t       | TULIP_STS_RXSTOPPED\n\t\t\t       );\n\tLMC_CSR_WRITE(sc, csr_intr, sc->lmc_intrmask);\n\n\tsc->lmc_cmdmode |= TULIP_CMD_TXRUN;\n\tsc->lmc_cmdmode |= TULIP_CMD_RXRUN;\n\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\n\tsc->lmc_if.if_timer = 1;\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic void\nlmc_ifup(lmc_softc_t * const sc)\n{\n\tsc->lmc_if.if_timer = 0;\n\n\tlmc_dec_reset(sc);\n\tlmc_reset(sc);\n\n\tsc->lmc_media->set_link_status(sc, LMC_LINK_UP);\n\tsc->lmc_media->set_status(sc, NULL);\n\n\tsc->lmc_flags |= LMC_IFUP;\n\n\t/*\n\t * for DS3 & DS1 adapters light the green light, led2\n\t */\n\tif (sc->lmc_cardtype == LMC_CARDTYPE_DS3 ||\n\t    sc->lmc_cardtype == LMC_CARDTYPE_T1)\n\t\tlmc_led_on (sc, LMC_MII16_LED2);\n\telse\n\t\tlmc_led_on (sc, LMC_MII16_LED0 | LMC_MII16_LED2);\n\n\t/*\n\t * select what interrupts we want to get\n\t */\n\tsc->lmc_intrmask |= (TULIP_STS_NORMALINTR\n\t\t\t       | TULIP_STS_RXINTR\n\t\t\t       | TULIP_STS_TXINTR\n\t\t\t       | TULIP_STS_ABNRMLINTR\n\t\t\t       | TULIP_STS_SYSERROR\n\t\t\t       | TULIP_STS_TXSTOPPED\n\t\t\t       | TULIP_STS_TXUNDERFLOW\n\t\t\t       | TULIP_STS_RXSTOPPED\n\t\t\t       );\n\tLMC_CSR_WRITE(sc, csr_intr, sc->lmc_intrmask);\n\n\tsc->lmc_cmdmode |= TULIP_CMD_TXRUN;\n\tsc->lmc_cmdmode |= TULIP_CMD_RXRUN;\n\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\n\tsc->lmc_if.if_timer = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p2p_ioctl",
          "args": [
            "ifp",
            "cmd",
            "data"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sppp_ioctl",
          "args": [
            "ifp",
            "cmd",
            "data"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->lmc_media->set_status",
          "args": [
            "sc",
            "&ctl"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyin",
          "args": [
            "ifr->ifr_data",
            "&ctl",
            "sizeof(lmc_ctl_t)"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suser",
          "args": [
            "p->p_ucred",
            "&p->p_acflag"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyout",
          "args": [
            "&sc->ictl",
            "ifr->ifr_data",
            "sizeof(lmc_ctl_t)"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "audio_silence_copyout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1249-1268",
          "snippet": "int\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LMC_RAISESPL",
          "args": [],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_IFP_TO_SOFTC",
          "args": [
            "ifp"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);\nstatic ifnet_ret_t lmc_ifstart(struct ifnet *ifp);\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic int\nlmc_ifioctl(struct ifnet * ifp, ioctl_cmd_t cmd, caddr_t data)\n{\n\tlmc_softc_t * const sc = LMC_IFP_TO_SOFTC(ifp);\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\tlmc_spl_t s;\n#endif\n\tstruct proc *p = curproc;\n\tint error = 0;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tu_int32_t new_state;\n\tu_int32_t old_state;\n\tlmc_ctl_t ctl;\n\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\ts = LMC_RAISESPL();\n#endif\n\n\tswitch (cmd) {\n\tcase LMCIOCGINFO:\n\t\terror = copyout(&sc->ictl, ifr->ifr_data, sizeof(lmc_ctl_t));\n\n\t\tgoto out;\n\t\tbreak;\n\n\tcase LMCIOCSINFO:\n\t\terror = suser(p->p_ucred, &p->p_acflag);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = copyin(ifr->ifr_data, &ctl, sizeof(lmc_ctl_t));\n\t\tif (error != 0)\n\t\t\tgoto out;\n\n\t\tsc->lmc_media->set_status(sc, &ctl);\n\n\t\tgoto out;\n\t\tbreak;\n\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\tcase SIOCSIFMTU:\n\t\t/*\n\t\t * Don't allow the MTU to get larger than we can handle\n\t\t */\n\t\tif (ifr->ifr_mtu > LMC_MTU) {\n\t\t\terror = EINVAL;\n\t\t\tgoto out;\n\t\t} else {\n                        ifp->if_mtu = ifr->ifr_mtu;\n\t\t}\n\t\tbreak;\n#endif\n\t}\n\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\t/*\n\t * call the sppp ioctl layer\n\t */\n\terror = sppp_ioctl(ifp, cmd, data);\n\tif (error != 0)\n\t\tgoto out;\n#endif\n\n#if defined(__bsdi__)\n\terror = p2p_ioctl(ifp, cmd, data);\n#endif\n\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\t/*\n\t * If we are transitioning from up to down or down to up, call\n\t * our init routine.\n\t */\n\tnew_state = ifp->if_flags & IFF_UP;\n\told_state = sc->lmc_flags & LMC_IFUP;\n\n\tif (new_state && !old_state)\n\t\tlmc_ifup(sc);\n\telse if (!new_state && old_state)\n\t\tlmc_ifdown(sc);\n#endif\n\n out:\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\tLMC_RESTORESPL(s);\n#endif\n\n\treturn error;\n}"
  },
  {
    "function_name": "lmc_txput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "1004-1185",
    "snippet": "static struct mbuf *\nlmc_txput(lmc_softc_t * const sc, struct mbuf *m)\n{\n\tlmc_ringinfo_t * const ri = &sc->lmc_txinfo;\n\ttulip_desc_t *eop, *nextout;\n\tint segcnt, free;\n\tu_int32_t d_status;\n\tstruct mbuf *m0;\n\n#if defined(LMC_DEBUG)\n\tif ((sc->lmc_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\t\tprintf(LMC_PRINTF_FMT \": txput: tx not running\\n\",\n\t\t       LMC_PRINTF_ARGS);\n\t\tsc->lmc_flags |= LMC_WANTTXSTART;\n\t\tgoto finish;\n\t}\n#endif\n\n\t/*\n\t * Now we try to fill in our transmit descriptors.  This is\n\t * a bit reminiscent of going on the Ark two by two\n\t * since each descriptor for the TULIP can describe\n\t * two buffers.  So we advance through packet filling\n\t * each of the two entries at a time to fill each\n\t * descriptor.  Clear the first and last segment bits\n\t * in each descriptor (actually just clear everything\n\t * but the end-of-ring or chain bits) to make sure\n\t * we don't get messed up by previously sent packets.\n\t *\n\t * We may fail to put the entire packet on the ring if\n\t * there is either not enough ring entries free or if the\n\t * packet has more than MAX_TXSEG segments.  In the former\n\t * case we will just wait for the ring to empty.  In the\n\t * latter case we have to recopy.\n\t */\n again:\n\td_status = 0;\n\teop = nextout = ri->ri_nextout;\n\tm0 = m;\n\tsegcnt = 0;\n\tfree = ri->ri_free;\n\tdo {\n\t\tint len = m0->m_len;\n\t\tcaddr_t addr = mtod(m0, caddr_t);\n\t\tunsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));\n\n\t\twhile (len > 0) {\n\t\t\tunsigned slen = min(len, clsize);\n#ifdef BIG_PACKET\n\t\t\tint partial = 0;\n\t\t\tif (slen >= 2048)\n\t\t\t\tslen = 2040, partial = 1;\n#endif\n\t\t\tsegcnt++;\n\t\t\tif (segcnt > LMC_MAX_TXSEG) {\n\t\t\t\t/*\n\t\t\t\t * The packet exceeds the number of transmit\n\t\t\t\t * buffer entries that we can use for one\n\t\t\t\t * packet, so we have recopy it into one mbuf\n\t\t\t\t * and then try again.\n\t\t\t\t */\n\t\t\t\tm = lmc_mbuf_compress(m);\n\t\t\t\tif (m == NULL)\n\t\t\t\t\tgoto finish;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (segcnt & 1) {\n\t\t\t\tif (--free == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * See if there's any unclaimed space\n\t\t\t\t\t * in the transmit ring.\n\t\t\t\t\t */\n\t\t\t\t\tif ((free += lmc_tx_intr(sc)) == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * There's no more room but\n\t\t\t\t\t\t * since nothing has been\n\t\t\t\t\t\t * committed at this point,\n\t\t\t\t\t\t * just show output is active,\n\t\t\t\t\t\t * put back the mbuf and\n\t\t\t\t\t\t * return.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tsc->lmc_flags |= LMC_WANTTXSTART;\n\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\teop = nextout;\n\t\t\t\tif (++nextout == ri->ri_last)\n\t\t\t\t\tnextout = ri->ri_first;\n\t\t\t\teop->d_flag &= TULIP_DFLAG_ENDRING;\n\t\t\t\teop->d_flag |= TULIP_DFLAG_TxNOPADDING;\n\t\t\t\tif (sc->ictl.crc_length == 16)\n\t\t\t\t\teop->d_flag |= TULIP_DFLAG_TxHASCRC;\n\t\t\t\teop->d_status = d_status;\n\t\t\t\teop->d_addr1 = LMC_KVATOPHYS(sc, addr);\n\t\t\t\teop->d_length1 = slen;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t *  Fill in second half of descriptor\n\t\t\t\t */\n\t\t\t\teop->d_addr2 = LMC_KVATOPHYS(sc, addr);\n\t\t\t\teop->d_length2 = slen;\n\t\t\t}\n\t\t\td_status = TULIP_DSTS_OWNER;\n\t\t\tlen -= slen;\n\t\t\taddr += slen;\n#ifdef BIG_PACKET\n\t\t\tif (partial)\n\t\t\t\tcontinue;\n#endif\n\t\t\tclsize = CLBYTES;\n\t\t}\n\t} while ((m0 = m0->m_next) != NULL);\n\n\n\t/*\n\t * The descriptors have been filled in.  Now get ready\n\t * to transmit.\n\t */\n\tIF_ENQUEUE(&sc->lmc_txq, m);\n\tm = NULL;\n\n\t/*\n\t * Make sure the next descriptor after this packet is owned\n\t * by us since it may have been set up above if we ran out\n\t * of room in the ring.\n\t */\n\tnextout->d_status = 0;\n\n\t/*\n\t * If we only used the first segment of the last descriptor,\n\t * make sure the second segment will not be used.\n\t */\n\tif (segcnt & 1) {\n\t\teop->d_addr2 = 0;\n\t\teop->d_length2 = 0;\n\t}\n\n\t/*\n\t * Mark the last and first segments, indicate we want a transmit\n\t * complete interrupt, and tell it to transmit!\n\t */\n\teop->d_flag |= TULIP_DFLAG_TxLASTSEG | TULIP_DFLAG_TxWANTINTR;\n\n\t/*\n\t * Note that ri->ri_nextout is still the start of the packet\n\t * and until we set the OWNER bit, we can still back out of\n\t * everything we have done.\n\t */\n\tri->ri_nextout->d_flag |= TULIP_DFLAG_TxFIRSTSEG;\n\tri->ri_nextout->d_status = TULIP_DSTS_OWNER;\n\n\tLMC_CSR_WRITE(sc, csr_txpoll, 1);\n\n\t/*\n\t * This advances the ring for us.\n\t */\n\tri->ri_nextout = nextout;\n\tri->ri_free = free;\n\n\t/*\n\t * switch back to the single queueing ifstart.\n\t */\n\tsc->lmc_flags &= ~LMC_WANTTXSTART;\n\tsc->lmc_if.if_start = lmc_ifstart_one;\n\n\t/*\n\t * If we want a txstart, there must be not enough space in the\n\t * transmit ring.  So we want to enable transmit done interrupts\n\t * so we can immediately reclaim some space.  When the transmit\n\t * interrupt is posted, the interrupt handler will call tx_intr\n\t * to reclaim space and then txstart (since WANTTXSTART is set).\n\t * txstart will move the packet into the transmit ring and clear\n\t * WANTTXSTART thereby causing TXINTR to be cleared.\n\t */\n finish:\n\tif (sc->lmc_flags & LMC_WANTTXSTART) {\n\t\tsc->lmc_if.if_flags |= IFF_OACTIVE;\n\t\tsc->lmc_if.if_start = lmc_ifstart;\n\t}\n\n\treturn m;\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define d_flag u.bd_flag",
      "#define d_length2 u.bd_length2",
      "#define d_length1 u.bd_length1"
    ],
    "globals_used": [
      "static struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);",
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LMC_CSR_WRITE",
          "args": [
            "sc",
            "csr_txpoll",
            "1"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_ENQUEUE",
          "args": [
            "&sc->lmc_txq",
            "m"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_KVATOPHYS",
          "args": [
            "sc",
            "addr"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_KVATOPHYS",
          "args": [
            "sc",
            "addr"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmc_tx_intr",
          "args": [
            "sc"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmc_mbuf_compress",
          "args": [
            "m"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_mbuf_compress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "944-998",
          "snippet": "static struct mbuf *\nlmc_mbuf_compress(struct mbuf *m)\n{\n\tstruct mbuf *m0;\n#if MCLBYTES >= LMC_MTU + PPP_HEADER_LEN && !defined(BIG_PACKET)\n\tMGETHDR(m0, M_DONTWAIT, MT_DATA);\n\tif (m0 != NULL) {\n\t\tif (m->m_pkthdr.len > MHLEN) {\n\t\t\tMCLGET(m0, M_DONTWAIT);\n\t\t\tif ((m0->m_flags & M_EXT) == 0) {\n\t\t\t\tm_freem(m);\n\t\t\t\tm_freem(m0);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tm_copydata(m, 0, m->m_pkthdr.len, mtod(m0, caddr_t));\n\t\tm0->m_pkthdr.len = m0->m_len = m->m_pkthdr.len;\n\t}\n#else\n\tint mlen = MHLEN;\n\tint len = m->m_pkthdr.len;\n\tstruct mbuf **mp = &m0;\n\n\twhile (len > 0) {\n\t\tif (mlen == MHLEN) {\n\t\t\tMGETHDR(*mp, M_DONTWAIT, MT_DATA);\n\t\t} else {\n\t\t\tMGET(*mp, M_DONTWAIT, MT_DATA);\n\t\t}\n\t\tif (*mp == NULL) {\n\t\t\tm_freem(m0);\n\t\t\tm0 = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (len > MLEN) {\n\t\t\tMCLGET(*mp, M_DONTWAIT);\n\t\t\tif (((*mp)->m_flags & M_EXT) == 0) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tm0 = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(*mp)->m_len = (len <= MCLBYTES ? len : MCLBYTES);\n\t\t} else {\n\t\t\t(*mp)->m_len = (len <= mlen ? len : mlen);\n\t\t}\n\t\tm_copydata(m, m->m_pkthdr.len - len,\n\t\t\t   (*mp)->m_len, mtod((*mp), caddr_t));\n\t\tlen -= (*mp)->m_len;\n\t\tmp = &(*mp)->m_next;\n\t\tmlen = MLEN;\n\t}\n#endif\n\tm_freem(m);\n\treturn m0;\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);\n\nstatic struct mbuf *\nlmc_mbuf_compress(struct mbuf *m)\n{\n\tstruct mbuf *m0;\n#if MCLBYTES >= LMC_MTU + PPP_HEADER_LEN && !defined(BIG_PACKET)\n\tMGETHDR(m0, M_DONTWAIT, MT_DATA);\n\tif (m0 != NULL) {\n\t\tif (m->m_pkthdr.len > MHLEN) {\n\t\t\tMCLGET(m0, M_DONTWAIT);\n\t\t\tif ((m0->m_flags & M_EXT) == 0) {\n\t\t\t\tm_freem(m);\n\t\t\t\tm_freem(m0);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tm_copydata(m, 0, m->m_pkthdr.len, mtod(m0, caddr_t));\n\t\tm0->m_pkthdr.len = m0->m_len = m->m_pkthdr.len;\n\t}\n#else\n\tint mlen = MHLEN;\n\tint len = m->m_pkthdr.len;\n\tstruct mbuf **mp = &m0;\n\n\twhile (len > 0) {\n\t\tif (mlen == MHLEN) {\n\t\t\tMGETHDR(*mp, M_DONTWAIT, MT_DATA);\n\t\t} else {\n\t\t\tMGET(*mp, M_DONTWAIT, MT_DATA);\n\t\t}\n\t\tif (*mp == NULL) {\n\t\t\tm_freem(m0);\n\t\t\tm0 = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (len > MLEN) {\n\t\t\tMCLGET(*mp, M_DONTWAIT);\n\t\t\tif (((*mp)->m_flags & M_EXT) == 0) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tm0 = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(*mp)->m_len = (len <= MCLBYTES ? len : MCLBYTES);\n\t\t} else {\n\t\t\t(*mp)->m_len = (len <= mlen ? len : mlen);\n\t\t}\n\t\tm_copydata(m, m->m_pkthdr.len - len,\n\t\t\t   (*mp)->m_len, mtod((*mp), caddr_t));\n\t\tlen -= (*mp)->m_len;\n\t\tmp = &(*mp)->m_next;\n\t\tmlen = MLEN;\n\t}\n#endif\n\tm_freem(m);\n\treturn m0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "clsize"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "ti_free_rx_ring_mini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "964-979",
          "snippet": "void ti_free_rx_ring_mini(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_MINI_RX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_rx_mini_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_rx_mini_chain[i]);\n\t\t\tsc->ti_cdata.ti_rx_mini_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_rx_mini_ring[i],\n\t\t    sizeof(struct ti_rx_desc));\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_free_rx_ring_mini",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_free_rx_ring_mini;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_free_rx_ring_mini(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_MINI_RX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_rx_mini_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_rx_mini_chain[i]);\n\t\t\tsc->ti_cdata.ti_rx_mini_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_rx_mini_ring[i],\n\t\t    sizeof(struct ti_rx_desc));\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m0",
            "caddr_t"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "LMC_PRINTF_FMT \": txput: tx not running\\n\"",
            "LMC_PRINTF_ARGS"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define d_flag u.bd_flag\n#define d_length2 u.bd_length2\n#define d_length1 u.bd_length1\n\nstatic struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic struct mbuf *\nlmc_txput(lmc_softc_t * const sc, struct mbuf *m)\n{\n\tlmc_ringinfo_t * const ri = &sc->lmc_txinfo;\n\ttulip_desc_t *eop, *nextout;\n\tint segcnt, free;\n\tu_int32_t d_status;\n\tstruct mbuf *m0;\n\n#if defined(LMC_DEBUG)\n\tif ((sc->lmc_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\t\tprintf(LMC_PRINTF_FMT \": txput: tx not running\\n\",\n\t\t       LMC_PRINTF_ARGS);\n\t\tsc->lmc_flags |= LMC_WANTTXSTART;\n\t\tgoto finish;\n\t}\n#endif\n\n\t/*\n\t * Now we try to fill in our transmit descriptors.  This is\n\t * a bit reminiscent of going on the Ark two by two\n\t * since each descriptor for the TULIP can describe\n\t * two buffers.  So we advance through packet filling\n\t * each of the two entries at a time to fill each\n\t * descriptor.  Clear the first and last segment bits\n\t * in each descriptor (actually just clear everything\n\t * but the end-of-ring or chain bits) to make sure\n\t * we don't get messed up by previously sent packets.\n\t *\n\t * We may fail to put the entire packet on the ring if\n\t * there is either not enough ring entries free or if the\n\t * packet has more than MAX_TXSEG segments.  In the former\n\t * case we will just wait for the ring to empty.  In the\n\t * latter case we have to recopy.\n\t */\n again:\n\td_status = 0;\n\teop = nextout = ri->ri_nextout;\n\tm0 = m;\n\tsegcnt = 0;\n\tfree = ri->ri_free;\n\tdo {\n\t\tint len = m0->m_len;\n\t\tcaddr_t addr = mtod(m0, caddr_t);\n\t\tunsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));\n\n\t\twhile (len > 0) {\n\t\t\tunsigned slen = min(len, clsize);\n#ifdef BIG_PACKET\n\t\t\tint partial = 0;\n\t\t\tif (slen >= 2048)\n\t\t\t\tslen = 2040, partial = 1;\n#endif\n\t\t\tsegcnt++;\n\t\t\tif (segcnt > LMC_MAX_TXSEG) {\n\t\t\t\t/*\n\t\t\t\t * The packet exceeds the number of transmit\n\t\t\t\t * buffer entries that we can use for one\n\t\t\t\t * packet, so we have recopy it into one mbuf\n\t\t\t\t * and then try again.\n\t\t\t\t */\n\t\t\t\tm = lmc_mbuf_compress(m);\n\t\t\t\tif (m == NULL)\n\t\t\t\t\tgoto finish;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (segcnt & 1) {\n\t\t\t\tif (--free == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * See if there's any unclaimed space\n\t\t\t\t\t * in the transmit ring.\n\t\t\t\t\t */\n\t\t\t\t\tif ((free += lmc_tx_intr(sc)) == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * There's no more room but\n\t\t\t\t\t\t * since nothing has been\n\t\t\t\t\t\t * committed at this point,\n\t\t\t\t\t\t * just show output is active,\n\t\t\t\t\t\t * put back the mbuf and\n\t\t\t\t\t\t * return.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tsc->lmc_flags |= LMC_WANTTXSTART;\n\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\teop = nextout;\n\t\t\t\tif (++nextout == ri->ri_last)\n\t\t\t\t\tnextout = ri->ri_first;\n\t\t\t\teop->d_flag &= TULIP_DFLAG_ENDRING;\n\t\t\t\teop->d_flag |= TULIP_DFLAG_TxNOPADDING;\n\t\t\t\tif (sc->ictl.crc_length == 16)\n\t\t\t\t\teop->d_flag |= TULIP_DFLAG_TxHASCRC;\n\t\t\t\teop->d_status = d_status;\n\t\t\t\teop->d_addr1 = LMC_KVATOPHYS(sc, addr);\n\t\t\t\teop->d_length1 = slen;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t *  Fill in second half of descriptor\n\t\t\t\t */\n\t\t\t\teop->d_addr2 = LMC_KVATOPHYS(sc, addr);\n\t\t\t\teop->d_length2 = slen;\n\t\t\t}\n\t\t\td_status = TULIP_DSTS_OWNER;\n\t\t\tlen -= slen;\n\t\t\taddr += slen;\n#ifdef BIG_PACKET\n\t\t\tif (partial)\n\t\t\t\tcontinue;\n#endif\n\t\t\tclsize = CLBYTES;\n\t\t}\n\t} while ((m0 = m0->m_next) != NULL);\n\n\n\t/*\n\t * The descriptors have been filled in.  Now get ready\n\t * to transmit.\n\t */\n\tIF_ENQUEUE(&sc->lmc_txq, m);\n\tm = NULL;\n\n\t/*\n\t * Make sure the next descriptor after this packet is owned\n\t * by us since it may have been set up above if we ran out\n\t * of room in the ring.\n\t */\n\tnextout->d_status = 0;\n\n\t/*\n\t * If we only used the first segment of the last descriptor,\n\t * make sure the second segment will not be used.\n\t */\n\tif (segcnt & 1) {\n\t\teop->d_addr2 = 0;\n\t\teop->d_length2 = 0;\n\t}\n\n\t/*\n\t * Mark the last and first segments, indicate we want a transmit\n\t * complete interrupt, and tell it to transmit!\n\t */\n\teop->d_flag |= TULIP_DFLAG_TxLASTSEG | TULIP_DFLAG_TxWANTINTR;\n\n\t/*\n\t * Note that ri->ri_nextout is still the start of the packet\n\t * and until we set the OWNER bit, we can still back out of\n\t * everything we have done.\n\t */\n\tri->ri_nextout->d_flag |= TULIP_DFLAG_TxFIRSTSEG;\n\tri->ri_nextout->d_status = TULIP_DSTS_OWNER;\n\n\tLMC_CSR_WRITE(sc, csr_txpoll, 1);\n\n\t/*\n\t * This advances the ring for us.\n\t */\n\tri->ri_nextout = nextout;\n\tri->ri_free = free;\n\n\t/*\n\t * switch back to the single queueing ifstart.\n\t */\n\tsc->lmc_flags &= ~LMC_WANTTXSTART;\n\tsc->lmc_if.if_start = lmc_ifstart_one;\n\n\t/*\n\t * If we want a txstart, there must be not enough space in the\n\t * transmit ring.  So we want to enable transmit done interrupts\n\t * so we can immediately reclaim some space.  When the transmit\n\t * interrupt is posted, the interrupt handler will call tx_intr\n\t * to reclaim space and then txstart (since WANTTXSTART is set).\n\t * txstart will move the packet into the transmit ring and clear\n\t * WANTTXSTART thereby causing TXINTR to be cleared.\n\t */\n finish:\n\tif (sc->lmc_flags & LMC_WANTTXSTART) {\n\t\tsc->lmc_if.if_flags |= IFF_OACTIVE;\n\t\tsc->lmc_if.if_start = lmc_ifstart;\n\t}\n\n\treturn m;\n}"
  },
  {
    "function_name": "lmc_mbuf_compress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "944-998",
    "snippet": "static struct mbuf *\nlmc_mbuf_compress(struct mbuf *m)\n{\n\tstruct mbuf *m0;\n#if MCLBYTES >= LMC_MTU + PPP_HEADER_LEN && !defined(BIG_PACKET)\n\tMGETHDR(m0, M_DONTWAIT, MT_DATA);\n\tif (m0 != NULL) {\n\t\tif (m->m_pkthdr.len > MHLEN) {\n\t\t\tMCLGET(m0, M_DONTWAIT);\n\t\t\tif ((m0->m_flags & M_EXT) == 0) {\n\t\t\t\tm_freem(m);\n\t\t\t\tm_freem(m0);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tm_copydata(m, 0, m->m_pkthdr.len, mtod(m0, caddr_t));\n\t\tm0->m_pkthdr.len = m0->m_len = m->m_pkthdr.len;\n\t}\n#else\n\tint mlen = MHLEN;\n\tint len = m->m_pkthdr.len;\n\tstruct mbuf **mp = &m0;\n\n\twhile (len > 0) {\n\t\tif (mlen == MHLEN) {\n\t\t\tMGETHDR(*mp, M_DONTWAIT, MT_DATA);\n\t\t} else {\n\t\t\tMGET(*mp, M_DONTWAIT, MT_DATA);\n\t\t}\n\t\tif (*mp == NULL) {\n\t\t\tm_freem(m0);\n\t\t\tm0 = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (len > MLEN) {\n\t\t\tMCLGET(*mp, M_DONTWAIT);\n\t\t\tif (((*mp)->m_flags & M_EXT) == 0) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tm0 = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(*mp)->m_len = (len <= MCLBYTES ? len : MCLBYTES);\n\t\t} else {\n\t\t\t(*mp)->m_len = (len <= mlen ? len : mlen);\n\t\t}\n\t\tm_copydata(m, m->m_pkthdr.len - len,\n\t\t\t   (*mp)->m_len, mtod((*mp), caddr_t));\n\t\tlen -= (*mp)->m_len;\n\t\tmp = &(*mp)->m_next;\n\t\tmlen = MLEN;\n\t}\n#endif\n\tm_freem(m);\n\treturn m0;\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "m",
            "m->m_pkthdr.len - len",
            "(*mp)->m_len",
            "mtod((*mp), caddr_t)"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "(*mp)",
            "caddr_t"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "*mp",
            "M_DONTWAIT"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGET",
          "args": [
            "*mp",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "*mp",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "m",
            "0",
            "m->m_pkthdr.len",
            "mtod(m0, caddr_t)"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m0",
            "caddr_t"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m0",
            "M_DONTWAIT"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m0",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);\n\nstatic struct mbuf *\nlmc_mbuf_compress(struct mbuf *m)\n{\n\tstruct mbuf *m0;\n#if MCLBYTES >= LMC_MTU + PPP_HEADER_LEN && !defined(BIG_PACKET)\n\tMGETHDR(m0, M_DONTWAIT, MT_DATA);\n\tif (m0 != NULL) {\n\t\tif (m->m_pkthdr.len > MHLEN) {\n\t\t\tMCLGET(m0, M_DONTWAIT);\n\t\t\tif ((m0->m_flags & M_EXT) == 0) {\n\t\t\t\tm_freem(m);\n\t\t\t\tm_freem(m0);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tm_copydata(m, 0, m->m_pkthdr.len, mtod(m0, caddr_t));\n\t\tm0->m_pkthdr.len = m0->m_len = m->m_pkthdr.len;\n\t}\n#else\n\tint mlen = MHLEN;\n\tint len = m->m_pkthdr.len;\n\tstruct mbuf **mp = &m0;\n\n\twhile (len > 0) {\n\t\tif (mlen == MHLEN) {\n\t\t\tMGETHDR(*mp, M_DONTWAIT, MT_DATA);\n\t\t} else {\n\t\t\tMGET(*mp, M_DONTWAIT, MT_DATA);\n\t\t}\n\t\tif (*mp == NULL) {\n\t\t\tm_freem(m0);\n\t\t\tm0 = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (len > MLEN) {\n\t\t\tMCLGET(*mp, M_DONTWAIT);\n\t\t\tif (((*mp)->m_flags & M_EXT) == 0) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tm0 = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(*mp)->m_len = (len <= MCLBYTES ? len : MCLBYTES);\n\t\t} else {\n\t\t\t(*mp)->m_len = (len <= mlen ? len : mlen);\n\t\t}\n\t\tm_copydata(m, m->m_pkthdr.len - len,\n\t\t\t   (*mp)->m_len, mtod((*mp), caddr_t));\n\t\tlen -= (*mp)->m_len;\n\t\tmp = &(*mp)->m_next;\n\t\tmlen = MLEN;\n\t}\n#endif\n\tm_freem(m);\n\treturn m0;\n}"
  },
  {
    "function_name": "lmc_intr_normal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "931-942",
    "snippet": "lmc_intrfunc_t\nlmc_intr_normal(void *arg)\n{\n\tlmc_softc_t * sc = (lmc_softc_t *) arg;\n\tint progress = 0;\n\n\tlmc_intr_handler(sc, &progress);\n\n#if !defined(LMC_VOID_INTRFUNC)\n\treturn progress;\n#endif\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lmc_intr_handler",
          "args": [
            "sc",
            "&progress"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_intr_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "844-929",
          "snippet": "static void\nlmc_intr_handler(lmc_softc_t * const sc, int *progress_p)\n{\n    u_int32_t csr;\n\n    while ((csr = LMC_CSR_READ(sc, csr_status)) & sc->lmc_intrmask) {\n\n#if defined(__NetBSD__)\n#if NRND > 0\n\t    rnd_add_uint32(&sc->lmc_rndsource, csr);\n#endif\n#endif\n\n\t*progress_p = 1;\n\tLMC_CSR_WRITE(sc, csr_status, csr);\n\n\tif (csr & TULIP_STS_SYSERROR) {\n\t    sc->lmc_last_system_error = (csr & TULIP_STS_ERRORMASK) >> TULIP_STS_ERR_SHIFT;\n\t    if (sc->lmc_flags & LMC_NOMESSAGES) {\n\t\tsc->lmc_flags |= LMC_SYSTEMERROR;\n\t    } else {\n\t\tprintf(LMC_PRINTF_FMT \": system error: %s\\n\",\n\t\t       LMC_PRINTF_ARGS,\n\t\t       lmc_system_errors[sc->lmc_last_system_error]);\n\t    }\n\t    sc->lmc_flags |= LMC_NEEDRESET;\n\t    sc->lmc_system_errors++;\n\t    break;\n\t}\n\tif (csr & (TULIP_STS_RXINTR | TULIP_STS_RXNOBUF)) {\n\t    u_int32_t misses = LMC_CSR_READ(sc, csr_missed_frames);\n\t    if (csr & TULIP_STS_RXNOBUF)\n\t\tsc->lmc_dot3stats.dot3StatsMissedFrames += misses & 0xFFFF;\n\t    /*\n\t     * Pass 2.[012] of the 21140A-A[CDE] may hang and/or corrupt data\n\t     * on receive overflows.\n\t     */\n\t   if ((misses & 0x0FFE0000) && (sc->lmc_features & LMC_HAVE_RXBADOVRFLW)) {\n\t\tsc->lmc_dot3stats.dot3StatsInternalMacReceiveErrors++;\n\t\t/*\n\t\t * Stop the receiver process and spin until it's stopped.\n\t\t * Tell rx_intr to drop the packets it dequeues.\n\t\t */\n\t\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode & ~TULIP_CMD_RXRUN);\n\t\twhile ((LMC_CSR_READ(sc, csr_status) & TULIP_STS_RXSTOPPED) == 0)\n\t\t    ;\n\t\tLMC_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\tsc->lmc_flags |= LMC_RXIGNORE;\n\t    }\n\t    lmc_rx_intr(sc);\n\t    if (sc->lmc_flags & LMC_RXIGNORE) {\n\t\t/*\n\t\t * Restart the receiver.\n\t\t */\n\t\tsc->lmc_flags &= ~LMC_RXIGNORE;\n\t\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\t    }\n\t}\n\tif (csr & TULIP_STS_ABNRMLINTR) {\n\t    u_int32_t tmp = csr & sc->lmc_intrmask\n\t\t& ~(TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR);\n\t    if (csr & TULIP_STS_TXUNDERFLOW) {\n\t\tif ((sc->lmc_cmdmode & TULIP_CMD_THRESHOLDCTL) != TULIP_CMD_THRSHLD160) {\n\t\t    sc->lmc_cmdmode += TULIP_CMD_THRSHLD96;\n\t\t    sc->lmc_flags |= LMC_NEWTXTHRESH;\n\t\t} else if (sc->lmc_features & LMC_HAVE_STOREFWD) {\n\t\t    sc->lmc_cmdmode |= TULIP_CMD_STOREFWD;\n\t\t    sc->lmc_flags |= LMC_NEWTXTHRESH;\n\t\t}\n\t    }\n\t    if (sc->lmc_flags & LMC_NOMESSAGES) {\n\t\tsc->lmc_statusbits |= tmp;\n\t    } else {\n\t\tlmc_print_abnormal_interrupt(sc, tmp);\n\t\tsc->lmc_flags |= LMC_NOMESSAGES;\n\t    }\n\t    LMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\t}\n\n\tif (csr & TULIP_STS_TXINTR)\n\t\tlmc_tx_intr(sc);\n\n\tif (sc->lmc_flags & LMC_WANTTXSTART)\n\t    lmc_ifstart(&sc->lmc_if);\n    }\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic void\nlmc_intr_handler(lmc_softc_t * const sc, int *progress_p)\n{\n    u_int32_t csr;\n\n    while ((csr = LMC_CSR_READ(sc, csr_status)) & sc->lmc_intrmask) {\n\n#if defined(__NetBSD__)\n#if NRND > 0\n\t    rnd_add_uint32(&sc->lmc_rndsource, csr);\n#endif\n#endif\n\n\t*progress_p = 1;\n\tLMC_CSR_WRITE(sc, csr_status, csr);\n\n\tif (csr & TULIP_STS_SYSERROR) {\n\t    sc->lmc_last_system_error = (csr & TULIP_STS_ERRORMASK) >> TULIP_STS_ERR_SHIFT;\n\t    if (sc->lmc_flags & LMC_NOMESSAGES) {\n\t\tsc->lmc_flags |= LMC_SYSTEMERROR;\n\t    } else {\n\t\tprintf(LMC_PRINTF_FMT \": system error: %s\\n\",\n\t\t       LMC_PRINTF_ARGS,\n\t\t       lmc_system_errors[sc->lmc_last_system_error]);\n\t    }\n\t    sc->lmc_flags |= LMC_NEEDRESET;\n\t    sc->lmc_system_errors++;\n\t    break;\n\t}\n\tif (csr & (TULIP_STS_RXINTR | TULIP_STS_RXNOBUF)) {\n\t    u_int32_t misses = LMC_CSR_READ(sc, csr_missed_frames);\n\t    if (csr & TULIP_STS_RXNOBUF)\n\t\tsc->lmc_dot3stats.dot3StatsMissedFrames += misses & 0xFFFF;\n\t    /*\n\t     * Pass 2.[012] of the 21140A-A[CDE] may hang and/or corrupt data\n\t     * on receive overflows.\n\t     */\n\t   if ((misses & 0x0FFE0000) && (sc->lmc_features & LMC_HAVE_RXBADOVRFLW)) {\n\t\tsc->lmc_dot3stats.dot3StatsInternalMacReceiveErrors++;\n\t\t/*\n\t\t * Stop the receiver process and spin until it's stopped.\n\t\t * Tell rx_intr to drop the packets it dequeues.\n\t\t */\n\t\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode & ~TULIP_CMD_RXRUN);\n\t\twhile ((LMC_CSR_READ(sc, csr_status) & TULIP_STS_RXSTOPPED) == 0)\n\t\t    ;\n\t\tLMC_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\tsc->lmc_flags |= LMC_RXIGNORE;\n\t    }\n\t    lmc_rx_intr(sc);\n\t    if (sc->lmc_flags & LMC_RXIGNORE) {\n\t\t/*\n\t\t * Restart the receiver.\n\t\t */\n\t\tsc->lmc_flags &= ~LMC_RXIGNORE;\n\t\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\t    }\n\t}\n\tif (csr & TULIP_STS_ABNRMLINTR) {\n\t    u_int32_t tmp = csr & sc->lmc_intrmask\n\t\t& ~(TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR);\n\t    if (csr & TULIP_STS_TXUNDERFLOW) {\n\t\tif ((sc->lmc_cmdmode & TULIP_CMD_THRESHOLDCTL) != TULIP_CMD_THRSHLD160) {\n\t\t    sc->lmc_cmdmode += TULIP_CMD_THRSHLD96;\n\t\t    sc->lmc_flags |= LMC_NEWTXTHRESH;\n\t\t} else if (sc->lmc_features & LMC_HAVE_STOREFWD) {\n\t\t    sc->lmc_cmdmode |= TULIP_CMD_STOREFWD;\n\t\t    sc->lmc_flags |= LMC_NEWTXTHRESH;\n\t\t}\n\t    }\n\t    if (sc->lmc_flags & LMC_NOMESSAGES) {\n\t\tsc->lmc_statusbits |= tmp;\n\t    } else {\n\t\tlmc_print_abnormal_interrupt(sc, tmp);\n\t\tsc->lmc_flags |= LMC_NOMESSAGES;\n\t    }\n\t    LMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\t}\n\n\tif (csr & TULIP_STS_TXINTR)\n\t\tlmc_tx_intr(sc);\n\n\tif (sc->lmc_flags & LMC_WANTTXSTART)\n\t    lmc_ifstart(&sc->lmc_if);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nlmc_intrfunc_t\nlmc_intr_normal(void *arg)\n{\n\tlmc_softc_t * sc = (lmc_softc_t *) arg;\n\tint progress = 0;\n\n\tlmc_intr_handler(sc, &progress);\n\n#if !defined(LMC_VOID_INTRFUNC)\n\treturn progress;\n#endif\n}"
  },
  {
    "function_name": "lmc_intr_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "844-929",
    "snippet": "static void\nlmc_intr_handler(lmc_softc_t * const sc, int *progress_p)\n{\n    u_int32_t csr;\n\n    while ((csr = LMC_CSR_READ(sc, csr_status)) & sc->lmc_intrmask) {\n\n#if defined(__NetBSD__)\n#if NRND > 0\n\t    rnd_add_uint32(&sc->lmc_rndsource, csr);\n#endif\n#endif\n\n\t*progress_p = 1;\n\tLMC_CSR_WRITE(sc, csr_status, csr);\n\n\tif (csr & TULIP_STS_SYSERROR) {\n\t    sc->lmc_last_system_error = (csr & TULIP_STS_ERRORMASK) >> TULIP_STS_ERR_SHIFT;\n\t    if (sc->lmc_flags & LMC_NOMESSAGES) {\n\t\tsc->lmc_flags |= LMC_SYSTEMERROR;\n\t    } else {\n\t\tprintf(LMC_PRINTF_FMT \": system error: %s\\n\",\n\t\t       LMC_PRINTF_ARGS,\n\t\t       lmc_system_errors[sc->lmc_last_system_error]);\n\t    }\n\t    sc->lmc_flags |= LMC_NEEDRESET;\n\t    sc->lmc_system_errors++;\n\t    break;\n\t}\n\tif (csr & (TULIP_STS_RXINTR | TULIP_STS_RXNOBUF)) {\n\t    u_int32_t misses = LMC_CSR_READ(sc, csr_missed_frames);\n\t    if (csr & TULIP_STS_RXNOBUF)\n\t\tsc->lmc_dot3stats.dot3StatsMissedFrames += misses & 0xFFFF;\n\t    /*\n\t     * Pass 2.[012] of the 21140A-A[CDE] may hang and/or corrupt data\n\t     * on receive overflows.\n\t     */\n\t   if ((misses & 0x0FFE0000) && (sc->lmc_features & LMC_HAVE_RXBADOVRFLW)) {\n\t\tsc->lmc_dot3stats.dot3StatsInternalMacReceiveErrors++;\n\t\t/*\n\t\t * Stop the receiver process and spin until it's stopped.\n\t\t * Tell rx_intr to drop the packets it dequeues.\n\t\t */\n\t\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode & ~TULIP_CMD_RXRUN);\n\t\twhile ((LMC_CSR_READ(sc, csr_status) & TULIP_STS_RXSTOPPED) == 0)\n\t\t    ;\n\t\tLMC_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\tsc->lmc_flags |= LMC_RXIGNORE;\n\t    }\n\t    lmc_rx_intr(sc);\n\t    if (sc->lmc_flags & LMC_RXIGNORE) {\n\t\t/*\n\t\t * Restart the receiver.\n\t\t */\n\t\tsc->lmc_flags &= ~LMC_RXIGNORE;\n\t\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\t    }\n\t}\n\tif (csr & TULIP_STS_ABNRMLINTR) {\n\t    u_int32_t tmp = csr & sc->lmc_intrmask\n\t\t& ~(TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR);\n\t    if (csr & TULIP_STS_TXUNDERFLOW) {\n\t\tif ((sc->lmc_cmdmode & TULIP_CMD_THRESHOLDCTL) != TULIP_CMD_THRSHLD160) {\n\t\t    sc->lmc_cmdmode += TULIP_CMD_THRSHLD96;\n\t\t    sc->lmc_flags |= LMC_NEWTXTHRESH;\n\t\t} else if (sc->lmc_features & LMC_HAVE_STOREFWD) {\n\t\t    sc->lmc_cmdmode |= TULIP_CMD_STOREFWD;\n\t\t    sc->lmc_flags |= LMC_NEWTXTHRESH;\n\t\t}\n\t    }\n\t    if (sc->lmc_flags & LMC_NOMESSAGES) {\n\t\tsc->lmc_statusbits |= tmp;\n\t    } else {\n\t\tlmc_print_abnormal_interrupt(sc, tmp);\n\t\tsc->lmc_flags |= LMC_NOMESSAGES;\n\t    }\n\t    LMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\t}\n\n\tif (csr & TULIP_STS_TXINTR)\n\t\tlmc_tx_intr(sc);\n\n\tif (sc->lmc_flags & LMC_WANTTXSTART)\n\t    lmc_ifstart(&sc->lmc_if);\n    }\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lmc_ifstart",
          "args": [
            "&sc->lmc_if"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_ifstart_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "1352-1380",
          "snippet": "static ifnet_ret_t\nlmc_ifstart_one(struct ifnet * const ifp)\n{\n\tlmc_softc_t * const sc = LMC_IFP_TO_SOFTC(ifp);\n\tstruct mbuf *m;\n\tstruct ifqueue *ifq;\n\n\tif ((sc->lmc_flags & LMC_IFUP) == 0)\n\t\treturn;\n\n\tifq = &sc->lmc_p2pcom.p2p_isnd;\n\n        m = ifq->ifq_head;\n    {\n\tif (m == NULL) {\n\t\tifq = &sc->lmc_if.if_snd;\n\t\tm = ifq->ifq_head;\n\t}\n\tif (m == NULL)\n\t\treturn 0;\n\tIF_DEQUEUE(ifq, m);\n\n\tm = lmc_txput(sc, m);\n    }\n\tif (m != NULL)\n\t\tIF_PREPEND(ifq, m);\n\n\tLMC_CSR_WRITE(sc, csr_txpoll, 1);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);",
            "static ifnet_ret_t lmc_ifstart(struct ifnet *ifp);",
            "static struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);",
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);\nstatic ifnet_ret_t lmc_ifstart(struct ifnet *ifp);\nstatic struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic ifnet_ret_t\nlmc_ifstart_one(struct ifnet * const ifp)\n{\n\tlmc_softc_t * const sc = LMC_IFP_TO_SOFTC(ifp);\n\tstruct mbuf *m;\n\tstruct ifqueue *ifq;\n\n\tif ((sc->lmc_flags & LMC_IFUP) == 0)\n\t\treturn;\n\n\tifq = &sc->lmc_p2pcom.p2p_isnd;\n\n        m = ifq->ifq_head;\n    {\n\tif (m == NULL) {\n\t\tifq = &sc->lmc_if.if_snd;\n\t\tm = ifq->ifq_head;\n\t}\n\tif (m == NULL)\n\t\treturn 0;\n\tIF_DEQUEUE(ifq, m);\n\n\tm = lmc_txput(sc, m);\n    }\n\tif (m != NULL)\n\t\tIF_PREPEND(ifq, m);\n\n\tLMC_CSR_WRITE(sc, csr_txpoll, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmc_tx_intr",
          "args": [
            "sc"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "sc->lmc_cmdmode"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmc_print_abnormal_interrupt",
          "args": [
            "sc",
            "tmp"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_print_abnormal_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "838-842",
          "snippet": "static void\nlmc_print_abnormal_interrupt (lmc_softc_t * const sc, u_int32_t csr)\n{\n\tprintf(LMC_PRINTF_FMT \": Abnormal interrupt\\n\", LMC_PRINTF_ARGS);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic void\nlmc_print_abnormal_interrupt (lmc_softc_t * const sc, u_int32_t csr)\n{\n\tprintf(LMC_PRINTF_FMT \": Abnormal interrupt\\n\", LMC_PRINTF_ARGS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LMC_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "sc->lmc_cmdmode"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmc_rx_intr",
          "args": [
            "sc"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_rx_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "591-769",
          "snippet": "static void\nlmc_rx_intr(lmc_softc_t * const sc)\n{\n\tlmc_ringinfo_t * const ri = &sc->lmc_rxinfo;\n\tstruct ifnet * const ifp = &sc->lmc_if;\n\tint fillok = 1;\n\n\tsc->lmc_rxtick++;\n\n\tfor (;;) {\n\t\ttulip_desc_t *eop = ri->ri_nextin;\n\t\tint total_len = 0, last_offset = 0;\n\t\tstruct mbuf *ms = NULL, *me = NULL;\n\t\tint accept = 0;\n\n\t\tif (fillok && sc->lmc_rxq.ifq_len < LMC_RXQ_TARGET)\n\t\t\tgoto queue_mbuf;\n\n\t\t/*\n\t\t * If the TULIP has no descriptors, there can't be any receive\n\t\t * descriptors to process.\n\t\t */\n\t\tif (eop == ri->ri_nextout)\n\t\t\tbreak;\n\t    \n\t\t/*\n\t\t * 90% of the packets will fit in one descriptor.  So we\n\t\t * optimize for that case.\n\t\t */\n\t\tif ((((volatile tulip_desc_t *) eop)->d_status & (TULIP_DSTS_OWNER|TULIP_DSTS_RxFIRSTDESC|TULIP_DSTS_RxLASTDESC)) == (TULIP_DSTS_RxFIRSTDESC|TULIP_DSTS_RxLASTDESC)) {\n\t\t\tIF_DEQUEUE(&sc->lmc_rxq, ms);\n\t\t\tme = ms;\n\t\t} else {\n\t\t\t/*\n\t\t\t * If still owned by the TULIP, don't touch it.\n\t\t\t */\n\t\t\tif (((volatile tulip_desc_t *)eop)->d_status & TULIP_DSTS_OWNER)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * It is possible (though improbable unless the\n\t\t\t * BIG_PACKET support is enabled or MCLBYTES < 1518)\n\t\t\t * for a received packet to cross more than one\n\t\t\t * receive descriptor.\n\t\t\t */\n\t\t\twhile ((((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_RxLASTDESC) == 0) {\n\t\t\t\tif (++eop == ri->ri_last)\n\t\t\t\t\teop = ri->ri_first;\n\t\t\t\tif (eop == ri->ri_nextout || ((((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_OWNER))) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttotal_len++;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Dequeue the first buffer for the start of the\n\t\t\t * packet.  Hopefully this will be the only one we\n\t\t\t * need to dequeue.  However, if the packet consumed\n\t\t\t * multiple descriptors, then we need to dequeue\n\t\t\t * those buffers and chain to the starting mbuf.\n\t\t\t * All buffers but the last buffer have the same\n\t\t\t * length so we can set that now. (we add to\n\t\t\t * last_offset instead of multiplying since we\n\t\t\t * normally won't go into the loop and thereby\n\t\t\t * saving a ourselves from doing a multiplication\n\t\t\t * by 0 in the normal case).\n\t\t\t */\n\t\t\tIF_DEQUEUE(&sc->lmc_rxq, ms);\n\t\t\tfor (me = ms; total_len > 0; total_len--) {\n\t\t\t\tme->m_len = LMC_RX_BUFLEN;\n\t\t\t\tlast_offset += LMC_RX_BUFLEN;\n\t\t\t\tIF_DEQUEUE(&sc->lmc_rxq, me->m_next);\n\t\t\t\tme = me->m_next;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *  Now get the size of received packet (minus the CRC).\n\t\t */\n\t\ttotal_len = ((eop->d_status >> 16) & 0x7FFF);\n\t\tif (sc->ictl.crc_length == 16)\n\t\t\ttotal_len -= 2;\n\t\telse\n\t\t\ttotal_len -= 4;\n\n\t\tif ((sc->lmc_flags & LMC_RXIGNORE) == 0\n\t\t    && ((eop->d_status & LMC_DSTS_ERRSUM) == 0\n#ifdef BIG_PACKET\n\t\t\t|| (total_len <= sc->lmc_if.if_mtu + PPP_HEADER_LEN\n\t\t\t    && (eop->d_status & TULIP_DSTS_RxOVERFLOW) == 0)\n#endif\n\t\t\t)) {\n\t\t\tme->m_len = total_len - last_offset;\n#if NBPFILTER > 0\n\t\t\tif (sc->lmc_bpf != NULL) {\n\t\t\t\tif (me == ms)\n\t\t\t\t\tLMC_BPF_TAP(sc, mtod(ms, caddr_t), total_len);\n\t\t\t\telse\n\t\t\t\t\tLMC_BPF_MTAP(sc, ms);\n\t\t\t}\n#endif\n\t\t\tsc->lmc_flags |= LMC_RXACT;\n\t\t\taccept = 1;\n\t\t} else {\n\t\t\tifp->if_ierrors++;\n\t\t\tif (eop->d_status & TULIP_DSTS_RxOVERFLOW) {\n\t\t\t\tsc->lmc_dot3stats.dot3StatsInternalMacReceiveErrors++;\n\t\t\t}\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\tif (++eop == ri->ri_last)\n\t\t\teop = ri->ri_first;\n\t\tri->ri_nextin = eop;\n\n\tqueue_mbuf:\n\t\t/*\n\t\t * Either we are priming the TULIP with mbufs (m == NULL)\n\t\t * or we are about to accept an mbuf for the upper layers\n\t\t * so we need to allocate an mbuf to replace it.  If we\n\t\t * can't replace it, send up it anyways.  This may cause\n\t\t * us to drop packets in the future but that's better than\n\t\t * being caught in livelock.\n\t\t *\n\t\t * Note that if this packet crossed multiple descriptors\n\t\t * we don't even try to reallocate all the mbufs here.\n\t\t * Instead we rely on the test of the beginning of\n\t\t * the loop to refill for the extra consumed mbufs.\n\t\t */\n\t\tif (accept || ms == NULL) {\n\t\t\tstruct mbuf *m0;\n\t\t\tMGETHDR(m0, M_DONTWAIT, MT_DATA);\n\t\t\tif (m0 != NULL) {\n\t\t\t\tMCLGET(m0, M_DONTWAIT);\n\t\t\t\tif ((m0->m_flags & M_EXT) == 0) {\n\t\t\t\t\tm_freem(m0);\n\t\t\t\t\tm0 = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (accept) {\n\t\t\t\tms->m_pkthdr.len = total_len;\n\t\t\t\tms->m_pkthdr.rcvif = ifp;\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\t\t\t\tsppp_input(ifp, ms);\n#endif\n#if defined(__bsdi__)\n\t\t\t\tsc->lmc_p2pcom.p2p_input(&sc->lmc_p2pcom, ms);\n#endif\n\t\t\t}\n\t\t\tms = m0;\n\t\t}\n\t\tif (ms == NULL) {\n\t\t\t/*\n\t\t\t * Couldn't allocate a new buffer.  Don't bother \n\t\t\t * trying to replenish the receive queue.\n\t\t\t */\n\t\t\tfillok = 0;\n\t\t\tsc->lmc_flags |= LMC_RXBUFSLOW;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Now give the buffer(s) to the TULIP and save in our\n\t\t * receive queue.\n\t\t */\n\t\tdo {\n\t\t\tri->ri_nextout->d_length1 = LMC_RX_BUFLEN;\n\t\t\tri->ri_nextout->d_addr1 = LMC_KVATOPHYS(sc, mtod(ms, caddr_t));\n\t\t\tri->ri_nextout->d_status = TULIP_DSTS_OWNER;\n\t\t\tif (++ri->ri_nextout == ri->ri_last)\n\t\t\t\tri->ri_nextout = ri->ri_first;\n\t\t\tme = ms->m_next;\n\t\t\tms->m_next = NULL;\n\t\t\tIF_ENQUEUE(&sc->lmc_rxq, ms);\n\t\t} while ((ms = me) != NULL);\n\n\t\tif (sc->lmc_rxq.ifq_len >= LMC_RXQ_TARGET)\n\t\t\tsc->lmc_flags &= ~LMC_RXBUFSLOW;\n\t}\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define d_length1 u.bd_length1"
          ],
          "globals_used": [
            "static ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);",
            "static ifnet_ret_t lmc_ifstart(struct ifnet *ifp);",
            "static struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);",
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define d_length1 u.bd_length1\n\nstatic ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);\nstatic ifnet_ret_t lmc_ifstart(struct ifnet *ifp);\nstatic struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic void\nlmc_rx_intr(lmc_softc_t * const sc)\n{\n\tlmc_ringinfo_t * const ri = &sc->lmc_rxinfo;\n\tstruct ifnet * const ifp = &sc->lmc_if;\n\tint fillok = 1;\n\n\tsc->lmc_rxtick++;\n\n\tfor (;;) {\n\t\ttulip_desc_t *eop = ri->ri_nextin;\n\t\tint total_len = 0, last_offset = 0;\n\t\tstruct mbuf *ms = NULL, *me = NULL;\n\t\tint accept = 0;\n\n\t\tif (fillok && sc->lmc_rxq.ifq_len < LMC_RXQ_TARGET)\n\t\t\tgoto queue_mbuf;\n\n\t\t/*\n\t\t * If the TULIP has no descriptors, there can't be any receive\n\t\t * descriptors to process.\n\t\t */\n\t\tif (eop == ri->ri_nextout)\n\t\t\tbreak;\n\t    \n\t\t/*\n\t\t * 90% of the packets will fit in one descriptor.  So we\n\t\t * optimize for that case.\n\t\t */\n\t\tif ((((volatile tulip_desc_t *) eop)->d_status & (TULIP_DSTS_OWNER|TULIP_DSTS_RxFIRSTDESC|TULIP_DSTS_RxLASTDESC)) == (TULIP_DSTS_RxFIRSTDESC|TULIP_DSTS_RxLASTDESC)) {\n\t\t\tIF_DEQUEUE(&sc->lmc_rxq, ms);\n\t\t\tme = ms;\n\t\t} else {\n\t\t\t/*\n\t\t\t * If still owned by the TULIP, don't touch it.\n\t\t\t */\n\t\t\tif (((volatile tulip_desc_t *)eop)->d_status & TULIP_DSTS_OWNER)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * It is possible (though improbable unless the\n\t\t\t * BIG_PACKET support is enabled or MCLBYTES < 1518)\n\t\t\t * for a received packet to cross more than one\n\t\t\t * receive descriptor.\n\t\t\t */\n\t\t\twhile ((((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_RxLASTDESC) == 0) {\n\t\t\t\tif (++eop == ri->ri_last)\n\t\t\t\t\teop = ri->ri_first;\n\t\t\t\tif (eop == ri->ri_nextout || ((((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_OWNER))) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttotal_len++;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Dequeue the first buffer for the start of the\n\t\t\t * packet.  Hopefully this will be the only one we\n\t\t\t * need to dequeue.  However, if the packet consumed\n\t\t\t * multiple descriptors, then we need to dequeue\n\t\t\t * those buffers and chain to the starting mbuf.\n\t\t\t * All buffers but the last buffer have the same\n\t\t\t * length so we can set that now. (we add to\n\t\t\t * last_offset instead of multiplying since we\n\t\t\t * normally won't go into the loop and thereby\n\t\t\t * saving a ourselves from doing a multiplication\n\t\t\t * by 0 in the normal case).\n\t\t\t */\n\t\t\tIF_DEQUEUE(&sc->lmc_rxq, ms);\n\t\t\tfor (me = ms; total_len > 0; total_len--) {\n\t\t\t\tme->m_len = LMC_RX_BUFLEN;\n\t\t\t\tlast_offset += LMC_RX_BUFLEN;\n\t\t\t\tIF_DEQUEUE(&sc->lmc_rxq, me->m_next);\n\t\t\t\tme = me->m_next;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *  Now get the size of received packet (minus the CRC).\n\t\t */\n\t\ttotal_len = ((eop->d_status >> 16) & 0x7FFF);\n\t\tif (sc->ictl.crc_length == 16)\n\t\t\ttotal_len -= 2;\n\t\telse\n\t\t\ttotal_len -= 4;\n\n\t\tif ((sc->lmc_flags & LMC_RXIGNORE) == 0\n\t\t    && ((eop->d_status & LMC_DSTS_ERRSUM) == 0\n#ifdef BIG_PACKET\n\t\t\t|| (total_len <= sc->lmc_if.if_mtu + PPP_HEADER_LEN\n\t\t\t    && (eop->d_status & TULIP_DSTS_RxOVERFLOW) == 0)\n#endif\n\t\t\t)) {\n\t\t\tme->m_len = total_len - last_offset;\n#if NBPFILTER > 0\n\t\t\tif (sc->lmc_bpf != NULL) {\n\t\t\t\tif (me == ms)\n\t\t\t\t\tLMC_BPF_TAP(sc, mtod(ms, caddr_t), total_len);\n\t\t\t\telse\n\t\t\t\t\tLMC_BPF_MTAP(sc, ms);\n\t\t\t}\n#endif\n\t\t\tsc->lmc_flags |= LMC_RXACT;\n\t\t\taccept = 1;\n\t\t} else {\n\t\t\tifp->if_ierrors++;\n\t\t\tif (eop->d_status & TULIP_DSTS_RxOVERFLOW) {\n\t\t\t\tsc->lmc_dot3stats.dot3StatsInternalMacReceiveErrors++;\n\t\t\t}\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\tif (++eop == ri->ri_last)\n\t\t\teop = ri->ri_first;\n\t\tri->ri_nextin = eop;\n\n\tqueue_mbuf:\n\t\t/*\n\t\t * Either we are priming the TULIP with mbufs (m == NULL)\n\t\t * or we are about to accept an mbuf for the upper layers\n\t\t * so we need to allocate an mbuf to replace it.  If we\n\t\t * can't replace it, send up it anyways.  This may cause\n\t\t * us to drop packets in the future but that's better than\n\t\t * being caught in livelock.\n\t\t *\n\t\t * Note that if this packet crossed multiple descriptors\n\t\t * we don't even try to reallocate all the mbufs here.\n\t\t * Instead we rely on the test of the beginning of\n\t\t * the loop to refill for the extra consumed mbufs.\n\t\t */\n\t\tif (accept || ms == NULL) {\n\t\t\tstruct mbuf *m0;\n\t\t\tMGETHDR(m0, M_DONTWAIT, MT_DATA);\n\t\t\tif (m0 != NULL) {\n\t\t\t\tMCLGET(m0, M_DONTWAIT);\n\t\t\t\tif ((m0->m_flags & M_EXT) == 0) {\n\t\t\t\t\tm_freem(m0);\n\t\t\t\t\tm0 = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (accept) {\n\t\t\t\tms->m_pkthdr.len = total_len;\n\t\t\t\tms->m_pkthdr.rcvif = ifp;\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\t\t\t\tsppp_input(ifp, ms);\n#endif\n#if defined(__bsdi__)\n\t\t\t\tsc->lmc_p2pcom.p2p_input(&sc->lmc_p2pcom, ms);\n#endif\n\t\t\t}\n\t\t\tms = m0;\n\t\t}\n\t\tif (ms == NULL) {\n\t\t\t/*\n\t\t\t * Couldn't allocate a new buffer.  Don't bother \n\t\t\t * trying to replenish the receive queue.\n\t\t\t */\n\t\t\tfillok = 0;\n\t\t\tsc->lmc_flags |= LMC_RXBUFSLOW;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Now give the buffer(s) to the TULIP and save in our\n\t\t * receive queue.\n\t\t */\n\t\tdo {\n\t\t\tri->ri_nextout->d_length1 = LMC_RX_BUFLEN;\n\t\t\tri->ri_nextout->d_addr1 = LMC_KVATOPHYS(sc, mtod(ms, caddr_t));\n\t\t\tri->ri_nextout->d_status = TULIP_DSTS_OWNER;\n\t\t\tif (++ri->ri_nextout == ri->ri_last)\n\t\t\t\tri->ri_nextout = ri->ri_first;\n\t\t\tme = ms->m_next;\n\t\t\tms->m_next = NULL;\n\t\t\tIF_ENQUEUE(&sc->lmc_rxq, ms);\n\t\t} while ((ms = me) != NULL);\n\n\t\tif (sc->lmc_rxq.ifq_len >= LMC_RXQ_TARGET)\n\t\t\tsc->lmc_flags &= ~LMC_RXBUFSLOW;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LMC_CSR_WRITE",
          "args": [
            "sc",
            "csr_status",
            "TULIP_STS_RXSTOPPED"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_CSR_READ",
          "args": [
            "sc",
            "csr_status"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "sc->lmc_cmdmode & ~TULIP_CMD_RXRUN"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_CSR_READ",
          "args": [
            "sc",
            "csr_missed_frames"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "LMC_PRINTF_FMT \": system error: %s\\n\"",
            "LMC_PRINTF_ARGS",
            "lmc_system_errors[sc->lmc_last_system_error]"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LMC_CSR_WRITE",
          "args": [
            "sc",
            "csr_status",
            "csr"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rnd_add_uint32",
          "args": [
            "&sc->lmc_rndsource",
            "csr"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_CSR_READ",
          "args": [
            "sc",
            "csr_status"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic void\nlmc_intr_handler(lmc_softc_t * const sc, int *progress_p)\n{\n    u_int32_t csr;\n\n    while ((csr = LMC_CSR_READ(sc, csr_status)) & sc->lmc_intrmask) {\n\n#if defined(__NetBSD__)\n#if NRND > 0\n\t    rnd_add_uint32(&sc->lmc_rndsource, csr);\n#endif\n#endif\n\n\t*progress_p = 1;\n\tLMC_CSR_WRITE(sc, csr_status, csr);\n\n\tif (csr & TULIP_STS_SYSERROR) {\n\t    sc->lmc_last_system_error = (csr & TULIP_STS_ERRORMASK) >> TULIP_STS_ERR_SHIFT;\n\t    if (sc->lmc_flags & LMC_NOMESSAGES) {\n\t\tsc->lmc_flags |= LMC_SYSTEMERROR;\n\t    } else {\n\t\tprintf(LMC_PRINTF_FMT \": system error: %s\\n\",\n\t\t       LMC_PRINTF_ARGS,\n\t\t       lmc_system_errors[sc->lmc_last_system_error]);\n\t    }\n\t    sc->lmc_flags |= LMC_NEEDRESET;\n\t    sc->lmc_system_errors++;\n\t    break;\n\t}\n\tif (csr & (TULIP_STS_RXINTR | TULIP_STS_RXNOBUF)) {\n\t    u_int32_t misses = LMC_CSR_READ(sc, csr_missed_frames);\n\t    if (csr & TULIP_STS_RXNOBUF)\n\t\tsc->lmc_dot3stats.dot3StatsMissedFrames += misses & 0xFFFF;\n\t    /*\n\t     * Pass 2.[012] of the 21140A-A[CDE] may hang and/or corrupt data\n\t     * on receive overflows.\n\t     */\n\t   if ((misses & 0x0FFE0000) && (sc->lmc_features & LMC_HAVE_RXBADOVRFLW)) {\n\t\tsc->lmc_dot3stats.dot3StatsInternalMacReceiveErrors++;\n\t\t/*\n\t\t * Stop the receiver process and spin until it's stopped.\n\t\t * Tell rx_intr to drop the packets it dequeues.\n\t\t */\n\t\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode & ~TULIP_CMD_RXRUN);\n\t\twhile ((LMC_CSR_READ(sc, csr_status) & TULIP_STS_RXSTOPPED) == 0)\n\t\t    ;\n\t\tLMC_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\tsc->lmc_flags |= LMC_RXIGNORE;\n\t    }\n\t    lmc_rx_intr(sc);\n\t    if (sc->lmc_flags & LMC_RXIGNORE) {\n\t\t/*\n\t\t * Restart the receiver.\n\t\t */\n\t\tsc->lmc_flags &= ~LMC_RXIGNORE;\n\t\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\t    }\n\t}\n\tif (csr & TULIP_STS_ABNRMLINTR) {\n\t    u_int32_t tmp = csr & sc->lmc_intrmask\n\t\t& ~(TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR);\n\t    if (csr & TULIP_STS_TXUNDERFLOW) {\n\t\tif ((sc->lmc_cmdmode & TULIP_CMD_THRESHOLDCTL) != TULIP_CMD_THRSHLD160) {\n\t\t    sc->lmc_cmdmode += TULIP_CMD_THRSHLD96;\n\t\t    sc->lmc_flags |= LMC_NEWTXTHRESH;\n\t\t} else if (sc->lmc_features & LMC_HAVE_STOREFWD) {\n\t\t    sc->lmc_cmdmode |= TULIP_CMD_STOREFWD;\n\t\t    sc->lmc_flags |= LMC_NEWTXTHRESH;\n\t\t}\n\t    }\n\t    if (sc->lmc_flags & LMC_NOMESSAGES) {\n\t\tsc->lmc_statusbits |= tmp;\n\t    } else {\n\t\tlmc_print_abnormal_interrupt(sc, tmp);\n\t\tsc->lmc_flags |= LMC_NOMESSAGES;\n\t    }\n\t    LMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\t}\n\n\tif (csr & TULIP_STS_TXINTR)\n\t\tlmc_tx_intr(sc);\n\n\tif (sc->lmc_flags & LMC_WANTTXSTART)\n\t    lmc_ifstart(&sc->lmc_if);\n    }\n}"
  },
  {
    "function_name": "lmc_print_abnormal_interrupt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "838-842",
    "snippet": "static void\nlmc_print_abnormal_interrupt (lmc_softc_t * const sc, u_int32_t csr)\n{\n\tprintf(LMC_PRINTF_FMT \": Abnormal interrupt\\n\", LMC_PRINTF_ARGS);\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "LMC_PRINTF_FMT \": Abnormal interrupt\\n\"",
            "LMC_PRINTF_ARGS"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic void\nlmc_print_abnormal_interrupt (lmc_softc_t * const sc, u_int32_t csr)\n{\n\tprintf(LMC_PRINTF_FMT \": Abnormal interrupt\\n\", LMC_PRINTF_ARGS);\n}"
  },
  {
    "function_name": "lmc_rx_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "591-769",
    "snippet": "static void\nlmc_rx_intr(lmc_softc_t * const sc)\n{\n\tlmc_ringinfo_t * const ri = &sc->lmc_rxinfo;\n\tstruct ifnet * const ifp = &sc->lmc_if;\n\tint fillok = 1;\n\n\tsc->lmc_rxtick++;\n\n\tfor (;;) {\n\t\ttulip_desc_t *eop = ri->ri_nextin;\n\t\tint total_len = 0, last_offset = 0;\n\t\tstruct mbuf *ms = NULL, *me = NULL;\n\t\tint accept = 0;\n\n\t\tif (fillok && sc->lmc_rxq.ifq_len < LMC_RXQ_TARGET)\n\t\t\tgoto queue_mbuf;\n\n\t\t/*\n\t\t * If the TULIP has no descriptors, there can't be any receive\n\t\t * descriptors to process.\n\t\t */\n\t\tif (eop == ri->ri_nextout)\n\t\t\tbreak;\n\t    \n\t\t/*\n\t\t * 90% of the packets will fit in one descriptor.  So we\n\t\t * optimize for that case.\n\t\t */\n\t\tif ((((volatile tulip_desc_t *) eop)->d_status & (TULIP_DSTS_OWNER|TULIP_DSTS_RxFIRSTDESC|TULIP_DSTS_RxLASTDESC)) == (TULIP_DSTS_RxFIRSTDESC|TULIP_DSTS_RxLASTDESC)) {\n\t\t\tIF_DEQUEUE(&sc->lmc_rxq, ms);\n\t\t\tme = ms;\n\t\t} else {\n\t\t\t/*\n\t\t\t * If still owned by the TULIP, don't touch it.\n\t\t\t */\n\t\t\tif (((volatile tulip_desc_t *)eop)->d_status & TULIP_DSTS_OWNER)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * It is possible (though improbable unless the\n\t\t\t * BIG_PACKET support is enabled or MCLBYTES < 1518)\n\t\t\t * for a received packet to cross more than one\n\t\t\t * receive descriptor.\n\t\t\t */\n\t\t\twhile ((((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_RxLASTDESC) == 0) {\n\t\t\t\tif (++eop == ri->ri_last)\n\t\t\t\t\teop = ri->ri_first;\n\t\t\t\tif (eop == ri->ri_nextout || ((((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_OWNER))) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttotal_len++;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Dequeue the first buffer for the start of the\n\t\t\t * packet.  Hopefully this will be the only one we\n\t\t\t * need to dequeue.  However, if the packet consumed\n\t\t\t * multiple descriptors, then we need to dequeue\n\t\t\t * those buffers and chain to the starting mbuf.\n\t\t\t * All buffers but the last buffer have the same\n\t\t\t * length so we can set that now. (we add to\n\t\t\t * last_offset instead of multiplying since we\n\t\t\t * normally won't go into the loop and thereby\n\t\t\t * saving a ourselves from doing a multiplication\n\t\t\t * by 0 in the normal case).\n\t\t\t */\n\t\t\tIF_DEQUEUE(&sc->lmc_rxq, ms);\n\t\t\tfor (me = ms; total_len > 0; total_len--) {\n\t\t\t\tme->m_len = LMC_RX_BUFLEN;\n\t\t\t\tlast_offset += LMC_RX_BUFLEN;\n\t\t\t\tIF_DEQUEUE(&sc->lmc_rxq, me->m_next);\n\t\t\t\tme = me->m_next;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *  Now get the size of received packet (minus the CRC).\n\t\t */\n\t\ttotal_len = ((eop->d_status >> 16) & 0x7FFF);\n\t\tif (sc->ictl.crc_length == 16)\n\t\t\ttotal_len -= 2;\n\t\telse\n\t\t\ttotal_len -= 4;\n\n\t\tif ((sc->lmc_flags & LMC_RXIGNORE) == 0\n\t\t    && ((eop->d_status & LMC_DSTS_ERRSUM) == 0\n#ifdef BIG_PACKET\n\t\t\t|| (total_len <= sc->lmc_if.if_mtu + PPP_HEADER_LEN\n\t\t\t    && (eop->d_status & TULIP_DSTS_RxOVERFLOW) == 0)\n#endif\n\t\t\t)) {\n\t\t\tme->m_len = total_len - last_offset;\n#if NBPFILTER > 0\n\t\t\tif (sc->lmc_bpf != NULL) {\n\t\t\t\tif (me == ms)\n\t\t\t\t\tLMC_BPF_TAP(sc, mtod(ms, caddr_t), total_len);\n\t\t\t\telse\n\t\t\t\t\tLMC_BPF_MTAP(sc, ms);\n\t\t\t}\n#endif\n\t\t\tsc->lmc_flags |= LMC_RXACT;\n\t\t\taccept = 1;\n\t\t} else {\n\t\t\tifp->if_ierrors++;\n\t\t\tif (eop->d_status & TULIP_DSTS_RxOVERFLOW) {\n\t\t\t\tsc->lmc_dot3stats.dot3StatsInternalMacReceiveErrors++;\n\t\t\t}\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\tif (++eop == ri->ri_last)\n\t\t\teop = ri->ri_first;\n\t\tri->ri_nextin = eop;\n\n\tqueue_mbuf:\n\t\t/*\n\t\t * Either we are priming the TULIP with mbufs (m == NULL)\n\t\t * or we are about to accept an mbuf for the upper layers\n\t\t * so we need to allocate an mbuf to replace it.  If we\n\t\t * can't replace it, send up it anyways.  This may cause\n\t\t * us to drop packets in the future but that's better than\n\t\t * being caught in livelock.\n\t\t *\n\t\t * Note that if this packet crossed multiple descriptors\n\t\t * we don't even try to reallocate all the mbufs here.\n\t\t * Instead we rely on the test of the beginning of\n\t\t * the loop to refill for the extra consumed mbufs.\n\t\t */\n\t\tif (accept || ms == NULL) {\n\t\t\tstruct mbuf *m0;\n\t\t\tMGETHDR(m0, M_DONTWAIT, MT_DATA);\n\t\t\tif (m0 != NULL) {\n\t\t\t\tMCLGET(m0, M_DONTWAIT);\n\t\t\t\tif ((m0->m_flags & M_EXT) == 0) {\n\t\t\t\t\tm_freem(m0);\n\t\t\t\t\tm0 = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (accept) {\n\t\t\t\tms->m_pkthdr.len = total_len;\n\t\t\t\tms->m_pkthdr.rcvif = ifp;\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\t\t\t\tsppp_input(ifp, ms);\n#endif\n#if defined(__bsdi__)\n\t\t\t\tsc->lmc_p2pcom.p2p_input(&sc->lmc_p2pcom, ms);\n#endif\n\t\t\t}\n\t\t\tms = m0;\n\t\t}\n\t\tif (ms == NULL) {\n\t\t\t/*\n\t\t\t * Couldn't allocate a new buffer.  Don't bother \n\t\t\t * trying to replenish the receive queue.\n\t\t\t */\n\t\t\tfillok = 0;\n\t\t\tsc->lmc_flags |= LMC_RXBUFSLOW;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Now give the buffer(s) to the TULIP and save in our\n\t\t * receive queue.\n\t\t */\n\t\tdo {\n\t\t\tri->ri_nextout->d_length1 = LMC_RX_BUFLEN;\n\t\t\tri->ri_nextout->d_addr1 = LMC_KVATOPHYS(sc, mtod(ms, caddr_t));\n\t\t\tri->ri_nextout->d_status = TULIP_DSTS_OWNER;\n\t\t\tif (++ri->ri_nextout == ri->ri_last)\n\t\t\t\tri->ri_nextout = ri->ri_first;\n\t\t\tme = ms->m_next;\n\t\t\tms->m_next = NULL;\n\t\t\tIF_ENQUEUE(&sc->lmc_rxq, ms);\n\t\t} while ((ms = me) != NULL);\n\n\t\tif (sc->lmc_rxq.ifq_len >= LMC_RXQ_TARGET)\n\t\t\tsc->lmc_flags &= ~LMC_RXBUFSLOW;\n\t}\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define d_length1 u.bd_length1"
    ],
    "globals_used": [
      "static ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);",
      "static ifnet_ret_t lmc_ifstart(struct ifnet *ifp);",
      "static struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);",
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IF_ENQUEUE",
          "args": [
            "&sc->lmc_rxq",
            "ms"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_KVATOPHYS",
          "args": [
            "sc",
            "mtod(ms, caddr_t)"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "ms",
            "caddr_t"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->lmc_p2pcom.p2p_input",
          "args": [
            "&sc->lmc_p2pcom",
            "ms"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sppp_input",
          "args": [
            "ifp",
            "ms"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m0",
            "M_DONTWAIT"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m0",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_BPF_MTAP",
          "args": [
            "sc",
            "ms"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_BPF_TAP",
          "args": [
            "sc",
            "mtod(ms, caddr_t)",
            "total_len"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "ms",
            "caddr_t"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&sc->lmc_rxq",
            "me->m_next"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&sc->lmc_rxq",
            "ms"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&sc->lmc_rxq",
            "ms"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define d_length1 u.bd_length1\n\nstatic ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);\nstatic ifnet_ret_t lmc_ifstart(struct ifnet *ifp);\nstatic struct mbuf *lmc_txput(lmc_softc_t * const sc, struct mbuf *m);\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic void\nlmc_rx_intr(lmc_softc_t * const sc)\n{\n\tlmc_ringinfo_t * const ri = &sc->lmc_rxinfo;\n\tstruct ifnet * const ifp = &sc->lmc_if;\n\tint fillok = 1;\n\n\tsc->lmc_rxtick++;\n\n\tfor (;;) {\n\t\ttulip_desc_t *eop = ri->ri_nextin;\n\t\tint total_len = 0, last_offset = 0;\n\t\tstruct mbuf *ms = NULL, *me = NULL;\n\t\tint accept = 0;\n\n\t\tif (fillok && sc->lmc_rxq.ifq_len < LMC_RXQ_TARGET)\n\t\t\tgoto queue_mbuf;\n\n\t\t/*\n\t\t * If the TULIP has no descriptors, there can't be any receive\n\t\t * descriptors to process.\n\t\t */\n\t\tif (eop == ri->ri_nextout)\n\t\t\tbreak;\n\t    \n\t\t/*\n\t\t * 90% of the packets will fit in one descriptor.  So we\n\t\t * optimize for that case.\n\t\t */\n\t\tif ((((volatile tulip_desc_t *) eop)->d_status & (TULIP_DSTS_OWNER|TULIP_DSTS_RxFIRSTDESC|TULIP_DSTS_RxLASTDESC)) == (TULIP_DSTS_RxFIRSTDESC|TULIP_DSTS_RxLASTDESC)) {\n\t\t\tIF_DEQUEUE(&sc->lmc_rxq, ms);\n\t\t\tme = ms;\n\t\t} else {\n\t\t\t/*\n\t\t\t * If still owned by the TULIP, don't touch it.\n\t\t\t */\n\t\t\tif (((volatile tulip_desc_t *)eop)->d_status & TULIP_DSTS_OWNER)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * It is possible (though improbable unless the\n\t\t\t * BIG_PACKET support is enabled or MCLBYTES < 1518)\n\t\t\t * for a received packet to cross more than one\n\t\t\t * receive descriptor.\n\t\t\t */\n\t\t\twhile ((((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_RxLASTDESC) == 0) {\n\t\t\t\tif (++eop == ri->ri_last)\n\t\t\t\t\teop = ri->ri_first;\n\t\t\t\tif (eop == ri->ri_nextout || ((((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_OWNER))) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttotal_len++;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Dequeue the first buffer for the start of the\n\t\t\t * packet.  Hopefully this will be the only one we\n\t\t\t * need to dequeue.  However, if the packet consumed\n\t\t\t * multiple descriptors, then we need to dequeue\n\t\t\t * those buffers and chain to the starting mbuf.\n\t\t\t * All buffers but the last buffer have the same\n\t\t\t * length so we can set that now. (we add to\n\t\t\t * last_offset instead of multiplying since we\n\t\t\t * normally won't go into the loop and thereby\n\t\t\t * saving a ourselves from doing a multiplication\n\t\t\t * by 0 in the normal case).\n\t\t\t */\n\t\t\tIF_DEQUEUE(&sc->lmc_rxq, ms);\n\t\t\tfor (me = ms; total_len > 0; total_len--) {\n\t\t\t\tme->m_len = LMC_RX_BUFLEN;\n\t\t\t\tlast_offset += LMC_RX_BUFLEN;\n\t\t\t\tIF_DEQUEUE(&sc->lmc_rxq, me->m_next);\n\t\t\t\tme = me->m_next;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *  Now get the size of received packet (minus the CRC).\n\t\t */\n\t\ttotal_len = ((eop->d_status >> 16) & 0x7FFF);\n\t\tif (sc->ictl.crc_length == 16)\n\t\t\ttotal_len -= 2;\n\t\telse\n\t\t\ttotal_len -= 4;\n\n\t\tif ((sc->lmc_flags & LMC_RXIGNORE) == 0\n\t\t    && ((eop->d_status & LMC_DSTS_ERRSUM) == 0\n#ifdef BIG_PACKET\n\t\t\t|| (total_len <= sc->lmc_if.if_mtu + PPP_HEADER_LEN\n\t\t\t    && (eop->d_status & TULIP_DSTS_RxOVERFLOW) == 0)\n#endif\n\t\t\t)) {\n\t\t\tme->m_len = total_len - last_offset;\n#if NBPFILTER > 0\n\t\t\tif (sc->lmc_bpf != NULL) {\n\t\t\t\tif (me == ms)\n\t\t\t\t\tLMC_BPF_TAP(sc, mtod(ms, caddr_t), total_len);\n\t\t\t\telse\n\t\t\t\t\tLMC_BPF_MTAP(sc, ms);\n\t\t\t}\n#endif\n\t\t\tsc->lmc_flags |= LMC_RXACT;\n\t\t\taccept = 1;\n\t\t} else {\n\t\t\tifp->if_ierrors++;\n\t\t\tif (eop->d_status & TULIP_DSTS_RxOVERFLOW) {\n\t\t\t\tsc->lmc_dot3stats.dot3StatsInternalMacReceiveErrors++;\n\t\t\t}\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\tif (++eop == ri->ri_last)\n\t\t\teop = ri->ri_first;\n\t\tri->ri_nextin = eop;\n\n\tqueue_mbuf:\n\t\t/*\n\t\t * Either we are priming the TULIP with mbufs (m == NULL)\n\t\t * or we are about to accept an mbuf for the upper layers\n\t\t * so we need to allocate an mbuf to replace it.  If we\n\t\t * can't replace it, send up it anyways.  This may cause\n\t\t * us to drop packets in the future but that's better than\n\t\t * being caught in livelock.\n\t\t *\n\t\t * Note that if this packet crossed multiple descriptors\n\t\t * we don't even try to reallocate all the mbufs here.\n\t\t * Instead we rely on the test of the beginning of\n\t\t * the loop to refill for the extra consumed mbufs.\n\t\t */\n\t\tif (accept || ms == NULL) {\n\t\t\tstruct mbuf *m0;\n\t\t\tMGETHDR(m0, M_DONTWAIT, MT_DATA);\n\t\t\tif (m0 != NULL) {\n\t\t\t\tMCLGET(m0, M_DONTWAIT);\n\t\t\t\tif ((m0->m_flags & M_EXT) == 0) {\n\t\t\t\t\tm_freem(m0);\n\t\t\t\t\tm0 = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (accept) {\n\t\t\t\tms->m_pkthdr.len = total_len;\n\t\t\t\tms->m_pkthdr.rcvif = ifp;\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\t\t\t\tsppp_input(ifp, ms);\n#endif\n#if defined(__bsdi__)\n\t\t\t\tsc->lmc_p2pcom.p2p_input(&sc->lmc_p2pcom, ms);\n#endif\n\t\t\t}\n\t\t\tms = m0;\n\t\t}\n\t\tif (ms == NULL) {\n\t\t\t/*\n\t\t\t * Couldn't allocate a new buffer.  Don't bother \n\t\t\t * trying to replenish the receive queue.\n\t\t\t */\n\t\t\tfillok = 0;\n\t\t\tsc->lmc_flags |= LMC_RXBUFSLOW;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Now give the buffer(s) to the TULIP and save in our\n\t\t * receive queue.\n\t\t */\n\t\tdo {\n\t\t\tri->ri_nextout->d_length1 = LMC_RX_BUFLEN;\n\t\t\tri->ri_nextout->d_addr1 = LMC_KVATOPHYS(sc, mtod(ms, caddr_t));\n\t\t\tri->ri_nextout->d_status = TULIP_DSTS_OWNER;\n\t\t\tif (++ri->ri_nextout == ri->ri_last)\n\t\t\t\tri->ri_nextout = ri->ri_first;\n\t\t\tme = ms->m_next;\n\t\t\tms->m_next = NULL;\n\t\t\tIF_ENQUEUE(&sc->lmc_rxq, ms);\n\t\t} while ((ms = me) != NULL);\n\n\t\tif (sc->lmc_rxq.ifq_len >= LMC_RXQ_TARGET)\n\t\t\tsc->lmc_flags &= ~LMC_RXBUFSLOW;\n\t}\n}"
  },
  {
    "function_name": "lmc_ifdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "577-589",
    "snippet": "static void\nlmc_ifdown(lmc_softc_t * const sc)\n{\n\tsc->lmc_if.if_timer = 0;\n\tsc->lmc_flags &= ~LMC_IFUP;\n\n\tsc->lmc_media->set_link_status(sc, LMC_LINK_DOWN);\n\tlmc_led_off(sc, LMC_MII16_LED_ALL);\n\n\tlmc_dec_reset(sc);\n\tlmc_reset(sc);\n\tsc->lmc_media->set_status(sc, NULL);\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->lmc_media->set_status",
          "args": [
            "sc",
            "NULL"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmc_reset",
          "args": [
            "sc"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc_common.c",
          "lines": "207-248",
          "snippet": "void\nlmc_reset(lmc_softc_t * const sc)\n{\n\tsc->lmc_miireg16 |= LMC_MII16_FIFO_RESET;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n\n\tsc->lmc_miireg16 &= ~LMC_MII16_FIFO_RESET;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n\n\t/*\n\t * make some of the GPIO pins be outputs\n\t */\n\tlmc_gpio_mkoutput(sc, LMC_GEP_DP | LMC_GEP_RESET);\n\n\t/*\n\t * drive DP and RESET low to force configuration.  This also forces\n\t * the transmitter clock to be internal, but we expect to reset\n\t * that later anyway.\n\t */\n\tsc->lmc_gpio &= ~(LMC_GEP_DP | LMC_GEP_RESET);\n\tLMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);\n\n\t/*\n\t * hold for more than 10 microseconds\n\t */\n\tDELAY(50);\n\n\t/*\n\t * stop driving Xilinx-related signals\n\t */\n\tlmc_gpio_mkinput(sc, LMC_GEP_DP | LMC_GEP_RESET);\n\n\t/*\n\t * busy wait for the chip to reset\n\t */\n\twhile ((LMC_CSR_READ(sc, csr_gp) & LMC_GEP_DP) == 0);\n\n\t/*\n\t * Call media specific init routine\n\t */\n\tsc->lmc_media->init(sc);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmc_types.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmc_types.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nlmc_reset(lmc_softc_t * const sc)\n{\n\tsc->lmc_miireg16 |= LMC_MII16_FIFO_RESET;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n\n\tsc->lmc_miireg16 &= ~LMC_MII16_FIFO_RESET;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n\n\t/*\n\t * make some of the GPIO pins be outputs\n\t */\n\tlmc_gpio_mkoutput(sc, LMC_GEP_DP | LMC_GEP_RESET);\n\n\t/*\n\t * drive DP and RESET low to force configuration.  This also forces\n\t * the transmitter clock to be internal, but we expect to reset\n\t * that later anyway.\n\t */\n\tsc->lmc_gpio &= ~(LMC_GEP_DP | LMC_GEP_RESET);\n\tLMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);\n\n\t/*\n\t * hold for more than 10 microseconds\n\t */\n\tDELAY(50);\n\n\t/*\n\t * stop driving Xilinx-related signals\n\t */\n\tlmc_gpio_mkinput(sc, LMC_GEP_DP | LMC_GEP_RESET);\n\n\t/*\n\t * busy wait for the chip to reset\n\t */\n\twhile ((LMC_CSR_READ(sc, csr_gp) & LMC_GEP_DP) == 0);\n\n\t/*\n\t * Call media specific init routine\n\t */\n\tsc->lmc_media->init(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmc_dec_reset",
          "args": [
            "sc"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_dec_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc_common.c",
          "lines": "250-386",
          "snippet": "void\nlmc_dec_reset(lmc_softc_t * const sc)\n{\n#ifndef __linux__\n\tlmc_ringinfo_t *ri;\n\ttulip_desc_t *di;\n#endif\n\tu_int32_t val;\n\n\t/*\n\t * disable all interrupts\n\t */\n\tsc->lmc_intrmask = 0;\n\tLMC_CSR_WRITE(sc, csr_intr, sc->lmc_intrmask);\n\n\t/*\n\t * we are, obviously, down.\n\t */\n#ifndef __linux__\n\tsc->lmc_flags &= ~(LMC_IFUP | LMC_MODEMOK);\n\n\tDP((\"lmc_dec_reset\\n\"));\n#endif\n\n\t/*\n\t * Reset the chip with a software reset command.\n\t * Wait 10 microseconds (actually 50 PCI cycles but at \n\t * 33MHz that comes to two microseconds but wait a\n\t * bit longer anyways)\n\t */\n\tLMC_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n\tDELAY(10);\n\tsc->lmc_cmdmode = LMC_CSR_READ(sc, csr_command);\n\n\t/*\n\t * We want:\n\t *   no ethernet address in frames we write\n\t *   disable padding (txdesc, padding disable)\n\t *   ignore runt frames (rdes0 bit 15)\n\t *   no receiver watchdog or transmitter jabber timer\n\t *       (csr15 bit 0,14 == 1)\n\t *   if using 16-bit CRC, turn off CRC (trans desc, crc disable)\n\t */\n\n#ifndef TULIP_CMD_RECEIVEALL\n#define TULIP_CMD_RECEIVEALL 0x40000000L\n#endif\n\n\tsc->lmc_cmdmode |= ( TULIP_CMD_PROMISCUOUS\n\t\t\t       | TULIP_CMD_FULLDUPLEX\n\t\t\t       | TULIP_CMD_PASSBADPKT\n\t\t\t       | TULIP_CMD_NOHEARTBEAT\n\t\t\t       | TULIP_CMD_PORTSELECT\n\t\t\t       | TULIP_CMD_RECEIVEALL\n\t\t\t       | TULIP_CMD_MUSTBEONE\n\t\t\t       );\n\tsc->lmc_cmdmode &= ~( TULIP_CMD_OPERMODE\n\t\t\t\t| TULIP_CMD_THRESHOLDCTL\n\t\t\t\t| TULIP_CMD_STOREFWD\n\t\t\t\t| TULIP_CMD_TXTHRSHLDCTL\n\t\t\t\t);\n\n\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\n\t/*\n\t * disable receiver watchdog and transmit jabber\n\t */\n\tval = LMC_CSR_READ(sc, csr_sia_general);\n\tval |= (TULIP_WATCHDOG_TXDISABLE | TULIP_WATCHDOG_RXDISABLE);\n\tLMC_CSR_WRITE(sc, csr_sia_general, val);\n\n\t/*\n\t * turn off those LEDs...\n\t */\n\tsc->lmc_miireg16 |= LMC_MII16_LED_ALL;\n\tlmc_led_on(sc, LMC_MII16_LED0);\n\n#ifndef __linux__\n\t/*\n\t * reprogram the tx desc, rx desc, and PCI bus options\n\t */\n\tLMC_CSR_WRITE(sc, csr_txlist,\n\t\t\tLMC_KVATOPHYS(sc, &sc->lmc_txinfo.ri_first[0]));\n\tLMC_CSR_WRITE(sc, csr_rxlist,\n\t\t\tLMC_KVATOPHYS(sc, &sc->lmc_rxinfo.ri_first[0]));\n\tLMC_CSR_WRITE(sc, csr_busmode,\n\t\t\t(1 << (LMC_BURSTSIZE(sc->lmc_unit) + 8))\n\t\t\t|TULIP_BUSMODE_CACHE_ALIGN8\n\t\t\t|TULIP_BUSMODE_READMULTIPLE\n\t\t\t|(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_BIGENDIAN : 0));\n\n\tsc->lmc_txq.ifq_maxlen = LMC_TXDESCS;\n\n\t/*\n\t * Free all the mbufs that were on the transmit ring.\n\t */\n\tfor (;;) {\n\t\tstruct mbuf *m;\n\n\t\tIF_DEQUEUE(&sc->lmc_txq, m);\n\t\tif (m == NULL)\n\t\t\tbreak;\n\t\tm_freem(m);\n\t}\n\n\t/*\n\t * reset descriptor state and reclaim all descriptors.\n\t */\n\tri = &sc->lmc_txinfo;\n\tri->ri_nextin = ri->ri_nextout = ri->ri_first;\n\tri->ri_free = ri->ri_max;\n\tfor (di = ri->ri_first; di < ri->ri_last; di++)\n\t\tdi->d_status = 0;\n\n\t/*\n\t * We need to collect all the mbufs were on the \n\t * receive ring before we reinit it either to put\n\t * them back on or to know if we have to allocate\n\t * more.\n\t */\n\tri = &sc->lmc_rxinfo;\n\tri->ri_nextin = ri->ri_nextout = ri->ri_first;\n\tri->ri_free = ri->ri_max;\n\tfor (di = ri->ri_first; di < ri->ri_last; di++) {\n\t\tdi->d_status = 0;\n\t\tdi->d_length1 = 0; di->d_addr1 = 0;\n\t\tdi->d_length2 = 0; di->d_addr2 = 0;\n\t}\n\tfor (;;) {\n\t\tstruct mbuf *m;\n\t\tIF_DEQUEUE(&sc->lmc_rxq, m);\n\t\tif (m == NULL)\n\t\t\tbreak;\n\t\tm_freem(m);\n\t}\n#endif\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmc_types.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_CMD_RECEIVEALL 0x40000000L",
            "#define d_length2 u.bd_length2",
            "#define d_length1 u.bd_length1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmc_types.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_CMD_RECEIVEALL 0x40000000L\n#define d_length2 u.bd_length2\n#define d_length1 u.bd_length1\n\nvoid\nlmc_dec_reset(lmc_softc_t * const sc)\n{\n#ifndef __linux__\n\tlmc_ringinfo_t *ri;\n\ttulip_desc_t *di;\n#endif\n\tu_int32_t val;\n\n\t/*\n\t * disable all interrupts\n\t */\n\tsc->lmc_intrmask = 0;\n\tLMC_CSR_WRITE(sc, csr_intr, sc->lmc_intrmask);\n\n\t/*\n\t * we are, obviously, down.\n\t */\n#ifndef __linux__\n\tsc->lmc_flags &= ~(LMC_IFUP | LMC_MODEMOK);\n\n\tDP((\"lmc_dec_reset\\n\"));\n#endif\n\n\t/*\n\t * Reset the chip with a software reset command.\n\t * Wait 10 microseconds (actually 50 PCI cycles but at \n\t * 33MHz that comes to two microseconds but wait a\n\t * bit longer anyways)\n\t */\n\tLMC_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n\tDELAY(10);\n\tsc->lmc_cmdmode = LMC_CSR_READ(sc, csr_command);\n\n\t/*\n\t * We want:\n\t *   no ethernet address in frames we write\n\t *   disable padding (txdesc, padding disable)\n\t *   ignore runt frames (rdes0 bit 15)\n\t *   no receiver watchdog or transmitter jabber timer\n\t *       (csr15 bit 0,14 == 1)\n\t *   if using 16-bit CRC, turn off CRC (trans desc, crc disable)\n\t */\n\n#ifndef TULIP_CMD_RECEIVEALL\n#define TULIP_CMD_RECEIVEALL 0x40000000L\n#endif\n\n\tsc->lmc_cmdmode |= ( TULIP_CMD_PROMISCUOUS\n\t\t\t       | TULIP_CMD_FULLDUPLEX\n\t\t\t       | TULIP_CMD_PASSBADPKT\n\t\t\t       | TULIP_CMD_NOHEARTBEAT\n\t\t\t       | TULIP_CMD_PORTSELECT\n\t\t\t       | TULIP_CMD_RECEIVEALL\n\t\t\t       | TULIP_CMD_MUSTBEONE\n\t\t\t       );\n\tsc->lmc_cmdmode &= ~( TULIP_CMD_OPERMODE\n\t\t\t\t| TULIP_CMD_THRESHOLDCTL\n\t\t\t\t| TULIP_CMD_STOREFWD\n\t\t\t\t| TULIP_CMD_TXTHRSHLDCTL\n\t\t\t\t);\n\n\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\n\t/*\n\t * disable receiver watchdog and transmit jabber\n\t */\n\tval = LMC_CSR_READ(sc, csr_sia_general);\n\tval |= (TULIP_WATCHDOG_TXDISABLE | TULIP_WATCHDOG_RXDISABLE);\n\tLMC_CSR_WRITE(sc, csr_sia_general, val);\n\n\t/*\n\t * turn off those LEDs...\n\t */\n\tsc->lmc_miireg16 |= LMC_MII16_LED_ALL;\n\tlmc_led_on(sc, LMC_MII16_LED0);\n\n#ifndef __linux__\n\t/*\n\t * reprogram the tx desc, rx desc, and PCI bus options\n\t */\n\tLMC_CSR_WRITE(sc, csr_txlist,\n\t\t\tLMC_KVATOPHYS(sc, &sc->lmc_txinfo.ri_first[0]));\n\tLMC_CSR_WRITE(sc, csr_rxlist,\n\t\t\tLMC_KVATOPHYS(sc, &sc->lmc_rxinfo.ri_first[0]));\n\tLMC_CSR_WRITE(sc, csr_busmode,\n\t\t\t(1 << (LMC_BURSTSIZE(sc->lmc_unit) + 8))\n\t\t\t|TULIP_BUSMODE_CACHE_ALIGN8\n\t\t\t|TULIP_BUSMODE_READMULTIPLE\n\t\t\t|(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_BIGENDIAN : 0));\n\n\tsc->lmc_txq.ifq_maxlen = LMC_TXDESCS;\n\n\t/*\n\t * Free all the mbufs that were on the transmit ring.\n\t */\n\tfor (;;) {\n\t\tstruct mbuf *m;\n\n\t\tIF_DEQUEUE(&sc->lmc_txq, m);\n\t\tif (m == NULL)\n\t\t\tbreak;\n\t\tm_freem(m);\n\t}\n\n\t/*\n\t * reset descriptor state and reclaim all descriptors.\n\t */\n\tri = &sc->lmc_txinfo;\n\tri->ri_nextin = ri->ri_nextout = ri->ri_first;\n\tri->ri_free = ri->ri_max;\n\tfor (di = ri->ri_first; di < ri->ri_last; di++)\n\t\tdi->d_status = 0;\n\n\t/*\n\t * We need to collect all the mbufs were on the \n\t * receive ring before we reinit it either to put\n\t * them back on or to know if we have to allocate\n\t * more.\n\t */\n\tri = &sc->lmc_rxinfo;\n\tri->ri_nextin = ri->ri_nextout = ri->ri_first;\n\tri->ri_free = ri->ri_max;\n\tfor (di = ri->ri_first; di < ri->ri_last; di++) {\n\t\tdi->d_status = 0;\n\t\tdi->d_length1 = 0; di->d_addr1 = 0;\n\t\tdi->d_length2 = 0; di->d_addr2 = 0;\n\t}\n\tfor (;;) {\n\t\tstruct mbuf *m;\n\t\tIF_DEQUEUE(&sc->lmc_rxq, m);\n\t\tif (m == NULL)\n\t\t\tbreak;\n\t\tm_freem(m);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmc_led_off",
          "args": [
            "sc",
            "LMC_MII16_LED_ALL"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_led_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc_common.c",
          "lines": "200-205",
          "snippet": "void\nlmc_led_off(lmc_softc_t * const sc, u_int32_t led)\n{\n\tsc->lmc_miireg16 |= led;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmc_types.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmc_types.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nlmc_led_off(lmc_softc_t * const sc, u_int32_t led)\n{\n\tsc->lmc_miireg16 |= led;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->lmc_media->set_link_status",
          "args": [
            "sc",
            "LMC_LINK_DOWN"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic void\nlmc_ifdown(lmc_softc_t * const sc)\n{\n\tsc->lmc_if.if_timer = 0;\n\tsc->lmc_flags &= ~LMC_IFUP;\n\n\tsc->lmc_media->set_link_status(sc, LMC_LINK_DOWN);\n\tlmc_led_off(sc, LMC_MII16_LED_ALL);\n\n\tlmc_dec_reset(sc);\n\tlmc_reset(sc);\n\tsc->lmc_media->set_status(sc, NULL);\n}"
  },
  {
    "function_name": "lmc_ifup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "530-571",
    "snippet": "static void\nlmc_ifup(lmc_softc_t * const sc)\n{\n\tsc->lmc_if.if_timer = 0;\n\n\tlmc_dec_reset(sc);\n\tlmc_reset(sc);\n\n\tsc->lmc_media->set_link_status(sc, LMC_LINK_UP);\n\tsc->lmc_media->set_status(sc, NULL);\n\n\tsc->lmc_flags |= LMC_IFUP;\n\n\t/*\n\t * for DS3 & DS1 adapters light the green light, led2\n\t */\n\tif (sc->lmc_cardtype == LMC_CARDTYPE_DS3 ||\n\t    sc->lmc_cardtype == LMC_CARDTYPE_T1)\n\t\tlmc_led_on (sc, LMC_MII16_LED2);\n\telse\n\t\tlmc_led_on (sc, LMC_MII16_LED0 | LMC_MII16_LED2);\n\n\t/*\n\t * select what interrupts we want to get\n\t */\n\tsc->lmc_intrmask |= (TULIP_STS_NORMALINTR\n\t\t\t       | TULIP_STS_RXINTR\n\t\t\t       | TULIP_STS_TXINTR\n\t\t\t       | TULIP_STS_ABNRMLINTR\n\t\t\t       | TULIP_STS_SYSERROR\n\t\t\t       | TULIP_STS_TXSTOPPED\n\t\t\t       | TULIP_STS_TXUNDERFLOW\n\t\t\t       | TULIP_STS_RXSTOPPED\n\t\t\t       );\n\tLMC_CSR_WRITE(sc, csr_intr, sc->lmc_intrmask);\n\n\tsc->lmc_cmdmode |= TULIP_CMD_TXRUN;\n\tsc->lmc_cmdmode |= TULIP_CMD_RXRUN;\n\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\n\tsc->lmc_if.if_timer = 1;\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LMC_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "sc->lmc_cmdmode"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_CSR_WRITE",
          "args": [
            "sc",
            "csr_intr",
            "sc->lmc_intrmask"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmc_led_on",
          "args": [
            "sc",
            "LMC_MII16_LED0 | LMC_MII16_LED2"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_led_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc_common.c",
          "lines": "193-198",
          "snippet": "void\nlmc_led_on(lmc_softc_t * const sc, u_int32_t led)\n{\n\tsc->lmc_miireg16 &= ~led;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmc_types.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmc_types.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nlmc_led_on(lmc_softc_t * const sc, u_int32_t led)\n{\n\tsc->lmc_miireg16 &= ~led;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->lmc_media->set_status",
          "args": [
            "sc",
            "NULL"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->lmc_media->set_link_status",
          "args": [
            "sc",
            "LMC_LINK_UP"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmc_reset",
          "args": [
            "sc"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc_common.c",
          "lines": "207-248",
          "snippet": "void\nlmc_reset(lmc_softc_t * const sc)\n{\n\tsc->lmc_miireg16 |= LMC_MII16_FIFO_RESET;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n\n\tsc->lmc_miireg16 &= ~LMC_MII16_FIFO_RESET;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n\n\t/*\n\t * make some of the GPIO pins be outputs\n\t */\n\tlmc_gpio_mkoutput(sc, LMC_GEP_DP | LMC_GEP_RESET);\n\n\t/*\n\t * drive DP and RESET low to force configuration.  This also forces\n\t * the transmitter clock to be internal, but we expect to reset\n\t * that later anyway.\n\t */\n\tsc->lmc_gpio &= ~(LMC_GEP_DP | LMC_GEP_RESET);\n\tLMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);\n\n\t/*\n\t * hold for more than 10 microseconds\n\t */\n\tDELAY(50);\n\n\t/*\n\t * stop driving Xilinx-related signals\n\t */\n\tlmc_gpio_mkinput(sc, LMC_GEP_DP | LMC_GEP_RESET);\n\n\t/*\n\t * busy wait for the chip to reset\n\t */\n\twhile ((LMC_CSR_READ(sc, csr_gp) & LMC_GEP_DP) == 0);\n\n\t/*\n\t * Call media specific init routine\n\t */\n\tsc->lmc_media->init(sc);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmc_types.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmc_types.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nlmc_reset(lmc_softc_t * const sc)\n{\n\tsc->lmc_miireg16 |= LMC_MII16_FIFO_RESET;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n\n\tsc->lmc_miireg16 &= ~LMC_MII16_FIFO_RESET;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n\n\t/*\n\t * make some of the GPIO pins be outputs\n\t */\n\tlmc_gpio_mkoutput(sc, LMC_GEP_DP | LMC_GEP_RESET);\n\n\t/*\n\t * drive DP and RESET low to force configuration.  This also forces\n\t * the transmitter clock to be internal, but we expect to reset\n\t * that later anyway.\n\t */\n\tsc->lmc_gpio &= ~(LMC_GEP_DP | LMC_GEP_RESET);\n\tLMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);\n\n\t/*\n\t * hold for more than 10 microseconds\n\t */\n\tDELAY(50);\n\n\t/*\n\t * stop driving Xilinx-related signals\n\t */\n\tlmc_gpio_mkinput(sc, LMC_GEP_DP | LMC_GEP_RESET);\n\n\t/*\n\t * busy wait for the chip to reset\n\t */\n\twhile ((LMC_CSR_READ(sc, csr_gp) & LMC_GEP_DP) == 0);\n\n\t/*\n\t * Call media specific init routine\n\t */\n\tsc->lmc_media->init(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmc_dec_reset",
          "args": [
            "sc"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_dec_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc_common.c",
          "lines": "250-386",
          "snippet": "void\nlmc_dec_reset(lmc_softc_t * const sc)\n{\n#ifndef __linux__\n\tlmc_ringinfo_t *ri;\n\ttulip_desc_t *di;\n#endif\n\tu_int32_t val;\n\n\t/*\n\t * disable all interrupts\n\t */\n\tsc->lmc_intrmask = 0;\n\tLMC_CSR_WRITE(sc, csr_intr, sc->lmc_intrmask);\n\n\t/*\n\t * we are, obviously, down.\n\t */\n#ifndef __linux__\n\tsc->lmc_flags &= ~(LMC_IFUP | LMC_MODEMOK);\n\n\tDP((\"lmc_dec_reset\\n\"));\n#endif\n\n\t/*\n\t * Reset the chip with a software reset command.\n\t * Wait 10 microseconds (actually 50 PCI cycles but at \n\t * 33MHz that comes to two microseconds but wait a\n\t * bit longer anyways)\n\t */\n\tLMC_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n\tDELAY(10);\n\tsc->lmc_cmdmode = LMC_CSR_READ(sc, csr_command);\n\n\t/*\n\t * We want:\n\t *   no ethernet address in frames we write\n\t *   disable padding (txdesc, padding disable)\n\t *   ignore runt frames (rdes0 bit 15)\n\t *   no receiver watchdog or transmitter jabber timer\n\t *       (csr15 bit 0,14 == 1)\n\t *   if using 16-bit CRC, turn off CRC (trans desc, crc disable)\n\t */\n\n#ifndef TULIP_CMD_RECEIVEALL\n#define TULIP_CMD_RECEIVEALL 0x40000000L\n#endif\n\n\tsc->lmc_cmdmode |= ( TULIP_CMD_PROMISCUOUS\n\t\t\t       | TULIP_CMD_FULLDUPLEX\n\t\t\t       | TULIP_CMD_PASSBADPKT\n\t\t\t       | TULIP_CMD_NOHEARTBEAT\n\t\t\t       | TULIP_CMD_PORTSELECT\n\t\t\t       | TULIP_CMD_RECEIVEALL\n\t\t\t       | TULIP_CMD_MUSTBEONE\n\t\t\t       );\n\tsc->lmc_cmdmode &= ~( TULIP_CMD_OPERMODE\n\t\t\t\t| TULIP_CMD_THRESHOLDCTL\n\t\t\t\t| TULIP_CMD_STOREFWD\n\t\t\t\t| TULIP_CMD_TXTHRSHLDCTL\n\t\t\t\t);\n\n\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\n\t/*\n\t * disable receiver watchdog and transmit jabber\n\t */\n\tval = LMC_CSR_READ(sc, csr_sia_general);\n\tval |= (TULIP_WATCHDOG_TXDISABLE | TULIP_WATCHDOG_RXDISABLE);\n\tLMC_CSR_WRITE(sc, csr_sia_general, val);\n\n\t/*\n\t * turn off those LEDs...\n\t */\n\tsc->lmc_miireg16 |= LMC_MII16_LED_ALL;\n\tlmc_led_on(sc, LMC_MII16_LED0);\n\n#ifndef __linux__\n\t/*\n\t * reprogram the tx desc, rx desc, and PCI bus options\n\t */\n\tLMC_CSR_WRITE(sc, csr_txlist,\n\t\t\tLMC_KVATOPHYS(sc, &sc->lmc_txinfo.ri_first[0]));\n\tLMC_CSR_WRITE(sc, csr_rxlist,\n\t\t\tLMC_KVATOPHYS(sc, &sc->lmc_rxinfo.ri_first[0]));\n\tLMC_CSR_WRITE(sc, csr_busmode,\n\t\t\t(1 << (LMC_BURSTSIZE(sc->lmc_unit) + 8))\n\t\t\t|TULIP_BUSMODE_CACHE_ALIGN8\n\t\t\t|TULIP_BUSMODE_READMULTIPLE\n\t\t\t|(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_BIGENDIAN : 0));\n\n\tsc->lmc_txq.ifq_maxlen = LMC_TXDESCS;\n\n\t/*\n\t * Free all the mbufs that were on the transmit ring.\n\t */\n\tfor (;;) {\n\t\tstruct mbuf *m;\n\n\t\tIF_DEQUEUE(&sc->lmc_txq, m);\n\t\tif (m == NULL)\n\t\t\tbreak;\n\t\tm_freem(m);\n\t}\n\n\t/*\n\t * reset descriptor state and reclaim all descriptors.\n\t */\n\tri = &sc->lmc_txinfo;\n\tri->ri_nextin = ri->ri_nextout = ri->ri_first;\n\tri->ri_free = ri->ri_max;\n\tfor (di = ri->ri_first; di < ri->ri_last; di++)\n\t\tdi->d_status = 0;\n\n\t/*\n\t * We need to collect all the mbufs were on the \n\t * receive ring before we reinit it either to put\n\t * them back on or to know if we have to allocate\n\t * more.\n\t */\n\tri = &sc->lmc_rxinfo;\n\tri->ri_nextin = ri->ri_nextout = ri->ri_first;\n\tri->ri_free = ri->ri_max;\n\tfor (di = ri->ri_first; di < ri->ri_last; di++) {\n\t\tdi->d_status = 0;\n\t\tdi->d_length1 = 0; di->d_addr1 = 0;\n\t\tdi->d_length2 = 0; di->d_addr2 = 0;\n\t}\n\tfor (;;) {\n\t\tstruct mbuf *m;\n\t\tIF_DEQUEUE(&sc->lmc_rxq, m);\n\t\tif (m == NULL)\n\t\t\tbreak;\n\t\tm_freem(m);\n\t}\n#endif\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmc_types.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_CMD_RECEIVEALL 0x40000000L",
            "#define d_length2 u.bd_length2",
            "#define d_length1 u.bd_length1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmc_types.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_CMD_RECEIVEALL 0x40000000L\n#define d_length2 u.bd_length2\n#define d_length1 u.bd_length1\n\nvoid\nlmc_dec_reset(lmc_softc_t * const sc)\n{\n#ifndef __linux__\n\tlmc_ringinfo_t *ri;\n\ttulip_desc_t *di;\n#endif\n\tu_int32_t val;\n\n\t/*\n\t * disable all interrupts\n\t */\n\tsc->lmc_intrmask = 0;\n\tLMC_CSR_WRITE(sc, csr_intr, sc->lmc_intrmask);\n\n\t/*\n\t * we are, obviously, down.\n\t */\n#ifndef __linux__\n\tsc->lmc_flags &= ~(LMC_IFUP | LMC_MODEMOK);\n\n\tDP((\"lmc_dec_reset\\n\"));\n#endif\n\n\t/*\n\t * Reset the chip with a software reset command.\n\t * Wait 10 microseconds (actually 50 PCI cycles but at \n\t * 33MHz that comes to two microseconds but wait a\n\t * bit longer anyways)\n\t */\n\tLMC_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n\tDELAY(10);\n\tsc->lmc_cmdmode = LMC_CSR_READ(sc, csr_command);\n\n\t/*\n\t * We want:\n\t *   no ethernet address in frames we write\n\t *   disable padding (txdesc, padding disable)\n\t *   ignore runt frames (rdes0 bit 15)\n\t *   no receiver watchdog or transmitter jabber timer\n\t *       (csr15 bit 0,14 == 1)\n\t *   if using 16-bit CRC, turn off CRC (trans desc, crc disable)\n\t */\n\n#ifndef TULIP_CMD_RECEIVEALL\n#define TULIP_CMD_RECEIVEALL 0x40000000L\n#endif\n\n\tsc->lmc_cmdmode |= ( TULIP_CMD_PROMISCUOUS\n\t\t\t       | TULIP_CMD_FULLDUPLEX\n\t\t\t       | TULIP_CMD_PASSBADPKT\n\t\t\t       | TULIP_CMD_NOHEARTBEAT\n\t\t\t       | TULIP_CMD_PORTSELECT\n\t\t\t       | TULIP_CMD_RECEIVEALL\n\t\t\t       | TULIP_CMD_MUSTBEONE\n\t\t\t       );\n\tsc->lmc_cmdmode &= ~( TULIP_CMD_OPERMODE\n\t\t\t\t| TULIP_CMD_THRESHOLDCTL\n\t\t\t\t| TULIP_CMD_STOREFWD\n\t\t\t\t| TULIP_CMD_TXTHRSHLDCTL\n\t\t\t\t);\n\n\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\n\t/*\n\t * disable receiver watchdog and transmit jabber\n\t */\n\tval = LMC_CSR_READ(sc, csr_sia_general);\n\tval |= (TULIP_WATCHDOG_TXDISABLE | TULIP_WATCHDOG_RXDISABLE);\n\tLMC_CSR_WRITE(sc, csr_sia_general, val);\n\n\t/*\n\t * turn off those LEDs...\n\t */\n\tsc->lmc_miireg16 |= LMC_MII16_LED_ALL;\n\tlmc_led_on(sc, LMC_MII16_LED0);\n\n#ifndef __linux__\n\t/*\n\t * reprogram the tx desc, rx desc, and PCI bus options\n\t */\n\tLMC_CSR_WRITE(sc, csr_txlist,\n\t\t\tLMC_KVATOPHYS(sc, &sc->lmc_txinfo.ri_first[0]));\n\tLMC_CSR_WRITE(sc, csr_rxlist,\n\t\t\tLMC_KVATOPHYS(sc, &sc->lmc_rxinfo.ri_first[0]));\n\tLMC_CSR_WRITE(sc, csr_busmode,\n\t\t\t(1 << (LMC_BURSTSIZE(sc->lmc_unit) + 8))\n\t\t\t|TULIP_BUSMODE_CACHE_ALIGN8\n\t\t\t|TULIP_BUSMODE_READMULTIPLE\n\t\t\t|(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_BIGENDIAN : 0));\n\n\tsc->lmc_txq.ifq_maxlen = LMC_TXDESCS;\n\n\t/*\n\t * Free all the mbufs that were on the transmit ring.\n\t */\n\tfor (;;) {\n\t\tstruct mbuf *m;\n\n\t\tIF_DEQUEUE(&sc->lmc_txq, m);\n\t\tif (m == NULL)\n\t\t\tbreak;\n\t\tm_freem(m);\n\t}\n\n\t/*\n\t * reset descriptor state and reclaim all descriptors.\n\t */\n\tri = &sc->lmc_txinfo;\n\tri->ri_nextin = ri->ri_nextout = ri->ri_first;\n\tri->ri_free = ri->ri_max;\n\tfor (di = ri->ri_first; di < ri->ri_last; di++)\n\t\tdi->d_status = 0;\n\n\t/*\n\t * We need to collect all the mbufs were on the \n\t * receive ring before we reinit it either to put\n\t * them back on or to know if we have to allocate\n\t * more.\n\t */\n\tri = &sc->lmc_rxinfo;\n\tri->ri_nextin = ri->ri_nextout = ri->ri_first;\n\tri->ri_free = ri->ri_max;\n\tfor (di = ri->ri_first; di < ri->ri_last; di++) {\n\t\tdi->d_status = 0;\n\t\tdi->d_length1 = 0; di->d_addr1 = 0;\n\t\tdi->d_length2 = 0; di->d_addr2 = 0;\n\t}\n\tfor (;;) {\n\t\tstruct mbuf *m;\n\t\tIF_DEQUEUE(&sc->lmc_rxq, m);\n\t\tif (m == NULL)\n\t\t\tbreak;\n\t\tm_freem(m);\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic void\nlmc_ifup(lmc_softc_t * const sc)\n{\n\tsc->lmc_if.if_timer = 0;\n\n\tlmc_dec_reset(sc);\n\tlmc_reset(sc);\n\n\tsc->lmc_media->set_link_status(sc, LMC_LINK_UP);\n\tsc->lmc_media->set_status(sc, NULL);\n\n\tsc->lmc_flags |= LMC_IFUP;\n\n\t/*\n\t * for DS3 & DS1 adapters light the green light, led2\n\t */\n\tif (sc->lmc_cardtype == LMC_CARDTYPE_DS3 ||\n\t    sc->lmc_cardtype == LMC_CARDTYPE_T1)\n\t\tlmc_led_on (sc, LMC_MII16_LED2);\n\telse\n\t\tlmc_led_on (sc, LMC_MII16_LED0 | LMC_MII16_LED2);\n\n\t/*\n\t * select what interrupts we want to get\n\t */\n\tsc->lmc_intrmask |= (TULIP_STS_NORMALINTR\n\t\t\t       | TULIP_STS_RXINTR\n\t\t\t       | TULIP_STS_TXINTR\n\t\t\t       | TULIP_STS_ABNRMLINTR\n\t\t\t       | TULIP_STS_SYSERROR\n\t\t\t       | TULIP_STS_TXSTOPPED\n\t\t\t       | TULIP_STS_TXUNDERFLOW\n\t\t\t       | TULIP_STS_RXSTOPPED\n\t\t\t       );\n\tLMC_CSR_WRITE(sc, csr_intr, sc->lmc_intrmask);\n\n\tsc->lmc_cmdmode |= TULIP_CMD_TXRUN;\n\tsc->lmc_cmdmode |= TULIP_CMD_RXRUN;\n\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\n\tsc->lmc_if.if_timer = 1;\n}"
  },
  {
    "function_name": "lmc_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "414-524",
    "snippet": "static int\nlmc_watchdog(int unit)\n#endif\n{\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\tlmc_softc_t * const sc = LMC_IFP_TO_SOFTC(ifp);\n#endif\n#if defined(__bsdi__)\n\tlmc_softc_t * const sc = LMC_UNIT_TO_SOFTC(unit);\n\tstruct ifnet *ifp = &sc->lmc_if;\n#endif\n\tint state;\n\tu_int32_t ostatus;\n\tu_int32_t link_status;\n\tu_int32_t ticks;\n\n\tstate = 0;\n\n\t/*\n\t * Make sure the tx jabber and rx watchdog are off,\n\t * and the transmit and recieve processes are running.\n\t */\n\tLMC_CSR_WRITE (sc, csr_15, 0x00000011);\n\tsc->lmc_cmdmode |= TULIP_CMD_TXRUN | TULIP_CMD_RXRUN;\n\tLMC_CSR_WRITE (sc, csr_command, sc->lmc_cmdmode);\n\n\t/* Is the transmit clock still available? */\n\tticks = LMC_CSR_READ (sc, csr_gp_timer);\n\tticks = 0x0000ffff - (ticks & 0x0000ffff);\n\n\tif (ticks == 0)\n\t{\n\t\t/* no clock found ? */\n\t\tif (sc->tx_clockState != 0)\n\t\t{\n\t\t\tsc->tx_clockState = 0;\n\t\t\tif (sc->lmc_cardtype == LMC_CARDTYPE_SSI)\n\t\t\t\tlmc_led_on (sc, LMC_MII16_LED3); /* ON red */\n\t\t}\n\telse\n\t\tif (sc->tx_clockState == 0)\n\t\t{\n\t\t\tsc->tx_clockState = 1;\n\t\t\tif (sc->lmc_cardtype == LMC_CARDTYPE_SSI)\n\t\t\t\tlmc_led_off (sc, LMC_MII16_LED3); /* OFF red */\n\t\t}\n\t}\n\n\tlink_status = sc->lmc_media->get_link_status(sc);\n\tostatus = ((sc->lmc_flags & LMC_MODEMOK) == LMC_MODEMOK);\n\n\t/*\n\t * hardware level link lost, but the interface is marked as up.\n\t * Mark it as down.\n\t */\n        if (link_status == LMC_LINK_DOWN && ostatus) {\n\t\tprintf(LMC_PRINTF_FMT \": physical link down\\n\",\n\t\t       LMC_PRINTF_ARGS);\n\t\tsc->lmc_flags &= ~LMC_MODEMOK;\n\t\tif (sc->lmc_cardtype == LMC_CARDTYPE_DS3 ||\n\t\t    sc->lmc_cardtype == LMC_CARDTYPE_T1)\n\t\t\tlmc_led_on (sc, LMC_DS3_LED3 | LMC_DS3_LED2);\n\t\t\t\t\t\t\t/* turn on red LED */\n\t\telse {\n\t\t\tlmc_led_off (sc, LMC_MII16_LED1);\n\t\t\tlmc_led_on (sc, LMC_MII16_LED0);\n\t\t\tif (sc->lmc_timing == LMC_CTL_CLOCK_SOURCE_EXT)\n\t\t\t\tlmc_led_on (sc, LMC_MII16_LED3);\n\t\t}\n\n\t}\n\n\t/*\n\t * hardware link is up, but the interface is marked as down.\n\t * Bring it back up again.\n\t */\n\tif (link_status != LMC_LINK_DOWN && !ostatus) {\n\t\tprintf(LMC_PRINTF_FMT \": physical link up\\n\",\n\t\t       LMC_PRINTF_ARGS);\n\t\tif (sc->lmc_flags & LMC_IFUP)\n\t\t\tlmc_ifup(sc);\n\t\tsc->lmc_flags |= LMC_MODEMOK;\n\t\tif (sc->lmc_cardtype == LMC_CARDTYPE_DS3 ||\n\t\t    sc->lmc_cardtype == LMC_CARDTYPE_T1)\n\t\t{\n\t\t\tsc->lmc_miireg16 |= LMC_DS3_LED3;\n\t\t\tlmc_led_off (sc, LMC_DS3_LED3);\n\t\t\t\t\t\t\t/* turn off red LED */\n\t\t\tlmc_led_on (sc, LMC_DS3_LED2);\n\t\t} else {\n\t\t\tlmc_led_on (sc, LMC_MII16_LED0 | LMC_MII16_LED1\n\t\t\t\t    | LMC_MII16_LED2);\n\t\t\tif (sc->lmc_timing != LMC_CTL_CLOCK_SOURCE_EXT)\n\t\t\t\tlmc_led_off (sc, LMC_MII16_LED3);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t/* Call media specific watchdog functions */\n\tsc->lmc_media->watchdog(sc);\n\n\t/*\n\t * remember the timer value\n\t */\n\tticks = LMC_CSR_READ(sc, csr_gp_timer);\n\tLMC_CSR_WRITE(sc, csr_gp_timer, 0xffffffffUL);\n\tsc->ictl.ticks = 0x0000ffff - (ticks & 0x0000ffff);\n\n\tifp->if_timer = 1;\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);",
      "static ifnet_ret_t lmc_ifstart(struct ifnet *ifp);",
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LMC_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp_timer",
            "0xffffffffUL"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_CSR_READ",
          "args": [
            "sc",
            "csr_gp_timer"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->lmc_media->watchdog",
          "args": [
            "sc"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmc_led_off",
          "args": [
            "sc",
            "LMC_MII16_LED3"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_led_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc_common.c",
          "lines": "200-205",
          "snippet": "void\nlmc_led_off(lmc_softc_t * const sc, u_int32_t led)\n{\n\tsc->lmc_miireg16 |= led;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmc_types.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmc_types.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nlmc_led_off(lmc_softc_t * const sc, u_int32_t led)\n{\n\tsc->lmc_miireg16 |= led;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmc_led_on",
          "args": [
            "sc",
            "LMC_MII16_LED0 | LMC_MII16_LED1\n\t\t\t\t    | LMC_MII16_LED2"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_led_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc_common.c",
          "lines": "193-198",
          "snippet": "void\nlmc_led_on(lmc_softc_t * const sc, u_int32_t led)\n{\n\tsc->lmc_miireg16 &= ~led;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmc_types.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmc_types.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nlmc_led_on(lmc_softc_t * const sc, u_int32_t led)\n{\n\tsc->lmc_miireg16 &= ~led;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmc_ifup",
          "args": [
            "sc"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_ifup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "530-571",
          "snippet": "static void\nlmc_ifup(lmc_softc_t * const sc)\n{\n\tsc->lmc_if.if_timer = 0;\n\n\tlmc_dec_reset(sc);\n\tlmc_reset(sc);\n\n\tsc->lmc_media->set_link_status(sc, LMC_LINK_UP);\n\tsc->lmc_media->set_status(sc, NULL);\n\n\tsc->lmc_flags |= LMC_IFUP;\n\n\t/*\n\t * for DS3 & DS1 adapters light the green light, led2\n\t */\n\tif (sc->lmc_cardtype == LMC_CARDTYPE_DS3 ||\n\t    sc->lmc_cardtype == LMC_CARDTYPE_T1)\n\t\tlmc_led_on (sc, LMC_MII16_LED2);\n\telse\n\t\tlmc_led_on (sc, LMC_MII16_LED0 | LMC_MII16_LED2);\n\n\t/*\n\t * select what interrupts we want to get\n\t */\n\tsc->lmc_intrmask |= (TULIP_STS_NORMALINTR\n\t\t\t       | TULIP_STS_RXINTR\n\t\t\t       | TULIP_STS_TXINTR\n\t\t\t       | TULIP_STS_ABNRMLINTR\n\t\t\t       | TULIP_STS_SYSERROR\n\t\t\t       | TULIP_STS_TXSTOPPED\n\t\t\t       | TULIP_STS_TXUNDERFLOW\n\t\t\t       | TULIP_STS_RXSTOPPED\n\t\t\t       );\n\tLMC_CSR_WRITE(sc, csr_intr, sc->lmc_intrmask);\n\n\tsc->lmc_cmdmode |= TULIP_CMD_TXRUN;\n\tsc->lmc_cmdmode |= TULIP_CMD_RXRUN;\n\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\n\tsc->lmc_if.if_timer = 1;\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic void\nlmc_ifup(lmc_softc_t * const sc)\n{\n\tsc->lmc_if.if_timer = 0;\n\n\tlmc_dec_reset(sc);\n\tlmc_reset(sc);\n\n\tsc->lmc_media->set_link_status(sc, LMC_LINK_UP);\n\tsc->lmc_media->set_status(sc, NULL);\n\n\tsc->lmc_flags |= LMC_IFUP;\n\n\t/*\n\t * for DS3 & DS1 adapters light the green light, led2\n\t */\n\tif (sc->lmc_cardtype == LMC_CARDTYPE_DS3 ||\n\t    sc->lmc_cardtype == LMC_CARDTYPE_T1)\n\t\tlmc_led_on (sc, LMC_MII16_LED2);\n\telse\n\t\tlmc_led_on (sc, LMC_MII16_LED0 | LMC_MII16_LED2);\n\n\t/*\n\t * select what interrupts we want to get\n\t */\n\tsc->lmc_intrmask |= (TULIP_STS_NORMALINTR\n\t\t\t       | TULIP_STS_RXINTR\n\t\t\t       | TULIP_STS_TXINTR\n\t\t\t       | TULIP_STS_ABNRMLINTR\n\t\t\t       | TULIP_STS_SYSERROR\n\t\t\t       | TULIP_STS_TXSTOPPED\n\t\t\t       | TULIP_STS_TXUNDERFLOW\n\t\t\t       | TULIP_STS_RXSTOPPED\n\t\t\t       );\n\tLMC_CSR_WRITE(sc, csr_intr, sc->lmc_intrmask);\n\n\tsc->lmc_cmdmode |= TULIP_CMD_TXRUN;\n\tsc->lmc_cmdmode |= TULIP_CMD_RXRUN;\n\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\n\tsc->lmc_if.if_timer = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "LMC_PRINTF_FMT \": physical link up\\n\"",
            "LMC_PRINTF_ARGS"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->lmc_media->get_link_status",
          "args": [
            "sc"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_CSR_READ",
          "args": [
            "sc",
            "csr_gp_timer"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "sc->lmc_cmdmode"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_CSR_WRITE",
          "args": [
            "sc",
            "csr_15",
            "0x00000011"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_UNIT_TO_SOFTC",
          "args": [
            "unit"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_IFP_TO_SOFTC",
          "args": [
            "ifp"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);\nstatic ifnet_ret_t lmc_ifstart(struct ifnet *ifp);\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic int\nlmc_watchdog(int unit)\n#endif\n{\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\tlmc_softc_t * const sc = LMC_IFP_TO_SOFTC(ifp);\n#endif\n#if defined(__bsdi__)\n\tlmc_softc_t * const sc = LMC_UNIT_TO_SOFTC(unit);\n\tstruct ifnet *ifp = &sc->lmc_if;\n#endif\n\tint state;\n\tu_int32_t ostatus;\n\tu_int32_t link_status;\n\tu_int32_t ticks;\n\n\tstate = 0;\n\n\t/*\n\t * Make sure the tx jabber and rx watchdog are off,\n\t * and the transmit and recieve processes are running.\n\t */\n\tLMC_CSR_WRITE (sc, csr_15, 0x00000011);\n\tsc->lmc_cmdmode |= TULIP_CMD_TXRUN | TULIP_CMD_RXRUN;\n\tLMC_CSR_WRITE (sc, csr_command, sc->lmc_cmdmode);\n\n\t/* Is the transmit clock still available? */\n\tticks = LMC_CSR_READ (sc, csr_gp_timer);\n\tticks = 0x0000ffff - (ticks & 0x0000ffff);\n\n\tif (ticks == 0)\n\t{\n\t\t/* no clock found ? */\n\t\tif (sc->tx_clockState != 0)\n\t\t{\n\t\t\tsc->tx_clockState = 0;\n\t\t\tif (sc->lmc_cardtype == LMC_CARDTYPE_SSI)\n\t\t\t\tlmc_led_on (sc, LMC_MII16_LED3); /* ON red */\n\t\t}\n\telse\n\t\tif (sc->tx_clockState == 0)\n\t\t{\n\t\t\tsc->tx_clockState = 1;\n\t\t\tif (sc->lmc_cardtype == LMC_CARDTYPE_SSI)\n\t\t\t\tlmc_led_off (sc, LMC_MII16_LED3); /* OFF red */\n\t\t}\n\t}\n\n\tlink_status = sc->lmc_media->get_link_status(sc);\n\tostatus = ((sc->lmc_flags & LMC_MODEMOK) == LMC_MODEMOK);\n\n\t/*\n\t * hardware level link lost, but the interface is marked as up.\n\t * Mark it as down.\n\t */\n        if (link_status == LMC_LINK_DOWN && ostatus) {\n\t\tprintf(LMC_PRINTF_FMT \": physical link down\\n\",\n\t\t       LMC_PRINTF_ARGS);\n\t\tsc->lmc_flags &= ~LMC_MODEMOK;\n\t\tif (sc->lmc_cardtype == LMC_CARDTYPE_DS3 ||\n\t\t    sc->lmc_cardtype == LMC_CARDTYPE_T1)\n\t\t\tlmc_led_on (sc, LMC_DS3_LED3 | LMC_DS3_LED2);\n\t\t\t\t\t\t\t/* turn on red LED */\n\t\telse {\n\t\t\tlmc_led_off (sc, LMC_MII16_LED1);\n\t\t\tlmc_led_on (sc, LMC_MII16_LED0);\n\t\t\tif (sc->lmc_timing == LMC_CTL_CLOCK_SOURCE_EXT)\n\t\t\t\tlmc_led_on (sc, LMC_MII16_LED3);\n\t\t}\n\n\t}\n\n\t/*\n\t * hardware link is up, but the interface is marked as down.\n\t * Bring it back up again.\n\t */\n\tif (link_status != LMC_LINK_DOWN && !ostatus) {\n\t\tprintf(LMC_PRINTF_FMT \": physical link up\\n\",\n\t\t       LMC_PRINTF_ARGS);\n\t\tif (sc->lmc_flags & LMC_IFUP)\n\t\t\tlmc_ifup(sc);\n\t\tsc->lmc_flags |= LMC_MODEMOK;\n\t\tif (sc->lmc_cardtype == LMC_CARDTYPE_DS3 ||\n\t\t    sc->lmc_cardtype == LMC_CARDTYPE_T1)\n\t\t{\n\t\t\tsc->lmc_miireg16 |= LMC_DS3_LED3;\n\t\t\tlmc_led_off (sc, LMC_DS3_LED3);\n\t\t\t\t\t\t\t/* turn off red LED */\n\t\t\tlmc_led_on (sc, LMC_DS3_LED2);\n\t\t} else {\n\t\t\tlmc_led_on (sc, LMC_MII16_LED0 | LMC_MII16_LED1\n\t\t\t\t    | LMC_MII16_LED2);\n\t\t\tif (sc->lmc_timing != LMC_CTL_CLOCK_SOURCE_EXT)\n\t\t\t\tlmc_led_off (sc, LMC_MII16_LED3);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t/* Call media specific watchdog functions */\n\tsc->lmc_media->watchdog(sc);\n\n\t/*\n\t * remember the timer value\n\t */\n\tticks = LMC_CSR_READ(sc, csr_gp_timer);\n\tLMC_CSR_WRITE(sc, csr_gp_timer, 0xffffffffUL);\n\tsc->ictl.ticks = 0x0000ffff - (ticks & 0x0000ffff);\n\n\tifp->if_timer = 1;\n}"
  },
  {
    "function_name": "lmc_read_macaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "395-403",
    "snippet": "int\nlmc_read_macaddr(lmc_softc_t * const sc)\n{\n\tlmc_srom_read(sc);\n\n\tbcopy(sc->lmc_rombuf + 20, sc->lmc_enaddr, 6);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->lmc_rombuf + 20",
            "sc->lmc_enaddr",
            "6"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmc_srom_read",
          "args": [
            "sc"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_srom_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "255-301",
          "snippet": "static void\nlmc_srom_read(lmc_softc_t * const sc)\n{   \n\tunsigned idx; \n\tconst unsigned bitwidth = SROM_BITWIDTH;\n\tconst unsigned cmdmask = (SROMCMD_RD << bitwidth);\n\tconst unsigned msb = 1 << (bitwidth + 3 - 1);\n\tunsigned lastidx = (1 << bitwidth) - 1;\n\n\tlmc_srom_idle(sc);\n\n\tfor (idx = 0; idx <= lastidx; idx++) {\n\t\tunsigned lastbit, data, bits, bit, csr;\n\t\tcsr  = SROMSEL ;\t        EMIT;\n\t\tcsr  = SROMSEL | SROMRD;        EMIT;\n\t\tcsr ^= SROMCSON;                EMIT;\n\t\tcsr ^=            SROMCLKON;    EMIT;\n    \n\t\tlastbit = 0;\n\t\tfor (bits = idx|cmdmask, bit = bitwidth + 3\n\t\t\t     ; bit > 0\n\t\t\t     ; bit--, bits <<= 1) {\n\t\t\tconst unsigned thisbit = bits & msb;\n\t\t\tcsr ^= SROMCLKOFF; EMIT;    /* clock L data invalid */\n\t\t\tif (thisbit != lastbit) {\n\t\t\t\tcsr ^= SROMDOUT; EMIT;/* clock L invert data */\n\t\t\t} else {\n\t\t\t\tEMIT;\n\t\t\t}\n\t\t\tcsr ^= SROMCLKON; EMIT;     /* clock H data valid */\n\t\t\tlastbit = thisbit;\n\t\t}\n\t\tcsr ^= SROMCLKOFF; EMIT;\n\n\t\tfor (data = 0, bits = 0; bits < 16; bits++) {\n\t\t\tdata <<= 1;\n\t\t\tcsr ^= SROMCLKON; EMIT;     /* clock H data valid */ \n\t\t\tdata |= LMC_CSR_READ(sc, csr_srom_mii) & SROMDIN ? 1 : 0;\n\t\t\tcsr ^= SROMCLKOFF; EMIT;    /* clock L data invalid */\n\t\t}\n\t\tsc->lmc_rombuf[idx*2] = data & 0xFF;\n\t\tsc->lmc_rombuf[idx*2+1] = data >> 8;\n\t\tcsr  = SROMSEL | SROMRD; EMIT;\n\t\tcsr  = 0; EMIT;\n\t}\n\tlmc_srom_idle(sc);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define EMIT    \\\ndo { \\\n\tLMC_CSR_WRITE(sc, csr_srom_mii, csr); \\\n\tlmc_delay_300ns(sc); \\\n} while (0)"
          ],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EMIT    \\\ndo { \\\n\tLMC_CSR_WRITE(sc, csr_srom_mii, csr); \\\n\tlmc_delay_300ns(sc); \\\n} while (0)\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic void\nlmc_srom_read(lmc_softc_t * const sc)\n{   \n\tunsigned idx; \n\tconst unsigned bitwidth = SROM_BITWIDTH;\n\tconst unsigned cmdmask = (SROMCMD_RD << bitwidth);\n\tconst unsigned msb = 1 << (bitwidth + 3 - 1);\n\tunsigned lastidx = (1 << bitwidth) - 1;\n\n\tlmc_srom_idle(sc);\n\n\tfor (idx = 0; idx <= lastidx; idx++) {\n\t\tunsigned lastbit, data, bits, bit, csr;\n\t\tcsr  = SROMSEL ;\t        EMIT;\n\t\tcsr  = SROMSEL | SROMRD;        EMIT;\n\t\tcsr ^= SROMCSON;                EMIT;\n\t\tcsr ^=            SROMCLKON;    EMIT;\n    \n\t\tlastbit = 0;\n\t\tfor (bits = idx|cmdmask, bit = bitwidth + 3\n\t\t\t     ; bit > 0\n\t\t\t     ; bit--, bits <<= 1) {\n\t\t\tconst unsigned thisbit = bits & msb;\n\t\t\tcsr ^= SROMCLKOFF; EMIT;    /* clock L data invalid */\n\t\t\tif (thisbit != lastbit) {\n\t\t\t\tcsr ^= SROMDOUT; EMIT;/* clock L invert data */\n\t\t\t} else {\n\t\t\t\tEMIT;\n\t\t\t}\n\t\t\tcsr ^= SROMCLKON; EMIT;     /* clock H data valid */\n\t\t\tlastbit = thisbit;\n\t\t}\n\t\tcsr ^= SROMCLKOFF; EMIT;\n\n\t\tfor (data = 0, bits = 0; bits < 16; bits++) {\n\t\t\tdata <<= 1;\n\t\t\tcsr ^= SROMCLKON; EMIT;     /* clock H data valid */ \n\t\t\tdata |= LMC_CSR_READ(sc, csr_srom_mii) & SROMDIN ? 1 : 0;\n\t\t\tcsr ^= SROMCLKOFF; EMIT;    /* clock L data invalid */\n\t\t}\n\t\tsc->lmc_rombuf[idx*2] = data & 0xFF;\n\t\tsc->lmc_rombuf[idx*2+1] = data >> 8;\n\t\tcsr  = SROMSEL | SROMRD; EMIT;\n\t\tcsr  = 0; EMIT;\n\t}\n\tlmc_srom_idle(sc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nint\nlmc_read_macaddr(lmc_softc_t * const sc)\n{\n\tlmc_srom_read(sc);\n\n\tbcopy(sc->lmc_rombuf + 20, sc->lmc_enaddr, 6);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lmc_mii_writereg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "379-393",
    "snippet": "void\nlmc_mii_writereg(lmc_softc_t * const sc, u_int32_t devaddr,\n\t\t   u_int32_t regno, u_int32_t data)\n{\n    u_int32_t csr;\n\n    csr = LMC_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    lmc_mii_writebits(sc, MII_PREAMBLE, 32);\n    lmc_mii_writebits(sc, MII_WRCMD, 8);\n    lmc_mii_writebits(sc, devaddr, 5);\n    lmc_mii_writebits(sc, regno, 5);\n    lmc_mii_turnaround(sc, MII_WRCMD);\n    lmc_mii_writebits(sc, data, 16);\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MII_EMIT    do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)"
    ],
    "globals_used": [
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lmc_mii_writebits",
          "args": [
            "sc",
            "data",
            "16"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_mii_writebits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "305-323",
          "snippet": "static inline void\nlmc_mii_writebits(lmc_softc_t * const sc, unsigned data, unsigned bits)\n{\n    unsigned msb = 1 << (bits - 1);\n    unsigned csr = LMC_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned lastbit = (csr & MII_DOUT) ? msb : 0;\n\n    csr |= MII_WR; MII_EMIT;  \t\t/* clock low; assert write */\n\n    for (; bits > 0; bits--, data <<= 1) {\n\tconst unsigned thisbit = data & msb;\n\tif (thisbit != lastbit) {\n\t    csr ^= MII_DOUT; MII_EMIT;  /* clock low; invert data */\n\t}\n\tcsr ^= MII_CLKON; MII_EMIT;     /* clock high; data valid */\n\tlastbit = thisbit;\n\tcsr ^= MII_CLKOFF; MII_EMIT;    /* clock low; data not valid */\n    }\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MII_EMIT    do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)"
          ],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_mii_writebits(lmc_softc_t * const sc, unsigned data, unsigned bits)\n{\n    unsigned msb = 1 << (bits - 1);\n    unsigned csr = LMC_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned lastbit = (csr & MII_DOUT) ? msb : 0;\n\n    csr |= MII_WR; MII_EMIT;  \t\t/* clock low; assert write */\n\n    for (; bits > 0; bits--, data <<= 1) {\n\tconst unsigned thisbit = data & msb;\n\tif (thisbit != lastbit) {\n\t    csr ^= MII_DOUT; MII_EMIT;  /* clock low; invert data */\n\t}\n\tcsr ^= MII_CLKON; MII_EMIT;     /* clock high; data valid */\n\tlastbit = thisbit;\n\tcsr ^= MII_CLKOFF; MII_EMIT;    /* clock low; data not valid */\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmc_mii_turnaround",
          "args": [
            "sc",
            "MII_WRCMD"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_mii_turnaround",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "325-341",
          "snippet": "static void\nlmc_mii_turnaround(lmc_softc_t * const sc, u_int32_t cmd)\n{\n    u_int32_t csr;\n\n    csr = LMC_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    if (cmd == MII_WRCMD) {\n\tcsr |= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n\tcsr ^= MII_CLKON; MII_EMIT;\t/* clock high; data valid */\n\tcsr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n\tcsr ^= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n    } else {\n\tcsr |= MII_RD; MII_EMIT;\t/* clock low; switch to read */\n    }\n    csr ^= MII_CLKON; MII_EMIT;\t\t/* clock high; data valid */\n    csr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MII_EMIT    do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)"
          ],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic void\nlmc_mii_turnaround(lmc_softc_t * const sc, u_int32_t cmd)\n{\n    u_int32_t csr;\n\n    csr = LMC_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    if (cmd == MII_WRCMD) {\n\tcsr |= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n\tcsr ^= MII_CLKON; MII_EMIT;\t/* clock high; data valid */\n\tcsr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n\tcsr ^= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n    } else {\n\tcsr |= MII_RD; MII_EMIT;\t/* clock low; switch to read */\n    }\n    csr ^= MII_CLKON; MII_EMIT;\t\t/* clock high; data valid */\n    csr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n}"
        }
      },
      {
        "call_info": {
          "callee": "LMC_CSR_READ",
          "args": [
            "sc",
            "csr_srom_mii"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nvoid\nlmc_mii_writereg(lmc_softc_t * const sc, u_int32_t devaddr,\n\t\t   u_int32_t regno, u_int32_t data)\n{\n    u_int32_t csr;\n\n    csr = LMC_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    lmc_mii_writebits(sc, MII_PREAMBLE, 32);\n    lmc_mii_writebits(sc, MII_WRCMD, 8);\n    lmc_mii_writebits(sc, devaddr, 5);\n    lmc_mii_writebits(sc, regno, 5);\n    lmc_mii_turnaround(sc, MII_WRCMD);\n    lmc_mii_writebits(sc, data, 16);\n}"
  },
  {
    "function_name": "lmc_mii_readreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "362-377",
    "snippet": "u_int32_t\nlmc_mii_readreg(lmc_softc_t * const sc, u_int32_t devaddr, u_int32_t regno)\n{\n    u_int32_t csr = LMC_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    u_int32_t data;\n\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    lmc_mii_writebits(sc, MII_PREAMBLE, 32);\n    lmc_mii_writebits(sc, MII_RDCMD, 8);\n    lmc_mii_writebits(sc, devaddr, 5);\n    lmc_mii_writebits(sc, regno, 5);\n    lmc_mii_turnaround(sc, MII_RDCMD);\n\n    data = lmc_mii_readbits(sc);\n    return (data);\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MII_EMIT    do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)"
    ],
    "globals_used": [
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lmc_mii_readbits",
          "args": [
            "sc"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_mii_readbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "343-360",
          "snippet": "static u_int32_t\nlmc_mii_readbits(lmc_softc_t * const sc)\n{\n    u_int32_t data;\n    u_int32_t csr = LMC_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    int idx;\n\n    for (idx = 0, data = 0; idx < 16; idx++) {\n\tdata <<= 1;\t/* this is NOOP on the first pass through */\n\tcsr ^= MII_CLKON; MII_EMIT;\t/* clock high; data valid */\n\tif (LMC_CSR_READ(sc, csr_srom_mii) & MII_DIN)\n\t    data |= 1;\n\tcsr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n    }\n    csr ^= MII_RD; MII_EMIT;\t\t/* clock low; turn off read */\n\n    return data;\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MII_EMIT    do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)"
          ],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic u_int32_t\nlmc_mii_readbits(lmc_softc_t * const sc)\n{\n    u_int32_t data;\n    u_int32_t csr = LMC_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    int idx;\n\n    for (idx = 0, data = 0; idx < 16; idx++) {\n\tdata <<= 1;\t/* this is NOOP on the first pass through */\n\tcsr ^= MII_CLKON; MII_EMIT;\t/* clock high; data valid */\n\tif (LMC_CSR_READ(sc, csr_srom_mii) & MII_DIN)\n\t    data |= 1;\n\tcsr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n    }\n    csr ^= MII_RD; MII_EMIT;\t\t/* clock low; turn off read */\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmc_mii_turnaround",
          "args": [
            "sc",
            "MII_RDCMD"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_mii_turnaround",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "325-341",
          "snippet": "static void\nlmc_mii_turnaround(lmc_softc_t * const sc, u_int32_t cmd)\n{\n    u_int32_t csr;\n\n    csr = LMC_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    if (cmd == MII_WRCMD) {\n\tcsr |= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n\tcsr ^= MII_CLKON; MII_EMIT;\t/* clock high; data valid */\n\tcsr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n\tcsr ^= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n    } else {\n\tcsr |= MII_RD; MII_EMIT;\t/* clock low; switch to read */\n    }\n    csr ^= MII_CLKON; MII_EMIT;\t\t/* clock high; data valid */\n    csr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MII_EMIT    do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)"
          ],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic void\nlmc_mii_turnaround(lmc_softc_t * const sc, u_int32_t cmd)\n{\n    u_int32_t csr;\n\n    csr = LMC_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    if (cmd == MII_WRCMD) {\n\tcsr |= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n\tcsr ^= MII_CLKON; MII_EMIT;\t/* clock high; data valid */\n\tcsr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n\tcsr ^= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n    } else {\n\tcsr |= MII_RD; MII_EMIT;\t/* clock low; switch to read */\n    }\n    csr ^= MII_CLKON; MII_EMIT;\t\t/* clock high; data valid */\n    csr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmc_mii_writebits",
          "args": [
            "sc",
            "regno",
            "5"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_mii_writebits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "305-323",
          "snippet": "static inline void\nlmc_mii_writebits(lmc_softc_t * const sc, unsigned data, unsigned bits)\n{\n    unsigned msb = 1 << (bits - 1);\n    unsigned csr = LMC_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned lastbit = (csr & MII_DOUT) ? msb : 0;\n\n    csr |= MII_WR; MII_EMIT;  \t\t/* clock low; assert write */\n\n    for (; bits > 0; bits--, data <<= 1) {\n\tconst unsigned thisbit = data & msb;\n\tif (thisbit != lastbit) {\n\t    csr ^= MII_DOUT; MII_EMIT;  /* clock low; invert data */\n\t}\n\tcsr ^= MII_CLKON; MII_EMIT;     /* clock high; data valid */\n\tlastbit = thisbit;\n\tcsr ^= MII_CLKOFF; MII_EMIT;    /* clock low; data not valid */\n    }\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MII_EMIT    do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)"
          ],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_mii_writebits(lmc_softc_t * const sc, unsigned data, unsigned bits)\n{\n    unsigned msb = 1 << (bits - 1);\n    unsigned csr = LMC_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned lastbit = (csr & MII_DOUT) ? msb : 0;\n\n    csr |= MII_WR; MII_EMIT;  \t\t/* clock low; assert write */\n\n    for (; bits > 0; bits--, data <<= 1) {\n\tconst unsigned thisbit = data & msb;\n\tif (thisbit != lastbit) {\n\t    csr ^= MII_DOUT; MII_EMIT;  /* clock low; invert data */\n\t}\n\tcsr ^= MII_CLKON; MII_EMIT;     /* clock high; data valid */\n\tlastbit = thisbit;\n\tcsr ^= MII_CLKOFF; MII_EMIT;    /* clock low; data not valid */\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LMC_CSR_READ",
          "args": [
            "sc",
            "csr_srom_mii"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nu_int32_t\nlmc_mii_readreg(lmc_softc_t * const sc, u_int32_t devaddr, u_int32_t regno)\n{\n    u_int32_t csr = LMC_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    u_int32_t data;\n\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    lmc_mii_writebits(sc, MII_PREAMBLE, 32);\n    lmc_mii_writebits(sc, MII_RDCMD, 8);\n    lmc_mii_writebits(sc, devaddr, 5);\n    lmc_mii_writebits(sc, regno, 5);\n    lmc_mii_turnaround(sc, MII_RDCMD);\n\n    data = lmc_mii_readbits(sc);\n    return (data);\n}"
  },
  {
    "function_name": "lmc_mii_readbits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "343-360",
    "snippet": "static u_int32_t\nlmc_mii_readbits(lmc_softc_t * const sc)\n{\n    u_int32_t data;\n    u_int32_t csr = LMC_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    int idx;\n\n    for (idx = 0, data = 0; idx < 16; idx++) {\n\tdata <<= 1;\t/* this is NOOP on the first pass through */\n\tcsr ^= MII_CLKON; MII_EMIT;\t/* clock high; data valid */\n\tif (LMC_CSR_READ(sc, csr_srom_mii) & MII_DIN)\n\t    data |= 1;\n\tcsr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n    }\n    csr ^= MII_RD; MII_EMIT;\t\t/* clock low; turn off read */\n\n    return data;\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MII_EMIT    do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)"
    ],
    "globals_used": [
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LMC_CSR_READ",
          "args": [
            "sc",
            "csr_srom_mii"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_CSR_READ",
          "args": [
            "sc",
            "csr_srom_mii"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic u_int32_t\nlmc_mii_readbits(lmc_softc_t * const sc)\n{\n    u_int32_t data;\n    u_int32_t csr = LMC_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    int idx;\n\n    for (idx = 0, data = 0; idx < 16; idx++) {\n\tdata <<= 1;\t/* this is NOOP on the first pass through */\n\tcsr ^= MII_CLKON; MII_EMIT;\t/* clock high; data valid */\n\tif (LMC_CSR_READ(sc, csr_srom_mii) & MII_DIN)\n\t    data |= 1;\n\tcsr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n    }\n    csr ^= MII_RD; MII_EMIT;\t\t/* clock low; turn off read */\n\n    return data;\n}"
  },
  {
    "function_name": "lmc_mii_turnaround",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "325-341",
    "snippet": "static void\nlmc_mii_turnaround(lmc_softc_t * const sc, u_int32_t cmd)\n{\n    u_int32_t csr;\n\n    csr = LMC_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    if (cmd == MII_WRCMD) {\n\tcsr |= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n\tcsr ^= MII_CLKON; MII_EMIT;\t/* clock high; data valid */\n\tcsr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n\tcsr ^= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n    } else {\n\tcsr |= MII_RD; MII_EMIT;\t/* clock low; switch to read */\n    }\n    csr ^= MII_CLKON; MII_EMIT;\t\t/* clock high; data valid */\n    csr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MII_EMIT    do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)"
    ],
    "globals_used": [
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LMC_CSR_READ",
          "args": [
            "sc",
            "csr_srom_mii"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic void\nlmc_mii_turnaround(lmc_softc_t * const sc, u_int32_t cmd)\n{\n    u_int32_t csr;\n\n    csr = LMC_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    if (cmd == MII_WRCMD) {\n\tcsr |= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n\tcsr ^= MII_CLKON; MII_EMIT;\t/* clock high; data valid */\n\tcsr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n\tcsr ^= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n    } else {\n\tcsr |= MII_RD; MII_EMIT;\t/* clock low; switch to read */\n    }\n    csr ^= MII_CLKON; MII_EMIT;\t\t/* clock high; data valid */\n    csr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n}"
  },
  {
    "function_name": "lmc_mii_writebits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "305-323",
    "snippet": "static inline void\nlmc_mii_writebits(lmc_softc_t * const sc, unsigned data, unsigned bits)\n{\n    unsigned msb = 1 << (bits - 1);\n    unsigned csr = LMC_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned lastbit = (csr & MII_DOUT) ? msb : 0;\n\n    csr |= MII_WR; MII_EMIT;  \t\t/* clock low; assert write */\n\n    for (; bits > 0; bits--, data <<= 1) {\n\tconst unsigned thisbit = data & msb;\n\tif (thisbit != lastbit) {\n\t    csr ^= MII_DOUT; MII_EMIT;  /* clock low; invert data */\n\t}\n\tcsr ^= MII_CLKON; MII_EMIT;     /* clock high; data valid */\n\tlastbit = thisbit;\n\tcsr ^= MII_CLKOFF; MII_EMIT;    /* clock low; data not valid */\n    }\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MII_EMIT    do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)"
    ],
    "globals_used": [
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LMC_CSR_READ",
          "args": [
            "sc",
            "csr_srom_mii"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { LMC_CSR_WRITE(sc, csr_srom_mii, csr); lmc_delay_300ns(sc); } while (0)\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_mii_writebits(lmc_softc_t * const sc, unsigned data, unsigned bits)\n{\n    unsigned msb = 1 << (bits - 1);\n    unsigned csr = LMC_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned lastbit = (csr & MII_DOUT) ? msb : 0;\n\n    csr |= MII_WR; MII_EMIT;  \t\t/* clock low; assert write */\n\n    for (; bits > 0; bits--, data <<= 1) {\n\tconst unsigned thisbit = data & msb;\n\tif (thisbit != lastbit) {\n\t    csr ^= MII_DOUT; MII_EMIT;  /* clock low; invert data */\n\t}\n\tcsr ^= MII_CLKON; MII_EMIT;     /* clock high; data valid */\n\tlastbit = thisbit;\n\tcsr ^= MII_CLKOFF; MII_EMIT;    /* clock low; data not valid */\n    }\n}"
  },
  {
    "function_name": "lmc_srom_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "255-301",
    "snippet": "static void\nlmc_srom_read(lmc_softc_t * const sc)\n{   \n\tunsigned idx; \n\tconst unsigned bitwidth = SROM_BITWIDTH;\n\tconst unsigned cmdmask = (SROMCMD_RD << bitwidth);\n\tconst unsigned msb = 1 << (bitwidth + 3 - 1);\n\tunsigned lastidx = (1 << bitwidth) - 1;\n\n\tlmc_srom_idle(sc);\n\n\tfor (idx = 0; idx <= lastidx; idx++) {\n\t\tunsigned lastbit, data, bits, bit, csr;\n\t\tcsr  = SROMSEL ;\t        EMIT;\n\t\tcsr  = SROMSEL | SROMRD;        EMIT;\n\t\tcsr ^= SROMCSON;                EMIT;\n\t\tcsr ^=            SROMCLKON;    EMIT;\n    \n\t\tlastbit = 0;\n\t\tfor (bits = idx|cmdmask, bit = bitwidth + 3\n\t\t\t     ; bit > 0\n\t\t\t     ; bit--, bits <<= 1) {\n\t\t\tconst unsigned thisbit = bits & msb;\n\t\t\tcsr ^= SROMCLKOFF; EMIT;    /* clock L data invalid */\n\t\t\tif (thisbit != lastbit) {\n\t\t\t\tcsr ^= SROMDOUT; EMIT;/* clock L invert data */\n\t\t\t} else {\n\t\t\t\tEMIT;\n\t\t\t}\n\t\t\tcsr ^= SROMCLKON; EMIT;     /* clock H data valid */\n\t\t\tlastbit = thisbit;\n\t\t}\n\t\tcsr ^= SROMCLKOFF; EMIT;\n\n\t\tfor (data = 0, bits = 0; bits < 16; bits++) {\n\t\t\tdata <<= 1;\n\t\t\tcsr ^= SROMCLKON; EMIT;     /* clock H data valid */ \n\t\t\tdata |= LMC_CSR_READ(sc, csr_srom_mii) & SROMDIN ? 1 : 0;\n\t\t\tcsr ^= SROMCLKOFF; EMIT;    /* clock L data invalid */\n\t\t}\n\t\tsc->lmc_rombuf[idx*2] = data & 0xFF;\n\t\tsc->lmc_rombuf[idx*2+1] = data >> 8;\n\t\tcsr  = SROMSEL | SROMRD; EMIT;\n\t\tcsr  = 0; EMIT;\n\t}\n\tlmc_srom_idle(sc);\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define EMIT    \\\ndo { \\\n\tLMC_CSR_WRITE(sc, csr_srom_mii, csr); \\\n\tlmc_delay_300ns(sc); \\\n} while (0)"
    ],
    "globals_used": [
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lmc_srom_idle",
          "args": [
            "sc"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_srom_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "232-252",
          "snippet": "static inline void\nlmc_srom_idle(lmc_softc_t * const sc)\n{\n\tunsigned bit, csr;\n    \n\tcsr  = SROMSEL ; EMIT;\n\tcsr  = SROMSEL | SROMRD; EMIT;  \n\tcsr ^= SROMCS; EMIT;\n\tcsr ^= SROMCLKON; EMIT;\n\n\t/*\n\t * Write 25 cycles of 0 which will force the SROM to be idle.\n\t */\n\tfor (bit = 3 + SROM_BITWIDTH + 16; bit > 0; bit--) {\n\t\tcsr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */\n\t\tcsr ^= SROMCLKON; EMIT;     /* clock high; data valid */\n\t}\n\tcsr ^= SROMCLKOFF; EMIT;\n\tcsr ^= SROMCS; EMIT;\n\tcsr  = 0; EMIT;\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define EMIT    \\\ndo { \\\n\tLMC_CSR_WRITE(sc, csr_srom_mii, csr); \\\n\tlmc_delay_300ns(sc); \\\n} while (0)"
          ],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EMIT    \\\ndo { \\\n\tLMC_CSR_WRITE(sc, csr_srom_mii, csr); \\\n\tlmc_delay_300ns(sc); \\\n} while (0)\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_srom_idle(lmc_softc_t * const sc)\n{\n\tunsigned bit, csr;\n    \n\tcsr  = SROMSEL ; EMIT;\n\tcsr  = SROMSEL | SROMRD; EMIT;  \n\tcsr ^= SROMCS; EMIT;\n\tcsr ^= SROMCLKON; EMIT;\n\n\t/*\n\t * Write 25 cycles of 0 which will force the SROM to be idle.\n\t */\n\tfor (bit = 3 + SROM_BITWIDTH + 16; bit > 0; bit--) {\n\t\tcsr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */\n\t\tcsr ^= SROMCLKON; EMIT;     /* clock high; data valid */\n\t}\n\tcsr ^= SROMCLKOFF; EMIT;\n\tcsr ^= SROMCS; EMIT;\n\tcsr  = 0; EMIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LMC_CSR_READ",
          "args": [
            "sc",
            "csr_srom_mii"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EMIT    \\\ndo { \\\n\tLMC_CSR_WRITE(sc, csr_srom_mii, csr); \\\n\tlmc_delay_300ns(sc); \\\n} while (0)\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic void\nlmc_srom_read(lmc_softc_t * const sc)\n{   \n\tunsigned idx; \n\tconst unsigned bitwidth = SROM_BITWIDTH;\n\tconst unsigned cmdmask = (SROMCMD_RD << bitwidth);\n\tconst unsigned msb = 1 << (bitwidth + 3 - 1);\n\tunsigned lastidx = (1 << bitwidth) - 1;\n\n\tlmc_srom_idle(sc);\n\n\tfor (idx = 0; idx <= lastidx; idx++) {\n\t\tunsigned lastbit, data, bits, bit, csr;\n\t\tcsr  = SROMSEL ;\t        EMIT;\n\t\tcsr  = SROMSEL | SROMRD;        EMIT;\n\t\tcsr ^= SROMCSON;                EMIT;\n\t\tcsr ^=            SROMCLKON;    EMIT;\n    \n\t\tlastbit = 0;\n\t\tfor (bits = idx|cmdmask, bit = bitwidth + 3\n\t\t\t     ; bit > 0\n\t\t\t     ; bit--, bits <<= 1) {\n\t\t\tconst unsigned thisbit = bits & msb;\n\t\t\tcsr ^= SROMCLKOFF; EMIT;    /* clock L data invalid */\n\t\t\tif (thisbit != lastbit) {\n\t\t\t\tcsr ^= SROMDOUT; EMIT;/* clock L invert data */\n\t\t\t} else {\n\t\t\t\tEMIT;\n\t\t\t}\n\t\t\tcsr ^= SROMCLKON; EMIT;     /* clock H data valid */\n\t\t\tlastbit = thisbit;\n\t\t}\n\t\tcsr ^= SROMCLKOFF; EMIT;\n\n\t\tfor (data = 0, bits = 0; bits < 16; bits++) {\n\t\t\tdata <<= 1;\n\t\t\tcsr ^= SROMCLKON; EMIT;     /* clock H data valid */ \n\t\t\tdata |= LMC_CSR_READ(sc, csr_srom_mii) & SROMDIN ? 1 : 0;\n\t\t\tcsr ^= SROMCLKOFF; EMIT;    /* clock L data invalid */\n\t\t}\n\t\tsc->lmc_rombuf[idx*2] = data & 0xFF;\n\t\tsc->lmc_rombuf[idx*2+1] = data >> 8;\n\t\tcsr  = SROMSEL | SROMRD; EMIT;\n\t\tcsr  = 0; EMIT;\n\t}\n\tlmc_srom_idle(sc);\n}"
  },
  {
    "function_name": "lmc_srom_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "232-252",
    "snippet": "static inline void\nlmc_srom_idle(lmc_softc_t * const sc)\n{\n\tunsigned bit, csr;\n    \n\tcsr  = SROMSEL ; EMIT;\n\tcsr  = SROMSEL | SROMRD; EMIT;  \n\tcsr ^= SROMCS; EMIT;\n\tcsr ^= SROMCLKON; EMIT;\n\n\t/*\n\t * Write 25 cycles of 0 which will force the SROM to be idle.\n\t */\n\tfor (bit = 3 + SROM_BITWIDTH + 16; bit > 0; bit--) {\n\t\tcsr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */\n\t\tcsr ^= SROMCLKON; EMIT;     /* clock high; data valid */\n\t}\n\tcsr ^= SROMCLKOFF; EMIT;\n\tcsr ^= SROMCS; EMIT;\n\tcsr  = 0; EMIT;\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define EMIT    \\\ndo { \\\n\tLMC_CSR_WRITE(sc, csr_srom_mii, csr); \\\n\tlmc_delay_300ns(sc); \\\n} while (0)"
    ],
    "globals_used": [
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EMIT    \\\ndo { \\\n\tLMC_CSR_WRITE(sc, csr_srom_mii, csr); \\\n\tlmc_delay_300ns(sc); \\\n} while (0)\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_srom_idle(lmc_softc_t * const sc)\n{\n\tunsigned bit, csr;\n    \n\tcsr  = SROMSEL ; EMIT;\n\tcsr  = SROMSEL | SROMRD; EMIT;  \n\tcsr ^= SROMCS; EMIT;\n\tcsr ^= SROMCLKON; EMIT;\n\n\t/*\n\t * Write 25 cycles of 0 which will force the SROM to be idle.\n\t */\n\tfor (bit = 3 + SROM_BITWIDTH + 16; bit > 0; bit--) {\n\t\tcsr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */\n\t\tcsr ^= SROMCLKON; EMIT;     /* clock high; data valid */\n\t}\n\tcsr ^= SROMCLKOFF; EMIT;\n\tcsr ^= SROMCS; EMIT;\n\tcsr  = 0; EMIT;\n}"
  },
  {
    "function_name": "lmc_delay_300ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
    "lines": "217-223",
    "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void lmc_rx_intr(lmc_softc_t * const sc);",
      "static void lmc_ifup(lmc_softc_t * const sc);",
      "static void lmc_ifdown(lmc_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LMC_CSR_READ",
          "args": [
            "sc",
            "csr_busmode"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
  }
]