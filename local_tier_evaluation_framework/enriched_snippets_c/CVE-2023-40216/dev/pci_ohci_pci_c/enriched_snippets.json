[
  {
    "function_name": "ohci_pci_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ohci_pci.c",
    "lines": "161-181",
    "snippet": "int\nohci_pci_detach(self, flags)\n\tdevice_ptr_t self;\n\tint flags;\n{\n\tstruct ohci_pci_softc *sc = (struct ohci_pci_softc *)self;\n\tint rv;\n\n\trv = ohci_detach(&sc->sc, flags);\n\tif (rv)\n\t\treturn (rv);\n\tif (sc->sc_ih) {\n\t\tpci_intr_disestablish(sc->sc_pc, sc->sc_ih);\n\t\tsc->sc_ih = 0;\n\t}\n\tif (sc->sc_size) {\n\t\tbus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc_size);\n\t\tsc->sc_size = 0;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tohci_pci_detach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "sc->sc.iot",
            "sc->sc.ioh",
            "sc->sc_size"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_disestablish",
          "args": [
            "sc->sc_pc",
            "sc->sc_ih"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_detach",
          "args": [
            "&sc->sc",
            "flags"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "363-384",
          "snippet": "int\nohci_detach(sc, flags)\n\tstruct ohci_softc *sc;\n\tint flags;\n{\n\tint rv = 0;\n\n\tif (sc->sc_child != NULL)\n\t\trv = config_detach(sc->sc_child, flags);\n\t\n\tif (rv != 0)\n\t\treturn (rv);\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tpowerhook_disestablish(sc->sc_powerhook);\n\tshutdownhook_disestablish(sc->sc_shutdownhook);\n#endif\n\n\t/* free data structures XXX */\n\n\treturn (rv);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nint\nohci_detach(sc, flags)\n\tstruct ohci_softc *sc;\n\tint flags;\n{\n\tint rv = 0;\n\n\tif (sc->sc_child != NULL)\n\t\trv = config_detach(sc->sc_child, flags);\n\t\n\tif (rv != 0)\n\t\treturn (rv);\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tpowerhook_disestablish(sc->sc_powerhook);\n\tshutdownhook_disestablish(sc->sc_shutdownhook);\n#endif\n\n\t/* free data structures XXX */\n\n\treturn (rv);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tohci_pci_detach;\n\nint\nohci_pci_detach(self, flags)\n\tdevice_ptr_t self;\n\tint flags;\n{\n\tstruct ohci_pci_softc *sc = (struct ohci_pci_softc *)self;\n\tint rv;\n\n\trv = ohci_detach(&sc->sc, flags);\n\tif (rv)\n\t\treturn (rv);\n\tif (sc->sc_ih) {\n\t\tpci_intr_disestablish(sc->sc_pc, sc->sc_ih);\n\t\tsc->sc_ih = 0;\n\t}\n\tif (sc->sc_size) {\n\t\tbus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc_size);\n\t\tsc->sc_size = 0;\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "ohci_pci_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ohci_pci.c",
    "lines": "98-159",
    "snippet": "void\nohci_pci_attach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tstruct ohci_pci_softc *sc = (struct ohci_pci_softc *)self;\n\tstruct pci_attach_args *pa = (struct pci_attach_args *)aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tchar const *intrstr;\n\tpci_intr_handle_t ih;\n\tpcireg_t csr;\n\tusbd_status r;\n\n\t/* Map I/O registers */\n\tif (pci_mapreg_map(pa, PCI_CBMEM, PCI_MAPREG_TYPE_MEM, 0,\n\t\t\t   &sc->sc.iot, &sc->sc.ioh, NULL, NULL)) {\n\t\tprintf(\": can't map mem space\\n\");\n\t\treturn;\n\t}\n\n\t/* Disable interrupts, so we don't get any spurious ones. */\n\tbus_space_write_4(sc->sc.iot, sc->sc.ioh, OHCI_INTERRUPT_DISABLE,\n\t\t\t  OHCI_ALL_INTRS);\n\n\tsc->sc_pc = pc;\n\tsc->sc.sc_bus.dmatag = pa->pa_dmat;\n\n\t/* Enable the device. */\n\tcsr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t       csr | PCI_COMMAND_MASTER_ENABLE);\n\n\t/* Map and establish the interrupt. */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\treturn;\n\t}\n\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_USB, ohci_intr, sc,\n\t    sc->sc.sc_bus.bdev.dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\": couldn't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf(\": %s\", intrstr);\n\n\tr = ohci_init(&sc->sc);\n\tif (r != USBD_NORMAL_COMPLETION) {\n\t\tprintf(\": init failed, error=%d\\n\", r);\n\t\treturn;\n\t}\n\n\t/* Attach usb device. */\n\tsc->sc.sc_child = config_found((void *)sc, &sc->sc.sc_bus,\n\t\t\t\t       usbctlprint);\n}",
    "includes": [
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tohci_pci_attach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "(void *)sc",
            "&sc->sc.sc_bus",
            "usbctlprint"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": init failed, error=%d\\n\"",
            "r"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ohci_init",
          "args": [
            "&sc->sc"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "655-892",
          "snippet": "usbd_status\nohci_init(sc)\n\tohci_softc_t *sc;\n{\n\tohci_soft_ed_t *sed, *psed;\n\tusbd_status err;\n\tint i;\n\tu_int32_t s, ctl, ival, hcr, fm, per, rev, desca;\n\n\tDPRINTF((\"ohci_init: start\\n\"));\n#if defined(__OpenBSD__)\n\tprintf(\",\");\n#else\n\tprintf(\"%s:\", USBDEVNAME(sc->sc_bus.bdev));\n#endif\n\trev = OREAD4(sc, OHCI_REVISION);\n\tprintf(\" OHCI version %d.%d%s\\n\", OHCI_REV_HI(rev), OHCI_REV_LO(rev),\n\t       OHCI_REV_LEGACY(rev) ? \", legacy support\" : \"\");\n\n\tif (OHCI_REV_HI(rev) != 1 || OHCI_REV_LO(rev) != 0) {\n\t\tprintf(\"%s: unsupported OHCI revision\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\tsc->sc_bus.usbrev = USBREV_UNKNOWN;\n\t\treturn (USBD_INVAL);\n\t}\n\tsc->sc_bus.usbrev = USBREV_1_0;\n\n\tfor (i = 0; i < OHCI_HASH_SIZE; i++)\n\t\tLIST_INIT(&sc->sc_hash_tds[i]);\n\tfor (i = 0; i < OHCI_HASH_SIZE; i++)\n\t\tLIST_INIT(&sc->sc_hash_itds[i]);\n\n\tSIMPLEQ_INIT(&sc->sc_free_xfers);\n\n\t/* XXX determine alignment by R/W */\n\t/* Allocate the HCCA area. */\n\terr = usb_allocmem(&sc->sc_bus, OHCI_HCCA_SIZE, \n\t\t\t OHCI_HCCA_ALIGN, &sc->sc_hccadma);\n\tif (err)\n\t\treturn (err);\n\tsc->sc_hcca = (struct ohci_hcca *)KERNADDR(&sc->sc_hccadma);\n\tmemset(sc->sc_hcca, 0, OHCI_HCCA_SIZE);\n\n\tsc->sc_eintrs = OHCI_NORMAL_INTRS;\n\n\t/* Allocate dummy ED that starts the control list. */\n\tsc->sc_ctrl_head = ohci_alloc_sed(sc);\n\tif (sc->sc_ctrl_head == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tsc->sc_ctrl_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\n\t/* Allocate dummy ED that starts the bulk list. */\n\tsc->sc_bulk_head = ohci_alloc_sed(sc);\n\tif (sc->sc_bulk_head == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad2;\n\t}\n\tsc->sc_bulk_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\n\t/* Allocate dummy ED that starts the isochronous list. */\n\tsc->sc_isoc_head = ohci_alloc_sed(sc);\n\tif (sc->sc_isoc_head == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad3;\n\t}\n\tsc->sc_isoc_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\n\t/* Allocate all the dummy EDs that make up the interrupt tree. */\n\tfor (i = 0; i < OHCI_NO_EDS; i++) {\n\t\tsed = ohci_alloc_sed(sc);\n\t\tif (sed == NULL) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tohci_free_sed(sc, sc->sc_eds[i]);\n\t\t\terr = USBD_NOMEM;\n\t\t\tgoto bad4;\n\t\t}\n\t\t/* All ED fields are set to 0. */\n\t\tsc->sc_eds[i] = sed;\n\t\tsed->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\t\tif (i != 0)\n\t\t\tpsed = sc->sc_eds[(i-1) / 2];\n\t\telse\n\t\t\tpsed= sc->sc_isoc_head;\n\t\tsed->next = psed;\n\t\tsed->ed.ed_nexted = htole32(psed->physaddr);\n\t}\n\t/* \n\t * Fill HCCA interrupt table.  The bit reversal is to get\n\t * the tree set up properly to spread the interrupts.\n\t */\n\tfor (i = 0; i < OHCI_NO_INTRS; i++)\n\t\tsc->sc_hcca->hcca_interrupt_table[revbits[i]] = \n\t\t    htole32(sc->sc_eds[OHCI_NO_EDS-OHCI_NO_INTRS+i]->physaddr);\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 15) {\n\t\tfor (i = 0; i < OHCI_NO_EDS; i++) {\n\t\t\tprintf(\"ed#%d \", i);\n\t\t\tohci_dump_ed(sc->sc_eds[i]);\n\t\t}\n\t\tprintf(\"iso \");\n\t\tohci_dump_ed(sc->sc_isoc_head);\n\t}\n#endif\n\n\t/* Determine in what context we are running. */\n\tctl = OREAD4(sc, OHCI_CONTROL);\n\tif (ctl & OHCI_IR) {\n\t\t/* SMM active, request change */\n\t\tDPRINTF((\"ohci_init: SMM active, request owner change\\n\"));\n\t\ts = OREAD4(sc, OHCI_COMMAND_STATUS);\n\t\tOWRITE4(sc, OHCI_COMMAND_STATUS, s | OHCI_OCR);\n\t\tfor (i = 0; i < 100 && (ctl & OHCI_IR); i++) {\n\t\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t\t\tctl = OREAD4(sc, OHCI_CONTROL);\n\t\t}\n\t\tif ((ctl & OHCI_IR) == 0) {\n\t\t\tprintf(\"%s: SMM does not respond, resetting\\n\",\n\t\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\t\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);\n\t\t\tgoto reset;\n\t\t}\n\t} else if ((ctl & OHCI_HCFS_MASK) != OHCI_HCFS_RESET) {\n\t\t/* BIOS started controller. */\n\t\tDPRINTF((\"ohci_init: BIOS active\\n\"));\n\t\tif ((ctl & OHCI_HCFS_MASK) != OHCI_HCFS_OPERATIONAL) {\n\t\t\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_OPERATIONAL);\n\t\t\tusb_delay_ms(&sc->sc_bus, USB_RESUME_DELAY);\n\t\t}\n\t} else {\n\t\tDPRINTF((\"ohci_init: cold started\\n\"));\n\treset:\n\t\t/* Controller was cold started. */\n\t\tusb_delay_ms(&sc->sc_bus, USB_BUS_RESET_DELAY);\n\t}\n\n\t/*\n\t * This reset should not be necessary according to the OHCI spec, but\n\t * without it some controllers do not start.\n\t */\n\tDPRINTF((\"%s: resetting\\n\", USBDEVNAME(sc->sc_bus.bdev)));\n\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);\n\tusb_delay_ms(&sc->sc_bus, USB_BUS_RESET_DELAY);\n\n\t/* We now own the host controller and the bus has been reset. */\n\tival = OHCI_GET_IVAL(OREAD4(sc, OHCI_FM_INTERVAL));\n\n\tOWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_HCR); /* Reset HC */\n\t/* Nominal time for a reset is 10 us. */\n\tfor (i = 0; i < 10; i++) {\n\t\tdelay(10);\n\t\thcr = OREAD4(sc, OHCI_COMMAND_STATUS) & OHCI_HCR;\n\t\tif (!hcr)\n\t\t\tbreak;\n\t}\n\tif (hcr) {\n\t\tprintf(\"%s: reset timeout\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t\terr = USBD_IOERROR;\n\t\tgoto bad5;\n\t}\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 15)\n\t\tohci_dumpregs(sc);\n#endif\n\n\t/* The controller is now in SUSPEND state, we have 2ms to finish. */\n\n\t/* Set up HC registers. */\n\tOWRITE4(sc, OHCI_HCCA, DMAADDR(&sc->sc_hccadma));\n\tOWRITE4(sc, OHCI_CONTROL_HEAD_ED, sc->sc_ctrl_head->physaddr);\n\tOWRITE4(sc, OHCI_BULK_HEAD_ED, sc->sc_bulk_head->physaddr);\n\t/* disable all interrupts and then switch on all desired interrupts */\n\tOWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_ALL_INTRS);\n\tOWRITE4(sc, OHCI_INTERRUPT_ENABLE, sc->sc_eintrs | OHCI_MIE);\n\t/* switch on desired functional features */\n\tctl = OREAD4(sc, OHCI_CONTROL);\n\tctl &= ~(OHCI_CBSR_MASK | OHCI_LES | OHCI_HCFS_MASK | OHCI_IR);\n\tctl |= OHCI_PLE | OHCI_IE | OHCI_CLE | OHCI_BLE |\n\t\tOHCI_RATIO_1_4 | OHCI_HCFS_OPERATIONAL;\n\t/* And finally start it! */\n\tOWRITE4(sc, OHCI_CONTROL, ctl);\n\n\t/*\n\t * The controller is now OPERATIONAL.  Set a some final\n\t * registers that should be set earlier, but that the\n\t * controller ignores when in the SUSPEND state.\n\t */\n\tfm = (OREAD4(sc, OHCI_FM_INTERVAL) & OHCI_FIT) ^ OHCI_FIT;\n\tfm |= OHCI_FSMPS(ival) | ival;\n\tOWRITE4(sc, OHCI_FM_INTERVAL, fm);\n\tper = OHCI_PERIODIC(ival); /* 90% periodic */\n\tOWRITE4(sc, OHCI_PERIODIC_START, per);\n\n\t/* Fiddle the No OverCurrent Protection bit to avoid chip bug. */\n\tdesca = OREAD4(sc, OHCI_RH_DESCRIPTOR_A);\n\tOWRITE4(sc, OHCI_RH_DESCRIPTOR_A, desca | OHCI_NOCP);\n\tOWRITE4(sc, OHCI_RH_STATUS, OHCI_LPSC); /* Enable port power */\n\tusb_delay_ms(&sc->sc_bus, OHCI_ENABLE_POWER_DELAY);\n\tOWRITE4(sc, OHCI_RH_DESCRIPTOR_A, desca);\n\n\t/*\n\t * The AMD756 requires a delay before re-reading the register,\n\t * otherwise it will occasionally report 0 ports.\n\t */\n\tusb_delay_ms(&sc->sc_bus, OHCI_READ_DESC_DELAY);\n\tsc->sc_noport = OHCI_GET_NDP(OREAD4(sc, OHCI_RH_DESCRIPTOR_A));\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5)\n\t\tohci_dumpregs(sc);\n#endif\n\t\n\t/* Set up the bus struct. */\n\tsc->sc_bus.methods = &ohci_bus_methods;\n\tsc->sc_bus.pipe_size = sizeof(struct ohci_pipe);\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tsc->sc_powerhook = powerhook_establish(ohci_power, sc);\n\tsc->sc_shutdownhook = shutdownhook_establish(ohci_shutdown, sc);\n#endif\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad5:\n\tfor (i = 0; i < OHCI_NO_EDS; i++)\n\t\tohci_free_sed(sc, sc->sc_eds[i]);\n bad4:\n\tohci_free_sed(sc, sc->sc_isoc_head);\n bad3:\n\tohci_free_sed(sc, sc->sc_ctrl_head);\n bad2:\n\tohci_free_sed(sc, sc->sc_bulk_head);\n bad1:\n\tusb_freemem(&sc->sc_bus, &sc->sc_hccadma);\n\treturn (err);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "Static usbd_status",
            "Static usbd_status",
            "ohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "ohci_device_setintr __P((ohci_softc_t *sc, \n\t\t\t    struct ohci_pipe *pipe, int ival));",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "Static u_int8_t revbits[OHCI_NO_INTRS] = \n  { 0x00, 0x10, 0x08, 0x18, 0x04, 0x14, 0x0c, 0x1c,\n    0x02, 0x12, 0x0a, 0x1a, 0x06, 0x16, 0x0e, 0x1e,\n    0x01, 0x11, 0x09, 0x19, 0x05, 0x15, 0x0d, 0x1d,\n    0x03, 0x13, 0x0b, 0x1b, 0x07, 0x17, 0x0f, 0x1f };",
            "Static struct",
            "usbd_bus_methods ohci_bus_methods = {\n\tohci_open,\n\tohci_softintr,\n\tohci_poll,\n\tohci_allocm,\n\tohci_freem,\n\tohci_allocx,\n\tohci_freex,\n};",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_physaddr_t a;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;",
            "ohci_physaddr_t a;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nStatic usbd_status;\nStatic usbd_status;\nohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nohci_device_setintr __P((ohci_softc_t *sc, \n\t\t\t    struct ohci_pipe *pipe, int ival));\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic u_int8_t revbits[OHCI_NO_INTRS] = \n  { 0x00, 0x10, 0x08, 0x18, 0x04, 0x14, 0x0c, 0x1c,\n    0x02, 0x12, 0x0a, 0x1a, 0x06, 0x16, 0x0e, 0x1e,\n    0x01, 0x11, 0x09, 0x19, 0x05, 0x15, 0x0d, 0x1d,\n    0x03, 0x13, 0x0b, 0x1b, 0x07, 0x17, 0x0f, 0x1f };\nStatic struct;\nusbd_bus_methods ohci_bus_methods = {\n\tohci_open,\n\tohci_softintr,\n\tohci_poll,\n\tohci_allocm,\n\tohci_freem,\n\tohci_allocx,\n\tohci_freex,\n};\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\n\nusbd_status\nohci_init(sc)\n\tohci_softc_t *sc;\n{\n\tohci_soft_ed_t *sed, *psed;\n\tusbd_status err;\n\tint i;\n\tu_int32_t s, ctl, ival, hcr, fm, per, rev, desca;\n\n\tDPRINTF((\"ohci_init: start\\n\"));\n#if defined(__OpenBSD__)\n\tprintf(\",\");\n#else\n\tprintf(\"%s:\", USBDEVNAME(sc->sc_bus.bdev));\n#endif\n\trev = OREAD4(sc, OHCI_REVISION);\n\tprintf(\" OHCI version %d.%d%s\\n\", OHCI_REV_HI(rev), OHCI_REV_LO(rev),\n\t       OHCI_REV_LEGACY(rev) ? \", legacy support\" : \"\");\n\n\tif (OHCI_REV_HI(rev) != 1 || OHCI_REV_LO(rev) != 0) {\n\t\tprintf(\"%s: unsupported OHCI revision\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\tsc->sc_bus.usbrev = USBREV_UNKNOWN;\n\t\treturn (USBD_INVAL);\n\t}\n\tsc->sc_bus.usbrev = USBREV_1_0;\n\n\tfor (i = 0; i < OHCI_HASH_SIZE; i++)\n\t\tLIST_INIT(&sc->sc_hash_tds[i]);\n\tfor (i = 0; i < OHCI_HASH_SIZE; i++)\n\t\tLIST_INIT(&sc->sc_hash_itds[i]);\n\n\tSIMPLEQ_INIT(&sc->sc_free_xfers);\n\n\t/* XXX determine alignment by R/W */\n\t/* Allocate the HCCA area. */\n\terr = usb_allocmem(&sc->sc_bus, OHCI_HCCA_SIZE, \n\t\t\t OHCI_HCCA_ALIGN, &sc->sc_hccadma);\n\tif (err)\n\t\treturn (err);\n\tsc->sc_hcca = (struct ohci_hcca *)KERNADDR(&sc->sc_hccadma);\n\tmemset(sc->sc_hcca, 0, OHCI_HCCA_SIZE);\n\n\tsc->sc_eintrs = OHCI_NORMAL_INTRS;\n\n\t/* Allocate dummy ED that starts the control list. */\n\tsc->sc_ctrl_head = ohci_alloc_sed(sc);\n\tif (sc->sc_ctrl_head == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tsc->sc_ctrl_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\n\t/* Allocate dummy ED that starts the bulk list. */\n\tsc->sc_bulk_head = ohci_alloc_sed(sc);\n\tif (sc->sc_bulk_head == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad2;\n\t}\n\tsc->sc_bulk_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\n\t/* Allocate dummy ED that starts the isochronous list. */\n\tsc->sc_isoc_head = ohci_alloc_sed(sc);\n\tif (sc->sc_isoc_head == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad3;\n\t}\n\tsc->sc_isoc_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\n\t/* Allocate all the dummy EDs that make up the interrupt tree. */\n\tfor (i = 0; i < OHCI_NO_EDS; i++) {\n\t\tsed = ohci_alloc_sed(sc);\n\t\tif (sed == NULL) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tohci_free_sed(sc, sc->sc_eds[i]);\n\t\t\terr = USBD_NOMEM;\n\t\t\tgoto bad4;\n\t\t}\n\t\t/* All ED fields are set to 0. */\n\t\tsc->sc_eds[i] = sed;\n\t\tsed->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\t\tif (i != 0)\n\t\t\tpsed = sc->sc_eds[(i-1) / 2];\n\t\telse\n\t\t\tpsed= sc->sc_isoc_head;\n\t\tsed->next = psed;\n\t\tsed->ed.ed_nexted = htole32(psed->physaddr);\n\t}\n\t/* \n\t * Fill HCCA interrupt table.  The bit reversal is to get\n\t * the tree set up properly to spread the interrupts.\n\t */\n\tfor (i = 0; i < OHCI_NO_INTRS; i++)\n\t\tsc->sc_hcca->hcca_interrupt_table[revbits[i]] = \n\t\t    htole32(sc->sc_eds[OHCI_NO_EDS-OHCI_NO_INTRS+i]->physaddr);\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 15) {\n\t\tfor (i = 0; i < OHCI_NO_EDS; i++) {\n\t\t\tprintf(\"ed#%d \", i);\n\t\t\tohci_dump_ed(sc->sc_eds[i]);\n\t\t}\n\t\tprintf(\"iso \");\n\t\tohci_dump_ed(sc->sc_isoc_head);\n\t}\n#endif\n\n\t/* Determine in what context we are running. */\n\tctl = OREAD4(sc, OHCI_CONTROL);\n\tif (ctl & OHCI_IR) {\n\t\t/* SMM active, request change */\n\t\tDPRINTF((\"ohci_init: SMM active, request owner change\\n\"));\n\t\ts = OREAD4(sc, OHCI_COMMAND_STATUS);\n\t\tOWRITE4(sc, OHCI_COMMAND_STATUS, s | OHCI_OCR);\n\t\tfor (i = 0; i < 100 && (ctl & OHCI_IR); i++) {\n\t\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t\t\tctl = OREAD4(sc, OHCI_CONTROL);\n\t\t}\n\t\tif ((ctl & OHCI_IR) == 0) {\n\t\t\tprintf(\"%s: SMM does not respond, resetting\\n\",\n\t\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\t\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);\n\t\t\tgoto reset;\n\t\t}\n\t} else if ((ctl & OHCI_HCFS_MASK) != OHCI_HCFS_RESET) {\n\t\t/* BIOS started controller. */\n\t\tDPRINTF((\"ohci_init: BIOS active\\n\"));\n\t\tif ((ctl & OHCI_HCFS_MASK) != OHCI_HCFS_OPERATIONAL) {\n\t\t\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_OPERATIONAL);\n\t\t\tusb_delay_ms(&sc->sc_bus, USB_RESUME_DELAY);\n\t\t}\n\t} else {\n\t\tDPRINTF((\"ohci_init: cold started\\n\"));\n\treset:\n\t\t/* Controller was cold started. */\n\t\tusb_delay_ms(&sc->sc_bus, USB_BUS_RESET_DELAY);\n\t}\n\n\t/*\n\t * This reset should not be necessary according to the OHCI spec, but\n\t * without it some controllers do not start.\n\t */\n\tDPRINTF((\"%s: resetting\\n\", USBDEVNAME(sc->sc_bus.bdev)));\n\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);\n\tusb_delay_ms(&sc->sc_bus, USB_BUS_RESET_DELAY);\n\n\t/* We now own the host controller and the bus has been reset. */\n\tival = OHCI_GET_IVAL(OREAD4(sc, OHCI_FM_INTERVAL));\n\n\tOWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_HCR); /* Reset HC */\n\t/* Nominal time for a reset is 10 us. */\n\tfor (i = 0; i < 10; i++) {\n\t\tdelay(10);\n\t\thcr = OREAD4(sc, OHCI_COMMAND_STATUS) & OHCI_HCR;\n\t\tif (!hcr)\n\t\t\tbreak;\n\t}\n\tif (hcr) {\n\t\tprintf(\"%s: reset timeout\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t\terr = USBD_IOERROR;\n\t\tgoto bad5;\n\t}\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 15)\n\t\tohci_dumpregs(sc);\n#endif\n\n\t/* The controller is now in SUSPEND state, we have 2ms to finish. */\n\n\t/* Set up HC registers. */\n\tOWRITE4(sc, OHCI_HCCA, DMAADDR(&sc->sc_hccadma));\n\tOWRITE4(sc, OHCI_CONTROL_HEAD_ED, sc->sc_ctrl_head->physaddr);\n\tOWRITE4(sc, OHCI_BULK_HEAD_ED, sc->sc_bulk_head->physaddr);\n\t/* disable all interrupts and then switch on all desired interrupts */\n\tOWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_ALL_INTRS);\n\tOWRITE4(sc, OHCI_INTERRUPT_ENABLE, sc->sc_eintrs | OHCI_MIE);\n\t/* switch on desired functional features */\n\tctl = OREAD4(sc, OHCI_CONTROL);\n\tctl &= ~(OHCI_CBSR_MASK | OHCI_LES | OHCI_HCFS_MASK | OHCI_IR);\n\tctl |= OHCI_PLE | OHCI_IE | OHCI_CLE | OHCI_BLE |\n\t\tOHCI_RATIO_1_4 | OHCI_HCFS_OPERATIONAL;\n\t/* And finally start it! */\n\tOWRITE4(sc, OHCI_CONTROL, ctl);\n\n\t/*\n\t * The controller is now OPERATIONAL.  Set a some final\n\t * registers that should be set earlier, but that the\n\t * controller ignores when in the SUSPEND state.\n\t */\n\tfm = (OREAD4(sc, OHCI_FM_INTERVAL) & OHCI_FIT) ^ OHCI_FIT;\n\tfm |= OHCI_FSMPS(ival) | ival;\n\tOWRITE4(sc, OHCI_FM_INTERVAL, fm);\n\tper = OHCI_PERIODIC(ival); /* 90% periodic */\n\tOWRITE4(sc, OHCI_PERIODIC_START, per);\n\n\t/* Fiddle the No OverCurrent Protection bit to avoid chip bug. */\n\tdesca = OREAD4(sc, OHCI_RH_DESCRIPTOR_A);\n\tOWRITE4(sc, OHCI_RH_DESCRIPTOR_A, desca | OHCI_NOCP);\n\tOWRITE4(sc, OHCI_RH_STATUS, OHCI_LPSC); /* Enable port power */\n\tusb_delay_ms(&sc->sc_bus, OHCI_ENABLE_POWER_DELAY);\n\tOWRITE4(sc, OHCI_RH_DESCRIPTOR_A, desca);\n\n\t/*\n\t * The AMD756 requires a delay before re-reading the register,\n\t * otherwise it will occasionally report 0 ports.\n\t */\n\tusb_delay_ms(&sc->sc_bus, OHCI_READ_DESC_DELAY);\n\tsc->sc_noport = OHCI_GET_NDP(OREAD4(sc, OHCI_RH_DESCRIPTOR_A));\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5)\n\t\tohci_dumpregs(sc);\n#endif\n\t\n\t/* Set up the bus struct. */\n\tsc->sc_bus.methods = &ohci_bus_methods;\n\tsc->sc_bus.pipe_size = sizeof(struct ohci_pipe);\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tsc->sc_powerhook = powerhook_establish(ohci_power, sc);\n\tsc->sc_shutdownhook = shutdownhook_establish(ohci_shutdown, sc);\n#endif\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad5:\n\tfor (i = 0; i < OHCI_NO_EDS; i++)\n\t\tohci_free_sed(sc, sc->sc_eds[i]);\n bad4:\n\tohci_free_sed(sc, sc->sc_isoc_head);\n bad3:\n\tohci_free_sed(sc, sc->sc_ctrl_head);\n bad2:\n\tohci_free_sed(sc, sc->sc_bulk_head);\n bad1:\n\tusb_freemem(&sc->sc_bus, &sc->sc_hccadma);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pc",
            "ih",
            "IPL_USB",
            "ohci_intr",
            "sc",
            "sc->sc.sc_bus.bdev.dv_xname"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pc",
            "ih"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&ih"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG",
            "csr | PCI_COMMAND_MASTER_ENABLE"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "sc->sc.iot",
            "sc->sc.ioh",
            "OHCI_INTERRUPT_DISABLE",
            "OHCI_ALL_INTRS"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_mapreg_map",
          "args": [
            "pa",
            "PCI_CBMEM",
            "PCI_MAPREG_TYPE_MEM",
            "0",
            "&sc->sc.iot",
            "&sc->sc.ioh",
            "NULL",
            "NULL"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mapreg_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "230-275",
          "snippet": "int\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find",
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\nstatic int nbsd_pci_mem_find;\n\nint\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tohci_pci_attach;\n\nvoid\nohci_pci_attach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tstruct ohci_pci_softc *sc = (struct ohci_pci_softc *)self;\n\tstruct pci_attach_args *pa = (struct pci_attach_args *)aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tchar const *intrstr;\n\tpci_intr_handle_t ih;\n\tpcireg_t csr;\n\tusbd_status r;\n\n\t/* Map I/O registers */\n\tif (pci_mapreg_map(pa, PCI_CBMEM, PCI_MAPREG_TYPE_MEM, 0,\n\t\t\t   &sc->sc.iot, &sc->sc.ioh, NULL, NULL)) {\n\t\tprintf(\": can't map mem space\\n\");\n\t\treturn;\n\t}\n\n\t/* Disable interrupts, so we don't get any spurious ones. */\n\tbus_space_write_4(sc->sc.iot, sc->sc.ioh, OHCI_INTERRUPT_DISABLE,\n\t\t\t  OHCI_ALL_INTRS);\n\n\tsc->sc_pc = pc;\n\tsc->sc.sc_bus.dmatag = pa->pa_dmat;\n\n\t/* Enable the device. */\n\tcsr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t       csr | PCI_COMMAND_MASTER_ENABLE);\n\n\t/* Map and establish the interrupt. */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\treturn;\n\t}\n\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_USB, ohci_intr, sc,\n\t    sc->sc.sc_bus.bdev.dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\": couldn't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf(\": %s\", intrstr);\n\n\tr = ohci_init(&sc->sc);\n\tif (r != USBD_NORMAL_COMPLETION) {\n\t\tprintf(\": init failed, error=%d\\n\", r);\n\t\treturn;\n\t}\n\n\t/* Attach usb device. */\n\tsc->sc.sc_child = config_found((void *)sc, &sc->sc.sc_bus,\n\t\t\t\t       usbctlprint);\n}"
  },
  {
    "function_name": "ohci_pci_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ohci_pci.c",
    "lines": "83-96",
    "snippet": "int\nohci_pci_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pci_attach_args *pa = (struct pci_attach_args *) aux;\n\n\tif (PCI_CLASS(pa->pa_class) == PCI_CLASS_SERIALBUS &&\n\t    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_SERIALBUS_USB &&\n\t    PCI_INTERFACE(pa->pa_class) == PCI_INTERFACE_OHCI)\n\t\treturn (1);\n \n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tohci_pci_match"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_INTERFACE",
          "args": [
            "pa->pa_class"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_SUBCLASS",
          "args": [
            "pa->pa_class"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CLASS",
          "args": [
            "pa->pa_class"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tohci_pci_match;\n\nint\nohci_pci_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pci_attach_args *pa = (struct pci_attach_args *) aux;\n\n\tif (PCI_CLASS(pa->pa_class) == PCI_CLASS_SERIALBUS &&\n\t    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_SERIALBUS_USB &&\n\t    PCI_INTERFACE(pa->pa_class) == PCI_INTERFACE_OHCI)\n\t\treturn (1);\n \n\treturn (0);\n}"
  }
]