[
  {
    "function_name": "ucomprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "1081-1090",
    "snippet": "int\nucomprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\n\tif (pnp)\n\t\tprintf(\"ucom at %s\\n\", pnp);\n\treturn (UNCONF);\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int s;",
      "void *aux;",
      "void *aux;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ucom at %s\\n\"",
            "pnp"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint s;\nvoid *aux;\nvoid *aux;\n\nint\nucomprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\n\tif (pnp)\n\t\tprintf(\"ucom at %s\\n\", pnp);\n\treturn (UNCONF);\n}"
  },
  {
    "function_name": "ucom_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "1064-1077",
    "snippet": "Static void\nucom_cleanup(sc)\n\tstruct ucom_softc *sc;\n{\n\tDPRINTF((\"ucom_cleanup: closing pipes\\n\"));\n\n\tucom_shutdown(sc);\n\tusbd_abort_pipe(sc->sc_bulkin_pipe);\n\tusbd_close_pipe(sc->sc_bulkin_pipe);\n\tusbd_abort_pipe(sc->sc_bulkout_pipe);\n\tusbd_close_pipe(sc->sc_bulkout_pipe);\n\tusbd_free_xfer(sc->sc_ixfer);\n\tusbd_free_xfer(sc->sc_oxfer);\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "ucom_cleanup\t__P((struct ucom_softc *));",
      "Static void",
      "ucom_hwiflow\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "Static void",
      "ucom_shutdown\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "ucom_dtr\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_rts\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_break\t__P((struct ucom_softc *, int));",
      "ucomstartread __P((struct ucom_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
      "Static int",
      "ucom_to_tiocm\t__P((struct ucom_softc *));",
      "struct ucom_softc *sc;",
      "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_free_xfer",
          "args": [
            "sc->sc_oxfer"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "403-418",
          "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_close_pipe",
          "args": [
            "sc->sc_bulkout_pipe"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_close_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "224-252",
          "snippet": "usbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_abort_pipe",
          "args": [
            "sc->sc_bulkout_pipe"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_abort_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "560-577",
          "snippet": "usbd_status \nusbd_abort_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_status err;\n\tint s;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\ts = splusb();\n\terr = usbd_ar_pipe(pipe);\n\tsplx(s);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status \nusbd_abort_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_status err;\n\tint s;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\ts = splusb();\n\terr = usbd_ar_pipe(pipe);\n\tsplx(s);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ucom_shutdown",
          "args": [
            "sc"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "ucom_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
          "lines": "250-265",
          "snippet": "void\nucom_shutdown(sc)\n\tstruct ucom_softc *sc;\n{\n\tstruct tty *tp = sc->sc_tty;\n\n\tDPRINTF((\"ucom_shutdown\\n\"));\n\t/*\n\t * Hang up if necessary.  Wait a bit, so the other side has time to\n\t * notice even if we immediately open the port again.\n\t */\n\tif (ISSET(tp->t_cflag, HUPCL)) {\n\t\tucom_dtr(sc, 0);\n\t\t(void)tsleep(sc, TTIPRI, ttclos, hz);\n\t}\n}",
          "includes": [
            "#include \"ucom.h\"",
            "#include <dev/usb/ucomvar.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ucom_cleanup\t__P((struct ucom_softc *));",
            "ucom_hwiflow\t__P((struct ucom_softc *));",
            "ucomstart\t__P((struct tty *));",
            "ucom_shutdown\t__P((struct ucom_softc *));",
            "ucom_dtr\t__P((struct ucom_softc *, int));",
            "ucom_rts\t__P((struct ucom_softc *, int));",
            "ucom_break\t__P((struct ucom_softc *, int));",
            "ucomstartread __P((struct ucom_softc *));",
            "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
            "ucom_to_tiocm\t__P((struct ucom_softc *));",
            "struct ucom_softc *sc;",
            "struct tty *tp;",
            "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];",
            "struct tty *tp = sc->sc_tty;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nucom_cleanup\t__P((struct ucom_softc *));\nucom_hwiflow\t__P((struct ucom_softc *));\nucomstart\t__P((struct tty *));\nucom_shutdown\t__P((struct ucom_softc *));\nucom_dtr\t__P((struct ucom_softc *, int));\nucom_rts\t__P((struct ucom_softc *, int));\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct ucom_softc *sc;\nstruct tty *tp;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\nstruct tty *tp = sc->sc_tty;\n\nvoid\nucom_shutdown(sc)\n\tstruct ucom_softc *sc;\n{\n\tstruct tty *tp = sc->sc_tty;\n\n\tDPRINTF((\"ucom_shutdown\\n\"));\n\t/*\n\t * Hang up if necessary.  Wait a bit, so the other side has time to\n\t * notice even if we immediately open the port again.\n\t */\n\tif (ISSET(tp->t_cflag, HUPCL)) {\n\t\tucom_dtr(sc, 0);\n\t\t(void)tsleep(sc, TTIPRI, ttclos, hz);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ucom_cleanup: closing pipes\\n\")"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct ucom_softc *sc;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\nStatic void\nucom_cleanup(sc)\n\tstruct ucom_softc *sc;\n{\n\tDPRINTF((\"ucom_cleanup: closing pipes\\n\"));\n\n\tucom_shutdown(sc);\n\tusbd_abort_pipe(sc->sc_bulkin_pipe);\n\tusbd_close_pipe(sc->sc_bulkin_pipe);\n\tusbd_abort_pipe(sc->sc_bulkout_pipe);\n\tusbd_close_pipe(sc->sc_bulkout_pipe);\n\tusbd_free_xfer(sc->sc_ixfer);\n\tusbd_free_xfer(sc->sc_oxfer);\n}"
  },
  {
    "function_name": "ucomreadcb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "1014-1062",
    "snippet": "Static void\nucomreadcb(xfer, p, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle p;\n\tusbd_status status;\n{\n\tstruct ucom_softc *sc = (struct ucom_softc *)p;\n\tstruct tty *tp = sc->sc_tty;\n\tint (*rint) __P((int c, struct tty *tp)) = linesw[tp->t_line].l_rint;\n\tusbd_status err;\n\tu_int32_t cc;\n\tu_char *cp;\n\tint s;\n\n\tif (status == USBD_CANCELLED)\n\t\treturn;\n\n\tif (status) {\n\t\tDPRINTF((\"ucomreadcb: status=%d\\n\", status));\n\t\tusbd_clear_endpoint_stall_async(sc->sc_bulkin_pipe);\n\t\t/* XXX we should restart after some delay. */\n\t\treturn;\n\t}\n\n\tusbd_get_xfer_status(xfer, NULL, (void **)&cp, &cc, NULL);\n\tDPRINTFN(5,(\"ucomreadcb: got %d chars, tp=%p\\n\", cc, tp));\n\tif (sc->sc_methods->ucom_read != NULL)\n\t\tsc->sc_methods->ucom_read(sc->sc_parent, sc->sc_portno,\n\t\t\t\t\t  &cp, &cc);\n\n\ts = spltty();\n\t/* Give characters to tty layer. */\n\twhile (cc-- > 0) {\n\t\tDPRINTFN(7,(\"ucomreadcb: char=0x%02x\\n\", *cp));\n\t\tif ((*rint)(*cp++, tp) == -1) {\n\t\t\t/* XXX what should we do? */\n\t\t\tprintf(\"%s: lost %d chars\\n\", USBDEVNAME(sc->sc_dev),\n\t\t\t       cc);\n\t\t\tbreak;\n\t\t}\n\t}\n\tsplx(s);\n\n\terr = ucomstartread(sc);\n\tif (err) {\n\t\tprintf(\"%s: read start failed\\n\", USBDEVNAME(sc->sc_dev));\n\t\t/* XXX what should we dow now? */\n\t}\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "ucom_cleanup\t__P((struct ucom_softc *));",
      "Static void",
      "ucom_hwiflow\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "ucomstart\t__P((struct tty *));",
      "Static void",
      "ucom_shutdown\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "ucom_dtr\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_rts\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_break\t__P((struct ucom_softc *, int));",
      "Static usbd_status",
      "ucomstartread __P((struct ucom_softc *));",
      "Static void",
      "ucomreadcb\t__P((usbd_xfer_handle, usbd_private_handle, \n\t\t\t\t     usbd_status status));",
      "Static void",
      "ucomwritecb\t__P((usbd_xfer_handle, usbd_private_handle, \n\t\t\t\t     usbd_status status));",
      "Static void",
      "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
      "Static int",
      "ucom_to_tiocm\t__P((struct ucom_softc *));",
      "struct proc *p;",
      "usbd_status err;",
      "struct ucom_softc *sc;",
      "struct tty *tp;",
      "int s;",
      "struct proc *p;",
      "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];",
      "struct tty *tp = sc->sc_tty;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: read start failed\\n\"",
            "USBDEVNAME(sc->sc_dev)"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucomstartread",
          "args": [
            "sc"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "ucomstartread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
          "lines": "994-1012",
          "snippet": "Static usbd_status\nucomstartread(sc)\n\tstruct ucom_softc *sc;\n{\n\tusbd_status err;\n\n\tDPRINTFN(5,(\"ucomstartread: start\\n\"));\n\tusbd_setup_xfer(sc->sc_ixfer, sc->sc_bulkin_pipe, \n\t\t\t(usbd_private_handle)sc, \n\t\t\tsc->sc_ibuf, sc->sc_ibufsize,\n\t\t\tUSBD_SHORT_XFER_OK | USBD_NO_COPY,\n\t\t\tUSBD_NO_TIMEOUT, ucomreadcb);\n\terr = usbd_transfer(sc->sc_ixfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tDPRINTF((\"ucomstartread: err=%s\\n\", usbd_errstr(err)));\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"ucom.h\"",
            "#include <dev/usb/ucomvar.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "ucom_cleanup\t__P((struct ucom_softc *));",
            "Static void",
            "ucom_hwiflow\t__P((struct ucom_softc *));",
            "Static int",
            "Static void",
            "Static void",
            "ucom_shutdown\t__P((struct ucom_softc *));",
            "Static int",
            "Static void",
            "ucom_dtr\t__P((struct ucom_softc *, int));",
            "Static void",
            "ucom_rts\t__P((struct ucom_softc *, int));",
            "Static void",
            "ucom_break\t__P((struct ucom_softc *, int));",
            "Static usbd_status",
            "ucomstartread __P((struct ucom_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
            "Static int",
            "ucom_to_tiocm\t__P((struct ucom_softc *));",
            "usbd_status err;",
            "struct ucom_softc *sc;",
            "int s;",
            "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nStatic usbd_status;\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nusbd_status err;\nstruct ucom_softc *sc;\nint s;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\nStatic usbd_status\nucomstartread(sc)\n\tstruct ucom_softc *sc;\n{\n\tusbd_status err;\n\n\tDPRINTFN(5,(\"ucomstartread: start\\n\"));\n\tusbd_setup_xfer(sc->sc_ixfer, sc->sc_bulkin_pipe, \n\t\t\t(usbd_private_handle)sc, \n\t\t\tsc->sc_ibuf, sc->sc_ibufsize,\n\t\t\tUSBD_SHORT_XFER_OK | USBD_NO_COPY,\n\t\t\tUSBD_NO_TIMEOUT, ucomreadcb);\n\terr = usbd_transfer(sc->sc_ixfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tDPRINTF((\"ucomstartread: err=%s\\n\", usbd_errstr(err)));\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "*cp++",
            "tp"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "7",
            "(\"ucomreadcb: char=0x%02x\\n\", *cp)"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->sc_methods->ucom_read",
          "args": [
            "sc->sc_parent",
            "sc->sc_portno",
            "&cp",
            "&cc"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ucomreadcb: got %d chars, tp=%p\\n\", cc, tp)"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_xfer_status",
          "args": [
            "xfer",
            "NULL",
            "(void **)&cp",
            "&cc",
            "NULL"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_xfer_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "499-515",
          "snippet": "void\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nvoid\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_clear_endpoint_stall_async",
          "args": [
            "sc->sc_bulkin_pipe"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_clear_endpoint_stall_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "611-628",
          "snippet": "usbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ucomreadcb: status=%d\\n\", status)"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucomstart\t__P((struct tty *));\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nStatic usbd_status;\nucomstartread __P((struct ucom_softc *));\nStatic void;\nucomreadcb\t__P((usbd_xfer_handle, usbd_private_handle, \n\t\t\t\t     usbd_status status));\nStatic void;\nucomwritecb\t__P((usbd_xfer_handle, usbd_private_handle, \n\t\t\t\t     usbd_status status));\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct proc *p;\nusbd_status err;\nstruct ucom_softc *sc;\nstruct tty *tp;\nint s;\nstruct proc *p;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\nstruct tty *tp = sc->sc_tty;\n\nStatic void\nucomreadcb(xfer, p, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle p;\n\tusbd_status status;\n{\n\tstruct ucom_softc *sc = (struct ucom_softc *)p;\n\tstruct tty *tp = sc->sc_tty;\n\tint (*rint) __P((int c, struct tty *tp)) = linesw[tp->t_line].l_rint;\n\tusbd_status err;\n\tu_int32_t cc;\n\tu_char *cp;\n\tint s;\n\n\tif (status == USBD_CANCELLED)\n\t\treturn;\n\n\tif (status) {\n\t\tDPRINTF((\"ucomreadcb: status=%d\\n\", status));\n\t\tusbd_clear_endpoint_stall_async(sc->sc_bulkin_pipe);\n\t\t/* XXX we should restart after some delay. */\n\t\treturn;\n\t}\n\n\tusbd_get_xfer_status(xfer, NULL, (void **)&cp, &cc, NULL);\n\tDPRINTFN(5,(\"ucomreadcb: got %d chars, tp=%p\\n\", cc, tp));\n\tif (sc->sc_methods->ucom_read != NULL)\n\t\tsc->sc_methods->ucom_read(sc->sc_parent, sc->sc_portno,\n\t\t\t\t\t  &cp, &cc);\n\n\ts = spltty();\n\t/* Give characters to tty layer. */\n\twhile (cc-- > 0) {\n\t\tDPRINTFN(7,(\"ucomreadcb: char=0x%02x\\n\", *cp));\n\t\tif ((*rint)(*cp++, tp) == -1) {\n\t\t\t/* XXX what should we do? */\n\t\t\tprintf(\"%s: lost %d chars\\n\", USBDEVNAME(sc->sc_dev),\n\t\t\t       cc);\n\t\t\tbreak;\n\t\t}\n\t}\n\tsplx(s);\n\n\terr = ucomstartread(sc);\n\tif (err) {\n\t\tprintf(\"%s: read start failed\\n\", USBDEVNAME(sc->sc_dev));\n\t\t/* XXX what should we dow now? */\n\t}\n}"
  },
  {
    "function_name": "ucomstartread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "994-1012",
    "snippet": "Static usbd_status\nucomstartread(sc)\n\tstruct ucom_softc *sc;\n{\n\tusbd_status err;\n\n\tDPRINTFN(5,(\"ucomstartread: start\\n\"));\n\tusbd_setup_xfer(sc->sc_ixfer, sc->sc_bulkin_pipe, \n\t\t\t(usbd_private_handle)sc, \n\t\t\tsc->sc_ibuf, sc->sc_ibufsize,\n\t\t\tUSBD_SHORT_XFER_OK | USBD_NO_COPY,\n\t\t\tUSBD_NO_TIMEOUT, ucomreadcb);\n\terr = usbd_transfer(sc->sc_ixfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tDPRINTF((\"ucomstartread: err=%s\\n\", usbd_errstr(err)));\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "ucom_cleanup\t__P((struct ucom_softc *));",
      "Static void",
      "ucom_hwiflow\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "Static void",
      "ucom_shutdown\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "ucom_dtr\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_rts\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_break\t__P((struct ucom_softc *, int));",
      "Static usbd_status",
      "ucomstartread __P((struct ucom_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
      "Static int",
      "ucom_to_tiocm\t__P((struct ucom_softc *));",
      "usbd_status err;",
      "struct ucom_softc *sc;",
      "int s;",
      "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ucomstartread: err=%s\\n\", usbd_errstr(err))"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "sc->sc_ixfer"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_xfer",
          "args": [
            "sc->sc_ixfer",
            "sc->sc_bulkin_pipe",
            "(usbd_private_handle)sc",
            "sc->sc_ibuf",
            "sc->sc_ibufsize",
            "USBD_SHORT_XFER_OK | USBD_NO_COPY",
            "USBD_NO_TIMEOUT",
            "ucomreadcb"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "420-444",
          "snippet": "void\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ucomstartread: start\\n\")"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nStatic usbd_status;\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nusbd_status err;\nstruct ucom_softc *sc;\nint s;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\nStatic usbd_status\nucomstartread(sc)\n\tstruct ucom_softc *sc;\n{\n\tusbd_status err;\n\n\tDPRINTFN(5,(\"ucomstartread: start\\n\"));\n\tusbd_setup_xfer(sc->sc_ixfer, sc->sc_bulkin_pipe, \n\t\t\t(usbd_private_handle)sc, \n\t\t\tsc->sc_ibuf, sc->sc_ibufsize,\n\t\t\tUSBD_SHORT_XFER_OK | USBD_NO_COPY,\n\t\t\tUSBD_NO_TIMEOUT, ucomreadcb);\n\terr = usbd_transfer(sc->sc_ixfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tDPRINTF((\"ucomstartread: err=%s\\n\", usbd_errstr(err)));\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "ucomwritecb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "958-992",
    "snippet": "Static void\nucomwritecb(xfer, p, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle p;\n\tusbd_status status;\n{\n\tstruct ucom_softc *sc = (struct ucom_softc *)p;\n\tstruct tty *tp = sc->sc_tty;\n\tu_int32_t cc;\n\tint s;\n\n\tDPRINTFN(5,(\"ucomwritecb: status=%d\\n\", status));\n\n\tif (status == USBD_CANCELLED)\n\t\treturn;\n\n\tif (status) {\n\t\tDPRINTF((\"ucomwritecb: status=%d\\n\", status));\n\t\tusbd_clear_endpoint_stall_async(sc->sc_bulkin_pipe);\n\t\t/* XXX we should restart after some delay. */\n\t\treturn;\n\t}\n\n\tusbd_get_xfer_status(xfer, NULL, NULL, &cc, NULL);\n\tDPRINTFN(5,(\"ucomwritecb: cc=%d\\n\", cc));\n\n\ts = spltty();\n\tCLR(tp->t_state, TS_BUSY);\n\tif (ISSET(tp->t_state, TS_FLUSH))\n\t\tCLR(tp->t_state, TS_FLUSH);\n\telse\n\t\tndflush(&tp->t_outq, cc);\n\t(*linesw[tp->t_line].l_start)(tp);\n\tsplx(s);\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "ucom_cleanup\t__P((struct ucom_softc *));",
      "Static void",
      "ucom_hwiflow\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "ucomstart\t__P((struct tty *));",
      "Static void",
      "ucom_shutdown\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "ucom_dtr\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_rts\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_break\t__P((struct ucom_softc *, int));",
      "Static usbd_status",
      "ucomstartread __P((struct ucom_softc *));",
      "Static void",
      "ucomreadcb\t__P((usbd_xfer_handle, usbd_private_handle, \n\t\t\t\t     usbd_status status));",
      "Static void",
      "ucomwritecb\t__P((usbd_xfer_handle, usbd_private_handle, \n\t\t\t\t     usbd_status status));",
      "Static void",
      "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
      "Static int",
      "ucom_to_tiocm\t__P((struct ucom_softc *));",
      "struct proc *p;",
      "struct ucom_softc *sc;",
      "struct tty *tp;",
      "int s;",
      "struct proc *p;",
      "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];",
      "struct tty *tp = sc->sc_tty;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tp"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndflush",
          "args": [
            "&tp->t_outq",
            "cc"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLR",
          "args": [
            "tp->t_state",
            "TS_FLUSH"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "tp->t_state",
            "TS_FLUSH"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLR",
          "args": [
            "tp->t_state",
            "TS_BUSY"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ucomwritecb: cc=%d\\n\", cc)"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_xfer_status",
          "args": [
            "xfer",
            "NULL",
            "NULL",
            "&cc",
            "NULL"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_xfer_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "499-515",
          "snippet": "void\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nvoid\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_clear_endpoint_stall_async",
          "args": [
            "sc->sc_bulkin_pipe"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_clear_endpoint_stall_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "611-628",
          "snippet": "usbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ucomwritecb: status=%d\\n\", status)"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ucomwritecb: status=%d\\n\", status)"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucomstart\t__P((struct tty *));\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nStatic usbd_status;\nucomstartread __P((struct ucom_softc *));\nStatic void;\nucomreadcb\t__P((usbd_xfer_handle, usbd_private_handle, \n\t\t\t\t     usbd_status status));\nStatic void;\nucomwritecb\t__P((usbd_xfer_handle, usbd_private_handle, \n\t\t\t\t     usbd_status status));\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct proc *p;\nstruct ucom_softc *sc;\nstruct tty *tp;\nint s;\nstruct proc *p;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\nstruct tty *tp = sc->sc_tty;\n\nStatic void\nucomwritecb(xfer, p, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle p;\n\tusbd_status status;\n{\n\tstruct ucom_softc *sc = (struct ucom_softc *)p;\n\tstruct tty *tp = sc->sc_tty;\n\tu_int32_t cc;\n\tint s;\n\n\tDPRINTFN(5,(\"ucomwritecb: status=%d\\n\", status));\n\n\tif (status == USBD_CANCELLED)\n\t\treturn;\n\n\tif (status) {\n\t\tDPRINTF((\"ucomwritecb: status=%d\\n\", status));\n\t\tusbd_clear_endpoint_stall_async(sc->sc_bulkin_pipe);\n\t\t/* XXX we should restart after some delay. */\n\t\treturn;\n\t}\n\n\tusbd_get_xfer_status(xfer, NULL, NULL, &cc, NULL);\n\tDPRINTFN(5,(\"ucomwritecb: cc=%d\\n\", cc));\n\n\ts = spltty();\n\tCLR(tp->t_state, TS_BUSY);\n\tif (ISSET(tp->t_state, TS_FLUSH))\n\t\tCLR(tp->t_state, TS_FLUSH);\n\telse\n\t\tndflush(&tp->t_outq, cc);\n\t(*linesw[tp->t_line].l_start)(tp);\n\tsplx(s);\n}"
  },
  {
    "function_name": "ucomstop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "933-956",
    "snippet": "int\n#endif\nucomstop(tp, flag)\n\tstruct tty *tp;\n\tint flag;\n{\n\tDPRINTF((\"ucomstop: flag=%d\\n\", flag));\n#if 0\n\t/*struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(tp->t_dev)];*/\n\tint s;\n\n\ts = spltty();\n\tif (ISSET(tp->t_state, TS_BUSY)) {\n\t\tDPRINTF((\"ucomstop: XXX\\n\"));\n\t\t/* sc->sc_tx_stopped = 1; */\n\t\tif (!ISSET(tp->t_state, TS_TTSTOP))\n\t\t\tSET(tp->t_state, TS_FLUSH);\n\t}\n\tsplx(s);\n#endif\n#if !defined(__NetBSD__)\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ucom_cleanup\t__P((struct ucom_softc *));",
      "ucom_hwiflow\t__P((struct ucom_softc *));",
      "ucomstart\t__P((struct tty *));",
      "ucom_shutdown\t__P((struct ucom_softc *));",
      "ucom_dtr\t__P((struct ucom_softc *, int));",
      "ucom_rts\t__P((struct ucom_softc *, int));",
      "ucom_break\t__P((struct ucom_softc *, int));",
      "ucomstartread __P((struct ucom_softc *));",
      "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
      "ucom_to_tiocm\t__P((struct ucom_softc *));",
      "struct ucom_softc *sc;",
      "struct tty *tp;",
      "int s;",
      "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];",
      "struct tty *tp = sc->sc_tty;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "tp->t_state",
            "TS_FLUSH"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "tp->t_state",
            "TS_TTSTOP"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ucomstop: XXX\\n\")"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "tp->t_state",
            "TS_BUSY"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ucomstop: flag=%d\\n\", flag)"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nucom_cleanup\t__P((struct ucom_softc *));\nucom_hwiflow\t__P((struct ucom_softc *));\nucomstart\t__P((struct tty *));\nucom_shutdown\t__P((struct ucom_softc *));\nucom_dtr\t__P((struct ucom_softc *, int));\nucom_rts\t__P((struct ucom_softc *, int));\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct ucom_softc *sc;\nstruct tty *tp;\nint s;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\nstruct tty *tp = sc->sc_tty;\n\nint\n#endif\nucomstop(tp, flag)\n\tstruct tty *tp;\n\tint flag;\n{\n\tDPRINTF((\"ucomstop: flag=%d\\n\", flag));\n#if 0\n\t/*struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(tp->t_dev)];*/\n\tint s;\n\n\ts = spltty();\n\tif (ISSET(tp->t_state, TS_BUSY)) {\n\t\tDPRINTF((\"ucomstop: XXX\\n\"));\n\t\t/* sc->sc_tx_stopped = 1; */\n\t\tif (!ISSET(tp->t_state, TS_TTSTOP))\n\t\t\tSET(tp->t_state, TS_FLUSH);\n\t}\n\tsplx(s);\n#endif\n#if !defined(__NetBSD__)\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "ucomstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "863-928",
    "snippet": "Static void\nucomstart(tp)\n\tstruct tty *tp;\n{\n\tstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(tp->t_dev)];\n\tusbd_status err;\n\tint s;\n\tu_char *data;\n\tint cnt;\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\ts = spltty();\n\tif (ISSET(tp->t_state, TS_BUSY | TS_TIMEOUT | TS_TTSTOP)) {\n\t\tDPRINTFN(4,(\"ucomstart: no go, state=0x%x\\n\", tp->t_state));\n\t\tgoto out;\n\t}\n\tif (sc->sc_tx_stopped)\n\t\tgoto out;\n\n\tif (tp->t_outq.c_cc <= tp->t_lowat) {\n\t\tif (ISSET(tp->t_state, TS_ASLEEP)) {\n\t\t\tCLR(tp->t_state, TS_ASLEEP);\n\t\t\twakeup(&tp->t_outq);\n\t\t}\n\t\tselwakeup(&tp->t_wsel);\n\t\tif (tp->t_outq.c_cc == 0)\n\t\t\tgoto out;\n\t}\n\n\t/* Grab the first contiguous region of buffer space. */\n\tdata = tp->t_outq.c_cf;\n\tcnt = ndqb(&tp->t_outq, 0);\n\n\tif (cnt == 0) {\n\t\tDPRINTF((\"ucomstart: cnt==0\\n\"));\n\t\tgoto out;\n\t}\n\n\tSET(tp->t_state, TS_BUSY);\n\n\tif (cnt > sc->sc_obufsize) {\n\t\tDPRINTF((\"ucomstart: big buffer %d chars\\n\", cnt));\n\t\tcnt = sc->sc_obufsize;\n\t}\n\tif (sc->sc_methods->ucom_write != NULL)\n\t\tsc->sc_methods->ucom_write(sc->sc_parent, sc->sc_portno,\n\t\t\t\t\t   sc->sc_obuf, data, &cnt);\n\telse\n\t\tmemcpy(sc->sc_obuf, data, cnt);\n\n\tDPRINTFN(4,(\"ucomstart: %d chars\\n\", cnt));\n\tusbd_setup_xfer(sc->sc_oxfer, sc->sc_bulkout_pipe, \n\t\t\t(usbd_private_handle)sc, sc->sc_obuf, cnt,\n\t\t\tUSBD_NO_COPY, USBD_NO_TIMEOUT, ucomwritecb);\n\t/* What can we do on error? */\n\terr = usbd_transfer(sc->sc_oxfer);\n#ifdef DIAGNOSTIC\n\tif (err != USBD_IN_PROGRESS)\n\t\tprintf(\"ucomstart: err=%s\\n\", usbd_errstr(err));\n#endif\n\nout:\n\tsplx(s);\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "ucom_cleanup\t__P((struct ucom_softc *));",
      "Static void",
      "ucom_hwiflow\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "ucomstart\t__P((struct tty *));",
      "Static void",
      "ucom_shutdown\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "ucom_dtr\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_rts\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_break\t__P((struct ucom_softc *, int));",
      "Static usbd_status",
      "ucomstartread __P((struct ucom_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
      "Static int",
      "ucom_to_tiocm\t__P((struct ucom_softc *));",
      "usbd_status err;",
      "struct ucom_softc *sc;",
      "struct tty *tp;",
      "int s;",
      "int error;",
      "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];",
      "struct tty *tp = sc->sc_tty;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ucomstart: err=%s\\n\"",
            "usbd_errstr(err)"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "sc->sc_oxfer"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_xfer",
          "args": [
            "sc->sc_oxfer",
            "sc->sc_bulkout_pipe",
            "(usbd_private_handle)sc",
            "sc->sc_obuf",
            "cnt",
            "USBD_NO_COPY",
            "USBD_NO_TIMEOUT",
            "ucomwritecb"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "420-444",
          "snippet": "void\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "4",
            "(\"ucomstart: %d chars\\n\", cnt)"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sc->sc_obuf",
            "data",
            "cnt"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->sc_methods->ucom_write",
          "args": [
            "sc->sc_parent",
            "sc->sc_portno",
            "sc->sc_obuf",
            "data",
            "&cnt"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ucomstart: big buffer %d chars\\n\", cnt)"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "tp->t_state",
            "TS_BUSY"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ucomstart: cnt==0\\n\")"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndqb",
          "args": [
            "&tp->t_outq",
            "0"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selwakeup",
          "args": [
            "&tp->t_wsel"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&tp->t_outq"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CLR",
          "args": [
            "tp->t_state",
            "TS_ASLEEP"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "tp->t_state",
            "TS_ASLEEP"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "4",
            "(\"ucomstart: no go, state=0x%x\\n\", tp->t_state)"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "tp->t_state",
            "TS_BUSY | TS_TIMEOUT | TS_TTSTOP"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UCOMUNIT",
          "args": [
            "tp->t_dev"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucomstart\t__P((struct tty *));\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nStatic usbd_status;\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nusbd_status err;\nstruct ucom_softc *sc;\nstruct tty *tp;\nint s;\nint error;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\nstruct tty *tp = sc->sc_tty;\n\nStatic void\nucomstart(tp)\n\tstruct tty *tp;\n{\n\tstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(tp->t_dev)];\n\tusbd_status err;\n\tint s;\n\tu_char *data;\n\tint cnt;\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\ts = spltty();\n\tif (ISSET(tp->t_state, TS_BUSY | TS_TIMEOUT | TS_TTSTOP)) {\n\t\tDPRINTFN(4,(\"ucomstart: no go, state=0x%x\\n\", tp->t_state));\n\t\tgoto out;\n\t}\n\tif (sc->sc_tx_stopped)\n\t\tgoto out;\n\n\tif (tp->t_outq.c_cc <= tp->t_lowat) {\n\t\tif (ISSET(tp->t_state, TS_ASLEEP)) {\n\t\t\tCLR(tp->t_state, TS_ASLEEP);\n\t\t\twakeup(&tp->t_outq);\n\t\t}\n\t\tselwakeup(&tp->t_wsel);\n\t\tif (tp->t_outq.c_cc == 0)\n\t\t\tgoto out;\n\t}\n\n\t/* Grab the first contiguous region of buffer space. */\n\tdata = tp->t_outq.c_cf;\n\tcnt = ndqb(&tp->t_outq, 0);\n\n\tif (cnt == 0) {\n\t\tDPRINTF((\"ucomstart: cnt==0\\n\"));\n\t\tgoto out;\n\t}\n\n\tSET(tp->t_state, TS_BUSY);\n\n\tif (cnt > sc->sc_obufsize) {\n\t\tDPRINTF((\"ucomstart: big buffer %d chars\\n\", cnt));\n\t\tcnt = sc->sc_obufsize;\n\t}\n\tif (sc->sc_methods->ucom_write != NULL)\n\t\tsc->sc_methods->ucom_write(sc->sc_parent, sc->sc_portno,\n\t\t\t\t\t   sc->sc_obuf, data, &cnt);\n\telse\n\t\tmemcpy(sc->sc_obuf, data, cnt);\n\n\tDPRINTFN(4,(\"ucomstart: %d chars\\n\", cnt));\n\tusbd_setup_xfer(sc->sc_oxfer, sc->sc_bulkout_pipe, \n\t\t\t(usbd_private_handle)sc, sc->sc_obuf, cnt,\n\t\t\tUSBD_NO_COPY, USBD_NO_TIMEOUT, ucomwritecb);\n\t/* What can we do on error? */\n\terr = usbd_transfer(sc->sc_oxfer);\n#ifdef DIAGNOSTIC\n\tif (err != USBD_IN_PROGRESS)\n\t\tprintf(\"ucomstart: err=%s\\n\", usbd_errstr(err));\n#endif\n\nout:\n\tsplx(s);\n}"
  },
  {
    "function_name": "ucom_hwiflow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "839-861",
    "snippet": "Static void\nucom_hwiflow(sc)\n\tstruct ucom_softc *sc;\n{\n\tDPRINTF((\"ucom_hwiflow:\\n\"));\n#if 0\nXXX\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (sc->sc_mcr_rts == 0)\n\t\treturn;\n\n\tif (ISSET(sc->sc_rx_flags, RX_ANY_BLOCK)) {\n\t\tCLR(sc->sc_mcr, sc->sc_mcr_rts);\n\t\tCLR(sc->sc_mcr_active, sc->sc_mcr_rts);\n\t} else {\n\t\tSET(sc->sc_mcr, sc->sc_mcr_rts);\n\t\tSET(sc->sc_mcr_active, sc->sc_mcr_rts);\n\t}\n\tbus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr_active);\n#endif\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "ucom_cleanup\t__P((struct ucom_softc *));",
      "Static void",
      "ucom_hwiflow\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "Static void",
      "ucom_shutdown\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "ucom_dtr\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_rts\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_break\t__P((struct ucom_softc *, int));",
      "ucomstartread __P((struct ucom_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
      "Static int",
      "ucom_to_tiocm\t__P((struct ucom_softc *));",
      "struct ucom_softc *sc;",
      "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "com_mcr",
            "sc->sc_mcr_active"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "sc->sc_mcr_active",
            "sc->sc_mcr_rts"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "sc->sc_mcr",
            "sc->sc_mcr_rts"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLR",
          "args": [
            "sc->sc_mcr_active",
            "sc->sc_mcr_rts"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLR",
          "args": [
            "sc->sc_mcr",
            "sc->sc_mcr_rts"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "sc->sc_rx_flags",
            "RX_ANY_BLOCK"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ucom_hwiflow:\\n\")"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct ucom_softc *sc;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\nStatic void\nucom_hwiflow(sc)\n\tstruct ucom_softc *sc;\n{\n\tDPRINTF((\"ucom_hwiflow:\\n\"));\n#if 0\nXXX\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (sc->sc_mcr_rts == 0)\n\t\treturn;\n\n\tif (ISSET(sc->sc_rx_flags, RX_ANY_BLOCK)) {\n\t\tCLR(sc->sc_mcr, sc->sc_mcr_rts);\n\t\tCLR(sc->sc_mcr_active, sc->sc_mcr_rts);\n\t} else {\n\t\tSET(sc->sc_mcr, sc->sc_mcr_rts);\n\t\tSET(sc->sc_mcr_active, sc->sc_mcr_rts);\n\t}\n\tbus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr_active);\n#endif\n}"
  },
  {
    "function_name": "ucomparam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "766-834",
    "snippet": "Static int\nucomparam(tp, t)\n\tstruct tty *tp;\n\tstruct termios *t;\n{\n\tstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(tp->t_dev)];\n\tint error;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\t/* Check requested parameters. */\n\tif (t->c_ispeed && t->c_ispeed != t->c_ospeed)\n\t\treturn (EINVAL);\n\n\t/*\n\t * For the console, always force CLOCAL and !HUPCL, so that the port\n\t * is always active.\n\t */\n\tif (ISSET(sc->sc_swflags, TIOCFLAG_SOFTCAR)) {\n\t\tSET(t->c_cflag, CLOCAL);\n\t\tCLR(t->c_cflag, HUPCL);\n\t}\n\n\t/*\n\t * If there were no changes, don't do anything.  This avoids dropping\n\t * input and improves performance when all we did was frob things like\n\t * VMIN and VTIME.\n\t */\n\tif (tp->t_ospeed == t->c_ospeed &&\n\t    tp->t_cflag == t->c_cflag)\n\t\treturn (0);\n\n\t//XXX lcr = ISSET(sc->sc_lcr, LCR_SBREAK) | cflag2lcr(t->c_cflag);\n\n\t/* And copy to tty. */\n\ttp->t_ispeed = 0;\n\ttp->t_ospeed = t->c_ospeed;\n\ttp->t_cflag = t->c_cflag;\n\n\tif (sc->sc_methods->ucom_param != NULL) {\n\t\terror = sc->sc_methods->ucom_param(sc->sc_parent, sc->sc_portno,\n\t\t\t    t);\n\t\tif (error)\n\t\t\treturn (error);\n\t}\n\n\t// XXX worry about CHWFLOW\n\n\t/*\n\t * Update the tty layer's idea of the carrier bit, in case we changed\n\t * CLOCAL or MDMBUF.  We don't hang up here; we only do that by\n\t * explicit request.\n\t */\n\tDPRINTF((\"ucomparam: l_modem\\n\"));\n\t(void) (*linesw[tp->t_line].l_modem)(tp, 1 /* XXX carrier */ );\n\n#if 0\nXXX what if the hardware is not open\n\tif (!ISSET(t->c_cflag, CHWFLOW)) {\n\t\tif (sc->sc_tx_stopped) {\n\t\t\tsc->sc_tx_stopped = 0;\n\t\t\tucomstart(tp);\n\t\t}\n\t}\n#endif\n\n\treturn (0);\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "ucom_cleanup\t__P((struct ucom_softc *));",
      "Static void",
      "ucom_hwiflow\t__P((struct ucom_softc *));",
      "Static int",
      "ucomparam\t__P((struct tty *, struct termios *));",
      "Static void",
      "ucomstart\t__P((struct tty *));",
      "Static void",
      "ucom_shutdown\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "ucom_dtr\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_rts\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_break\t__P((struct ucom_softc *, int));",
      "ucomstartread __P((struct ucom_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
      "Static int",
      "ucom_to_tiocm\t__P((struct ucom_softc *));",
      "struct ucom_softc *sc;",
      "struct tty *tp;",
      "int s;",
      "int error;",
      "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];",
      "struct tty *tp = sc->sc_tty;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ucomstart",
          "args": [
            "tp"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "ucomstartread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
          "lines": "994-1012",
          "snippet": "Static usbd_status\nucomstartread(sc)\n\tstruct ucom_softc *sc;\n{\n\tusbd_status err;\n\n\tDPRINTFN(5,(\"ucomstartread: start\\n\"));\n\tusbd_setup_xfer(sc->sc_ixfer, sc->sc_bulkin_pipe, \n\t\t\t(usbd_private_handle)sc, \n\t\t\tsc->sc_ibuf, sc->sc_ibufsize,\n\t\t\tUSBD_SHORT_XFER_OK | USBD_NO_COPY,\n\t\t\tUSBD_NO_TIMEOUT, ucomreadcb);\n\terr = usbd_transfer(sc->sc_ixfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tDPRINTF((\"ucomstartread: err=%s\\n\", usbd_errstr(err)));\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"ucom.h\"",
            "#include <dev/usb/ucomvar.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "ucom_cleanup\t__P((struct ucom_softc *));",
            "Static void",
            "ucom_hwiflow\t__P((struct ucom_softc *));",
            "Static int",
            "Static void",
            "Static void",
            "ucom_shutdown\t__P((struct ucom_softc *));",
            "Static int",
            "Static void",
            "ucom_dtr\t__P((struct ucom_softc *, int));",
            "Static void",
            "ucom_rts\t__P((struct ucom_softc *, int));",
            "Static void",
            "ucom_break\t__P((struct ucom_softc *, int));",
            "Static usbd_status",
            "ucomstartread __P((struct ucom_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
            "Static int",
            "ucom_to_tiocm\t__P((struct ucom_softc *));",
            "usbd_status err;",
            "struct ucom_softc *sc;",
            "int s;",
            "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nStatic usbd_status;\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nusbd_status err;\nstruct ucom_softc *sc;\nint s;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\nStatic usbd_status\nucomstartread(sc)\n\tstruct ucom_softc *sc;\n{\n\tusbd_status err;\n\n\tDPRINTFN(5,(\"ucomstartread: start\\n\"));\n\tusbd_setup_xfer(sc->sc_ixfer, sc->sc_bulkin_pipe, \n\t\t\t(usbd_private_handle)sc, \n\t\t\tsc->sc_ibuf, sc->sc_ibufsize,\n\t\t\tUSBD_SHORT_XFER_OK | USBD_NO_COPY,\n\t\t\tUSBD_NO_TIMEOUT, ucomreadcb);\n\terr = usbd_transfer(sc->sc_ixfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tDPRINTF((\"ucomstartread: err=%s\\n\", usbd_errstr(err)));\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "t->c_cflag",
            "CHWFLOW"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tp",
            "1/* XXX carrier */"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ucomparam: l_modem\\n\")"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->sc_methods->ucom_param",
          "args": [
            "sc->sc_parent",
            "sc->sc_portno",
            "t"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLR",
          "args": [
            "t->c_cflag",
            "HUPCL"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "t->c_cflag",
            "CLOCAL"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "sc->sc_swflags",
            "TIOCFLAG_SOFTCAR"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UCOMUNIT",
          "args": [
            "tp->t_dev"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nucomparam\t__P((struct tty *, struct termios *));\nStatic void;\nucomstart\t__P((struct tty *));\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct ucom_softc *sc;\nstruct tty *tp;\nint s;\nint error;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\nstruct tty *tp = sc->sc_tty;\n\nStatic int\nucomparam(tp, t)\n\tstruct tty *tp;\n\tstruct termios *t;\n{\n\tstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(tp->t_dev)];\n\tint error;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\t/* Check requested parameters. */\n\tif (t->c_ispeed && t->c_ispeed != t->c_ospeed)\n\t\treturn (EINVAL);\n\n\t/*\n\t * For the console, always force CLOCAL and !HUPCL, so that the port\n\t * is always active.\n\t */\n\tif (ISSET(sc->sc_swflags, TIOCFLAG_SOFTCAR)) {\n\t\tSET(t->c_cflag, CLOCAL);\n\t\tCLR(t->c_cflag, HUPCL);\n\t}\n\n\t/*\n\t * If there were no changes, don't do anything.  This avoids dropping\n\t * input and improves performance when all we did was frob things like\n\t * VMIN and VTIME.\n\t */\n\tif (tp->t_ospeed == t->c_ospeed &&\n\t    tp->t_cflag == t->c_cflag)\n\t\treturn (0);\n\n\t//XXX lcr = ISSET(sc->sc_lcr, LCR_SBREAK) | cflag2lcr(t->c_cflag);\n\n\t/* And copy to tty. */\n\ttp->t_ispeed = 0;\n\ttp->t_ospeed = t->c_ospeed;\n\ttp->t_cflag = t->c_cflag;\n\n\tif (sc->sc_methods->ucom_param != NULL) {\n\t\terror = sc->sc_methods->ucom_param(sc->sc_parent, sc->sc_portno,\n\t\t\t    t);\n\t\tif (error)\n\t\t\treturn (error);\n\t}\n\n\t// XXX worry about CHWFLOW\n\n\t/*\n\t * Update the tty layer's idea of the carrier bit, in case we changed\n\t * CLOCAL or MDMBUF.  We don't hang up here; we only do that by\n\t * explicit request.\n\t */\n\tDPRINTF((\"ucomparam: l_modem\\n\"));\n\t(void) (*linesw[tp->t_line].l_modem)(tp, 1 /* XXX carrier */ );\n\n#if 0\nXXX what if the hardware is not open\n\tif (!ISSET(t->c_cflag, CHWFLOW)) {\n\t\tif (sc->sc_tx_stopped) {\n\t\t\tsc->sc_tx_stopped = 0;\n\t\t\tucomstart(tp);\n\t\t}\n\t}\n#endif\n\n\treturn (0);\n}"
  },
  {
    "function_name": "ucom_status_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "753-764",
    "snippet": "void\nucom_status_change(sc)\n\tstruct ucom_softc *sc;\n{\n\tif (sc->sc_methods->ucom_get_status != NULL) {\n\t\tsc->sc_methods->ucom_get_status(sc->sc_parent, sc->sc_portno,\n\t\t    &sc->sc_lsr, &sc->sc_msr);\n\t} else {\n\t\tsc->sc_lsr = 0;\n\t\tsc->sc_msr = 0;\n\t}\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ucom_cleanup\t__P((struct ucom_softc *));",
      "ucom_hwiflow\t__P((struct ucom_softc *));",
      "ucom_shutdown\t__P((struct ucom_softc *));",
      "ucom_dtr\t__P((struct ucom_softc *, int));",
      "ucom_rts\t__P((struct ucom_softc *, int));",
      "ucom_break\t__P((struct ucom_softc *, int));",
      "ucomstartread __P((struct ucom_softc *));",
      "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
      "ucom_to_tiocm\t__P((struct ucom_softc *));",
      "struct ucom_softc *sc;",
      "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->sc_methods->ucom_get_status",
          "args": [
            "sc->sc_parent",
            "sc->sc_portno",
            "&sc->sc_lsr",
            "&sc->sc_msr"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nucom_cleanup\t__P((struct ucom_softc *));\nucom_hwiflow\t__P((struct ucom_softc *));\nucom_shutdown\t__P((struct ucom_softc *));\nucom_dtr\t__P((struct ucom_softc *, int));\nucom_rts\t__P((struct ucom_softc *, int));\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct ucom_softc *sc;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\nvoid\nucom_status_change(sc)\n\tstruct ucom_softc *sc;\n{\n\tif (sc->sc_methods->ucom_get_status != NULL) {\n\t\tsc->sc_methods->ucom_get_status(sc->sc_parent, sc->sc_portno,\n\t\t    &sc->sc_lsr, &sc->sc_msr);\n\t} else {\n\t\tsc->sc_lsr = 0;\n\t\tsc->sc_msr = 0;\n\t}\n}"
  },
  {
    "function_name": "ucom_rts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "741-751",
    "snippet": "Static void\nucom_rts(sc, onoff)\n\tstruct ucom_softc *sc;\n\tint onoff;\n{\n\tDPRINTF((\"ucom_rts: onoff=%d\\n\", onoff));\n\n\tif (sc->sc_methods->ucom_set != NULL)\n\t\tsc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno, \n\t\t    UCOM_SET_RTS, onoff);\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "ucom_cleanup\t__P((struct ucom_softc *));",
      "Static void",
      "ucom_hwiflow\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "Static void",
      "ucom_shutdown\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "ucom_dtr\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_rts\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_break\t__P((struct ucom_softc *, int));",
      "ucomstartread __P((struct ucom_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
      "Static int",
      "ucom_to_tiocm\t__P((struct ucom_softc *));",
      "struct ucom_softc *sc;",
      "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->sc_methods->ucom_set",
          "args": [
            "sc->sc_parent",
            "sc->sc_portno",
            "UCOM_SET_RTS",
            "onoff"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ucom_rts: onoff=%d\\n\", onoff)"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct ucom_softc *sc;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\nStatic void\nucom_rts(sc, onoff)\n\tstruct ucom_softc *sc;\n\tint onoff;\n{\n\tDPRINTF((\"ucom_rts: onoff=%d\\n\", onoff));\n\n\tif (sc->sc_methods->ucom_set != NULL)\n\t\tsc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno, \n\t\t    UCOM_SET_RTS, onoff);\n}"
  },
  {
    "function_name": "ucom_dtr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "729-739",
    "snippet": "Static void\nucom_dtr(sc, onoff)\n\tstruct ucom_softc *sc;\n\tint onoff;\n{\n\tDPRINTF((\"ucom_dtr: onoff=%d\\n\", onoff));\n\n\tif (sc->sc_methods->ucom_set != NULL)\n\t\tsc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno, \n\t\t    UCOM_SET_DTR, onoff);\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "ucom_cleanup\t__P((struct ucom_softc *));",
      "Static void",
      "ucom_hwiflow\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "Static void",
      "ucom_shutdown\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "ucom_dtr\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_rts\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_break\t__P((struct ucom_softc *, int));",
      "ucomstartread __P((struct ucom_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
      "Static int",
      "ucom_to_tiocm\t__P((struct ucom_softc *));",
      "struct ucom_softc *sc;",
      "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->sc_methods->ucom_set",
          "args": [
            "sc->sc_parent",
            "sc->sc_portno",
            "UCOM_SET_DTR",
            "onoff"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ucom_dtr: onoff=%d\\n\", onoff)"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct ucom_softc *sc;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\nStatic void\nucom_dtr(sc, onoff)\n\tstruct ucom_softc *sc;\n\tint onoff;\n{\n\tDPRINTF((\"ucom_dtr: onoff=%d\\n\", onoff));\n\n\tif (sc->sc_methods->ucom_set != NULL)\n\t\tsc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno, \n\t\t    UCOM_SET_DTR, onoff);\n}"
  },
  {
    "function_name": "ucom_break",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "717-727",
    "snippet": "Static void\nucom_break(sc, onoff)\n\tstruct ucom_softc *sc;\n\tint onoff;\n{\n\tDPRINTF((\"ucom_break: onoff=%d\\n\", onoff));\n\n\tif (sc->sc_methods->ucom_set != NULL)\n\t\tsc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno,\n\t\t    UCOM_SET_BREAK, onoff);\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "ucom_cleanup\t__P((struct ucom_softc *));",
      "Static void",
      "ucom_hwiflow\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "Static void",
      "ucom_shutdown\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "ucom_dtr\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_rts\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_break\t__P((struct ucom_softc *, int));",
      "ucomstartread __P((struct ucom_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
      "Static int",
      "ucom_to_tiocm\t__P((struct ucom_softc *));",
      "struct ucom_softc *sc;",
      "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->sc_methods->ucom_set",
          "args": [
            "sc->sc_parent",
            "sc->sc_portno",
            "UCOM_SET_BREAK",
            "onoff"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ucom_break: onoff=%d\\n\", onoff)"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct ucom_softc *sc;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\nStatic void\nucom_break(sc, onoff)\n\tstruct ucom_softc *sc;\n\tint onoff;\n{\n\tDPRINTF((\"ucom_break: onoff=%d\\n\", onoff));\n\n\tif (sc->sc_methods->ucom_set != NULL)\n\t\tsc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno,\n\t\t    UCOM_SET_BREAK, onoff);\n}"
  },
  {
    "function_name": "ucom_to_tiocm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "685-715",
    "snippet": "Static int\nucom_to_tiocm(sc)\n\tstruct ucom_softc *sc;\n{\n\tu_char combits;\n\tint ttybits = 0;\n\n\tcombits = sc->sc_mcr;\n\tif (ISSET(combits, UMCR_DTR))\n\t\tSET(ttybits, TIOCM_DTR);\n\tif (ISSET(combits, UMCR_RTS))\n\t\tSET(ttybits, TIOCM_RTS);\n\n\tcombits = sc->sc_msr;\n\tif (ISSET(combits, UMSR_DCD))\n\t\tSET(ttybits, TIOCM_CD);\n\tif (ISSET(combits, UMSR_CTS))\n\t\tSET(ttybits, TIOCM_CTS);\n\tif (ISSET(combits, UMSR_DSR))\n\t\tSET(ttybits, TIOCM_DSR);\n\tif (ISSET(combits, UMSR_RI | UMSR_TERI))\n\t\tSET(ttybits, TIOCM_RI);\n\n#if 0\nXXX;\n\tif (sc->sc_ier != 0)\n\t\tSET(ttybits, TIOCM_LE);\n#endif\n\n\treturn (ttybits);\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "ucom_cleanup\t__P((struct ucom_softc *));",
      "Static void",
      "ucom_hwiflow\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "Static void",
      "ucom_shutdown\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "ucom_dtr\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_rts\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_break\t__P((struct ucom_softc *, int));",
      "ucomstartread __P((struct ucom_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
      "Static int",
      "ucom_to_tiocm\t__P((struct ucom_softc *));",
      "struct ucom_softc *sc;",
      "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "ttybits",
            "TIOCM_LE"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "ttybits",
            "TIOCM_RI"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "combits",
            "UMSR_RI | UMSR_TERI"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "ttybits",
            "TIOCM_DSR"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "combits",
            "UMSR_DSR"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "ttybits",
            "TIOCM_CTS"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "combits",
            "UMSR_CTS"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "ttybits",
            "TIOCM_CD"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "combits",
            "UMSR_DCD"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "ttybits",
            "TIOCM_RTS"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "combits",
            "UMCR_RTS"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "ttybits",
            "TIOCM_DTR"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "combits",
            "UMCR_DTR"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct ucom_softc *sc;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\nStatic int\nucom_to_tiocm(sc)\n\tstruct ucom_softc *sc;\n{\n\tu_char combits;\n\tint ttybits = 0;\n\n\tcombits = sc->sc_mcr;\n\tif (ISSET(combits, UMCR_DTR))\n\t\tSET(ttybits, TIOCM_DTR);\n\tif (ISSET(combits, UMCR_RTS))\n\t\tSET(ttybits, TIOCM_RTS);\n\n\tcombits = sc->sc_msr;\n\tif (ISSET(combits, UMSR_DCD))\n\t\tSET(ttybits, TIOCM_CD);\n\tif (ISSET(combits, UMSR_CTS))\n\t\tSET(ttybits, TIOCM_CTS);\n\tif (ISSET(combits, UMSR_DSR))\n\t\tSET(ttybits, TIOCM_DSR);\n\tif (ISSET(combits, UMSR_RI | UMSR_TERI))\n\t\tSET(ttybits, TIOCM_RI);\n\n#if 0\nXXX;\n\tif (sc->sc_ier != 0)\n\t\tSET(ttybits, TIOCM_LE);\n#endif\n\n\treturn (ttybits);\n}"
  },
  {
    "function_name": "tiocm_to_ucom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "653-683",
    "snippet": "Static void\ntiocm_to_ucom(sc, how, ttybits)\n\tstruct ucom_softc *sc;\n\tint how, ttybits;\n{\n\tu_char combits;\n\n\tcombits = 0;\n\tif (ISSET(ttybits, TIOCM_DTR))\n\t\tSET(combits, UMCR_DTR);\n\tif (ISSET(ttybits, TIOCM_RTS))\n\t\tSET(combits, UMCR_RTS);\n \n\tswitch (how) {\n\tcase TIOCMBIC:\n\t\tCLR(sc->sc_mcr, combits);\n\t\tbreak;\n\n\tcase TIOCMBIS:\n\t\tSET(sc->sc_mcr, combits);\n\t\tbreak;\n\n\tcase TIOCMSET:\n\t\tCLR(sc->sc_mcr, UMCR_DTR | UMCR_RTS);\n\t\tSET(sc->sc_mcr, combits);\n\t\tbreak;\n\t}\n\n\tucom_dtr(sc, (sc->sc_mcr & UMCR_DTR) != 0);\n\tucom_rts(sc, (sc->sc_mcr & UMCR_RTS) != 0);\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "ucom_cleanup\t__P((struct ucom_softc *));",
      "Static void",
      "ucom_hwiflow\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "Static void",
      "ucom_shutdown\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "ucom_dtr\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_rts\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_break\t__P((struct ucom_softc *, int));",
      "ucomstartread __P((struct ucom_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
      "Static int",
      "ucom_to_tiocm\t__P((struct ucom_softc *));",
      "struct ucom_softc *sc;",
      "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ucom_rts",
          "args": [
            "sc",
            "(sc->sc_mcr & UMCR_RTS) != 0"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "ucom_rts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
          "lines": "741-751",
          "snippet": "Static void\nucom_rts(sc, onoff)\n\tstruct ucom_softc *sc;\n\tint onoff;\n{\n\tDPRINTF((\"ucom_rts: onoff=%d\\n\", onoff));\n\n\tif (sc->sc_methods->ucom_set != NULL)\n\t\tsc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno, \n\t\t    UCOM_SET_RTS, onoff);\n}",
          "includes": [
            "#include \"ucom.h\"",
            "#include <dev/usb/ucomvar.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "ucom_cleanup\t__P((struct ucom_softc *));",
            "Static void",
            "ucom_hwiflow\t__P((struct ucom_softc *));",
            "Static int",
            "Static void",
            "Static void",
            "ucom_shutdown\t__P((struct ucom_softc *));",
            "Static int",
            "Static void",
            "ucom_dtr\t__P((struct ucom_softc *, int));",
            "Static void",
            "ucom_rts\t__P((struct ucom_softc *, int));",
            "Static void",
            "ucom_break\t__P((struct ucom_softc *, int));",
            "ucomstartread __P((struct ucom_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
            "Static int",
            "ucom_to_tiocm\t__P((struct ucom_softc *));",
            "struct ucom_softc *sc;",
            "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct ucom_softc *sc;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\nStatic void\nucom_rts(sc, onoff)\n\tstruct ucom_softc *sc;\n\tint onoff;\n{\n\tDPRINTF((\"ucom_rts: onoff=%d\\n\", onoff));\n\n\tif (sc->sc_methods->ucom_set != NULL)\n\t\tsc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno, \n\t\t    UCOM_SET_RTS, onoff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ucom_dtr",
          "args": [
            "sc",
            "(sc->sc_mcr & UMCR_DTR) != 0"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "ucom_dtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
          "lines": "729-739",
          "snippet": "Static void\nucom_dtr(sc, onoff)\n\tstruct ucom_softc *sc;\n\tint onoff;\n{\n\tDPRINTF((\"ucom_dtr: onoff=%d\\n\", onoff));\n\n\tif (sc->sc_methods->ucom_set != NULL)\n\t\tsc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno, \n\t\t    UCOM_SET_DTR, onoff);\n}",
          "includes": [
            "#include \"ucom.h\"",
            "#include <dev/usb/ucomvar.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "ucom_cleanup\t__P((struct ucom_softc *));",
            "Static void",
            "ucom_hwiflow\t__P((struct ucom_softc *));",
            "Static int",
            "Static void",
            "Static void",
            "ucom_shutdown\t__P((struct ucom_softc *));",
            "Static int",
            "Static void",
            "ucom_dtr\t__P((struct ucom_softc *, int));",
            "Static void",
            "ucom_rts\t__P((struct ucom_softc *, int));",
            "Static void",
            "ucom_break\t__P((struct ucom_softc *, int));",
            "ucomstartread __P((struct ucom_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
            "Static int",
            "ucom_to_tiocm\t__P((struct ucom_softc *));",
            "struct ucom_softc *sc;",
            "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct ucom_softc *sc;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\nStatic void\nucom_dtr(sc, onoff)\n\tstruct ucom_softc *sc;\n\tint onoff;\n{\n\tDPRINTF((\"ucom_dtr: onoff=%d\\n\", onoff));\n\n\tif (sc->sc_methods->ucom_set != NULL)\n\t\tsc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno, \n\t\t    UCOM_SET_DTR, onoff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "sc->sc_mcr",
            "combits"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLR",
          "args": [
            "sc->sc_mcr",
            "UMCR_DTR | UMCR_RTS"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "sc->sc_mcr",
            "combits"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLR",
          "args": [
            "sc->sc_mcr",
            "combits"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "combits",
            "UMCR_RTS"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "ttybits",
            "TIOCM_RTS"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "combits",
            "UMCR_DTR"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "ttybits",
            "TIOCM_DTR"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct ucom_softc *sc;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\nStatic void\ntiocm_to_ucom(sc, how, ttybits)\n\tstruct ucom_softc *sc;\n\tint how, ttybits;\n{\n\tu_char combits;\n\n\tcombits = 0;\n\tif (ISSET(ttybits, TIOCM_DTR))\n\t\tSET(combits, UMCR_DTR);\n\tif (ISSET(ttybits, TIOCM_RTS))\n\t\tSET(combits, UMCR_RTS);\n \n\tswitch (how) {\n\tcase TIOCMBIC:\n\t\tCLR(sc->sc_mcr, combits);\n\t\tbreak;\n\n\tcase TIOCMBIS:\n\t\tSET(sc->sc_mcr, combits);\n\t\tbreak;\n\n\tcase TIOCMSET:\n\t\tCLR(sc->sc_mcr, UMCR_DTR | UMCR_RTS);\n\t\tSET(sc->sc_mcr, combits);\n\t\tbreak;\n\t}\n\n\tucom_dtr(sc, (sc->sc_mcr & UMCR_DTR) != 0);\n\tucom_rts(sc, (sc->sc_mcr & UMCR_RTS) != 0);\n}"
  },
  {
    "function_name": "ucom_do_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "568-651",
    "snippet": "Static int\nucom_do_ioctl(sc, cmd, data, flag, p)\n\tstruct ucom_softc *sc;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct tty *tp = sc->sc_tty;\n\tint error;\n\tint s;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n \n\tDPRINTF((\"ucomioctl: cmd=0x%08lx\\n\", cmd));\n\n\terror = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);\n\tif (error >= 0)\n\t\treturn (error);\n\n\terror = ttioctl(tp, cmd, data, flag, p);\n\tif (error >= 0)\n\t\treturn (error);\n\n\tif (sc->sc_methods->ucom_ioctl != NULL) {\n\t\terror = sc->sc_methods->ucom_ioctl(sc->sc_parent,\n\t\t\t    sc->sc_portno, cmd, data, flag, p);\n\t\tif (error >= 0)\n\t\t\treturn (error);\n\t}\n\n\terror = 0;\n\n\tDPRINTF((\"ucomioctl: our cmd=0x%08lx\\n\", cmd));\n\ts = spltty();\n\n\tswitch (cmd) {\n\tcase TIOCSBRK:\n\t\tucom_break(sc, 1);\n\t\tbreak;\n\n\tcase TIOCCBRK:\n\t\tucom_break(sc, 0);\n\t\tbreak;\n\n\tcase TIOCSDTR:\n\t\tucom_dtr(sc, 1);\n\t\tbreak;\n\n\tcase TIOCCDTR:\n\t\tucom_dtr(sc, 0);\n\t\tbreak;\n\n\tcase TIOCGFLAGS:\n\t\t*(int *)data = sc->sc_swflags;\n\t\tbreak;\n\n\tcase TIOCSFLAGS:\n\t\terror = suser(p->p_ucred, &p->p_acflag); \n\t\tif (error)\n\t\t\tbreak;\n\t\tsc->sc_swflags = *(int *)data;\n\t\tbreak;\n\n\tcase TIOCMSET:\n\tcase TIOCMBIS:\n\tcase TIOCMBIC:\n\t\ttiocm_to_ucom(sc, cmd, *(int *)data);\n\t\tbreak;\n\n\tcase TIOCMGET:\n\t\t*(int *)data = ucom_to_tiocm(sc);\n\t\tbreak;\n\n\tdefault:\n\t\terror = ENOTTY;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\n\treturn (error);\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "ucom_cleanup\t__P((struct ucom_softc *));",
      "Static void",
      "ucom_hwiflow\t__P((struct ucom_softc *));",
      "Static int",
      "Static void",
      "ucomstart\t__P((struct tty *));",
      "Static void",
      "ucom_shutdown\t__P((struct ucom_softc *));",
      "Static int",
      "ucom_do_ioctl\t__P((struct ucom_softc *, u_long, caddr_t,\n\t\t\t\t     int, struct proc *));",
      "Static void",
      "ucom_dtr\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_rts\t__P((struct ucom_softc *, int));",
      "Static void",
      "ucom_break\t__P((struct ucom_softc *, int));",
      "ucomstartread __P((struct ucom_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
      "Static int",
      "ucom_to_tiocm\t__P((struct ucom_softc *));",
      "struct proc *p;",
      "struct ucom_softc *sc;",
      "struct tty *tp;",
      "int s;",
      "int error;",
      "struct proc *p;",
      "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];",
      "struct tty *tp = sc->sc_tty;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucom_to_tiocm",
          "args": [
            "sc"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "ucom_to_tiocm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
          "lines": "685-715",
          "snippet": "Static int\nucom_to_tiocm(sc)\n\tstruct ucom_softc *sc;\n{\n\tu_char combits;\n\tint ttybits = 0;\n\n\tcombits = sc->sc_mcr;\n\tif (ISSET(combits, UMCR_DTR))\n\t\tSET(ttybits, TIOCM_DTR);\n\tif (ISSET(combits, UMCR_RTS))\n\t\tSET(ttybits, TIOCM_RTS);\n\n\tcombits = sc->sc_msr;\n\tif (ISSET(combits, UMSR_DCD))\n\t\tSET(ttybits, TIOCM_CD);\n\tif (ISSET(combits, UMSR_CTS))\n\t\tSET(ttybits, TIOCM_CTS);\n\tif (ISSET(combits, UMSR_DSR))\n\t\tSET(ttybits, TIOCM_DSR);\n\tif (ISSET(combits, UMSR_RI | UMSR_TERI))\n\t\tSET(ttybits, TIOCM_RI);\n\n#if 0\nXXX;\n\tif (sc->sc_ier != 0)\n\t\tSET(ttybits, TIOCM_LE);\n#endif\n\n\treturn (ttybits);\n}",
          "includes": [
            "#include \"ucom.h\"",
            "#include <dev/usb/ucomvar.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "ucom_cleanup\t__P((struct ucom_softc *));",
            "Static void",
            "ucom_hwiflow\t__P((struct ucom_softc *));",
            "Static int",
            "Static void",
            "Static void",
            "ucom_shutdown\t__P((struct ucom_softc *));",
            "Static int",
            "Static void",
            "ucom_dtr\t__P((struct ucom_softc *, int));",
            "Static void",
            "ucom_rts\t__P((struct ucom_softc *, int));",
            "Static void",
            "ucom_break\t__P((struct ucom_softc *, int));",
            "ucomstartread __P((struct ucom_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
            "Static int",
            "ucom_to_tiocm\t__P((struct ucom_softc *));",
            "struct ucom_softc *sc;",
            "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct ucom_softc *sc;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\nStatic int\nucom_to_tiocm(sc)\n\tstruct ucom_softc *sc;\n{\n\tu_char combits;\n\tint ttybits = 0;\n\n\tcombits = sc->sc_mcr;\n\tif (ISSET(combits, UMCR_DTR))\n\t\tSET(ttybits, TIOCM_DTR);\n\tif (ISSET(combits, UMCR_RTS))\n\t\tSET(ttybits, TIOCM_RTS);\n\n\tcombits = sc->sc_msr;\n\tif (ISSET(combits, UMSR_DCD))\n\t\tSET(ttybits, TIOCM_CD);\n\tif (ISSET(combits, UMSR_CTS))\n\t\tSET(ttybits, TIOCM_CTS);\n\tif (ISSET(combits, UMSR_DSR))\n\t\tSET(ttybits, TIOCM_DSR);\n\tif (ISSET(combits, UMSR_RI | UMSR_TERI))\n\t\tSET(ttybits, TIOCM_RI);\n\n#if 0\nXXX;\n\tif (sc->sc_ier != 0)\n\t\tSET(ttybits, TIOCM_LE);\n#endif\n\n\treturn (ttybits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tiocm_to_ucom",
          "args": [
            "sc",
            "cmd",
            "*(int *)data"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "tiocm_to_ucom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
          "lines": "653-683",
          "snippet": "Static void\ntiocm_to_ucom(sc, how, ttybits)\n\tstruct ucom_softc *sc;\n\tint how, ttybits;\n{\n\tu_char combits;\n\n\tcombits = 0;\n\tif (ISSET(ttybits, TIOCM_DTR))\n\t\tSET(combits, UMCR_DTR);\n\tif (ISSET(ttybits, TIOCM_RTS))\n\t\tSET(combits, UMCR_RTS);\n \n\tswitch (how) {\n\tcase TIOCMBIC:\n\t\tCLR(sc->sc_mcr, combits);\n\t\tbreak;\n\n\tcase TIOCMBIS:\n\t\tSET(sc->sc_mcr, combits);\n\t\tbreak;\n\n\tcase TIOCMSET:\n\t\tCLR(sc->sc_mcr, UMCR_DTR | UMCR_RTS);\n\t\tSET(sc->sc_mcr, combits);\n\t\tbreak;\n\t}\n\n\tucom_dtr(sc, (sc->sc_mcr & UMCR_DTR) != 0);\n\tucom_rts(sc, (sc->sc_mcr & UMCR_RTS) != 0);\n}",
          "includes": [
            "#include \"ucom.h\"",
            "#include <dev/usb/ucomvar.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "ucom_cleanup\t__P((struct ucom_softc *));",
            "Static void",
            "ucom_hwiflow\t__P((struct ucom_softc *));",
            "Static int",
            "Static void",
            "Static void",
            "ucom_shutdown\t__P((struct ucom_softc *));",
            "Static int",
            "Static void",
            "ucom_dtr\t__P((struct ucom_softc *, int));",
            "Static void",
            "ucom_rts\t__P((struct ucom_softc *, int));",
            "Static void",
            "ucom_break\t__P((struct ucom_softc *, int));",
            "ucomstartread __P((struct ucom_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
            "Static int",
            "ucom_to_tiocm\t__P((struct ucom_softc *));",
            "struct ucom_softc *sc;",
            "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct ucom_softc *sc;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\nStatic void\ntiocm_to_ucom(sc, how, ttybits)\n\tstruct ucom_softc *sc;\n\tint how, ttybits;\n{\n\tu_char combits;\n\n\tcombits = 0;\n\tif (ISSET(ttybits, TIOCM_DTR))\n\t\tSET(combits, UMCR_DTR);\n\tif (ISSET(ttybits, TIOCM_RTS))\n\t\tSET(combits, UMCR_RTS);\n \n\tswitch (how) {\n\tcase TIOCMBIC:\n\t\tCLR(sc->sc_mcr, combits);\n\t\tbreak;\n\n\tcase TIOCMBIS:\n\t\tSET(sc->sc_mcr, combits);\n\t\tbreak;\n\n\tcase TIOCMSET:\n\t\tCLR(sc->sc_mcr, UMCR_DTR | UMCR_RTS);\n\t\tSET(sc->sc_mcr, combits);\n\t\tbreak;\n\t}\n\n\tucom_dtr(sc, (sc->sc_mcr & UMCR_DTR) != 0);\n\tucom_rts(sc, (sc->sc_mcr & UMCR_RTS) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "suser",
          "args": [
            "p->p_ucred",
            "&p->p_acflag"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucom_dtr",
          "args": [
            "sc",
            "0"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "ucom_dtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
          "lines": "729-739",
          "snippet": "Static void\nucom_dtr(sc, onoff)\n\tstruct ucom_softc *sc;\n\tint onoff;\n{\n\tDPRINTF((\"ucom_dtr: onoff=%d\\n\", onoff));\n\n\tif (sc->sc_methods->ucom_set != NULL)\n\t\tsc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno, \n\t\t    UCOM_SET_DTR, onoff);\n}",
          "includes": [
            "#include \"ucom.h\"",
            "#include <dev/usb/ucomvar.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "ucom_cleanup\t__P((struct ucom_softc *));",
            "Static void",
            "ucom_hwiflow\t__P((struct ucom_softc *));",
            "Static int",
            "Static void",
            "Static void",
            "ucom_shutdown\t__P((struct ucom_softc *));",
            "Static int",
            "Static void",
            "ucom_dtr\t__P((struct ucom_softc *, int));",
            "Static void",
            "ucom_rts\t__P((struct ucom_softc *, int));",
            "Static void",
            "ucom_break\t__P((struct ucom_softc *, int));",
            "ucomstartread __P((struct ucom_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
            "Static int",
            "ucom_to_tiocm\t__P((struct ucom_softc *));",
            "struct ucom_softc *sc;",
            "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct ucom_softc *sc;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\nStatic void\nucom_dtr(sc, onoff)\n\tstruct ucom_softc *sc;\n\tint onoff;\n{\n\tDPRINTF((\"ucom_dtr: onoff=%d\\n\", onoff));\n\n\tif (sc->sc_methods->ucom_set != NULL)\n\t\tsc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno, \n\t\t    UCOM_SET_DTR, onoff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ucom_break",
          "args": [
            "sc",
            "0"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "ucom_break",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
          "lines": "717-727",
          "snippet": "Static void\nucom_break(sc, onoff)\n\tstruct ucom_softc *sc;\n\tint onoff;\n{\n\tDPRINTF((\"ucom_break: onoff=%d\\n\", onoff));\n\n\tif (sc->sc_methods->ucom_set != NULL)\n\t\tsc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno,\n\t\t    UCOM_SET_BREAK, onoff);\n}",
          "includes": [
            "#include \"ucom.h\"",
            "#include <dev/usb/ucomvar.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "ucom_cleanup\t__P((struct ucom_softc *));",
            "Static void",
            "ucom_hwiflow\t__P((struct ucom_softc *));",
            "Static int",
            "Static void",
            "Static void",
            "ucom_shutdown\t__P((struct ucom_softc *));",
            "Static int",
            "Static void",
            "ucom_dtr\t__P((struct ucom_softc *, int));",
            "Static void",
            "ucom_rts\t__P((struct ucom_softc *, int));",
            "Static void",
            "ucom_break\t__P((struct ucom_softc *, int));",
            "ucomstartread __P((struct ucom_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
            "Static int",
            "ucom_to_tiocm\t__P((struct ucom_softc *));",
            "struct ucom_softc *sc;",
            "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct ucom_softc *sc;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\nStatic void\nucom_break(sc, onoff)\n\tstruct ucom_softc *sc;\n\tint onoff;\n{\n\tDPRINTF((\"ucom_break: onoff=%d\\n\", onoff));\n\n\tif (sc->sc_methods->ucom_set != NULL)\n\t\tsc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno,\n\t\t    UCOM_SET_BREAK, onoff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ucomioctl: our cmd=0x%08lx\\n\", cmd)"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->sc_methods->ucom_ioctl",
          "args": [
            "sc->sc_parent",
            "sc->sc_portno",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttioctl",
          "args": [
            "tp",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tp",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ucomioctl: cmd=0x%08lx\\n\", cmd)"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucomstart\t__P((struct tty *));\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nucom_do_ioctl\t__P((struct ucom_softc *, u_long, caddr_t,\n\t\t\t\t     int, struct proc *));\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct proc *p;\nstruct ucom_softc *sc;\nstruct tty *tp;\nint s;\nint error;\nstruct proc *p;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\nstruct tty *tp = sc->sc_tty;\n\nStatic int\nucom_do_ioctl(sc, cmd, data, flag, p)\n\tstruct ucom_softc *sc;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct tty *tp = sc->sc_tty;\n\tint error;\n\tint s;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n \n\tDPRINTF((\"ucomioctl: cmd=0x%08lx\\n\", cmd));\n\n\terror = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);\n\tif (error >= 0)\n\t\treturn (error);\n\n\terror = ttioctl(tp, cmd, data, flag, p);\n\tif (error >= 0)\n\t\treturn (error);\n\n\tif (sc->sc_methods->ucom_ioctl != NULL) {\n\t\terror = sc->sc_methods->ucom_ioctl(sc->sc_parent,\n\t\t\t    sc->sc_portno, cmd, data, flag, p);\n\t\tif (error >= 0)\n\t\t\treturn (error);\n\t}\n\n\terror = 0;\n\n\tDPRINTF((\"ucomioctl: our cmd=0x%08lx\\n\", cmd));\n\ts = spltty();\n\n\tswitch (cmd) {\n\tcase TIOCSBRK:\n\t\tucom_break(sc, 1);\n\t\tbreak;\n\n\tcase TIOCCBRK:\n\t\tucom_break(sc, 0);\n\t\tbreak;\n\n\tcase TIOCSDTR:\n\t\tucom_dtr(sc, 1);\n\t\tbreak;\n\n\tcase TIOCCDTR:\n\t\tucom_dtr(sc, 0);\n\t\tbreak;\n\n\tcase TIOCGFLAGS:\n\t\t*(int *)data = sc->sc_swflags;\n\t\tbreak;\n\n\tcase TIOCSFLAGS:\n\t\terror = suser(p->p_ucred, &p->p_acflag); \n\t\tif (error)\n\t\t\tbreak;\n\t\tsc->sc_swflags = *(int *)data;\n\t\tbreak;\n\n\tcase TIOCMSET:\n\tcase TIOCMBIS:\n\tcase TIOCMBIC:\n\t\ttiocm_to_ucom(sc, cmd, *(int *)data);\n\t\tbreak;\n\n\tcase TIOCMGET:\n\t\t*(int *)data = ucom_to_tiocm(sc);\n\t\tbreak;\n\n\tdefault:\n\t\terror = ENOTTY;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\n\treturn (error);\n}"
  },
  {
    "function_name": "ucomioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "550-566",
    "snippet": "int\nucomioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\tint error;\n\n\tsc->sc_refcnt++;\n\terror = ucom_do_ioctl(sc, cmd, data, flag, p);\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\treturn (error);\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ucom_cleanup\t__P((struct ucom_softc *));",
      "ucom_hwiflow\t__P((struct ucom_softc *));",
      "ucom_shutdown\t__P((struct ucom_softc *));",
      "ucom_do_ioctl\t__P((struct ucom_softc *, u_long, caddr_t,\n\t\t\t\t     int, struct proc *));",
      "ucom_dtr\t__P((struct ucom_softc *, int));",
      "ucom_rts\t__P((struct ucom_softc *, int));",
      "ucom_break\t__P((struct ucom_softc *, int));",
      "ucomstartread __P((struct ucom_softc *));",
      "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
      "ucom_to_tiocm\t__P((struct ucom_softc *));",
      "dev_t dev;",
      "struct proc *p;",
      "struct ucom_softc *sc;",
      "int error;",
      "dev_t dev;",
      "struct proc *p;",
      "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];",
      "struct tty *\nucomtty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_detach_wakeup",
          "args": [
            "USBDEV(sc->sc_dev)"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEV",
          "args": [
            "sc->sc_dev"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucom_do_ioctl",
          "args": [
            "sc",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "ucom_do_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
          "lines": "568-651",
          "snippet": "Static int\nucom_do_ioctl(sc, cmd, data, flag, p)\n\tstruct ucom_softc *sc;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct tty *tp = sc->sc_tty;\n\tint error;\n\tint s;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n \n\tDPRINTF((\"ucomioctl: cmd=0x%08lx\\n\", cmd));\n\n\terror = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);\n\tif (error >= 0)\n\t\treturn (error);\n\n\terror = ttioctl(tp, cmd, data, flag, p);\n\tif (error >= 0)\n\t\treturn (error);\n\n\tif (sc->sc_methods->ucom_ioctl != NULL) {\n\t\terror = sc->sc_methods->ucom_ioctl(sc->sc_parent,\n\t\t\t    sc->sc_portno, cmd, data, flag, p);\n\t\tif (error >= 0)\n\t\t\treturn (error);\n\t}\n\n\terror = 0;\n\n\tDPRINTF((\"ucomioctl: our cmd=0x%08lx\\n\", cmd));\n\ts = spltty();\n\n\tswitch (cmd) {\n\tcase TIOCSBRK:\n\t\tucom_break(sc, 1);\n\t\tbreak;\n\n\tcase TIOCCBRK:\n\t\tucom_break(sc, 0);\n\t\tbreak;\n\n\tcase TIOCSDTR:\n\t\tucom_dtr(sc, 1);\n\t\tbreak;\n\n\tcase TIOCCDTR:\n\t\tucom_dtr(sc, 0);\n\t\tbreak;\n\n\tcase TIOCGFLAGS:\n\t\t*(int *)data = sc->sc_swflags;\n\t\tbreak;\n\n\tcase TIOCSFLAGS:\n\t\terror = suser(p->p_ucred, &p->p_acflag); \n\t\tif (error)\n\t\t\tbreak;\n\t\tsc->sc_swflags = *(int *)data;\n\t\tbreak;\n\n\tcase TIOCMSET:\n\tcase TIOCMBIS:\n\tcase TIOCMBIC:\n\t\ttiocm_to_ucom(sc, cmd, *(int *)data);\n\t\tbreak;\n\n\tcase TIOCMGET:\n\t\t*(int *)data = ucom_to_tiocm(sc);\n\t\tbreak;\n\n\tdefault:\n\t\terror = ENOTTY;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\n\treturn (error);\n}",
          "includes": [
            "#include \"ucom.h\"",
            "#include <dev/usb/ucomvar.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "ucom_cleanup\t__P((struct ucom_softc *));",
            "Static void",
            "ucom_hwiflow\t__P((struct ucom_softc *));",
            "Static int",
            "Static void",
            "ucomstart\t__P((struct tty *));",
            "Static void",
            "ucom_shutdown\t__P((struct ucom_softc *));",
            "Static int",
            "ucom_do_ioctl\t__P((struct ucom_softc *, u_long, caddr_t,\n\t\t\t\t     int, struct proc *));",
            "Static void",
            "ucom_dtr\t__P((struct ucom_softc *, int));",
            "Static void",
            "ucom_rts\t__P((struct ucom_softc *, int));",
            "Static void",
            "ucom_break\t__P((struct ucom_softc *, int));",
            "ucomstartread __P((struct ucom_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
            "Static int",
            "ucom_to_tiocm\t__P((struct ucom_softc *));",
            "struct proc *p;",
            "struct ucom_softc *sc;",
            "struct tty *tp;",
            "int s;",
            "int error;",
            "struct proc *p;",
            "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];",
            "struct tty *tp = sc->sc_tty;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucomstart\t__P((struct tty *));\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nucom_do_ioctl\t__P((struct ucom_softc *, u_long, caddr_t,\n\t\t\t\t     int, struct proc *));\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct proc *p;\nstruct ucom_softc *sc;\nstruct tty *tp;\nint s;\nint error;\nstruct proc *p;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\nstruct tty *tp = sc->sc_tty;\n\nStatic int\nucom_do_ioctl(sc, cmd, data, flag, p)\n\tstruct ucom_softc *sc;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct tty *tp = sc->sc_tty;\n\tint error;\n\tint s;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n \n\tDPRINTF((\"ucomioctl: cmd=0x%08lx\\n\", cmd));\n\n\terror = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);\n\tif (error >= 0)\n\t\treturn (error);\n\n\terror = ttioctl(tp, cmd, data, flag, p);\n\tif (error >= 0)\n\t\treturn (error);\n\n\tif (sc->sc_methods->ucom_ioctl != NULL) {\n\t\terror = sc->sc_methods->ucom_ioctl(sc->sc_parent,\n\t\t\t    sc->sc_portno, cmd, data, flag, p);\n\t\tif (error >= 0)\n\t\t\treturn (error);\n\t}\n\n\terror = 0;\n\n\tDPRINTF((\"ucomioctl: our cmd=0x%08lx\\n\", cmd));\n\ts = spltty();\n\n\tswitch (cmd) {\n\tcase TIOCSBRK:\n\t\tucom_break(sc, 1);\n\t\tbreak;\n\n\tcase TIOCCBRK:\n\t\tucom_break(sc, 0);\n\t\tbreak;\n\n\tcase TIOCSDTR:\n\t\tucom_dtr(sc, 1);\n\t\tbreak;\n\n\tcase TIOCCDTR:\n\t\tucom_dtr(sc, 0);\n\t\tbreak;\n\n\tcase TIOCGFLAGS:\n\t\t*(int *)data = sc->sc_swflags;\n\t\tbreak;\n\n\tcase TIOCSFLAGS:\n\t\terror = suser(p->p_ucred, &p->p_acflag); \n\t\tif (error)\n\t\t\tbreak;\n\t\tsc->sc_swflags = *(int *)data;\n\t\tbreak;\n\n\tcase TIOCMSET:\n\tcase TIOCMBIS:\n\tcase TIOCMBIC:\n\t\ttiocm_to_ucom(sc, cmd, *(int *)data);\n\t\tbreak;\n\n\tcase TIOCMGET:\n\t\t*(int *)data = ucom_to_tiocm(sc);\n\t\tbreak;\n\n\tdefault:\n\t\terror = ENOTTY;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UCOMUNIT",
          "args": [
            "dev"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nucom_cleanup\t__P((struct ucom_softc *));\nucom_hwiflow\t__P((struct ucom_softc *));\nucom_shutdown\t__P((struct ucom_softc *));\nucom_do_ioctl\t__P((struct ucom_softc *, u_long, caddr_t,\n\t\t\t\t     int, struct proc *));\nucom_dtr\t__P((struct ucom_softc *, int));\nucom_rts\t__P((struct ucom_softc *, int));\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nucom_to_tiocm\t__P((struct ucom_softc *));\ndev_t dev;\nstruct proc *p;\nstruct ucom_softc *sc;\nint error;\ndev_t dev;\nstruct proc *p;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\nstruct tty *\nucomtty(dev)\n\tdev_t dev;\n\nint\nucomioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\tint error;\n\n\tsc->sc_refcnt++;\n\terror = ucom_do_ioctl(sc, cmd, data, flag, p);\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\treturn (error);\n}"
  },
  {
    "function_name": "ucomwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "520-538",
    "snippet": "int\nucomwrite(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\tstruct tty *tp = sc->sc_tty;\n\tint error;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n \n\tsc->sc_refcnt++;\n\terror = ((*linesw[tp->t_line].l_write)(tp, uio, flag));\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\treturn (error);\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ucom_cleanup\t__P((struct ucom_softc *));",
      "ucom_hwiflow\t__P((struct ucom_softc *));",
      "ucomstart\t__P((struct tty *));",
      "ucom_shutdown\t__P((struct ucom_softc *));",
      "ucom_dtr\t__P((struct ucom_softc *, int));",
      "ucom_rts\t__P((struct ucom_softc *, int));",
      "ucom_break\t__P((struct ucom_softc *, int));",
      "ucomstartread __P((struct ucom_softc *));",
      "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
      "ucom_to_tiocm\t__P((struct ucom_softc *));",
      "dev_t dev;",
      "struct ucom_softc *sc;",
      "struct tty *tp;",
      "int error;",
      "dev_t dev;",
      "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];",
      "struct tty *tp = sc->sc_tty;",
      "struct tty *\nucomtty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_detach_wakeup",
          "args": [
            "USBDEV(sc->sc_dev)"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEV",
          "args": [
            "sc->sc_dev"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tp",
            "uio",
            "flag"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UCOMUNIT",
          "args": [
            "dev"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nucom_cleanup\t__P((struct ucom_softc *));\nucom_hwiflow\t__P((struct ucom_softc *));\nucomstart\t__P((struct tty *));\nucom_shutdown\t__P((struct ucom_softc *));\nucom_dtr\t__P((struct ucom_softc *, int));\nucom_rts\t__P((struct ucom_softc *, int));\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nucom_to_tiocm\t__P((struct ucom_softc *));\ndev_t dev;\nstruct ucom_softc *sc;\nstruct tty *tp;\nint error;\ndev_t dev;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\nstruct tty *tp = sc->sc_tty;\nstruct tty *\nucomtty(dev)\n\tdev_t dev;\n\nint\nucomwrite(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\tstruct tty *tp = sc->sc_tty;\n\tint error;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n \n\tsc->sc_refcnt++;\n\terror = ((*linesw[tp->t_line].l_write)(tp, uio, flag));\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\treturn (error);\n}"
  },
  {
    "function_name": "ucomread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "500-518",
    "snippet": "int\nucomread(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\tstruct tty *tp = sc->sc_tty;\n\tint error;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n \n\tsc->sc_refcnt++;\n\terror = ((*linesw[tp->t_line].l_read)(tp, uio, flag));\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\treturn (error);\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ucom_cleanup\t__P((struct ucom_softc *));",
      "ucom_hwiflow\t__P((struct ucom_softc *));",
      "ucomstart\t__P((struct tty *));",
      "ucom_shutdown\t__P((struct ucom_softc *));",
      "ucom_dtr\t__P((struct ucom_softc *, int));",
      "ucom_rts\t__P((struct ucom_softc *, int));",
      "ucom_break\t__P((struct ucom_softc *, int));",
      "ucomstartread __P((struct ucom_softc *));",
      "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
      "ucom_to_tiocm\t__P((struct ucom_softc *));",
      "dev_t dev;",
      "struct ucom_softc *sc;",
      "struct tty *tp;",
      "int error;",
      "dev_t dev;",
      "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];",
      "struct tty *tp = sc->sc_tty;",
      "struct tty *\nucomtty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_detach_wakeup",
          "args": [
            "USBDEV(sc->sc_dev)"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEV",
          "args": [
            "sc->sc_dev"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tp",
            "uio",
            "flag"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UCOMUNIT",
          "args": [
            "dev"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nucom_cleanup\t__P((struct ucom_softc *));\nucom_hwiflow\t__P((struct ucom_softc *));\nucomstart\t__P((struct tty *));\nucom_shutdown\t__P((struct ucom_softc *));\nucom_dtr\t__P((struct ucom_softc *, int));\nucom_rts\t__P((struct ucom_softc *, int));\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nucom_to_tiocm\t__P((struct ucom_softc *));\ndev_t dev;\nstruct ucom_softc *sc;\nstruct tty *tp;\nint error;\ndev_t dev;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\nstruct tty *tp = sc->sc_tty;\nstruct tty *\nucomtty(dev)\n\tdev_t dev;\n\nint\nucomread(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\tstruct tty *tp = sc->sc_tty;\n\tint error;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n \n\tsc->sc_refcnt++;\n\terror = ((*linesw[tp->t_line].l_read)(tp, uio, flag));\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\treturn (error);\n}"
  },
  {
    "function_name": "ucom_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "250-265",
    "snippet": "void\nucom_shutdown(sc)\n\tstruct ucom_softc *sc;\n{\n\tstruct tty *tp = sc->sc_tty;\n\n\tDPRINTF((\"ucom_shutdown\\n\"));\n\t/*\n\t * Hang up if necessary.  Wait a bit, so the other side has time to\n\t * notice even if we immediately open the port again.\n\t */\n\tif (ISSET(tp->t_cflag, HUPCL)) {\n\t\tucom_dtr(sc, 0);\n\t\t(void)tsleep(sc, TTIPRI, ttclos, hz);\n\t}\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ucom_cleanup\t__P((struct ucom_softc *));",
      "ucom_hwiflow\t__P((struct ucom_softc *));",
      "ucomstart\t__P((struct tty *));",
      "ucom_shutdown\t__P((struct ucom_softc *));",
      "ucom_dtr\t__P((struct ucom_softc *, int));",
      "ucom_rts\t__P((struct ucom_softc *, int));",
      "ucom_break\t__P((struct ucom_softc *, int));",
      "ucomstartread __P((struct ucom_softc *));",
      "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
      "ucom_to_tiocm\t__P((struct ucom_softc *));",
      "struct ucom_softc *sc;",
      "struct tty *tp;",
      "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];",
      "struct tty *tp = sc->sc_tty;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "sc",
            "TTIPRI",
            "ttclos",
            "hz"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucom_dtr",
          "args": [
            "sc",
            "0"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "ucom_dtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
          "lines": "729-739",
          "snippet": "Static void\nucom_dtr(sc, onoff)\n\tstruct ucom_softc *sc;\n\tint onoff;\n{\n\tDPRINTF((\"ucom_dtr: onoff=%d\\n\", onoff));\n\n\tif (sc->sc_methods->ucom_set != NULL)\n\t\tsc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno, \n\t\t    UCOM_SET_DTR, onoff);\n}",
          "includes": [
            "#include \"ucom.h\"",
            "#include <dev/usb/ucomvar.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "ucom_cleanup\t__P((struct ucom_softc *));",
            "Static void",
            "ucom_hwiflow\t__P((struct ucom_softc *));",
            "Static int",
            "Static void",
            "Static void",
            "ucom_shutdown\t__P((struct ucom_softc *));",
            "Static int",
            "Static void",
            "ucom_dtr\t__P((struct ucom_softc *, int));",
            "Static void",
            "ucom_rts\t__P((struct ucom_softc *, int));",
            "Static void",
            "ucom_break\t__P((struct ucom_softc *, int));",
            "ucomstartread __P((struct ucom_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
            "Static int",
            "ucom_to_tiocm\t__P((struct ucom_softc *));",
            "struct ucom_softc *sc;",
            "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nucom_cleanup\t__P((struct ucom_softc *));\nStatic void;\nucom_hwiflow\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nStatic void;\nucom_shutdown\t__P((struct ucom_softc *));\nStatic int;\nStatic void;\nucom_dtr\t__P((struct ucom_softc *, int));\nStatic void;\nucom_rts\t__P((struct ucom_softc *, int));\nStatic void;\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\nStatic void;\nStatic void;\nStatic void;\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nStatic int;\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct ucom_softc *sc;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\nStatic void\nucom_dtr(sc, onoff)\n\tstruct ucom_softc *sc;\n\tint onoff;\n{\n\tDPRINTF((\"ucom_dtr: onoff=%d\\n\", onoff));\n\n\tif (sc->sc_methods->ucom_set != NULL)\n\t\tsc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno, \n\t\t    UCOM_SET_DTR, onoff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "tp->t_cflag",
            "HUPCL"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ucom_shutdown\\n\")"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nucom_cleanup\t__P((struct ucom_softc *));\nucom_hwiflow\t__P((struct ucom_softc *));\nucomstart\t__P((struct tty *));\nucom_shutdown\t__P((struct ucom_softc *));\nucom_dtr\t__P((struct ucom_softc *, int));\nucom_rts\t__P((struct ucom_softc *, int));\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct ucom_softc *sc;\nstruct tty *tp;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\nstruct tty *tp = sc->sc_tty;\n\nvoid\nucom_shutdown(sc)\n\tstruct ucom_softc *sc;\n{\n\tstruct tty *tp = sc->sc_tty;\n\n\tDPRINTF((\"ucom_shutdown\\n\"));\n\t/*\n\t * Hang up if necessary.  Wait a bit, so the other side has time to\n\t * notice even if we immediately open the port again.\n\t */\n\tif (ISSET(tp->t_cflag, HUPCL)) {\n\t\tucom_dtr(sc, 0);\n\t\t(void)tsleep(sc, TTIPRI, ttclos, hz);\n\t}\n}"
  },
  {
    "function_name": "ucom_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ucom.c",
    "lines": "230-247",
    "snippet": "int\nucom_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct ucom_softc *sc = (struct ucom_softc *)self;\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tsc->sc_dying = 1;\n\t\tbreak;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include \"ucom.h\"",
      "#include <dev/usb/ucomvar.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ucom_cleanup\t__P((struct ucom_softc *));",
      "ucom_hwiflow\t__P((struct ucom_softc *));",
      "ucom_shutdown\t__P((struct ucom_softc *));",
      "ucom_dtr\t__P((struct ucom_softc *, int));",
      "ucom_rts\t__P((struct ucom_softc *, int));",
      "ucom_break\t__P((struct ucom_softc *, int));",
      "ucomstartread __P((struct ucom_softc *));",
      "tiocm_to_ucom\t__P((struct ucom_softc *, int, int));",
      "ucom_to_tiocm\t__P((struct ucom_softc *));",
      "struct ucom_softc *sc;",
      "struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ucom.h\"\n#include <dev/usb/ucomvar.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nucom_cleanup\t__P((struct ucom_softc *));\nucom_hwiflow\t__P((struct ucom_softc *));\nucom_shutdown\t__P((struct ucom_softc *));\nucom_dtr\t__P((struct ucom_softc *, int));\nucom_rts\t__P((struct ucom_softc *, int));\nucom_break\t__P((struct ucom_softc *, int));\nucomstartread __P((struct ucom_softc *));\ntiocm_to_ucom\t__P((struct ucom_softc *, int, int));\nucom_to_tiocm\t__P((struct ucom_softc *));\nstruct ucom_softc *sc;\nstruct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];\n\nint\nucom_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct ucom_softc *sc = (struct ucom_softc *)self;\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tsc->sc_dying = 1;\n\t\tbreak;\n\t}\n\treturn (0);\n}"
  }
]