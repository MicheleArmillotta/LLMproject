[
  {
    "function_name": "asc_dma_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc_ioasic.c",
    "lines": "310-328",
    "snippet": "void\nasc_dma_intr()\n{\n\tasc_softc_t asc =  &asc_cd.cd_devs[0]; /*XXX*/\n\tu_int next_phys;\n\n\tasc->dma_xfer -= NBPG;\n\tif (asc->dma_xfer <= -NBPG) {\n\t\tvolatile u_int *ssr = (volatile u_int *)\n\t\t\tIOASIC_REG_CSR(ioasic_base);\n\t\t*ssr &= ~IOASIC_CSR_DMAEN_SCSI;\n\t} else {\n\t\tasc->dma_next += NBPG;\n\t\tnext_phys = MIPS_KSEG0_TO_PHYS(asc->dma_next);\n\t}\n\t*(volatile int *)IOASIC_REG_SCSI_DMANPTR(ioasic_base) =\n\t\tIOASIC_DMA_ADDR(next_phys);\n\twbflush();\n}",
    "includes": [
      "#include <pmax/pmax/pmaxtype.h>",
      "#include <pmax/pmax/kmin.h>\t/* XXX ioasic register defs? */",
      "#include <pmax/pmax/asic.h>\t\t/* XXX ioasic register defs? */",
      "#include <machine/bus.h>\t\t/* bus, cache consistency, etc  */",
      "#include <machine/cpu.h>",
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/dev/ascreg.h>\t\t/* XXX */",
      "#include <pmax/dev/scsi.h>\t\t/* XXX */",
      "#include <pmax/dev/device.h>\t\t/* XXX */",
      "#include <machine/autoconf.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wbflush",
          "args": [],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOASIC_DMA_ADDR",
          "args": [
            "next_phys"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOASIC_REG_SCSI_DMANPTR",
          "args": [
            "ioasic_base"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIPS_KSEG0_TO_PHYS",
          "args": [
            "asc->dma_next"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOASIC_REG_CSR",
          "args": [
            "ioasic_base"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pmax/pmax/pmaxtype.h>\n#include <pmax/pmax/kmin.h>\t/* XXX ioasic register defs? */\n#include <pmax/pmax/asic.h>\t\t/* XXX ioasic register defs? */\n#include <machine/bus.h>\t\t/* bus, cache consistency, etc  */\n#include <machine/cpu.h>\n#include <dev/tc/ascvar.h>\n#include <pmax/dev/ascreg.h>\t\t/* XXX */\n#include <pmax/dev/scsi.h>\t\t/* XXX */\n#include <pmax/dev/device.h>\t\t/* XXX */\n#include <machine/autoconf.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nasc_dma_intr()\n{\n\tasc_softc_t asc =  &asc_cd.cd_devs[0]; /*XXX*/\n\tu_int next_phys;\n\n\tasc->dma_xfer -= NBPG;\n\tif (asc->dma_xfer <= -NBPG) {\n\t\tvolatile u_int *ssr = (volatile u_int *)\n\t\t\tIOASIC_REG_CSR(ioasic_base);\n\t\t*ssr &= ~IOASIC_CSR_DMAEN_SCSI;\n\t} else {\n\t\tasc->dma_next += NBPG;\n\t\tnext_phys = MIPS_KSEG0_TO_PHYS(asc->dma_next);\n\t}\n\t*(volatile int *)IOASIC_REG_SCSI_DMANPTR(ioasic_base) =\n\t\tIOASIC_DMA_ADDR(next_phys);\n\twbflush();\n}"
  },
  {
    "function_name": "asic_dma_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc_ioasic.c",
    "lines": "248-304",
    "snippet": "static void\nasic_dma_end(asc, state, flag)\n\tasc_softc_t asc;\n\tState *state;\n\tint flag;\n{\n\tregister volatile u_int *ssr = (volatile u_int *)\n\t\tIOASIC_REG_CSR(ioasic_base);\n\tregister volatile u_int *dmap = (volatile u_int *)\n\t\tIOASIC_REG_SCSI_DMAPTR(ioasic_base);\n\tregister u_short *to;\n\tregister int w;\n\tint nb;\n\n\t*ssr &= ~IOASIC_CSR_DMAEN_SCSI;\n#if USE_CACHED_BUFFER\t/* XXX - Should uncached address always be used? */\n\tto = (u_short *)MIPS_PHYS_TO_KSEG0(*dmap >> 3);\n#else\n\tto = (u_short *)MIPS_PHYS_TO_KSEG1(*dmap >> 3);\n#endif\n\t*dmap = -1;\n\t*((volatile int *)IOASIC_REG_SCSI_DMANPTR(ioasic_base)) = -1;\n\twbflush();\n\n\tif (flag == ASCDMA_READ) {\n#if !defined(ASC_IOASIC_BOUNCE) && USE_CACHED_BUFFER\n\t\t/* Invalidate cache for the buffer */\n#ifdef MIPS3\n\t\tif (CPUISMIPS3)\n\t\t\tMachFlushDCache(MIPS_KSEG1_TO_PHYS(state->dmaBufAddr),\n\t\t\t   state->dmalen);\n\t\telse\n#endif /* MIPS3 */\n\t\t\tMachFlushDCache(MIPS_PHYS_TO_KSEG0(\n\t\t\t    MIPS_KSEG1_TO_PHYS(state->dmaBufAddr)),\n\t\t\t    state->dmalen);\n#endif\t/* USE_CACHED_BUFFER */\n\t\tif ( (nb = *((int *)IOASIC_REG_SCSI_SCR(ioasic_base))) != 0) {\n\t\t\t/* pick up last upto6 bytes, sigh. */\n\t\n\t\t\t/* Last byte really xferred is.. */\n\t\t\tw = *(int *)IOASIC_REG_SCSI_SDR0(ioasic_base);\n\t\t\t*to++ = w;\n\t\t\tif (--nb > 0) {\n\t\t\t\tw >>= 16;\n\t\t\t\t*to++ = w;\n\t\t\t}\n\t\t\tif (--nb > 0) {\n\t\t\t\tw = *(int *)IOASIC_REG_SCSI_SDR1(ioasic_base);\n\t\t\t\t*to++ = w;\n\t\t\t}\n\t\t}\n#ifdef ASC_IOASIC_BOUNCE\n\t\tbcopy(state->dmaBufAddr, state->buf, state->dmalen);\n#endif\n\t}\n}",
    "includes": [
      "#include <pmax/pmax/pmaxtype.h>",
      "#include <pmax/pmax/kmin.h>\t/* XXX ioasic register defs? */",
      "#include <pmax/pmax/asic.h>\t\t/* XXX ioasic register defs? */",
      "#include <machine/bus.h>\t\t/* bus, cache consistency, etc  */",
      "#include <machine/cpu.h>",
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/dev/ascreg.h>\t\t/* XXX */",
      "#include <pmax/dev/scsi.h>\t\t/* XXX */",
      "#include <pmax/dev/device.h>\t\t/* XXX */",
      "#include <machine/autoconf.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define USE_CACHED_BUFFER 0"
    ],
    "globals_used": [
      "static void\nasic_dma_end",
      "__P((asc_softc_t asc, State *state, int flag));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "state->dmaBufAddr",
            "state->buf",
            "state->dmalen"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IOASIC_REG_SCSI_SDR1",
          "args": [
            "ioasic_base"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOASIC_REG_SCSI_SDR0",
          "args": [
            "ioasic_base"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOASIC_REG_SCSI_SCR",
          "args": [
            "ioasic_base"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MachFlushDCache",
          "args": [
            "MIPS_PHYS_TO_KSEG0(\n\t\t\t    MIPS_KSEG1_TO_PHYS(state->dmaBufAddr))",
            "state->dmalen"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIPS_PHYS_TO_KSEG0",
          "args": [
            "MIPS_KSEG1_TO_PHYS(state->dmaBufAddr)"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIPS_KSEG1_TO_PHYS",
          "args": [
            "state->dmaBufAddr"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MachFlushDCache",
          "args": [
            "MIPS_KSEG1_TO_PHYS(state->dmaBufAddr)",
            "state->dmalen"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIPS_KSEG1_TO_PHYS",
          "args": [
            "state->dmaBufAddr"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbflush",
          "args": [],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOASIC_REG_SCSI_DMANPTR",
          "args": [
            "ioasic_base"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIPS_PHYS_TO_KSEG1",
          "args": [
            "*dmap >> 3"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIPS_PHYS_TO_KSEG0",
          "args": [
            "*dmap >> 3"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOASIC_REG_SCSI_DMAPTR",
          "args": [
            "ioasic_base"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOASIC_REG_CSR",
          "args": [
            "ioasic_base"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pmax/pmax/pmaxtype.h>\n#include <pmax/pmax/kmin.h>\t/* XXX ioasic register defs? */\n#include <pmax/pmax/asic.h>\t\t/* XXX ioasic register defs? */\n#include <machine/bus.h>\t\t/* bus, cache consistency, etc  */\n#include <machine/cpu.h>\n#include <dev/tc/ascvar.h>\n#include <pmax/dev/ascreg.h>\t\t/* XXX */\n#include <pmax/dev/scsi.h>\t\t/* XXX */\n#include <pmax/dev/device.h>\t\t/* XXX */\n#include <machine/autoconf.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define USE_CACHED_BUFFER 0\n\nstatic void\nasic_dma_end;\n__P((asc_softc_t asc, State *state, int flag));\n\nstatic void\nasic_dma_end(asc, state, flag)\n\tasc_softc_t asc;\n\tState *state;\n\tint flag;\n{\n\tregister volatile u_int *ssr = (volatile u_int *)\n\t\tIOASIC_REG_CSR(ioasic_base);\n\tregister volatile u_int *dmap = (volatile u_int *)\n\t\tIOASIC_REG_SCSI_DMAPTR(ioasic_base);\n\tregister u_short *to;\n\tregister int w;\n\tint nb;\n\n\t*ssr &= ~IOASIC_CSR_DMAEN_SCSI;\n#if USE_CACHED_BUFFER\t/* XXX - Should uncached address always be used? */\n\tto = (u_short *)MIPS_PHYS_TO_KSEG0(*dmap >> 3);\n#else\n\tto = (u_short *)MIPS_PHYS_TO_KSEG1(*dmap >> 3);\n#endif\n\t*dmap = -1;\n\t*((volatile int *)IOASIC_REG_SCSI_DMANPTR(ioasic_base)) = -1;\n\twbflush();\n\n\tif (flag == ASCDMA_READ) {\n#if !defined(ASC_IOASIC_BOUNCE) && USE_CACHED_BUFFER\n\t\t/* Invalidate cache for the buffer */\n#ifdef MIPS3\n\t\tif (CPUISMIPS3)\n\t\t\tMachFlushDCache(MIPS_KSEG1_TO_PHYS(state->dmaBufAddr),\n\t\t\t   state->dmalen);\n\t\telse\n#endif /* MIPS3 */\n\t\t\tMachFlushDCache(MIPS_PHYS_TO_KSEG0(\n\t\t\t    MIPS_KSEG1_TO_PHYS(state->dmaBufAddr)),\n\t\t\t    state->dmalen);\n#endif\t/* USE_CACHED_BUFFER */\n\t\tif ( (nb = *((int *)IOASIC_REG_SCSI_SCR(ioasic_base))) != 0) {\n\t\t\t/* pick up last upto6 bytes, sigh. */\n\t\n\t\t\t/* Last byte really xferred is.. */\n\t\t\tw = *(int *)IOASIC_REG_SCSI_SDR0(ioasic_base);\n\t\t\t*to++ = w;\n\t\t\tif (--nb > 0) {\n\t\t\t\tw >>= 16;\n\t\t\t\t*to++ = w;\n\t\t\t}\n\t\t\tif (--nb > 0) {\n\t\t\t\tw = *(int *)IOASIC_REG_SCSI_SDR1(ioasic_base);\n\t\t\t\t*to++ = w;\n\t\t\t}\n\t\t}\n#ifdef ASC_IOASIC_BOUNCE\n\t\tbcopy(state->dmaBufAddr, state->buf, state->dmalen);\n#endif\n\t}\n}"
  },
  {
    "function_name": "asic_dma_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc_ioasic.c",
    "lines": "163-246",
    "snippet": "static int\nasic_dma_start(asc, state, cp, flag, len, off)\n\tasc_softc_t asc;\n\tState *state;\n\tcaddr_t cp;\n\tint flag;\n\tint len;\n\tint off;\n{\n\tregister volatile u_int *ssr = (volatile u_int *)\n\t\tIOASIC_REG_CSR(ioasic_base);\n\tu_int phys, nphys;\n\n\t/* stop DMA engine first */\n\t*ssr &= ~IOASIC_CSR_DMAEN_SCSI;\n\t*((volatile int *)IOASIC_REG_SCSI_SCR(ioasic_base)) = 0;\n\n#ifndef ASC_IOASIC_BOUNCE\n\t/* restrict len to the maximum the IOASIC can transfer */\n\tif (len > ((caddr_t)mips_trunc_page(cp + NBPG * 2) - cp))\n\t\tlen = (caddr_t)mips_trunc_page(cp + NBPG * 2) - cp;\n\n\t/* If R4K, writeback and invalidate  the buffer */\n\tif (CPUISMIPS3)\n\t\tmips3_HitFlushDCache((vm_offset_t)cp, len);\n\n\t/* Get physical address of buffer start, no next phys addr */\n\tphys = (u_int)kvtophys((vm_offset_t)cp);\n\tnphys = -1;\n\n\t/* Compute 2nd DMA pointer only if next page is part of this I/O */\n\tif ((NBPG - (phys & (NBPG - 1))) < len) {\n\t\tcp = (caddr_t)mips_trunc_page(cp + NBPG);\n\t\tnphys = (u_int)kvtophys((vm_offset_t)cp);\n\t}\n\n\t/* If not R4K, need to invalidate cache lines for both physical segments */\n\tif (!CPUISMIPS3 && flag == ASCDMA_READ) {\n\t\tMachFlushDCache(MIPS_PHYS_TO_KSEG0(phys),\n\t\t    nphys == 0xffffffff ?  len : NBPG - (phys & (NBPG - 1)));\n\t\tif (nphys != 0xffffffff)\n\t\t\tMachFlushDCache(MIPS_PHYS_TO_KSEG0(nphys),\n\t\t\t    NBPG);\t/* XXX */\n\t}\n#else\t/* ASC_IOASIC_BOUNCE */\n\t/* restrict len to the maximum the IOASIC can transfer */\n\tif (len > ((caddr_t)mips_trunc_page(state->dmaBufAddr + off + NBPG * 2) - (caddr_t)(state->dmaBufAddr + off)))\n\t\tlen = (caddr_t)mips_trunc_page(state->dmaBufAddr + off + NBPG * 2) - (caddr_t)(state->dmaBufAddr + off);\n\n\tif (flag == ASCDMA_WRITE)\n\t\tbcopy(cp, state->dmaBufAddr + off, len);\n\tcp = state->dmaBufAddr + off;\n#if USE_CACHED_BUFFER\n#ifdef MIPS3\n\t/* If R4K, need to writeback the bounce buffer */\n\tif (CPUISMIPS3)\n\t\tmips3_HitFlushDCache((vm_offset_t)cp, len);\n#endif /* MIPS3 */\n\tphys = MIPS_KSEG0_TO_PHYS(cp);\n\tcp = (caddr_t)mips_trunc_page(cp + NBPG);\n\tnphys = MIPS_KSEG0_TO_PHYS(cp);\n#else\n\tphys = MIPS_KSEG1_TO_PHYS(cp);\n\tcp = (caddr_t)mips_trunc_page(cp + NBPG);\n\tnphys = MIPS_KSEG1_TO_PHYS(cp);\n#endif\t/* USE_CACHED_BUFFER */\n#endif\t/* ASC_IOASIC_BOUNCE */\n\n#ifdef notyet\n\tasc->dma_next = cp;\n\tasc->dma_xfer = state->dmalen - (nphys - phys);\n#endif\n\n\t*(volatile int *)IOASIC_REG_SCSI_DMAPTR(ioasic_base) =\n\t\tIOASIC_DMA_ADDR(phys);\n\t*(volatile int *)IOASIC_REG_SCSI_DMANPTR(ioasic_base) =\n\t\tIOASIC_DMA_ADDR(nphys);\n\tif (flag == ASCDMA_READ)\n\t\t*ssr |= IOASIC_CSR_SCSI_DIR | IOASIC_CSR_DMAEN_SCSI;\n\telse\n\t\t*ssr = (*ssr & ~IOASIC_CSR_SCSI_DIR) | IOASIC_CSR_DMAEN_SCSI;\n\twbflush();\n\treturn (len);\n}",
    "includes": [
      "#include <pmax/pmax/pmaxtype.h>",
      "#include <pmax/pmax/kmin.h>\t/* XXX ioasic register defs? */",
      "#include <pmax/pmax/asic.h>\t\t/* XXX ioasic register defs? */",
      "#include <machine/bus.h>\t\t/* bus, cache consistency, etc  */",
      "#include <machine/cpu.h>",
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/dev/ascreg.h>\t\t/* XXX */",
      "#include <pmax/dev/scsi.h>\t\t/* XXX */",
      "#include <pmax/dev/device.h>\t\t/* XXX */",
      "#include <machine/autoconf.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define USE_CACHED_BUFFER 0"
    ],
    "globals_used": [
      "extern vm_offset_t kvtophys",
      "static int\nasic_dma_start",
      "__P((asc_softc_t asc, State *state, caddr_t cp, int flag,\n    int len, int off));",
      "__P((asc_softc_t asc, State *state, int flag));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wbflush",
          "args": [],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOASIC_DMA_ADDR",
          "args": [
            "nphys"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOASIC_REG_SCSI_DMANPTR",
          "args": [
            "ioasic_base"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOASIC_DMA_ADDR",
          "args": [
            "phys"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOASIC_REG_SCSI_DMAPTR",
          "args": [
            "ioasic_base"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIPS_KSEG1_TO_PHYS",
          "args": [
            "cp"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mips_trunc_page",
          "args": [
            "cp + NBPG"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIPS_KSEG1_TO_PHYS",
          "args": [
            "cp"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIPS_KSEG0_TO_PHYS",
          "args": [
            "cp"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mips_trunc_page",
          "args": [
            "cp + NBPG"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIPS_KSEG0_TO_PHYS",
          "args": [
            "cp"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mips3_HitFlushDCache",
          "args": [
            "(vm_offset_t)cp",
            "len"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "cp",
            "state->dmaBufAddr + off",
            "len"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "state->dmaBufAddr + off"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mips_trunc_page",
          "args": [
            "state->dmaBufAddr + off + NBPG * 2"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "state->dmaBufAddr + off"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mips_trunc_page",
          "args": [
            "state->dmaBufAddr + off + NBPG * 2"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MachFlushDCache",
          "args": [
            "MIPS_PHYS_TO_KSEG0(nphys)",
            "NBPG"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIPS_PHYS_TO_KSEG0",
          "args": [
            "nphys"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MachFlushDCache",
          "args": [
            "MIPS_PHYS_TO_KSEG0(phys)",
            "nphys == 0xffffffff ?  len : NBPG - (phys & (NBPG - 1))"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIPS_PHYS_TO_KSEG0",
          "args": [
            "phys"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvtophys",
          "args": [
            "(vm_offset_t)cp"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mips_trunc_page",
          "args": [
            "cp + NBPG"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvtophys",
          "args": [
            "(vm_offset_t)cp"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mips3_HitFlushDCache",
          "args": [
            "(vm_offset_t)cp",
            "len"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mips_trunc_page",
          "args": [
            "cp + NBPG * 2"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mips_trunc_page",
          "args": [
            "cp + NBPG * 2"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOASIC_REG_SCSI_SCR",
          "args": [
            "ioasic_base"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOASIC_REG_CSR",
          "args": [
            "ioasic_base"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pmax/pmax/pmaxtype.h>\n#include <pmax/pmax/kmin.h>\t/* XXX ioasic register defs? */\n#include <pmax/pmax/asic.h>\t\t/* XXX ioasic register defs? */\n#include <machine/bus.h>\t\t/* bus, cache consistency, etc  */\n#include <machine/cpu.h>\n#include <dev/tc/ascvar.h>\n#include <pmax/dev/ascreg.h>\t\t/* XXX */\n#include <pmax/dev/scsi.h>\t\t/* XXX */\n#include <pmax/dev/device.h>\t\t/* XXX */\n#include <machine/autoconf.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define USE_CACHED_BUFFER 0\n\nextern vm_offset_t kvtophys;\nstatic int\nasic_dma_start;\n__P((asc_softc_t asc, State *state, caddr_t cp, int flag,\n    int len, int off));\n__P((asc_softc_t asc, State *state, int flag));\n\nstatic int\nasic_dma_start(asc, state, cp, flag, len, off)\n\tasc_softc_t asc;\n\tState *state;\n\tcaddr_t cp;\n\tint flag;\n\tint len;\n\tint off;\n{\n\tregister volatile u_int *ssr = (volatile u_int *)\n\t\tIOASIC_REG_CSR(ioasic_base);\n\tu_int phys, nphys;\n\n\t/* stop DMA engine first */\n\t*ssr &= ~IOASIC_CSR_DMAEN_SCSI;\n\t*((volatile int *)IOASIC_REG_SCSI_SCR(ioasic_base)) = 0;\n\n#ifndef ASC_IOASIC_BOUNCE\n\t/* restrict len to the maximum the IOASIC can transfer */\n\tif (len > ((caddr_t)mips_trunc_page(cp + NBPG * 2) - cp))\n\t\tlen = (caddr_t)mips_trunc_page(cp + NBPG * 2) - cp;\n\n\t/* If R4K, writeback and invalidate  the buffer */\n\tif (CPUISMIPS3)\n\t\tmips3_HitFlushDCache((vm_offset_t)cp, len);\n\n\t/* Get physical address of buffer start, no next phys addr */\n\tphys = (u_int)kvtophys((vm_offset_t)cp);\n\tnphys = -1;\n\n\t/* Compute 2nd DMA pointer only if next page is part of this I/O */\n\tif ((NBPG - (phys & (NBPG - 1))) < len) {\n\t\tcp = (caddr_t)mips_trunc_page(cp + NBPG);\n\t\tnphys = (u_int)kvtophys((vm_offset_t)cp);\n\t}\n\n\t/* If not R4K, need to invalidate cache lines for both physical segments */\n\tif (!CPUISMIPS3 && flag == ASCDMA_READ) {\n\t\tMachFlushDCache(MIPS_PHYS_TO_KSEG0(phys),\n\t\t    nphys == 0xffffffff ?  len : NBPG - (phys & (NBPG - 1)));\n\t\tif (nphys != 0xffffffff)\n\t\t\tMachFlushDCache(MIPS_PHYS_TO_KSEG0(nphys),\n\t\t\t    NBPG);\t/* XXX */\n\t}\n#else\t/* ASC_IOASIC_BOUNCE */\n\t/* restrict len to the maximum the IOASIC can transfer */\n\tif (len > ((caddr_t)mips_trunc_page(state->dmaBufAddr + off + NBPG * 2) - (caddr_t)(state->dmaBufAddr + off)))\n\t\tlen = (caddr_t)mips_trunc_page(state->dmaBufAddr + off + NBPG * 2) - (caddr_t)(state->dmaBufAddr + off);\n\n\tif (flag == ASCDMA_WRITE)\n\t\tbcopy(cp, state->dmaBufAddr + off, len);\n\tcp = state->dmaBufAddr + off;\n#if USE_CACHED_BUFFER\n#ifdef MIPS3\n\t/* If R4K, need to writeback the bounce buffer */\n\tif (CPUISMIPS3)\n\t\tmips3_HitFlushDCache((vm_offset_t)cp, len);\n#endif /* MIPS3 */\n\tphys = MIPS_KSEG0_TO_PHYS(cp);\n\tcp = (caddr_t)mips_trunc_page(cp + NBPG);\n\tnphys = MIPS_KSEG0_TO_PHYS(cp);\n#else\n\tphys = MIPS_KSEG1_TO_PHYS(cp);\n\tcp = (caddr_t)mips_trunc_page(cp + NBPG);\n\tnphys = MIPS_KSEG1_TO_PHYS(cp);\n#endif\t/* USE_CACHED_BUFFER */\n#endif\t/* ASC_IOASIC_BOUNCE */\n\n#ifdef notyet\n\tasc->dma_next = cp;\n\tasc->dma_xfer = state->dmalen - (nphys - phys);\n#endif\n\n\t*(volatile int *)IOASIC_REG_SCSI_DMAPTR(ioasic_base) =\n\t\tIOASIC_DMA_ADDR(phys);\n\t*(volatile int *)IOASIC_REG_SCSI_DMANPTR(ioasic_base) =\n\t\tIOASIC_DMA_ADDR(nphys);\n\tif (flag == ASCDMA_READ)\n\t\t*ssr |= IOASIC_CSR_SCSI_DIR | IOASIC_CSR_DMAEN_SCSI;\n\telse\n\t\t*ssr = (*ssr & ~IOASIC_CSR_SCSI_DIR) | IOASIC_CSR_DMAEN_SCSI;\n\twbflush();\n\treturn (len);\n}"
  },
  {
    "function_name": "asc_ioasic_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc_ioasic.c",
    "lines": "92-156",
    "snippet": "void\nasc_ioasic_attach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tregister struct ioasicdev_attach_args *d = aux;\n\tregister asc_softc_t asc = (asc_softc_t) self;\n#ifdef ASC_IOASIC_BOUNCE\n\tu_char *buff;\n\tint i;\n#endif\n\n\tvoid *ascaddr;\n\tint unit;\n\n\tascaddr = (void*)MIPS_PHYS_TO_KSEG1(d->iada_addr);\n\tunit = asc->sc_dev.dv_unit;\n\t\n\t/*\n\t * Initialize hw descriptor, cache some pointers\n\t */\n\tasc->regs = (asc_regmap_t *)(ascaddr + ASC_OFFSET_53C94);\n\n\t/*\n\t * Set up machine dependencies.\n\t * (1) how to do dma\n\t * (2) timing based on turbochannel frequency\n\t */\n\n#ifdef ASC_IOASIC_BOUNCE\n#if USE_CACHED_BUFFER\n\t/* XXX Use cached address for DMA buffer to increase raw read speed */\n\tbuff = (u_char *)MIPS_PHYS_TO_KSEG0(asc_iomem);\n#else\n\tbuff = (u_char *)MIPS_PHYS_TO_KSEG1(asc_iomem);\n#endif\t/* USE_CACHED_BUFFER */\n\t/*\n\t * Statically partition the DMA buffer between targets.\n\t * This way we will eventually be able to attach/detach\n\t * drives on-fly.  And 18k/target is plenty for normal use.\n\t */\n\n\t/*\n\t * Give each target its own DMA buffer region.\n\t * We may want to try ping ponging buffers later.\n\t */\n\tfor (i = 0; i < ASC_NCMD; i++)\n\t\tasc->st[i].dmaBufAddr = buff + 8192 * i;\n\n#endif\t/* ASC_IOASIC_BOUNCE */\n\t*((volatile int *)IOASIC_REG_SCSI_DMAPTR(ioasic_base)) = -1;\n\t*((volatile int *)IOASIC_REG_SCSI_DMANPTR(ioasic_base)) = -1;\n\t*((volatile int *)IOASIC_REG_SCSI_SCR(ioasic_base)) = 0;\n\tasc->dma_start = asic_dma_start;\n\tasc->dma_end = asic_dma_end;\n\n\t/* digital meters show IOASIC 53c94s are clocked at approx 25MHz */\n\tascattach(asc, ASC_SPEED_25_MHZ);\n\n\t/* tie pseudo-slot to device */\n\n\tioasic_intr_establish(parent, d->iada_cookie, TC_IPL_BIO,\n\t\t\t      asc_intr, asc);\n}",
    "includes": [
      "#include <pmax/pmax/pmaxtype.h>",
      "#include <pmax/pmax/kmin.h>\t/* XXX ioasic register defs? */",
      "#include <pmax/pmax/asic.h>\t\t/* XXX ioasic register defs? */",
      "#include <machine/bus.h>\t\t/* bus, cache consistency, etc  */",
      "#include <machine/cpu.h>",
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/dev/ascreg.h>\t\t/* XXX */",
      "#include <pmax/dev/scsi.h>\t\t/* XXX */",
      "#include <pmax/dev/device.h>\t\t/* XXX */",
      "#include <machine/autoconf.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define USE_CACHED_BUFFER 0"
    ],
    "globals_used": [
      "void asc_ioasic_attach",
      "static int\nasic_dma_start",
      "static void\nasic_dma_end"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ioasic_intr_establish",
          "args": [
            "parent",
            "d->iada_cookie",
            "TC_IPL_BIO",
            "asc_intr",
            "asc"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascattach",
          "args": [
            "asc",
            "ASC_SPEED_25_MHZ"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "ascattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
          "lines": "450-546",
          "snippet": "void\nascattach(asc, bus_speed)\n\tregister asc_softc_t asc;\n\tint bus_speed;\n{\n\tregister asc_regmap_t *regs;\n\tint id, s;\n\n\tint unit;\n\n\tunit = asc->sc_dev.dv_unit;\n\t\n\t/*\n\t * Set up machine dependencies.\n\t * (1) timing based on turbochannel frequency\n\t */\n\n\t/* dma setup done in parent-specific attach code */\n\n\t/*\n\t * Now for timing. The 3max has a 25Mhz tb whereas the 3min and\n\t * maxine are 12.5Mhz.\n\t */\n\tswitch (bus_speed) {\n\tcase ASC_SPEED_25_MHZ:\n\t\tasc->min_period = ASC_MIN_PERIOD25;\n\t\tasc->max_period = ASC_MAX_PERIOD25;\n\t\tasc->ccf = ASC_CCF(25);\n\t\tasc->timeout_250 = ASC_TIMEOUT_250(25, asc->ccf);\n\t\tasc->tb_ticks = 10;\n\t\tbreak;\n\n\tcase ASC_SPEED_12_5_MHZ:\n\tdefault:\n\t\tasc->min_period = ASC_MIN_PERIOD12;\n\t\tasc->max_period = ASC_MAX_PERIOD12;\n\t\tasc->ccf = ASC_CCF(13);\n\t\tasc->timeout_250 = ASC_TIMEOUT_250(13, asc->ccf);\n\t\tasc->tb_ticks = 20;\n\t\tbreak;\n\t};\n\n\tasc->state = ASC_STATE_IDLE;\n\tasc->target = -1;\n\n\tregs = asc->regs;\n\n\t/*\n\t * Reset chip, fully.  Note that interrupts are already enabled.\n\t */\n\ts = splbio();\n\n\t/* preserve our ID for now */\n\tasc->sc_id = regs->asc_cnfg1 & ASC_CNFG1_MY_BUS_ID;\n\tasc->myidmask = ~(1 << asc->sc_id);\n\n\tasc_reset(asc, regs);\n\n\t/*\n\t * Our SCSI id on the bus.\n\t * The user can set this via the prom on 3maxen/pmaxen.\n\t * If this changes it is easy to fix: make a default that\n\t * can be changed as boot arg.\n\t */\n#ifdef\tunneeded\n\tregs->asc_cnfg1 = (regs->asc_cnfg1 & ~ASC_CNFG1_MY_BUS_ID) |\n\t\t\t      (scsi_initiator_id[unit] & 0x7);\n\tasc->sc_id = regs->asc_cnfg1 & ASC_CNFG1_MY_BUS_ID;\n#endif\n\n\tid = asc->sc_id;\n\tsplx(s);\n\n\t/* Hack for old-sytle SCSI-device probe */\n\t(void) pmax_add_scsi(&ascdriver, unit);\n\n\tprintf(\": target %d\\n\", id);\n\n\n#ifdef USE_NEW_SCSI\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n\tasc->sc_link.channel = SCSI_CHANNEL_ONLY_ONE;\n\tasc->sc_link.adapter_softc = asc;\n\tasc->sc_link.adapter_target = asc->sc_id;\n\tasc->sc_link.adapter = &asc_switch;\n\tasc->sc_link.device = &asc_dev;\n\tasc->sc_link.openings = 2;\n\n\t/*\n\t * Now try to attach all the sub-devices.\n\t */\n\tconfig_found(self, &asc->sc_link, scsiprint);\n\n#endif /* USE_NEW_SCSI */\n}",
          "includes": [
            "#include <dev/tc/ascvar.h>",
            "#include <pmax/pmax/kmin.h>",
            "#include <pmax/pmax/asic.h>",
            "#include <pmax/dev/ascreg.h>",
            "#include <pmax/dev/scsi.h>",
            "#include <pmax/dev/device.h>",
            "#include <machine/bus.h>",
            "#include <machine/autoconf.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/tc/ioasicvar.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <sys/reboot.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/errno.h>",
            "#include <sys/conf.h>",
            "#include <sys/buf.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <asc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\nvoid\nascattach(asc, bus_speed)\n\tregister asc_softc_t asc;\n\tint bus_speed;\n{\n\tregister asc_regmap_t *regs;\n\tint id, s;\n\n\tint unit;\n\n\tunit = asc->sc_dev.dv_unit;\n\t\n\t/*\n\t * Set up machine dependencies.\n\t * (1) timing based on turbochannel frequency\n\t */\n\n\t/* dma setup done in parent-specific attach code */\n\n\t/*\n\t * Now for timing. The 3max has a 25Mhz tb whereas the 3min and\n\t * maxine are 12.5Mhz.\n\t */\n\tswitch (bus_speed) {\n\tcase ASC_SPEED_25_MHZ:\n\t\tasc->min_period = ASC_MIN_PERIOD25;\n\t\tasc->max_period = ASC_MAX_PERIOD25;\n\t\tasc->ccf = ASC_CCF(25);\n\t\tasc->timeout_250 = ASC_TIMEOUT_250(25, asc->ccf);\n\t\tasc->tb_ticks = 10;\n\t\tbreak;\n\n\tcase ASC_SPEED_12_5_MHZ:\n\tdefault:\n\t\tasc->min_period = ASC_MIN_PERIOD12;\n\t\tasc->max_period = ASC_MAX_PERIOD12;\n\t\tasc->ccf = ASC_CCF(13);\n\t\tasc->timeout_250 = ASC_TIMEOUT_250(13, asc->ccf);\n\t\tasc->tb_ticks = 20;\n\t\tbreak;\n\t};\n\n\tasc->state = ASC_STATE_IDLE;\n\tasc->target = -1;\n\n\tregs = asc->regs;\n\n\t/*\n\t * Reset chip, fully.  Note that interrupts are already enabled.\n\t */\n\ts = splbio();\n\n\t/* preserve our ID for now */\n\tasc->sc_id = regs->asc_cnfg1 & ASC_CNFG1_MY_BUS_ID;\n\tasc->myidmask = ~(1 << asc->sc_id);\n\n\tasc_reset(asc, regs);\n\n\t/*\n\t * Our SCSI id on the bus.\n\t * The user can set this via the prom on 3maxen/pmaxen.\n\t * If this changes it is easy to fix: make a default that\n\t * can be changed as boot arg.\n\t */\n#ifdef\tunneeded\n\tregs->asc_cnfg1 = (regs->asc_cnfg1 & ~ASC_CNFG1_MY_BUS_ID) |\n\t\t\t      (scsi_initiator_id[unit] & 0x7);\n\tasc->sc_id = regs->asc_cnfg1 & ASC_CNFG1_MY_BUS_ID;\n#endif\n\n\tid = asc->sc_id;\n\tsplx(s);\n\n\t/* Hack for old-sytle SCSI-device probe */\n\t(void) pmax_add_scsi(&ascdriver, unit);\n\n\tprintf(\": target %d\\n\", id);\n\n\n#ifdef USE_NEW_SCSI\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n\tasc->sc_link.channel = SCSI_CHANNEL_ONLY_ONE;\n\tasc->sc_link.adapter_softc = asc;\n\tasc->sc_link.adapter_target = asc->sc_id;\n\tasc->sc_link.adapter = &asc_switch;\n\tasc->sc_link.device = &asc_dev;\n\tasc->sc_link.openings = 2;\n\n\t/*\n\t * Now try to attach all the sub-devices.\n\t */\n\tconfig_found(self, &asc->sc_link, scsiprint);\n\n#endif /* USE_NEW_SCSI */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IOASIC_REG_SCSI_SCR",
          "args": [
            "ioasic_base"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOASIC_REG_SCSI_DMANPTR",
          "args": [
            "ioasic_base"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOASIC_REG_SCSI_DMAPTR",
          "args": [
            "ioasic_base"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIPS_PHYS_TO_KSEG1",
          "args": [
            "asc_iomem"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIPS_PHYS_TO_KSEG0",
          "args": [
            "asc_iomem"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIPS_PHYS_TO_KSEG1",
          "args": [
            "d->iada_addr"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pmax/pmax/pmaxtype.h>\n#include <pmax/pmax/kmin.h>\t/* XXX ioasic register defs? */\n#include <pmax/pmax/asic.h>\t\t/* XXX ioasic register defs? */\n#include <machine/bus.h>\t\t/* bus, cache consistency, etc  */\n#include <machine/cpu.h>\n#include <dev/tc/ascvar.h>\n#include <pmax/dev/ascreg.h>\t\t/* XXX */\n#include <pmax/dev/scsi.h>\t\t/* XXX */\n#include <pmax/dev/device.h>\t\t/* XXX */\n#include <machine/autoconf.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define USE_CACHED_BUFFER 0\n\nvoid asc_ioasic_attach;\nstatic int\nasic_dma_start;\nstatic void\nasic_dma_end;\n\nvoid\nasc_ioasic_attach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tregister struct ioasicdev_attach_args *d = aux;\n\tregister asc_softc_t asc = (asc_softc_t) self;\n#ifdef ASC_IOASIC_BOUNCE\n\tu_char *buff;\n\tint i;\n#endif\n\n\tvoid *ascaddr;\n\tint unit;\n\n\tascaddr = (void*)MIPS_PHYS_TO_KSEG1(d->iada_addr);\n\tunit = asc->sc_dev.dv_unit;\n\t\n\t/*\n\t * Initialize hw descriptor, cache some pointers\n\t */\n\tasc->regs = (asc_regmap_t *)(ascaddr + ASC_OFFSET_53C94);\n\n\t/*\n\t * Set up machine dependencies.\n\t * (1) how to do dma\n\t * (2) timing based on turbochannel frequency\n\t */\n\n#ifdef ASC_IOASIC_BOUNCE\n#if USE_CACHED_BUFFER\n\t/* XXX Use cached address for DMA buffer to increase raw read speed */\n\tbuff = (u_char *)MIPS_PHYS_TO_KSEG0(asc_iomem);\n#else\n\tbuff = (u_char *)MIPS_PHYS_TO_KSEG1(asc_iomem);\n#endif\t/* USE_CACHED_BUFFER */\n\t/*\n\t * Statically partition the DMA buffer between targets.\n\t * This way we will eventually be able to attach/detach\n\t * drives on-fly.  And 18k/target is plenty for normal use.\n\t */\n\n\t/*\n\t * Give each target its own DMA buffer region.\n\t * We may want to try ping ponging buffers later.\n\t */\n\tfor (i = 0; i < ASC_NCMD; i++)\n\t\tasc->st[i].dmaBufAddr = buff + 8192 * i;\n\n#endif\t/* ASC_IOASIC_BOUNCE */\n\t*((volatile int *)IOASIC_REG_SCSI_DMAPTR(ioasic_base)) = -1;\n\t*((volatile int *)IOASIC_REG_SCSI_DMANPTR(ioasic_base)) = -1;\n\t*((volatile int *)IOASIC_REG_SCSI_SCR(ioasic_base)) = 0;\n\tasc->dma_start = asic_dma_start;\n\tasc->dma_end = asic_dma_end;\n\n\t/* digital meters show IOASIC 53c94s are clocked at approx 25MHz */\n\tascattach(asc, ASC_SPEED_25_MHZ);\n\n\t/* tie pseudo-slot to device */\n\n\tioasic_intr_establish(parent, d->iada_cookie, TC_IPL_BIO,\n\t\t\t      asc_intr, asc);\n}"
  },
  {
    "function_name": "asc_ioasic_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc_ioasic.c",
    "lines": "71-90",
    "snippet": "int\nasc_ioasic_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct ioasicdev_attach_args *d = aux;\n\tvoid *ascaddr;\n\n\tif (strncmp(d->iada_modname, \"asc\", TC_ROM_LLEN) &&\n\t    strncmp(d->iada_modname, \"PMAZ-AA \", TC_ROM_LLEN))\n\t\treturn (0);\n\n\t/* probe for chip */\n\tascaddr = (void*)d->iada_addr;\n\tif (tc_badaddr(ascaddr + ASC_OFFSET_53C94))\n\t\treturn (0);\n\n\treturn (1);\n}",
    "includes": [
      "#include <pmax/pmax/pmaxtype.h>",
      "#include <pmax/pmax/kmin.h>\t/* XXX ioasic register defs? */",
      "#include <pmax/pmax/asic.h>\t\t/* XXX ioasic register defs? */",
      "#include <machine/bus.h>\t\t/* bus, cache consistency, etc  */",
      "#include <machine/cpu.h>",
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/dev/ascreg.h>\t\t/* XXX */",
      "#include <pmax/dev/scsi.h>\t\t/* XXX */",
      "#include <pmax/dev/device.h>\t\t/* XXX */",
      "#include <machine/autoconf.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int asc_ioasic_match"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tc_badaddr",
          "args": [
            "ascaddr + ASC_OFFSET_53C94"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "d->iada_modname",
            "\"PMAZ-AA \"",
            "TC_ROM_LLEN"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "d->iada_modname",
            "\"asc\"",
            "TC_ROM_LLEN"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pmax/pmax/pmaxtype.h>\n#include <pmax/pmax/kmin.h>\t/* XXX ioasic register defs? */\n#include <pmax/pmax/asic.h>\t\t/* XXX ioasic register defs? */\n#include <machine/bus.h>\t\t/* bus, cache consistency, etc  */\n#include <machine/cpu.h>\n#include <dev/tc/ascvar.h>\n#include <pmax/dev/ascreg.h>\t\t/* XXX */\n#include <pmax/dev/scsi.h>\t\t/* XXX */\n#include <pmax/dev/device.h>\t\t/* XXX */\n#include <machine/autoconf.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint asc_ioasic_match;\n\nint\nasc_ioasic_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct ioasicdev_attach_args *d = aux;\n\tvoid *ascaddr;\n\n\tif (strncmp(d->iada_modname, \"asc\", TC_ROM_LLEN) &&\n\t    strncmp(d->iada_modname, \"PMAZ-AA \", TC_ROM_LLEN))\n\t\treturn (0);\n\n\t/* probe for chip */\n\tascaddr = (void*)d->iada_addr;\n\tif (tc_badaddr(ascaddr + ASC_OFFSET_53C94))\n\t\treturn (0);\n\n\treturn (1);\n}"
  }
]