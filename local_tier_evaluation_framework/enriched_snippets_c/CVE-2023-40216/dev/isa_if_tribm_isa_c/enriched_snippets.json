[
  {
    "function_name": "tribm_isa_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_tribm_isa.c",
    "lines": "63-174",
    "snippet": "int\ntribm_isa_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tstatic int irq_f[4] = { 9, 3, 6, 7 };\n\tstatic int irq_e[4] = { 9, 3, 10, 11 };\n\tbus_space_tag_t piot = ia->ia_iot;\n\tbus_space_tag_t memt = ia->ia_memt;\n\tbus_space_handle_t pioh, mmioh;\n\tint i, irq;\n\tu_int8_t s;\n\n#ifdef notyet\n/* XXX Try both 0xa20 and 0xa24 and store that info like 3com */\n\tif (ia->ia_iobase == IOBASEUNK)\n\t\tia->ia_iobase = 0xa20;\n#else\n\tif (ia->ia_iobase == IOBASEUNK)\n\t\treturn 0;\n#endif\n\n\tia->ia_iosize = 4;\n\tia->ia_aux = NULL;\n\n\tif (tr_isa_map_io(ia, &pioh, &mmioh))\n\t\treturn 0;\n\n/*\n * F = Token-Ring Network PC Adapter\n *     Token-Ring Network PC Adapter II\n *     Token-Ring Network Adapter/A\n * E = Token-Ring Network 16/4 Adapter/A (long card)\n *     Token-Ring Network 16/4 Adapter\n * D = Token-Ring Network 16/4 Adapter/A (short card)\n *     16/4 ISA-16 Adapter\n * C = Auto 16/4 Token-Ring ISA Adapter\n *     Auto 16/4 Token-Ring MC Adapter\n */\n/*\n * XXX Both 0xD and 0xC types should be able to use 16-bit read and writes\n */\n\tswitch (bus_space_read_1(memt, mmioh, TR_TYP_OFFSET)) {\n\tcase 0xF:\n\tcase 0xE:\n\tcase 0xD:\n\t\tif (ia->ia_maddr == MADDRUNK)\n#ifdef notyet\n\t\t\tia->ia_maddr = TR_SRAM_DEFAULT;\n#else\n\t\t\treturn 0;\n#endif\n\t\tbreak;\n\tcase 0xC:\n\t\ti = bus_space_read_1(memt, mmioh, TR_ACA_OFFSET) << 12;\n\t\tif (ia->ia_maddr == MADDRUNK)\n\t\t\tia->ia_maddr = i;\n\t\telse if (ia->ia_maddr != i) {\n\t\t\tprintf(\n\"tribm_isa_probe: sram mismatch; kernel configured %x != board configured %x\\n\",\n\t\t\t\tia->ia_maddr, i);\n\t\t\ttr_isa_unmap_io(ia, pioh, mmioh);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"tribm_isa_probe: unknown type code %x\\n\",\n\t\t    bus_space_read_1(memt, mmioh, TR_TYP_OFFSET));\n\t\ttr_isa_unmap_io(ia, pioh, mmioh);\n\t\treturn 0;\n\t}\n\n\ts = bus_space_read_1(piot, pioh, TR_SWITCH);\n\n\tswitch (bus_space_read_1(memt, mmioh, TR_IRQ_OFFSET)) {\n\tcase 0xF:\n\t\tirq = irq_f[s & 3];\n\t\tbreak;\n\tcase 0xE:\n\t\tirq = irq_e[s & 3];\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"tribm_isa_probe: Unknown IRQ code %x\\n\",\n\t\t    bus_space_read_1(memt, mmioh, TR_IRQ_OFFSET));\n\t\ttr_isa_unmap_io(ia, pioh, mmioh);\n\t\treturn 0;\n\t}\n\n\tif (ia->ia_irq == IRQUNK)\n\t\tia->ia_irq = irq;\n\telse if (ia->ia_irq != irq) {\n\t\tprintf(\n\"tribm_isa_probe: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\tia->ia_irq, irq);\n\t\ttr_isa_unmap_io(ia, pioh, mmioh);\n\t\treturn 0;\n\t}\n/*\n * XXX 0x0c == MSIZEMASK (MSIZEBITS)\n */\n\tia->ia_msize = 8192 <<\n\t    ((bus_space_read_1(memt, mmioh, TR_ACA_OFFSET + 1) & 0x0c) >> 2);\n\ttr_isa_unmap_io(ia, pioh, mmioh);\n\t/* Check alignment of membase. */\n\tif ((ia->ia_maddr & (ia->ia_msize-1)) != 0) {\n\t\tprintf(\"tribm_isa_probe: SRAM unaligned 0x%04x/%d\\n\",\n\t\t    ia->ia_maddr, ia->ia_msize);\n\t\treturn 0;\n\t}\n \treturn 1;\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ttribm_isa_probe",
      "int\ttr_isa_map_io",
      "void\ttr_isa_unmap_io"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"tribm_isa_probe: SRAM unaligned 0x%04x/%d\\n\"",
            "ia->ia_maddr",
            "ia->ia_msize"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tr_isa_unmap_io",
          "args": [
            "ia",
            "pioh",
            "mmioh"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "tr_isa_unmap_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_tr_isa.c",
          "lines": "120-127",
          "snippet": "void\ntr_isa_unmap_io(ia, pioh, mmioh)\nstruct isa_attach_args *ia;\nbus_space_handle_t pioh, mmioh;\n{\n\tbus_space_unmap(ia->ia_memt, mmioh, TR_MMIO_SIZE);\n\tbus_space_unmap(ia->ia_iot, pioh, ia->ia_iosize);\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_isa_unmap_io"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ttr_isa_unmap_io;\n\nvoid\ntr_isa_unmap_io(ia, pioh, mmioh)\nstruct isa_attach_args *ia;\nbus_space_handle_t pioh, mmioh;\n{\n\tbus_space_unmap(ia->ia_memt, mmioh, TR_MMIO_SIZE);\n\tbus_space_unmap(ia->ia_iot, pioh, ia->ia_iosize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "memt",
            "mmioh",
            "TR_ACA_OFFSET + 1"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "memt",
            "mmioh",
            "TR_IRQ_OFFSET"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "memt",
            "mmioh",
            "TR_IRQ_OFFSET"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "piot",
            "pioh",
            "TR_SWITCH"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "memt",
            "mmioh",
            "TR_TYP_OFFSET"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "memt",
            "mmioh",
            "TR_ACA_OFFSET"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "memt",
            "mmioh",
            "TR_TYP_OFFSET"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr_isa_map_io",
          "args": [
            "ia",
            "&pioh",
            "&mmioh"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "tr_isa_map_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_tr_isa.c",
          "lines": "88-118",
          "snippet": "int\ntr_isa_map_io(ia, pioh, mmioh)\nstruct isa_attach_args *ia;\nbus_space_handle_t *pioh, *mmioh;\n{\n\tbus_size_t mmio;\n\tu_int8_t s;\n\n\tif (bus_space_map(ia->ia_iot, ia->ia_iobase, ia->ia_iosize, 0, pioh)) {\n\t\tprintf(\"tr_isa_map_io: can't map PIO ports\\n\");\n\t\treturn 1;\n\t}\n\n\t/* Read adapter switches and calculate addresses of MMIO. */\n\ts = bus_space_read_1(ia->ia_iot, *pioh, TR_SWITCH);\n\n\tif ((s & 0xfc) < ((TR_MMIO_MINADDR - TR_MMIO_OFFSET) >> 11) ||\n\t    (s & 0xfc) > ((TR_MMIO_MAXADDR - TR_MMIO_OFFSET) >> 11)) {\n\t\tbus_space_unmap(ia->ia_iot, *pioh, ia->ia_iosize);\n\t\treturn 1;\n\t}\n\n\tmmio = ((s & 0xfc) << 11) + TR_MMIO_OFFSET;\n\tif (bus_space_map(ia->ia_memt, mmio, TR_MMIO_SIZE, 0, mmioh)) {\n\t\tprintf(\"tr_isa_map_io: can't map MMIO region 0x%05lx/%d\\n\",\n\t\t\tmmio, TR_MMIO_SIZE);\n\t\tbus_space_unmap(ia->ia_iot, *pioh, ia->ia_iosize);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ttr_isa_map_io"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ttr_isa_map_io;\n\nint\ntr_isa_map_io(ia, pioh, mmioh)\nstruct isa_attach_args *ia;\nbus_space_handle_t *pioh, *mmioh;\n{\n\tbus_size_t mmio;\n\tu_int8_t s;\n\n\tif (bus_space_map(ia->ia_iot, ia->ia_iobase, ia->ia_iosize, 0, pioh)) {\n\t\tprintf(\"tr_isa_map_io: can't map PIO ports\\n\");\n\t\treturn 1;\n\t}\n\n\t/* Read adapter switches and calculate addresses of MMIO. */\n\ts = bus_space_read_1(ia->ia_iot, *pioh, TR_SWITCH);\n\n\tif ((s & 0xfc) < ((TR_MMIO_MINADDR - TR_MMIO_OFFSET) >> 11) ||\n\t    (s & 0xfc) > ((TR_MMIO_MAXADDR - TR_MMIO_OFFSET) >> 11)) {\n\t\tbus_space_unmap(ia->ia_iot, *pioh, ia->ia_iosize);\n\t\treturn 1;\n\t}\n\n\tmmio = ((s & 0xfc) << 11) + TR_MMIO_OFFSET;\n\tif (bus_space_map(ia->ia_memt, mmio, TR_MMIO_SIZE, 0, mmioh)) {\n\t\tprintf(\"tr_isa_map_io: can't map MMIO region 0x%05lx/%d\\n\",\n\t\t\tmmio, TR_MMIO_SIZE);\n\t\tbus_space_unmap(ia->ia_iot, *pioh, ia->ia_iosize);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ttribm_isa_probe;\nint\ttr_isa_map_io;\nvoid\ttr_isa_unmap_io;\n\nint\ntribm_isa_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tstatic int irq_f[4] = { 9, 3, 6, 7 };\n\tstatic int irq_e[4] = { 9, 3, 10, 11 };\n\tbus_space_tag_t piot = ia->ia_iot;\n\tbus_space_tag_t memt = ia->ia_memt;\n\tbus_space_handle_t pioh, mmioh;\n\tint i, irq;\n\tu_int8_t s;\n\n#ifdef notyet\n/* XXX Try both 0xa20 and 0xa24 and store that info like 3com */\n\tif (ia->ia_iobase == IOBASEUNK)\n\t\tia->ia_iobase = 0xa20;\n#else\n\tif (ia->ia_iobase == IOBASEUNK)\n\t\treturn 0;\n#endif\n\n\tia->ia_iosize = 4;\n\tia->ia_aux = NULL;\n\n\tif (tr_isa_map_io(ia, &pioh, &mmioh))\n\t\treturn 0;\n\n/*\n * F = Token-Ring Network PC Adapter\n *     Token-Ring Network PC Adapter II\n *     Token-Ring Network Adapter/A\n * E = Token-Ring Network 16/4 Adapter/A (long card)\n *     Token-Ring Network 16/4 Adapter\n * D = Token-Ring Network 16/4 Adapter/A (short card)\n *     16/4 ISA-16 Adapter\n * C = Auto 16/4 Token-Ring ISA Adapter\n *     Auto 16/4 Token-Ring MC Adapter\n */\n/*\n * XXX Both 0xD and 0xC types should be able to use 16-bit read and writes\n */\n\tswitch (bus_space_read_1(memt, mmioh, TR_TYP_OFFSET)) {\n\tcase 0xF:\n\tcase 0xE:\n\tcase 0xD:\n\t\tif (ia->ia_maddr == MADDRUNK)\n#ifdef notyet\n\t\t\tia->ia_maddr = TR_SRAM_DEFAULT;\n#else\n\t\t\treturn 0;\n#endif\n\t\tbreak;\n\tcase 0xC:\n\t\ti = bus_space_read_1(memt, mmioh, TR_ACA_OFFSET) << 12;\n\t\tif (ia->ia_maddr == MADDRUNK)\n\t\t\tia->ia_maddr = i;\n\t\telse if (ia->ia_maddr != i) {\n\t\t\tprintf(\n\"tribm_isa_probe: sram mismatch; kernel configured %x != board configured %x\\n\",\n\t\t\t\tia->ia_maddr, i);\n\t\t\ttr_isa_unmap_io(ia, pioh, mmioh);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"tribm_isa_probe: unknown type code %x\\n\",\n\t\t    bus_space_read_1(memt, mmioh, TR_TYP_OFFSET));\n\t\ttr_isa_unmap_io(ia, pioh, mmioh);\n\t\treturn 0;\n\t}\n\n\ts = bus_space_read_1(piot, pioh, TR_SWITCH);\n\n\tswitch (bus_space_read_1(memt, mmioh, TR_IRQ_OFFSET)) {\n\tcase 0xF:\n\t\tirq = irq_f[s & 3];\n\t\tbreak;\n\tcase 0xE:\n\t\tirq = irq_e[s & 3];\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"tribm_isa_probe: Unknown IRQ code %x\\n\",\n\t\t    bus_space_read_1(memt, mmioh, TR_IRQ_OFFSET));\n\t\ttr_isa_unmap_io(ia, pioh, mmioh);\n\t\treturn 0;\n\t}\n\n\tif (ia->ia_irq == IRQUNK)\n\t\tia->ia_irq = irq;\n\telse if (ia->ia_irq != irq) {\n\t\tprintf(\n\"tribm_isa_probe: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\tia->ia_irq, irq);\n\t\ttr_isa_unmap_io(ia, pioh, mmioh);\n\t\treturn 0;\n\t}\n/*\n * XXX 0x0c == MSIZEMASK (MSIZEBITS)\n */\n\tia->ia_msize = 8192 <<\n\t    ((bus_space_read_1(memt, mmioh, TR_ACA_OFFSET + 1) & 0x0c) >> 2);\n\ttr_isa_unmap_io(ia, pioh, mmioh);\n\t/* Check alignment of membase. */\n\tif ((ia->ia_maddr & (ia->ia_msize-1)) != 0) {\n\t\tprintf(\"tribm_isa_probe: SRAM unaligned 0x%04x/%d\\n\",\n\t\t    ia->ia_maddr, ia->ia_msize);\n\t\treturn 0;\n\t}\n \treturn 1;\n}"
  }
]