[
  {
    "function_name": "randomioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
    "lines": "1037-1091",
    "snippet": "int\nrandomioctl(dev, cmd, data, flag, p)\n\tdev_t\tdev;\n\tu_long\tcmd;\n\tcaddr_t\tdata;\n\tint\tflag;\n\tstruct proc *p;\n{\n\tint\tret = 0;\n\tu_int\tcnt;\n\n\tadd_timer_randomness((u_long)p ^ (u_long)data ^ cmd);\n\n\tswitch (cmd) {\n\tcase RNDGETENTCNT:\n\t\tret = copyout(&random_state.entropy_count, data,\n\t\t    sizeof(random_state.entropy_count));\n\t\tbreak;\n\tcase RNDADDTOENTCNT:\n\t\tif (suser(p->p_ucred, &p->p_acflag) != 0)\n\t\t\tret = EPERM;\n\t\telse {\n\t\t\tcopyin(&cnt, data, sizeof(cnt));\n\t\t\trandom_state.entropy_count += cnt;\n\t\t\tif (random_state.entropy_count > POOLBITS)\n\t\t\t\trandom_state.entropy_count = POOLBITS;\n\t\t}\n\t\tbreak;\n\tcase RNDZAPENTCNT:\n\t\tif (suser(p->p_ucred, &p->p_acflag) != 0)\n\t\t\tret = EPERM;\n\t\telse\n\t\t\trandom_state.entropy_count = 0;\n\t\tbreak;\n\tcase RNDSTIRARC4:\n\t\tif (suser(p->p_ucred, &p->p_acflag) != 0)\n\t\t\tret = EPERM;\n\t\telse if (random_state.entropy_count < 64)\n\t\t\tret = EAGAIN;\n\t\telse\n\t\t\tarc4random_initialized = 0;\n\t\tbreak;\n\tcase RNDCLRSTATS:\n\t\tif (suser(p->p_ucred, &p->p_acflag) != 0)\n\t\t\tret = EPERM;\n\t\telse\n\t\t\tbzero(&rndstats, sizeof(rndstats));\n\t\tbreak;\n\tdefault:\n\t\tret = EINVAL;\n\t}\n\n\tadd_timer_randomness((u_long)p ^ (u_long)data ^ cmd);\n\treturn ret;\n}",
    "includes": [
      "#include <dev/rndioctl.h>",
      "#include <dev/rndvar.h>",
      "#include <sys/timeout.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/md5k.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/disk.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define POOLBITS (POOLWORDS*32)"
    ],
    "globals_used": [
      "struct random_bucket random_state;",
      "int arc4random_initialized;",
      "struct rndstats rndstats;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_timer_randomness",
          "args": [
            "(u_long)p ^ (u_long)data ^ cmd"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&rndstats",
            "sizeof(rndstats)"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suser",
          "args": [
            "p->p_ucred",
            "&p->p_acflag"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suser",
          "args": [
            "p->p_ucred",
            "&p->p_acflag"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suser",
          "args": [
            "p->p_ucred",
            "&p->p_acflag"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyin",
          "args": [
            "&cnt",
            "data",
            "sizeof(cnt)"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suser",
          "args": [
            "p->p_ucred",
            "&p->p_acflag"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyout",
          "args": [
            "&random_state.entropy_count",
            "data",
            "sizeof(random_state.entropy_count)"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "audio_silence_copyout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1249-1268",
          "snippet": "int\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_timer_randomness",
          "args": [
            "(u_long)p ^ (u_long)data ^ cmd"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define POOLBITS (POOLWORDS*32)\n\nstruct random_bucket random_state;\nint arc4random_initialized;\nstruct rndstats rndstats;\n\nint\nrandomioctl(dev, cmd, data, flag, p)\n\tdev_t\tdev;\n\tu_long\tcmd;\n\tcaddr_t\tdata;\n\tint\tflag;\n\tstruct proc *p;\n{\n\tint\tret = 0;\n\tu_int\tcnt;\n\n\tadd_timer_randomness((u_long)p ^ (u_long)data ^ cmd);\n\n\tswitch (cmd) {\n\tcase RNDGETENTCNT:\n\t\tret = copyout(&random_state.entropy_count, data,\n\t\t    sizeof(random_state.entropy_count));\n\t\tbreak;\n\tcase RNDADDTOENTCNT:\n\t\tif (suser(p->p_ucred, &p->p_acflag) != 0)\n\t\t\tret = EPERM;\n\t\telse {\n\t\t\tcopyin(&cnt, data, sizeof(cnt));\n\t\t\trandom_state.entropy_count += cnt;\n\t\t\tif (random_state.entropy_count > POOLBITS)\n\t\t\t\trandom_state.entropy_count = POOLBITS;\n\t\t}\n\t\tbreak;\n\tcase RNDZAPENTCNT:\n\t\tif (suser(p->p_ucred, &p->p_acflag) != 0)\n\t\t\tret = EPERM;\n\t\telse\n\t\t\trandom_state.entropy_count = 0;\n\t\tbreak;\n\tcase RNDSTIRARC4:\n\t\tif (suser(p->p_ucred, &p->p_acflag) != 0)\n\t\t\tret = EPERM;\n\t\telse if (random_state.entropy_count < 64)\n\t\t\tret = EAGAIN;\n\t\telse\n\t\t\tarc4random_initialized = 0;\n\t\tbreak;\n\tcase RNDCLRSTATS:\n\t\tif (suser(p->p_ucred, &p->p_acflag) != 0)\n\t\t\tret = EPERM;\n\t\telse\n\t\t\tbzero(&rndstats, sizeof(rndstats));\n\t\tbreak;\n\tdefault:\n\t\tret = EINVAL;\n\t}\n\n\tadd_timer_randomness((u_long)p ^ (u_long)data ^ cmd);\n\treturn ret;\n}"
  },
  {
    "function_name": "randomwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
    "lines": "1005-1035",
    "snippet": "int\nrandomwrite(dev, uio, flags)\n\tdev_t\tdev;\n\tstruct uio *uio;\n\tint\tflags;\n{\n\tint\tret = 0;\n\n\tif (minor(dev) == RND_RND || minor(dev) == RND_PRND)\n\t\treturn ENXIO;\n\n\tif (uio->uio_resid == 0)\n\t\treturn 0;\n\n\twhile (!ret && uio->uio_resid > 0) {\n\t\tu_int32_t\tbuf[ POOLWORDS ];\n\t\tu_short\t\tn = min(sizeof(buf),uio->uio_resid);\n\n\t\tret = uiomove((caddr_t)buf, n, uio);\n\t\tif (!ret) {\n\t\t\twhile (n % sizeof(u_int32_t))\n\t\t\t\t((u_int8_t *) buf)[n++] = 0;\n\t\t\tadd_entropy_words(buf, n / 4);\n\t\t}\n\t}\n\n\tif (minor(dev) == RND_ARND && !ret)\n\t\tarc4random_initialized = 0;\n\n\treturn ret;\n}",
    "includes": [
      "#include <dev/rndioctl.h>",
      "#include <dev/rndvar.h>",
      "#include <sys/timeout.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/md5k.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/disk.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int arc4random_initialized;",
      "static __inline void add_entropy_words",
      "__P((register u_int8_t *, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_entropy_words",
          "args": [
            "buf",
            "n / 4"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "add_entropy_words",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
          "lines": "602-639",
          "snippet": "static __inline void\nadd_entropy_words(buf, n)\n\tconst u_int32_t *buf;\n\tu_int n;\n{\n\tstatic const u_int32_t twist_table[8] = {\n\t\t0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,\n\t\t0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278\n\t};\n\tu_int i;\n\tint new_rotate;\n\tu_int32_t w;\n\n\twhile (n--) {\n\t\tw = roll(*buf, random_state.input_rotate);\n\t\ti = random_state.add_ptr =\n\t\t    (random_state.add_ptr - 1) & (POOLWORDS - 1);\n\t\t/*\n\t\t * Normally, we add 7 bits of rotation to the pool.\n\t\t * At the beginning of the pool, add an extra 7 bits\n\t\t * rotation, so that successive passes spread the\n\t\t * input bits across the pool evenly.\n\t\t */\n\t\tnew_rotate = random_state.input_rotate + 14;\n\t\tif (i)\n\t\t\tnew_rotate = random_state.input_rotate + 7;\n\t\trandom_state.input_rotate = new_rotate & 31;\n\n\t\t/* XOR in the various taps */\n\t\tw ^= random_state.pool[(i+TAP1)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP2)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP3)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP4)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP5)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[i];\n\t\trandom_state.pool[i] = (w >> 3) ^ twist_table[w & 7];\n\t}\n}",
          "includes": [
            "#include <dev/rndioctl.h>",
            "#include <dev/rndvar.h>",
            "#include <sys/timeout.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/md5k.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/disk.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tTAP5\t1",
            "#define\tTAP4\t7",
            "#define\tTAP3\t14",
            "#define\tTAP2\t20",
            "#define\tTAP1\t26",
            "#define\tTAP5\t1",
            "#define\tTAP4\t14",
            "#define\tTAP3\t26",
            "#define\tTAP2\t39",
            "#define\tTAP1\t52",
            "#define\tTAP5\t1",
            "#define\tTAP4\t25",
            "#define\tTAP3\t51",
            "#define\tTAP2\t76",
            "#define\tTAP1\t103",
            "#define\tTAP5\t1",
            "#define\tTAP4\t52",
            "#define\tTAP3\t101",
            "#define\tTAP2\t155",
            "#define\tTAP1\t205",
            "#define\tTAP5\t1",
            "#define\tTAP4\t104",
            "#define\tTAP3\t208",
            "#define\tTAP2\t308",
            "#define\tTAP1\t411",
            "#define\tTAP5\t1",
            "#define\tTAP4\t204",
            "#define\tTAP3\t412",
            "#define\tTAP2\t615",
            "#define\tTAP1\t817",
            "#define\tTAP5\t1",
            "#define\tTAP4\t411",
            "#define\tTAP3\t819",
            "#define\tTAP2\t1231",
            "#define\tTAP1\t1638"
          ],
          "globals_used": [
            "struct random_bucket random_state;",
            "static __inline void add_entropy_words"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTAP5\t1\n#define\tTAP4\t7\n#define\tTAP3\t14\n#define\tTAP2\t20\n#define\tTAP1\t26\n#define\tTAP5\t1\n#define\tTAP4\t14\n#define\tTAP3\t26\n#define\tTAP2\t39\n#define\tTAP1\t52\n#define\tTAP5\t1\n#define\tTAP4\t25\n#define\tTAP3\t51\n#define\tTAP2\t76\n#define\tTAP1\t103\n#define\tTAP5\t1\n#define\tTAP4\t52\n#define\tTAP3\t101\n#define\tTAP2\t155\n#define\tTAP1\t205\n#define\tTAP5\t1\n#define\tTAP4\t104\n#define\tTAP3\t208\n#define\tTAP2\t308\n#define\tTAP1\t411\n#define\tTAP5\t1\n#define\tTAP4\t204\n#define\tTAP3\t412\n#define\tTAP2\t615\n#define\tTAP1\t817\n#define\tTAP5\t1\n#define\tTAP4\t411\n#define\tTAP3\t819\n#define\tTAP2\t1231\n#define\tTAP1\t1638\n\nstruct random_bucket random_state;\nstatic __inline void add_entropy_words;\n\nstatic __inline void\nadd_entropy_words(buf, n)\n\tconst u_int32_t *buf;\n\tu_int n;\n{\n\tstatic const u_int32_t twist_table[8] = {\n\t\t0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,\n\t\t0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278\n\t};\n\tu_int i;\n\tint new_rotate;\n\tu_int32_t w;\n\n\twhile (n--) {\n\t\tw = roll(*buf, random_state.input_rotate);\n\t\ti = random_state.add_ptr =\n\t\t    (random_state.add_ptr - 1) & (POOLWORDS - 1);\n\t\t/*\n\t\t * Normally, we add 7 bits of rotation to the pool.\n\t\t * At the beginning of the pool, add an extra 7 bits\n\t\t * rotation, so that successive passes spread the\n\t\t * input bits across the pool evenly.\n\t\t */\n\t\tnew_rotate = random_state.input_rotate + 14;\n\t\tif (i)\n\t\t\tnew_rotate = random_state.input_rotate + 7;\n\t\trandom_state.input_rotate = new_rotate & 31;\n\n\t\t/* XOR in the various taps */\n\t\tw ^= random_state.pool[(i+TAP1)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP2)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP3)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP4)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP5)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[i];\n\t\trandom_state.pool[i] = (w >> 3) ^ twist_table[w & 7];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "(caddr_t)buf",
            "n",
            "uio"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "sizeof(buf)",
            "uio->uio_resid"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "seq_do_timing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sequencer.c",
          "lines": "804-819",
          "snippet": "int\nseq_do_timing(sc, b)\n\tstruct sequencer_softc *sc;\n\tseq_event_rec *b;\n{\n\tunion {\n\t\tint32_t i;\n\t\tu_int8_t b[4];\n\t} u;\n\n\tu.b[0] = b->arr[4];\n\tu.b[1] = b->arr[5];\n\tu.b[2] = b->arr[6];\n\tu.b[3] = b->arr[7];\n\treturn (seq_timer(sc, SEQ_TCMD(b), u.i, b));\n}",
          "includes": [
            "#include \"midi.h\"",
            "#include <dev/sequencervar.h>",
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"midi.h\"\n#include <dev/sequencervar.h>\n#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n\nint\nseq_do_timing(sc, b)\n\tstruct sequencer_softc *sc;\n\tseq_event_rec *b;\n{\n\tunion {\n\t\tint32_t i;\n\t\tu_int8_t b[4];\n\t} u;\n\n\tu.b[0] = b->arr[4];\n\tu.b[1] = b->arr[5];\n\tu.b[2] = b->arr[6];\n\tu.b[3] = b->arr[7];\n\treturn (seq_timer(sc, SEQ_TCMD(b), u.i, b));\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint arc4random_initialized;\nstatic __inline void add_entropy_words;\n__P((register u_int8_t *, int));\n\nint\nrandomwrite(dev, uio, flags)\n\tdev_t\tdev;\n\tstruct uio *uio;\n\tint\tflags;\n{\n\tint\tret = 0;\n\n\tif (minor(dev) == RND_RND || minor(dev) == RND_PRND)\n\t\treturn ENXIO;\n\n\tif (uio->uio_resid == 0)\n\t\treturn 0;\n\n\twhile (!ret && uio->uio_resid > 0) {\n\t\tu_int32_t\tbuf[ POOLWORDS ];\n\t\tu_short\t\tn = min(sizeof(buf),uio->uio_resid);\n\n\t\tret = uiomove((caddr_t)buf, n, uio);\n\t\tif (!ret) {\n\t\t\twhile (n % sizeof(u_int32_t))\n\t\t\t\t((u_int8_t *) buf)[n++] = 0;\n\t\t\tadd_entropy_words(buf, n / 4);\n\t\t}\n\t}\n\n\tif (minor(dev) == RND_ARND && !ret)\n\t\tarc4random_initialized = 0;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "randomselect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
    "lines": "990-1003",
    "snippet": "int\nrandomselect(dev, rw, p)\n\tdev_t\tdev;\n\tint\trw;\n\tstruct proc *p;\n{\n\tswitch (rw) {\n\tcase FREAD:\n\t\treturn random_state.entropy_count > 0;\n\tcase FWRITE:\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <dev/rndioctl.h>",
      "#include <dev/rndvar.h>",
      "#include <sys/timeout.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/md5k.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/disk.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct random_bucket random_state;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct random_bucket random_state;\n\nint\nrandomselect(dev, rw, p)\n\tdev_t\tdev;\n\tint\trw;\n\tstruct proc *p;\n{\n\tswitch (rw) {\n\tcase FREAD:\n\t\treturn random_state.entropy_count > 0;\n\tcase FWRITE:\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "randomread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
    "lines": "910-988",
    "snippet": "int\nrandomread(dev, uio, ioflag)\n\tdev_t\tdev;\n\tstruct uio *uio;\n\tint\tioflag;\n{\n\tint\tret = 0;\n\tint\ts, i;\n\n\tif (uio->uio_resid == 0)\n\t\treturn 0;\n\n\twhile (!ret && uio->uio_resid > 0) {\n\t\tu_int32_t buf[ POOLWORDS ];\n\t\tint\tn = min(sizeof(buf), uio->uio_resid);\n\n\t\ts = splhigh();\n\t\tswitch(minor(dev)) {\n\t\tcase RND_RND:\n\t\t\tret = EIO;\t/* no chip -- error */\n\t\t\tbreak;\n\t\tcase RND_SRND:\n\t\t\tif (random_state.entropy_count < 16 * 8) {\n\t\t\t\tif (ioflag & IO_NDELAY) {\n\t\t\t\t\tret = EWOULDBLOCK;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#ifdef\tRNDEBUG\n\t\t\t\tif (rnd_debug & RD_WAIT)\n\t\t\t\t\tprintf(\"rnd: sleep[%u]\\n\",\n\t\t\t\t\t    random_state.asleep);\n#endif\n\t\t\t\trandom_state.asleep++;\n\t\t\t\trndstats.rnd_waits++;\n\t\t\t\tret = tsleep(&random_state.asleep,\n\t\t\t\t    PWAIT | PCATCH, \"rndrd\", 0);\n#ifdef\tRNDEBUG\n\t\t\t\tif (rnd_debug & RD_WAIT)\n\t\t\t\t\tprintf(\"rnd: awakened(%d)\\n\", ret);\n#endif\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n > random_state.entropy_count / 8)\n\t\t\t\tn = random_state.entropy_count / 8;\n\t\t\trndstats.rnd_reads++;\n#ifdef\tRNDEBUG\n\t\t\tif (rnd_debug & RD_OUTPUT)\n\t\t\t\tprintf(\"rnd: %u possible output\\n\", n);\n#endif\n\t\tcase RND_URND:\n\t\t\tget_random_bytes((char *)buf, n);\n#ifdef\tRNDEBUG\n\t\t\tif (rnd_debug & RD_OUTPUT)\n\t\t\t\tprintf(\"rnd: %u bytes for output\\n\", n);\n#endif\n\t\t\tbreak;\n\t\tcase RND_PRND:\n\t\t\ti = (n + 3) / 4;\n\t\t\twhile (i--)\n\t\t\t\tbuf[i] = random() << 16 | (random() & 0xFFFF);\n\t\t\tbreak;\n\t\tcase RND_ARND:\n\t\t{\n\t\t\tu_int8_t *cp = (u_int8_t *) buf;\n\t\t\tu_int8_t *end = cp + n;\n\t\t\twhile (cp < end)\n\t\t\t\t*cp++ = arc4random_8();\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tret = ENXIO;\n\t\t}\n\t\tsplx(s);\n\t\tif (n != 0 && ret == 0)\n\t\t\tret = uiomove((caddr_t)buf, n, uio);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <dev/rndioctl.h>",
      "#include <dev/rndvar.h>",
      "#include <sys/timeout.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/md5k.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/disk.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tRD_WAIT\t\t0x0100\t/* sleep/wakeup for good data */",
      "#define\tRD_OUTPUT\t0x00f0\t/* output data */"
    ],
    "globals_used": [
      "struct random_bucket random_state;",
      "struct rndstats rndstats;",
      "__P((register u_int8_t *, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "(caddr_t)buf",
            "n",
            "uio"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arc4random_8",
          "args": [],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random_8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
          "lines": "519-524",
          "snippet": "int\narc4random_8(void)\n{\n\tarc4maybeinit();\n\treturn arc4_getbyte();\n}",
          "includes": [
            "#include <dev/rndioctl.h>",
            "#include <dev/rndvar.h>",
            "#include <sys/timeout.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/md5k.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/disk.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline u_int8_t arc4_getbyte"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline u_int8_t arc4_getbyte;\n\nint\narc4random_8(void)\n{\n\tarc4maybeinit();\n\treturn arc4_getbyte();\n}"
        }
      },
      {
        "call_info": {
          "callee": "random",
          "args": [],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "randomattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
          "lines": "534-566",
          "snippet": "void\nrandomattach(void)\n{\n\tint i;\n\tstruct timeval tv;\n\tstruct rand_event *rep;\n\n\tif (rnd_attached) {\n#ifdef RNDEBUG\n\t\tprintf(\"random: second attach\\n\");\n#endif\n\t\treturn;\n\t}\n\n\trandom_state.add_ptr = 0;\n\trandom_state.entropy_count = 0;\n\trnd_states[RND_SRC_TIMER].dont_count_entropy = 1;\n\trnd_states[RND_SRC_TRUE].dont_count_entropy = 1;\n\trnd_states[RND_SRC_TRUE].max_entropy = 1;\n\n\tbzero(&rndstats, sizeof(rndstats));\n\tbzero(&rnd_event_space, sizeof(rnd_event_space));\n\trnd_event_free = rnd_event_space;\n\tfor (rep = rnd_event_space; rep < &rnd_event_space[QEVLEN-1]; rep++)\n\t\trep->re_next = rep + 1;\n\tfor (i = 0; i < 256; i++)\n\t\tarc4random_state.s[i] = i;\n\tmicrotime(&tv);\n\ttimeout_set(&rnd_timeout, dequeue_randomness, NULL);\n\ttimeout_set(&arc4_timeout, arc4_reinit, NULL);\n\tarc4_reinit(NULL);\n\trnd_attached = 1;\n}",
          "includes": [
            "#include <dev/rndioctl.h>",
            "#include <dev/rndvar.h>",
            "#include <sys/timeout.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/md5k.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/disk.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define QEVLEN 96"
          ],
          "globals_used": [
            "struct timeout rnd_timeout, arc4_timeout;",
            "struct random_bucket random_state;",
            "struct arc4_stream arc4random_state;",
            "struct timer_rand_state rnd_states[RND_SRC_NUM];",
            "struct rand_event rnd_event_space[QEVLEN];",
            "struct rand_event *rnd_event_free;",
            "int rnd_attached;",
            "struct rndstats rndstats;",
            "void dequeue_randomness",
            "void arc4_reinit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define QEVLEN 96\n\nstruct timeout rnd_timeout, arc4_timeout;\nstruct random_bucket random_state;\nstruct arc4_stream arc4random_state;\nstruct timer_rand_state rnd_states[RND_SRC_NUM];\nstruct rand_event rnd_event_space[QEVLEN];\nstruct rand_event *rnd_event_free;\nint rnd_attached;\nstruct rndstats rndstats;\nvoid dequeue_randomness;\nvoid arc4_reinit;\n\nvoid\nrandomattach(void)\n{\n\tint i;\n\tstruct timeval tv;\n\tstruct rand_event *rep;\n\n\tif (rnd_attached) {\n#ifdef RNDEBUG\n\t\tprintf(\"random: second attach\\n\");\n#endif\n\t\treturn;\n\t}\n\n\trandom_state.add_ptr = 0;\n\trandom_state.entropy_count = 0;\n\trnd_states[RND_SRC_TIMER].dont_count_entropy = 1;\n\trnd_states[RND_SRC_TRUE].dont_count_entropy = 1;\n\trnd_states[RND_SRC_TRUE].max_entropy = 1;\n\n\tbzero(&rndstats, sizeof(rndstats));\n\tbzero(&rnd_event_space, sizeof(rnd_event_space));\n\trnd_event_free = rnd_event_space;\n\tfor (rep = rnd_event_space; rep < &rnd_event_space[QEVLEN-1]; rep++)\n\t\trep->re_next = rep + 1;\n\tfor (i = 0; i < 256; i++)\n\t\tarc4random_state.s[i] = i;\n\tmicrotime(&tv);\n\ttimeout_set(&rnd_timeout, dequeue_randomness, NULL);\n\ttimeout_set(&arc4_timeout, arc4_reinit, NULL);\n\tarc4_reinit(NULL);\n\trnd_attached = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"rnd: %u bytes for output\\n\"",
            "n"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "(char *)buf",
            "n"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "get_random_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
          "lines": "901-908",
          "snippet": "void\nget_random_bytes(buf, nbytes)\n\tvoid\t*buf;\n\tsize_t\tnbytes;\n{\n\textract_entropy((u_int8_t *) buf, nbytes);\n\trndstats.rnd_used += nbytes * 8;\n}",
          "includes": [
            "#include <dev/rndioctl.h>",
            "#include <dev/rndvar.h>",
            "#include <sys/timeout.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/md5k.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/disk.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rndstats rndstats;",
            "static __inline void extract_entropy",
            "__P((register u_int8_t *, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct rndstats rndstats;\nstatic __inline void extract_entropy;\n__P((register u_int8_t *, int));\n\nvoid\nget_random_bytes(buf, nbytes)\n\tvoid\t*buf;\n\tsize_t\tnbytes;\n{\n\textract_entropy((u_int8_t *) buf, nbytes);\n\trndstats.rnd_used += nbytes * 8;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "&random_state.asleep",
            "PWAIT | PCATCH",
            "\"rndrd\"",
            "0"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "sizeof(buf)",
            "uio->uio_resid"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "seq_do_timing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sequencer.c",
          "lines": "804-819",
          "snippet": "int\nseq_do_timing(sc, b)\n\tstruct sequencer_softc *sc;\n\tseq_event_rec *b;\n{\n\tunion {\n\t\tint32_t i;\n\t\tu_int8_t b[4];\n\t} u;\n\n\tu.b[0] = b->arr[4];\n\tu.b[1] = b->arr[5];\n\tu.b[2] = b->arr[6];\n\tu.b[3] = b->arr[7];\n\treturn (seq_timer(sc, SEQ_TCMD(b), u.i, b));\n}",
          "includes": [
            "#include \"midi.h\"",
            "#include <dev/sequencervar.h>",
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"midi.h\"\n#include <dev/sequencervar.h>\n#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n\nint\nseq_do_timing(sc, b)\n\tstruct sequencer_softc *sc;\n\tseq_event_rec *b;\n{\n\tunion {\n\t\tint32_t i;\n\t\tu_int8_t b[4];\n\t} u;\n\n\tu.b[0] = b->arr[4];\n\tu.b[1] = b->arr[5];\n\tu.b[2] = b->arr[6];\n\tu.b[3] = b->arr[7];\n\treturn (seq_timer(sc, SEQ_TCMD(b), u.i, b));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tRD_WAIT\t\t0x0100\t/* sleep/wakeup for good data */\n#define\tRD_OUTPUT\t0x00f0\t/* output data */\n\nstruct random_bucket random_state;\nstruct rndstats rndstats;\n__P((register u_int8_t *, int));\n\nint\nrandomread(dev, uio, ioflag)\n\tdev_t\tdev;\n\tstruct uio *uio;\n\tint\tioflag;\n{\n\tint\tret = 0;\n\tint\ts, i;\n\n\tif (uio->uio_resid == 0)\n\t\treturn 0;\n\n\twhile (!ret && uio->uio_resid > 0) {\n\t\tu_int32_t buf[ POOLWORDS ];\n\t\tint\tn = min(sizeof(buf), uio->uio_resid);\n\n\t\ts = splhigh();\n\t\tswitch(minor(dev)) {\n\t\tcase RND_RND:\n\t\t\tret = EIO;\t/* no chip -- error */\n\t\t\tbreak;\n\t\tcase RND_SRND:\n\t\t\tif (random_state.entropy_count < 16 * 8) {\n\t\t\t\tif (ioflag & IO_NDELAY) {\n\t\t\t\t\tret = EWOULDBLOCK;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#ifdef\tRNDEBUG\n\t\t\t\tif (rnd_debug & RD_WAIT)\n\t\t\t\t\tprintf(\"rnd: sleep[%u]\\n\",\n\t\t\t\t\t    random_state.asleep);\n#endif\n\t\t\t\trandom_state.asleep++;\n\t\t\t\trndstats.rnd_waits++;\n\t\t\t\tret = tsleep(&random_state.asleep,\n\t\t\t\t    PWAIT | PCATCH, \"rndrd\", 0);\n#ifdef\tRNDEBUG\n\t\t\t\tif (rnd_debug & RD_WAIT)\n\t\t\t\t\tprintf(\"rnd: awakened(%d)\\n\", ret);\n#endif\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n > random_state.entropy_count / 8)\n\t\t\t\tn = random_state.entropy_count / 8;\n\t\t\trndstats.rnd_reads++;\n#ifdef\tRNDEBUG\n\t\t\tif (rnd_debug & RD_OUTPUT)\n\t\t\t\tprintf(\"rnd: %u possible output\\n\", n);\n#endif\n\t\tcase RND_URND:\n\t\t\tget_random_bytes((char *)buf, n);\n#ifdef\tRNDEBUG\n\t\t\tif (rnd_debug & RD_OUTPUT)\n\t\t\t\tprintf(\"rnd: %u bytes for output\\n\", n);\n#endif\n\t\t\tbreak;\n\t\tcase RND_PRND:\n\t\t\ti = (n + 3) / 4;\n\t\t\twhile (i--)\n\t\t\t\tbuf[i] = random() << 16 | (random() & 0xFFFF);\n\t\t\tbreak;\n\t\tcase RND_ARND:\n\t\t{\n\t\t\tu_int8_t *cp = (u_int8_t *) buf;\n\t\t\tu_int8_t *end = cp + n;\n\t\t\twhile (cp < end)\n\t\t\t\t*cp++ = arc4random_8();\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tret = ENXIO;\n\t\t}\n\t\tsplx(s);\n\t\tif (n != 0 && ret == 0)\n\t\t\tret = uiomove((caddr_t)buf, n, uio);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "get_random_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
    "lines": "901-908",
    "snippet": "void\nget_random_bytes(buf, nbytes)\n\tvoid\t*buf;\n\tsize_t\tnbytes;\n{\n\textract_entropy((u_int8_t *) buf, nbytes);\n\trndstats.rnd_used += nbytes * 8;\n}",
    "includes": [
      "#include <dev/rndioctl.h>",
      "#include <dev/rndvar.h>",
      "#include <sys/timeout.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/md5k.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/disk.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rndstats rndstats;",
      "static __inline void extract_entropy",
      "__P((register u_int8_t *, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "extract_entropy",
          "args": [
            "(u_int8_t *) buf",
            "nbytes"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "extract_entropy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
          "lines": "833-894",
          "snippet": "static __inline void\nextract_entropy(buf, nbytes)\n\tregister u_int8_t *buf;\n\tint\tnbytes;\n{\n\tMD5_CTX tmp;\n\tu_char buffer[16];\n\n\tadd_timer_randomness(nbytes);\n\n\t/* Redundant, but just in case... */\n\tif (random_state.entropy_count > POOLBITS)\n\t\trandom_state.entropy_count = POOLBITS;\n\n\tif (random_state.entropy_count / 8 > nbytes)\n\t\trandom_state.entropy_count -= nbytes*8;\n\telse\n\t\trandom_state.entropy_count = 0;\n\n\twhile (nbytes) {\n\t\tregister u_char *p = buf;\n\t\tregister int i = sizeof(buffer);\n\n\t\tif (i > nbytes) {\n\t\t\ti = nbytes;\n\t\t\tp = buffer;\n\t\t}\n\n\t\t/* Hash the pool to get the output */\n\t\tMD5Init(&tmp);\n\t\tMD5Update(&tmp, (u_int8_t*)random_state.pool,\n\t\t    sizeof(random_state.pool));\n\t\tMD5Final(p, &tmp);\n\n\t\t/*\n\t\t * In case the hash function has some recognizable\n\t\t * output pattern, we fold it in half.\n\t\t */\n\t\tp[0] ^= p[15];\n\t\tp[1] ^= p[14];\n\t\tp[2] ^= p[13];\n\t\tp[3] ^= p[12];\n\t\tp[4] ^= p[11];\n\t\tp[5] ^= p[10];\n\t\tp[6] ^= p[ 9];\n\t\tp[7] ^= p[ 8];\n\n\t\t/* Modify pool so next hash will produce different results */\n\t\tadd_entropy_words((u_int32_t*)p, sizeof(buffer)/4);\n\n\t\t/* Copy data to destination buffer */\n\t\tif (i < sizeof(buffer))\n\t\t\tbcopy(buffer, buf, i);\n\t\tnbytes -= i;\n\t\tbuf += i;\n\t\tadd_timer_randomness(nbytes);\n\t}\n\n\t/* Wipe data from memory */\n\tbzero(&tmp, sizeof(tmp));\n\tbzero(&buffer, sizeof(buffer));\n}",
          "includes": [
            "#include <dev/rndioctl.h>",
            "#include <dev/rndvar.h>",
            "#include <sys/timeout.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/md5k.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/disk.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define POOLBITS (POOLWORDS*32)"
          ],
          "globals_used": [
            "struct random_bucket random_state;",
            "static __inline void add_entropy_words",
            "static __inline void extract_entropy",
            "__P((register u_int8_t *, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define POOLBITS (POOLWORDS*32)\n\nstruct random_bucket random_state;\nstatic __inline void add_entropy_words;\nstatic __inline void extract_entropy;\n__P((register u_int8_t *, int));\n\nstatic __inline void\nextract_entropy(buf, nbytes)\n\tregister u_int8_t *buf;\n\tint\tnbytes;\n{\n\tMD5_CTX tmp;\n\tu_char buffer[16];\n\n\tadd_timer_randomness(nbytes);\n\n\t/* Redundant, but just in case... */\n\tif (random_state.entropy_count > POOLBITS)\n\t\trandom_state.entropy_count = POOLBITS;\n\n\tif (random_state.entropy_count / 8 > nbytes)\n\t\trandom_state.entropy_count -= nbytes*8;\n\telse\n\t\trandom_state.entropy_count = 0;\n\n\twhile (nbytes) {\n\t\tregister u_char *p = buf;\n\t\tregister int i = sizeof(buffer);\n\n\t\tif (i > nbytes) {\n\t\t\ti = nbytes;\n\t\t\tp = buffer;\n\t\t}\n\n\t\t/* Hash the pool to get the output */\n\t\tMD5Init(&tmp);\n\t\tMD5Update(&tmp, (u_int8_t*)random_state.pool,\n\t\t    sizeof(random_state.pool));\n\t\tMD5Final(p, &tmp);\n\n\t\t/*\n\t\t * In case the hash function has some recognizable\n\t\t * output pattern, we fold it in half.\n\t\t */\n\t\tp[0] ^= p[15];\n\t\tp[1] ^= p[14];\n\t\tp[2] ^= p[13];\n\t\tp[3] ^= p[12];\n\t\tp[4] ^= p[11];\n\t\tp[5] ^= p[10];\n\t\tp[6] ^= p[ 9];\n\t\tp[7] ^= p[ 8];\n\n\t\t/* Modify pool so next hash will produce different results */\n\t\tadd_entropy_words((u_int32_t*)p, sizeof(buffer)/4);\n\n\t\t/* Copy data to destination buffer */\n\t\tif (i < sizeof(buffer))\n\t\t\tbcopy(buffer, buf, i);\n\t\tnbytes -= i;\n\t\tbuf += i;\n\t\tadd_timer_randomness(nbytes);\n\t}\n\n\t/* Wipe data from memory */\n\tbzero(&tmp, sizeof(tmp));\n\tbzero(&buffer, sizeof(buffer));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct rndstats rndstats;\nstatic __inline void extract_entropy;\n__P((register u_int8_t *, int));\n\nvoid\nget_random_bytes(buf, nbytes)\n\tvoid\t*buf;\n\tsize_t\tnbytes;\n{\n\textract_entropy((u_int8_t *) buf, nbytes);\n\trndstats.rnd_used += nbytes * 8;\n}"
  },
  {
    "function_name": "extract_entropy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
    "lines": "833-894",
    "snippet": "static __inline void\nextract_entropy(buf, nbytes)\n\tregister u_int8_t *buf;\n\tint\tnbytes;\n{\n\tMD5_CTX tmp;\n\tu_char buffer[16];\n\n\tadd_timer_randomness(nbytes);\n\n\t/* Redundant, but just in case... */\n\tif (random_state.entropy_count > POOLBITS)\n\t\trandom_state.entropy_count = POOLBITS;\n\n\tif (random_state.entropy_count / 8 > nbytes)\n\t\trandom_state.entropy_count -= nbytes*8;\n\telse\n\t\trandom_state.entropy_count = 0;\n\n\twhile (nbytes) {\n\t\tregister u_char *p = buf;\n\t\tregister int i = sizeof(buffer);\n\n\t\tif (i > nbytes) {\n\t\t\ti = nbytes;\n\t\t\tp = buffer;\n\t\t}\n\n\t\t/* Hash the pool to get the output */\n\t\tMD5Init(&tmp);\n\t\tMD5Update(&tmp, (u_int8_t*)random_state.pool,\n\t\t    sizeof(random_state.pool));\n\t\tMD5Final(p, &tmp);\n\n\t\t/*\n\t\t * In case the hash function has some recognizable\n\t\t * output pattern, we fold it in half.\n\t\t */\n\t\tp[0] ^= p[15];\n\t\tp[1] ^= p[14];\n\t\tp[2] ^= p[13];\n\t\tp[3] ^= p[12];\n\t\tp[4] ^= p[11];\n\t\tp[5] ^= p[10];\n\t\tp[6] ^= p[ 9];\n\t\tp[7] ^= p[ 8];\n\n\t\t/* Modify pool so next hash will produce different results */\n\t\tadd_entropy_words((u_int32_t*)p, sizeof(buffer)/4);\n\n\t\t/* Copy data to destination buffer */\n\t\tif (i < sizeof(buffer))\n\t\t\tbcopy(buffer, buf, i);\n\t\tnbytes -= i;\n\t\tbuf += i;\n\t\tadd_timer_randomness(nbytes);\n\t}\n\n\t/* Wipe data from memory */\n\tbzero(&tmp, sizeof(tmp));\n\tbzero(&buffer, sizeof(buffer));\n}",
    "includes": [
      "#include <dev/rndioctl.h>",
      "#include <dev/rndvar.h>",
      "#include <sys/timeout.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/md5k.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/disk.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define POOLBITS (POOLWORDS*32)"
    ],
    "globals_used": [
      "struct random_bucket random_state;",
      "static __inline void add_entropy_words",
      "static __inline void extract_entropy",
      "__P((register u_int8_t *, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&buffer",
            "sizeof(buffer)"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&tmp",
            "sizeof(tmp)"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_timer_randomness",
          "args": [
            "nbytes"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "buffer",
            "buf",
            "i"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_entropy_words",
          "args": [
            "(u_int32_t*)p",
            "sizeof(buffer)/4"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "add_entropy_words",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
          "lines": "602-639",
          "snippet": "static __inline void\nadd_entropy_words(buf, n)\n\tconst u_int32_t *buf;\n\tu_int n;\n{\n\tstatic const u_int32_t twist_table[8] = {\n\t\t0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,\n\t\t0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278\n\t};\n\tu_int i;\n\tint new_rotate;\n\tu_int32_t w;\n\n\twhile (n--) {\n\t\tw = roll(*buf, random_state.input_rotate);\n\t\ti = random_state.add_ptr =\n\t\t    (random_state.add_ptr - 1) & (POOLWORDS - 1);\n\t\t/*\n\t\t * Normally, we add 7 bits of rotation to the pool.\n\t\t * At the beginning of the pool, add an extra 7 bits\n\t\t * rotation, so that successive passes spread the\n\t\t * input bits across the pool evenly.\n\t\t */\n\t\tnew_rotate = random_state.input_rotate + 14;\n\t\tif (i)\n\t\t\tnew_rotate = random_state.input_rotate + 7;\n\t\trandom_state.input_rotate = new_rotate & 31;\n\n\t\t/* XOR in the various taps */\n\t\tw ^= random_state.pool[(i+TAP1)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP2)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP3)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP4)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP5)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[i];\n\t\trandom_state.pool[i] = (w >> 3) ^ twist_table[w & 7];\n\t}\n}",
          "includes": [
            "#include <dev/rndioctl.h>",
            "#include <dev/rndvar.h>",
            "#include <sys/timeout.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/md5k.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/disk.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tTAP5\t1",
            "#define\tTAP4\t7",
            "#define\tTAP3\t14",
            "#define\tTAP2\t20",
            "#define\tTAP1\t26",
            "#define\tTAP5\t1",
            "#define\tTAP4\t14",
            "#define\tTAP3\t26",
            "#define\tTAP2\t39",
            "#define\tTAP1\t52",
            "#define\tTAP5\t1",
            "#define\tTAP4\t25",
            "#define\tTAP3\t51",
            "#define\tTAP2\t76",
            "#define\tTAP1\t103",
            "#define\tTAP5\t1",
            "#define\tTAP4\t52",
            "#define\tTAP3\t101",
            "#define\tTAP2\t155",
            "#define\tTAP1\t205",
            "#define\tTAP5\t1",
            "#define\tTAP4\t104",
            "#define\tTAP3\t208",
            "#define\tTAP2\t308",
            "#define\tTAP1\t411",
            "#define\tTAP5\t1",
            "#define\tTAP4\t204",
            "#define\tTAP3\t412",
            "#define\tTAP2\t615",
            "#define\tTAP1\t817",
            "#define\tTAP5\t1",
            "#define\tTAP4\t411",
            "#define\tTAP3\t819",
            "#define\tTAP2\t1231",
            "#define\tTAP1\t1638"
          ],
          "globals_used": [
            "struct random_bucket random_state;",
            "static __inline void add_entropy_words"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTAP5\t1\n#define\tTAP4\t7\n#define\tTAP3\t14\n#define\tTAP2\t20\n#define\tTAP1\t26\n#define\tTAP5\t1\n#define\tTAP4\t14\n#define\tTAP3\t26\n#define\tTAP2\t39\n#define\tTAP1\t52\n#define\tTAP5\t1\n#define\tTAP4\t25\n#define\tTAP3\t51\n#define\tTAP2\t76\n#define\tTAP1\t103\n#define\tTAP5\t1\n#define\tTAP4\t52\n#define\tTAP3\t101\n#define\tTAP2\t155\n#define\tTAP1\t205\n#define\tTAP5\t1\n#define\tTAP4\t104\n#define\tTAP3\t208\n#define\tTAP2\t308\n#define\tTAP1\t411\n#define\tTAP5\t1\n#define\tTAP4\t204\n#define\tTAP3\t412\n#define\tTAP2\t615\n#define\tTAP1\t817\n#define\tTAP5\t1\n#define\tTAP4\t411\n#define\tTAP3\t819\n#define\tTAP2\t1231\n#define\tTAP1\t1638\n\nstruct random_bucket random_state;\nstatic __inline void add_entropy_words;\n\nstatic __inline void\nadd_entropy_words(buf, n)\n\tconst u_int32_t *buf;\n\tu_int n;\n{\n\tstatic const u_int32_t twist_table[8] = {\n\t\t0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,\n\t\t0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278\n\t};\n\tu_int i;\n\tint new_rotate;\n\tu_int32_t w;\n\n\twhile (n--) {\n\t\tw = roll(*buf, random_state.input_rotate);\n\t\ti = random_state.add_ptr =\n\t\t    (random_state.add_ptr - 1) & (POOLWORDS - 1);\n\t\t/*\n\t\t * Normally, we add 7 bits of rotation to the pool.\n\t\t * At the beginning of the pool, add an extra 7 bits\n\t\t * rotation, so that successive passes spread the\n\t\t * input bits across the pool evenly.\n\t\t */\n\t\tnew_rotate = random_state.input_rotate + 14;\n\t\tif (i)\n\t\t\tnew_rotate = random_state.input_rotate + 7;\n\t\trandom_state.input_rotate = new_rotate & 31;\n\n\t\t/* XOR in the various taps */\n\t\tw ^= random_state.pool[(i+TAP1)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP2)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP3)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP4)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP5)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[i];\n\t\trandom_state.pool[i] = (w >> 3) ^ twist_table[w & 7];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MD5Final",
          "args": [
            "p",
            "&tmp"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MD5Update",
          "args": [
            "&tmp",
            "(u_int8_t*)random_state.pool",
            "sizeof(random_state.pool)"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MD5Init",
          "args": [
            "&tmp"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_timer_randomness",
          "args": [
            "nbytes"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define POOLBITS (POOLWORDS*32)\n\nstruct random_bucket random_state;\nstatic __inline void add_entropy_words;\nstatic __inline void extract_entropy;\n__P((register u_int8_t *, int));\n\nstatic __inline void\nextract_entropy(buf, nbytes)\n\tregister u_int8_t *buf;\n\tint\tnbytes;\n{\n\tMD5_CTX tmp;\n\tu_char buffer[16];\n\n\tadd_timer_randomness(nbytes);\n\n\t/* Redundant, but just in case... */\n\tif (random_state.entropy_count > POOLBITS)\n\t\trandom_state.entropy_count = POOLBITS;\n\n\tif (random_state.entropy_count / 8 > nbytes)\n\t\trandom_state.entropy_count -= nbytes*8;\n\telse\n\t\trandom_state.entropy_count = 0;\n\n\twhile (nbytes) {\n\t\tregister u_char *p = buf;\n\t\tregister int i = sizeof(buffer);\n\n\t\tif (i > nbytes) {\n\t\t\ti = nbytes;\n\t\t\tp = buffer;\n\t\t}\n\n\t\t/* Hash the pool to get the output */\n\t\tMD5Init(&tmp);\n\t\tMD5Update(&tmp, (u_int8_t*)random_state.pool,\n\t\t    sizeof(random_state.pool));\n\t\tMD5Final(p, &tmp);\n\n\t\t/*\n\t\t * In case the hash function has some recognizable\n\t\t * output pattern, we fold it in half.\n\t\t */\n\t\tp[0] ^= p[15];\n\t\tp[1] ^= p[14];\n\t\tp[2] ^= p[13];\n\t\tp[3] ^= p[12];\n\t\tp[4] ^= p[11];\n\t\tp[5] ^= p[10];\n\t\tp[6] ^= p[ 9];\n\t\tp[7] ^= p[ 8];\n\n\t\t/* Modify pool so next hash will produce different results */\n\t\tadd_entropy_words((u_int32_t*)p, sizeof(buffer)/4);\n\n\t\t/* Copy data to destination buffer */\n\t\tif (i < sizeof(buffer))\n\t\t\tbcopy(buffer, buf, i);\n\t\tnbytes -= i;\n\t\tbuf += i;\n\t\tadd_timer_randomness(nbytes);\n\t}\n\n\t/* Wipe data from memory */\n\tbzero(&tmp, sizeof(tmp));\n\tbzero(&buffer, sizeof(buffer));\n}"
  },
  {
    "function_name": "dequeue_randomness",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
    "lines": "764-821",
    "snippet": "void\ndequeue_randomness(v)\n\tvoid *v;\n{\n\tregister struct rand_event *rep;\n\tu_int32_t val, time;\n\tu_int nbits;\n\tint s;\n\n\ttimeout_del(&rnd_timeout);\n\trndstats.rnd_deqs++;\n\n\tdo {\n\t\ts = splhigh();\n\t\tif (rnd_event_q == NULL) {\n\t\t\tsplx(s);\n\t\t\tbreak;\n\t\t}\n\t\trep = rnd_event_q;\n\t\trnd_event_q = rep->re_next;\n\t\trandom_state.queued--;\n\n\t\tval = rep->re_val;\n\t\ttime = rep->re_time;\n\t\tnbits = rep->re_nbits;\n\n\t\trep->re_next = rnd_event_free;\n\t\trnd_event_free = rep;\n\t\tsplx(s);\n\n\t\t/* Prevent overflow */\n\t\tif ((random_state.entropy_count + nbits) > POOLBITS &&\n\t\t    arc4random_state.cnt > 253)\n\t\t\tarc4_stir();\n\n\t\tadd_entropy_words(&val, 1);\n\t\tadd_entropy_words(&time, 1);\n\n\t\trandom_state.entropy_count += nbits;\n\t\trndstats.rnd_total += nbits;\n\t\tif (random_state.entropy_count > POOLBITS)\n\t\t\trandom_state.entropy_count = POOLBITS;\n\n\t\tif (random_state.entropy_count > 8 &&\n\t\t    random_state.asleep != 0) {\n#ifdef\tRNDEBUG\n\t\t\tif (rnd_debug & RD_WAIT)\n\t\t\t\tprintf(\"rnd: wakeup[%u]{%u}\\n\",\n\t\t\t\t    random_state.asleep,\n\t\t\t\t    random_state.entropy_count);\n#endif\n\t\t\trandom_state.asleep--;\n\t\t\twakeup(&random_state.asleep);\n\t\t}\n\t} while(1);\n\n\trandom_state.tmo = 0;\n}",
    "includes": [
      "#include <dev/rndioctl.h>",
      "#include <dev/rndvar.h>",
      "#include <sys/timeout.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/md5k.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/disk.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define POOLBITS (POOLWORDS*32)",
      "#define\tRD_WAIT\t\t0x0100\t/* sleep/wakeup for good data */"
    ],
    "globals_used": [
      "struct random_bucket random_state;",
      "struct arc4_stream arc4random_state;",
      "struct rand_event *rnd_event_q;",
      "struct rand_event *rnd_event_free;",
      "struct rndstats rndstats;",
      "void dequeue_randomness",
      "static __inline void add_entropy_words",
      "void arc4_stir"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&random_state.asleep"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"rnd: wakeup[%u]{%u}\\n\"",
            "random_state.asleep",
            "random_state.entropy_count"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_entropy_words",
          "args": [
            "&time",
            "1"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "add_entropy_words",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
          "lines": "602-639",
          "snippet": "static __inline void\nadd_entropy_words(buf, n)\n\tconst u_int32_t *buf;\n\tu_int n;\n{\n\tstatic const u_int32_t twist_table[8] = {\n\t\t0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,\n\t\t0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278\n\t};\n\tu_int i;\n\tint new_rotate;\n\tu_int32_t w;\n\n\twhile (n--) {\n\t\tw = roll(*buf, random_state.input_rotate);\n\t\ti = random_state.add_ptr =\n\t\t    (random_state.add_ptr - 1) & (POOLWORDS - 1);\n\t\t/*\n\t\t * Normally, we add 7 bits of rotation to the pool.\n\t\t * At the beginning of the pool, add an extra 7 bits\n\t\t * rotation, so that successive passes spread the\n\t\t * input bits across the pool evenly.\n\t\t */\n\t\tnew_rotate = random_state.input_rotate + 14;\n\t\tif (i)\n\t\t\tnew_rotate = random_state.input_rotate + 7;\n\t\trandom_state.input_rotate = new_rotate & 31;\n\n\t\t/* XOR in the various taps */\n\t\tw ^= random_state.pool[(i+TAP1)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP2)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP3)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP4)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP5)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[i];\n\t\trandom_state.pool[i] = (w >> 3) ^ twist_table[w & 7];\n\t}\n}",
          "includes": [
            "#include <dev/rndioctl.h>",
            "#include <dev/rndvar.h>",
            "#include <sys/timeout.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/md5k.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/disk.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tTAP5\t1",
            "#define\tTAP4\t7",
            "#define\tTAP3\t14",
            "#define\tTAP2\t20",
            "#define\tTAP1\t26",
            "#define\tTAP5\t1",
            "#define\tTAP4\t14",
            "#define\tTAP3\t26",
            "#define\tTAP2\t39",
            "#define\tTAP1\t52",
            "#define\tTAP5\t1",
            "#define\tTAP4\t25",
            "#define\tTAP3\t51",
            "#define\tTAP2\t76",
            "#define\tTAP1\t103",
            "#define\tTAP5\t1",
            "#define\tTAP4\t52",
            "#define\tTAP3\t101",
            "#define\tTAP2\t155",
            "#define\tTAP1\t205",
            "#define\tTAP5\t1",
            "#define\tTAP4\t104",
            "#define\tTAP3\t208",
            "#define\tTAP2\t308",
            "#define\tTAP1\t411",
            "#define\tTAP5\t1",
            "#define\tTAP4\t204",
            "#define\tTAP3\t412",
            "#define\tTAP2\t615",
            "#define\tTAP1\t817",
            "#define\tTAP5\t1",
            "#define\tTAP4\t411",
            "#define\tTAP3\t819",
            "#define\tTAP2\t1231",
            "#define\tTAP1\t1638"
          ],
          "globals_used": [
            "struct random_bucket random_state;",
            "static __inline void add_entropy_words"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTAP5\t1\n#define\tTAP4\t7\n#define\tTAP3\t14\n#define\tTAP2\t20\n#define\tTAP1\t26\n#define\tTAP5\t1\n#define\tTAP4\t14\n#define\tTAP3\t26\n#define\tTAP2\t39\n#define\tTAP1\t52\n#define\tTAP5\t1\n#define\tTAP4\t25\n#define\tTAP3\t51\n#define\tTAP2\t76\n#define\tTAP1\t103\n#define\tTAP5\t1\n#define\tTAP4\t52\n#define\tTAP3\t101\n#define\tTAP2\t155\n#define\tTAP1\t205\n#define\tTAP5\t1\n#define\tTAP4\t104\n#define\tTAP3\t208\n#define\tTAP2\t308\n#define\tTAP1\t411\n#define\tTAP5\t1\n#define\tTAP4\t204\n#define\tTAP3\t412\n#define\tTAP2\t615\n#define\tTAP1\t817\n#define\tTAP5\t1\n#define\tTAP4\t411\n#define\tTAP3\t819\n#define\tTAP2\t1231\n#define\tTAP1\t1638\n\nstruct random_bucket random_state;\nstatic __inline void add_entropy_words;\n\nstatic __inline void\nadd_entropy_words(buf, n)\n\tconst u_int32_t *buf;\n\tu_int n;\n{\n\tstatic const u_int32_t twist_table[8] = {\n\t\t0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,\n\t\t0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278\n\t};\n\tu_int i;\n\tint new_rotate;\n\tu_int32_t w;\n\n\twhile (n--) {\n\t\tw = roll(*buf, random_state.input_rotate);\n\t\ti = random_state.add_ptr =\n\t\t    (random_state.add_ptr - 1) & (POOLWORDS - 1);\n\t\t/*\n\t\t * Normally, we add 7 bits of rotation to the pool.\n\t\t * At the beginning of the pool, add an extra 7 bits\n\t\t * rotation, so that successive passes spread the\n\t\t * input bits across the pool evenly.\n\t\t */\n\t\tnew_rotate = random_state.input_rotate + 14;\n\t\tif (i)\n\t\t\tnew_rotate = random_state.input_rotate + 7;\n\t\trandom_state.input_rotate = new_rotate & 31;\n\n\t\t/* XOR in the various taps */\n\t\tw ^= random_state.pool[(i+TAP1)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP2)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP3)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP4)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP5)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[i];\n\t\trandom_state.pool[i] = (w >> 3) ^ twist_table[w & 7];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "arc4_stir",
          "args": [],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "arc4_stir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
          "lines": "452-482",
          "snippet": "void\narc4_stir(void)\n{\n\tu_int8_t buf[256];\n\tregister u_int8_t si;\n\tregister int n, s;\n\tint len;\n\n\tmicrotime((struct timeval *) buf);\n\tlen = random_state.entropy_count / 8; /* XXX maybe a half? */\n\tif (len > sizeof(buf) - sizeof(struct timeval))\n\t\tlen = sizeof(buf) - sizeof(struct timeval);\n\tget_random_bytes(buf + sizeof (struct timeval), len);\n\tlen += sizeof(struct timeval);\n\n\ts = splhigh();\n\tarc4random_state.i--;\n\tfor (n = 0; n < 256; n++) {\n\t\tarc4random_state.i++;\n\t\tsi = arc4random_state.s[arc4random_state.i];\n\t\tarc4random_state.j += si + buf[n % len];\n\t\tarc4random_state.s[arc4random_state.i] =\n\t\t    arc4random_state.s[arc4random_state.j];\n\t\tarc4random_state.s[arc4random_state.j] = si;\n\t}\n\tarc4random_state.j = arc4random_state.i;\n\tarc4random_state.cnt = 0;\n\trndstats.arc4_stirs += len;\n\trndstats.arc4_nstirs++;\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/rndioctl.h>",
            "#include <dev/rndvar.h>",
            "#include <sys/timeout.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/md5k.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/disk.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct random_bucket random_state;",
            "struct arc4_stream arc4random_state;",
            "struct rndstats rndstats;",
            "__P((register u_int8_t *, int));",
            "void arc4_stir"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct random_bucket random_state;\nstruct arc4_stream arc4random_state;\nstruct rndstats rndstats;\n__P((register u_int8_t *, int));\nvoid arc4_stir;\n\nvoid\narc4_stir(void)\n{\n\tu_int8_t buf[256];\n\tregister u_int8_t si;\n\tregister int n, s;\n\tint len;\n\n\tmicrotime((struct timeval *) buf);\n\tlen = random_state.entropy_count / 8; /* XXX maybe a half? */\n\tif (len > sizeof(buf) - sizeof(struct timeval))\n\t\tlen = sizeof(buf) - sizeof(struct timeval);\n\tget_random_bytes(buf + sizeof (struct timeval), len);\n\tlen += sizeof(struct timeval);\n\n\ts = splhigh();\n\tarc4random_state.i--;\n\tfor (n = 0; n < 256; n++) {\n\t\tarc4random_state.i++;\n\t\tsi = arc4random_state.s[arc4random_state.i];\n\t\tarc4random_state.j += si + buf[n % len];\n\t\tarc4random_state.s[arc4random_state.i] =\n\t\t    arc4random_state.s[arc4random_state.j];\n\t\tarc4random_state.s[arc4random_state.j] = si;\n\t}\n\tarc4random_state.j = arc4random_state.i;\n\tarc4random_state.cnt = 0;\n\trndstats.arc4_stirs += len;\n\trndstats.arc4_nstirs++;\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout_del",
          "args": [
            "&rnd_timeout"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define POOLBITS (POOLWORDS*32)\n#define\tRD_WAIT\t\t0x0100\t/* sleep/wakeup for good data */\n\nstruct random_bucket random_state;\nstruct arc4_stream arc4random_state;\nstruct rand_event *rnd_event_q;\nstruct rand_event *rnd_event_free;\nstruct rndstats rndstats;\nvoid dequeue_randomness;\nstatic __inline void add_entropy_words;\nvoid arc4_stir;\n\nvoid\ndequeue_randomness(v)\n\tvoid *v;\n{\n\tregister struct rand_event *rep;\n\tu_int32_t val, time;\n\tu_int nbits;\n\tint s;\n\n\ttimeout_del(&rnd_timeout);\n\trndstats.rnd_deqs++;\n\n\tdo {\n\t\ts = splhigh();\n\t\tif (rnd_event_q == NULL) {\n\t\t\tsplx(s);\n\t\t\tbreak;\n\t\t}\n\t\trep = rnd_event_q;\n\t\trnd_event_q = rep->re_next;\n\t\trandom_state.queued--;\n\n\t\tval = rep->re_val;\n\t\ttime = rep->re_time;\n\t\tnbits = rep->re_nbits;\n\n\t\trep->re_next = rnd_event_free;\n\t\trnd_event_free = rep;\n\t\tsplx(s);\n\n\t\t/* Prevent overflow */\n\t\tif ((random_state.entropy_count + nbits) > POOLBITS &&\n\t\t    arc4random_state.cnt > 253)\n\t\t\tarc4_stir();\n\n\t\tadd_entropy_words(&val, 1);\n\t\tadd_entropy_words(&time, 1);\n\n\t\trandom_state.entropy_count += nbits;\n\t\trndstats.rnd_total += nbits;\n\t\tif (random_state.entropy_count > POOLBITS)\n\t\t\trandom_state.entropy_count = POOLBITS;\n\n\t\tif (random_state.entropy_count > 8 &&\n\t\t    random_state.asleep != 0) {\n#ifdef\tRNDEBUG\n\t\t\tif (rnd_debug & RD_WAIT)\n\t\t\t\tprintf(\"rnd: wakeup[%u]{%u}\\n\",\n\t\t\t\t    random_state.asleep,\n\t\t\t\t    random_state.entropy_count);\n#endif\n\t\t\trandom_state.asleep--;\n\t\t\twakeup(&random_state.asleep);\n\t\t}\n\t} while(1);\n\n\trandom_state.tmo = 0;\n}"
  },
  {
    "function_name": "enqueue_randomness",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
    "lines": "653-762",
    "snippet": "void\nenqueue_randomness(state, val)\n\tint\tstate, val;\n{\n\tstruct timer_rand_state *p;\n\tstruct timeval\ttv;\n\tregister struct rand_event *rep;\n\tint s;\n\tu_int\ttime, nbits;\n\n#ifdef DIAGNOSTIC\n\tif (state < 0 || state >= RND_SRC_NUM)\n\t\treturn;\n#endif\n\n\tp = &rnd_states[state];\n\tval += state << 13;\n\n\tmicrotime(&tv);\n\ttime = tv.tv_usec ^ tv.tv_sec;\n\tnbits = 0;\n\n\t/*\n\t * Calculate number of bits of randomness we probably\n\t * added.  We take into account the first and second order\n\t * deltas in order to make our estimate.\n\t */\n\tif (!p->dont_count_entropy) {\n\t\tregister int\tdelta, delta2, delta3;\n\t\tdelta  = time   - p->last_time;\n\t\tdelta2 = delta  - p->last_delta;\n\t\tdelta3 = delta2 - p->last_delta2;\n\n\t\tif (delta < 0) delta = -delta;\n\t\tif (delta2 < 0) delta2 = -delta2;\n\t\tif (delta3 < 0) delta3 = -delta3;\n\t\tif (delta > delta2) delta = delta2;\n\t\tif (delta > delta3) delta = delta3;\n\t\tdelta3 = delta >>= 1;\n\t\t/*\n\t\t * delta &= 0xfff;\n\t\t * we don't do it since our time sheet is different from linux\n\t\t */\n\n\t\tif (delta & 0xffff0000) {\n\t\t\tnbits = 16;\n\t\t\tdelta >>= 16;\n\t\t}\n\t\tif (delta & 0xff00) {\n\t\t\tnbits += 8;\n\t\t\tdelta >>= 8;\n\t\t}\n\t\tif (delta & 0xf0) {\n\t\t\tnbits += 4;\n\t\t\tdelta >>= 4;\n\t\t}\n\t\tif (delta & 0xc) {\n\t\t\tnbits += 2;\n\t\t\tdelta >>= 2;\n\t\t}\n\t\tif (delta & 2) {\n\t\t\tnbits += 1;\n\t\t\tdelta >>= 1;\n\t\t}\n\t\tif (delta & 1)\n\t\t\tnbits++;\n\n\t\t/*\n\t\t * the logic is to drop low-entropy entries,\n\t\t * in hope for dequeuing to be more sourcefull\n\t\t */\n\t\tif (random_state.queued > QEVSLOW && nbits < QEVSBITS) {\n\t\t\trndstats.rnd_drople++;\n\t\t\treturn;\n\t\t}\n\t\tp->last_time = time;\n\t\tp->last_delta  = delta3;\n\t\tp->last_delta2 = delta2;\n\t} else if (p->max_entropy)\n\t\tnbits = 8 * sizeof(val) - 1;\n\n\ts = splhigh();\n\tif ((rep = rnd_event_free) == NULL) {\n\t\trndstats.rnd_drops++;\n\t\tsplx(s);\n\t\treturn;\n\t}\n\trnd_event_free = rep->re_next;\n\n\trep->re_state = p;\n\trep->re_nbits = nbits;\n\trep->re_time = time;\n\trep->re_val = val;\n\n\trep->re_next = rnd_event_q;\n\trnd_event_q = rep;\n\trep = rep->re_next;\n\trandom_state.queued++;\n\n\trndstats.rnd_enqs++;\n\trndstats.rnd_ed[nbits]++;\n\trndstats.rnd_sc[state]++;\n\trndstats.rnd_sb[state] += nbits;\n\n\tif (++random_state.queued > QEVSLOW/2 && !random_state.tmo) {\n\t\trandom_state.tmo++;\n\t\ttimeout_add(&rnd_timeout, 1);\n\t}\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/rndioctl.h>",
      "#include <dev/rndvar.h>",
      "#include <sys/timeout.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/md5k.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/disk.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define QEVSBITS 12",
      "#define QEVSLOW 64 /* yet another 0.75 for 60-minutes hour /-; */"
    ],
    "globals_used": [
      "struct random_bucket random_state;",
      "struct timer_rand_state rnd_states[RND_SRC_NUM];",
      "struct rand_event *rnd_event_q;",
      "struct rand_event *rnd_event_free;",
      "struct rndstats rndstats;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout_add",
          "args": [
            "&rnd_timeout",
            "1"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "microtime",
          "args": [
            "&tv"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define QEVSBITS 12\n#define QEVSLOW 64 /* yet another 0.75 for 60-minutes hour /-; */\n\nstruct random_bucket random_state;\nstruct timer_rand_state rnd_states[RND_SRC_NUM];\nstruct rand_event *rnd_event_q;\nstruct rand_event *rnd_event_free;\nstruct rndstats rndstats;\n\nvoid\nenqueue_randomness(state, val)\n\tint\tstate, val;\n{\n\tstruct timer_rand_state *p;\n\tstruct timeval\ttv;\n\tregister struct rand_event *rep;\n\tint s;\n\tu_int\ttime, nbits;\n\n#ifdef DIAGNOSTIC\n\tif (state < 0 || state >= RND_SRC_NUM)\n\t\treturn;\n#endif\n\n\tp = &rnd_states[state];\n\tval += state << 13;\n\n\tmicrotime(&tv);\n\ttime = tv.tv_usec ^ tv.tv_sec;\n\tnbits = 0;\n\n\t/*\n\t * Calculate number of bits of randomness we probably\n\t * added.  We take into account the first and second order\n\t * deltas in order to make our estimate.\n\t */\n\tif (!p->dont_count_entropy) {\n\t\tregister int\tdelta, delta2, delta3;\n\t\tdelta  = time   - p->last_time;\n\t\tdelta2 = delta  - p->last_delta;\n\t\tdelta3 = delta2 - p->last_delta2;\n\n\t\tif (delta < 0) delta = -delta;\n\t\tif (delta2 < 0) delta2 = -delta2;\n\t\tif (delta3 < 0) delta3 = -delta3;\n\t\tif (delta > delta2) delta = delta2;\n\t\tif (delta > delta3) delta = delta3;\n\t\tdelta3 = delta >>= 1;\n\t\t/*\n\t\t * delta &= 0xfff;\n\t\t * we don't do it since our time sheet is different from linux\n\t\t */\n\n\t\tif (delta & 0xffff0000) {\n\t\t\tnbits = 16;\n\t\t\tdelta >>= 16;\n\t\t}\n\t\tif (delta & 0xff00) {\n\t\t\tnbits += 8;\n\t\t\tdelta >>= 8;\n\t\t}\n\t\tif (delta & 0xf0) {\n\t\t\tnbits += 4;\n\t\t\tdelta >>= 4;\n\t\t}\n\t\tif (delta & 0xc) {\n\t\t\tnbits += 2;\n\t\t\tdelta >>= 2;\n\t\t}\n\t\tif (delta & 2) {\n\t\t\tnbits += 1;\n\t\t\tdelta >>= 1;\n\t\t}\n\t\tif (delta & 1)\n\t\t\tnbits++;\n\n\t\t/*\n\t\t * the logic is to drop low-entropy entries,\n\t\t * in hope for dequeuing to be more sourcefull\n\t\t */\n\t\tif (random_state.queued > QEVSLOW && nbits < QEVSBITS) {\n\t\t\trndstats.rnd_drople++;\n\t\t\treturn;\n\t\t}\n\t\tp->last_time = time;\n\t\tp->last_delta  = delta3;\n\t\tp->last_delta2 = delta2;\n\t} else if (p->max_entropy)\n\t\tnbits = 8 * sizeof(val) - 1;\n\n\ts = splhigh();\n\tif ((rep = rnd_event_free) == NULL) {\n\t\trndstats.rnd_drops++;\n\t\tsplx(s);\n\t\treturn;\n\t}\n\trnd_event_free = rep->re_next;\n\n\trep->re_state = p;\n\trep->re_nbits = nbits;\n\trep->re_time = time;\n\trep->re_val = val;\n\n\trep->re_next = rnd_event_q;\n\trnd_event_q = rep;\n\trep = rep->re_next;\n\trandom_state.queued++;\n\n\trndstats.rnd_enqs++;\n\trndstats.rnd_ed[nbits]++;\n\trndstats.rnd_sc[state]++;\n\trndstats.rnd_sb[state] += nbits;\n\n\tif (++random_state.queued > QEVSLOW/2 && !random_state.tmo) {\n\t\trandom_state.tmo++;\n\t\ttimeout_add(&rnd_timeout, 1);\n\t}\n\tsplx(s);\n}"
  },
  {
    "function_name": "add_entropy_words",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
    "lines": "602-639",
    "snippet": "static __inline void\nadd_entropy_words(buf, n)\n\tconst u_int32_t *buf;\n\tu_int n;\n{\n\tstatic const u_int32_t twist_table[8] = {\n\t\t0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,\n\t\t0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278\n\t};\n\tu_int i;\n\tint new_rotate;\n\tu_int32_t w;\n\n\twhile (n--) {\n\t\tw = roll(*buf, random_state.input_rotate);\n\t\ti = random_state.add_ptr =\n\t\t    (random_state.add_ptr - 1) & (POOLWORDS - 1);\n\t\t/*\n\t\t * Normally, we add 7 bits of rotation to the pool.\n\t\t * At the beginning of the pool, add an extra 7 bits\n\t\t * rotation, so that successive passes spread the\n\t\t * input bits across the pool evenly.\n\t\t */\n\t\tnew_rotate = random_state.input_rotate + 14;\n\t\tif (i)\n\t\t\tnew_rotate = random_state.input_rotate + 7;\n\t\trandom_state.input_rotate = new_rotate & 31;\n\n\t\t/* XOR in the various taps */\n\t\tw ^= random_state.pool[(i+TAP1)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP2)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP3)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP4)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP5)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[i];\n\t\trandom_state.pool[i] = (w >> 3) ^ twist_table[w & 7];\n\t}\n}",
    "includes": [
      "#include <dev/rndioctl.h>",
      "#include <dev/rndvar.h>",
      "#include <sys/timeout.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/md5k.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/disk.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tTAP5\t1",
      "#define\tTAP4\t7",
      "#define\tTAP3\t14",
      "#define\tTAP2\t20",
      "#define\tTAP1\t26",
      "#define\tTAP5\t1",
      "#define\tTAP4\t14",
      "#define\tTAP3\t26",
      "#define\tTAP2\t39",
      "#define\tTAP1\t52",
      "#define\tTAP5\t1",
      "#define\tTAP4\t25",
      "#define\tTAP3\t51",
      "#define\tTAP2\t76",
      "#define\tTAP1\t103",
      "#define\tTAP5\t1",
      "#define\tTAP4\t52",
      "#define\tTAP3\t101",
      "#define\tTAP2\t155",
      "#define\tTAP1\t205",
      "#define\tTAP5\t1",
      "#define\tTAP4\t104",
      "#define\tTAP3\t208",
      "#define\tTAP2\t308",
      "#define\tTAP1\t411",
      "#define\tTAP5\t1",
      "#define\tTAP4\t204",
      "#define\tTAP3\t412",
      "#define\tTAP2\t615",
      "#define\tTAP1\t817",
      "#define\tTAP5\t1",
      "#define\tTAP4\t411",
      "#define\tTAP3\t819",
      "#define\tTAP2\t1231",
      "#define\tTAP1\t1638"
    ],
    "globals_used": [
      "struct random_bucket random_state;",
      "static __inline void add_entropy_words"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "roll",
          "args": [
            "*buf",
            "random_state.input_rotate"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "roll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
          "lines": "415-423",
          "snippet": "static __inline u_int32_t roll(u_int32_t w, int i)\n{\n#ifdef i386\n\t__asm (\"roll %%cl, %0\" : \"+r\" (w) : \"c\" (i));\n#else\n\tw = (w << i) | (w >> (32 - i));\n#endif\n\treturn w;\n}",
          "includes": [
            "#include <dev/rndioctl.h>",
            "#include <dev/rndvar.h>",
            "#include <sys/timeout.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/md5k.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/disk.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline u_int32_t roll(u_int32_t w, int i)\n{\n#ifdef i386\n\t__asm (\"roll %%cl, %0\" : \"+r\" (w) : \"c\" (i));\n#else\n\tw = (w << i) | (w >> (32 - i));\n#endif\n\treturn w;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTAP5\t1\n#define\tTAP4\t7\n#define\tTAP3\t14\n#define\tTAP2\t20\n#define\tTAP1\t26\n#define\tTAP5\t1\n#define\tTAP4\t14\n#define\tTAP3\t26\n#define\tTAP2\t39\n#define\tTAP1\t52\n#define\tTAP5\t1\n#define\tTAP4\t25\n#define\tTAP3\t51\n#define\tTAP2\t76\n#define\tTAP1\t103\n#define\tTAP5\t1\n#define\tTAP4\t52\n#define\tTAP3\t101\n#define\tTAP2\t155\n#define\tTAP1\t205\n#define\tTAP5\t1\n#define\tTAP4\t104\n#define\tTAP3\t208\n#define\tTAP2\t308\n#define\tTAP1\t411\n#define\tTAP5\t1\n#define\tTAP4\t204\n#define\tTAP3\t412\n#define\tTAP2\t615\n#define\tTAP1\t817\n#define\tTAP5\t1\n#define\tTAP4\t411\n#define\tTAP3\t819\n#define\tTAP2\t1231\n#define\tTAP1\t1638\n\nstruct random_bucket random_state;\nstatic __inline void add_entropy_words;\n\nstatic __inline void\nadd_entropy_words(buf, n)\n\tconst u_int32_t *buf;\n\tu_int n;\n{\n\tstatic const u_int32_t twist_table[8] = {\n\t\t0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,\n\t\t0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278\n\t};\n\tu_int i;\n\tint new_rotate;\n\tu_int32_t w;\n\n\twhile (n--) {\n\t\tw = roll(*buf, random_state.input_rotate);\n\t\ti = random_state.add_ptr =\n\t\t    (random_state.add_ptr - 1) & (POOLWORDS - 1);\n\t\t/*\n\t\t * Normally, we add 7 bits of rotation to the pool.\n\t\t * At the beginning of the pool, add an extra 7 bits\n\t\t * rotation, so that successive passes spread the\n\t\t * input bits across the pool evenly.\n\t\t */\n\t\tnew_rotate = random_state.input_rotate + 14;\n\t\tif (i)\n\t\t\tnew_rotate = random_state.input_rotate + 7;\n\t\trandom_state.input_rotate = new_rotate & 31;\n\n\t\t/* XOR in the various taps */\n\t\tw ^= random_state.pool[(i+TAP1)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP2)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP3)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP4)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[(i+TAP5)&(POOLWORDS-1)];\n\t\tw ^= random_state.pool[i];\n\t\trandom_state.pool[i] = (w >> 3) ^ twist_table[w & 7];\n\t}\n}"
  },
  {
    "function_name": "randomclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
    "lines": "578-586",
    "snippet": "int\nrandomclose(dev, flag, mode, p)\n\tdev_t\tdev;\n\tint\tflag;\n\tint\tmode;\n\tstruct proc *p;\n{\n\treturn 0;\n}",
    "includes": [
      "#include <dev/rndioctl.h>",
      "#include <dev/rndvar.h>",
      "#include <sys/timeout.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/md5k.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/disk.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrandomclose(dev, flag, mode, p)\n\tdev_t\tdev;\n\tint\tflag;\n\tint\tmode;\n\tstruct proc *p;\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "randomopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
    "lines": "568-576",
    "snippet": "int\nrandomopen(dev, flag, mode, p)\n\tdev_t\tdev;\n\tint\tflag;\n\tint\tmode;\n\tstruct proc *p;\n{\n\treturn (minor (dev) < RND_NODEV) ? 0 : ENXIO;\n}",
    "includes": [
      "#include <dev/rndioctl.h>",
      "#include <dev/rndvar.h>",
      "#include <sys/timeout.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/md5k.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/disk.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrandomopen(dev, flag, mode, p)\n\tdev_t\tdev;\n\tint\tflag;\n\tint\tmode;\n\tstruct proc *p;\n{\n\treturn (minor (dev) < RND_NODEV) ? 0 : ENXIO;\n}"
  },
  {
    "function_name": "randomattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
    "lines": "534-566",
    "snippet": "void\nrandomattach(void)\n{\n\tint i;\n\tstruct timeval tv;\n\tstruct rand_event *rep;\n\n\tif (rnd_attached) {\n#ifdef RNDEBUG\n\t\tprintf(\"random: second attach\\n\");\n#endif\n\t\treturn;\n\t}\n\n\trandom_state.add_ptr = 0;\n\trandom_state.entropy_count = 0;\n\trnd_states[RND_SRC_TIMER].dont_count_entropy = 1;\n\trnd_states[RND_SRC_TRUE].dont_count_entropy = 1;\n\trnd_states[RND_SRC_TRUE].max_entropy = 1;\n\n\tbzero(&rndstats, sizeof(rndstats));\n\tbzero(&rnd_event_space, sizeof(rnd_event_space));\n\trnd_event_free = rnd_event_space;\n\tfor (rep = rnd_event_space; rep < &rnd_event_space[QEVLEN-1]; rep++)\n\t\trep->re_next = rep + 1;\n\tfor (i = 0; i < 256; i++)\n\t\tarc4random_state.s[i] = i;\n\tmicrotime(&tv);\n\ttimeout_set(&rnd_timeout, dequeue_randomness, NULL);\n\ttimeout_set(&arc4_timeout, arc4_reinit, NULL);\n\tarc4_reinit(NULL);\n\trnd_attached = 1;\n}",
    "includes": [
      "#include <dev/rndioctl.h>",
      "#include <dev/rndvar.h>",
      "#include <sys/timeout.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/md5k.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/disk.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define QEVLEN 96"
    ],
    "globals_used": [
      "struct timeout rnd_timeout, arc4_timeout;",
      "struct random_bucket random_state;",
      "struct arc4_stream arc4random_state;",
      "struct timer_rand_state rnd_states[RND_SRC_NUM];",
      "struct rand_event rnd_event_space[QEVLEN];",
      "struct rand_event *rnd_event_free;",
      "int rnd_attached;",
      "struct rndstats rndstats;",
      "void dequeue_randomness",
      "void arc4_reinit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arc4_reinit",
          "args": [
            "NULL"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "arc4_reinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
          "lines": "509-517",
          "snippet": "void\narc4_reinit(v)\n\tvoid *v;\n{\n\textern int hz;\n\n\tarc4random_initialized = 0;\n\ttimeout_add(&arc4_timeout, 10*60*hz);\n}",
          "includes": [
            "#include <dev/rndioctl.h>",
            "#include <dev/rndvar.h>",
            "#include <sys/timeout.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/md5k.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/disk.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct timeout rnd_timeout, arc4_timeout;",
            "int arc4random_initialized;",
            "void arc4_reinit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct timeout rnd_timeout, arc4_timeout;\nint arc4random_initialized;\nvoid arc4_reinit;\n\nvoid\narc4_reinit(v)\n\tvoid *v;\n{\n\textern int hz;\n\n\tarc4random_initialized = 0;\n\ttimeout_add(&arc4_timeout, 10*60*hz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout_set",
          "args": [
            "&arc4_timeout",
            "arc4_reinit",
            "NULL"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout_set",
          "args": [
            "&rnd_timeout",
            "dequeue_randomness",
            "NULL"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "microtime",
          "args": [
            "&tv"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&rnd_event_space",
            "sizeof(rnd_event_space)"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&rndstats",
            "sizeof(rndstats)"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"random: second attach\\n\""
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define QEVLEN 96\n\nstruct timeout rnd_timeout, arc4_timeout;\nstruct random_bucket random_state;\nstruct arc4_stream arc4random_state;\nstruct timer_rand_state rnd_states[RND_SRC_NUM];\nstruct rand_event rnd_event_space[QEVLEN];\nstruct rand_event *rnd_event_free;\nint rnd_attached;\nstruct rndstats rndstats;\nvoid dequeue_randomness;\nvoid arc4_reinit;\n\nvoid\nrandomattach(void)\n{\n\tint i;\n\tstruct timeval tv;\n\tstruct rand_event *rep;\n\n\tif (rnd_attached) {\n#ifdef RNDEBUG\n\t\tprintf(\"random: second attach\\n\");\n#endif\n\t\treturn;\n\t}\n\n\trandom_state.add_ptr = 0;\n\trandom_state.entropy_count = 0;\n\trnd_states[RND_SRC_TIMER].dont_count_entropy = 1;\n\trnd_states[RND_SRC_TRUE].dont_count_entropy = 1;\n\trnd_states[RND_SRC_TRUE].max_entropy = 1;\n\n\tbzero(&rndstats, sizeof(rndstats));\n\tbzero(&rnd_event_space, sizeof(rnd_event_space));\n\trnd_event_free = rnd_event_space;\n\tfor (rep = rnd_event_space; rep < &rnd_event_space[QEVLEN-1]; rep++)\n\t\trep->re_next = rep + 1;\n\tfor (i = 0; i < 256; i++)\n\t\tarc4random_state.s[i] = i;\n\tmicrotime(&tv);\n\ttimeout_set(&rnd_timeout, dequeue_randomness, NULL);\n\ttimeout_set(&arc4_timeout, arc4_reinit, NULL);\n\tarc4_reinit(NULL);\n\trnd_attached = 1;\n}"
  },
  {
    "function_name": "arc4random",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
    "lines": "526-532",
    "snippet": "u_int32_t\narc4random(void)\n{\n\tarc4maybeinit();\n\treturn ((arc4_getbyte() << 24) | (arc4_getbyte() << 16)\n\t\t| (arc4_getbyte() << 8) | arc4_getbyte());\n}",
    "includes": [
      "#include <dev/rndioctl.h>",
      "#include <dev/rndvar.h>",
      "#include <sys/timeout.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/md5k.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/disk.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline u_int8_t arc4_getbyte"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arc4_getbyte",
          "args": [],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "arc4_getbyte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
          "lines": "484-498",
          "snippet": "static __inline u_int8_t\narc4_getbyte(void)\n{\n\tregister u_int8_t si, sj;\n\n\trndstats.arc4_reads++;\n\tarc4random_state.cnt++;\n\tarc4random_state.i++;\n\tsi = arc4random_state.s[arc4random_state.i];\n\tarc4random_state.j += si;\n\tsj = arc4random_state.s[arc4random_state.j];\n\tarc4random_state.s[arc4random_state.i] = sj;\n\tarc4random_state.s[arc4random_state.j] = si;\n\treturn arc4random_state.s[(si + sj) & 0xff];\n}",
          "includes": [
            "#include <dev/rndioctl.h>",
            "#include <dev/rndvar.h>",
            "#include <sys/timeout.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/md5k.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/disk.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct arc4_stream arc4random_state;",
            "struct rndstats rndstats;",
            "__P((register u_int8_t *, int));",
            "static __inline u_int8_t arc4_getbyte"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct arc4_stream arc4random_state;\nstruct rndstats rndstats;\n__P((register u_int8_t *, int));\nstatic __inline u_int8_t arc4_getbyte;\n\nstatic __inline u_int8_t\narc4_getbyte(void)\n{\n\tregister u_int8_t si, sj;\n\n\trndstats.arc4_reads++;\n\tarc4random_state.cnt++;\n\tarc4random_state.i++;\n\tsi = arc4random_state.s[arc4random_state.i];\n\tarc4random_state.j += si;\n\tsj = arc4random_state.s[arc4random_state.j];\n\tarc4random_state.s[arc4random_state.i] = sj;\n\tarc4random_state.s[arc4random_state.j] = si;\n\treturn arc4random_state.s[(si + sj) & 0xff];\n}"
        }
      },
      {
        "call_info": {
          "callee": "arc4maybeinit",
          "args": [],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "arc4maybeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
          "lines": "500-507",
          "snippet": "static __inline void\narc4maybeinit(void)\n{\n\tif (!arc4random_initialized) {\n\t\tarc4random_initialized++;\n\t\tarc4_stir();\n\t}\n}",
          "includes": [
            "#include <dev/rndioctl.h>",
            "#include <dev/rndvar.h>",
            "#include <sys/timeout.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/md5k.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/disk.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int arc4random_initialized;",
            "void arc4_stir"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint arc4random_initialized;\nvoid arc4_stir;\n\nstatic __inline void\narc4maybeinit(void)\n{\n\tif (!arc4random_initialized) {\n\t\tarc4random_initialized++;\n\t\tarc4_stir();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline u_int8_t arc4_getbyte;\n\nu_int32_t\narc4random(void)\n{\n\tarc4maybeinit();\n\treturn ((arc4_getbyte() << 24) | (arc4_getbyte() << 16)\n\t\t| (arc4_getbyte() << 8) | arc4_getbyte());\n}"
  },
  {
    "function_name": "arc4random_8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
    "lines": "519-524",
    "snippet": "int\narc4random_8(void)\n{\n\tarc4maybeinit();\n\treturn arc4_getbyte();\n}",
    "includes": [
      "#include <dev/rndioctl.h>",
      "#include <dev/rndvar.h>",
      "#include <sys/timeout.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/md5k.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/disk.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline u_int8_t arc4_getbyte"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arc4_getbyte",
          "args": [],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "arc4_getbyte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
          "lines": "484-498",
          "snippet": "static __inline u_int8_t\narc4_getbyte(void)\n{\n\tregister u_int8_t si, sj;\n\n\trndstats.arc4_reads++;\n\tarc4random_state.cnt++;\n\tarc4random_state.i++;\n\tsi = arc4random_state.s[arc4random_state.i];\n\tarc4random_state.j += si;\n\tsj = arc4random_state.s[arc4random_state.j];\n\tarc4random_state.s[arc4random_state.i] = sj;\n\tarc4random_state.s[arc4random_state.j] = si;\n\treturn arc4random_state.s[(si + sj) & 0xff];\n}",
          "includes": [
            "#include <dev/rndioctl.h>",
            "#include <dev/rndvar.h>",
            "#include <sys/timeout.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/md5k.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/disk.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct arc4_stream arc4random_state;",
            "struct rndstats rndstats;",
            "__P((register u_int8_t *, int));",
            "static __inline u_int8_t arc4_getbyte"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct arc4_stream arc4random_state;\nstruct rndstats rndstats;\n__P((register u_int8_t *, int));\nstatic __inline u_int8_t arc4_getbyte;\n\nstatic __inline u_int8_t\narc4_getbyte(void)\n{\n\tregister u_int8_t si, sj;\n\n\trndstats.arc4_reads++;\n\tarc4random_state.cnt++;\n\tarc4random_state.i++;\n\tsi = arc4random_state.s[arc4random_state.i];\n\tarc4random_state.j += si;\n\tsj = arc4random_state.s[arc4random_state.j];\n\tarc4random_state.s[arc4random_state.i] = sj;\n\tarc4random_state.s[arc4random_state.j] = si;\n\treturn arc4random_state.s[(si + sj) & 0xff];\n}"
        }
      },
      {
        "call_info": {
          "callee": "arc4maybeinit",
          "args": [],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "arc4maybeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
          "lines": "500-507",
          "snippet": "static __inline void\narc4maybeinit(void)\n{\n\tif (!arc4random_initialized) {\n\t\tarc4random_initialized++;\n\t\tarc4_stir();\n\t}\n}",
          "includes": [
            "#include <dev/rndioctl.h>",
            "#include <dev/rndvar.h>",
            "#include <sys/timeout.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/md5k.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/disk.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int arc4random_initialized;",
            "void arc4_stir"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint arc4random_initialized;\nvoid arc4_stir;\n\nstatic __inline void\narc4maybeinit(void)\n{\n\tif (!arc4random_initialized) {\n\t\tarc4random_initialized++;\n\t\tarc4_stir();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline u_int8_t arc4_getbyte;\n\nint\narc4random_8(void)\n{\n\tarc4maybeinit();\n\treturn arc4_getbyte();\n}"
  },
  {
    "function_name": "arc4_reinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
    "lines": "509-517",
    "snippet": "void\narc4_reinit(v)\n\tvoid *v;\n{\n\textern int hz;\n\n\tarc4random_initialized = 0;\n\ttimeout_add(&arc4_timeout, 10*60*hz);\n}",
    "includes": [
      "#include <dev/rndioctl.h>",
      "#include <dev/rndvar.h>",
      "#include <sys/timeout.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/md5k.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/disk.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct timeout rnd_timeout, arc4_timeout;",
      "int arc4random_initialized;",
      "void arc4_reinit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout_add",
          "args": [
            "&arc4_timeout",
            "10*60*hz"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct timeout rnd_timeout, arc4_timeout;\nint arc4random_initialized;\nvoid arc4_reinit;\n\nvoid\narc4_reinit(v)\n\tvoid *v;\n{\n\textern int hz;\n\n\tarc4random_initialized = 0;\n\ttimeout_add(&arc4_timeout, 10*60*hz);\n}"
  },
  {
    "function_name": "arc4maybeinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
    "lines": "500-507",
    "snippet": "static __inline void\narc4maybeinit(void)\n{\n\tif (!arc4random_initialized) {\n\t\tarc4random_initialized++;\n\t\tarc4_stir();\n\t}\n}",
    "includes": [
      "#include <dev/rndioctl.h>",
      "#include <dev/rndvar.h>",
      "#include <sys/timeout.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/md5k.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/disk.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int arc4random_initialized;",
      "void arc4_stir"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arc4_stir",
          "args": [],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "arc4_stir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
          "lines": "452-482",
          "snippet": "void\narc4_stir(void)\n{\n\tu_int8_t buf[256];\n\tregister u_int8_t si;\n\tregister int n, s;\n\tint len;\n\n\tmicrotime((struct timeval *) buf);\n\tlen = random_state.entropy_count / 8; /* XXX maybe a half? */\n\tif (len > sizeof(buf) - sizeof(struct timeval))\n\t\tlen = sizeof(buf) - sizeof(struct timeval);\n\tget_random_bytes(buf + sizeof (struct timeval), len);\n\tlen += sizeof(struct timeval);\n\n\ts = splhigh();\n\tarc4random_state.i--;\n\tfor (n = 0; n < 256; n++) {\n\t\tarc4random_state.i++;\n\t\tsi = arc4random_state.s[arc4random_state.i];\n\t\tarc4random_state.j += si + buf[n % len];\n\t\tarc4random_state.s[arc4random_state.i] =\n\t\t    arc4random_state.s[arc4random_state.j];\n\t\tarc4random_state.s[arc4random_state.j] = si;\n\t}\n\tarc4random_state.j = arc4random_state.i;\n\tarc4random_state.cnt = 0;\n\trndstats.arc4_stirs += len;\n\trndstats.arc4_nstirs++;\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/rndioctl.h>",
            "#include <dev/rndvar.h>",
            "#include <sys/timeout.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/md5k.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/disk.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct random_bucket random_state;",
            "struct arc4_stream arc4random_state;",
            "struct rndstats rndstats;",
            "__P((register u_int8_t *, int));",
            "void arc4_stir"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct random_bucket random_state;\nstruct arc4_stream arc4random_state;\nstruct rndstats rndstats;\n__P((register u_int8_t *, int));\nvoid arc4_stir;\n\nvoid\narc4_stir(void)\n{\n\tu_int8_t buf[256];\n\tregister u_int8_t si;\n\tregister int n, s;\n\tint len;\n\n\tmicrotime((struct timeval *) buf);\n\tlen = random_state.entropy_count / 8; /* XXX maybe a half? */\n\tif (len > sizeof(buf) - sizeof(struct timeval))\n\t\tlen = sizeof(buf) - sizeof(struct timeval);\n\tget_random_bytes(buf + sizeof (struct timeval), len);\n\tlen += sizeof(struct timeval);\n\n\ts = splhigh();\n\tarc4random_state.i--;\n\tfor (n = 0; n < 256; n++) {\n\t\tarc4random_state.i++;\n\t\tsi = arc4random_state.s[arc4random_state.i];\n\t\tarc4random_state.j += si + buf[n % len];\n\t\tarc4random_state.s[arc4random_state.i] =\n\t\t    arc4random_state.s[arc4random_state.j];\n\t\tarc4random_state.s[arc4random_state.j] = si;\n\t}\n\tarc4random_state.j = arc4random_state.i;\n\tarc4random_state.cnt = 0;\n\trndstats.arc4_stirs += len;\n\trndstats.arc4_nstirs++;\n\tsplx(s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint arc4random_initialized;\nvoid arc4_stir;\n\nstatic __inline void\narc4maybeinit(void)\n{\n\tif (!arc4random_initialized) {\n\t\tarc4random_initialized++;\n\t\tarc4_stir();\n\t}\n}"
  },
  {
    "function_name": "arc4_getbyte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
    "lines": "484-498",
    "snippet": "static __inline u_int8_t\narc4_getbyte(void)\n{\n\tregister u_int8_t si, sj;\n\n\trndstats.arc4_reads++;\n\tarc4random_state.cnt++;\n\tarc4random_state.i++;\n\tsi = arc4random_state.s[arc4random_state.i];\n\tarc4random_state.j += si;\n\tsj = arc4random_state.s[arc4random_state.j];\n\tarc4random_state.s[arc4random_state.i] = sj;\n\tarc4random_state.s[arc4random_state.j] = si;\n\treturn arc4random_state.s[(si + sj) & 0xff];\n}",
    "includes": [
      "#include <dev/rndioctl.h>",
      "#include <dev/rndvar.h>",
      "#include <sys/timeout.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/md5k.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/disk.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct arc4_stream arc4random_state;",
      "struct rndstats rndstats;",
      "__P((register u_int8_t *, int));",
      "static __inline u_int8_t arc4_getbyte"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct arc4_stream arc4random_state;\nstruct rndstats rndstats;\n__P((register u_int8_t *, int));\nstatic __inline u_int8_t arc4_getbyte;\n\nstatic __inline u_int8_t\narc4_getbyte(void)\n{\n\tregister u_int8_t si, sj;\n\n\trndstats.arc4_reads++;\n\tarc4random_state.cnt++;\n\tarc4random_state.i++;\n\tsi = arc4random_state.s[arc4random_state.i];\n\tarc4random_state.j += si;\n\tsj = arc4random_state.s[arc4random_state.j];\n\tarc4random_state.s[arc4random_state.i] = sj;\n\tarc4random_state.s[arc4random_state.j] = si;\n\treturn arc4random_state.s[(si + sj) & 0xff];\n}"
  },
  {
    "function_name": "arc4_stir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
    "lines": "452-482",
    "snippet": "void\narc4_stir(void)\n{\n\tu_int8_t buf[256];\n\tregister u_int8_t si;\n\tregister int n, s;\n\tint len;\n\n\tmicrotime((struct timeval *) buf);\n\tlen = random_state.entropy_count / 8; /* XXX maybe a half? */\n\tif (len > sizeof(buf) - sizeof(struct timeval))\n\t\tlen = sizeof(buf) - sizeof(struct timeval);\n\tget_random_bytes(buf + sizeof (struct timeval), len);\n\tlen += sizeof(struct timeval);\n\n\ts = splhigh();\n\tarc4random_state.i--;\n\tfor (n = 0; n < 256; n++) {\n\t\tarc4random_state.i++;\n\t\tsi = arc4random_state.s[arc4random_state.i];\n\t\tarc4random_state.j += si + buf[n % len];\n\t\tarc4random_state.s[arc4random_state.i] =\n\t\t    arc4random_state.s[arc4random_state.j];\n\t\tarc4random_state.s[arc4random_state.j] = si;\n\t}\n\tarc4random_state.j = arc4random_state.i;\n\tarc4random_state.cnt = 0;\n\trndstats.arc4_stirs += len;\n\trndstats.arc4_nstirs++;\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/rndioctl.h>",
      "#include <dev/rndvar.h>",
      "#include <sys/timeout.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/md5k.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/disk.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct random_bucket random_state;",
      "struct arc4_stream arc4random_state;",
      "struct rndstats rndstats;",
      "__P((register u_int8_t *, int));",
      "void arc4_stir"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "buf + sizeof (struct timeval)",
            "len"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "get_random_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
          "lines": "901-908",
          "snippet": "void\nget_random_bytes(buf, nbytes)\n\tvoid\t*buf;\n\tsize_t\tnbytes;\n{\n\textract_entropy((u_int8_t *) buf, nbytes);\n\trndstats.rnd_used += nbytes * 8;\n}",
          "includes": [
            "#include <dev/rndioctl.h>",
            "#include <dev/rndvar.h>",
            "#include <sys/timeout.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/md5k.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/disk.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rndstats rndstats;",
            "static __inline void extract_entropy",
            "__P((register u_int8_t *, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct rndstats rndstats;\nstatic __inline void extract_entropy;\n__P((register u_int8_t *, int));\n\nvoid\nget_random_bytes(buf, nbytes)\n\tvoid\t*buf;\n\tsize_t\tnbytes;\n{\n\textract_entropy((u_int8_t *) buf, nbytes);\n\trndstats.rnd_used += nbytes * 8;\n}"
        }
      },
      {
        "call_info": {
          "callee": "microtime",
          "args": [
            "(struct timeval *) buf"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct random_bucket random_state;\nstruct arc4_stream arc4random_state;\nstruct rndstats rndstats;\n__P((register u_int8_t *, int));\nvoid arc4_stir;\n\nvoid\narc4_stir(void)\n{\n\tu_int8_t buf[256];\n\tregister u_int8_t si;\n\tregister int n, s;\n\tint len;\n\n\tmicrotime((struct timeval *) buf);\n\tlen = random_state.entropy_count / 8; /* XXX maybe a half? */\n\tif (len > sizeof(buf) - sizeof(struct timeval))\n\t\tlen = sizeof(buf) - sizeof(struct timeval);\n\tget_random_bytes(buf + sizeof (struct timeval), len);\n\tlen += sizeof(struct timeval);\n\n\ts = splhigh();\n\tarc4random_state.i--;\n\tfor (n = 0; n < 256; n++) {\n\t\tarc4random_state.i++;\n\t\tsi = arc4random_state.s[arc4random_state.i];\n\t\tarc4random_state.j += si + buf[n % len];\n\t\tarc4random_state.s[arc4random_state.i] =\n\t\t    arc4random_state.s[arc4random_state.j];\n\t\tarc4random_state.s[arc4random_state.j] = si;\n\t}\n\tarc4random_state.j = arc4random_state.i;\n\tarc4random_state.cnt = 0;\n\trndstats.arc4_stirs += len;\n\trndstats.arc4_nstirs++;\n\tsplx(s);\n}"
  },
  {
    "function_name": "roll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
    "lines": "415-423",
    "snippet": "static __inline u_int32_t roll(u_int32_t w, int i)\n{\n#ifdef i386\n\t__asm (\"roll %%cl, %0\" : \"+r\" (w) : \"c\" (i));\n#else\n\tw = (w << i) | (w >> (32 - i));\n#endif\n\treturn w;\n}",
    "includes": [
      "#include <dev/rndioctl.h>",
      "#include <dev/rndvar.h>",
      "#include <sys/timeout.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/md5k.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/disk.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline u_int32_t roll(u_int32_t w, int i)\n{\n#ifdef i386\n\t__asm (\"roll %%cl, %0\" : \"+r\" (w) : \"c\" (i));\n#else\n\tw = (w << i) | (w >> (32 - i));\n#endif\n\treturn w;\n}"
  }
]