[
  {
    "function_name": "epmbufempty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "1487-1503",
    "snippet": "void\nepmbufempty(sc)\n\tstruct ep_softc *sc;\n{\n\tint s, i;\n\n\ts = splnet();\n\tfor (i = 0; i<MAX_MBS; i++) {\n\t\tif (sc->mb[i]) {\n\t\t\tm_freem(sc->mb[i]);\n\t\t\tsc->mb[i] = NULL;\n\t\t}\n\t}\n\tsc->last_mb = sc->next_mb = 0;\n\tuntimeout(epmbuffill, sc);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [
      "#define MAX_MBS\t8\t\t\t/* # of mbufs we keep around\t*/"
    ],
    "globals_used": [
      "void epmbuffill",
      "void epmbufempty",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "epmbuffill",
            "sc"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->mb[i]"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define MAX_MBS\t8\t\t\t/* # of mbufs we keep around\t*/\n\nvoid epmbuffill;\nvoid epmbufempty;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepmbufempty(sc)\n\tstruct ep_softc *sc;\n{\n\tint s, i;\n\n\ts = splnet();\n\tfor (i = 0; i<MAX_MBS; i++) {\n\t\tif (sc->mb[i]) {\n\t\t\tm_freem(sc->mb[i]);\n\t\t\tsc->mb[i] = NULL;\n\t\t}\n\t}\n\tsc->last_mb = sc->next_mb = 0;\n\tuntimeout(epmbuffill, sc);\n\tsplx(s);\n}"
  },
  {
    "function_name": "epmbuffill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "1464-1485",
    "snippet": "void\nepmbuffill(arg)\n\tvoid *arg;\n{\n\tstruct ep_softc *sc = arg;\n\tint s, i;\n\n\ts = splnet();\n\ti = sc->last_mb;\n\tdo {\n\t\tif (sc->mb[i] == NULL)\n\t\t\tMGET(sc->mb[i], M_DONTWAIT, MT_DATA);\n\t\tif (sc->mb[i] == NULL)\n\t\t\tbreak;\n\t\ti = (i + 1) % MAX_MBS;\n\t} while (i != sc->next_mb);\n\tsc->last_mb = i;\n\t/* If the queue was not filled, try again. */\n\tif (sc->last_mb != sc->next_mb)\n\t\ttimeout(epmbuffill, sc, 1);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [
      "#define MAX_MBS\t8\t\t\t/* # of mbufs we keep around\t*/"
    ],
    "globals_used": [
      "void epmbuffill",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "epmbuffill",
            "sc",
            "1"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "bt_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1300-1345",
          "snippet": "void\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
          ],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_queue_ccb",
            "void bt_collect_mbo",
            "void bt_timeout",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_queue_ccb;\nvoid bt_collect_mbo;\nvoid bt_timeout;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MGET",
          "args": [
            "sc->mb[i]",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define MAX_MBS\t8\t\t\t/* # of mbufs we keep around\t*/\n\nvoid epmbuffill;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepmbuffill(arg)\n\tvoid *arg;\n{\n\tstruct ep_softc *sc = arg;\n\tint s, i;\n\n\ts = splnet();\n\ti = sc->last_mb;\n\tdo {\n\t\tif (sc->mb[i] == NULL)\n\t\t\tMGET(sc->mb[i], M_DONTWAIT, MT_DATA);\n\t\tif (sc->mb[i] == NULL)\n\t\t\tbreak;\n\t\ti = (i + 1) % MAX_MBS;\n\t} while (i != sc->next_mb);\n\tsc->last_mb = i;\n\t/* If the queue was not filled, try again. */\n\tif (sc->last_mb != sc->next_mb)\n\t\ttimeout(epmbuffill, sc, 1);\n\tsplx(s);\n}"
  },
  {
    "function_name": "epbusyeeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "1433-1462",
    "snippet": "static int\nepbusyeeprom(sc)\n\tstruct ep_softc *sc;\n{\n\tint i = 100, j;\n\n\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\tdelay(1000);\n\t\treturn 0;\n\t}\n\n\twhile (i--) {\n\t\tj = inw(BASE + EP_W0_EEPROM_COMMAND);\n\t\tif (j & EEPROM_BUSY)\n\t\t\tdelay(100);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!i) {\n\t\tprintf(\"\\n%s: eeprom failed to come ready\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\tif (j & EEPROM_TST_MODE) {\n\t\tprintf(\"\\n%s: erase pencil mark, or disable plug-n-play mode!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [
      "#define\tEP_BUS_PCMCIA\t  \t0x1"
    ],
    "globals_used": [
      "static int epbusyeeprom",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n%s: erase pencil mark, or disable plug-n-play mode!\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "BASE + EP_W0_EEPROM_COMMAND"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define\tEP_BUS_PCMCIA\t  \t0x1\n\nstatic int epbusyeeprom;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nstatic int\nepbusyeeprom(sc)\n\tstruct ep_softc *sc;\n{\n\tint i = 100, j;\n\n\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\tdelay(1000);\n\t\treturn 0;\n\t}\n\n\twhile (i--) {\n\t\tj = inw(BASE + EP_W0_EEPROM_COMMAND);\n\t\tif (j & EEPROM_BUSY)\n\t\t\tdelay(100);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!i) {\n\t\tprintf(\"\\n%s: eeprom failed to come ready\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\tif (j & EEPROM_TST_MODE) {\n\t\tprintf(\"\\n%s: erase pencil mark, or disable plug-n-play mode!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "epreadeeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "1419-1431",
    "snippet": "static u_short\nepreadeeprom(id_port, offset)\n\tint     id_port;\n\tint     offset;\n{\n\tint i, data = 0;\n\n\toutb(id_port, 0x80 + offset);\n\tdelay(1000);\n\tfor (i = 0; i < 16; i++)\n\t\tdata = (data << 1) | (inw(id_port) & 1);\n\treturn (data);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u_short epreadeeprom",
      "__P((int id_port, int offset));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "id_port"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "id_port",
            "0x80 + offset"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nstatic u_short epreadeeprom;\n__P((int id_port, int offset));\n\nstatic u_short\nepreadeeprom(id_port, offset)\n\tint     id_port;\n\tint     offset;\n{\n\tint i, data = 0;\n\n\toutb(id_port, 0x80 + offset);\n\tdelay(1000);\n\tfor (i = 0; i < 16; i++)\n\t\tdata = (data << 1) | (inw(id_port) & 1);\n\treturn (data);\n}"
  },
  {
    "function_name": "epstop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "1384-1403",
    "snippet": "void\nepstop(sc)\n\tregister struct ep_softc *sc;\n{\n\n\toutw(BASE + EP_COMMAND, RX_DISABLE);\n\toutw(BASE + EP_COMMAND, RX_DISCARD_TOP_PACK);\n\twhile (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\toutw(BASE + EP_COMMAND, TX_DISABLE);\n\toutw(BASE + EP_COMMAND, STOP_TRANSCEIVER);\n\toutw(BASE + EP_COMMAND, RX_RESET);\n\toutw(BASE + EP_COMMAND, TX_RESET);\n\toutw(BASE + EP_COMMAND, C_INTR_LATCH);\n\toutw(BASE + EP_COMMAND, SET_RD_0_MASK);\n\toutw(BASE + EP_COMMAND, SET_INTR_MASK);\n\toutw(BASE + EP_COMMAND, SET_RX_FILTER);\n\n\tepmbufempty(sc);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void epmbufempty",
      "void epstop",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "epmbufempty",
          "args": [
            "sc"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "epmbufempty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "1487-1503",
          "snippet": "void\nepmbufempty(sc)\n\tstruct ep_softc *sc;\n{\n\tint s, i;\n\n\ts = splnet();\n\tfor (i = 0; i<MAX_MBS; i++) {\n\t\tif (sc->mb[i]) {\n\t\t\tm_freem(sc->mb[i]);\n\t\t\tsc->mb[i] = NULL;\n\t\t}\n\t}\n\tsc->last_mb = sc->next_mb = 0;\n\tuntimeout(epmbuffill, sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [
            "#define MAX_MBS\t8\t\t\t/* # of mbufs we keep around\t*/"
          ],
          "globals_used": [
            "void epmbuffill",
            "void epmbufempty",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define MAX_MBS\t8\t\t\t/* # of mbufs we keep around\t*/\n\nvoid epmbuffill;\nvoid epmbufempty;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepmbufempty(sc)\n\tstruct ep_softc *sc;\n{\n\tint s, i;\n\n\ts = splnet();\n\tfor (i = 0; i<MAX_MBS; i++) {\n\t\tif (sc->mb[i]) {\n\t\t\tm_freem(sc->mb[i]);\n\t\t\tsc->mb[i] = NULL;\n\t\t}\n\t}\n\tsc->last_mb = sc->next_mb = 0;\n\tuntimeout(epmbuffill, sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "SET_RX_FILTER"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "SET_INTR_MASK"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "SET_RD_0_MASK"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "C_INTR_LATCH"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "TX_RESET"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "RX_RESET"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "STOP_TRANSCEIVER"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "TX_DISABLE"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "BASE + EP_STATUS"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "RX_DISCARD_TOP_PACK"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "RX_DISABLE"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nvoid epmbufempty;\nvoid epstop;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepstop(sc)\n\tregister struct ep_softc *sc;\n{\n\n\toutw(BASE + EP_COMMAND, RX_DISABLE);\n\toutw(BASE + EP_COMMAND, RX_DISCARD_TOP_PACK);\n\twhile (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\toutw(BASE + EP_COMMAND, TX_DISABLE);\n\toutw(BASE + EP_COMMAND, STOP_TRANSCEIVER);\n\toutw(BASE + EP_COMMAND, RX_RESET);\n\toutw(BASE + EP_COMMAND, TX_RESET);\n\toutw(BASE + EP_COMMAND, C_INTR_LATCH);\n\toutw(BASE + EP_COMMAND, SET_RD_0_MASK);\n\toutw(BASE + EP_COMMAND, SET_INTR_MASK);\n\toutw(BASE + EP_COMMAND, SET_RX_FILTER);\n\n\tepmbufempty(sc);\n}"
  },
  {
    "function_name": "epwatchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "1372-1382",
    "snippet": "void\nepwatchdog(unit)\n\tint unit;\n{\n\tstruct ep_softc *sc = ep_cd.cd_devs[unit];\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++sc->sc_arpcom.ac_if.if_oerrors;\n\n\tepreset(sc);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver ep_cd = {\n\tNULL, \"ep\", DV_IFNET\n};",
      "void epwatchdog",
      "void epreset",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "epreset",
          "args": [
            "sc"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "epreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "1360-1370",
          "snippet": "void\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void epinit",
            "void epreset",
            "void epstop",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nvoid epinit;\nvoid epreset;\nvoid epstop;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: device timeout\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nstruct cfdriver ep_cd = {\n\tNULL, \"ep\", DV_IFNET\n};\nvoid epwatchdog;\nvoid epreset;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepwatchdog(unit)\n\tint unit;\n{\n\tstruct ep_softc *sc = ep_cd.cd_devs[unit];\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++sc->sc_arpcom.ac_if.if_oerrors;\n\n\tepreset(sc);\n}"
  },
  {
    "function_name": "epreset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "1360-1370",
    "snippet": "void\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void epinit",
      "void epreset",
      "void epstop",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epinit",
          "args": [
            "sc"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "epinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "660-723",
          "snippet": "void\nepinit(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i;\n\n\twhile (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\n\tif (sc->bustype != EP_BUS_PCI) {\n\t\tGO_WINDOW(0);\n\t\toutw(BASE + EP_W0_CONFIG_CTRL, 0);\n\t\toutw(BASE + EP_W0_CONFIG_CTRL, ENABLE_DRQ_IRQ);\n\t}\n\n\tif (sc->bustype == EP_BUS_PCMCIA) {\n#ifdef EP_COAX_DEFAULT\n\t\toutw(BASE + EP_W0_ADDRESS_CFG,3<<14);\n#else\n\t\toutw(BASE + EP_W0_ADDRESS_CFG,0<<14);\n#endif\n\t\toutw(BASE + EP_W0_RESOURCE_CFG, 0x3f00);\n\t}\n\n\tGO_WINDOW(2);\n\tfor (i = 0; i < 6; i++)\t/* Reload the ether_addr. */\n\t\toutb(BASE + EP_W2_ADDR_0 + i, sc->sc_arpcom.ac_enaddr[i]);\n\n\toutw(BASE + EP_COMMAND, RX_RESET);\n\toutw(BASE + EP_COMMAND, TX_RESET);\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\tfor (i = 0; i < 31; i++)\n\t\tinb(BASE + EP_W1_TX_STATUS);\n\n\toutw(BASE + EP_COMMAND, SET_RD_0_MASK | S_CARD_FAILURE | \n\t\t\t\tS_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\toutw(BASE + EP_COMMAND, SET_INTR_MASK | S_CARD_FAILURE |\n\t\t\t\tS_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\n\t/*\n\t * Attempt to get rid of any stray interrupts that occured during\n\t * configuration.  On the i386 this isn't possible because one may\n\t * already be queued.  However, a single stray interrupt is\n\t * unimportant.\n\t */\n\toutw(BASE + EP_COMMAND, ACK_INTR | 0xff);\n\n\tepsetfilter(sc);\n\tepsetlink(sc);\n\n\toutw(BASE + EP_COMMAND, RX_ENABLE);\n\toutw(BASE + EP_COMMAND, TX_ENABLE);\n\n\tepmbuffill(sc);\n\n\t/* Interface is now `running', with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Attempt to start output, if any. */\n\tepstart(ifp);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [
            "#define EP_BUS_PCI\t  \t0x3",
            "#define\tEP_BUS_PCMCIA\t  \t0x1"
          ],
          "globals_used": [
            "void epinit",
            "void epstart",
            "void epmbuffill",
            "void epsetfilter",
            "void epsetlink",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define EP_BUS_PCI\t  \t0x3\n#define\tEP_BUS_PCMCIA\t  \t0x1\n\nvoid epinit;\nvoid epstart;\nvoid epmbuffill;\nvoid epsetfilter;\nvoid epsetlink;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepinit(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i;\n\n\twhile (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\n\tif (sc->bustype != EP_BUS_PCI) {\n\t\tGO_WINDOW(0);\n\t\toutw(BASE + EP_W0_CONFIG_CTRL, 0);\n\t\toutw(BASE + EP_W0_CONFIG_CTRL, ENABLE_DRQ_IRQ);\n\t}\n\n\tif (sc->bustype == EP_BUS_PCMCIA) {\n#ifdef EP_COAX_DEFAULT\n\t\toutw(BASE + EP_W0_ADDRESS_CFG,3<<14);\n#else\n\t\toutw(BASE + EP_W0_ADDRESS_CFG,0<<14);\n#endif\n\t\toutw(BASE + EP_W0_RESOURCE_CFG, 0x3f00);\n\t}\n\n\tGO_WINDOW(2);\n\tfor (i = 0; i < 6; i++)\t/* Reload the ether_addr. */\n\t\toutb(BASE + EP_W2_ADDR_0 + i, sc->sc_arpcom.ac_enaddr[i]);\n\n\toutw(BASE + EP_COMMAND, RX_RESET);\n\toutw(BASE + EP_COMMAND, TX_RESET);\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\tfor (i = 0; i < 31; i++)\n\t\tinb(BASE + EP_W1_TX_STATUS);\n\n\toutw(BASE + EP_COMMAND, SET_RD_0_MASK | S_CARD_FAILURE | \n\t\t\t\tS_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\toutw(BASE + EP_COMMAND, SET_INTR_MASK | S_CARD_FAILURE |\n\t\t\t\tS_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\n\t/*\n\t * Attempt to get rid of any stray interrupts that occured during\n\t * configuration.  On the i386 this isn't possible because one may\n\t * already be queued.  However, a single stray interrupt is\n\t * unimportant.\n\t */\n\toutw(BASE + EP_COMMAND, ACK_INTR | 0xff);\n\n\tepsetfilter(sc);\n\tepsetlink(sc);\n\n\toutw(BASE + EP_COMMAND, RX_ENABLE);\n\toutw(BASE + EP_COMMAND, TX_ENABLE);\n\n\tepmbuffill(sc);\n\n\t/* Interface is now `running', with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Attempt to start output, if any. */\n\tepstart(ifp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "epstop",
          "args": [
            "sc"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "epstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "1384-1403",
          "snippet": "void\nepstop(sc)\n\tregister struct ep_softc *sc;\n{\n\n\toutw(BASE + EP_COMMAND, RX_DISABLE);\n\toutw(BASE + EP_COMMAND, RX_DISCARD_TOP_PACK);\n\twhile (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\toutw(BASE + EP_COMMAND, TX_DISABLE);\n\toutw(BASE + EP_COMMAND, STOP_TRANSCEIVER);\n\toutw(BASE + EP_COMMAND, RX_RESET);\n\toutw(BASE + EP_COMMAND, TX_RESET);\n\toutw(BASE + EP_COMMAND, C_INTR_LATCH);\n\toutw(BASE + EP_COMMAND, SET_RD_0_MASK);\n\toutw(BASE + EP_COMMAND, SET_INTR_MASK);\n\toutw(BASE + EP_COMMAND, SET_RX_FILTER);\n\n\tepmbufempty(sc);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void epmbufempty",
            "void epstop",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nvoid epmbufempty;\nvoid epstop;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepstop(sc)\n\tregister struct ep_softc *sc;\n{\n\n\toutw(BASE + EP_COMMAND, RX_DISABLE);\n\toutw(BASE + EP_COMMAND, RX_DISCARD_TOP_PACK);\n\twhile (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\toutw(BASE + EP_COMMAND, TX_DISABLE);\n\toutw(BASE + EP_COMMAND, STOP_TRANSCEIVER);\n\toutw(BASE + EP_COMMAND, RX_RESET);\n\toutw(BASE + EP_COMMAND, TX_RESET);\n\toutw(BASE + EP_COMMAND, C_INTR_LATCH);\n\toutw(BASE + EP_COMMAND, SET_RD_0_MASK);\n\toutw(BASE + EP_COMMAND, SET_INTR_MASK);\n\toutw(BASE + EP_COMMAND, SET_RX_FILTER);\n\n\tepmbufempty(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nvoid epinit;\nvoid epreset;\nvoid epstop;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}"
  },
  {
    "function_name": "epioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "1264-1358",
    "snippet": "int\nepioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ep_softc *sc = ep_cd.cd_devs[ifp->if_unit];\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tif (sc->bustype == EP_BUS_PCMCIA &&\n\t    (sc->pcmcia_flags & EP_ABSENT)) {\n\t    if_down(ifp);\n\t    printf(\"%s: device offline\\n\", sc->sc_dev.dv_xname);\n\t    splx(s);\n\t    return ENXIO;\n\t}\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tepinit(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tepinit(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tepstop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tepinit(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * deal with flags changes:\n\t\t\t * IFF_MULTICAST, IFF_PROMISC,\n\t\t\t * IFF_LINK0, IFF_LINK1,\n\t\t\t */\n\t\t\tepsetfilter(sc);\n\t\t\tepsetlink(sc);\n\t\t}\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom) :\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tepreset(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [
      "#define EP_ABSENT\t\t0x02",
      "#define\tEP_BUS_PCMCIA\t  \t0x1"
    ],
    "globals_used": [
      "struct cfdriver ep_cd = {\n\tNULL, \"ep\", DV_IFNET\n};",
      "void epinit",
      "int epioctl",
      "void epreset",
      "void epstop",
      "void epsetfilter",
      "void epsetlink",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epreset",
          "args": [
            "sc"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "epreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "1360-1370",
          "snippet": "void\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void epinit",
            "void epreset",
            "void epstop",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nvoid epinit;\nvoid epreset;\nvoid epstop;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epsetlink",
          "args": [
            "sc"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "epsetlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "738-776",
          "snippet": "void\nepsetlink(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\t/*\n\t * you can `ifconfig (link0|-link0) ep0' to get the following\n\t * behaviour:\n\t *\t-link0\tdisable AUI/UTP. enable BNC.\n\t *\tlink0\tdisable BNC. enable AUI.\n\t *\tlink1\tif the card has a UTP connector, and link0 is\n\t *\t\tset too, then you get the UTP port.\n\t */\n\tGO_WINDOW(4);\n\toutw(BASE + EP_W4_MEDIA_TYPE, DISABLE_UTP);\n\tif (!(ifp->if_flags & IFF_LINK0) && (sc->ep_connectors & BNC)) {\n\t\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\t\tGO_WINDOW(0);\n\t\t\toutw(BASE + EP_W0_ADDRESS_CFG,3<<14);\n\t\t\tGO_WINDOW(1);\n\t\t}\n\t\toutw(BASE + EP_COMMAND, START_TRANSCEIVER);\n\t\tdelay(1000);\n\t}\n\tif (ifp->if_flags & IFF_LINK0) {\n\t\toutw(BASE + EP_COMMAND, STOP_TRANSCEIVER);\n\t\tdelay(1000);\n\t\tif ((ifp->if_flags & IFF_LINK1) && (sc->ep_connectors & UTP)) {\n\t\t\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\t\t\tGO_WINDOW(0);\n\t\t\t\toutw(BASE + EP_W0_ADDRESS_CFG,0<<14);\n\t\t\t\tGO_WINDOW(4);\n\t\t\t}\n\t\t\toutw(BASE + EP_W4_MEDIA_TYPE, ENABLE_UTP);\n\t\t}\n\t}\n\tGO_WINDOW(1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [
            "#define\tEP_BUS_PCMCIA\t  \t0x1"
          ],
          "globals_used": [
            "void epsetlink",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define\tEP_BUS_PCMCIA\t  \t0x1\n\nvoid epsetlink;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepsetlink(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\t/*\n\t * you can `ifconfig (link0|-link0) ep0' to get the following\n\t * behaviour:\n\t *\t-link0\tdisable AUI/UTP. enable BNC.\n\t *\tlink0\tdisable BNC. enable AUI.\n\t *\tlink1\tif the card has a UTP connector, and link0 is\n\t *\t\tset too, then you get the UTP port.\n\t */\n\tGO_WINDOW(4);\n\toutw(BASE + EP_W4_MEDIA_TYPE, DISABLE_UTP);\n\tif (!(ifp->if_flags & IFF_LINK0) && (sc->ep_connectors & BNC)) {\n\t\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\t\tGO_WINDOW(0);\n\t\t\toutw(BASE + EP_W0_ADDRESS_CFG,3<<14);\n\t\t\tGO_WINDOW(1);\n\t\t}\n\t\toutw(BASE + EP_COMMAND, START_TRANSCEIVER);\n\t\tdelay(1000);\n\t}\n\tif (ifp->if_flags & IFF_LINK0) {\n\t\toutw(BASE + EP_COMMAND, STOP_TRANSCEIVER);\n\t\tdelay(1000);\n\t\tif ((ifp->if_flags & IFF_LINK1) && (sc->ep_connectors & UTP)) {\n\t\t\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\t\t\tGO_WINDOW(0);\n\t\t\t\toutw(BASE + EP_W0_ADDRESS_CFG,0<<14);\n\t\t\t\tGO_WINDOW(4);\n\t\t\t}\n\t\t\toutw(BASE + EP_W4_MEDIA_TYPE, ENABLE_UTP);\n\t\t}\n\t}\n\tGO_WINDOW(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "epsetfilter",
          "args": [
            "sc"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "epsetfilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "725-736",
          "snippet": "void\nepsetfilter(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\toutw(BASE + EP_COMMAND, SET_RX_FILTER |\n\t    FIL_INDIVIDUAL | FIL_BRDCST |\n\t    ((ifp->if_flags & IFF_MULTICAST) ? FIL_MULTICAST : 0 ) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? FIL_PROMISC : 0 ));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void epsetfilter",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nvoid epsetfilter;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepsetfilter(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\toutw(BASE + EP_COMMAND, SET_RX_FILTER |\n\t    FIL_INDIVIDUAL | FIL_BRDCST |\n\t    ((ifp->if_flags & IFF_MULTICAST) ? FIL_MULTICAST : 0 ) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? FIL_PROMISC : 0 ));\n}"
        }
      },
      {
        "call_info": {
          "callee": "epinit",
          "args": [
            "sc"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "epinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "660-723",
          "snippet": "void\nepinit(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i;\n\n\twhile (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\n\tif (sc->bustype != EP_BUS_PCI) {\n\t\tGO_WINDOW(0);\n\t\toutw(BASE + EP_W0_CONFIG_CTRL, 0);\n\t\toutw(BASE + EP_W0_CONFIG_CTRL, ENABLE_DRQ_IRQ);\n\t}\n\n\tif (sc->bustype == EP_BUS_PCMCIA) {\n#ifdef EP_COAX_DEFAULT\n\t\toutw(BASE + EP_W0_ADDRESS_CFG,3<<14);\n#else\n\t\toutw(BASE + EP_W0_ADDRESS_CFG,0<<14);\n#endif\n\t\toutw(BASE + EP_W0_RESOURCE_CFG, 0x3f00);\n\t}\n\n\tGO_WINDOW(2);\n\tfor (i = 0; i < 6; i++)\t/* Reload the ether_addr. */\n\t\toutb(BASE + EP_W2_ADDR_0 + i, sc->sc_arpcom.ac_enaddr[i]);\n\n\toutw(BASE + EP_COMMAND, RX_RESET);\n\toutw(BASE + EP_COMMAND, TX_RESET);\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\tfor (i = 0; i < 31; i++)\n\t\tinb(BASE + EP_W1_TX_STATUS);\n\n\toutw(BASE + EP_COMMAND, SET_RD_0_MASK | S_CARD_FAILURE | \n\t\t\t\tS_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\toutw(BASE + EP_COMMAND, SET_INTR_MASK | S_CARD_FAILURE |\n\t\t\t\tS_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\n\t/*\n\t * Attempt to get rid of any stray interrupts that occured during\n\t * configuration.  On the i386 this isn't possible because one may\n\t * already be queued.  However, a single stray interrupt is\n\t * unimportant.\n\t */\n\toutw(BASE + EP_COMMAND, ACK_INTR | 0xff);\n\n\tepsetfilter(sc);\n\tepsetlink(sc);\n\n\toutw(BASE + EP_COMMAND, RX_ENABLE);\n\toutw(BASE + EP_COMMAND, TX_ENABLE);\n\n\tepmbuffill(sc);\n\n\t/* Interface is now `running', with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Attempt to start output, if any. */\n\tepstart(ifp);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [
            "#define EP_BUS_PCI\t  \t0x3",
            "#define\tEP_BUS_PCMCIA\t  \t0x1"
          ],
          "globals_used": [
            "void epinit",
            "void epstart",
            "void epmbuffill",
            "void epsetfilter",
            "void epsetlink",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define EP_BUS_PCI\t  \t0x3\n#define\tEP_BUS_PCMCIA\t  \t0x1\n\nvoid epinit;\nvoid epstart;\nvoid epmbuffill;\nvoid epsetfilter;\nvoid epsetlink;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepinit(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i;\n\n\twhile (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\n\tif (sc->bustype != EP_BUS_PCI) {\n\t\tGO_WINDOW(0);\n\t\toutw(BASE + EP_W0_CONFIG_CTRL, 0);\n\t\toutw(BASE + EP_W0_CONFIG_CTRL, ENABLE_DRQ_IRQ);\n\t}\n\n\tif (sc->bustype == EP_BUS_PCMCIA) {\n#ifdef EP_COAX_DEFAULT\n\t\toutw(BASE + EP_W0_ADDRESS_CFG,3<<14);\n#else\n\t\toutw(BASE + EP_W0_ADDRESS_CFG,0<<14);\n#endif\n\t\toutw(BASE + EP_W0_RESOURCE_CFG, 0x3f00);\n\t}\n\n\tGO_WINDOW(2);\n\tfor (i = 0; i < 6; i++)\t/* Reload the ether_addr. */\n\t\toutb(BASE + EP_W2_ADDR_0 + i, sc->sc_arpcom.ac_enaddr[i]);\n\n\toutw(BASE + EP_COMMAND, RX_RESET);\n\toutw(BASE + EP_COMMAND, TX_RESET);\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\tfor (i = 0; i < 31; i++)\n\t\tinb(BASE + EP_W1_TX_STATUS);\n\n\toutw(BASE + EP_COMMAND, SET_RD_0_MASK | S_CARD_FAILURE | \n\t\t\t\tS_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\toutw(BASE + EP_COMMAND, SET_INTR_MASK | S_CARD_FAILURE |\n\t\t\t\tS_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\n\t/*\n\t * Attempt to get rid of any stray interrupts that occured during\n\t * configuration.  On the i386 this isn't possible because one may\n\t * already be queued.  However, a single stray interrupt is\n\t * unimportant.\n\t */\n\toutw(BASE + EP_COMMAND, ACK_INTR | 0xff);\n\n\tepsetfilter(sc);\n\tepsetlink(sc);\n\n\toutw(BASE + EP_COMMAND, RX_ENABLE);\n\toutw(BASE + EP_COMMAND, TX_ENABLE);\n\n\tepmbuffill(sc);\n\n\t/* Interface is now `running', with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Attempt to start output, if any. */\n\tepstart(ifp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "epstop",
          "args": [
            "sc"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "epstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "1384-1403",
          "snippet": "void\nepstop(sc)\n\tregister struct ep_softc *sc;\n{\n\n\toutw(BASE + EP_COMMAND, RX_DISABLE);\n\toutw(BASE + EP_COMMAND, RX_DISCARD_TOP_PACK);\n\twhile (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\toutw(BASE + EP_COMMAND, TX_DISABLE);\n\toutw(BASE + EP_COMMAND, STOP_TRANSCEIVER);\n\toutw(BASE + EP_COMMAND, RX_RESET);\n\toutw(BASE + EP_COMMAND, TX_RESET);\n\toutw(BASE + EP_COMMAND, C_INTR_LATCH);\n\toutw(BASE + EP_COMMAND, SET_RD_0_MASK);\n\toutw(BASE + EP_COMMAND, SET_INTR_MASK);\n\toutw(BASE + EP_COMMAND, SET_RX_FILTER);\n\n\tepmbufempty(sc);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void epmbufempty",
            "void epstop",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nvoid epmbufempty;\nvoid epstop;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepstop(sc)\n\tregister struct ep_softc *sc;\n{\n\n\toutw(BASE + EP_COMMAND, RX_DISABLE);\n\toutw(BASE + EP_COMMAND, RX_DISCARD_TOP_PACK);\n\twhile (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\toutw(BASE + EP_COMMAND, TX_DISABLE);\n\toutw(BASE + EP_COMMAND, STOP_TRANSCEIVER);\n\toutw(BASE + EP_COMMAND, RX_RESET);\n\toutw(BASE + EP_COMMAND, TX_RESET);\n\toutw(BASE + EP_COMMAND, C_INTR_LATCH);\n\toutw(BASE + EP_COMMAND, SET_RD_0_MASK);\n\toutw(BASE + EP_COMMAND, SET_INTR_MASK);\n\toutw(BASE + EP_COMMAND, SET_RX_FILTER);\n\n\tepmbufempty(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->sc_arpcom",
            "ifa"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "&sc->sc_arpcom",
            "cmd",
            "data"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "wx_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "303-356",
          "snippet": "static int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_init",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_init;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: device offline\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "if_down",
          "args": [
            "ifp"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define EP_ABSENT\t\t0x02\n#define\tEP_BUS_PCMCIA\t  \t0x1\n\nstruct cfdriver ep_cd = {\n\tNULL, \"ep\", DV_IFNET\n};\nvoid epinit;\nint epioctl;\nvoid epreset;\nvoid epstop;\nvoid epsetfilter;\nvoid epsetlink;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nint\nepioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ep_softc *sc = ep_cd.cd_devs[ifp->if_unit];\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tif (sc->bustype == EP_BUS_PCMCIA &&\n\t    (sc->pcmcia_flags & EP_ABSENT)) {\n\t    if_down(ifp);\n\t    printf(\"%s: device offline\\n\", sc->sc_dev.dv_xname);\n\t    splx(s);\n\t    return ENXIO;\n\t}\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tepinit(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tepinit(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tepstop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tepinit(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * deal with flags changes:\n\t\t\t * IFF_MULTICAST, IFF_PROMISC,\n\t\t\t * IFF_LINK0, IFF_LINK1,\n\t\t\t */\n\t\t\tepsetfilter(sc);\n\t\t\tepsetlink(sc);\n\t\t}\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom) :\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tepreset(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}"
  },
  {
    "function_name": "epread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "1051-1170",
    "snippet": "void\nepread(sc)\n\tregister struct ep_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\tint len;\n\n\tlen = inw(BASE + EP_W1_RX_STATUS);\n\nagain:\n\tif (ifp->if_flags & IFF_DEBUG) {\n\t\tint err = len & ERR_MASK;\n\t\tchar *s = NULL;\n\n\t\tif (len & ERR_INCOMPLETE)\n\t\t\ts = \"incomplete packet\";\n\t\telse if (err == ERR_OVERRUN)\n\t\t\ts = \"packet overrun\";\n\t\telse if (err == ERR_RUNT)\n\t\t\ts = \"runt packet\";\n\t\telse if (err == ERR_ALIGNMENT)\n\t\t\ts = \"bad alignment\";\n\t\telse if (err == ERR_CRC)\n\t\t\ts = \"bad crc\";\n\t\telse if (err == ERR_OVERSIZE)\n\t\t\ts = \"oversized packet\";\n\t\telse if (err == ERR_DRIBBLE)\n\t\t\ts = \"dribble bits\";\n\n\t\tif (s)\n\t\t\tprintf(\"%s: %s\\n\", sc->sc_dev.dv_xname, s);\n\t}\n\n\tif (len & ERR_INCOMPLETE)\n\t\treturn;\n\n\tif (len & ERR_RX) {\n\t\t++ifp->if_ierrors;\n\t\tgoto abort;\n\t}\n\n\tlen &= RX_BYTES_MASK;\t/* Lower 11 bits = RX bytes. */\n\n\t/* Pull packet off interface. */\n\tm = epget(sc, len);\n\tif (m == 0) {\n\t\tifp->if_ierrors++;\n\t\tgoto abort;\n\t}\n\n\t++ifp->if_ipackets;\n\n\t/* We assume the header fit entirely in one mbuf. */\n\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.\n\t * If so, hand off the raw packet to BPF.\n\t */\n\tif (ifp->if_bpf) {\n\t\tbpf_mtap(ifp->if_bpf, m);\n\n\t\t/*\n\t\t * Note that the interface cannot be in promiscuous mode if\n\t\t * there are no BPF listeners.  And if we are in promiscuous\n\t\t * mode, we have to check if this packet is really ours.\n\t\t */\n\t\tif ((ifp->if_flags & IFF_PROMISC) &&\n\t\t    (eh->ether_dhost[0] & 1) == 0 && /* !mcast and !bcast */\n\t\t    bcmp(eh->ether_dhost, sc->sc_arpcom.ac_enaddr,\n\t\t\t    sizeof(eh->ether_dhost)) != 0) {\n\t\t\tm_freem(m);\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\t/* We assume the header fit entirely in one mbuf. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n\n\t/*\n\t * In periods of high traffic we can actually receive enough\n\t * packets so that the fifo overrun bit will be set at this point,\n\t * even though we just read a packet. In this case we\n\t * are not going to receive any more interrupts. We check for\n\t * this condition and read again until the fifo is not full.\n\t * We could simplify this test by not using epstatus(), but\n\t * rechecking the RX_STATUS register directly. This test could\n\t * result in unnecessary looping in cases where there is a new\n\t * packet but the fifo is not full, but it will not fix the\n\t * stuck behavior.\n\t *\n\t * Even with this improvement, we still get packet overrun errors\n\t * which are hurting performance. Maybe when I get some more time\n\t * I'll modify epread() so that it can handle RX_EARLY interrupts.\n\t */\n\tif (epstatus(sc)) {\n\t\tlen = inw(BASE + EP_W1_RX_STATUS);\n\t\t/* Check if we are stuck and reset [see XXX comment] */\n\t\tif (len & ERR_INCOMPLETE) {\n\t\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: adapter reset\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname);\n\t\t\tepreset(sc);\n\t\t\treturn;\n\t\t}\n\t\tgoto again;\n\t}\n\n\treturn;\n\nabort:\n\toutw(BASE + EP_COMMAND, RX_DISCARD_TOP_PACK);\n\twhile (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int epstatus",
      "void epreset",
      "void epread",
      "struct mbuf *epget",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "BASE + EP_STATUS"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "RX_DISCARD_TOP_PACK"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epreset",
          "args": [
            "sc"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "epreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "1360-1370",
          "snippet": "void\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void epinit",
            "void epreset",
            "void epstop",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nvoid epinit;\nvoid epreset;\nvoid epstop;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: adapter reset\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "BASE + EP_W1_RX_STATUS"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epstatus",
          "args": [
            "sc"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "epstatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "918-958",
          "snippet": "static int\nepstatus(sc)\n\tregister struct ep_softc *sc;\n{\n\tu_short fifost;\n\n\t/*\n\t * Check the FIFO status and act accordingly\n\t */\n\tGO_WINDOW(4);\n\tfifost = inw(BASE + EP_W4_FIFO_DIAG);\n\tGO_WINDOW(1);\n\n\tif (fifost & FIFOS_RX_UNDERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX underrun\\n\", sc->sc_dev.dv_xname);\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\tif (fifost & FIFOS_RX_STATUS_OVERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX Status overrun\\n\", sc->sc_dev.dv_xname);\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_RX_OVERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX overrun\\n\", sc->sc_dev.dv_xname);\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_TX_OVERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: TX overrun\\n\", sc->sc_dev.dv_xname);\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int epstatus",
            "void epreset",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nstatic int epstatus;\nvoid epreset;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nstatic int\nepstatus(sc)\n\tregister struct ep_softc *sc;\n{\n\tu_short fifost;\n\n\t/*\n\t * Check the FIFO status and act accordingly\n\t */\n\tGO_WINDOW(4);\n\tfifost = inw(BASE + EP_W4_FIFO_DIAG);\n\tGO_WINDOW(1);\n\n\tif (fifost & FIFOS_RX_UNDERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX underrun\\n\", sc->sc_dev.dv_xname);\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\tif (fifost & FIFOS_RX_STATUS_OVERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX Status overrun\\n\", sc->sc_dev.dv_xname);\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_RX_OVERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX overrun\\n\", sc->sc_dev.dv_xname);\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_TX_OVERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: TX overrun\\n\", sc->sc_dev.dv_xname);\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "sizeof(struct ether_header)"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "eh->ether_dhost",
            "sc->sc_arpcom.ac_enaddr",
            "sizeof(eh->ether_dhost)"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epget",
          "args": [
            "sc",
            "len"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "BASE + EP_W1_RX_STATUS"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nstatic int epstatus;\nvoid epreset;\nvoid epread;\nstruct mbuf *epget;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepread(sc)\n\tregister struct ep_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\tint len;\n\n\tlen = inw(BASE + EP_W1_RX_STATUS);\n\nagain:\n\tif (ifp->if_flags & IFF_DEBUG) {\n\t\tint err = len & ERR_MASK;\n\t\tchar *s = NULL;\n\n\t\tif (len & ERR_INCOMPLETE)\n\t\t\ts = \"incomplete packet\";\n\t\telse if (err == ERR_OVERRUN)\n\t\t\ts = \"packet overrun\";\n\t\telse if (err == ERR_RUNT)\n\t\t\ts = \"runt packet\";\n\t\telse if (err == ERR_ALIGNMENT)\n\t\t\ts = \"bad alignment\";\n\t\telse if (err == ERR_CRC)\n\t\t\ts = \"bad crc\";\n\t\telse if (err == ERR_OVERSIZE)\n\t\t\ts = \"oversized packet\";\n\t\telse if (err == ERR_DRIBBLE)\n\t\t\ts = \"dribble bits\";\n\n\t\tif (s)\n\t\t\tprintf(\"%s: %s\\n\", sc->sc_dev.dv_xname, s);\n\t}\n\n\tif (len & ERR_INCOMPLETE)\n\t\treturn;\n\n\tif (len & ERR_RX) {\n\t\t++ifp->if_ierrors;\n\t\tgoto abort;\n\t}\n\n\tlen &= RX_BYTES_MASK;\t/* Lower 11 bits = RX bytes. */\n\n\t/* Pull packet off interface. */\n\tm = epget(sc, len);\n\tif (m == 0) {\n\t\tifp->if_ierrors++;\n\t\tgoto abort;\n\t}\n\n\t++ifp->if_ipackets;\n\n\t/* We assume the header fit entirely in one mbuf. */\n\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.\n\t * If so, hand off the raw packet to BPF.\n\t */\n\tif (ifp->if_bpf) {\n\t\tbpf_mtap(ifp->if_bpf, m);\n\n\t\t/*\n\t\t * Note that the interface cannot be in promiscuous mode if\n\t\t * there are no BPF listeners.  And if we are in promiscuous\n\t\t * mode, we have to check if this packet is really ours.\n\t\t */\n\t\tif ((ifp->if_flags & IFF_PROMISC) &&\n\t\t    (eh->ether_dhost[0] & 1) == 0 && /* !mcast and !bcast */\n\t\t    bcmp(eh->ether_dhost, sc->sc_arpcom.ac_enaddr,\n\t\t\t    sizeof(eh->ether_dhost)) != 0) {\n\t\t\tm_freem(m);\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\t/* We assume the header fit entirely in one mbuf. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n\n\t/*\n\t * In periods of high traffic we can actually receive enough\n\t * packets so that the fifo overrun bit will be set at this point,\n\t * even though we just read a packet. In this case we\n\t * are not going to receive any more interrupts. We check for\n\t * this condition and read again until the fifo is not full.\n\t * We could simplify this test by not using epstatus(), but\n\t * rechecking the RX_STATUS register directly. This test could\n\t * result in unnecessary looping in cases where there is a new\n\t * packet but the fifo is not full, but it will not fix the\n\t * stuck behavior.\n\t *\n\t * Even with this improvement, we still get packet overrun errors\n\t * which are hurting performance. Maybe when I get some more time\n\t * I'll modify epread() so that it can handle RX_EARLY interrupts.\n\t */\n\tif (epstatus(sc)) {\n\t\tlen = inw(BASE + EP_W1_RX_STATUS);\n\t\t/* Check if we are stuck and reset [see XXX comment] */\n\t\tif (len & ERR_INCOMPLETE) {\n\t\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: adapter reset\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname);\n\t\t\tepreset(sc);\n\t\t\treturn;\n\t\t}\n\t\tgoto again;\n\t}\n\n\treturn;\n\nabort:\n\toutw(BASE + EP_COMMAND, RX_DISCARD_TOP_PACK);\n\twhile (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n}"
  },
  {
    "function_name": "epintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "1001-1049",
    "snippet": "int\nepintr(arg)\n\tvoid *arg;\n{\n\tregister struct ep_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_short status;\n\tint ret = 0;\n\n\tfor (;;) {\n\t\toutw(BASE + EP_COMMAND, C_INTR_LATCH);\n\n\t\tstatus = inw(BASE + EP_STATUS);\n\n\t\tif ((status & (S_TX_COMPLETE | S_TX_AVAIL |\n\t\t\t       S_RX_COMPLETE | S_CARD_FAILURE)) == 0)\n\t\t\tbreak;\n\n\t\tret = 1;\n\n\t\t/*\n\t\t * Acknowledge any interrupts.  It's important that we do this\n\t\t * first, since there would otherwise be a race condition.\n\t\t * Due to the i386 interrupt queueing, we may get spurious\n\t\t * interrupts occasionally.\n\t\t */\n\t\toutw(BASE + EP_COMMAND, ACK_INTR | status);\n\n\t\tif (status & S_RX_COMPLETE)\n\t\t\tepread(sc);\n\t\tif (status & S_TX_AVAIL) {\n\t\t\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\t\t\tepstart(&sc->sc_arpcom.ac_if);\n\t\t}\n\t\tif (status & S_CARD_FAILURE) {\n\t\t\tprintf(\"%s: adapter failure (%x)\\n\",\n\t\t\t       sc->sc_dev.dv_xname, status);\n\t\t\tepreset(sc);\n\t\t\treturn (1);\n\t\t}\n\t\tif (status & S_TX_COMPLETE) {\n\t\t\teptxstat(sc);\n\t\t\tepstart(ifp);\n\t\t}\n\t}\t\n\n\t/* no more interrupts */\n\treturn (ret);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int epintr",
      "void epstart",
      "void epreset",
      "void epread",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "epstart",
          "args": [
            "ifp"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "epstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "782-908",
          "snippet": "void\nepstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ep_softc *sc = ep_cd.cd_devs[ifp->if_unit];\n\tstruct mbuf *m, *m0;\n\tint sh, len, pad;\n\n\t/* Don't transmit if interface is busy or not running */\n\tif ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\nstartagain:\n\t/* Sneak a peek at the next packet */\n\tm0 = ifp->if_snd.ifq_head;\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"epstart: no header mbuf\");\n\tlen = m0->m_pkthdr.len;\n\n\tpad = (4 - len) & 3;\n\n\t/*\n\t * The 3c509 automatically pads short packets to minimum ethernet\n\t * length, but we drop packets that are too large. Perhaps we should\n\t * truncate them instead?\n\t */\n\tif (len + pad > ETHER_MAX_LEN) {\n\t\t/* packet is obviously too large: toss it */\n\t\t++ifp->if_oerrors;\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tm_freem(m0);\n\t\tgoto readcheck;\n\t}\n\n\tif (inw(BASE + EP_W1_FREE_TX) < len + pad + 4) {\n\t\toutw(BASE + EP_COMMAND, SET_TX_AVAIL_THRESH | (len + pad + 4));\n\t\t/* not enough room in FIFO */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t} else {\n\t\toutw(BASE + EP_COMMAND, SET_TX_AVAIL_THRESH | 2044);\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\t\t/* not really needed */\n\t\treturn;\n\n\toutw(BASE + EP_COMMAND, SET_TX_START_THRESH |\n\t    (len / 4 + sc->tx_start_thresh));\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/*\n\t * Do the output at splhigh() so that an interrupt from another device\n\t * won't cause a FIFO underrun.\n\t */\n\tsh = splhigh();\n\n\toutw(BASE + EP_W1_TX_PIO_WR_1, len);\n\toutw(BASE + EP_W1_TX_PIO_WR_1, 0xffff);\t/* Second dword meaningless */\n\tif (EP_IS_BUS_32(sc->bustype)) {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 3)\n\t\t\t\toutsl(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t      mtod(m, caddr_t), m->m_len / 4);\n\t\t\tif (m->m_len & 3)\n\t\t\t\toutsb(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t      mtod(m, caddr_t) + (m->m_len & ~3),\n\t\t\t\t      m->m_len & 3);\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t} else {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 1)\n\t\t\t\toutsw(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t      mtod(m, caddr_t), m->m_len / 2);\n\t\t\tif (m->m_len & 1)\n\t\t\t\toutb(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t     *(mtod(m, caddr_t) + m->m_len - 1));\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t}\n\twhile (pad--)\n\t\toutb(BASE + EP_W1_TX_PIO_WR_1, 0);\n\n\tsplx(sh);\n\n\t++ifp->if_opackets;\n\nreadcheck:\n\tif ((inw(BASE + EP_W1_RX_STATUS) & ERR_INCOMPLETE) == 0) {\n\t\t/* We received a complete packet. */\n\t\tu_short status = inw(BASE + EP_STATUS);\n\n\t\tif ((status & S_INTR_LATCH) == 0) {\n\t\t\t/*\n\t\t\t * No interrupt, read the packet and continue\n\t\t\t * Is  this supposed to happen? Is my motherboard \n\t\t\t * completely busted?\n\t\t\t */\n\t\t\tepread(sc);\n\t\t}\n\t\telse\n\t\t\t/* Got an interrupt, return so that it gets serviced. */\n\t\t\treturn;\n\t}\n\telse {\n\t\t/* Check if we are stuck and reset [see XXX comment] */\n\t\tif (epstatus(sc)) {\n\t\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: adapter reset\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname);\n\t\t\tepreset(sc);\n\t\t}\n\t}\n\n\tgoto startagain;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [
            "#define ETHER_MAX_LEN   1518"
          ],
          "globals_used": [
            "struct cfdriver ep_cd = {\n\tNULL, \"ep\", DV_IFNET\n};",
            "static int epstatus",
            "void epstart",
            "void epreset",
            "void epread",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define ETHER_MAX_LEN   1518\n\nstruct cfdriver ep_cd = {\n\tNULL, \"ep\", DV_IFNET\n};\nstatic int epstatus;\nvoid epstart;\nvoid epreset;\nvoid epread;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ep_softc *sc = ep_cd.cd_devs[ifp->if_unit];\n\tstruct mbuf *m, *m0;\n\tint sh, len, pad;\n\n\t/* Don't transmit if interface is busy or not running */\n\tif ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\nstartagain:\n\t/* Sneak a peek at the next packet */\n\tm0 = ifp->if_snd.ifq_head;\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"epstart: no header mbuf\");\n\tlen = m0->m_pkthdr.len;\n\n\tpad = (4 - len) & 3;\n\n\t/*\n\t * The 3c509 automatically pads short packets to minimum ethernet\n\t * length, but we drop packets that are too large. Perhaps we should\n\t * truncate them instead?\n\t */\n\tif (len + pad > ETHER_MAX_LEN) {\n\t\t/* packet is obviously too large: toss it */\n\t\t++ifp->if_oerrors;\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tm_freem(m0);\n\t\tgoto readcheck;\n\t}\n\n\tif (inw(BASE + EP_W1_FREE_TX) < len + pad + 4) {\n\t\toutw(BASE + EP_COMMAND, SET_TX_AVAIL_THRESH | (len + pad + 4));\n\t\t/* not enough room in FIFO */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t} else {\n\t\toutw(BASE + EP_COMMAND, SET_TX_AVAIL_THRESH | 2044);\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\t\t/* not really needed */\n\t\treturn;\n\n\toutw(BASE + EP_COMMAND, SET_TX_START_THRESH |\n\t    (len / 4 + sc->tx_start_thresh));\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/*\n\t * Do the output at splhigh() so that an interrupt from another device\n\t * won't cause a FIFO underrun.\n\t */\n\tsh = splhigh();\n\n\toutw(BASE + EP_W1_TX_PIO_WR_1, len);\n\toutw(BASE + EP_W1_TX_PIO_WR_1, 0xffff);\t/* Second dword meaningless */\n\tif (EP_IS_BUS_32(sc->bustype)) {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 3)\n\t\t\t\toutsl(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t      mtod(m, caddr_t), m->m_len / 4);\n\t\t\tif (m->m_len & 3)\n\t\t\t\toutsb(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t      mtod(m, caddr_t) + (m->m_len & ~3),\n\t\t\t\t      m->m_len & 3);\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t} else {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 1)\n\t\t\t\toutsw(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t      mtod(m, caddr_t), m->m_len / 2);\n\t\t\tif (m->m_len & 1)\n\t\t\t\toutb(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t     *(mtod(m, caddr_t) + m->m_len - 1));\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t}\n\twhile (pad--)\n\t\toutb(BASE + EP_W1_TX_PIO_WR_1, 0);\n\n\tsplx(sh);\n\n\t++ifp->if_opackets;\n\nreadcheck:\n\tif ((inw(BASE + EP_W1_RX_STATUS) & ERR_INCOMPLETE) == 0) {\n\t\t/* We received a complete packet. */\n\t\tu_short status = inw(BASE + EP_STATUS);\n\n\t\tif ((status & S_INTR_LATCH) == 0) {\n\t\t\t/*\n\t\t\t * No interrupt, read the packet and continue\n\t\t\t * Is  this supposed to happen? Is my motherboard \n\t\t\t * completely busted?\n\t\t\t */\n\t\t\tepread(sc);\n\t\t}\n\t\telse\n\t\t\t/* Got an interrupt, return so that it gets serviced. */\n\t\t\treturn;\n\t}\n\telse {\n\t\t/* Check if we are stuck and reset [see XXX comment] */\n\t\tif (epstatus(sc)) {\n\t\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: adapter reset\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname);\n\t\t\tepreset(sc);\n\t\t}\n\t}\n\n\tgoto startagain;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eptxstat",
          "args": [
            "sc"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "eptxstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "961-999",
          "snippet": "static void\neptxstat(sc)\n\tregister struct ep_softc *sc;\n{\n\tint i;\n\n\t/*\n\t * We need to read+write TX_STATUS until we get a 0 status\n\t * in order to turn off the interrupt flag.\n\t */\n\twhile ((i = inb(BASE + EP_W1_TX_STATUS)) & TXS_COMPLETE) {\n\t\toutb(BASE + EP_W1_TX_STATUS, 0x0);\n\n\t\tif (i & TXS_JABBER) {\n\t\t\t++sc->sc_arpcom.ac_if.if_oerrors;\n\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: jabber (%x)\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, i);\n\t\t\tepreset(sc);\n\t\t} else if (i & TXS_UNDERRUN) {\n\t\t\t++sc->sc_arpcom.ac_if.if_oerrors;\n\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: fifo underrun (%x) @%d\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, i,\n\t\t\t\t       sc->tx_start_thresh);\n\t\t\tif (sc->tx_succ_ok < 100)\n\t\t\t\t    sc->tx_start_thresh = min(ETHER_MAX_LEN,\n\t\t\t\t\t    sc->tx_start_thresh + 20);\n\t\t\tsc->tx_succ_ok = 0;\n\t\t\tepreset(sc);\n\t\t} else if (i & TXS_MAX_COLLISION) {\n\t\t\t++sc->sc_arpcom.ac_if.if_collisions;\n\t\t\toutw(BASE + EP_COMMAND, TX_ENABLE);\n\t\t\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\t\t} else\n\t\t\tsc->tx_succ_ok = (sc->tx_succ_ok+1) & 127;\n\t\t\t\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [
            "#define ETHER_MAX_LEN   1518"
          ],
          "globals_used": [
            "void epreset",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define ETHER_MAX_LEN   1518\n\nvoid epreset;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nstatic void\neptxstat(sc)\n\tregister struct ep_softc *sc;\n{\n\tint i;\n\n\t/*\n\t * We need to read+write TX_STATUS until we get a 0 status\n\t * in order to turn off the interrupt flag.\n\t */\n\twhile ((i = inb(BASE + EP_W1_TX_STATUS)) & TXS_COMPLETE) {\n\t\toutb(BASE + EP_W1_TX_STATUS, 0x0);\n\n\t\tif (i & TXS_JABBER) {\n\t\t\t++sc->sc_arpcom.ac_if.if_oerrors;\n\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: jabber (%x)\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, i);\n\t\t\tepreset(sc);\n\t\t} else if (i & TXS_UNDERRUN) {\n\t\t\t++sc->sc_arpcom.ac_if.if_oerrors;\n\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: fifo underrun (%x) @%d\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, i,\n\t\t\t\t       sc->tx_start_thresh);\n\t\t\tif (sc->tx_succ_ok < 100)\n\t\t\t\t    sc->tx_start_thresh = min(ETHER_MAX_LEN,\n\t\t\t\t\t    sc->tx_start_thresh + 20);\n\t\t\tsc->tx_succ_ok = 0;\n\t\t\tepreset(sc);\n\t\t} else if (i & TXS_MAX_COLLISION) {\n\t\t\t++sc->sc_arpcom.ac_if.if_collisions;\n\t\t\toutw(BASE + EP_COMMAND, TX_ENABLE);\n\t\t\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\t\t} else\n\t\t\tsc->tx_succ_ok = (sc->tx_succ_ok+1) & 127;\n\t\t\t\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "epreset",
          "args": [
            "sc"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "epreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "1360-1370",
          "snippet": "void\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void epinit",
            "void epreset",
            "void epstop",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nvoid epinit;\nvoid epreset;\nvoid epstop;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: adapter failure (%x)\\n\"",
            "sc->sc_dev.dv_xname",
            "status"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "epread",
          "args": [
            "sc"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "epreadeeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "1419-1431",
          "snippet": "static u_short\nepreadeeprom(id_port, offset)\n\tint     id_port;\n\tint     offset;\n{\n\tint i, data = 0;\n\n\toutb(id_port, 0x80 + offset);\n\tdelay(1000);\n\tfor (i = 0; i < 16; i++)\n\t\tdata = (data << 1) | (inw(id_port) & 1);\n\treturn (data);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u_short epreadeeprom",
            "__P((int id_port, int offset));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nstatic u_short epreadeeprom;\n__P((int id_port, int offset));\n\nstatic u_short\nepreadeeprom(id_port, offset)\n\tint     id_port;\n\tint     offset;\n{\n\tint i, data = 0;\n\n\toutb(id_port, 0x80 + offset);\n\tdelay(1000);\n\tfor (i = 0; i < 16; i++)\n\t\tdata = (data << 1) | (inw(id_port) & 1);\n\treturn (data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "ACK_INTR | status"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "BASE + EP_STATUS"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "C_INTR_LATCH"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nint epintr;\nvoid epstart;\nvoid epreset;\nvoid epread;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nint\nepintr(arg)\n\tvoid *arg;\n{\n\tregister struct ep_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_short status;\n\tint ret = 0;\n\n\tfor (;;) {\n\t\toutw(BASE + EP_COMMAND, C_INTR_LATCH);\n\n\t\tstatus = inw(BASE + EP_STATUS);\n\n\t\tif ((status & (S_TX_COMPLETE | S_TX_AVAIL |\n\t\t\t       S_RX_COMPLETE | S_CARD_FAILURE)) == 0)\n\t\t\tbreak;\n\n\t\tret = 1;\n\n\t\t/*\n\t\t * Acknowledge any interrupts.  It's important that we do this\n\t\t * first, since there would otherwise be a race condition.\n\t\t * Due to the i386 interrupt queueing, we may get spurious\n\t\t * interrupts occasionally.\n\t\t */\n\t\toutw(BASE + EP_COMMAND, ACK_INTR | status);\n\n\t\tif (status & S_RX_COMPLETE)\n\t\t\tepread(sc);\n\t\tif (status & S_TX_AVAIL) {\n\t\t\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\t\t\tepstart(&sc->sc_arpcom.ac_if);\n\t\t}\n\t\tif (status & S_CARD_FAILURE) {\n\t\t\tprintf(\"%s: adapter failure (%x)\\n\",\n\t\t\t       sc->sc_dev.dv_xname, status);\n\t\t\tepreset(sc);\n\t\t\treturn (1);\n\t\t}\n\t\tif (status & S_TX_COMPLETE) {\n\t\t\teptxstat(sc);\n\t\t\tepstart(ifp);\n\t\t}\n\t}\t\n\n\t/* no more interrupts */\n\treturn (ret);\n}"
  },
  {
    "function_name": "eptxstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "961-999",
    "snippet": "static void\neptxstat(sc)\n\tregister struct ep_softc *sc;\n{\n\tint i;\n\n\t/*\n\t * We need to read+write TX_STATUS until we get a 0 status\n\t * in order to turn off the interrupt flag.\n\t */\n\twhile ((i = inb(BASE + EP_W1_TX_STATUS)) & TXS_COMPLETE) {\n\t\toutb(BASE + EP_W1_TX_STATUS, 0x0);\n\n\t\tif (i & TXS_JABBER) {\n\t\t\t++sc->sc_arpcom.ac_if.if_oerrors;\n\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: jabber (%x)\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, i);\n\t\t\tepreset(sc);\n\t\t} else if (i & TXS_UNDERRUN) {\n\t\t\t++sc->sc_arpcom.ac_if.if_oerrors;\n\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: fifo underrun (%x) @%d\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, i,\n\t\t\t\t       sc->tx_start_thresh);\n\t\t\tif (sc->tx_succ_ok < 100)\n\t\t\t\t    sc->tx_start_thresh = min(ETHER_MAX_LEN,\n\t\t\t\t\t    sc->tx_start_thresh + 20);\n\t\t\tsc->tx_succ_ok = 0;\n\t\t\tepreset(sc);\n\t\t} else if (i & TXS_MAX_COLLISION) {\n\t\t\t++sc->sc_arpcom.ac_if.if_collisions;\n\t\t\toutw(BASE + EP_COMMAND, TX_ENABLE);\n\t\t\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\t\t} else\n\t\t\tsc->tx_succ_ok = (sc->tx_succ_ok+1) & 127;\n\t\t\t\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [
      "#define ETHER_MAX_LEN   1518"
    ],
    "globals_used": [
      "void epreset",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "TX_ENABLE"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epreset",
          "args": [
            "sc"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "epreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "1360-1370",
          "snippet": "void\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void epinit",
            "void epreset",
            "void epstop",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nvoid epinit;\nvoid epreset;\nvoid epstop;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "ETHER_MAX_LEN",
            "sc->tx_start_thresh + 20"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "btminphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1088-1096",
          "snippet": "void\nbtminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((BT_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((BT_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void btminphys"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid btminphys;\n\nvoid\nbtminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((BT_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((BT_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: fifo underrun (%x) @%d\\n\"",
            "sc->sc_dev.dv_xname",
            "i",
            "sc->tx_start_thresh"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "BASE + EP_W1_TX_STATUS",
            "0x0"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "BASE + EP_W1_TX_STATUS"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define ETHER_MAX_LEN   1518\n\nvoid epreset;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nstatic void\neptxstat(sc)\n\tregister struct ep_softc *sc;\n{\n\tint i;\n\n\t/*\n\t * We need to read+write TX_STATUS until we get a 0 status\n\t * in order to turn off the interrupt flag.\n\t */\n\twhile ((i = inb(BASE + EP_W1_TX_STATUS)) & TXS_COMPLETE) {\n\t\toutb(BASE + EP_W1_TX_STATUS, 0x0);\n\n\t\tif (i & TXS_JABBER) {\n\t\t\t++sc->sc_arpcom.ac_if.if_oerrors;\n\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: jabber (%x)\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, i);\n\t\t\tepreset(sc);\n\t\t} else if (i & TXS_UNDERRUN) {\n\t\t\t++sc->sc_arpcom.ac_if.if_oerrors;\n\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: fifo underrun (%x) @%d\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, i,\n\t\t\t\t       sc->tx_start_thresh);\n\t\t\tif (sc->tx_succ_ok < 100)\n\t\t\t\t    sc->tx_start_thresh = min(ETHER_MAX_LEN,\n\t\t\t\t\t    sc->tx_start_thresh + 20);\n\t\t\tsc->tx_succ_ok = 0;\n\t\t\tepreset(sc);\n\t\t} else if (i & TXS_MAX_COLLISION) {\n\t\t\t++sc->sc_arpcom.ac_if.if_collisions;\n\t\t\toutw(BASE + EP_COMMAND, TX_ENABLE);\n\t\t\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\t\t} else\n\t\t\tsc->tx_succ_ok = (sc->tx_succ_ok+1) & 127;\n\t\t\t\n\t}\n}"
  },
  {
    "function_name": "epstatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "918-958",
    "snippet": "static int\nepstatus(sc)\n\tregister struct ep_softc *sc;\n{\n\tu_short fifost;\n\n\t/*\n\t * Check the FIFO status and act accordingly\n\t */\n\tGO_WINDOW(4);\n\tfifost = inw(BASE + EP_W4_FIFO_DIAG);\n\tGO_WINDOW(1);\n\n\tif (fifost & FIFOS_RX_UNDERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX underrun\\n\", sc->sc_dev.dv_xname);\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\tif (fifost & FIFOS_RX_STATUS_OVERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX Status overrun\\n\", sc->sc_dev.dv_xname);\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_RX_OVERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX overrun\\n\", sc->sc_dev.dv_xname);\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_TX_OVERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: TX overrun\\n\", sc->sc_dev.dv_xname);\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int epstatus",
      "void epreset",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "epreset",
          "args": [
            "sc"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "epreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "1360-1370",
          "snippet": "void\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void epinit",
            "void epreset",
            "void epstop",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nvoid epinit;\nvoid epreset;\nvoid epstop;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: TX overrun\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "1"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "BASE + EP_W4_FIFO_DIAG"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "4"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nstatic int epstatus;\nvoid epreset;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nstatic int\nepstatus(sc)\n\tregister struct ep_softc *sc;\n{\n\tu_short fifost;\n\n\t/*\n\t * Check the FIFO status and act accordingly\n\t */\n\tGO_WINDOW(4);\n\tfifost = inw(BASE + EP_W4_FIFO_DIAG);\n\tGO_WINDOW(1);\n\n\tif (fifost & FIFOS_RX_UNDERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX underrun\\n\", sc->sc_dev.dv_xname);\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\tif (fifost & FIFOS_RX_STATUS_OVERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX Status overrun\\n\", sc->sc_dev.dv_xname);\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_RX_OVERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX overrun\\n\", sc->sc_dev.dv_xname);\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_TX_OVERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: TX overrun\\n\", sc->sc_dev.dv_xname);\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "epstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "782-908",
    "snippet": "void\nepstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ep_softc *sc = ep_cd.cd_devs[ifp->if_unit];\n\tstruct mbuf *m, *m0;\n\tint sh, len, pad;\n\n\t/* Don't transmit if interface is busy or not running */\n\tif ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\nstartagain:\n\t/* Sneak a peek at the next packet */\n\tm0 = ifp->if_snd.ifq_head;\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"epstart: no header mbuf\");\n\tlen = m0->m_pkthdr.len;\n\n\tpad = (4 - len) & 3;\n\n\t/*\n\t * The 3c509 automatically pads short packets to minimum ethernet\n\t * length, but we drop packets that are too large. Perhaps we should\n\t * truncate them instead?\n\t */\n\tif (len + pad > ETHER_MAX_LEN) {\n\t\t/* packet is obviously too large: toss it */\n\t\t++ifp->if_oerrors;\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tm_freem(m0);\n\t\tgoto readcheck;\n\t}\n\n\tif (inw(BASE + EP_W1_FREE_TX) < len + pad + 4) {\n\t\toutw(BASE + EP_COMMAND, SET_TX_AVAIL_THRESH | (len + pad + 4));\n\t\t/* not enough room in FIFO */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t} else {\n\t\toutw(BASE + EP_COMMAND, SET_TX_AVAIL_THRESH | 2044);\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\t\t/* not really needed */\n\t\treturn;\n\n\toutw(BASE + EP_COMMAND, SET_TX_START_THRESH |\n\t    (len / 4 + sc->tx_start_thresh));\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/*\n\t * Do the output at splhigh() so that an interrupt from another device\n\t * won't cause a FIFO underrun.\n\t */\n\tsh = splhigh();\n\n\toutw(BASE + EP_W1_TX_PIO_WR_1, len);\n\toutw(BASE + EP_W1_TX_PIO_WR_1, 0xffff);\t/* Second dword meaningless */\n\tif (EP_IS_BUS_32(sc->bustype)) {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 3)\n\t\t\t\toutsl(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t      mtod(m, caddr_t), m->m_len / 4);\n\t\t\tif (m->m_len & 3)\n\t\t\t\toutsb(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t      mtod(m, caddr_t) + (m->m_len & ~3),\n\t\t\t\t      m->m_len & 3);\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t} else {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 1)\n\t\t\t\toutsw(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t      mtod(m, caddr_t), m->m_len / 2);\n\t\t\tif (m->m_len & 1)\n\t\t\t\toutb(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t     *(mtod(m, caddr_t) + m->m_len - 1));\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t}\n\twhile (pad--)\n\t\toutb(BASE + EP_W1_TX_PIO_WR_1, 0);\n\n\tsplx(sh);\n\n\t++ifp->if_opackets;\n\nreadcheck:\n\tif ((inw(BASE + EP_W1_RX_STATUS) & ERR_INCOMPLETE) == 0) {\n\t\t/* We received a complete packet. */\n\t\tu_short status = inw(BASE + EP_STATUS);\n\n\t\tif ((status & S_INTR_LATCH) == 0) {\n\t\t\t/*\n\t\t\t * No interrupt, read the packet and continue\n\t\t\t * Is  this supposed to happen? Is my motherboard \n\t\t\t * completely busted?\n\t\t\t */\n\t\t\tepread(sc);\n\t\t}\n\t\telse\n\t\t\t/* Got an interrupt, return so that it gets serviced. */\n\t\t\treturn;\n\t}\n\telse {\n\t\t/* Check if we are stuck and reset [see XXX comment] */\n\t\tif (epstatus(sc)) {\n\t\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: adapter reset\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname);\n\t\t\tepreset(sc);\n\t\t}\n\t}\n\n\tgoto startagain;\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [
      "#define ETHER_MAX_LEN   1518"
    ],
    "globals_used": [
      "struct cfdriver ep_cd = {\n\tNULL, \"ep\", DV_IFNET\n};",
      "static int epstatus",
      "void epstart",
      "void epreset",
      "void epread",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "epreset",
          "args": [
            "sc"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "epreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "1360-1370",
          "snippet": "void\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void epinit",
            "void epreset",
            "void epstop",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nvoid epinit;\nvoid epreset;\nvoid epstop;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: adapter reset\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "epstatus",
          "args": [
            "sc"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "epstatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "918-958",
          "snippet": "static int\nepstatus(sc)\n\tregister struct ep_softc *sc;\n{\n\tu_short fifost;\n\n\t/*\n\t * Check the FIFO status and act accordingly\n\t */\n\tGO_WINDOW(4);\n\tfifost = inw(BASE + EP_W4_FIFO_DIAG);\n\tGO_WINDOW(1);\n\n\tif (fifost & FIFOS_RX_UNDERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX underrun\\n\", sc->sc_dev.dv_xname);\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\tif (fifost & FIFOS_RX_STATUS_OVERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX Status overrun\\n\", sc->sc_dev.dv_xname);\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_RX_OVERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX overrun\\n\", sc->sc_dev.dv_xname);\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_TX_OVERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: TX overrun\\n\", sc->sc_dev.dv_xname);\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int epstatus",
            "void epreset",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nstatic int epstatus;\nvoid epreset;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nstatic int\nepstatus(sc)\n\tregister struct ep_softc *sc;\n{\n\tu_short fifost;\n\n\t/*\n\t * Check the FIFO status and act accordingly\n\t */\n\tGO_WINDOW(4);\n\tfifost = inw(BASE + EP_W4_FIFO_DIAG);\n\tGO_WINDOW(1);\n\n\tif (fifost & FIFOS_RX_UNDERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX underrun\\n\", sc->sc_dev.dv_xname);\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\tif (fifost & FIFOS_RX_STATUS_OVERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX Status overrun\\n\", sc->sc_dev.dv_xname);\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_RX_OVERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX overrun\\n\", sc->sc_dev.dv_xname);\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_TX_OVERRUN) {\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: TX overrun\\n\", sc->sc_dev.dv_xname);\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "epread",
          "args": [
            "sc"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "epreadeeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "1419-1431",
          "snippet": "static u_short\nepreadeeprom(id_port, offset)\n\tint     id_port;\n\tint     offset;\n{\n\tint i, data = 0;\n\n\toutb(id_port, 0x80 + offset);\n\tdelay(1000);\n\tfor (i = 0; i < 16; i++)\n\t\tdata = (data << 1) | (inw(id_port) & 1);\n\treturn (data);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u_short epreadeeprom",
            "__P((int id_port, int offset));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nstatic u_short epreadeeprom;\n__P((int id_port, int offset));\n\nstatic u_short\nepreadeeprom(id_port, offset)\n\tint     id_port;\n\tint     offset;\n{\n\tint i, data = 0;\n\n\toutb(id_port, 0x80 + offset);\n\tdelay(1000);\n\tfor (i = 0; i < 16; i++)\n\t\tdata = (data << 1) | (inw(id_port) & 1);\n\treturn (data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "BASE + EP_STATUS"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "BASE + EP_W1_RX_STATUS"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "sh"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "BASE + EP_W1_TX_PIO_WR_1",
            "0"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "MFREE",
          "args": [
            "m",
            "m0"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outsw",
          "args": [
            "BASE + EP_W1_TX_PIO_WR_1",
            "mtod(m, caddr_t)",
            "m->m_len / 2"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MFREE",
          "args": [
            "m",
            "m0"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outsb",
          "args": [
            "BASE + EP_W1_TX_PIO_WR_1",
            "mtod(m, caddr_t) + (m->m_len & ~3)",
            "m->m_len & 3"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outsl",
          "args": [
            "BASE + EP_W1_TX_PIO_WR_1",
            "mtod(m, caddr_t)",
            "m->m_len / 4"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EP_IS_BUS_32",
          "args": [
            "sc->bustype"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_W1_TX_PIO_WR_1",
            "0xffff"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_W1_TX_PIO_WR_1",
            "len"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m0"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "SET_TX_START_THRESH |\n\t    (len / 4 + sc->tx_start_thresh)"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "SET_TX_AVAIL_THRESH | 2044"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "SET_TX_AVAIL_THRESH | (len + pad + 4)"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "BASE + EP_W1_FREE_TX"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"epstart: no header mbuf\""
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define ETHER_MAX_LEN   1518\n\nstruct cfdriver ep_cd = {\n\tNULL, \"ep\", DV_IFNET\n};\nstatic int epstatus;\nvoid epstart;\nvoid epreset;\nvoid epread;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ep_softc *sc = ep_cd.cd_devs[ifp->if_unit];\n\tstruct mbuf *m, *m0;\n\tint sh, len, pad;\n\n\t/* Don't transmit if interface is busy or not running */\n\tif ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\nstartagain:\n\t/* Sneak a peek at the next packet */\n\tm0 = ifp->if_snd.ifq_head;\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"epstart: no header mbuf\");\n\tlen = m0->m_pkthdr.len;\n\n\tpad = (4 - len) & 3;\n\n\t/*\n\t * The 3c509 automatically pads short packets to minimum ethernet\n\t * length, but we drop packets that are too large. Perhaps we should\n\t * truncate them instead?\n\t */\n\tif (len + pad > ETHER_MAX_LEN) {\n\t\t/* packet is obviously too large: toss it */\n\t\t++ifp->if_oerrors;\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tm_freem(m0);\n\t\tgoto readcheck;\n\t}\n\n\tif (inw(BASE + EP_W1_FREE_TX) < len + pad + 4) {\n\t\toutw(BASE + EP_COMMAND, SET_TX_AVAIL_THRESH | (len + pad + 4));\n\t\t/* not enough room in FIFO */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t} else {\n\t\toutw(BASE + EP_COMMAND, SET_TX_AVAIL_THRESH | 2044);\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\t\t/* not really needed */\n\t\treturn;\n\n\toutw(BASE + EP_COMMAND, SET_TX_START_THRESH |\n\t    (len / 4 + sc->tx_start_thresh));\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/*\n\t * Do the output at splhigh() so that an interrupt from another device\n\t * won't cause a FIFO underrun.\n\t */\n\tsh = splhigh();\n\n\toutw(BASE + EP_W1_TX_PIO_WR_1, len);\n\toutw(BASE + EP_W1_TX_PIO_WR_1, 0xffff);\t/* Second dword meaningless */\n\tif (EP_IS_BUS_32(sc->bustype)) {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 3)\n\t\t\t\toutsl(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t      mtod(m, caddr_t), m->m_len / 4);\n\t\t\tif (m->m_len & 3)\n\t\t\t\toutsb(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t      mtod(m, caddr_t) + (m->m_len & ~3),\n\t\t\t\t      m->m_len & 3);\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t} else {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 1)\n\t\t\t\toutsw(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t      mtod(m, caddr_t), m->m_len / 2);\n\t\t\tif (m->m_len & 1)\n\t\t\t\toutb(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t     *(mtod(m, caddr_t) + m->m_len - 1));\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t}\n\twhile (pad--)\n\t\toutb(BASE + EP_W1_TX_PIO_WR_1, 0);\n\n\tsplx(sh);\n\n\t++ifp->if_opackets;\n\nreadcheck:\n\tif ((inw(BASE + EP_W1_RX_STATUS) & ERR_INCOMPLETE) == 0) {\n\t\t/* We received a complete packet. */\n\t\tu_short status = inw(BASE + EP_STATUS);\n\n\t\tif ((status & S_INTR_LATCH) == 0) {\n\t\t\t/*\n\t\t\t * No interrupt, read the packet and continue\n\t\t\t * Is  this supposed to happen? Is my motherboard \n\t\t\t * completely busted?\n\t\t\t */\n\t\t\tepread(sc);\n\t\t}\n\t\telse\n\t\t\t/* Got an interrupt, return so that it gets serviced. */\n\t\t\treturn;\n\t}\n\telse {\n\t\t/* Check if we are stuck and reset [see XXX comment] */\n\t\tif (epstatus(sc)) {\n\t\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: adapter reset\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname);\n\t\t\tepreset(sc);\n\t\t}\n\t}\n\n\tgoto startagain;\n}"
  },
  {
    "function_name": "epsetlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "738-776",
    "snippet": "void\nepsetlink(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\t/*\n\t * you can `ifconfig (link0|-link0) ep0' to get the following\n\t * behaviour:\n\t *\t-link0\tdisable AUI/UTP. enable BNC.\n\t *\tlink0\tdisable BNC. enable AUI.\n\t *\tlink1\tif the card has a UTP connector, and link0 is\n\t *\t\tset too, then you get the UTP port.\n\t */\n\tGO_WINDOW(4);\n\toutw(BASE + EP_W4_MEDIA_TYPE, DISABLE_UTP);\n\tif (!(ifp->if_flags & IFF_LINK0) && (sc->ep_connectors & BNC)) {\n\t\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\t\tGO_WINDOW(0);\n\t\t\toutw(BASE + EP_W0_ADDRESS_CFG,3<<14);\n\t\t\tGO_WINDOW(1);\n\t\t}\n\t\toutw(BASE + EP_COMMAND, START_TRANSCEIVER);\n\t\tdelay(1000);\n\t}\n\tif (ifp->if_flags & IFF_LINK0) {\n\t\toutw(BASE + EP_COMMAND, STOP_TRANSCEIVER);\n\t\tdelay(1000);\n\t\tif ((ifp->if_flags & IFF_LINK1) && (sc->ep_connectors & UTP)) {\n\t\t\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\t\t\tGO_WINDOW(0);\n\t\t\t\toutw(BASE + EP_W0_ADDRESS_CFG,0<<14);\n\t\t\t\tGO_WINDOW(4);\n\t\t\t}\n\t\t\toutw(BASE + EP_W4_MEDIA_TYPE, ENABLE_UTP);\n\t\t}\n\t}\n\tGO_WINDOW(1);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [
      "#define\tEP_BUS_PCMCIA\t  \t0x1"
    ],
    "globals_used": [
      "void epsetlink",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "1"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_W4_MEDIA_TYPE",
            "ENABLE_UTP"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "4"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_W0_ADDRESS_CFG",
            "0<<14"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "0"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "STOP_TRANSCEIVER"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "START_TRANSCEIVER"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "1"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_W0_ADDRESS_CFG",
            "3<<14"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "0"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_W4_MEDIA_TYPE",
            "DISABLE_UTP"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "4"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define\tEP_BUS_PCMCIA\t  \t0x1\n\nvoid epsetlink;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepsetlink(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\t/*\n\t * you can `ifconfig (link0|-link0) ep0' to get the following\n\t * behaviour:\n\t *\t-link0\tdisable AUI/UTP. enable BNC.\n\t *\tlink0\tdisable BNC. enable AUI.\n\t *\tlink1\tif the card has a UTP connector, and link0 is\n\t *\t\tset too, then you get the UTP port.\n\t */\n\tGO_WINDOW(4);\n\toutw(BASE + EP_W4_MEDIA_TYPE, DISABLE_UTP);\n\tif (!(ifp->if_flags & IFF_LINK0) && (sc->ep_connectors & BNC)) {\n\t\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\t\tGO_WINDOW(0);\n\t\t\toutw(BASE + EP_W0_ADDRESS_CFG,3<<14);\n\t\t\tGO_WINDOW(1);\n\t\t}\n\t\toutw(BASE + EP_COMMAND, START_TRANSCEIVER);\n\t\tdelay(1000);\n\t}\n\tif (ifp->if_flags & IFF_LINK0) {\n\t\toutw(BASE + EP_COMMAND, STOP_TRANSCEIVER);\n\t\tdelay(1000);\n\t\tif ((ifp->if_flags & IFF_LINK1) && (sc->ep_connectors & UTP)) {\n\t\t\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\t\t\tGO_WINDOW(0);\n\t\t\t\toutw(BASE + EP_W0_ADDRESS_CFG,0<<14);\n\t\t\t\tGO_WINDOW(4);\n\t\t\t}\n\t\t\toutw(BASE + EP_W4_MEDIA_TYPE, ENABLE_UTP);\n\t\t}\n\t}\n\tGO_WINDOW(1);\n}"
  },
  {
    "function_name": "epsetfilter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "725-736",
    "snippet": "void\nepsetfilter(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\toutw(BASE + EP_COMMAND, SET_RX_FILTER |\n\t    FIL_INDIVIDUAL | FIL_BRDCST |\n\t    ((ifp->if_flags & IFF_MULTICAST) ? FIL_MULTICAST : 0 ) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? FIL_PROMISC : 0 ));\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void epsetfilter",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "SET_RX_FILTER |\n\t    FIL_INDIVIDUAL | FIL_BRDCST |\n\t    ((ifp->if_flags & IFF_MULTICAST) ? FIL_MULTICAST : 0 ) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? FIL_PROMISC : 0 )"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "1"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nvoid epsetfilter;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepsetfilter(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\toutw(BASE + EP_COMMAND, SET_RX_FILTER |\n\t    FIL_INDIVIDUAL | FIL_BRDCST |\n\t    ((ifp->if_flags & IFF_MULTICAST) ? FIL_MULTICAST : 0 ) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? FIL_PROMISC : 0 ));\n}"
  },
  {
    "function_name": "epinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "660-723",
    "snippet": "void\nepinit(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i;\n\n\twhile (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\n\tif (sc->bustype != EP_BUS_PCI) {\n\t\tGO_WINDOW(0);\n\t\toutw(BASE + EP_W0_CONFIG_CTRL, 0);\n\t\toutw(BASE + EP_W0_CONFIG_CTRL, ENABLE_DRQ_IRQ);\n\t}\n\n\tif (sc->bustype == EP_BUS_PCMCIA) {\n#ifdef EP_COAX_DEFAULT\n\t\toutw(BASE + EP_W0_ADDRESS_CFG,3<<14);\n#else\n\t\toutw(BASE + EP_W0_ADDRESS_CFG,0<<14);\n#endif\n\t\toutw(BASE + EP_W0_RESOURCE_CFG, 0x3f00);\n\t}\n\n\tGO_WINDOW(2);\n\tfor (i = 0; i < 6; i++)\t/* Reload the ether_addr. */\n\t\toutb(BASE + EP_W2_ADDR_0 + i, sc->sc_arpcom.ac_enaddr[i]);\n\n\toutw(BASE + EP_COMMAND, RX_RESET);\n\toutw(BASE + EP_COMMAND, TX_RESET);\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\tfor (i = 0; i < 31; i++)\n\t\tinb(BASE + EP_W1_TX_STATUS);\n\n\toutw(BASE + EP_COMMAND, SET_RD_0_MASK | S_CARD_FAILURE | \n\t\t\t\tS_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\toutw(BASE + EP_COMMAND, SET_INTR_MASK | S_CARD_FAILURE |\n\t\t\t\tS_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\n\t/*\n\t * Attempt to get rid of any stray interrupts that occured during\n\t * configuration.  On the i386 this isn't possible because one may\n\t * already be queued.  However, a single stray interrupt is\n\t * unimportant.\n\t */\n\toutw(BASE + EP_COMMAND, ACK_INTR | 0xff);\n\n\tepsetfilter(sc);\n\tepsetlink(sc);\n\n\toutw(BASE + EP_COMMAND, RX_ENABLE);\n\toutw(BASE + EP_COMMAND, TX_ENABLE);\n\n\tepmbuffill(sc);\n\n\t/* Interface is now `running', with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Attempt to start output, if any. */\n\tepstart(ifp);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [
      "#define EP_BUS_PCI\t  \t0x3",
      "#define\tEP_BUS_PCMCIA\t  \t0x1"
    ],
    "globals_used": [
      "void epinit",
      "void epstart",
      "void epmbuffill",
      "void epsetfilter",
      "void epsetlink",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "epstart",
          "args": [
            "ifp"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "epstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "782-908",
          "snippet": "void\nepstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ep_softc *sc = ep_cd.cd_devs[ifp->if_unit];\n\tstruct mbuf *m, *m0;\n\tint sh, len, pad;\n\n\t/* Don't transmit if interface is busy or not running */\n\tif ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\nstartagain:\n\t/* Sneak a peek at the next packet */\n\tm0 = ifp->if_snd.ifq_head;\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"epstart: no header mbuf\");\n\tlen = m0->m_pkthdr.len;\n\n\tpad = (4 - len) & 3;\n\n\t/*\n\t * The 3c509 automatically pads short packets to minimum ethernet\n\t * length, but we drop packets that are too large. Perhaps we should\n\t * truncate them instead?\n\t */\n\tif (len + pad > ETHER_MAX_LEN) {\n\t\t/* packet is obviously too large: toss it */\n\t\t++ifp->if_oerrors;\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tm_freem(m0);\n\t\tgoto readcheck;\n\t}\n\n\tif (inw(BASE + EP_W1_FREE_TX) < len + pad + 4) {\n\t\toutw(BASE + EP_COMMAND, SET_TX_AVAIL_THRESH | (len + pad + 4));\n\t\t/* not enough room in FIFO */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t} else {\n\t\toutw(BASE + EP_COMMAND, SET_TX_AVAIL_THRESH | 2044);\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\t\t/* not really needed */\n\t\treturn;\n\n\toutw(BASE + EP_COMMAND, SET_TX_START_THRESH |\n\t    (len / 4 + sc->tx_start_thresh));\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/*\n\t * Do the output at splhigh() so that an interrupt from another device\n\t * won't cause a FIFO underrun.\n\t */\n\tsh = splhigh();\n\n\toutw(BASE + EP_W1_TX_PIO_WR_1, len);\n\toutw(BASE + EP_W1_TX_PIO_WR_1, 0xffff);\t/* Second dword meaningless */\n\tif (EP_IS_BUS_32(sc->bustype)) {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 3)\n\t\t\t\toutsl(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t      mtod(m, caddr_t), m->m_len / 4);\n\t\t\tif (m->m_len & 3)\n\t\t\t\toutsb(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t      mtod(m, caddr_t) + (m->m_len & ~3),\n\t\t\t\t      m->m_len & 3);\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t} else {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 1)\n\t\t\t\toutsw(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t      mtod(m, caddr_t), m->m_len / 2);\n\t\t\tif (m->m_len & 1)\n\t\t\t\toutb(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t     *(mtod(m, caddr_t) + m->m_len - 1));\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t}\n\twhile (pad--)\n\t\toutb(BASE + EP_W1_TX_PIO_WR_1, 0);\n\n\tsplx(sh);\n\n\t++ifp->if_opackets;\n\nreadcheck:\n\tif ((inw(BASE + EP_W1_RX_STATUS) & ERR_INCOMPLETE) == 0) {\n\t\t/* We received a complete packet. */\n\t\tu_short status = inw(BASE + EP_STATUS);\n\n\t\tif ((status & S_INTR_LATCH) == 0) {\n\t\t\t/*\n\t\t\t * No interrupt, read the packet and continue\n\t\t\t * Is  this supposed to happen? Is my motherboard \n\t\t\t * completely busted?\n\t\t\t */\n\t\t\tepread(sc);\n\t\t}\n\t\telse\n\t\t\t/* Got an interrupt, return so that it gets serviced. */\n\t\t\treturn;\n\t}\n\telse {\n\t\t/* Check if we are stuck and reset [see XXX comment] */\n\t\tif (epstatus(sc)) {\n\t\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: adapter reset\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname);\n\t\t\tepreset(sc);\n\t\t}\n\t}\n\n\tgoto startagain;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [
            "#define ETHER_MAX_LEN   1518"
          ],
          "globals_used": [
            "struct cfdriver ep_cd = {\n\tNULL, \"ep\", DV_IFNET\n};",
            "static int epstatus",
            "void epstart",
            "void epreset",
            "void epread",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define ETHER_MAX_LEN   1518\n\nstruct cfdriver ep_cd = {\n\tNULL, \"ep\", DV_IFNET\n};\nstatic int epstatus;\nvoid epstart;\nvoid epreset;\nvoid epread;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ep_softc *sc = ep_cd.cd_devs[ifp->if_unit];\n\tstruct mbuf *m, *m0;\n\tint sh, len, pad;\n\n\t/* Don't transmit if interface is busy or not running */\n\tif ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\nstartagain:\n\t/* Sneak a peek at the next packet */\n\tm0 = ifp->if_snd.ifq_head;\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"epstart: no header mbuf\");\n\tlen = m0->m_pkthdr.len;\n\n\tpad = (4 - len) & 3;\n\n\t/*\n\t * The 3c509 automatically pads short packets to minimum ethernet\n\t * length, but we drop packets that are too large. Perhaps we should\n\t * truncate them instead?\n\t */\n\tif (len + pad > ETHER_MAX_LEN) {\n\t\t/* packet is obviously too large: toss it */\n\t\t++ifp->if_oerrors;\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tm_freem(m0);\n\t\tgoto readcheck;\n\t}\n\n\tif (inw(BASE + EP_W1_FREE_TX) < len + pad + 4) {\n\t\toutw(BASE + EP_COMMAND, SET_TX_AVAIL_THRESH | (len + pad + 4));\n\t\t/* not enough room in FIFO */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t} else {\n\t\toutw(BASE + EP_COMMAND, SET_TX_AVAIL_THRESH | 2044);\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\t\t/* not really needed */\n\t\treturn;\n\n\toutw(BASE + EP_COMMAND, SET_TX_START_THRESH |\n\t    (len / 4 + sc->tx_start_thresh));\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/*\n\t * Do the output at splhigh() so that an interrupt from another device\n\t * won't cause a FIFO underrun.\n\t */\n\tsh = splhigh();\n\n\toutw(BASE + EP_W1_TX_PIO_WR_1, len);\n\toutw(BASE + EP_W1_TX_PIO_WR_1, 0xffff);\t/* Second dword meaningless */\n\tif (EP_IS_BUS_32(sc->bustype)) {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 3)\n\t\t\t\toutsl(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t      mtod(m, caddr_t), m->m_len / 4);\n\t\t\tif (m->m_len & 3)\n\t\t\t\toutsb(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t      mtod(m, caddr_t) + (m->m_len & ~3),\n\t\t\t\t      m->m_len & 3);\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t} else {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 1)\n\t\t\t\toutsw(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t      mtod(m, caddr_t), m->m_len / 2);\n\t\t\tif (m->m_len & 1)\n\t\t\t\toutb(BASE + EP_W1_TX_PIO_WR_1,\n\t\t\t\t     *(mtod(m, caddr_t) + m->m_len - 1));\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t}\n\twhile (pad--)\n\t\toutb(BASE + EP_W1_TX_PIO_WR_1, 0);\n\n\tsplx(sh);\n\n\t++ifp->if_opackets;\n\nreadcheck:\n\tif ((inw(BASE + EP_W1_RX_STATUS) & ERR_INCOMPLETE) == 0) {\n\t\t/* We received a complete packet. */\n\t\tu_short status = inw(BASE + EP_STATUS);\n\n\t\tif ((status & S_INTR_LATCH) == 0) {\n\t\t\t/*\n\t\t\t * No interrupt, read the packet and continue\n\t\t\t * Is  this supposed to happen? Is my motherboard \n\t\t\t * completely busted?\n\t\t\t */\n\t\t\tepread(sc);\n\t\t}\n\t\telse\n\t\t\t/* Got an interrupt, return so that it gets serviced. */\n\t\t\treturn;\n\t}\n\telse {\n\t\t/* Check if we are stuck and reset [see XXX comment] */\n\t\tif (epstatus(sc)) {\n\t\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: adapter reset\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname);\n\t\t\tepreset(sc);\n\t\t}\n\t}\n\n\tgoto startagain;\n}"
        }
      },
      {
        "call_info": {
          "callee": "epmbuffill",
          "args": [
            "sc"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "epmbuffill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "1464-1485",
          "snippet": "void\nepmbuffill(arg)\n\tvoid *arg;\n{\n\tstruct ep_softc *sc = arg;\n\tint s, i;\n\n\ts = splnet();\n\ti = sc->last_mb;\n\tdo {\n\t\tif (sc->mb[i] == NULL)\n\t\t\tMGET(sc->mb[i], M_DONTWAIT, MT_DATA);\n\t\tif (sc->mb[i] == NULL)\n\t\t\tbreak;\n\t\ti = (i + 1) % MAX_MBS;\n\t} while (i != sc->next_mb);\n\tsc->last_mb = i;\n\t/* If the queue was not filled, try again. */\n\tif (sc->last_mb != sc->next_mb)\n\t\ttimeout(epmbuffill, sc, 1);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [
            "#define MAX_MBS\t8\t\t\t/* # of mbufs we keep around\t*/"
          ],
          "globals_used": [
            "void epmbuffill",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define MAX_MBS\t8\t\t\t/* # of mbufs we keep around\t*/\n\nvoid epmbuffill;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepmbuffill(arg)\n\tvoid *arg;\n{\n\tstruct ep_softc *sc = arg;\n\tint s, i;\n\n\ts = splnet();\n\ti = sc->last_mb;\n\tdo {\n\t\tif (sc->mb[i] == NULL)\n\t\t\tMGET(sc->mb[i], M_DONTWAIT, MT_DATA);\n\t\tif (sc->mb[i] == NULL)\n\t\t\tbreak;\n\t\ti = (i + 1) % MAX_MBS;\n\t} while (i != sc->next_mb);\n\tsc->last_mb = i;\n\t/* If the queue was not filled, try again. */\n\tif (sc->last_mb != sc->next_mb)\n\t\ttimeout(epmbuffill, sc, 1);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "TX_ENABLE"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "RX_ENABLE"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epsetlink",
          "args": [
            "sc"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "epsetlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "738-776",
          "snippet": "void\nepsetlink(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\t/*\n\t * you can `ifconfig (link0|-link0) ep0' to get the following\n\t * behaviour:\n\t *\t-link0\tdisable AUI/UTP. enable BNC.\n\t *\tlink0\tdisable BNC. enable AUI.\n\t *\tlink1\tif the card has a UTP connector, and link0 is\n\t *\t\tset too, then you get the UTP port.\n\t */\n\tGO_WINDOW(4);\n\toutw(BASE + EP_W4_MEDIA_TYPE, DISABLE_UTP);\n\tif (!(ifp->if_flags & IFF_LINK0) && (sc->ep_connectors & BNC)) {\n\t\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\t\tGO_WINDOW(0);\n\t\t\toutw(BASE + EP_W0_ADDRESS_CFG,3<<14);\n\t\t\tGO_WINDOW(1);\n\t\t}\n\t\toutw(BASE + EP_COMMAND, START_TRANSCEIVER);\n\t\tdelay(1000);\n\t}\n\tif (ifp->if_flags & IFF_LINK0) {\n\t\toutw(BASE + EP_COMMAND, STOP_TRANSCEIVER);\n\t\tdelay(1000);\n\t\tif ((ifp->if_flags & IFF_LINK1) && (sc->ep_connectors & UTP)) {\n\t\t\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\t\t\tGO_WINDOW(0);\n\t\t\t\toutw(BASE + EP_W0_ADDRESS_CFG,0<<14);\n\t\t\t\tGO_WINDOW(4);\n\t\t\t}\n\t\t\toutw(BASE + EP_W4_MEDIA_TYPE, ENABLE_UTP);\n\t\t}\n\t}\n\tGO_WINDOW(1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [
            "#define\tEP_BUS_PCMCIA\t  \t0x1"
          ],
          "globals_used": [
            "void epsetlink",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define\tEP_BUS_PCMCIA\t  \t0x1\n\nvoid epsetlink;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepsetlink(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\t/*\n\t * you can `ifconfig (link0|-link0) ep0' to get the following\n\t * behaviour:\n\t *\t-link0\tdisable AUI/UTP. enable BNC.\n\t *\tlink0\tdisable BNC. enable AUI.\n\t *\tlink1\tif the card has a UTP connector, and link0 is\n\t *\t\tset too, then you get the UTP port.\n\t */\n\tGO_WINDOW(4);\n\toutw(BASE + EP_W4_MEDIA_TYPE, DISABLE_UTP);\n\tif (!(ifp->if_flags & IFF_LINK0) && (sc->ep_connectors & BNC)) {\n\t\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\t\tGO_WINDOW(0);\n\t\t\toutw(BASE + EP_W0_ADDRESS_CFG,3<<14);\n\t\t\tGO_WINDOW(1);\n\t\t}\n\t\toutw(BASE + EP_COMMAND, START_TRANSCEIVER);\n\t\tdelay(1000);\n\t}\n\tif (ifp->if_flags & IFF_LINK0) {\n\t\toutw(BASE + EP_COMMAND, STOP_TRANSCEIVER);\n\t\tdelay(1000);\n\t\tif ((ifp->if_flags & IFF_LINK1) && (sc->ep_connectors & UTP)) {\n\t\t\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\t\t\tGO_WINDOW(0);\n\t\t\t\toutw(BASE + EP_W0_ADDRESS_CFG,0<<14);\n\t\t\t\tGO_WINDOW(4);\n\t\t\t}\n\t\t\toutw(BASE + EP_W4_MEDIA_TYPE, ENABLE_UTP);\n\t\t}\n\t}\n\tGO_WINDOW(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "epsetfilter",
          "args": [
            "sc"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "epsetfilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "725-736",
          "snippet": "void\nepsetfilter(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\toutw(BASE + EP_COMMAND, SET_RX_FILTER |\n\t    FIL_INDIVIDUAL | FIL_BRDCST |\n\t    ((ifp->if_flags & IFF_MULTICAST) ? FIL_MULTICAST : 0 ) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? FIL_PROMISC : 0 ));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void epsetfilter",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nvoid epsetfilter;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepsetfilter(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\toutw(BASE + EP_COMMAND, SET_RX_FILTER |\n\t    FIL_INDIVIDUAL | FIL_BRDCST |\n\t    ((ifp->if_flags & IFF_MULTICAST) ? FIL_MULTICAST : 0 ) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? FIL_PROMISC : 0 ));\n}"
        }
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "ACK_INTR | 0xff"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "SET_INTR_MASK | S_CARD_FAILURE |\n\t\t\t\tS_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "SET_RD_0_MASK | S_CARD_FAILURE | \n\t\t\t\tS_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "BASE + EP_W1_TX_STATUS"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "1"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "TX_RESET"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_COMMAND",
            "RX_RESET"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "BASE + EP_W2_ADDR_0 + i",
            "sc->sc_arpcom.ac_enaddr[i]"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "2"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_W0_RESOURCE_CFG",
            "0x3f00"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_W0_ADDRESS_CFG",
            "0<<14"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_W0_ADDRESS_CFG",
            "3<<14"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_W0_CONFIG_CTRL",
            "ENABLE_DRQ_IRQ"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_W0_CONFIG_CTRL",
            "0"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "0"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "BASE + EP_STATUS"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define EP_BUS_PCI\t  \t0x3\n#define\tEP_BUS_PCMCIA\t  \t0x1\n\nvoid epinit;\nvoid epstart;\nvoid epmbuffill;\nvoid epsetfilter;\nvoid epsetlink;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepinit(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i;\n\n\twhile (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\n\tif (sc->bustype != EP_BUS_PCI) {\n\t\tGO_WINDOW(0);\n\t\toutw(BASE + EP_W0_CONFIG_CTRL, 0);\n\t\toutw(BASE + EP_W0_CONFIG_CTRL, ENABLE_DRQ_IRQ);\n\t}\n\n\tif (sc->bustype == EP_BUS_PCMCIA) {\n#ifdef EP_COAX_DEFAULT\n\t\toutw(BASE + EP_W0_ADDRESS_CFG,3<<14);\n#else\n\t\toutw(BASE + EP_W0_ADDRESS_CFG,0<<14);\n#endif\n\t\toutw(BASE + EP_W0_RESOURCE_CFG, 0x3f00);\n\t}\n\n\tGO_WINDOW(2);\n\tfor (i = 0; i < 6; i++)\t/* Reload the ether_addr. */\n\t\toutb(BASE + EP_W2_ADDR_0 + i, sc->sc_arpcom.ac_enaddr[i]);\n\n\toutw(BASE + EP_COMMAND, RX_RESET);\n\toutw(BASE + EP_COMMAND, TX_RESET);\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\tfor (i = 0; i < 31; i++)\n\t\tinb(BASE + EP_W1_TX_STATUS);\n\n\toutw(BASE + EP_COMMAND, SET_RD_0_MASK | S_CARD_FAILURE | \n\t\t\t\tS_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\toutw(BASE + EP_COMMAND, SET_INTR_MASK | S_CARD_FAILURE |\n\t\t\t\tS_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\n\t/*\n\t * Attempt to get rid of any stray interrupts that occured during\n\t * configuration.  On the i386 this isn't possible because one may\n\t * already be queued.  However, a single stray interrupt is\n\t * unimportant.\n\t */\n\toutw(BASE + EP_COMMAND, ACK_INTR | 0xff);\n\n\tepsetfilter(sc);\n\tepsetlink(sc);\n\n\toutw(BASE + EP_COMMAND, RX_ENABLE);\n\toutw(BASE + EP_COMMAND, TX_ENABLE);\n\n\tepmbuffill(sc);\n\n\t/* Interface is now `running', with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Attempt to start output, if any. */\n\tepstart(ifp);\n}"
  },
  {
    "function_name": "epattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "581-654",
    "snippet": "static void\nepattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct ep_softc *sc = (void *)self;\n\tu_short conn = 0;\n#if NPCI > 0\n\textern struct cfdriver pci_cd;\n\n\tif (parent->dv_cfdata->cf_driver == &pci_cd) {\n\t\tstruct pci_attach_args *pa = aux;\n\t\tint iobase;\n\t\tu_short i;\n\n\t\tif (pci_map_io(pa->pa_tag, PCI_CBMA, &iobase)) {\n\t\t\tprintf(\"%s: couldn't map io\\n\", sc->sc_dev.dv_xname);\n\t\t\treturn;\n\t\t}\n\t\tsc->bustype = EP_BUS_PCI;\n\t\tsc->ep_iobase = iobase; /* & 0xfffffff0 */\n\t\ti = pci_conf_read(pa->pa_bc, pa->pa_tag, PCI_CONN);\n\n\t\t/*\n\t\t * Bits 13,12,9 of the isa adapter are the same as bits \n\t\t * 5,4,3 of the pci adapter\n\t\t */\n\t\tif (i & IS_PCI_AUI)\n\t\t\tconn |= IS_AUI;\n\t\tif (i & IS_PCI_BNC)\n\t\t\tconn |= IS_BNC;\n\t\tif (i & IS_PCI_UTP)\n\t\t\tconn |= IS_UTP;\n\n\t\tGO_WINDOW(0);\n\t}\n\telse\n#endif\n\t{\n\t\tstruct isa_attach_args *ia = aux;\n\n\t\tsc->ep_iobase = ia->ia_iobase;\n\t\tGO_WINDOW(0);\n\t\tconn = inw(ia->ia_iobase + EP_W0_CONFIG_CTRL);\n\t}\n\n\tepconfig(sc, conn);\n\n\n#if NPCI > 0\n\tif (parent->dv_cfdata->cf_driver == &pci_cd) {\n\t\tstruct pci_attach_args *pa = aux;\n\n\t\tpci_conf_write(pa->pa_bc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t\t       pci_conf_read(pa->pa_bc, pa->pa_tag,\n\t\t\t\t\t     PCI_COMMAND_STATUS_REG) |\n\t\t\t       PCI_COMMAND_MASTER_ENABLE);\n\n\t\tsc->sc_ih = pci_map_int(pa->pa_tag, IPL_NET, epintr, sc);\n\t\tif (sc->sc_ih == NULL) {\n\t\t\tprintf(\"%s: couldn't map interrupt\\n\",\n\t\t\t       sc->sc_dev.dv_xname);\n\t\t\treturn;\n\t\t}\n\t\tepstop(sc);\n\t}\n\telse\n#endif\n\t{\n\t\tstruct isa_attach_args *ia = aux;\n\t\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq,\n\t\t    IST_EDGE, IPL_NET, epintr, sc, sc->sc_dev.dv_xname);\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [
      "#define EP_BUS_PCI\t  \t0x3",
      "#define PCI_CBMA\t\t0x10    /* Configuration Base Memory Address */",
      "#define PCI_CONN\t\t0x48    /* Connector type */"
    ],
    "globals_used": [
      "static void epattach",
      "int epintr",
      "void epstop",
      "static void epconfig",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "ia->ia_irq",
            "IST_EDGE",
            "IPL_NET",
            "epintr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epstop",
          "args": [
            "sc"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "epstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "1384-1403",
          "snippet": "void\nepstop(sc)\n\tregister struct ep_softc *sc;\n{\n\n\toutw(BASE + EP_COMMAND, RX_DISABLE);\n\toutw(BASE + EP_COMMAND, RX_DISCARD_TOP_PACK);\n\twhile (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\toutw(BASE + EP_COMMAND, TX_DISABLE);\n\toutw(BASE + EP_COMMAND, STOP_TRANSCEIVER);\n\toutw(BASE + EP_COMMAND, RX_RESET);\n\toutw(BASE + EP_COMMAND, TX_RESET);\n\toutw(BASE + EP_COMMAND, C_INTR_LATCH);\n\toutw(BASE + EP_COMMAND, SET_RD_0_MASK);\n\toutw(BASE + EP_COMMAND, SET_INTR_MASK);\n\toutw(BASE + EP_COMMAND, SET_RX_FILTER);\n\n\tepmbufempty(sc);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void epmbufempty",
            "void epstop",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nvoid epmbufempty;\nvoid epstop;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepstop(sc)\n\tregister struct ep_softc *sc;\n{\n\n\toutw(BASE + EP_COMMAND, RX_DISABLE);\n\toutw(BASE + EP_COMMAND, RX_DISCARD_TOP_PACK);\n\twhile (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\toutw(BASE + EP_COMMAND, TX_DISABLE);\n\toutw(BASE + EP_COMMAND, STOP_TRANSCEIVER);\n\toutw(BASE + EP_COMMAND, RX_RESET);\n\toutw(BASE + EP_COMMAND, TX_RESET);\n\toutw(BASE + EP_COMMAND, C_INTR_LATCH);\n\toutw(BASE + EP_COMMAND, SET_RD_0_MASK);\n\toutw(BASE + EP_COMMAND, SET_INTR_MASK);\n\toutw(BASE + EP_COMMAND, SET_RX_FILTER);\n\n\tepmbufempty(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: couldn't map interrupt\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_map_int",
          "args": [
            "pa->pa_tag",
            "IPL_NET",
            "epintr",
            "sc"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_bc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG",
            "pci_conf_read(pa->pa_bc, pa->pa_tag,\n\t\t\t\t\t     PCI_COMMAND_STATUS_REG) |\n\t\t\t       PCI_COMMAND_MASTER_ENABLE"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_bc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epconfig",
          "args": [
            "sc",
            "conn"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "epconfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "514-579",
          "snippet": "static void\nepconfig(sc, conn)\n\tstruct ep_softc *sc;\n\tu_int conn;\n{\n\tu_short i;\n\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tsc->ep_connectors = 0;\n\tprintf(\": \");\n\tif (conn & IS_AUI) {\n\t\tprintf(\"aui\");\n\t\tsc->ep_connectors |= AUI;\n\t}\n\tif (conn & IS_BNC) {\n\t\tif (sc->ep_connectors)\n\t\t\tprintf(\"/\");\n\t\tprintf(\"bnc\");\n\t\tsc->ep_connectors |= BNC;\n\t}\n\tif (conn & IS_UTP) {\n\t\tif (sc->ep_connectors)\n\t\t\tprintf(\"/\");\n\t\tprintf(\"utp\");\n\t\tsc->ep_connectors |= UTP;\n\t}\n\tif (!sc->ep_connectors)\n\t\tprintf(\"no connectors!\");\n\n\t/*\n\t * Read the station address from the eeprom\n\t */\n\tfor (i = 0; i < 3; i++) {\n\t\tu_short x;\n\t\tif (epbusyeeprom(sc))\n\t\t\treturn;\n\t\toutw(BASE + EP_W0_EEPROM_COMMAND, READ_EEPROM | i);\n\t\tif (epbusyeeprom(sc))\n\t\t\treturn;\n\t\tx = inw(BASE + EP_W0_EEPROM_DATA);\n\t\tsc->sc_arpcom.ac_enaddr[(i << 1)] = x >> 8;\n\t\tsc->sc_arpcom.ac_enaddr[(i << 1) + 1] = x;\n\t}\n\n\tprintf(\" address %s\\n\", ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\tifp->if_unit = sc->sc_dev.dv_unit;\n\tifp->if_name = ep_cd.cd_name;\n\tifp->if_start = epstart;\n\tifp->if_ioctl = epioctl;\n\tifp->if_watchdog = epwatchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\n\tif ((sc->pcmcia_flags & EP_REATTACH) == 0) {\n\t\tif_attach(ifp);\n\t\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\t\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\t\t  sizeof(struct ether_header));\n#endif\n\t}\n\tsc->tx_start_thresh = 20;\t/* probably a good starting point. */\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [
            "#define EP_REATTACH\t\t0x01"
          ],
          "globals_used": [
            "struct cfdriver ep_cd = {\n\tNULL, \"ep\", DV_IFNET\n};",
            "int epioctl",
            "void epstart",
            "void epwatchdog",
            "static void epconfig",
            "static int epbusyeeprom",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define EP_REATTACH\t\t0x01\n\nstruct cfdriver ep_cd = {\n\tNULL, \"ep\", DV_IFNET\n};\nint epioctl;\nvoid epstart;\nvoid epwatchdog;\nstatic void epconfig;\nstatic int epbusyeeprom;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nstatic void\nepconfig(sc, conn)\n\tstruct ep_softc *sc;\n\tu_int conn;\n{\n\tu_short i;\n\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tsc->ep_connectors = 0;\n\tprintf(\": \");\n\tif (conn & IS_AUI) {\n\t\tprintf(\"aui\");\n\t\tsc->ep_connectors |= AUI;\n\t}\n\tif (conn & IS_BNC) {\n\t\tif (sc->ep_connectors)\n\t\t\tprintf(\"/\");\n\t\tprintf(\"bnc\");\n\t\tsc->ep_connectors |= BNC;\n\t}\n\tif (conn & IS_UTP) {\n\t\tif (sc->ep_connectors)\n\t\t\tprintf(\"/\");\n\t\tprintf(\"utp\");\n\t\tsc->ep_connectors |= UTP;\n\t}\n\tif (!sc->ep_connectors)\n\t\tprintf(\"no connectors!\");\n\n\t/*\n\t * Read the station address from the eeprom\n\t */\n\tfor (i = 0; i < 3; i++) {\n\t\tu_short x;\n\t\tif (epbusyeeprom(sc))\n\t\t\treturn;\n\t\toutw(BASE + EP_W0_EEPROM_COMMAND, READ_EEPROM | i);\n\t\tif (epbusyeeprom(sc))\n\t\t\treturn;\n\t\tx = inw(BASE + EP_W0_EEPROM_DATA);\n\t\tsc->sc_arpcom.ac_enaddr[(i << 1)] = x >> 8;\n\t\tsc->sc_arpcom.ac_enaddr[(i << 1) + 1] = x;\n\t}\n\n\tprintf(\" address %s\\n\", ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\tifp->if_unit = sc->sc_dev.dv_unit;\n\tifp->if_name = ep_cd.cd_name;\n\tifp->if_start = epstart;\n\tifp->if_ioctl = epioctl;\n\tifp->if_watchdog = epwatchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\n\tif ((sc->pcmcia_flags & EP_REATTACH) == 0) {\n\t\tif_attach(ifp);\n\t\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\t\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\t\t  sizeof(struct ether_header));\n#endif\n\t}\n\tsc->tx_start_thresh = 20;\t/* probably a good starting point. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "ia->ia_iobase + EP_W0_CONFIG_CTRL"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "0"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "0"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_bc",
            "pa->pa_tag",
            "PCI_CONN"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_map_io",
          "args": [
            "pa->pa_tag",
            "PCI_CBMA",
            "&iobase"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define EP_BUS_PCI\t  \t0x3\n#define PCI_CBMA\t\t0x10    /* Configuration Base Memory Address */\n#define PCI_CONN\t\t0x48    /* Connector type */\n\nstatic void epattach;\nint epintr;\nvoid epstop;\nstatic void epconfig;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nstatic void\nepattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct ep_softc *sc = (void *)self;\n\tu_short conn = 0;\n#if NPCI > 0\n\textern struct cfdriver pci_cd;\n\n\tif (parent->dv_cfdata->cf_driver == &pci_cd) {\n\t\tstruct pci_attach_args *pa = aux;\n\t\tint iobase;\n\t\tu_short i;\n\n\t\tif (pci_map_io(pa->pa_tag, PCI_CBMA, &iobase)) {\n\t\t\tprintf(\"%s: couldn't map io\\n\", sc->sc_dev.dv_xname);\n\t\t\treturn;\n\t\t}\n\t\tsc->bustype = EP_BUS_PCI;\n\t\tsc->ep_iobase = iobase; /* & 0xfffffff0 */\n\t\ti = pci_conf_read(pa->pa_bc, pa->pa_tag, PCI_CONN);\n\n\t\t/*\n\t\t * Bits 13,12,9 of the isa adapter are the same as bits \n\t\t * 5,4,3 of the pci adapter\n\t\t */\n\t\tif (i & IS_PCI_AUI)\n\t\t\tconn |= IS_AUI;\n\t\tif (i & IS_PCI_BNC)\n\t\t\tconn |= IS_BNC;\n\t\tif (i & IS_PCI_UTP)\n\t\t\tconn |= IS_UTP;\n\n\t\tGO_WINDOW(0);\n\t}\n\telse\n#endif\n\t{\n\t\tstruct isa_attach_args *ia = aux;\n\n\t\tsc->ep_iobase = ia->ia_iobase;\n\t\tGO_WINDOW(0);\n\t\tconn = inw(ia->ia_iobase + EP_W0_CONFIG_CTRL);\n\t}\n\n\tepconfig(sc, conn);\n\n\n#if NPCI > 0\n\tif (parent->dv_cfdata->cf_driver == &pci_cd) {\n\t\tstruct pci_attach_args *pa = aux;\n\n\t\tpci_conf_write(pa->pa_bc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t\t       pci_conf_read(pa->pa_bc, pa->pa_tag,\n\t\t\t\t\t     PCI_COMMAND_STATUS_REG) |\n\t\t\t       PCI_COMMAND_MASTER_ENABLE);\n\n\t\tsc->sc_ih = pci_map_int(pa->pa_tag, IPL_NET, epintr, sc);\n\t\tif (sc->sc_ih == NULL) {\n\t\t\tprintf(\"%s: couldn't map interrupt\\n\",\n\t\t\t       sc->sc_dev.dv_xname);\n\t\t\treturn;\n\t\t}\n\t\tepstop(sc);\n\t}\n\telse\n#endif\n\t{\n\t\tstruct isa_attach_args *ia = aux;\n\t\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq,\n\t\t    IST_EDGE, IPL_NET, epintr, sc, sc->sc_dev.dv_xname);\n\t}\n}"
  },
  {
    "function_name": "epconfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "514-579",
    "snippet": "static void\nepconfig(sc, conn)\n\tstruct ep_softc *sc;\n\tu_int conn;\n{\n\tu_short i;\n\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tsc->ep_connectors = 0;\n\tprintf(\": \");\n\tif (conn & IS_AUI) {\n\t\tprintf(\"aui\");\n\t\tsc->ep_connectors |= AUI;\n\t}\n\tif (conn & IS_BNC) {\n\t\tif (sc->ep_connectors)\n\t\t\tprintf(\"/\");\n\t\tprintf(\"bnc\");\n\t\tsc->ep_connectors |= BNC;\n\t}\n\tif (conn & IS_UTP) {\n\t\tif (sc->ep_connectors)\n\t\t\tprintf(\"/\");\n\t\tprintf(\"utp\");\n\t\tsc->ep_connectors |= UTP;\n\t}\n\tif (!sc->ep_connectors)\n\t\tprintf(\"no connectors!\");\n\n\t/*\n\t * Read the station address from the eeprom\n\t */\n\tfor (i = 0; i < 3; i++) {\n\t\tu_short x;\n\t\tif (epbusyeeprom(sc))\n\t\t\treturn;\n\t\toutw(BASE + EP_W0_EEPROM_COMMAND, READ_EEPROM | i);\n\t\tif (epbusyeeprom(sc))\n\t\t\treturn;\n\t\tx = inw(BASE + EP_W0_EEPROM_DATA);\n\t\tsc->sc_arpcom.ac_enaddr[(i << 1)] = x >> 8;\n\t\tsc->sc_arpcom.ac_enaddr[(i << 1) + 1] = x;\n\t}\n\n\tprintf(\" address %s\\n\", ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\tifp->if_unit = sc->sc_dev.dv_unit;\n\tifp->if_name = ep_cd.cd_name;\n\tifp->if_start = epstart;\n\tifp->if_ioctl = epioctl;\n\tifp->if_watchdog = epwatchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\n\tif ((sc->pcmcia_flags & EP_REATTACH) == 0) {\n\t\tif_attach(ifp);\n\t\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\t\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\t\t  sizeof(struct ether_header));\n#endif\n\t}\n\tsc->tx_start_thresh = 20;\t/* probably a good starting point. */\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [
      "#define EP_REATTACH\t\t0x01"
    ],
    "globals_used": [
      "struct cfdriver ep_cd = {\n\tNULL, \"ep\", DV_IFNET\n};",
      "int epioctl",
      "void epstart",
      "void epwatchdog",
      "static void epconfig",
      "static int epbusyeeprom",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&sc->sc_arpcom.ac_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" address %s\\n\"",
            "ether_sprintf(sc->sc_arpcom.ac_enaddr)"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->sc_arpcom.ac_enaddr"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "BASE + EP_W0_EEPROM_DATA"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epbusyeeprom",
          "args": [
            "sc"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "epbusyeeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "1433-1462",
          "snippet": "static int\nepbusyeeprom(sc)\n\tstruct ep_softc *sc;\n{\n\tint i = 100, j;\n\n\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\tdelay(1000);\n\t\treturn 0;\n\t}\n\n\twhile (i--) {\n\t\tj = inw(BASE + EP_W0_EEPROM_COMMAND);\n\t\tif (j & EEPROM_BUSY)\n\t\t\tdelay(100);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!i) {\n\t\tprintf(\"\\n%s: eeprom failed to come ready\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\tif (j & EEPROM_TST_MODE) {\n\t\tprintf(\"\\n%s: erase pencil mark, or disable plug-n-play mode!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [
            "#define\tEP_BUS_PCMCIA\t  \t0x1"
          ],
          "globals_used": [
            "static int epbusyeeprom",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define\tEP_BUS_PCMCIA\t  \t0x1\n\nstatic int epbusyeeprom;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nstatic int\nepbusyeeprom(sc)\n\tstruct ep_softc *sc;\n{\n\tint i = 100, j;\n\n\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\tdelay(1000);\n\t\treturn 0;\n\t}\n\n\twhile (i--) {\n\t\tj = inw(BASE + EP_W0_EEPROM_COMMAND);\n\t\tif (j & EEPROM_BUSY)\n\t\t\tdelay(100);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!i) {\n\t\tprintf(\"\\n%s: eeprom failed to come ready\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\tif (j & EEPROM_TST_MODE) {\n\t\tprintf(\"\\n%s: erase pencil mark, or disable plug-n-play mode!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "BASE + EP_W0_EEPROM_COMMAND",
            "READ_EEPROM | i"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define EP_REATTACH\t\t0x01\n\nstruct cfdriver ep_cd = {\n\tNULL, \"ep\", DV_IFNET\n};\nint epioctl;\nvoid epstart;\nvoid epwatchdog;\nstatic void epconfig;\nstatic int epbusyeeprom;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nstatic void\nepconfig(sc, conn)\n\tstruct ep_softc *sc;\n\tu_int conn;\n{\n\tu_short i;\n\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tsc->ep_connectors = 0;\n\tprintf(\": \");\n\tif (conn & IS_AUI) {\n\t\tprintf(\"aui\");\n\t\tsc->ep_connectors |= AUI;\n\t}\n\tif (conn & IS_BNC) {\n\t\tif (sc->ep_connectors)\n\t\t\tprintf(\"/\");\n\t\tprintf(\"bnc\");\n\t\tsc->ep_connectors |= BNC;\n\t}\n\tif (conn & IS_UTP) {\n\t\tif (sc->ep_connectors)\n\t\t\tprintf(\"/\");\n\t\tprintf(\"utp\");\n\t\tsc->ep_connectors |= UTP;\n\t}\n\tif (!sc->ep_connectors)\n\t\tprintf(\"no connectors!\");\n\n\t/*\n\t * Read the station address from the eeprom\n\t */\n\tfor (i = 0; i < 3; i++) {\n\t\tu_short x;\n\t\tif (epbusyeeprom(sc))\n\t\t\treturn;\n\t\toutw(BASE + EP_W0_EEPROM_COMMAND, READ_EEPROM | i);\n\t\tif (epbusyeeprom(sc))\n\t\t\treturn;\n\t\tx = inw(BASE + EP_W0_EEPROM_DATA);\n\t\tsc->sc_arpcom.ac_enaddr[(i << 1)] = x >> 8;\n\t\tsc->sc_arpcom.ac_enaddr[(i << 1) + 1] = x;\n\t}\n\n\tprintf(\" address %s\\n\", ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\tifp->if_unit = sc->sc_dev.dv_unit;\n\tifp->if_name = ep_cd.cd_name;\n\tifp->if_start = epstart;\n\tifp->if_ioctl = epioctl;\n\tifp->if_watchdog = epwatchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\n\tif ((sc->pcmcia_flags & EP_REATTACH) == 0) {\n\t\tif_attach(ifp);\n\t\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\t\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\t\t  sizeof(struct ether_header));\n#endif\n\t}\n\tsc->tx_start_thresh = 20;\t/* probably a good starting point. */\n}"
  },
  {
    "function_name": "epprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "378-512",
    "snippet": "int\nepprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct ep_softc *sc = match;\n\tstruct isa_attach_args *ia = aux;\n\tstatic int probed;\n\tint slot, iobase, i;\n\tu_short vendor, model;\n\tint k, k2;\n\n#if NPCI > 0\n\textern struct cfdriver pci_cd;\n\n\tif (parent->dv_cfdata->cf_driver == &pci_cd) {\n\t\tstruct pci_attach_args *pa = (struct pci_attach_args *) aux;\n\n\t\tif (PCI_VENDORID(pa->pa_id) != PCI_VENDOR_3COM)\n\t\t\treturn 0;\n\n\t\tswitch (PCI_CHIPID(pa->pa_id)) {\n\t\tcase PCI_PRODUCT_3COM_3C590:\n\t\tcase PCI_PRODUCT_3COM_3C595:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (nepcards >= MAXEPCARDS)\n\t\t\treturn 0;\n\n\t\tepcards[nepcards++].available = 0;\n\t\treturn 1;\n\t}\n#endif\n\n\tif (!probed) {\n\t\tprobed = 1;\n\n\t\t/* find all EISA cards */\n\t\tfor (slot = 1; slot < 16; slot++) {\n\t\t\tiobase = 0x1000 * slot;\n\n\t\t\tvendor = htons(inw(iobase + EISA_VENDOR));\n\t\t\tif (vendor != MFG_ID)\n\t\t\t\tcontinue;\n\n\t\t\tmodel = htons(inw(iobase + EISA_MODEL));\n\t\t\tif ((model & 0xfff0) != PROD_ID) {\n#ifndef trusted\n\t\t\t\tprintf(\"epprobe: ignoring model %04x\\n\", model);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toutb(iobase + EISA_CONTROL, EISA_ENABLE | EISA_RESET);\n\t\t\tdelay(10);\n\t\t\toutb(iobase + EISA_CONTROL, EISA_ENABLE);\n\t\t\t/* Wait for reset? */\n\t\t\tdelay(1000);\n\n\t\t\tk = inw(iobase + EP_W0_ADDRESS_CFG);\n\t\t\tk = (k & 0x1f) * 0x10 + 0x200;\n\n\t\t\tk2 = inw(iobase + EP_W0_RESOURCE_CFG);\n\t\t\tk2 >>= 12;\n\t\t\tepaddcard(iobase, k2, EP_BUS_EISA);\n\t\t}\n\n\t\tfor (slot = 0; slot < 10; slot++) {\n\t\t\telink_reset();\n\t\t\telink_idseq(ELINK_509_POLY);\n\n\t\t\t/* Untag all the adapters so they will talk to us. */\n\t\t\tif (slot == 0)\n\t\t\t\toutb(ELINK_ID_PORT, TAG_ADAPTER + 0);\n\n\t\t\tvendor =\n\t\t\t    htons(epreadeeprom(ELINK_ID_PORT, EEPROM_MFG_ID));\n\t\t\tif (vendor != MFG_ID)\n\t\t\t\tcontinue;\n\n\t\t\tmodel =\n\t\t\t    htons(epreadeeprom(ELINK_ID_PORT, EEPROM_PROD_ID));\n\t\t\tif ((model & 0xfff0) != PROD_ID) {\n#ifndef trusted\n\t\t\t\tprintf(\"epprobe: ignoring model %04x\\n\", model);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tk = epreadeeprom(ELINK_ID_PORT, EEPROM_ADDR_CFG);\n\t\t\tk = (k & 0x1f) * 0x10 + 0x200;\n\n\t\t\tk2 = epreadeeprom(ELINK_ID_PORT, EEPROM_RESOURCE_CFG);\n\t\t\tk2 >>= 12;\n\t\t\tepaddcard(k, k2, EP_BUS_ISA);\n\n\t\t\t/* so card will not respond to contention again */\n\t\t\toutb(ELINK_ID_PORT, TAG_ADAPTER + 1);\n\n\t\t\t/*\n\t\t\t * XXX: this should probably not be done here\n\t\t\t * because it enables the drq/irq lines from\n\t\t\t * the board. Perhaps it should be done after\n\t\t\t * we have checked for irq/drq collisions?\n\t\t\t */\n\t\t\toutb(ELINK_ID_PORT, ACTIVATE_ADAPTER_TO_CONFIG);\n\t\t}\n\t\t/* XXX should we sort by ethernet address? */\n\t}\n\n\tfor (i = 0; i < nepcards; i++) {\n\t\tif (epcards[i].available == 0)\n\t\t\tcontinue;\n\t\tif (ia->ia_iobase != IOBASEUNK &&\n\t\t    ia->ia_iobase != epcards[i].iobase)\n\t\t\tcontinue;\n\t\tif (ia->ia_irq != IRQUNK &&\n\t\t    ia->ia_irq != epcards[i].irq)\n\t\t\tcontinue;\n\t\tgoto good;\n\t}\n\treturn 0;\n\ngood:\n\tepcards[i].available = 0;\n\tsc->bustype = epcards[i].bustype;\n\tia->ia_iobase = epcards[i].iobase;\n\tia->ia_irq = epcards[i].irq;\n\tia->ia_iosize = 0x10;\n\tia->ia_msize = 0;\n\treturn 1;\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [
      "#define MAXEPCARDS 20\t/* if you have 21 cards in your machine... you lose */",
      "#define\tEP_BUS_EISA\t  \t0x2",
      "#define EP_BUS_ISA\t  \t0x0"
    ],
    "globals_used": [
      "static int epprobe",
      "static u_short epreadeeprom",
      "static struct epcard {\n\tint\tiobase;\n\tint\tirq;\n\tchar\tavailable;\n\tchar\tbustype;\n} epcards[MAXEPCARDS];",
      "static int nepcards;",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "ELINK_ID_PORT",
            "ACTIVATE_ADAPTER_TO_CONFIG"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "epaddcard",
          "args": [
            "k",
            "k2",
            "EP_BUS_ISA"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "epaddcard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "170-184",
          "snippet": "static void\nepaddcard(iobase, irq, bustype)\n\tint iobase;\n\tint irq;\n\tchar bustype;\n{\n\n\tif (nepcards >= MAXEPCARDS)\n\t\treturn;\n\tepcards[nepcards].iobase = iobase;\n\tepcards[nepcards].irq = (irq == 2) ? 9 : irq;\n\tepcards[nepcards].available = 1;\n\tepcards[nepcards].bustype = bustype;\n\tnepcards++;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [
            "#define MAXEPCARDS 20\t/* if you have 21 cards in your machine... you lose */"
          ],
          "globals_used": [
            "static struct epcard {\n\tint\tiobase;\n\tint\tirq;\n\tchar\tavailable;\n\tchar\tbustype;\n} epcards[MAXEPCARDS];",
            "static int nepcards;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define MAXEPCARDS 20\t/* if you have 21 cards in your machine... you lose */\n\nstatic struct epcard {\n\tint\tiobase;\n\tint\tirq;\n\tchar\tavailable;\n\tchar\tbustype;\n} epcards[MAXEPCARDS];\nstatic int nepcards;\n\nstatic void\nepaddcard(iobase, irq, bustype)\n\tint iobase;\n\tint irq;\n\tchar bustype;\n{\n\n\tif (nepcards >= MAXEPCARDS)\n\t\treturn;\n\tepcards[nepcards].iobase = iobase;\n\tepcards[nepcards].irq = (irq == 2) ? 9 : irq;\n\tepcards[nepcards].available = 1;\n\tepcards[nepcards].bustype = bustype;\n\tnepcards++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "epreadeeprom",
          "args": [
            "ELINK_ID_PORT",
            "EEPROM_RESOURCE_CFG"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "epreadeeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "1419-1431",
          "snippet": "static u_short\nepreadeeprom(id_port, offset)\n\tint     id_port;\n\tint     offset;\n{\n\tint i, data = 0;\n\n\toutb(id_port, 0x80 + offset);\n\tdelay(1000);\n\tfor (i = 0; i < 16; i++)\n\t\tdata = (data << 1) | (inw(id_port) & 1);\n\treturn (data);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u_short epreadeeprom",
            "__P((int id_port, int offset));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nstatic u_short epreadeeprom;\n__P((int id_port, int offset));\n\nstatic u_short\nepreadeeprom(id_port, offset)\n\tint     id_port;\n\tint     offset;\n{\n\tint i, data = 0;\n\n\toutb(id_port, 0x80 + offset);\n\tdelay(1000);\n\tfor (i = 0; i < 16; i++)\n\t\tdata = (data << 1) | (inw(id_port) & 1);\n\treturn (data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"epprobe: ignoring model %04x\\n\"",
            "model"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "epreadeeprom(ELINK_ID_PORT, EEPROM_PROD_ID)"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "epreadeeprom(ELINK_ID_PORT, EEPROM_MFG_ID)"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elink_idseq",
          "args": [
            "ELINK_509_POLY"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "elink_idseq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/elink.c",
          "lines": "111-129",
          "snippet": "void\nelink_idseq(iot, ioh, p)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tregister u_char p;\n{\n\tregister int i;\n\tregister u_char c;\n\n\tc = 0xff;\n\tfor (i = 255; i; i--) {\n\t\tbus_space_write_1(iot, ioh, 0, c);\n\t\tif (c & 0x80) {\n\t\t\tc <<= 1;\n\t\t\tc ^= p;\n\t\t} else\n\t\t\tc <<= 1;\n\t}\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nelink_idseq(iot, ioh, p)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tregister u_char p;\n{\n\tregister int i;\n\tregister u_char c;\n\n\tc = 0xff;\n\tfor (i = 255; i; i--) {\n\t\tbus_space_write_1(iot, ioh, 0, c);\n\t\tif (c & 0x80) {\n\t\t\tc <<= 1;\n\t\t\tc ^= p;\n\t\t} else\n\t\t\tc <<= 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elink_reset",
          "args": [],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "elink_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/elink.c",
          "lines": "67-103",
          "snippet": "void\nelink_reset(iot, ioh, bus)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint bus;\n{\n\tstruct elink_done_reset *er;\n\n\tif (elink_all_resets_initialized == 0) {\n\t\tLIST_INIT(&elink_all_resets);\n\t\telink_all_resets_initialized = 1;\n\t}\n\n\t/*\n\t * Reset these cards if we haven't done so already.\n\t */\n\tfor (er = elink_all_resets.lh_first; er != NULL;\n\t    er = er->er_link.le_next)\n\t\tif (er->er_bus == bus)\n\t\t\tgoto out;\n\n\t/* Mark this bus so we don't do it again. */\n\ter = (struct elink_done_reset *)malloc(sizeof(struct elink_done_reset),\n\t    M_DEVBUF, M_NOWAIT);\n\tif (er == NULL)\n\t\tpanic(\"elink_reset: can't allocate state storage\");\n\n\ter->er_bus = bus;\n\tLIST_INSERT_HEAD(&elink_all_resets, er, er_link);\n\n\t/* Haven't reset the cards on this bus, yet. */\n\tbus_space_write_1(iot, ioh, 0, ELINK_RESET);\n\n out:\n\tbus_space_write_1(iot, ioh, 0, 0x00);\n\tbus_space_write_1(iot, ioh, 0, 0x00);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(, elink_done_reset) elink_all_resets;",
            "static int elink_all_resets_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic LIST_HEAD(, elink_done_reset) elink_all_resets;\nstatic int elink_all_resets_initialized;\n\nvoid\nelink_reset(iot, ioh, bus)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint bus;\n{\n\tstruct elink_done_reset *er;\n\n\tif (elink_all_resets_initialized == 0) {\n\t\tLIST_INIT(&elink_all_resets);\n\t\telink_all_resets_initialized = 1;\n\t}\n\n\t/*\n\t * Reset these cards if we haven't done so already.\n\t */\n\tfor (er = elink_all_resets.lh_first; er != NULL;\n\t    er = er->er_link.le_next)\n\t\tif (er->er_bus == bus)\n\t\t\tgoto out;\n\n\t/* Mark this bus so we don't do it again. */\n\ter = (struct elink_done_reset *)malloc(sizeof(struct elink_done_reset),\n\t    M_DEVBUF, M_NOWAIT);\n\tif (er == NULL)\n\t\tpanic(\"elink_reset: can't allocate state storage\");\n\n\ter->er_bus = bus;\n\tLIST_INSERT_HEAD(&elink_all_resets, er, er_link);\n\n\t/* Haven't reset the cards on this bus, yet. */\n\tbus_space_write_1(iot, ioh, 0, ELINK_RESET);\n\n out:\n\tbus_space_write_1(iot, ioh, 0, 0x00);\n\tbus_space_write_1(iot, ioh, 0, 0x00);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + EP_W0_RESOURCE_CFG"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + EP_W0_ADDRESS_CFG"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "inw(iobase + EISA_MODEL)"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + EISA_MODEL"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "inw(iobase + EISA_VENDOR)"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + EISA_VENDOR"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CHIPID",
          "args": [
            "pa->pa_id"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDORID",
          "args": [
            "pa->pa_id"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define MAXEPCARDS 20\t/* if you have 21 cards in your machine... you lose */\n#define\tEP_BUS_EISA\t  \t0x2\n#define EP_BUS_ISA\t  \t0x0\n\nstatic int epprobe;\nstatic u_short epreadeeprom;\nstatic struct epcard {\n\tint\tiobase;\n\tint\tirq;\n\tchar\tavailable;\n\tchar\tbustype;\n} epcards[MAXEPCARDS];\nstatic int nepcards;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nint\nepprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct ep_softc *sc = match;\n\tstruct isa_attach_args *ia = aux;\n\tstatic int probed;\n\tint slot, iobase, i;\n\tu_short vendor, model;\n\tint k, k2;\n\n#if NPCI > 0\n\textern struct cfdriver pci_cd;\n\n\tif (parent->dv_cfdata->cf_driver == &pci_cd) {\n\t\tstruct pci_attach_args *pa = (struct pci_attach_args *) aux;\n\n\t\tif (PCI_VENDORID(pa->pa_id) != PCI_VENDOR_3COM)\n\t\t\treturn 0;\n\n\t\tswitch (PCI_CHIPID(pa->pa_id)) {\n\t\tcase PCI_PRODUCT_3COM_3C590:\n\t\tcase PCI_PRODUCT_3COM_3C595:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (nepcards >= MAXEPCARDS)\n\t\t\treturn 0;\n\n\t\tepcards[nepcards++].available = 0;\n\t\treturn 1;\n\t}\n#endif\n\n\tif (!probed) {\n\t\tprobed = 1;\n\n\t\t/* find all EISA cards */\n\t\tfor (slot = 1; slot < 16; slot++) {\n\t\t\tiobase = 0x1000 * slot;\n\n\t\t\tvendor = htons(inw(iobase + EISA_VENDOR));\n\t\t\tif (vendor != MFG_ID)\n\t\t\t\tcontinue;\n\n\t\t\tmodel = htons(inw(iobase + EISA_MODEL));\n\t\t\tif ((model & 0xfff0) != PROD_ID) {\n#ifndef trusted\n\t\t\t\tprintf(\"epprobe: ignoring model %04x\\n\", model);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toutb(iobase + EISA_CONTROL, EISA_ENABLE | EISA_RESET);\n\t\t\tdelay(10);\n\t\t\toutb(iobase + EISA_CONTROL, EISA_ENABLE);\n\t\t\t/* Wait for reset? */\n\t\t\tdelay(1000);\n\n\t\t\tk = inw(iobase + EP_W0_ADDRESS_CFG);\n\t\t\tk = (k & 0x1f) * 0x10 + 0x200;\n\n\t\t\tk2 = inw(iobase + EP_W0_RESOURCE_CFG);\n\t\t\tk2 >>= 12;\n\t\t\tepaddcard(iobase, k2, EP_BUS_EISA);\n\t\t}\n\n\t\tfor (slot = 0; slot < 10; slot++) {\n\t\t\telink_reset();\n\t\t\telink_idseq(ELINK_509_POLY);\n\n\t\t\t/* Untag all the adapters so they will talk to us. */\n\t\t\tif (slot == 0)\n\t\t\t\toutb(ELINK_ID_PORT, TAG_ADAPTER + 0);\n\n\t\t\tvendor =\n\t\t\t    htons(epreadeeprom(ELINK_ID_PORT, EEPROM_MFG_ID));\n\t\t\tif (vendor != MFG_ID)\n\t\t\t\tcontinue;\n\n\t\t\tmodel =\n\t\t\t    htons(epreadeeprom(ELINK_ID_PORT, EEPROM_PROD_ID));\n\t\t\tif ((model & 0xfff0) != PROD_ID) {\n#ifndef trusted\n\t\t\t\tprintf(\"epprobe: ignoring model %04x\\n\", model);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tk = epreadeeprom(ELINK_ID_PORT, EEPROM_ADDR_CFG);\n\t\t\tk = (k & 0x1f) * 0x10 + 0x200;\n\n\t\t\tk2 = epreadeeprom(ELINK_ID_PORT, EEPROM_RESOURCE_CFG);\n\t\t\tk2 >>= 12;\n\t\t\tepaddcard(k, k2, EP_BUS_ISA);\n\n\t\t\t/* so card will not respond to contention again */\n\t\t\toutb(ELINK_ID_PORT, TAG_ADAPTER + 1);\n\n\t\t\t/*\n\t\t\t * XXX: this should probably not be done here\n\t\t\t * because it enables the drq/irq lines from\n\t\t\t * the board. Perhaps it should be done after\n\t\t\t * we have checked for irq/drq collisions?\n\t\t\t */\n\t\t\toutb(ELINK_ID_PORT, ACTIVATE_ADAPTER_TO_CONFIG);\n\t\t}\n\t\t/* XXX should we sort by ethernet address? */\n\t}\n\n\tfor (i = 0; i < nepcards; i++) {\n\t\tif (epcards[i].available == 0)\n\t\t\tcontinue;\n\t\tif (ia->ia_iobase != IOBASEUNK &&\n\t\t    ia->ia_iobase != epcards[i].iobase)\n\t\t\tcontinue;\n\t\tif (ia->ia_irq != IRQUNK &&\n\t\t    ia->ia_irq != epcards[i].irq)\n\t\t\tcontinue;\n\t\tgoto good;\n\t}\n\treturn 0;\n\ngood:\n\tepcards[i].available = 0;\n\tsc->bustype = epcards[i].bustype;\n\tia->ia_iobase = epcards[i].iobase;\n\tia->ia_irq = epcards[i].irq;\n\tia->ia_iosize = 0x10;\n\tia->ia_msize = 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "ep_pcmcia_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "360-365",
    "snippet": "int\nep_pcmcia_detach(self)\n\tstruct device *self;\n{\n\treturn EBUSY;\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nint\nep_pcmcia_detach(self)\n\tstruct device *self;\n{\n\treturn EBUSY;\n}"
  },
  {
    "function_name": "ep_pcmcia_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "340-354",
    "snippet": "void\nep_pcmcia_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct pcmcia_attach_args *paa = aux;\n\t\n\tprintf(\"ep_pcmcia_attach %p %p %p\\n\", parent, self, aux);\n\tdelay(2000000);\n\tif (!pcmcia_configure(parent, self, paa->paa_link)) {\n\t\tstruct ep_softc *sc = (void *)self;\n\t\tsc->pcmcia_flags |= EP_ABSENT;\n\t\tprintf(\": not attached\\n\");\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [
      "#define EP_ABSENT\t\t0x02"
    ],
    "globals_used": [
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": not attached\\n\""
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_configure",
          "args": [
            "parent",
            "self",
            "paa->paa_link"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "2000000"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define EP_ABSENT\t\t0x02\n\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nep_pcmcia_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct pcmcia_attach_args *paa = aux;\n\t\n\tprintf(\"ep_pcmcia_attach %p %p %p\\n\", parent, self, aux);\n\tdelay(2000000);\n\tif (!pcmcia_configure(parent, self, paa->paa_link)) {\n\t\tstruct ep_softc *sc = (void *)self;\n\t\tsc->pcmcia_flags |= EP_ABSENT;\n\t\tprintf(\": not attached\\n\");\n\t}\n}"
  },
  {
    "function_name": "ep_pcmcia_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "331-338",
    "snippet": "int\nep_pcmcia_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\treturn pcmcia_slave_match(parent, match, aux, pcmcia_ep_devs,\n\t\t\t\t  nep_pcmcia_devs);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [
      "#define nep_pcmcia_devs sizeof(pcmcia_ep_devs)/sizeof(pcmcia_ep_devs[0])"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_slave_match",
          "args": [
            "parent",
            "match",
            "aux",
            "pcmcia_ep_devs",
            "nep_pcmcia_devs"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define nep_pcmcia_devs sizeof(pcmcia_ep_devs)/sizeof(pcmcia_ep_devs[0])\n\nint\nep_pcmcia_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\treturn pcmcia_slave_match(parent, match, aux, pcmcia_ep_devs,\n\t\t\t\t  nep_pcmcia_devs);\n}"
  },
  {
    "function_name": "ep_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "291-303",
    "snippet": "static int\nep_remove(pc_link, self)\n\tstruct pcmcia_link *pc_link;\n\tstruct device  *self;\n{\n\tstruct ep_softc *sc = (void *) self;\n\tstruct ifnet   *ifp = &sc->sc_arpcom.ac_if;\n\tif_down(ifp);\n\tepstop(sc);\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_UP);\n\tsc->pcmcia_flags = EP_ABSENT;\n\treturn PCMCIA_BUS_UNCONFIG(pc_link->adapter, pc_link);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [
      "#define EP_ABSENT\t\t0x02"
    ],
    "globals_used": [
      "void epstop",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCMCIA_BUS_UNCONFIG",
          "args": [
            "pc_link->adapter",
            "pc_link"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epstop",
          "args": [
            "sc"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "epstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "1384-1403",
          "snippet": "void\nepstop(sc)\n\tregister struct ep_softc *sc;\n{\n\n\toutw(BASE + EP_COMMAND, RX_DISABLE);\n\toutw(BASE + EP_COMMAND, RX_DISCARD_TOP_PACK);\n\twhile (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\toutw(BASE + EP_COMMAND, TX_DISABLE);\n\toutw(BASE + EP_COMMAND, STOP_TRANSCEIVER);\n\toutw(BASE + EP_COMMAND, RX_RESET);\n\toutw(BASE + EP_COMMAND, TX_RESET);\n\toutw(BASE + EP_COMMAND, C_INTR_LATCH);\n\toutw(BASE + EP_COMMAND, SET_RD_0_MASK);\n\toutw(BASE + EP_COMMAND, SET_INTR_MASK);\n\toutw(BASE + EP_COMMAND, SET_RX_FILTER);\n\n\tepmbufempty(sc);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void epmbufempty",
            "void epstop",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nvoid epmbufempty;\nvoid epstop;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepstop(sc)\n\tregister struct ep_softc *sc;\n{\n\n\toutw(BASE + EP_COMMAND, RX_DISABLE);\n\toutw(BASE + EP_COMMAND, RX_DISCARD_TOP_PACK);\n\twhile (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\toutw(BASE + EP_COMMAND, TX_DISABLE);\n\toutw(BASE + EP_COMMAND, STOP_TRANSCEIVER);\n\toutw(BASE + EP_COMMAND, RX_RESET);\n\toutw(BASE + EP_COMMAND, TX_RESET);\n\toutw(BASE + EP_COMMAND, C_INTR_LATCH);\n\toutw(BASE + EP_COMMAND, SET_RD_0_MASK);\n\toutw(BASE + EP_COMMAND, SET_INTR_MASK);\n\toutw(BASE + EP_COMMAND, SET_RX_FILTER);\n\n\tepmbufempty(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "if_down",
          "args": [
            "ifp"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define EP_ABSENT\t\t0x02\n\nvoid epstop;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nstatic int\nep_remove(pc_link, self)\n\tstruct pcmcia_link *pc_link;\n\tstruct device  *self;\n{\n\tstruct ep_softc *sc = (void *) self;\n\tstruct ifnet   *ifp = &sc->sc_arpcom.ac_if;\n\tif_down(ifp);\n\tepstop(sc);\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_UP);\n\tsc->pcmcia_flags = EP_ABSENT;\n\treturn PCMCIA_BUS_UNCONFIG(pc_link->adapter, pc_link);\n}"
  },
  {
    "function_name": "epmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "264-289",
    "snippet": "static int\nepmod(pc_link, self, pc_cf, cf)\n\tstruct pcmcia_link *pc_link;\n\tstruct device  *self;\n\tstruct pcmcia_conf *pc_cf;\n\tstruct cfdata  *cf;\n{\n\tint             err;\n/*\tstruct pcmciadevs *dev = pc_link->device;*/\n/*\tstruct ep_softc *sc = (void *) self;*/\n\n\tif ((err = PCMCIA_BUS_CONFIG(pc_link->adapter, pc_link, self,\n\t\t\t\t     pc_cf, cf)) != 0) {\n\t\tprintf(\"bus_config failed %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (pc_cf->io[0].len > 0x10)\n\t    pc_cf->io[0].len = 0x10;\n#if 0\n\tpc_cf->cfgtype = DOSRESET;\n#endif\n\tpc_cf->cfgtype = 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"bus_config failed %d\\n\"",
            "err"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCMCIA_BUS_CONFIG",
          "args": [
            "pc_link->adapter",
            "pc_link",
            "self",
            "pc_cf",
            "cf"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nstatic int\nepmod(pc_link, self, pc_cf, cf)\n\tstruct pcmcia_link *pc_link;\n\tstruct device  *self;\n\tstruct pcmcia_conf *pc_cf;\n\tstruct cfdata  *cf;\n{\n\tint             err;\n/*\tstruct pcmciadevs *dev = pc_link->device;*/\n/*\tstruct ep_softc *sc = (void *) self;*/\n\n\tif ((err = PCMCIA_BUS_CONFIG(pc_link->adapter, pc_link, self,\n\t\t\t\t     pc_cf, cf)) != 0) {\n\t\tprintf(\"bus_config failed %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (pc_cf->io[0].len > 0x10)\n\t    pc_cf->io[0].len = 0x10;\n#if 0\n\tpc_cf->cfgtype = DOSRESET;\n#endif\n\tpc_cf->cfgtype = 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ep_pcmcia_isa_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "204-261",
    "snippet": "static int\nep_pcmcia_isa_attach(parent, match, aux, pc_link)\n\tstruct device\t*parent;\n\tvoid\t\t*match;\n\tvoid\t\t*aux;\n\tstruct pcmcia_link *pc_link;\n{\n\tstruct ep_softc *sc = (void *) match;\n/*\tstruct cfdata  *cf = sc->sc_dev.dv_cfdata;*/\n\tstruct isa_attach_args *ia = aux;\n/*\tstruct pcmciadevs *dev = pc_link->device;*/\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint             i;\n\textern int      ifqmaxlen;\n\n\toutw(ia->ia_iobase + EP_COMMAND, WINDOW_SELECT | 0);\n\toutw(ia->ia_iobase + EP_W0_CONFIG_CTRL, ENABLE_DRQ_IRQ);\n\toutw(ia->ia_iobase + EP_W0_RESOURCE_CFG, 0x3f00);\n\n\t/*\n\t * ok til here. Now try to figure out which link we have.\n\t * try coax first...\n\t */\n#ifdef EP_COAX_DEFAULT\n\toutw(ia->ia_iobase + EP_W0_ADDRESS_CFG, 0xC000);\n#else\n\t/* COAX as default is reported to be a problem */\n\toutw(ia->ia_iobase + EP_W0_ADDRESS_CFG, 0x0000);\n#endif\n\tifp->if_snd.ifq_maxlen = ifqmaxlen;\n\n\tepaddcard(ia->ia_iobase, ia->ia_irq, EP_BUS_PCMCIA);\n\n\tfor (i = 0; i < nepcards; i++) {\n\t\tif (epcards[i].available == 0)\n\t\t\tcontinue;\n\t\tif (ia->ia_iobase != IOBASEUNK &&\n\t\t    ia->ia_iobase != epcards[i].iobase)\n\t\t\tcontinue;\n\t\tif (ia->ia_irq != IRQUNK &&\n\t\t    ia->ia_irq != epcards[i].irq)\n\t\t\tcontinue;\n\t\tgoto good;\n\t}\n\treturn 0;\n\ngood:\n\n\tepcards[i].available = 0;\n\tia->ia_iobase = epcards[i].iobase;\n\tia->ia_irq = epcards[i].irq;\n\tia->ia_iosize = 0x10;\n\tia->ia_msize = 0;\n\n \tsc->bustype = epcards[i].bustype;\n\tsc->pcmcia_flags = (pc_link->flags & PCMCIA_REATTACH) ? EP_REATTACH:0;\n\treturn 1;\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [
      "#define EP_REATTACH\t\t0x01",
      "#define\tEP_BUS_PCMCIA\t  \t0x1"
    ],
    "globals_used": [
      "static struct epcard {\n\tint\tiobase;\n\tint\tirq;\n\tchar\tavailable;\n\tchar\tbustype;\n} epcards[MAXEPCARDS];",
      "static int nepcards;",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "epaddcard",
          "args": [
            "ia->ia_iobase",
            "ia->ia_irq",
            "EP_BUS_PCMCIA"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "epaddcard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
          "lines": "170-184",
          "snippet": "static void\nepaddcard(iobase, irq, bustype)\n\tint iobase;\n\tint irq;\n\tchar bustype;\n{\n\n\tif (nepcards >= MAXEPCARDS)\n\t\treturn;\n\tepcards[nepcards].iobase = iobase;\n\tepcards[nepcards].irq = (irq == 2) ? 9 : irq;\n\tepcards[nepcards].available = 1;\n\tepcards[nepcards].bustype = bustype;\n\tnepcards++;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_epreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include \"pci.h\"",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include \"ep.h\"",
            "#include \"bpfilter.h\"",
            "#include \"pcmcia.h\""
          ],
          "macros_used": [
            "#define MAXEPCARDS 20\t/* if you have 21 cards in your machine... you lose */"
          ],
          "globals_used": [
            "static struct epcard {\n\tint\tiobase;\n\tint\tirq;\n\tchar\tavailable;\n\tchar\tbustype;\n} epcards[MAXEPCARDS];",
            "static int nepcards;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define MAXEPCARDS 20\t/* if you have 21 cards in your machine... you lose */\n\nstatic struct epcard {\n\tint\tiobase;\n\tint\tirq;\n\tchar\tavailable;\n\tchar\tbustype;\n} epcards[MAXEPCARDS];\nstatic int nepcards;\n\nstatic void\nepaddcard(iobase, irq, bustype)\n\tint iobase;\n\tint irq;\n\tchar bustype;\n{\n\n\tif (nepcards >= MAXEPCARDS)\n\t\treturn;\n\tepcards[nepcards].iobase = iobase;\n\tepcards[nepcards].irq = (irq == 2) ? 9 : irq;\n\tepcards[nepcards].available = 1;\n\tepcards[nepcards].bustype = bustype;\n\tnepcards++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "ia->ia_iobase + EP_W0_ADDRESS_CFG",
            "0x0000"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "ia->ia_iobase + EP_W0_ADDRESS_CFG",
            "0xC000"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "ia->ia_iobase + EP_W0_RESOURCE_CFG",
            "0x3f00"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "ia->ia_iobase + EP_W0_CONFIG_CTRL",
            "ENABLE_DRQ_IRQ"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "ia->ia_iobase + EP_COMMAND",
            "WINDOW_SELECT | 0"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define EP_REATTACH\t\t0x01\n#define\tEP_BUS_PCMCIA\t  \t0x1\n\nstatic struct epcard {\n\tint\tiobase;\n\tint\tirq;\n\tchar\tavailable;\n\tchar\tbustype;\n} epcards[MAXEPCARDS];\nstatic int nepcards;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nstatic int\nep_pcmcia_isa_attach(parent, match, aux, pc_link)\n\tstruct device\t*parent;\n\tvoid\t\t*match;\n\tvoid\t\t*aux;\n\tstruct pcmcia_link *pc_link;\n{\n\tstruct ep_softc *sc = (void *) match;\n/*\tstruct cfdata  *cf = sc->sc_dev.dv_cfdata;*/\n\tstruct isa_attach_args *ia = aux;\n/*\tstruct pcmciadevs *dev = pc_link->device;*/\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint             i;\n\textern int      ifqmaxlen;\n\n\toutw(ia->ia_iobase + EP_COMMAND, WINDOW_SELECT | 0);\n\toutw(ia->ia_iobase + EP_W0_CONFIG_CTRL, ENABLE_DRQ_IRQ);\n\toutw(ia->ia_iobase + EP_W0_RESOURCE_CFG, 0x3f00);\n\n\t/*\n\t * ok til here. Now try to figure out which link we have.\n\t * try coax first...\n\t */\n#ifdef EP_COAX_DEFAULT\n\toutw(ia->ia_iobase + EP_W0_ADDRESS_CFG, 0xC000);\n#else\n\t/* COAX as default is reported to be a problem */\n\toutw(ia->ia_iobase + EP_W0_ADDRESS_CFG, 0x0000);\n#endif\n\tifp->if_snd.ifq_maxlen = ifqmaxlen;\n\n\tepaddcard(ia->ia_iobase, ia->ia_irq, EP_BUS_PCMCIA);\n\n\tfor (i = 0; i < nepcards; i++) {\n\t\tif (epcards[i].available == 0)\n\t\t\tcontinue;\n\t\tif (ia->ia_iobase != IOBASEUNK &&\n\t\t    ia->ia_iobase != epcards[i].iobase)\n\t\t\tcontinue;\n\t\tif (ia->ia_irq != IRQUNK &&\n\t\t    ia->ia_irq != epcards[i].irq)\n\t\t\tcontinue;\n\t\tgoto good;\n\t}\n\treturn 0;\n\ngood:\n\n\tepcards[i].available = 0;\n\tia->ia_iobase = epcards[i].iobase;\n\tia->ia_irq = epcards[i].irq;\n\tia->ia_iosize = 0x10;\n\tia->ia_msize = 0;\n\n \tsc->bustype = epcards[i].bustype;\n\tsc->pcmcia_flags = (pc_link->flags & PCMCIA_REATTACH) ? EP_REATTACH:0;\n\treturn 1;\n}"
  },
  {
    "function_name": "epaddcard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ep.c",
    "lines": "170-184",
    "snippet": "static void\nepaddcard(iobase, irq, bustype)\n\tint iobase;\n\tint irq;\n\tchar bustype;\n{\n\n\tif (nepcards >= MAXEPCARDS)\n\t\treturn;\n\tepcards[nepcards].iobase = iobase;\n\tepcards[nepcards].irq = (irq == 2) ? 9 : irq;\n\tepcards[nepcards].available = 1;\n\tepcards[nepcards].bustype = bustype;\n\tnepcards++;\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_epreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/cpu.h>",
      "#include \"pci.h\"",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include \"ep.h\"",
      "#include \"bpfilter.h\"",
      "#include \"pcmcia.h\""
    ],
    "macros_used": [
      "#define MAXEPCARDS 20\t/* if you have 21 cards in your machine... you lose */"
    ],
    "globals_used": [
      "static struct epcard {\n\tint\tiobase;\n\tint\tirq;\n\tchar\tavailable;\n\tchar\tbustype;\n} epcards[MAXEPCARDS];",
      "static int nepcards;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/elink.h>\n#include <dev/isa/if_epreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include \"pci.h\"\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include \"ep.h\"\n#include \"bpfilter.h\"\n#include \"pcmcia.h\"\n\n#define MAXEPCARDS 20\t/* if you have 21 cards in your machine... you lose */\n\nstatic struct epcard {\n\tint\tiobase;\n\tint\tirq;\n\tchar\tavailable;\n\tchar\tbustype;\n} epcards[MAXEPCARDS];\nstatic int nepcards;\n\nstatic void\nepaddcard(iobase, irq, bustype)\n\tint iobase;\n\tint irq;\n\tchar bustype;\n{\n\n\tif (nepcards >= MAXEPCARDS)\n\t\treturn;\n\tepcards[nepcards].iobase = iobase;\n\tepcards[nepcards].irq = (irq == 2) ? 9 : irq;\n\tepcards[nepcards].available = 1;\n\tepcards[nepcards].bustype = bustype;\n\tnepcards++;\n}"
  }
]