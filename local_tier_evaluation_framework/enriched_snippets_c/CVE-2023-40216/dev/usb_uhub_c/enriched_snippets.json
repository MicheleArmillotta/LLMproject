[
  {
    "function_name": "uhub_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhub.c",
    "lines": "575-588",
    "snippet": "void\nuhub_intr(xfer, addr, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle addr;\n\tusbd_status status;\n{\n\tstruct uhub_softc *sc = addr;\n\n\tDPRINTFN(5,(\"uhub_intr: sc=%p\\n\", sc));\n\tif (status != USBD_NORMAL_COMPLETION)\n\t\tusbd_clear_endpoint_stall_async(sc->sc_ipipe);\n\n\tusb_needs_explore(sc->sc_hub->bus);\n}",
    "includes": [
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include \"bus_if.h\"",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "uhub_intr __P((usbd_xfer_handle, usbd_private_handle,usbd_status));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_needs_explore",
          "args": [
            "sc->sc_hub->bus"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "usb_needs_explore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
          "lines": "618-628",
          "snippet": "void\nusb_needs_explore(bus)\n\tusbd_bus_handle bus;\n{\n\tbus->needs_explore = 1;\n#if defined(__FreeBSD__)\n\t/* This part should be deleted when kthreads is available */\n\tselwakeup(&bus->usbctl->sc_consel);\n#endif\n\twakeup(&bus->needs_explore);\n}",
          "includes": [
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <machine/bus.h>",
            "#include \"usb_if.h\"",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/vnode.h>",
            "#include <sys/select.h>",
            "#include <sys/poll.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/filio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/proc.h>",
            "#include <sys/kthread.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_needs_explore(bus)\n\tusbd_bus_handle bus;\n{\n\tbus->needs_explore = 1;\n#if defined(__FreeBSD__)\n\t/* This part should be deleted when kthreads is available */\n\tselwakeup(&bus->usbctl->sc_consel);\n#endif\n\twakeup(&bus->needs_explore);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_clear_endpoint_stall_async",
          "args": [
            "sc->sc_ipipe"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_clear_endpoint_stall_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "611-628",
          "snippet": "usbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uhub_intr: sc=%p\\n\", sc)"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include \"bus_if.h\"\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nuhub_intr __P((usbd_xfer_handle, usbd_private_handle,usbd_status));\n\nvoid\nuhub_intr(xfer, addr, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle addr;\n\tusbd_status status;\n{\n\tstruct uhub_softc *sc = addr;\n\n\tDPRINTFN(5,(\"uhub_intr: sc=%p\\n\", sc));\n\tif (status != USBD_NORMAL_COMPLETION)\n\t\tusbd_clear_endpoint_stall_async(sc->sc_ipipe);\n\n\tusb_needs_explore(sc->sc_hub->bus);\n}"
  },
  {
    "function_name": "uhub_child_detached",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhub.c",
    "lines": "537-565",
    "snippet": "Static void\nuhub_child_detached(self, child)\n       device_t self;\n       device_t child;\n{\n       struct uhub_softc *sc = device_get_softc(self);\n       usbd_device_handle devhub = sc->sc_hub;\n       usbd_device_handle dev;\n       int nports;\n       int port;\n       int i;\n\n       if (!devhub->hub)  \n               /* should never happen; children are only created after init */\n               panic(\"hub not fully initialised, but child deleted?\");\n\n       nports = devhub->hub->hubdesc.bNbrPorts;\n       for (port = 0; port < nports; port++) {\n               dev = devhub->hub->ports[port].device;\n               if (dev && dev->subdevs) {\n                       for (i = 0; dev->subdevs[i]; i++) {\n                               if (dev->subdevs[i] == child) {\n                                       dev->subdevs[i] = NULL;\n                                       return;\n                               }\n                       }\n               }\n       }\n}",
    "includes": [
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include \"bus_if.h\"",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhub_explore __P((usbd_device_handle hub));",
      "Static void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"hub not fully initialised, but child deleted?\""
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_get_softc",
          "args": [
            "self"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include \"bus_if.h\"\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhub_explore __P((usbd_device_handle hub));\nStatic void;\n\nStatic void\nuhub_child_detached(self, child)\n       device_t self;\n       device_t child;\n{\n       struct uhub_softc *sc = device_get_softc(self);\n       usbd_device_handle devhub = sc->sc_hub;\n       usbd_device_handle dev;\n       int nports;\n       int port;\n       int i;\n\n       if (!devhub->hub)  \n               /* should never happen; children are only created after init */\n               panic(\"hub not fully initialised, but child deleted?\");\n\n       nports = devhub->hub->hubdesc.bNbrPorts;\n       for (port = 0; port < nports; port++) {\n               dev = devhub->hub->ports[port].device;\n               if (dev && dev->subdevs) {\n                       for (i = 0; dev->subdevs[i]; i++) {\n                               if (dev->subdevs[i] == child) {\n                                       dev->subdevs[i] = NULL;\n                                       return;\n                               }\n                       }\n               }\n       }\n}"
  },
  {
    "function_name": "uhub_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhub.c",
    "lines": "464-493",
    "snippet": "int\nuhub_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct uhub_softc *sc = (struct uhub_softc *)self;\n\tstruct usbd_hub *hub = sc->sc_hub->hub;\n\tusbd_device_handle dev;\n\tint nports, port, i;\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tif (hub == NULL) /* malfunctioning hub */\n\t\t\tbreak;\n\t\tnports = hub->hubdesc.bNbrPorts;\n\t\tfor(port = 0; port < nports; port++) {\n\t\t\tdev = hub->ports[port].device;\n\t\t\tif (dev != NULL) {\n\t\t\t\tfor (i = 0; dev->subdevs[i]; i++)\n\t\t\t\t\tconfig_deactivate(dev->subdevs[i]);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include \"bus_if.h\"",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhub_explore __P((usbd_device_handle hub));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_deactivate",
          "args": [
            "dev->subdevs[i]"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include \"bus_if.h\"\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhub_explore __P((usbd_device_handle hub));\n\nint\nuhub_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct uhub_softc *sc = (struct uhub_softc *)self;\n\tstruct usbd_hub *hub = sc->sc_hub->hub;\n\tusbd_device_handle dev;\n\tint nports, port, i;\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tif (hub == NULL) /* malfunctioning hub */\n\t\t\tbreak;\n\t\tnports = hub->hubdesc.bNbrPorts;\n\t\tfor(port = 0; port < nports; port++) {\n\t\t\tdev = hub->ports[port].device;\n\t\t\tif (dev != NULL) {\n\t\t\t\tfor (i = 0; dev->subdevs[i]; i++)\n\t\t\t\t\tconfig_deactivate(dev->subdevs[i]);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "uhub_explore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhub.c",
    "lines": "335-461",
    "snippet": "usbd_status\nuhub_explore(dev)\n\tusbd_device_handle dev;\n{\n\tusb_hub_descriptor_t *hd = &dev->hub->hubdesc;\n\tstruct uhub_softc *sc = dev->hub->hubsoftc;\n\tstruct usbd_port *up;\n\tusbd_status err;\n\tint port;\n\tint change, status;\n\n\tDPRINTFN(10, (\"uhub_explore dev=%p addr=%d\\n\", dev, dev->address));\n\n\tif (!sc->sc_running)\n\t\treturn (USBD_NOT_STARTED);\n\n\t/* Ignore hubs that are too deep. */\n\tif (dev->depth > USB_HUB_MAX_DEPTH)\n\t\treturn (USBD_TOO_DEEP);\n\n\tfor(port = 1; port <= hd->bNbrPorts; port++) {\n\t\tup = &dev->hub->ports[port-1];\n\t\terr = usbd_get_port_status(dev, port, &up->status);\n\t\tif (err) {\n\t\t\tDPRINTF((\"uhub_explore: get port status failed, \"\n\t\t\t\t \"error=%s\\n\", usbd_errstr(err)));\n\t\t\tcontinue;\n\t\t}\n\t\tstatus = UGETW(up->status.wPortStatus);\n\t\tchange = UGETW(up->status.wPortChange);\n\t\tDPRINTFN(3,(\"uhub_explore: port %d status 0x%04x 0x%04x\\n\",\n\t\t\t    port, status, change));\n\t\tif (change & UPS_C_PORT_ENABLED) {\n\t\t\tDPRINTF((\"uhub_explore: C_PORT_ENABLED\\n\"));\n\t\t\tusbd_clear_port_feature(dev, port, UHF_C_PORT_ENABLE);\n\t\t\tif (status & UPS_PORT_ENABLED) {\n\t\t\t\tprintf(\"%s: illegal enable change, port %d\\n\",\n\t\t\t\t       USBDEVNAME(sc->sc_dev), port);\n\t\t\t} else {\n\t\t\t\t/* Port error condition. */\n\t\t\t\tif (up->restartcnt++ < USBD_RESTART_MAX) {\n\t\t\t\t\tprintf(\"%s: port error, restarting \"\n\t\t\t\t\t       \"port %d\\n\",\n\t\t\t\t\t       USBDEVNAME(sc->sc_dev), port);\n\t\t\t\t\tgoto disco;\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"%s: port error, giving up \"\n\t\t\t\t\t       \"port %d\\n\",\n\t\t\t\t\t       USBDEVNAME(sc->sc_dev), port);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!(change & UPS_C_CONNECT_STATUS)) {\n\t\t\tDPRINTFN(3,(\"uhub_explore: port=%d !C_CONNECT_\"\n\t\t\t\t    \"STATUS\\n\", port));\n\t\t\t/* No status change, just do recursive explore. */\n\t\t\tif (up->device && up->device->hub)\n\t\t\t\tup->device->hub->explore(up->device);\n\t\t\tcontinue;\n\t\t}\n\t\tDPRINTF((\"uhub_explore: status change hub=%d port=%d\\n\",\n\t\t\t dev->address, port));\n\t\tusbd_clear_port_feature(dev, port, UHF_C_PORT_CONNECTION);\n\t\tusbd_clear_port_feature(dev, port, UHF_C_PORT_ENABLE);\n\t\t/*\n\t\t * If there is already a device on the port the change status\n\t\t * must mean that is has disconnected.  Looking at the\n\t\t * current connect status is not enough to figure this out\n\t\t * since a new unit may have been connected before we handle\n\t\t * the disconnect.\n\t\t */\n\tdisco:\n\t\tif (up->device != NULL) {\n\t\t\t/* Disconnected */\n\t\t\tDPRINTF((\"uhub_explore: device addr=%d disappeared \"\n\t\t\t\t \"on port %d\\n\", up->device->address, port));\n\t\t\tusb_disconnect_port(up, USBDEV(sc->sc_dev));\n\t\t\tusbd_clear_port_feature(dev, port, \n\t\t\t\t\t\tUHF_C_PORT_CONNECTION);\n\t\t}\n\t\tif (!(status & UPS_CURRENT_CONNECT_STATUS)) {\n\t\t\tDPRINTFN(3,(\"uhub_explore: port=%d !CURRENT_CONNECT\"\n\t\t\t\t    \"_STATUS\\n\", port));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Connected */\n\t\tup->restartcnt = 0;\n\n\t\t/* Wait for maximum device power up time. */\n\t\tusbd_delay_ms(dev, USB_PORT_POWERUP_DELAY);\n\n\t\t/* Reset port, which implies enabling it. */\n\t\tif (usbd_reset_port(dev, port, &up->status)) {\n\t\t\tDPRINTF((\"uhub_explore: port=%d reset failed\\n\",\n\t\t\t\t port));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get device info and set its address. */\n\t\terr = usbd_new_device(USBDEV(sc->sc_dev), dev->bus, \n\t\t\t  dev->depth + 1, status & UPS_LOW_SPEED, \n\t\t\t  port, up);\n\t\t/* XXX retry a few times? */\n\t\tif (err) {\n\t\t\tDPRINTFN(-1,(\"uhub_explore: usb_new_device failed, \"\n\t\t\t\t     \"error=%s\\n\", usbd_errstr(err)));\n\t\t\t/* Avoid addressing problems by disabling. */\n\t\t\t/* usbd_reset_port(dev, port, &up->status); */\n\n\t\t\t/* \n\t\t\t * The unit refused to accept a new address, or had\n\t\t\t * some other serious problem.  Since we cannot leave\n\t\t\t * at 0 we have to disable the port instead.\n\t\t\t */\n\t\t\tprintf(\"%s: device problem, disabling port %d\\n\",\n\t\t\t       USBDEVNAME(sc->sc_dev), port);\n\t\t\tusbd_clear_port_feature(dev, port, UHF_PORT_ENABLE);\n\t\t\t/* Make sure we don't try to restart it infinitely. */\n\t\t\tup->restartcnt = USBD_RESTART_MAX;\n\t\t} else {\n\t\t\tif (up->device->hub)\n\t\t\t\tup->device->hub->explore(up->device);\n\t\t}\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include \"bus_if.h\"",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "uhub_init_port __P((struct usbd_port *));",
      "Static usbd_status",
      "uhub_explore __P((usbd_device_handle hub));",
      "uhub_intr __P((usbd_xfer_handle, usbd_private_handle,usbd_status));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up->device->hub->explore",
          "args": [
            "up->device"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_clear_port_feature",
          "args": [
            "dev",
            "port",
            "UHF_PORT_ENABLE"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_clear_port_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "222-235",
          "snippet": "usbd_status\nusbd_clear_port_feature(dev, port, sel)\n\tusbd_device_handle dev;\n\tint port, sel;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_WRITE_CLASS_OTHER;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, sel);\n\tUSETW(req.wIndex, port);\n\tUSETW(req.wLength, 0);\n\treturn (usbd_do_request(dev, &req, 0));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_clear_port_feature(dev, port, sel)\n\tusbd_device_handle dev;\n\tint port, sel;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_WRITE_CLASS_OTHER;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, sel);\n\tUSETW(req.wIndex, port);\n\tUSETW(req.wLength, 0);\n\treturn (usbd_do_request(dev, &req, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: device problem, disabling port %d\\n\"",
            "USBDEVNAME(sc->sc_dev)",
            "port"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "-1",
            "(\"uhub_explore: usb_new_device failed, \"\n\t\t\t\t     \"error=%s\\n\", usbd_errstr(err))"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_new_device",
          "args": [
            "USBDEV(sc->sc_dev)",
            "dev->bus",
            "dev->depth + 1",
            "status & UPS_LOW_SPEED",
            "port",
            "up"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_new_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "909-1046",
          "snippet": "usbd_status\nusbd_new_device(parent, bus, depth, lowspeed, port, up)\n\tdevice_ptr_t parent;\n\tusbd_bus_handle bus;\n\tint depth;\n\tint lowspeed;\n\tint port;\n\tstruct usbd_port *up;\n{\n\tusbd_device_handle dev;\n\tusb_device_descriptor_t *dd;\n\tusbd_status err;\n\tint addr;\n\tint i;\n\n\tDPRINTF((\"usbd_new_device bus=%p port=%d depth=%d lowspeed=%d\\n\",\n\t\t bus, port, depth, lowspeed));\n\taddr = usbd_getnewaddr(bus);\n\tif (addr < 0) {\n\t\tprintf(\"%s: No free USB addresses, new device ignored.\\n\", \n\t\t       USBDEVNAME(bus->bdev));\n\t\treturn (USBD_NO_ADDR);\n\t}\n\n\tdev = malloc(sizeof *dev, M_USB, M_NOWAIT);\n\tif (dev == NULL)\n\t\treturn (USBD_NOMEM);\n\tmemset(dev, 0, sizeof(*dev));\n\n\tdev->bus = bus;\n\n\t/* Set up default endpoint handle. */\n\tdev->def_ep.edesc = &dev->def_ep_desc;\n\n\t/* Set up default endpoint descriptor. */\n\tdev->def_ep_desc.bLength = USB_ENDPOINT_DESCRIPTOR_SIZE;\n\tdev->def_ep_desc.bDescriptorType = UDESC_ENDPOINT;\n\tdev->def_ep_desc.bEndpointAddress = USB_CONTROL_ENDPOINT;\n\tdev->def_ep_desc.bmAttributes = UE_CONTROL;\n\tUSETW(dev->def_ep_desc.wMaxPacketSize, USB_MAX_IPACKET);\n\tdev->def_ep_desc.bInterval = 0;\n\n\tdev->quirks = &usbd_no_quirk;\n\tdev->address = USB_START_ADDR;\n\tdev->ddesc.bMaxPacketSize = 0;\n\tdev->lowspeed = lowspeed != 0;\n\tdev->depth = depth;\n\tdev->powersrc = up;\n\tdev->langid = USBD_NOLANG;\n\tdev->cookie.cookie = ++usb_cookie_no;\n\n\t/* Establish the default pipe. */\n\terr = usbd_setup_pipe(dev, 0, &dev->def_ep, USBD_DEFAULT_INTERVAL,\n\t\t\t      &dev->default_pipe);\n\tif (err) {\n\t\tusbd_remove_device(dev, up);\n\t\treturn (err);\n\t}\n\n\tup->device = dev;\n\tdd = &dev->ddesc;\n\t/* Try a few times in case the device is slow (i.e. outside specs.) */\n\tfor (i = 0; i < 3; i++) {\n\t\t/* Get the first 8 bytes of the device descriptor. */\n\t\terr = usbd_get_desc(dev, UDESC_DEVICE, 0, USB_MAX_IPACKET, dd);\n\t\tif (!err)\n\t\t\tbreak;\n\t\tusbd_delay_ms(dev, 200);\n\t}\n\tif (err) {\n\t\tDPRINTFN(-1, (\"usbd_new_device: addr=%d, getting first desc \"\n\t\t\t      \"failed\\n\", addr));\n\t\tusbd_remove_device(dev, up);\n\t\treturn (err);\n\t}\n\n\tDPRINTF((\"usbd_new_device: adding unit addr=%d, rev=%02x, class=%d, \"\n\t\t \"subclass=%d, protocol=%d, maxpacket=%d, len=%d, ls=%d\\n\", \n\t\t addr,UGETW(dd->bcdUSB), dd->bDeviceClass, dd->bDeviceSubClass,\n\t\t dd->bDeviceProtocol, dd->bMaxPacketSize, dd->bLength, \n\t\t dev->lowspeed));\n\n\tif (dd->bDescriptorType != UDESC_DEVICE) {\n\t\t/* Illegal device descriptor */\n\t\tDPRINTFN(-1,(\"usbd_new_device: illegal descriptor %d\\n\",\n\t\t\t     dd->bDescriptorType));\n\t\tusbd_remove_device(dev, up);\n\t\treturn (USBD_INVAL);\n\t}\n\n\tif (dd->bLength < USB_DEVICE_DESCRIPTOR_SIZE) {\n\t\tDPRINTFN(-1,(\"usbd_new_device: bad length %d\\n\", dd->bLength));\n\t\tusbd_remove_device(dev, up);\n\t\treturn (USBD_INVAL);\n\t}\n\n\tUSETW(dev->def_ep_desc.wMaxPacketSize, dd->bMaxPacketSize);\n\n\terr = usbd_reload_device_desc(dev);\n\tif (err) {\n\t\tDPRINTFN(-1, (\"usbd_new_device: addr=%d, getting full desc \"\n\t\t\t      \"failed\\n\", addr));\n\t\tusbd_remove_device(dev, up);\n\t\treturn (err);\n\t}\n\n\t/* Set the address */\n\terr = usbd_set_address(dev, addr);\n\tDPRINTFN(5,(\"usbd_new_device: setting device address=%d\\n\", addr));\n\tif (err) {\n\t\tDPRINTFN(-1,(\"usb_new_device: set address %d failed\\n\", addr));\n\t\terr = USBD_SET_ADDR_FAILED;\n\t\tusbd_remove_device(dev, up);\n\t\treturn (err);\n\t}\n\t/* Allow device time to set new address */\n\tusbd_delay_ms(dev, USB_SET_ADDRESS_SETTLE);\n\n\tdev->address = addr;\t/* New device address now */\n\tbus->devices[addr] = dev;\n\n\t/* Assume 100mA bus powered for now. Changed when configured. */\n\tdev->power = USB_MIN_POWER;\n\tdev->self_powered = 0;\n\n\tDPRINTF((\"usbd_new_device: new dev (addr %d), dev=%p, parent=%p\\n\", \n\t\t addr, dev, parent));\n  \n\tusbd_add_dev_event(USB_EVENT_DEVICE_ATTACH, dev);\n\n\terr = usbd_probe_and_attach(parent, dev, port, addr);\n\tif (err) {\n\t\tusbd_remove_device(dev, up);\n\t\treturn (err);\n  \t}\n\n  \treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "Static usbd_status",
            "usbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));",
            "Static u_int32_t usb_cookie_no = 0;",
            "const char *\nusbd_errstr(err)\n\tusbd_status err;",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nStatic usbd_status;\nusbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));\nStatic u_int32_t usb_cookie_no = 0;\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_new_device(parent, bus, depth, lowspeed, port, up)\n\tdevice_ptr_t parent;\n\tusbd_bus_handle bus;\n\tint depth;\n\tint lowspeed;\n\tint port;\n\tstruct usbd_port *up;\n{\n\tusbd_device_handle dev;\n\tusb_device_descriptor_t *dd;\n\tusbd_status err;\n\tint addr;\n\tint i;\n\n\tDPRINTF((\"usbd_new_device bus=%p port=%d depth=%d lowspeed=%d\\n\",\n\t\t bus, port, depth, lowspeed));\n\taddr = usbd_getnewaddr(bus);\n\tif (addr < 0) {\n\t\tprintf(\"%s: No free USB addresses, new device ignored.\\n\", \n\t\t       USBDEVNAME(bus->bdev));\n\t\treturn (USBD_NO_ADDR);\n\t}\n\n\tdev = malloc(sizeof *dev, M_USB, M_NOWAIT);\n\tif (dev == NULL)\n\t\treturn (USBD_NOMEM);\n\tmemset(dev, 0, sizeof(*dev));\n\n\tdev->bus = bus;\n\n\t/* Set up default endpoint handle. */\n\tdev->def_ep.edesc = &dev->def_ep_desc;\n\n\t/* Set up default endpoint descriptor. */\n\tdev->def_ep_desc.bLength = USB_ENDPOINT_DESCRIPTOR_SIZE;\n\tdev->def_ep_desc.bDescriptorType = UDESC_ENDPOINT;\n\tdev->def_ep_desc.bEndpointAddress = USB_CONTROL_ENDPOINT;\n\tdev->def_ep_desc.bmAttributes = UE_CONTROL;\n\tUSETW(dev->def_ep_desc.wMaxPacketSize, USB_MAX_IPACKET);\n\tdev->def_ep_desc.bInterval = 0;\n\n\tdev->quirks = &usbd_no_quirk;\n\tdev->address = USB_START_ADDR;\n\tdev->ddesc.bMaxPacketSize = 0;\n\tdev->lowspeed = lowspeed != 0;\n\tdev->depth = depth;\n\tdev->powersrc = up;\n\tdev->langid = USBD_NOLANG;\n\tdev->cookie.cookie = ++usb_cookie_no;\n\n\t/* Establish the default pipe. */\n\terr = usbd_setup_pipe(dev, 0, &dev->def_ep, USBD_DEFAULT_INTERVAL,\n\t\t\t      &dev->default_pipe);\n\tif (err) {\n\t\tusbd_remove_device(dev, up);\n\t\treturn (err);\n\t}\n\n\tup->device = dev;\n\tdd = &dev->ddesc;\n\t/* Try a few times in case the device is slow (i.e. outside specs.) */\n\tfor (i = 0; i < 3; i++) {\n\t\t/* Get the first 8 bytes of the device descriptor. */\n\t\terr = usbd_get_desc(dev, UDESC_DEVICE, 0, USB_MAX_IPACKET, dd);\n\t\tif (!err)\n\t\t\tbreak;\n\t\tusbd_delay_ms(dev, 200);\n\t}\n\tif (err) {\n\t\tDPRINTFN(-1, (\"usbd_new_device: addr=%d, getting first desc \"\n\t\t\t      \"failed\\n\", addr));\n\t\tusbd_remove_device(dev, up);\n\t\treturn (err);\n\t}\n\n\tDPRINTF((\"usbd_new_device: adding unit addr=%d, rev=%02x, class=%d, \"\n\t\t \"subclass=%d, protocol=%d, maxpacket=%d, len=%d, ls=%d\\n\", \n\t\t addr,UGETW(dd->bcdUSB), dd->bDeviceClass, dd->bDeviceSubClass,\n\t\t dd->bDeviceProtocol, dd->bMaxPacketSize, dd->bLength, \n\t\t dev->lowspeed));\n\n\tif (dd->bDescriptorType != UDESC_DEVICE) {\n\t\t/* Illegal device descriptor */\n\t\tDPRINTFN(-1,(\"usbd_new_device: illegal descriptor %d\\n\",\n\t\t\t     dd->bDescriptorType));\n\t\tusbd_remove_device(dev, up);\n\t\treturn (USBD_INVAL);\n\t}\n\n\tif (dd->bLength < USB_DEVICE_DESCRIPTOR_SIZE) {\n\t\tDPRINTFN(-1,(\"usbd_new_device: bad length %d\\n\", dd->bLength));\n\t\tusbd_remove_device(dev, up);\n\t\treturn (USBD_INVAL);\n\t}\n\n\tUSETW(dev->def_ep_desc.wMaxPacketSize, dd->bMaxPacketSize);\n\n\terr = usbd_reload_device_desc(dev);\n\tif (err) {\n\t\tDPRINTFN(-1, (\"usbd_new_device: addr=%d, getting full desc \"\n\t\t\t      \"failed\\n\", addr));\n\t\tusbd_remove_device(dev, up);\n\t\treturn (err);\n\t}\n\n\t/* Set the address */\n\terr = usbd_set_address(dev, addr);\n\tDPRINTFN(5,(\"usbd_new_device: setting device address=%d\\n\", addr));\n\tif (err) {\n\t\tDPRINTFN(-1,(\"usb_new_device: set address %d failed\\n\", addr));\n\t\terr = USBD_SET_ADDR_FAILED;\n\t\tusbd_remove_device(dev, up);\n\t\treturn (err);\n\t}\n\t/* Allow device time to set new address */\n\tusbd_delay_ms(dev, USB_SET_ADDRESS_SETTLE);\n\n\tdev->address = addr;\t/* New device address now */\n\tbus->devices[addr] = dev;\n\n\t/* Assume 100mA bus powered for now. Changed when configured. */\n\tdev->power = USB_MIN_POWER;\n\tdev->self_powered = 0;\n\n\tDPRINTF((\"usbd_new_device: new dev (addr %d), dev=%p, parent=%p\\n\", \n\t\t addr, dev, parent));\n  \n\tusbd_add_dev_event(USB_EVENT_DEVICE_ATTACH, dev);\n\n\terr = usbd_probe_and_attach(parent, dev, port, addr);\n\tif (err) {\n\t\tusbd_remove_device(dev, up);\n\t\treturn (err);\n  \t}\n\n  \treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEV",
          "args": [
            "sc->sc_dev"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhub_explore: port=%d reset failed\\n\",\n\t\t\t\t port)"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_reset_port",
          "args": [
            "dev",
            "port",
            "&up->status"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_reset_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "324-369",
          "snippet": "usbd_status\nusbd_reset_port(dev, port, ps)\n\tusbd_device_handle dev;\n\tint port;\n\tusb_port_status_t *ps;\n{\n\tusb_device_request_t req;\n\tusbd_status err;\n\tint n;\n\t\n\treq.bmRequestType = UT_WRITE_CLASS_OTHER;\n\treq.bRequest = UR_SET_FEATURE;\n\tUSETW(req.wValue, UHF_PORT_RESET);\n\tUSETW(req.wIndex, port);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request(dev, &req, 0);\n\tDPRINTFN(1,(\"usbd_reset_port: port %d reset done, error=%s\\n\",\n\t\t    port, usbd_errstr(err)));\n\tif (err)\n\t\treturn (err);\n\tn = 10;\n\tdo {\n\t\t/* Wait for device to recover from reset. */\n\t\tusbd_delay_ms(dev, USB_PORT_RESET_DELAY);\n\t\terr = usbd_get_port_status(dev, port, ps);\n\t\tif (err) {\n\t\t\tDPRINTF((\"usbd_reset_port: get status failed %d\\n\",\n\t\t\t\t err));\n\t\t\treturn (err);\n\t\t}\n\t} while ((UGETW(ps->wPortChange) & UPS_C_PORT_RESET) == 0 && --n > 0);\n\tif (n == 0) {\n\t\tprintf(\"usbd_reset_port: timeout\\n\");\n\t\treturn (USBD_IOERROR);\n\t}\n\terr = usbd_clear_port_feature(dev, port, UHF_C_PORT_RESET);\n#ifdef USB_DEBUG\n\tif (err)\n\t\tDPRINTF((\"usbd_reset_port: clear port feature failed %d\\n\",\n\t\t\t err));\n#endif\n\n\t/* Wait for the device to recover from reset. */\n\tusbd_delay_ms(dev, USB_PORT_RESET_RECOVERY);\n\treturn (err);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_set_config __P((usbd_device_handle, int));",
            "Static usbd_status",
            "const char *\nusbd_errstr(err)\n\tusbd_status err;",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nStatic usbd_status;\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_reset_port(dev, port, ps)\n\tusbd_device_handle dev;\n\tint port;\n\tusb_port_status_t *ps;\n{\n\tusb_device_request_t req;\n\tusbd_status err;\n\tint n;\n\t\n\treq.bmRequestType = UT_WRITE_CLASS_OTHER;\n\treq.bRequest = UR_SET_FEATURE;\n\tUSETW(req.wValue, UHF_PORT_RESET);\n\tUSETW(req.wIndex, port);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request(dev, &req, 0);\n\tDPRINTFN(1,(\"usbd_reset_port: port %d reset done, error=%s\\n\",\n\t\t    port, usbd_errstr(err)));\n\tif (err)\n\t\treturn (err);\n\tn = 10;\n\tdo {\n\t\t/* Wait for device to recover from reset. */\n\t\tusbd_delay_ms(dev, USB_PORT_RESET_DELAY);\n\t\terr = usbd_get_port_status(dev, port, ps);\n\t\tif (err) {\n\t\t\tDPRINTF((\"usbd_reset_port: get status failed %d\\n\",\n\t\t\t\t err));\n\t\t\treturn (err);\n\t\t}\n\t} while ((UGETW(ps->wPortChange) & UPS_C_PORT_RESET) == 0 && --n > 0);\n\tif (n == 0) {\n\t\tprintf(\"usbd_reset_port: timeout\\n\");\n\t\treturn (USBD_IOERROR);\n\t}\n\terr = usbd_clear_port_feature(dev, port, UHF_C_PORT_RESET);\n#ifdef USB_DEBUG\n\tif (err)\n\t\tDPRINTF((\"usbd_reset_port: clear port feature failed %d\\n\",\n\t\t\t err));\n#endif\n\n\t/* Wait for the device to recover from reset. */\n\tusbd_delay_ms(dev, USB_PORT_RESET_RECOVERY);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_delay_ms",
          "args": [
            "dev",
            "USB_PORT_POWERUP_DELAY"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "316-322",
          "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"uhub_explore: port=%d !CURRENT_CONNECT\"\n\t\t\t\t    \"_STATUS\\n\", port)"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_disconnect_port",
          "args": [
            "up",
            "USBDEV(sc->sc_dev)"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "usb_disconnect_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "1271-1312",
          "snippet": "void\nusb_disconnect_port(up, parent)\n\tstruct usbd_port *up;\n\tdevice_ptr_t parent;\n{\n\tusbd_device_handle dev = up->device;\n\tchar *hubname = USBDEVPTRNAME(parent);\n\tint i;\n\n\tDPRINTFN(3,(\"uhub_disconnect: up=%p dev=%p port=%d\\n\", \n\t\t    up, dev, up->portno));\n\n#ifdef DIAGNOSTIC\n\tif (dev == NULL) {\n\t\tprintf(\"usb_disconnect_port: no device\\n\");\n\t\treturn;\n\t}\n#endif\n\n\tif (dev->subdevs != NULL) {\n\t\tDPRINTFN(3,(\"usb_disconnect_port: disconnect subdevs\\n\"));\n\t\tfor (i = 0; dev->subdevs[i]; i++) {\n\t\t\tprintf(\"%s: at %s\", USBDEVPTRNAME(dev->subdevs[i]), \n\t\t\t       hubname);\n\t\t\tif (up->portno != 0)\n\t\t\t\tprintf(\" port %d\", up->portno);\n\t\t\tprintf(\" (addr %d) disconnected\\n\", dev->address);\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\t\t\tconfig_detach(dev->subdevs[i], DETACH_FORCE);\n#elif defined(__FreeBSD__)\n                        device_delete_child(device_get_parent(dev->subdevs[i]),\n\t\t\t\t\t    dev->subdevs[i]);\n#endif\n\n\t\t}\n\t}\n\n\tusbd_add_dev_event(USB_EVENT_DEVICE_DETACH, dev);\n\tdev->bus->devices[dev->address] = NULL;\n\tup->device = NULL;\n\tusb_free_device(dev);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "usbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nusbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusb_disconnect_port(up, parent)\n\tstruct usbd_port *up;\n\tdevice_ptr_t parent;\n{\n\tusbd_device_handle dev = up->device;\n\tchar *hubname = USBDEVPTRNAME(parent);\n\tint i;\n\n\tDPRINTFN(3,(\"uhub_disconnect: up=%p dev=%p port=%d\\n\", \n\t\t    up, dev, up->portno));\n\n#ifdef DIAGNOSTIC\n\tif (dev == NULL) {\n\t\tprintf(\"usb_disconnect_port: no device\\n\");\n\t\treturn;\n\t}\n#endif\n\n\tif (dev->subdevs != NULL) {\n\t\tDPRINTFN(3,(\"usb_disconnect_port: disconnect subdevs\\n\"));\n\t\tfor (i = 0; dev->subdevs[i]; i++) {\n\t\t\tprintf(\"%s: at %s\", USBDEVPTRNAME(dev->subdevs[i]), \n\t\t\t       hubname);\n\t\t\tif (up->portno != 0)\n\t\t\t\tprintf(\" port %d\", up->portno);\n\t\t\tprintf(\" (addr %d) disconnected\\n\", dev->address);\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\t\t\tconfig_detach(dev->subdevs[i], DETACH_FORCE);\n#elif defined(__FreeBSD__)\n                        device_delete_child(device_get_parent(dev->subdevs[i]),\n\t\t\t\t\t    dev->subdevs[i]);\n#endif\n\n\t\t}\n\t}\n\n\tusbd_add_dev_event(USB_EVENT_DEVICE_DETACH, dev);\n\tdev->bus->devices[dev->address] = NULL;\n\tup->device = NULL;\n\tusb_free_device(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEV",
          "args": [
            "sc->sc_dev"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhub_explore: device addr=%d disappeared \"\n\t\t\t\t \"on port %d\\n\", up->device->address, port)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhub_explore: status change hub=%d port=%d\\n\",\n\t\t\t dev->address, port)"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->device->hub->explore",
          "args": [
            "up->device"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"uhub_explore: port=%d !C_CONNECT_\"\n\t\t\t\t    \"STATUS\\n\", port)"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhub_explore: C_PORT_ENABLED\\n\")"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"uhub_explore: port %d status 0x%04x 0x%04x\\n\",\n\t\t\t    port, status, change)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "up->status.wPortChange"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "up->status.wPortStatus"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhub_explore: get port status failed, \"\n\t\t\t\t \"error=%s\\n\", usbd_errstr(err))"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_port_status",
          "args": [
            "dev",
            "port",
            "&up->status"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_port_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "176-190",
          "snippet": "usbd_status\nusbd_get_port_status(dev, port, ps)\n\tusbd_device_handle dev;\n\tint port;\n\tusb_port_status_t *ps;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_READ_CLASS_OTHER;\n\treq.bRequest = UR_GET_STATUS;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, port);\n\tUSETW(req.wLength, sizeof *ps);\n\treturn (usbd_do_request(dev, &req, ps));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_get_port_status(dev, port, ps)\n\tusbd_device_handle dev;\n\tint port;\n\tusb_port_status_t *ps;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_READ_CLASS_OTHER;\n\treq.bRequest = UR_GET_STATUS;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, port);\n\tUSETW(req.wLength, sizeof *ps);\n\treturn (usbd_do_request(dev, &req, ps));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"uhub_explore dev=%p addr=%d\\n\", dev, dev->address)"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include \"bus_if.h\"\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nuhub_init_port __P((struct usbd_port *));\nStatic usbd_status;\nuhub_explore __P((usbd_device_handle hub));\nuhub_intr __P((usbd_xfer_handle, usbd_private_handle,usbd_status));\n\nusbd_status\nuhub_explore(dev)\n\tusbd_device_handle dev;\n{\n\tusb_hub_descriptor_t *hd = &dev->hub->hubdesc;\n\tstruct uhub_softc *sc = dev->hub->hubsoftc;\n\tstruct usbd_port *up;\n\tusbd_status err;\n\tint port;\n\tint change, status;\n\n\tDPRINTFN(10, (\"uhub_explore dev=%p addr=%d\\n\", dev, dev->address));\n\n\tif (!sc->sc_running)\n\t\treturn (USBD_NOT_STARTED);\n\n\t/* Ignore hubs that are too deep. */\n\tif (dev->depth > USB_HUB_MAX_DEPTH)\n\t\treturn (USBD_TOO_DEEP);\n\n\tfor(port = 1; port <= hd->bNbrPorts; port++) {\n\t\tup = &dev->hub->ports[port-1];\n\t\terr = usbd_get_port_status(dev, port, &up->status);\n\t\tif (err) {\n\t\t\tDPRINTF((\"uhub_explore: get port status failed, \"\n\t\t\t\t \"error=%s\\n\", usbd_errstr(err)));\n\t\t\tcontinue;\n\t\t}\n\t\tstatus = UGETW(up->status.wPortStatus);\n\t\tchange = UGETW(up->status.wPortChange);\n\t\tDPRINTFN(3,(\"uhub_explore: port %d status 0x%04x 0x%04x\\n\",\n\t\t\t    port, status, change));\n\t\tif (change & UPS_C_PORT_ENABLED) {\n\t\t\tDPRINTF((\"uhub_explore: C_PORT_ENABLED\\n\"));\n\t\t\tusbd_clear_port_feature(dev, port, UHF_C_PORT_ENABLE);\n\t\t\tif (status & UPS_PORT_ENABLED) {\n\t\t\t\tprintf(\"%s: illegal enable change, port %d\\n\",\n\t\t\t\t       USBDEVNAME(sc->sc_dev), port);\n\t\t\t} else {\n\t\t\t\t/* Port error condition. */\n\t\t\t\tif (up->restartcnt++ < USBD_RESTART_MAX) {\n\t\t\t\t\tprintf(\"%s: port error, restarting \"\n\t\t\t\t\t       \"port %d\\n\",\n\t\t\t\t\t       USBDEVNAME(sc->sc_dev), port);\n\t\t\t\t\tgoto disco;\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"%s: port error, giving up \"\n\t\t\t\t\t       \"port %d\\n\",\n\t\t\t\t\t       USBDEVNAME(sc->sc_dev), port);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!(change & UPS_C_CONNECT_STATUS)) {\n\t\t\tDPRINTFN(3,(\"uhub_explore: port=%d !C_CONNECT_\"\n\t\t\t\t    \"STATUS\\n\", port));\n\t\t\t/* No status change, just do recursive explore. */\n\t\t\tif (up->device && up->device->hub)\n\t\t\t\tup->device->hub->explore(up->device);\n\t\t\tcontinue;\n\t\t}\n\t\tDPRINTF((\"uhub_explore: status change hub=%d port=%d\\n\",\n\t\t\t dev->address, port));\n\t\tusbd_clear_port_feature(dev, port, UHF_C_PORT_CONNECTION);\n\t\tusbd_clear_port_feature(dev, port, UHF_C_PORT_ENABLE);\n\t\t/*\n\t\t * If there is already a device on the port the change status\n\t\t * must mean that is has disconnected.  Looking at the\n\t\t * current connect status is not enough to figure this out\n\t\t * since a new unit may have been connected before we handle\n\t\t * the disconnect.\n\t\t */\n\tdisco:\n\t\tif (up->device != NULL) {\n\t\t\t/* Disconnected */\n\t\t\tDPRINTF((\"uhub_explore: device addr=%d disappeared \"\n\t\t\t\t \"on port %d\\n\", up->device->address, port));\n\t\t\tusb_disconnect_port(up, USBDEV(sc->sc_dev));\n\t\t\tusbd_clear_port_feature(dev, port, \n\t\t\t\t\t\tUHF_C_PORT_CONNECTION);\n\t\t}\n\t\tif (!(status & UPS_CURRENT_CONNECT_STATUS)) {\n\t\t\tDPRINTFN(3,(\"uhub_explore: port=%d !CURRENT_CONNECT\"\n\t\t\t\t    \"_STATUS\\n\", port));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Connected */\n\t\tup->restartcnt = 0;\n\n\t\t/* Wait for maximum device power up time. */\n\t\tusbd_delay_ms(dev, USB_PORT_POWERUP_DELAY);\n\n\t\t/* Reset port, which implies enabling it. */\n\t\tif (usbd_reset_port(dev, port, &up->status)) {\n\t\t\tDPRINTF((\"uhub_explore: port=%d reset failed\\n\",\n\t\t\t\t port));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get device info and set its address. */\n\t\terr = usbd_new_device(USBDEV(sc->sc_dev), dev->bus, \n\t\t\t  dev->depth + 1, status & UPS_LOW_SPEED, \n\t\t\t  port, up);\n\t\t/* XXX retry a few times? */\n\t\tif (err) {\n\t\t\tDPRINTFN(-1,(\"uhub_explore: usb_new_device failed, \"\n\t\t\t\t     \"error=%s\\n\", usbd_errstr(err)));\n\t\t\t/* Avoid addressing problems by disabling. */\n\t\t\t/* usbd_reset_port(dev, port, &up->status); */\n\n\t\t\t/* \n\t\t\t * The unit refused to accept a new address, or had\n\t\t\t * some other serious problem.  Since we cannot leave\n\t\t\t * at 0 we have to disable the port instead.\n\t\t\t */\n\t\t\tprintf(\"%s: device problem, disabling port %d\\n\",\n\t\t\t       USBDEVNAME(sc->sc_dev), port);\n\t\t\tusbd_clear_port_feature(dev, port, UHF_PORT_ENABLE);\n\t\t\t/* Make sure we don't try to restart it infinitely. */\n\t\t\tup->restartcnt = USBD_RESTART_MAX;\n\t\t} else {\n\t\t\tif (up->device->hub)\n\t\t\t\tup->device->hub->explore(up->device);\n\t\t}\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "uhub_init_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhub.c",
    "lines": "273-333",
    "snippet": "usbd_status\nuhub_init_port(up)\n\tstruct usbd_port *up;\n{\n\tint port = up->portno;\n\tusbd_device_handle dev = up->parent;\n\tusbd_status err;\n\tu_int16_t pstatus;\n\n\terr = usbd_get_port_status(dev, port, &up->status);\n\tif (err)\n\t\treturn (err);\n\tpstatus = UGETW(up->status.wPortStatus);\n\tDPRINTF((\"usbd_init_port: adding hub port=%d status=0x%04x \"\n\t\t \"change=0x%04x\\n\",\n\t\t port, pstatus, UGETW(up->status.wPortChange)));\n\tif ((pstatus & UPS_PORT_POWER) == 0) {\n\t\t/* Port lacks power, turn it on */\n\n\t\t/* First let the device go through a good power cycle, */\n\t\tusbd_delay_ms(dev, USB_PORT_POWER_DOWN_TIME);\n\n\t\t/* then turn the power on. */\n\t\terr = usbd_set_port_feature(dev, port, UHF_PORT_POWER);\n\t\tif (err)\n\t\t\treturn (err);\n\t\tDPRINTF((\"usb_init_port: turn on port %d power status=0x%04x \"\n\t\t\t \"change=0x%04x\\n\",\n\t\t\t port, UGETW(up->status.wPortStatus),\n\t\t\t UGETW(up->status.wPortChange)));\n\t\t/* Wait for stable power. */\n\t\tusbd_delay_ms(dev, dev->hub->hubdesc.bPwrOn2PwrGood * \n\t\t\t           UHD_PWRON_FACTOR);\n\t\t/* Get the port status again. */\n\t\terr = usbd_get_port_status(dev, port, &up->status);\n\t\tif (err)\n\t\t\treturn (err);\n\t\tDPRINTF((\"usb_init_port: after power on status=0x%04x \"\n\t\t\t \"change=0x%04x\\n\",\n\t\t\t UGETW(up->status.wPortStatus),\n\t\t\t UGETW(up->status.wPortChange)));\n\n#if 0\nusbd_clear_hub_feature(dev, UHF_C_HUB_OVER_CURRENT);\nusbd_clear_port_feature(dev, port, UHF_C_PORT_OVER_CURRENT);\nusbd_get_port_status(dev, port, &up->status);\n#endif\n\n\t\tpstatus = UGETW(up->status.wPortStatus);\n\t\tif ((pstatus & UPS_PORT_POWER) == 0)\n\t\t\tprintf(\"%s: port %d did not power up\\n\",\n USBDEVNAME(((struct uhub_softc *)dev->hub->hubsoftc)->sc_dev), port);\n\n\t}\n\tif (dev->self_powered)\n\t\t/* Self powered hub, give ports maximum current. */\n\t\tup->power = USB_MAX_POWER;\n\telse\n\t\tup->power = USB_MIN_POWER;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include \"bus_if.h\"",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "uhub_init_port __P((struct usbd_port *));",
      "Static usbd_status",
      "uhub_explore __P((usbd_device_handle hub));",
      "uhub_intr __P((usbd_xfer_handle, usbd_private_handle,usbd_status));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: port %d did not power up\\n\"",
            "USBDEVNAME(((struct uhub_softc *)dev->hub->hubsoftc)->sc_dev)",
            "port"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "((struct uhub_softc *)dev->hub->hubsoftc)->sc_dev"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "up->status.wPortStatus"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_port_status",
          "args": [
            "dev",
            "port",
            "&up->status"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_port_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "176-190",
          "snippet": "usbd_status\nusbd_get_port_status(dev, port, ps)\n\tusbd_device_handle dev;\n\tint port;\n\tusb_port_status_t *ps;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_READ_CLASS_OTHER;\n\treq.bRequest = UR_GET_STATUS;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, port);\n\tUSETW(req.wLength, sizeof *ps);\n\treturn (usbd_do_request(dev, &req, ps));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_get_port_status(dev, port, ps)\n\tusbd_device_handle dev;\n\tint port;\n\tusb_port_status_t *ps;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_READ_CLASS_OTHER;\n\treq.bRequest = UR_GET_STATUS;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, port);\n\tUSETW(req.wLength, sizeof *ps);\n\treturn (usbd_do_request(dev, &req, ps));\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_clear_port_feature",
          "args": [
            "dev",
            "port",
            "UHF_C_PORT_OVER_CURRENT"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_clear_port_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "222-235",
          "snippet": "usbd_status\nusbd_clear_port_feature(dev, port, sel)\n\tusbd_device_handle dev;\n\tint port, sel;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_WRITE_CLASS_OTHER;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, sel);\n\tUSETW(req.wIndex, port);\n\tUSETW(req.wLength, 0);\n\treturn (usbd_do_request(dev, &req, 0));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_clear_port_feature(dev, port, sel)\n\tusbd_device_handle dev;\n\tint port, sel;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_WRITE_CLASS_OTHER;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, sel);\n\tUSETW(req.wIndex, port);\n\tUSETW(req.wLength, 0);\n\treturn (usbd_do_request(dev, &req, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_clear_hub_feature",
          "args": [
            "dev",
            "UHF_C_HUB_OVER_CURRENT"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_clear_hub_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "192-205",
          "snippet": "usbd_status\nusbd_clear_hub_feature(dev, sel)\n\tusbd_device_handle dev;\n\tint sel;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_WRITE_CLASS_DEVICE;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, sel);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\treturn (usbd_do_request(dev, &req, 0));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_clear_hub_feature(dev, sel)\n\tusbd_device_handle dev;\n\tint sel;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_WRITE_CLASS_DEVICE;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, sel);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\treturn (usbd_do_request(dev, &req, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usb_init_port: after power on status=0x%04x \"\n\t\t\t \"change=0x%04x\\n\",\n\t\t\t UGETW(up->status.wPortStatus),\n\t\t\t UGETW(up->status.wPortChange))"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "up->status.wPortChange"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "up->status.wPortStatus"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_delay_ms",
          "args": [
            "dev",
            "dev->hub->hubdesc.bPwrOn2PwrGood * \n\t\t\t           UHD_PWRON_FACTOR"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "316-322",
          "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usb_init_port: turn on port %d power status=0x%04x \"\n\t\t\t \"change=0x%04x\\n\",\n\t\t\t port, UGETW(up->status.wPortStatus),\n\t\t\t UGETW(up->status.wPortChange))"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "up->status.wPortChange"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "up->status.wPortStatus"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_set_port_feature",
          "args": [
            "dev",
            "port",
            "UHF_PORT_POWER"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_set_port_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "237-250",
          "snippet": "usbd_status\nusbd_set_port_feature(dev, port, sel)\n\tusbd_device_handle dev;\n\tint port, sel;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_WRITE_CLASS_OTHER;\n\treq.bRequest = UR_SET_FEATURE;\n\tUSETW(req.wValue, sel);\n\tUSETW(req.wIndex, port);\n\tUSETW(req.wLength, 0);\n\treturn (usbd_do_request(dev, &req, 0));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_set_port_feature(dev, port, sel)\n\tusbd_device_handle dev;\n\tint port, sel;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_WRITE_CLASS_OTHER;\n\treq.bRequest = UR_SET_FEATURE;\n\tUSETW(req.wValue, sel);\n\tUSETW(req.wIndex, port);\n\tUSETW(req.wLength, 0);\n\treturn (usbd_do_request(dev, &req, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_init_port: adding hub port=%d status=0x%04x \"\n\t\t \"change=0x%04x\\n\",\n\t\t port, pstatus, UGETW(up->status.wPortChange))"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "up->status.wPortChange"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "up->status.wPortStatus"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include \"bus_if.h\"\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nuhub_init_port __P((struct usbd_port *));\nStatic usbd_status;\nuhub_explore __P((usbd_device_handle hub));\nuhub_intr __P((usbd_xfer_handle, usbd_private_handle,usbd_status));\n\nusbd_status\nuhub_init_port(up)\n\tstruct usbd_port *up;\n{\n\tint port = up->portno;\n\tusbd_device_handle dev = up->parent;\n\tusbd_status err;\n\tu_int16_t pstatus;\n\n\terr = usbd_get_port_status(dev, port, &up->status);\n\tif (err)\n\t\treturn (err);\n\tpstatus = UGETW(up->status.wPortStatus);\n\tDPRINTF((\"usbd_init_port: adding hub port=%d status=0x%04x \"\n\t\t \"change=0x%04x\\n\",\n\t\t port, pstatus, UGETW(up->status.wPortChange)));\n\tif ((pstatus & UPS_PORT_POWER) == 0) {\n\t\t/* Port lacks power, turn it on */\n\n\t\t/* First let the device go through a good power cycle, */\n\t\tusbd_delay_ms(dev, USB_PORT_POWER_DOWN_TIME);\n\n\t\t/* then turn the power on. */\n\t\terr = usbd_set_port_feature(dev, port, UHF_PORT_POWER);\n\t\tif (err)\n\t\t\treturn (err);\n\t\tDPRINTF((\"usb_init_port: turn on port %d power status=0x%04x \"\n\t\t\t \"change=0x%04x\\n\",\n\t\t\t port, UGETW(up->status.wPortStatus),\n\t\t\t UGETW(up->status.wPortChange)));\n\t\t/* Wait for stable power. */\n\t\tusbd_delay_ms(dev, dev->hub->hubdesc.bPwrOn2PwrGood * \n\t\t\t           UHD_PWRON_FACTOR);\n\t\t/* Get the port status again. */\n\t\terr = usbd_get_port_status(dev, port, &up->status);\n\t\tif (err)\n\t\t\treturn (err);\n\t\tDPRINTF((\"usb_init_port: after power on status=0x%04x \"\n\t\t\t \"change=0x%04x\\n\",\n\t\t\t UGETW(up->status.wPortStatus),\n\t\t\t UGETW(up->status.wPortChange)));\n\n#if 0\nusbd_clear_hub_feature(dev, UHF_C_HUB_OVER_CURRENT);\nusbd_clear_port_feature(dev, port, UHF_C_PORT_OVER_CURRENT);\nusbd_get_port_status(dev, port, &up->status);\n#endif\n\n\t\tpstatus = UGETW(up->status.wPortStatus);\n\t\tif ((pstatus & UPS_PORT_POWER) == 0)\n\t\t\tprintf(\"%s: port %d did not power up\\n\",\n USBDEVNAME(((struct uhub_softc *)dev->hub->hubsoftc)->sc_dev), port);\n\n\t}\n\tif (dev->self_powered)\n\t\t/* Self powered hub, give ports maximum current. */\n\t\tup->power = USB_MAX_POWER;\n\telse\n\t\tup->power = USB_MIN_POWER;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  }
]