[
  {
    "function_name": "symtable_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm_symbol.c",
    "lines": "304-472",
    "snippet": "void\nsymtable_dump(ofile)\n\tFILE *ofile;\n{\n\t/*\n\t * Sort the registers by address with a simple insertion sort.\n\t * Put bitmasks next to the first register that defines them.\n\t * Put constants at the end.\n\t */\n\tsymlist_t registers;\n\tsymlist_t masks;\n\tsymlist_t constants;\n\tsymlist_t download_constants;\n\tsymlist_t aliases;\n\n\tSLIST_INIT(&registers);\n\tSLIST_INIT(&masks);\n\tSLIST_INIT(&constants);\n\tSLIST_INIT(&download_constants);\n\tSLIST_INIT(&aliases);\n\n\tif (symtable != NULL) {\n\t\tDBT\t key;\n\t\tDBT\t data;\n\t\tint\t flag = R_FIRST;\n\n\t\twhile (symtable->seq(symtable, &key, &data, flag) == 0) {\n\t\t\tsymbol_t *cursym;\n\n\t\t\tmemcpy(&cursym, data.data, sizeof(cursym));\n\t\t\tswitch(cursym->type) {\n\t\t\tcase REGISTER:\n\t\t\tcase SCBLOC:\n\t\t\tcase SRAMLOC:\n\t\t\t\tsymlist_add(&registers, cursym, SYMLIST_SORT);\n\t\t\t\tbreak;\n\t\t\tcase MASK:\n\t\t\tcase BIT:\n\t\t\t\tsymlist_add(&masks, cursym, SYMLIST_SORT);\n\t\t\t\tbreak;\n\t\t\tcase CONST:\n\t\t\t\tif (cursym->info.cinfo->define == FALSE) {\n\t\t\t\t\tsymlist_add(&constants, cursym,\n\t\t\t\t\t\t    SYMLIST_INSERT_HEAD);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DOWNLOAD_CONST:\n\t\t\t\tsymlist_add(&download_constants, cursym,\n\t\t\t\t\t    SYMLIST_INSERT_HEAD);\n\t\t\t\tbreak;\n\t\t\tcase ALIAS:\n\t\t\t\tsymlist_add(&aliases, cursym,\n\t\t\t\t\t    SYMLIST_INSERT_HEAD);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflag = R_NEXT;\n\t\t}\n\n\t\t/* Put in the masks and bits */\n\t\twhile (masks.slh_first != NULL) {\n\t\t\tsymbol_node_t *curnode;\n\t\t\tsymbol_node_t *regnode;\n\t\t\tchar *regname;\n\n\t\t\tcurnode = masks.slh_first;\n\t\t\tSLIST_REMOVE_HEAD(&masks, links);\n\n\t\t\tregnode =\n\t\t\t    curnode->symbol->info.minfo->symrefs.slh_first;\n\t\t\tregname = regnode->symbol->name;\n\t\t\tregnode = symlist_search(&registers, regname);\n\t\t\tSLIST_INSERT_AFTER(regnode, curnode, links);\n\t\t}\n\n\t\t/* Add the aliases */\n\t\twhile (aliases.slh_first != NULL) {\n\t\t\tsymbol_node_t *curnode;\n\t\t\tsymbol_node_t *regnode;\n\t\t\tchar *regname;\n\n\t\t\tcurnode = aliases.slh_first;\n\t\t\tSLIST_REMOVE_HEAD(&aliases, links);\n\n\t\t\tregname = curnode->symbol->info.ainfo->parent->name;\n\t\t\tregnode = symlist_search(&registers, regname);\n\t\t\tSLIST_INSERT_AFTER(regnode, curnode, links);\n\t\t}\n\n\t\t/* Output what we have */\n\t\tfprintf(ofile,\n\"/*\n * DO NOT EDIT - This file is automatically generated.\n */\\n\");\n\t\twhile (registers.slh_first != NULL) {\n\t\t\tsymbol_node_t *curnode;\n\t\t\tu_int8_t value;\n\t\t\tchar *tab_str;\n\t\t\tchar *tab_str2;\n\n\t\t\tcurnode = registers.slh_first;\n\t\t\tSLIST_REMOVE_HEAD(&registers, links);\n\t\t\tswitch(curnode->symbol->type) {\n\t\t\tcase REGISTER:\n\t\t\tcase SCBLOC:\n\t\t\tcase SRAMLOC:\n\t\t\t\tfprintf(ofile, \"\\n\");\n\t\t\t\tvalue = curnode->symbol->info.rinfo->address;\n\t\t\t\ttab_str = \"\\t\";\n\t\t\t\ttab_str2 = \"\\t\\t\";\n\t\t\t\tbreak;\n\t\t\tcase ALIAS:\n\t\t\t{\n\t\t\t\tsymbol_t *parent;\n\n\t\t\t\tparent = curnode->symbol->info.ainfo->parent;\n\t\t\t\tvalue = parent->info.rinfo->address;\n\t\t\t\ttab_str = \"\\t\";\n\t\t\t\ttab_str2 = \"\\t\\t\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase MASK:\n\t\t\tcase BIT:\n\t\t\t\tvalue = curnode->symbol->info.minfo->mask;\n\t\t\t\ttab_str = \"\\t\\t\";\n\t\t\t\ttab_str2 = \"\\t\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvalue = 0; /* Quiet compiler */\n\t\t\t\ttab_str = NULL;\n\t\t\t\ttab_str2 = NULL;\n\t\t\t\tstop(\"symtable_dump: Invalid symbol type \"\n\t\t\t\t     \"encountered\", EX_SOFTWARE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfprintf(ofile, \"#define%s%-16s%s0x%02x\\n\",\n\t\t\t\ttab_str, curnode->symbol->name, tab_str2,\n\t\t\t\tvalue);\n\t\t\tfree(curnode);\n\t\t}\n\t\tfprintf(ofile, \"\\n\\n\");\n\n\t\twhile (constants.slh_first != NULL) {\n\t\t\tsymbol_node_t *curnode;\n\n\t\t\tcurnode = constants.slh_first;\n\t\t\tSLIST_REMOVE_HEAD(&constants, links);\n\t\t\tfprintf(ofile, \"#define\\t%-8s\\t0x%02x\\n\",\n\t\t\t\tcurnode->symbol->name,\n\t\t\t\tcurnode->symbol->info.cinfo->value);\n\t\t\tfree(curnode);\n\t\t}\n\n\t\t\n\t\tfprintf(ofile, \"\\n\\n/* Downloaded Constant Definitions */\\n\");\n\n\t\twhile (download_constants.slh_first != NULL) {\n\t\t\tsymbol_node_t *curnode;\n\n\t\t\tcurnode = download_constants.slh_first;\n\t\t\tSLIST_REMOVE_HEAD(&download_constants, links);\n\t\t\tfprintf(ofile, \"#define\\t%-8s\\t0x%02x\\n\",\n\t\t\t\tcurnode->symbol->name,\n\t\t\t\tcurnode->symbol->info.cinfo->value);\n\t\t\tfree(curnode);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"aicasm.h\"",
      "#include \"aicasm_symbol.h\"",
      "#include <sysexits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <db.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DB *symtable;",
      "symbol_t *\nsymbol_create(name)\n\tchar *name;",
      "symbol_t *\nsymtable_get(name)\n\tchar *name;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "curnode"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "symlist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm_symbol.c",
          "lines": "270-283",
          "snippet": "void\nsymlist_free(symlist)\n\tsymlist_t *symlist;\n{\n\tsymbol_node_t *node1, *node2;\n\n\tnode1 = symlist->slh_first;\n\twhile (node1 != NULL) {\n\t\tnode2 = node1->links.sle_next;\n\t\tfree(node1);\n\t\tnode1 = node2;\n\t}\n\tSLIST_INIT(symlist);\n}",
          "includes": [
            "#include \"aicasm.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <db.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "symbol_node_t *\nsymlist_search(symlist, symname)\n\tsymlist_t *symlist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"aicasm.h\"\n#include \"aicasm_symbol.h\"\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <db.h>\n#include <sys/types.h>\n\nsymbol_node_t *\nsymlist_search(symlist, symname)\n\tsymlist_t *symlist;\n\nvoid\nsymlist_free(symlist)\n\tsymlist_t *symlist;\n{\n\tsymbol_node_t *node1, *node2;\n\n\tnode1 = symlist->slh_first;\n\twhile (node1 != NULL) {\n\t\tnode2 = node1->links.sle_next;\n\t\tfree(node1);\n\t\tnode1 = node2;\n\t}\n\tSLIST_INIT(symlist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ofile",
            "\"#define\\t%-8s\\t0x%02x\\n\"",
            "curnode->symbol->name",
            "curnode->symbol->info.cinfo->value"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_REMOVE_HEAD",
          "args": [
            "&download_constants",
            "links"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ofile",
            "\"\\n\\n/* Downloaded Constant Definitions */\\n\""
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ofile",
            "\"#define\\t%-8s\\t0x%02x\\n\"",
            "curnode->symbol->name",
            "curnode->symbol->info.cinfo->value"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_REMOVE_HEAD",
          "args": [
            "&constants",
            "links"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ofile",
            "\"\\n\\n\""
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ofile",
            "\"#define%s%-16s%s0x%02x\\n\"",
            "tab_str",
            "curnode->symbol->name",
            "tab_str2",
            "value"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop",
          "args": [
            "\"symtable_dump: Invalid symbol type \"\n\t\t\t\t     \"encountered\"",
            "EX_SOFTWARE"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
          "lines": "576-621",
          "snippet": "void\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}",
          "includes": [
            "#include \"sequencer.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include \"aicasm.h\"",
            "#include <unistd.h>",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <sys/mman.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void output_code(FILE *ofile);",
            "char *appname;",
            "FILE *ofile;",
            "char *ofilename;",
            "char *regfilename;",
            "FILE *regfile;",
            "char *listfilename;",
            "FILE *listfile;",
            "symlist_t patch_functions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void output_code(FILE *ofile);\nchar *appname;\nFILE *ofile;\nchar *ofilename;\nchar *regfilename;\nFILE *regfile;\nchar *listfilename;\nFILE *listfile;\nsymlist_t patch_functions;\n\nvoid\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ofile",
            "\"\\n\""
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_REMOVE_HEAD",
          "args": [
            "&registers",
            "links"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ofile",
            "\"/*\n * DO NOT EDIT - This file is automatically generated.\n */\\n\""
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_INSERT_AFTER",
          "args": [
            "regnode",
            "curnode",
            "links"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlist_search",
          "args": [
            "&registers",
            "regname"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_REMOVE_HEAD",
          "args": [
            "&aliases",
            "links"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_INSERT_AFTER",
          "args": [
            "regnode",
            "curnode",
            "links"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlist_search",
          "args": [
            "&registers",
            "regname"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_REMOVE_HEAD",
          "args": [
            "&masks",
            "links"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlist_add",
          "args": [
            "&aliases",
            "cursym",
            "SYMLIST_INSERT_HEAD"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "symlist_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm_symbol.c",
          "lines": "201-268",
          "snippet": "void\nsymlist_add(symlist, symbol, how)\n\tsymlist_t *symlist;\n\tsymbol_t  *symbol;\n\tint\t  how;\n{\n\tsymbol_node_t *newnode;\n\n\tnewnode = (symbol_node_t *)malloc(sizeof(symbol_node_t));\n\tif (newnode == NULL) {\n\t\tstop(\"symlist_add: Unable to malloc symbol_node\", EX_SOFTWARE);\n\t\t/* NOTREACHED */\n\t}\n\tnewnode->symbol = symbol;\n\tif (how == SYMLIST_SORT) {\n\t\tsymbol_node_t *curnode;\n\t\tint mask;\n\n\t\tmask = FALSE;\n\t\tswitch(symbol->type) {\n\t\tcase REGISTER:\n\t\tcase SCBLOC:\n\t\tcase SRAMLOC:\n\t\t\tbreak;\n\t\tcase BIT:\n\t\tcase MASK:\n\t\t\tmask = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstop(\"symlist_add: Invalid symbol type for sorting\",\n\t\t\t     EX_SOFTWARE);\n\t\t\t/* NOTREACHED */\n\t\t}\n\n\t\tcurnode = symlist->slh_first;\n\t\tif (curnode == NULL\n\t\t || (mask && (curnode->symbol->info.minfo->mask >\n\t\t              newnode->symbol->info.minfo->mask))\n\t\t || (!mask && (curnode->symbol->info.rinfo->address >\n\t\t               newnode->symbol->info.rinfo->address))) {\n\t\t\tSLIST_INSERT_HEAD(symlist, newnode, links);\n\t\t\treturn;\n\t\t}\n\n\t\twhile (1) {\n\t\t\tif (curnode->links.sle_next == NULL) {\n\t\t\t\tSLIST_INSERT_AFTER(curnode, newnode,\n\t\t\t\t\t\t   links);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tsymbol_t *cursymbol;\n\n\t\t\t\tcursymbol = curnode->links.sle_next->symbol;\n\t\t\t\tif ((mask && (cursymbol->info.minfo->mask >\n\t\t\t\t              symbol->info.minfo->mask))\n\t\t\t\t || (!mask &&(cursymbol->info.rinfo->address >\n\t\t\t\t              symbol->info.rinfo->address))){\n\t\t\t\t\tSLIST_INSERT_AFTER(curnode, newnode,\n\t\t\t\t\t\t\t   links);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurnode = curnode->links.sle_next;\n\t\t}\n\t} else {\n\t\tSLIST_INSERT_HEAD(symlist, newnode, links);\n\t}\n}",
          "includes": [
            "#include \"aicasm.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <db.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "symbol_node_t *\nsymlist_search(symlist, symname)\n\tsymlist_t *symlist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"aicasm.h\"\n#include \"aicasm_symbol.h\"\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <db.h>\n#include <sys/types.h>\n\nsymbol_node_t *\nsymlist_search(symlist, symname)\n\tsymlist_t *symlist;\n\nvoid\nsymlist_add(symlist, symbol, how)\n\tsymlist_t *symlist;\n\tsymbol_t  *symbol;\n\tint\t  how;\n{\n\tsymbol_node_t *newnode;\n\n\tnewnode = (symbol_node_t *)malloc(sizeof(symbol_node_t));\n\tif (newnode == NULL) {\n\t\tstop(\"symlist_add: Unable to malloc symbol_node\", EX_SOFTWARE);\n\t\t/* NOTREACHED */\n\t}\n\tnewnode->symbol = symbol;\n\tif (how == SYMLIST_SORT) {\n\t\tsymbol_node_t *curnode;\n\t\tint mask;\n\n\t\tmask = FALSE;\n\t\tswitch(symbol->type) {\n\t\tcase REGISTER:\n\t\tcase SCBLOC:\n\t\tcase SRAMLOC:\n\t\t\tbreak;\n\t\tcase BIT:\n\t\tcase MASK:\n\t\t\tmask = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstop(\"symlist_add: Invalid symbol type for sorting\",\n\t\t\t     EX_SOFTWARE);\n\t\t\t/* NOTREACHED */\n\t\t}\n\n\t\tcurnode = symlist->slh_first;\n\t\tif (curnode == NULL\n\t\t || (mask && (curnode->symbol->info.minfo->mask >\n\t\t              newnode->symbol->info.minfo->mask))\n\t\t || (!mask && (curnode->symbol->info.rinfo->address >\n\t\t               newnode->symbol->info.rinfo->address))) {\n\t\t\tSLIST_INSERT_HEAD(symlist, newnode, links);\n\t\t\treturn;\n\t\t}\n\n\t\twhile (1) {\n\t\t\tif (curnode->links.sle_next == NULL) {\n\t\t\t\tSLIST_INSERT_AFTER(curnode, newnode,\n\t\t\t\t\t\t   links);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tsymbol_t *cursymbol;\n\n\t\t\t\tcursymbol = curnode->links.sle_next->symbol;\n\t\t\t\tif ((mask && (cursymbol->info.minfo->mask >\n\t\t\t\t              symbol->info.minfo->mask))\n\t\t\t\t || (!mask &&(cursymbol->info.rinfo->address >\n\t\t\t\t              symbol->info.rinfo->address))){\n\t\t\t\t\tSLIST_INSERT_AFTER(curnode, newnode,\n\t\t\t\t\t\t\t   links);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurnode = curnode->links.sle_next;\n\t\t}\n\t} else {\n\t\tSLIST_INSERT_HEAD(symlist, newnode, links);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&cursym",
            "data.data",
            "sizeof(cursym)"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symtable->seq",
          "args": [
            "symtable",
            "&key",
            "&data",
            "flag"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_INIT",
          "args": [
            "&aliases"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_INIT",
          "args": [
            "&download_constants"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_INIT",
          "args": [
            "&constants"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_INIT",
          "args": [
            "&masks"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_INIT",
          "args": [
            "&registers"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"aicasm.h\"\n#include \"aicasm_symbol.h\"\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <db.h>\n#include <sys/types.h>\n\nstatic DB *symtable;\nsymbol_t *\nsymbol_create(name)\n\tchar *name;\nsymbol_t *\nsymtable_get(name)\n\tchar *name;\n\nvoid\nsymtable_dump(ofile)\n\tFILE *ofile;\n{\n\t/*\n\t * Sort the registers by address with a simple insertion sort.\n\t * Put bitmasks next to the first register that defines them.\n\t * Put constants at the end.\n\t */\n\tsymlist_t registers;\n\tsymlist_t masks;\n\tsymlist_t constants;\n\tsymlist_t download_constants;\n\tsymlist_t aliases;\n\n\tSLIST_INIT(&registers);\n\tSLIST_INIT(&masks);\n\tSLIST_INIT(&constants);\n\tSLIST_INIT(&download_constants);\n\tSLIST_INIT(&aliases);\n\n\tif (symtable != NULL) {\n\t\tDBT\t key;\n\t\tDBT\t data;\n\t\tint\t flag = R_FIRST;\n\n\t\twhile (symtable->seq(symtable, &key, &data, flag) == 0) {\n\t\t\tsymbol_t *cursym;\n\n\t\t\tmemcpy(&cursym, data.data, sizeof(cursym));\n\t\t\tswitch(cursym->type) {\n\t\t\tcase REGISTER:\n\t\t\tcase SCBLOC:\n\t\t\tcase SRAMLOC:\n\t\t\t\tsymlist_add(&registers, cursym, SYMLIST_SORT);\n\t\t\t\tbreak;\n\t\t\tcase MASK:\n\t\t\tcase BIT:\n\t\t\t\tsymlist_add(&masks, cursym, SYMLIST_SORT);\n\t\t\t\tbreak;\n\t\t\tcase CONST:\n\t\t\t\tif (cursym->info.cinfo->define == FALSE) {\n\t\t\t\t\tsymlist_add(&constants, cursym,\n\t\t\t\t\t\t    SYMLIST_INSERT_HEAD);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DOWNLOAD_CONST:\n\t\t\t\tsymlist_add(&download_constants, cursym,\n\t\t\t\t\t    SYMLIST_INSERT_HEAD);\n\t\t\t\tbreak;\n\t\t\tcase ALIAS:\n\t\t\t\tsymlist_add(&aliases, cursym,\n\t\t\t\t\t    SYMLIST_INSERT_HEAD);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflag = R_NEXT;\n\t\t}\n\n\t\t/* Put in the masks and bits */\n\t\twhile (masks.slh_first != NULL) {\n\t\t\tsymbol_node_t *curnode;\n\t\t\tsymbol_node_t *regnode;\n\t\t\tchar *regname;\n\n\t\t\tcurnode = masks.slh_first;\n\t\t\tSLIST_REMOVE_HEAD(&masks, links);\n\n\t\t\tregnode =\n\t\t\t    curnode->symbol->info.minfo->symrefs.slh_first;\n\t\t\tregname = regnode->symbol->name;\n\t\t\tregnode = symlist_search(&registers, regname);\n\t\t\tSLIST_INSERT_AFTER(regnode, curnode, links);\n\t\t}\n\n\t\t/* Add the aliases */\n\t\twhile (aliases.slh_first != NULL) {\n\t\t\tsymbol_node_t *curnode;\n\t\t\tsymbol_node_t *regnode;\n\t\t\tchar *regname;\n\n\t\t\tcurnode = aliases.slh_first;\n\t\t\tSLIST_REMOVE_HEAD(&aliases, links);\n\n\t\t\tregname = curnode->symbol->info.ainfo->parent->name;\n\t\t\tregnode = symlist_search(&registers, regname);\n\t\t\tSLIST_INSERT_AFTER(regnode, curnode, links);\n\t\t}\n\n\t\t/* Output what we have */\n\t\tfprintf(ofile,\n\"/*\n * DO NOT EDIT - This file is automatically generated.\n */\\n\");\n\t\twhile (registers.slh_first != NULL) {\n\t\t\tsymbol_node_t *curnode;\n\t\t\tu_int8_t value;\n\t\t\tchar *tab_str;\n\t\t\tchar *tab_str2;\n\n\t\t\tcurnode = registers.slh_first;\n\t\t\tSLIST_REMOVE_HEAD(&registers, links);\n\t\t\tswitch(curnode->symbol->type) {\n\t\t\tcase REGISTER:\n\t\t\tcase SCBLOC:\n\t\t\tcase SRAMLOC:\n\t\t\t\tfprintf(ofile, \"\\n\");\n\t\t\t\tvalue = curnode->symbol->info.rinfo->address;\n\t\t\t\ttab_str = \"\\t\";\n\t\t\t\ttab_str2 = \"\\t\\t\";\n\t\t\t\tbreak;\n\t\t\tcase ALIAS:\n\t\t\t{\n\t\t\t\tsymbol_t *parent;\n\n\t\t\t\tparent = curnode->symbol->info.ainfo->parent;\n\t\t\t\tvalue = parent->info.rinfo->address;\n\t\t\t\ttab_str = \"\\t\";\n\t\t\t\ttab_str2 = \"\\t\\t\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase MASK:\n\t\t\tcase BIT:\n\t\t\t\tvalue = curnode->symbol->info.minfo->mask;\n\t\t\t\ttab_str = \"\\t\\t\";\n\t\t\t\ttab_str2 = \"\\t\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvalue = 0; /* Quiet compiler */\n\t\t\t\ttab_str = NULL;\n\t\t\t\ttab_str2 = NULL;\n\t\t\t\tstop(\"symtable_dump: Invalid symbol type \"\n\t\t\t\t     \"encountered\", EX_SOFTWARE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfprintf(ofile, \"#define%s%-16s%s0x%02x\\n\",\n\t\t\t\ttab_str, curnode->symbol->name, tab_str2,\n\t\t\t\tvalue);\n\t\t\tfree(curnode);\n\t\t}\n\t\tfprintf(ofile, \"\\n\\n\");\n\n\t\twhile (constants.slh_first != NULL) {\n\t\t\tsymbol_node_t *curnode;\n\n\t\t\tcurnode = constants.slh_first;\n\t\t\tSLIST_REMOVE_HEAD(&constants, links);\n\t\t\tfprintf(ofile, \"#define\\t%-8s\\t0x%02x\\n\",\n\t\t\t\tcurnode->symbol->name,\n\t\t\t\tcurnode->symbol->info.cinfo->value);\n\t\t\tfree(curnode);\n\t\t}\n\n\t\t\n\t\tfprintf(ofile, \"\\n\\n/* Downloaded Constant Definitions */\\n\");\n\n\t\twhile (download_constants.slh_first != NULL) {\n\t\t\tsymbol_node_t *curnode;\n\n\t\t\tcurnode = download_constants.slh_first;\n\t\t\tSLIST_REMOVE_HEAD(&download_constants, links);\n\t\t\tfprintf(ofile, \"#define\\t%-8s\\t0x%02x\\n\",\n\t\t\t\tcurnode->symbol->name,\n\t\t\t\tcurnode->symbol->info.cinfo->value);\n\t\t\tfree(curnode);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "symlist_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm_symbol.c",
    "lines": "285-302",
    "snippet": "void\nsymlist_merge(symlist_dest, symlist_src1, symlist_src2)\n\tsymlist_t *symlist_dest;\n\tsymlist_t *symlist_src1;\n\tsymlist_t *symlist_src2;\n{\n\tsymbol_node_t *node;\n\n\t*symlist_dest = *symlist_src1;\n\twhile((node = symlist_src2->slh_first) != NULL) {\n\t\tSLIST_REMOVE_HEAD(symlist_src2, links);\n\t\tSLIST_INSERT_HEAD(symlist_dest, node, links);\n\t}\n\n\t/* These are now empty */\n\tSLIST_INIT(symlist_src1);\n\tSLIST_INIT(symlist_src2);\n}",
    "includes": [
      "#include \"aicasm.h\"",
      "#include \"aicasm_symbol.h\"",
      "#include <sysexits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <db.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SLIST_INIT",
          "args": [
            "symlist_src2"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_INIT",
          "args": [
            "symlist_src1"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_INSERT_HEAD",
          "args": [
            "symlist_dest",
            "node",
            "links"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_REMOVE_HEAD",
          "args": [
            "symlist_src2",
            "links"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"aicasm.h\"\n#include \"aicasm_symbol.h\"\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <db.h>\n#include <sys/types.h>\n\nvoid\nsymlist_merge(symlist_dest, symlist_src1, symlist_src2)\n\tsymlist_t *symlist_dest;\n\tsymlist_t *symlist_src1;\n\tsymlist_t *symlist_src2;\n{\n\tsymbol_node_t *node;\n\n\t*symlist_dest = *symlist_src1;\n\twhile((node = symlist_src2->slh_first) != NULL) {\n\t\tSLIST_REMOVE_HEAD(symlist_src2, links);\n\t\tSLIST_INSERT_HEAD(symlist_dest, node, links);\n\t}\n\n\t/* These are now empty */\n\tSLIST_INIT(symlist_src1);\n\tSLIST_INIT(symlist_src2);\n}"
  },
  {
    "function_name": "symlist_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm_symbol.c",
    "lines": "270-283",
    "snippet": "void\nsymlist_free(symlist)\n\tsymlist_t *symlist;\n{\n\tsymbol_node_t *node1, *node2;\n\n\tnode1 = symlist->slh_first;\n\twhile (node1 != NULL) {\n\t\tnode2 = node1->links.sle_next;\n\t\tfree(node1);\n\t\tnode1 = node2;\n\t}\n\tSLIST_INIT(symlist);\n}",
    "includes": [
      "#include \"aicasm.h\"",
      "#include \"aicasm_symbol.h\"",
      "#include <sysexits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <db.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "symbol_node_t *\nsymlist_search(symlist, symname)\n\tsymlist_t *symlist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SLIST_INIT",
          "args": [
            "symlist"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "node1"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "symlist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm_symbol.c",
          "lines": "270-283",
          "snippet": "void\nsymlist_free(symlist)\n\tsymlist_t *symlist;\n{\n\tsymbol_node_t *node1, *node2;\n\n\tnode1 = symlist->slh_first;\n\twhile (node1 != NULL) {\n\t\tnode2 = node1->links.sle_next;\n\t\tfree(node1);\n\t\tnode1 = node2;\n\t}\n\tSLIST_INIT(symlist);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"aicasm.h\"\n#include \"aicasm_symbol.h\"\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <db.h>\n#include <sys/types.h>\n\nsymbol_node_t *\nsymlist_search(symlist, symname)\n\tsymlist_t *symlist;\n\nvoid\nsymlist_free(symlist)\n\tsymlist_t *symlist;\n{\n\tsymbol_node_t *node1, *node2;\n\n\tnode1 = symlist->slh_first;\n\twhile (node1 != NULL) {\n\t\tnode2 = node1->links.sle_next;\n\t\tfree(node1);\n\t\tnode1 = node2;\n\t}\n\tSLIST_INIT(symlist);\n}"
  },
  {
    "function_name": "symlist_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm_symbol.c",
    "lines": "201-268",
    "snippet": "void\nsymlist_add(symlist, symbol, how)\n\tsymlist_t *symlist;\n\tsymbol_t  *symbol;\n\tint\t  how;\n{\n\tsymbol_node_t *newnode;\n\n\tnewnode = (symbol_node_t *)malloc(sizeof(symbol_node_t));\n\tif (newnode == NULL) {\n\t\tstop(\"symlist_add: Unable to malloc symbol_node\", EX_SOFTWARE);\n\t\t/* NOTREACHED */\n\t}\n\tnewnode->symbol = symbol;\n\tif (how == SYMLIST_SORT) {\n\t\tsymbol_node_t *curnode;\n\t\tint mask;\n\n\t\tmask = FALSE;\n\t\tswitch(symbol->type) {\n\t\tcase REGISTER:\n\t\tcase SCBLOC:\n\t\tcase SRAMLOC:\n\t\t\tbreak;\n\t\tcase BIT:\n\t\tcase MASK:\n\t\t\tmask = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstop(\"symlist_add: Invalid symbol type for sorting\",\n\t\t\t     EX_SOFTWARE);\n\t\t\t/* NOTREACHED */\n\t\t}\n\n\t\tcurnode = symlist->slh_first;\n\t\tif (curnode == NULL\n\t\t || (mask && (curnode->symbol->info.minfo->mask >\n\t\t              newnode->symbol->info.minfo->mask))\n\t\t || (!mask && (curnode->symbol->info.rinfo->address >\n\t\t               newnode->symbol->info.rinfo->address))) {\n\t\t\tSLIST_INSERT_HEAD(symlist, newnode, links);\n\t\t\treturn;\n\t\t}\n\n\t\twhile (1) {\n\t\t\tif (curnode->links.sle_next == NULL) {\n\t\t\t\tSLIST_INSERT_AFTER(curnode, newnode,\n\t\t\t\t\t\t   links);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tsymbol_t *cursymbol;\n\n\t\t\t\tcursymbol = curnode->links.sle_next->symbol;\n\t\t\t\tif ((mask && (cursymbol->info.minfo->mask >\n\t\t\t\t              symbol->info.minfo->mask))\n\t\t\t\t || (!mask &&(cursymbol->info.rinfo->address >\n\t\t\t\t              symbol->info.rinfo->address))){\n\t\t\t\t\tSLIST_INSERT_AFTER(curnode, newnode,\n\t\t\t\t\t\t\t   links);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurnode = curnode->links.sle_next;\n\t\t}\n\t} else {\n\t\tSLIST_INSERT_HEAD(symlist, newnode, links);\n\t}\n}",
    "includes": [
      "#include \"aicasm.h\"",
      "#include \"aicasm_symbol.h\"",
      "#include <sysexits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <db.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "symbol_node_t *\nsymlist_search(symlist, symname)\n\tsymlist_t *symlist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SLIST_INSERT_HEAD",
          "args": [
            "symlist",
            "newnode",
            "links"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_INSERT_AFTER",
          "args": [
            "curnode",
            "newnode",
            "links"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_INSERT_AFTER",
          "args": [
            "curnode",
            "newnode",
            "links"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_INSERT_HEAD",
          "args": [
            "symlist",
            "newnode",
            "links"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop",
          "args": [
            "\"symlist_add: Invalid symbol type for sorting\"",
            "EX_SOFTWARE"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
          "lines": "576-621",
          "snippet": "void\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}",
          "includes": [
            "#include \"sequencer.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include \"aicasm.h\"",
            "#include <unistd.h>",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <sys/mman.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void output_code(FILE *ofile);",
            "char *appname;",
            "FILE *ofile;",
            "char *ofilename;",
            "char *regfilename;",
            "FILE *regfile;",
            "char *listfilename;",
            "FILE *listfile;",
            "symlist_t patch_functions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void output_code(FILE *ofile);\nchar *appname;\nFILE *ofile;\nchar *ofilename;\nchar *regfilename;\nFILE *regfile;\nchar *listfilename;\nFILE *listfile;\nsymlist_t patch_functions;\n\nvoid\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(symbol_node_t)"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"aicasm.h\"\n#include \"aicasm_symbol.h\"\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <db.h>\n#include <sys/types.h>\n\nsymbol_node_t *\nsymlist_search(symlist, symname)\n\tsymlist_t *symlist;\n\nvoid\nsymlist_add(symlist, symbol, how)\n\tsymlist_t *symlist;\n\tsymbol_t  *symbol;\n\tint\t  how;\n{\n\tsymbol_node_t *newnode;\n\n\tnewnode = (symbol_node_t *)malloc(sizeof(symbol_node_t));\n\tif (newnode == NULL) {\n\t\tstop(\"symlist_add: Unable to malloc symbol_node\", EX_SOFTWARE);\n\t\t/* NOTREACHED */\n\t}\n\tnewnode->symbol = symbol;\n\tif (how == SYMLIST_SORT) {\n\t\tsymbol_node_t *curnode;\n\t\tint mask;\n\n\t\tmask = FALSE;\n\t\tswitch(symbol->type) {\n\t\tcase REGISTER:\n\t\tcase SCBLOC:\n\t\tcase SRAMLOC:\n\t\t\tbreak;\n\t\tcase BIT:\n\t\tcase MASK:\n\t\t\tmask = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstop(\"symlist_add: Invalid symbol type for sorting\",\n\t\t\t     EX_SOFTWARE);\n\t\t\t/* NOTREACHED */\n\t\t}\n\n\t\tcurnode = symlist->slh_first;\n\t\tif (curnode == NULL\n\t\t || (mask && (curnode->symbol->info.minfo->mask >\n\t\t              newnode->symbol->info.minfo->mask))\n\t\t || (!mask && (curnode->symbol->info.rinfo->address >\n\t\t               newnode->symbol->info.rinfo->address))) {\n\t\t\tSLIST_INSERT_HEAD(symlist, newnode, links);\n\t\t\treturn;\n\t\t}\n\n\t\twhile (1) {\n\t\t\tif (curnode->links.sle_next == NULL) {\n\t\t\t\tSLIST_INSERT_AFTER(curnode, newnode,\n\t\t\t\t\t\t   links);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tsymbol_t *cursymbol;\n\n\t\t\t\tcursymbol = curnode->links.sle_next->symbol;\n\t\t\t\tif ((mask && (cursymbol->info.minfo->mask >\n\t\t\t\t              symbol->info.minfo->mask))\n\t\t\t\t || (!mask &&(cursymbol->info.rinfo->address >\n\t\t\t\t              symbol->info.rinfo->address))){\n\t\t\t\t\tSLIST_INSERT_AFTER(curnode, newnode,\n\t\t\t\t\t\t\t   links);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurnode = curnode->links.sle_next;\n\t\t}\n\t} else {\n\t\tSLIST_INSERT_HEAD(symlist, newnode, links);\n\t}\n}"
  },
  {
    "function_name": "symtable_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm_symbol.c",
    "lines": "124-139",
    "snippet": "void\nsymtable_close()\n{\n\tif (symtable != NULL) {\n\t\tDBT\t key;\n\t\tDBT\t data;\n\n\t\twhile (symtable->seq(symtable, &key, &data, R_FIRST) == 0) {\n\t\t\tsymbol_t *stored_ptr;\n\n\t\t\tmemcpy(&stored_ptr, data.data, sizeof(stored_ptr));\n\t\t\tsymbol_delete(stored_ptr);\n\t\t}\n\t\tsymtable->close(symtable);\n\t}\n}",
    "includes": [
      "#include \"aicasm.h\"",
      "#include \"aicasm_symbol.h\"",
      "#include <sysexits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <db.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DB *symtable;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "symtable->close",
          "args": [
            "symtable"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symbol_delete",
          "args": [
            "stored_ptr"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "symbol_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm_symbol.c",
          "lines": "64-108",
          "snippet": "void\nsymbol_delete(symbol)\n\tsymbol_t *symbol;\n{\n\tif (symtable != NULL) {\n\t\tDBT\t key;\n\n\t\tkey.data = symbol->name;\n\t\tkey.size = strlen(symbol->name);\n\t\tsymtable->del(symtable, &key, /*flags*/0);\n\t}\n\tswitch(symbol->type) {\n\tcase SCBLOC:\n\tcase SRAMLOC:\n\tcase REGISTER:\n\t\tif (symbol->info.rinfo != NULL)\n\t\t\tfree(symbol->info.rinfo);\n\t\tbreak;\n\tcase ALIAS:\n\t\tif (symbol->info.ainfo != NULL)\n\t\t\tfree(symbol->info.ainfo);\n\t\tbreak;\n\tcase MASK:\n\tcase BIT:\n\t\tif (symbol->info.minfo != NULL) {\n\t\t\tsymlist_free(&symbol->info.minfo->symrefs);\n\t\t\tfree(symbol->info.minfo);\n\t\t}\n\t\tbreak;\n\tcase DOWNLOAD_CONST:\n\tcase CONST:\n\t\tif (symbol->info.cinfo != NULL)\n\t\t\tfree(symbol->info.cinfo);\n\t\tbreak;\n\tcase LABEL:\n\t\tif (symbol->info.linfo != NULL)\n\t\t\tfree(symbol->info.linfo);\n\t\tbreak;\n\tcase UNINITIALIZED:\n\tdefault:\n\t\tbreak;\n\t}\n\tfree(symbol->name);\n\tfree(symbol);\n}",
          "includes": [
            "#include \"aicasm.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <db.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DB *symtable;",
            "symbol_t *\nsymbol_create(name)\n\tchar *name;",
            "symbol_t *\nsymtable_get(name)\n\tchar *name;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"aicasm.h\"\n#include \"aicasm_symbol.h\"\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <db.h>\n#include <sys/types.h>\n\nstatic DB *symtable;\nsymbol_t *\nsymbol_create(name)\n\tchar *name;\nsymbol_t *\nsymtable_get(name)\n\tchar *name;\n\nvoid\nsymbol_delete(symbol)\n\tsymbol_t *symbol;\n{\n\tif (symtable != NULL) {\n\t\tDBT\t key;\n\n\t\tkey.data = symbol->name;\n\t\tkey.size = strlen(symbol->name);\n\t\tsymtable->del(symtable, &key, /*flags*/0);\n\t}\n\tswitch(symbol->type) {\n\tcase SCBLOC:\n\tcase SRAMLOC:\n\tcase REGISTER:\n\t\tif (symbol->info.rinfo != NULL)\n\t\t\tfree(symbol->info.rinfo);\n\t\tbreak;\n\tcase ALIAS:\n\t\tif (symbol->info.ainfo != NULL)\n\t\t\tfree(symbol->info.ainfo);\n\t\tbreak;\n\tcase MASK:\n\tcase BIT:\n\t\tif (symbol->info.minfo != NULL) {\n\t\t\tsymlist_free(&symbol->info.minfo->symrefs);\n\t\t\tfree(symbol->info.minfo);\n\t\t}\n\t\tbreak;\n\tcase DOWNLOAD_CONST:\n\tcase CONST:\n\t\tif (symbol->info.cinfo != NULL)\n\t\t\tfree(symbol->info.cinfo);\n\t\tbreak;\n\tcase LABEL:\n\t\tif (symbol->info.linfo != NULL)\n\t\t\tfree(symbol->info.linfo);\n\t\tbreak;\n\tcase UNINITIALIZED:\n\tdefault:\n\t\tbreak;\n\t}\n\tfree(symbol->name);\n\tfree(symbol);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&stored_ptr",
            "data.data",
            "sizeof(stored_ptr)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symtable->seq",
          "args": [
            "symtable",
            "&key",
            "&data",
            "R_FIRST"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"aicasm.h\"\n#include \"aicasm_symbol.h\"\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <db.h>\n#include <sys/types.h>\n\nstatic DB *symtable;\n\nvoid\nsymtable_close()\n{\n\tif (symtable != NULL) {\n\t\tDBT\t key;\n\t\tDBT\t data;\n\n\t\twhile (symtable->seq(symtable, &key, &data, R_FIRST) == 0) {\n\t\t\tsymbol_t *stored_ptr;\n\n\t\t\tmemcpy(&stored_ptr, data.data, sizeof(stored_ptr));\n\t\t\tsymbol_delete(stored_ptr);\n\t\t}\n\t\tsymtable->close(symtable);\n\t}\n}"
  },
  {
    "function_name": "symtable_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm_symbol.c",
    "lines": "110-122",
    "snippet": "void\nsymtable_open()\n{\n\tsymtable = dbopen(/*filename*/NULL,\n\t\t\t  O_CREAT | O_NONBLOCK | O_RDWR, /*mode*/0, DB_HASH,\n\t\t\t  /*openinfo*/NULL);\n\n\tif (symtable == NULL) {\n\t\tperror(\"Symbol table creation failed\");\n\t\texit(EX_SOFTWARE);\n\t\t/* NOTREACHED */\n\t}\n}",
    "includes": [
      "#include \"aicasm.h\"",
      "#include \"aicasm_symbol.h\"",
      "#include <sysexits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <db.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DB *symtable;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EX_SOFTWARE"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"Symbol table creation failed\""
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "ata_perror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata.c",
          "lines": "177-210",
          "snippet": "void\nata_perror(drvp, errno, buf)\n\tstruct ata_drive_datas *drvp;\n\tint errno;\n\tchar *buf;\n{\n\tstatic char *errstr0_3[] = {\"address mark not found\",\n\t    \"track 0 not found\", \"aborted command\", \"media change requested\",\n\t    \"id not found\", \"media changed\", \"uncorrectable data error\",\n\t    \"bad block detected\"};\n\tstatic char *errstr4_5[] = {\"\",\n\t    \"no media/write protected\", \"aborted command\",\n\t    \"media change requested\", \"id not found\", \"media changed\",\n\t    \"uncorrectable data error\", \"interface CRC error\"};\n\tchar **errstr;\n\tint i;\n\tchar *sep = \"\";\n\n\tif (drvp->ata_vers >= 4)\n\t\terrstr = errstr4_5;\n\telse\n\t\terrstr = errstr0_3;\n\n\tif (errno == 0) {\n\t\tsprintf(buf, \"error not notified\");\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (errno & (1 << i)) {\n\t\t\tbuf += sprintf(buf, \"%s %s\", sep, errstr[i]);\n\t\t\tsep = \",\";\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <dev/ic/wdcreg.h>\n#include <sys/syslog.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nata_perror(drvp, errno, buf)\n\tstruct ata_drive_datas *drvp;\n\tint errno;\n\tchar *buf;\n{\n\tstatic char *errstr0_3[] = {\"address mark not found\",\n\t    \"track 0 not found\", \"aborted command\", \"media change requested\",\n\t    \"id not found\", \"media changed\", \"uncorrectable data error\",\n\t    \"bad block detected\"};\n\tstatic char *errstr4_5[] = {\"\",\n\t    \"no media/write protected\", \"aborted command\",\n\t    \"media change requested\", \"id not found\", \"media changed\",\n\t    \"uncorrectable data error\", \"interface CRC error\"};\n\tchar **errstr;\n\tint i;\n\tchar *sep = \"\";\n\n\tif (drvp->ata_vers >= 4)\n\t\terrstr = errstr4_5;\n\telse\n\t\terrstr = errstr0_3;\n\n\tif (errno == 0) {\n\t\tsprintf(buf, \"error not notified\");\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (errno & (1 << i)) {\n\t\t\tbuf += sprintf(buf, \"%s %s\", sep, errstr[i]);\n\t\t\tsep = \",\";\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbopen",
          "args": [
            "/*filename*/NULL",
            "O_CREAT | O_NONBLOCK | O_RDWR",
            "/*mode*/0",
            "DB_HASH",
            "/*openinfo*/NULL"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"aicasm.h\"\n#include \"aicasm_symbol.h\"\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <db.h>\n#include <sys/types.h>\n\nstatic DB *symtable;\n\nvoid\nsymtable_open()\n{\n\tsymtable = dbopen(/*filename*/NULL,\n\t\t\t  O_CREAT | O_NONBLOCK | O_RDWR, /*mode*/0, DB_HASH,\n\t\t\t  /*openinfo*/NULL);\n\n\tif (symtable == NULL) {\n\t\tperror(\"Symbol table creation failed\");\n\t\texit(EX_SOFTWARE);\n\t\t/* NOTREACHED */\n\t}\n}"
  },
  {
    "function_name": "symbol_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm_symbol.c",
    "lines": "64-108",
    "snippet": "void\nsymbol_delete(symbol)\n\tsymbol_t *symbol;\n{\n\tif (symtable != NULL) {\n\t\tDBT\t key;\n\n\t\tkey.data = symbol->name;\n\t\tkey.size = strlen(symbol->name);\n\t\tsymtable->del(symtable, &key, /*flags*/0);\n\t}\n\tswitch(symbol->type) {\n\tcase SCBLOC:\n\tcase SRAMLOC:\n\tcase REGISTER:\n\t\tif (symbol->info.rinfo != NULL)\n\t\t\tfree(symbol->info.rinfo);\n\t\tbreak;\n\tcase ALIAS:\n\t\tif (symbol->info.ainfo != NULL)\n\t\t\tfree(symbol->info.ainfo);\n\t\tbreak;\n\tcase MASK:\n\tcase BIT:\n\t\tif (symbol->info.minfo != NULL) {\n\t\t\tsymlist_free(&symbol->info.minfo->symrefs);\n\t\t\tfree(symbol->info.minfo);\n\t\t}\n\t\tbreak;\n\tcase DOWNLOAD_CONST:\n\tcase CONST:\n\t\tif (symbol->info.cinfo != NULL)\n\t\t\tfree(symbol->info.cinfo);\n\t\tbreak;\n\tcase LABEL:\n\t\tif (symbol->info.linfo != NULL)\n\t\t\tfree(symbol->info.linfo);\n\t\tbreak;\n\tcase UNINITIALIZED:\n\tdefault:\n\t\tbreak;\n\t}\n\tfree(symbol->name);\n\tfree(symbol);\n}",
    "includes": [
      "#include \"aicasm.h\"",
      "#include \"aicasm_symbol.h\"",
      "#include <sysexits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <db.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DB *symtable;",
      "symbol_t *\nsymbol_create(name)\n\tchar *name;",
      "symbol_t *\nsymtable_get(name)\n\tchar *name;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "symbol"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "symlist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm_symbol.c",
          "lines": "270-283",
          "snippet": "void\nsymlist_free(symlist)\n\tsymlist_t *symlist;\n{\n\tsymbol_node_t *node1, *node2;\n\n\tnode1 = symlist->slh_first;\n\twhile (node1 != NULL) {\n\t\tnode2 = node1->links.sle_next;\n\t\tfree(node1);\n\t\tnode1 = node2;\n\t}\n\tSLIST_INIT(symlist);\n}",
          "includes": [
            "#include \"aicasm.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <db.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "symbol_node_t *\nsymlist_search(symlist, symname)\n\tsymlist_t *symlist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"aicasm.h\"\n#include \"aicasm_symbol.h\"\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <db.h>\n#include <sys/types.h>\n\nsymbol_node_t *\nsymlist_search(symlist, symname)\n\tsymlist_t *symlist;\n\nvoid\nsymlist_free(symlist)\n\tsymlist_t *symlist;\n{\n\tsymbol_node_t *node1, *node2;\n\n\tnode1 = symlist->slh_first;\n\twhile (node1 != NULL) {\n\t\tnode2 = node1->links.sle_next;\n\t\tfree(node1);\n\t\tnode1 = node2;\n\t}\n\tSLIST_INIT(symlist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "symtable->del",
          "args": [
            "symtable",
            "&key",
            "/*flags*/0"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symbol->name"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"aicasm.h\"\n#include \"aicasm_symbol.h\"\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <db.h>\n#include <sys/types.h>\n\nstatic DB *symtable;\nsymbol_t *\nsymbol_create(name)\n\tchar *name;\nsymbol_t *\nsymtable_get(name)\n\tchar *name;\n\nvoid\nsymbol_delete(symbol)\n\tsymbol_t *symbol;\n{\n\tif (symtable != NULL) {\n\t\tDBT\t key;\n\n\t\tkey.data = symbol->name;\n\t\tkey.size = strlen(symbol->name);\n\t\tsymtable->del(symtable, &key, /*flags*/0);\n\t}\n\tswitch(symbol->type) {\n\tcase SCBLOC:\n\tcase SRAMLOC:\n\tcase REGISTER:\n\t\tif (symbol->info.rinfo != NULL)\n\t\t\tfree(symbol->info.rinfo);\n\t\tbreak;\n\tcase ALIAS:\n\t\tif (symbol->info.ainfo != NULL)\n\t\t\tfree(symbol->info.ainfo);\n\t\tbreak;\n\tcase MASK:\n\tcase BIT:\n\t\tif (symbol->info.minfo != NULL) {\n\t\t\tsymlist_free(&symbol->info.minfo->symrefs);\n\t\t\tfree(symbol->info.minfo);\n\t\t}\n\t\tbreak;\n\tcase DOWNLOAD_CONST:\n\tcase CONST:\n\t\tif (symbol->info.cinfo != NULL)\n\t\t\tfree(symbol->info.cinfo);\n\t\tbreak;\n\tcase LABEL:\n\t\tif (symbol->info.linfo != NULL)\n\t\t\tfree(symbol->info.linfo);\n\t\tbreak;\n\tcase UNINITIALIZED:\n\tdefault:\n\t\tbreak;\n\t}\n\tfree(symbol->name);\n\tfree(symbol);\n}"
  }
]