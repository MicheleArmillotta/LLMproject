[
  {
    "function_name": "ne_isapnp_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ne_isapnp.c",
    "lines": "124-223",
    "snippet": "static void\nne_isapnp_attach(\n\tstruct device *parent,\n\tstruct device *self,\n\tvoid *aux)\n{\n\tstruct ne_isapnp_softc * const isc = (struct ne_isapnp_softc *)self;\n\tstruct ne2000_softc * const nsc = &isc->sc_ne2000;\n\tstruct dp8390_softc * const dsc = &nsc->sc_dp8390;\n\tstruct isa_attach_args * const ipa = aux;\n\tbus_space_tag_t nict;\n\tbus_space_handle_t nich;\n\tbus_space_tag_t asict;\n\tbus_space_handle_t asich;\n\tvoid (*npp_init_media) __P((struct dp8390_softc *, int **,\n\t    int *, int *));\n\tint *media, nmedia, defmedia;\n\tconst char *typestr;\n\tint netype;\n\n\tprintf(\"\\n\");\n\n\tnpp_init_media = NULL;\n\tmedia = NULL;\n\tnmedia = defmedia = 0;\n\n\tnict = ipa->ia_iot;\n\tnich = ipa->ipa_io[0].h;\n\n\tasict = nict;\n\n\tif (bus_space_subregion(nict, nich, NE2000_ASIC_OFFSET,\n\t    NE2000_ASIC_NPORTS, &asich)) {\n\t\tprintf(\"%s: can't subregion i/o space\\n\", dsc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tdsc->sc_regt = nict;\n\tdsc->sc_regh = nich;\n\n\tnsc->sc_asict = asict;\n\tnsc->sc_asich = asich;\n\n\t/*\n\t * Detect it again, so we can print some information about the\n\t * interface.\n\t */\n\tnetype = ne2000_detect(nsc);\n\tswitch (netype) {\n\tcase NE2000_TYPE_NE1000:\n\t\ttypestr = \"NE1000\";\n\t\tbreak;\n\n\tcase NE2000_TYPE_NE2000:\n\t\ttypestr = \"NE2000\";\n\t\t/*\n\t\t * Check for a RealTek 8019.\n\t\t */\n\t\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t\t    ED_CR_PAGE_0 | ED_CR_STP);\n\t\tif (bus_space_read_1(nict, nich, NERTL_RTL0_8019ID0) ==\n\t\t\t\t\t\t\t\tRTL0_8019ID0 &&\n\t\t    bus_space_read_1(nict, nich, NERTL_RTL0_8019ID1) ==\n\t\t\t\t\t\t\t\tRTL0_8019ID1) {\n\t\t\ttypestr = \"NE2000 (RTL8019)\";\n\t\t\tnpp_init_media = rtl80x9_init_media;\n\t\t\tdsc->sc_mediachange = rtl80x9_mediachange;\n\t\t\tdsc->sc_mediastatus = rtl80x9_mediastatus;\n\t\t\tdsc->init_card = rtl80x9_init_card;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: where did the card go?!\\n\", dsc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tprintf(\"%s: %s Ethernet\\n\", dsc->sc_dev.dv_xname, typestr);\n\n\t/* Initialize media, if we have it. */\n\tif (npp_init_media != NULL)\n\t\t(*npp_init_media)(dsc, &media, &nmedia, &defmedia);\n\n\t/* This interface is always enabled. */\n\tdsc->sc_enabled = 1;\n\n\t/*\n\t * Do generic NE2000 attach.  This will read the station address\n\t * from the EEPROM.\n\t */\n\tne2000_attach(nsc, NULL, media, nmedia, defmedia);\n\n\t/* Establish the interrupt handler. */\n\tisc->sc_ih = isa_intr_establish(ipa->ia_ic, ipa->ipa_irq[0].num,\n\t    IST_EDGE, IPL_NET, dp8390_intr, dsc,\n\t    dsc->sc_dev.dv_xname);\n\tif (isc->sc_ih == NULL)\n\t\tprintf(\"%s: couldn't establish interrupt handler\\n\",\n\t\t    dsc->sc_dev.dv_xname);\n}",
    "includes": [
      "#include <dev/isa/isapnpdevs.h>",
      "#include <dev/isa/isapnpvar.h>",
      "#include <dev/isa/isapnpreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/ic/rtl80x9var.h>",
      "#include <dev/ic/rtl80x9reg.h>",
      "#include <dev/ic/ne2000var.h>",
      "#include <dev/ic/ne2000reg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ne_isapnp_attach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: couldn't establish interrupt handler\\n\"",
            "dsc->sc_dev.dv_xname"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ipa->ia_ic",
            "ipa->ipa_irq[0].num",
            "IST_EDGE",
            "IPL_NET",
            "dp8390_intr",
            "dsc",
            "dsc->sc_dev.dv_xname"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ne2000_attach",
          "args": [
            "nsc",
            "NULL",
            "media",
            "nmedia",
            "defmedia"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "ne2000_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ne2000.c",
          "lines": "105-261",
          "snippet": "void\nne2000_attach(nsc, myea, media, nmedia, defmedia)\n\tstruct ne2000_softc *nsc;\n\tu_int8_t *myea;\n\tint *media, nmedia, defmedia;\n{\n\tstruct dp8390_softc *dsc = &nsc->sc_dp8390;\n\tbus_space_tag_t nict = dsc->sc_regt;\n\tbus_space_handle_t nich = dsc->sc_regh;\n\tbus_space_tag_t asict = nsc->sc_asict;\n\tbus_space_handle_t asich = nsc->sc_asich;\n\tu_int8_t romdata[16];\n\tint memsize, i, useword;\n\n\t/*\n\t * Detect it again; this gives us the memory size.\n\t */\n\tnsc->sc_type = ne2000_detect(nsc);\n\tif (nsc->sc_type == 0) {\n\t\tprintf(\"%s: where did the card go?\\n\", dsc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tuseword = (nsc->sc_type != NE2000_TYPE_NE1000);\n\n\tdsc->cr_proto = ED_CR_RD2;\n\n\t/*\n\t * DCR gets:\n\t *\n\t *\tFIFO threshold to 8, No auto-init Remote DMA,\n\t *\tbyte order=80x86.\n\t *\n\t * NE1000 gets byte-wide DMA, NE2000 gets word-wide DMA.\n\t */\n\tdsc->dcr_reg = ED_DCR_FT1 | ED_DCR_LS |\n\t    (nsc->sc_type != NE2000_TYPE_NE1000 ? ED_DCR_WTS : 0);\n\n\tdsc->test_mem = ne2000_test_mem;\n\tdsc->ring_copy = ne2000_ring_copy;\n\tdsc->write_mbuf = ne2000_write_mbuf;\n\tdsc->read_hdr = ne2000_read_hdr;\n\n\t/* Registers are linear. */\n\tfor (i = 0; i < 16; i++)\n\t\tdsc->sc_reg_map[i] = i;\n\n\t/*\n\t * 8k of memory plus an additional 8k if an NE2000.\n\t */\n\tmemsize = 8192 + (nsc->sc_type != NE2000_TYPE_NE1000 ? 8192 : 0);\n\n\t/*\n\t * NIC memory doens't start at zero on an NE board.\n\t * The start address is tied to the bus width.\n\t * (It happens to be computed the same way as mem size.)\n\t */\n\tdsc->mem_start = memsize;\n\n#ifdef GWETHER\n\t{\n\t\tint x, mstart = 0;\n\t\tint8_t pbuf0[ED_PAGE_SIZE], pbuf[ED_PAGE_SIZE],\n\t\t    tbuf[ED_PAGE_SIZE];\n\n\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\tpbuf0[i] = 0;\n\n\t\t/* Search for the start of RAM. */\n\t\tfor (x = 1; x < 256; x++) {\n\t\t\tne2000_writemem(nict, nich, asict, asich, pbuf0,\n\t\t\t    x << ED_PAGE_SHIFT, ED_PAGE_SIZE, useword);\n\t\t\tne2000_readmem(nict, nich, asict, asich,\n\t\t\t    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE, useword);\n\t\t\tif (bcmp(pbuf0, tbuf, ED_PAGE_SIZE) == 0) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\tne2000_writemem(nict, nich, asict, asich,\n\t\t\t\t    pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE,\n\t\t\t\t    useword);\n\t\t\t\tne2000_readmem(nict, nich, asict, asich,\n\t\t\t\t    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE,\n\t\t\t\t    useword);\n\t\t\t\tif (bcmp(pbuf, tbuf, ED_PAGE_SIZE) == 0) {\n\t\t\t\t\tmstart = x << ED_PAGE_SHIFT;\n\t\t\t\t\tmemsize = ED_PAGE_SIZE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mstart == 0) {\n\t\t\tprintf(\"%s: cannot find start of RAM\\n\",\n\t\t\t    dsc->sc_dev.dv_xname);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Search for the end of RAM. */\n\t\tfor (++x; x < 256; x++) {\n\t\t\tne2000_writemem(nict, nich, asict, asich, pbuf0,\n\t\t\t    x << ED_PAGE_SHIFT, ED_PAGE_SIZE, useword);\n\t\t\tne2000_readmem(nict, nich, asict, asich,\n\t\t\t    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE, useword);\n\t\t\tif (bcmp(pbuf0, tbuf, ED_PAGE_SIZE) == 0) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\tne2000_writemem(nict, nich, asict, asich,\n\t\t\t\t    pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE,\n\t\t\t\t    useword);\n\t\t\t\tne2000_readmem(nict, nich, asict, asich,\n\t\t\t\t    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE,\n\t\t\t\t    useword);\n\t\t\t\tif (bcmp(pbuf, tbuf, ED_PAGE_SIZE) == 0)\n\t\t\t\t\tmemsize += ED_PAGE_SIZE;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\n\t\tprintf(\"%s: RAM start 0x%x, size %d\\n\",\n\t\t    dsc->sc_dev.dv_xname, mstart, memsize);\n\n\t\tdsc->mem_start = mstart;\n\t}\n#endif /* GWETHER */\n\n\tdsc->mem_size = memsize;\n\n\tif (myea == NULL && nsc->sc_type != NE2000_TYPE_DL10019) {\n\t\t/* Read the station address. */\n\t\tne2000_readmem(nict, nich, asict, asich, 0, romdata,\n\t\t    sizeof(romdata), useword);\n\t\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n#ifdef __NetBSD__\n\t\t\tdsc->sc_enaddr[i] = romdata[i * (useword ? 2 : 1)];\n#else\n\t\t\tdsc->sc_arpcom.ac_enaddr[i] =\n\t\t\t\tromdata[i * (useword ? 2 : 1)];\n#endif\n\t}\n\n\t/* Clear any pending interrupts that might have occurred above. */\n\tbus_space_write_1(nict, nich, ED_P0_ISR, 0xff);\n\n\tif (dp8390_config(dsc, media, nmedia, defmedia)) {\n\t\tprintf(\"%s: setup failed\\n\", dsc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/*\n\t * We need to compute mem_ring a bit differently; override the\n\t * value set up in dp8390_config().\n\t */\n\tdsc->mem_ring =\n\t    dsc->mem_start + ((dsc->txb_cnt * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n}",
          "includes": [
            "#include <dev/ic/ne2000var.h>",
            "#include <dev/ic/ne2000reg.h>",
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tne2000_write_mbuf",
            "int\tne2000_ring_copy",
            "void\tne2000_read_hdr",
            "int\tne2000_test_mem",
            "void\tne2000_writemem",
            "void\tne2000_readmem"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ne2000var.h>\n#include <dev/ic/ne2000reg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tne2000_write_mbuf;\nint\tne2000_ring_copy;\nvoid\tne2000_read_hdr;\nint\tne2000_test_mem;\nvoid\tne2000_writemem;\nvoid\tne2000_readmem;\n\nvoid\nne2000_attach(nsc, myea, media, nmedia, defmedia)\n\tstruct ne2000_softc *nsc;\n\tu_int8_t *myea;\n\tint *media, nmedia, defmedia;\n{\n\tstruct dp8390_softc *dsc = &nsc->sc_dp8390;\n\tbus_space_tag_t nict = dsc->sc_regt;\n\tbus_space_handle_t nich = dsc->sc_regh;\n\tbus_space_tag_t asict = nsc->sc_asict;\n\tbus_space_handle_t asich = nsc->sc_asich;\n\tu_int8_t romdata[16];\n\tint memsize, i, useword;\n\n\t/*\n\t * Detect it again; this gives us the memory size.\n\t */\n\tnsc->sc_type = ne2000_detect(nsc);\n\tif (nsc->sc_type == 0) {\n\t\tprintf(\"%s: where did the card go?\\n\", dsc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tuseword = (nsc->sc_type != NE2000_TYPE_NE1000);\n\n\tdsc->cr_proto = ED_CR_RD2;\n\n\t/*\n\t * DCR gets:\n\t *\n\t *\tFIFO threshold to 8, No auto-init Remote DMA,\n\t *\tbyte order=80x86.\n\t *\n\t * NE1000 gets byte-wide DMA, NE2000 gets word-wide DMA.\n\t */\n\tdsc->dcr_reg = ED_DCR_FT1 | ED_DCR_LS |\n\t    (nsc->sc_type != NE2000_TYPE_NE1000 ? ED_DCR_WTS : 0);\n\n\tdsc->test_mem = ne2000_test_mem;\n\tdsc->ring_copy = ne2000_ring_copy;\n\tdsc->write_mbuf = ne2000_write_mbuf;\n\tdsc->read_hdr = ne2000_read_hdr;\n\n\t/* Registers are linear. */\n\tfor (i = 0; i < 16; i++)\n\t\tdsc->sc_reg_map[i] = i;\n\n\t/*\n\t * 8k of memory plus an additional 8k if an NE2000.\n\t */\n\tmemsize = 8192 + (nsc->sc_type != NE2000_TYPE_NE1000 ? 8192 : 0);\n\n\t/*\n\t * NIC memory doens't start at zero on an NE board.\n\t * The start address is tied to the bus width.\n\t * (It happens to be computed the same way as mem size.)\n\t */\n\tdsc->mem_start = memsize;\n\n#ifdef GWETHER\n\t{\n\t\tint x, mstart = 0;\n\t\tint8_t pbuf0[ED_PAGE_SIZE], pbuf[ED_PAGE_SIZE],\n\t\t    tbuf[ED_PAGE_SIZE];\n\n\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\tpbuf0[i] = 0;\n\n\t\t/* Search for the start of RAM. */\n\t\tfor (x = 1; x < 256; x++) {\n\t\t\tne2000_writemem(nict, nich, asict, asich, pbuf0,\n\t\t\t    x << ED_PAGE_SHIFT, ED_PAGE_SIZE, useword);\n\t\t\tne2000_readmem(nict, nich, asict, asich,\n\t\t\t    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE, useword);\n\t\t\tif (bcmp(pbuf0, tbuf, ED_PAGE_SIZE) == 0) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\tne2000_writemem(nict, nich, asict, asich,\n\t\t\t\t    pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE,\n\t\t\t\t    useword);\n\t\t\t\tne2000_readmem(nict, nich, asict, asich,\n\t\t\t\t    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE,\n\t\t\t\t    useword);\n\t\t\t\tif (bcmp(pbuf, tbuf, ED_PAGE_SIZE) == 0) {\n\t\t\t\t\tmstart = x << ED_PAGE_SHIFT;\n\t\t\t\t\tmemsize = ED_PAGE_SIZE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mstart == 0) {\n\t\t\tprintf(\"%s: cannot find start of RAM\\n\",\n\t\t\t    dsc->sc_dev.dv_xname);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Search for the end of RAM. */\n\t\tfor (++x; x < 256; x++) {\n\t\t\tne2000_writemem(nict, nich, asict, asich, pbuf0,\n\t\t\t    x << ED_PAGE_SHIFT, ED_PAGE_SIZE, useword);\n\t\t\tne2000_readmem(nict, nich, asict, asich,\n\t\t\t    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE, useword);\n\t\t\tif (bcmp(pbuf0, tbuf, ED_PAGE_SIZE) == 0) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\tne2000_writemem(nict, nich, asict, asich,\n\t\t\t\t    pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE,\n\t\t\t\t    useword);\n\t\t\t\tne2000_readmem(nict, nich, asict, asich,\n\t\t\t\t    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE,\n\t\t\t\t    useword);\n\t\t\t\tif (bcmp(pbuf, tbuf, ED_PAGE_SIZE) == 0)\n\t\t\t\t\tmemsize += ED_PAGE_SIZE;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\n\t\tprintf(\"%s: RAM start 0x%x, size %d\\n\",\n\t\t    dsc->sc_dev.dv_xname, mstart, memsize);\n\n\t\tdsc->mem_start = mstart;\n\t}\n#endif /* GWETHER */\n\n\tdsc->mem_size = memsize;\n\n\tif (myea == NULL && nsc->sc_type != NE2000_TYPE_DL10019) {\n\t\t/* Read the station address. */\n\t\tne2000_readmem(nict, nich, asict, asich, 0, romdata,\n\t\t    sizeof(romdata), useword);\n\t\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n#ifdef __NetBSD__\n\t\t\tdsc->sc_enaddr[i] = romdata[i * (useword ? 2 : 1)];\n#else\n\t\t\tdsc->sc_arpcom.ac_enaddr[i] =\n\t\t\t\tromdata[i * (useword ? 2 : 1)];\n#endif\n\t}\n\n\t/* Clear any pending interrupts that might have occurred above. */\n\tbus_space_write_1(nict, nich, ED_P0_ISR, 0xff);\n\n\tif (dp8390_config(dsc, media, nmedia, defmedia)) {\n\t\tprintf(\"%s: setup failed\\n\", dsc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/*\n\t * We need to compute mem_ring a bit differently; override the\n\t * value set up in dp8390_config().\n\t */\n\tdsc->mem_ring =\n\t    dsc->mem_start + ((dsc->txb_cnt * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "dsc",
            "&media",
            "&nmedia",
            "&defmedia"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "nict",
            "nich",
            "NERTL_RTL0_8019ID1"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "nict",
            "nich",
            "NERTL_RTL0_8019ID0"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "nict",
            "nich",
            "ED_P0_CR",
            "ED_CR_PAGE_0 | ED_CR_STP"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ne2000_detect",
          "args": [
            "nsc"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "ne2000_detect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ne2000.c",
          "lines": "266-429",
          "snippet": "int\nne2000_detect(nsc)\n\tstruct ne2000_softc *nsc;\n{\n\tstruct dp8390_softc *dsc = &nsc->sc_dp8390;\n\tbus_space_tag_t nict = dsc->sc_regt;\n\tbus_space_handle_t nich = dsc->sc_regh;\n\tbus_space_tag_t asict = nsc->sc_asict;\n\tbus_space_handle_t asich = nsc->sc_asich;\n\tstatic u_int8_t test_pattern[32] = \"THIS is A memory TEST pattern\";\n\tu_int8_t test_buffer[32], tmp;\n\tint i, rv = 0;\n\n\t/* Reset the board. */\n#ifdef GWETHER\n\tbus_space_write_1(asict, asich, NE2000_ASIC_RESET, 0);\n\tdelay(200);\n#endif /* GWETHER */\n\ttmp = bus_space_read_1(asict, asich, NE2000_ASIC_RESET);\n\tdelay(10000);\n\n\t/*\n\t * I don't know if this is necessary; probably cruft leftover from\n\t * Clarkson packet driver code. Doesn't do a thing on the boards I've\n\t * tested. -DG [note that a outb(0x84, 0) seems to work here, and is\n\t * non-invasive...but some boards don't seem to reset and I don't have\n\t * complete documentation on what the 'right' thing to do is...so we do\n\t * the invasive thing for now.  Yuck.]\n\t */\n\tbus_space_write_1(asict, asich, NE2000_ASIC_RESET, tmp);\n\tdelay(5000);\n\n\t/*\n\t * This is needed because some NE clones apparently don't reset the\n\t * NIC properly (or the NIC chip doesn't reset fully on power-up).\n\t * XXX - this makes the probe invasive!  Done against my better\n\t * judgement.  -DLG\n\t */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tdelay(5000);\n\n\t/*\n\t * Generic probe routine for testing for the existance of a DS8390.\n\t * Must be performed  after the NIC has just been reset.  This\n\t * works by looking at certain register values that are guaranteed\n\t * to be initialized a certain way after power-up or reset.\n\t *\n\t * Specifically:\n\t *\n\t *\tRegister\t\treset bits\tset bits\n\t *\t--------\t\t----------\t--------\n\t *\tCR\t\t\tTXP, STA\tRD2, STP\n\t *\tISR\t\t\t\t\tRST\n\t *\tIMR\t\t\t<all>\n\t *\tDCR\t\t\t\t\tLAS\n\t *\tTCR\t\t\tLB1, LB0\n\t *\n\t * We only look at CR and ISR, however, since looking at the others\n\t * would require changing register pages, which would be intrusive\n\t * if this isn't an 8390.\n\t */\n\n\ttmp = bus_space_read_1(nict, nich, ED_P0_CR);\n\tif ((tmp & (ED_CR_RD2 | ED_CR_TXP | ED_CR_STA | ED_CR_STP)) !=\n\t    (ED_CR_RD2 | ED_CR_STP))\n\t\tgoto out;\n\n\ttmp = bus_space_read_1(nict, nich, ED_P0_ISR);\n\tif ((tmp & ED_ISR_RST) != ED_ISR_RST)\n\t\tgoto out;\n\n\tbus_space_write_1(nict, nich,\n\t    ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tfor (i = 0; i < 100; i++) {\n\t\tif ((bus_space_read_1(nict, nich, ED_P0_ISR) & ED_ISR_RST) ==\n\t\t    ED_ISR_RST) {\n\t\t\t/* Ack the reset bit. */\n\t\t\tbus_space_write_1(nict, nich, ED_P0_ISR, ED_ISR_RST);\n\t\t\tbreak;\n\t\t}\n\t\tdelay(100);\n\t}\n\n#if 0\n\t/* XXX */\n\tif (i == 100)\n\t\tgoto out;\n#endif\n\n\t/*\n\t * Test the ability to read and write to the NIC memory.  This has\n\t * the side effect of determining if this is an NE1000 or an NE2000.\n\t */\n\n\t/*\n\t * This prevents packets from being stored in the NIC memory when\n\t * the readmem routine turns on the start bit in the CR.\n\t */\n\tbus_space_write_1(nict, nich, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Temporarily initialize DCR for byte operations. */\n\tbus_space_write_1(nict, nich, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\n\tbus_space_write_1(nict, nich, ED_P0_PSTART, 8192 >> ED_PAGE_SHIFT);\n\tbus_space_write_1(nict, nich, ED_P0_PSTOP, 16384 >> ED_PAGE_SHIFT);\n\n\t/*\n\t * Write a test pattern in byte mode.  If this fails, then there\n\t * probably isn't any memory at 8k - which likely means that the\n\t * board is an NE2000.\n\t */\n\tne2000_writemem(nict, nich, asict, asich, test_pattern, 8192,\n\t    sizeof(test_pattern), 0);\n\tne2000_readmem(nict, nich, asict, asich, 8192, test_buffer,\n\t    sizeof(test_buffer), 0);\n\n\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern))) {\n\t\t/* not an NE1000 - try NE2000 */\n\t\tbus_space_write_1(nict, nich, ED_P0_DCR,\n\t\t    ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS);\n\t\tbus_space_write_1(nict, nich, ED_P0_PSTART,\n\t\t    16384 >> ED_PAGE_SHIFT);\n\t\tbus_space_write_1(nict, nich, ED_P0_PSTOP,\n\t\t    32768 >> ED_PAGE_SHIFT);\n\n\t\t/*\n\t\t * Write the test pattern in word mode.  If this also fails,\n\t\t * then we don't know what this board is.\n\t\t */\n\t\tne2000_writemem(nict, nich, asict, asich, test_pattern, 16384,\n\t\t    sizeof(test_pattern), 1);\n\t\tne2000_readmem(nict, nich, asict, asich, 16384, test_buffer,\n\t\t    sizeof(test_buffer), 1);\n\n\t\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern)))\n\t\t\tgoto out;\t/* not an NE2000 either */\n\n\t\trv = NE2000_TYPE_NE2000;\n\t} else {\n\t\ttmp = 0;\n\t\tfor (i = 4; i < 12; i++)\n\t\t\ttmp += bus_space_read_1(asict, asich, i);\n\n\t\tif (tmp == 0xff) {\n\t\t\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\t\t\tdsc->sc_arpcom.ac_enaddr[i] =\n\t\t\t\t\tbus_space_read_1(asict, asich, i + 4);\n\n\t\t\trv = NE2000_TYPE_DL10019;\n\t\t} else {\n\t\t\t/* We're an NE1000. */\n\t\t\trv = NE2000_TYPE_NE1000;\n\t\t}\n\t}\n\n\t/* Clear any pending interrupts that might have occurred above. */\n\tbus_space_write_1(nict, nich, ED_P0_ISR, 0xff);\n\n out:\n\treturn (rv);\n}",
          "includes": [
            "#include <dev/ic/ne2000var.h>",
            "#include <dev/ic/ne2000reg.h>",
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tne2000_writemem",
            "void\tne2000_readmem"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ne2000var.h>\n#include <dev/ic/ne2000reg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tne2000_writemem;\nvoid\tne2000_readmem;\n\nint\nne2000_detect(nsc)\n\tstruct ne2000_softc *nsc;\n{\n\tstruct dp8390_softc *dsc = &nsc->sc_dp8390;\n\tbus_space_tag_t nict = dsc->sc_regt;\n\tbus_space_handle_t nich = dsc->sc_regh;\n\tbus_space_tag_t asict = nsc->sc_asict;\n\tbus_space_handle_t asich = nsc->sc_asich;\n\tstatic u_int8_t test_pattern[32] = \"THIS is A memory TEST pattern\";\n\tu_int8_t test_buffer[32], tmp;\n\tint i, rv = 0;\n\n\t/* Reset the board. */\n#ifdef GWETHER\n\tbus_space_write_1(asict, asich, NE2000_ASIC_RESET, 0);\n\tdelay(200);\n#endif /* GWETHER */\n\ttmp = bus_space_read_1(asict, asich, NE2000_ASIC_RESET);\n\tdelay(10000);\n\n\t/*\n\t * I don't know if this is necessary; probably cruft leftover from\n\t * Clarkson packet driver code. Doesn't do a thing on the boards I've\n\t * tested. -DG [note that a outb(0x84, 0) seems to work here, and is\n\t * non-invasive...but some boards don't seem to reset and I don't have\n\t * complete documentation on what the 'right' thing to do is...so we do\n\t * the invasive thing for now.  Yuck.]\n\t */\n\tbus_space_write_1(asict, asich, NE2000_ASIC_RESET, tmp);\n\tdelay(5000);\n\n\t/*\n\t * This is needed because some NE clones apparently don't reset the\n\t * NIC properly (or the NIC chip doesn't reset fully on power-up).\n\t * XXX - this makes the probe invasive!  Done against my better\n\t * judgement.  -DLG\n\t */\n\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tdelay(5000);\n\n\t/*\n\t * Generic probe routine for testing for the existance of a DS8390.\n\t * Must be performed  after the NIC has just been reset.  This\n\t * works by looking at certain register values that are guaranteed\n\t * to be initialized a certain way after power-up or reset.\n\t *\n\t * Specifically:\n\t *\n\t *\tRegister\t\treset bits\tset bits\n\t *\t--------\t\t----------\t--------\n\t *\tCR\t\t\tTXP, STA\tRD2, STP\n\t *\tISR\t\t\t\t\tRST\n\t *\tIMR\t\t\t<all>\n\t *\tDCR\t\t\t\t\tLAS\n\t *\tTCR\t\t\tLB1, LB0\n\t *\n\t * We only look at CR and ISR, however, since looking at the others\n\t * would require changing register pages, which would be intrusive\n\t * if this isn't an 8390.\n\t */\n\n\ttmp = bus_space_read_1(nict, nich, ED_P0_CR);\n\tif ((tmp & (ED_CR_RD2 | ED_CR_TXP | ED_CR_STA | ED_CR_STP)) !=\n\t    (ED_CR_RD2 | ED_CR_STP))\n\t\tgoto out;\n\n\ttmp = bus_space_read_1(nict, nich, ED_P0_ISR);\n\tif ((tmp & ED_ISR_RST) != ED_ISR_RST)\n\t\tgoto out;\n\n\tbus_space_write_1(nict, nich,\n\t    ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tfor (i = 0; i < 100; i++) {\n\t\tif ((bus_space_read_1(nict, nich, ED_P0_ISR) & ED_ISR_RST) ==\n\t\t    ED_ISR_RST) {\n\t\t\t/* Ack the reset bit. */\n\t\t\tbus_space_write_1(nict, nich, ED_P0_ISR, ED_ISR_RST);\n\t\t\tbreak;\n\t\t}\n\t\tdelay(100);\n\t}\n\n#if 0\n\t/* XXX */\n\tif (i == 100)\n\t\tgoto out;\n#endif\n\n\t/*\n\t * Test the ability to read and write to the NIC memory.  This has\n\t * the side effect of determining if this is an NE1000 or an NE2000.\n\t */\n\n\t/*\n\t * This prevents packets from being stored in the NIC memory when\n\t * the readmem routine turns on the start bit in the CR.\n\t */\n\tbus_space_write_1(nict, nich, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Temporarily initialize DCR for byte operations. */\n\tbus_space_write_1(nict, nich, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\n\tbus_space_write_1(nict, nich, ED_P0_PSTART, 8192 >> ED_PAGE_SHIFT);\n\tbus_space_write_1(nict, nich, ED_P0_PSTOP, 16384 >> ED_PAGE_SHIFT);\n\n\t/*\n\t * Write a test pattern in byte mode.  If this fails, then there\n\t * probably isn't any memory at 8k - which likely means that the\n\t * board is an NE2000.\n\t */\n\tne2000_writemem(nict, nich, asict, asich, test_pattern, 8192,\n\t    sizeof(test_pattern), 0);\n\tne2000_readmem(nict, nich, asict, asich, 8192, test_buffer,\n\t    sizeof(test_buffer), 0);\n\n\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern))) {\n\t\t/* not an NE1000 - try NE2000 */\n\t\tbus_space_write_1(nict, nich, ED_P0_DCR,\n\t\t    ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS);\n\t\tbus_space_write_1(nict, nich, ED_P0_PSTART,\n\t\t    16384 >> ED_PAGE_SHIFT);\n\t\tbus_space_write_1(nict, nich, ED_P0_PSTOP,\n\t\t    32768 >> ED_PAGE_SHIFT);\n\n\t\t/*\n\t\t * Write the test pattern in word mode.  If this also fails,\n\t\t * then we don't know what this board is.\n\t\t */\n\t\tne2000_writemem(nict, nich, asict, asich, test_pattern, 16384,\n\t\t    sizeof(test_pattern), 1);\n\t\tne2000_readmem(nict, nich, asict, asich, 16384, test_buffer,\n\t\t    sizeof(test_buffer), 1);\n\n\t\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern)))\n\t\t\tgoto out;\t/* not an NE2000 either */\n\n\t\trv = NE2000_TYPE_NE2000;\n\t} else {\n\t\ttmp = 0;\n\t\tfor (i = 4; i < 12; i++)\n\t\t\ttmp += bus_space_read_1(asict, asich, i);\n\n\t\tif (tmp == 0xff) {\n\t\t\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\t\t\tdsc->sc_arpcom.ac_enaddr[i] =\n\t\t\t\t\tbus_space_read_1(asict, asich, i + 4);\n\n\t\t\trv = NE2000_TYPE_DL10019;\n\t\t} else {\n\t\t\t/* We're an NE1000. */\n\t\t\trv = NE2000_TYPE_NE1000;\n\t\t}\n\t}\n\n\t/* Clear any pending interrupts that might have occurred above. */\n\tbus_space_write_1(nict, nich, ED_P0_ISR, 0xff);\n\n out:\n\treturn (rv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_subregion",
          "args": [
            "nict",
            "nich",
            "NE2000_ASIC_OFFSET",
            "NE2000_ASIC_NPORTS",
            "&asich"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__P",
          "args": [
            "(struct dp8390_softc *, int **,\n\t    int *, int *)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/isapnpdevs.h>\n#include <dev/isa/isapnpvar.h>\n#include <dev/isa/isapnpreg.h>\n#include <dev/isa/isavar.h>\n#include <dev/ic/rtl80x9var.h>\n#include <dev/ic/rtl80x9reg.h>\n#include <dev/ic/ne2000var.h>\n#include <dev/ic/ne2000reg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic void ne_isapnp_attach;\n\nstatic void\nne_isapnp_attach(\n\tstruct device *parent,\n\tstruct device *self,\n\tvoid *aux)\n{\n\tstruct ne_isapnp_softc * const isc = (struct ne_isapnp_softc *)self;\n\tstruct ne2000_softc * const nsc = &isc->sc_ne2000;\n\tstruct dp8390_softc * const dsc = &nsc->sc_dp8390;\n\tstruct isa_attach_args * const ipa = aux;\n\tbus_space_tag_t nict;\n\tbus_space_handle_t nich;\n\tbus_space_tag_t asict;\n\tbus_space_handle_t asich;\n\tvoid (*npp_init_media) __P((struct dp8390_softc *, int **,\n\t    int *, int *));\n\tint *media, nmedia, defmedia;\n\tconst char *typestr;\n\tint netype;\n\n\tprintf(\"\\n\");\n\n\tnpp_init_media = NULL;\n\tmedia = NULL;\n\tnmedia = defmedia = 0;\n\n\tnict = ipa->ia_iot;\n\tnich = ipa->ipa_io[0].h;\n\n\tasict = nict;\n\n\tif (bus_space_subregion(nict, nich, NE2000_ASIC_OFFSET,\n\t    NE2000_ASIC_NPORTS, &asich)) {\n\t\tprintf(\"%s: can't subregion i/o space\\n\", dsc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tdsc->sc_regt = nict;\n\tdsc->sc_regh = nich;\n\n\tnsc->sc_asict = asict;\n\tnsc->sc_asich = asich;\n\n\t/*\n\t * Detect it again, so we can print some information about the\n\t * interface.\n\t */\n\tnetype = ne2000_detect(nsc);\n\tswitch (netype) {\n\tcase NE2000_TYPE_NE1000:\n\t\ttypestr = \"NE1000\";\n\t\tbreak;\n\n\tcase NE2000_TYPE_NE2000:\n\t\ttypestr = \"NE2000\";\n\t\t/*\n\t\t * Check for a RealTek 8019.\n\t\t */\n\t\tbus_space_write_1(nict, nich, ED_P0_CR,\n\t\t    ED_CR_PAGE_0 | ED_CR_STP);\n\t\tif (bus_space_read_1(nict, nich, NERTL_RTL0_8019ID0) ==\n\t\t\t\t\t\t\t\tRTL0_8019ID0 &&\n\t\t    bus_space_read_1(nict, nich, NERTL_RTL0_8019ID1) ==\n\t\t\t\t\t\t\t\tRTL0_8019ID1) {\n\t\t\ttypestr = \"NE2000 (RTL8019)\";\n\t\t\tnpp_init_media = rtl80x9_init_media;\n\t\t\tdsc->sc_mediachange = rtl80x9_mediachange;\n\t\t\tdsc->sc_mediastatus = rtl80x9_mediastatus;\n\t\t\tdsc->init_card = rtl80x9_init_card;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: where did the card go?!\\n\", dsc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tprintf(\"%s: %s Ethernet\\n\", dsc->sc_dev.dv_xname, typestr);\n\n\t/* Initialize media, if we have it. */\n\tif (npp_init_media != NULL)\n\t\t(*npp_init_media)(dsc, &media, &nmedia, &defmedia);\n\n\t/* This interface is always enabled. */\n\tdsc->sc_enabled = 1;\n\n\t/*\n\t * Do generic NE2000 attach.  This will read the station address\n\t * from the EEPROM.\n\t */\n\tne2000_attach(nsc, NULL, media, nmedia, defmedia);\n\n\t/* Establish the interrupt handler. */\n\tisc->sc_ih = isa_intr_establish(ipa->ia_ic, ipa->ipa_irq[0].num,\n\t    IST_EDGE, IPL_NET, dp8390_intr, dsc,\n\t    dsc->sc_dev.dv_xname);\n\tif (isc->sc_ih == NULL)\n\t\tprintf(\"%s: couldn't establish interrupt handler\\n\",\n\t\t    dsc->sc_dev.dv_xname);\n}"
  },
  {
    "function_name": "ne_isapnp_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ne_isapnp.c",
    "lines": "116-122",
    "snippet": "static int\nne_isapnp_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\treturn 1;\n}",
    "includes": [
      "#include <dev/isa/isapnpdevs.h>",
      "#include <dev/isa/isapnpvar.h>",
      "#include <dev/isa/isapnpreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/ic/rtl80x9var.h>",
      "#include <dev/ic/rtl80x9reg.h>",
      "#include <dev/ic/ne2000var.h>",
      "#include <dev/ic/ne2000reg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ne_isapnp_match"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/isapnpdevs.h>\n#include <dev/isa/isapnpvar.h>\n#include <dev/isa/isapnpreg.h>\n#include <dev/isa/isavar.h>\n#include <dev/ic/rtl80x9var.h>\n#include <dev/ic/rtl80x9reg.h>\n#include <dev/ic/ne2000var.h>\n#include <dev/ic/ne2000reg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int ne_isapnp_match;\n\nstatic int\nne_isapnp_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\treturn 1;\n}"
  }
]