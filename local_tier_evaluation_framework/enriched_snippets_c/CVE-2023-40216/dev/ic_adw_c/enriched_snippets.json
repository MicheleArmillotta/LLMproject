[
  {
    "function_name": "adw_async_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "1231-1261",
    "snippet": "static void\nadw_async_callback(sc, code)\n\tADW_SOFTC\t*sc;\n\tu_int8_t\tcode;\n{\n\tswitch (code) {\n\tcase ADV_ASYNC_SCSI_BUS_RESET_DET:\n\t\t/*\n\t\t * The firmware detected a SCSI Bus reset.\n\t\t */\n\t\tbreak;\n\n\tcase ADV_ASYNC_RDMA_FAILURE:\n\t\t/*\n\t\t * Handle RDMA failure by resetting the SCSI Bus and\n\t\t * possibly the chip if it is unresponsive. Log the error\n\t\t * with a unique code.\n\t\t */\n\t\tAdvResetSCSIBus(sc);\n\t\tbreak;\n\n\tcase ADV_HOST_SCSI_BUS_RESET:\n               /*\n                * Host generated SCSI bus reset occurred.\n                */\n              break;\n\n\tdefault:\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adw_async_callback",
      "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
      "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
      "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
      "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AdvResetSCSIBus",
          "args": [
            "sc"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "AdvResetSCSIBus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "2077-2154",
          "snippet": "int\nAdvResetSCSIBus(sc)\nADW_SOFTC\t*sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint\t\tstatus;\n\tu_int16_t\twdtr_able, sdtr_able, tagqng_able;\n\tu_int8_t\ttid, max_cmd[ADW_MAX_TID + 1];\n\tu_int16_t\tbios_sig;\n\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++)\n\t{\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * Force the AdvInitAsc3550/38C0800Driver() function to\n\t * perform a SCSI Bus Reset by clearing the BIOS signature word.\n\t * The initialization functions assumes a SCSI Bus Reset is not\n\t * needed if the BIOS signature word is present.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, bios_sig);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, 0);\n\n\t/*\n\t * Stop chip and reset it.\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_STOP);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,\n\t\t\tADW_CTRL_REG_CMD_RESET);\n\tAdvSleepMilliSecond(100);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,\n\t\t\tADW_CTRL_REG_CMD_WR_IO_REG);\n\n\t/*\n\t * Reset Adv Library error code, if any, and try\n\t * re-initializing the chip.\n\t */\n\tif (sc->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tstatus = AdvInitAsc38C0800Driver(sc);\n\t} else {\n\t\tstatus = AdvInitAsc3550Driver(sc);\n\t}\n\n\t/* Translate initialization return value to status value. */\n\tif (status == 0) {\n\t\tstatus = ADW_TRUE;\n\t} else {\n\t\tstatus = ADW_FALSE;\n\t}\n\n\t/*\n\t * Restore the BIOS signature word.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, bios_sig);\n\n\t/*\n\t * Restore per TID negotiated values.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvSleepMilliSecond",
            "ADW_SOFTC\t*sc;",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;",
            "u_int8_t\t\ttid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvSleepMilliSecond;\nADW_SOFTC\t*sc;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\nu_int8_t\t\ttid;\n\nint\nAdvResetSCSIBus(sc)\nADW_SOFTC\t*sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint\t\tstatus;\n\tu_int16_t\twdtr_able, sdtr_able, tagqng_able;\n\tu_int8_t\ttid, max_cmd[ADW_MAX_TID + 1];\n\tu_int16_t\tbios_sig;\n\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++)\n\t{\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * Force the AdvInitAsc3550/38C0800Driver() function to\n\t * perform a SCSI Bus Reset by clearing the BIOS signature word.\n\t * The initialization functions assumes a SCSI Bus Reset is not\n\t * needed if the BIOS signature word is present.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, bios_sig);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, 0);\n\n\t/*\n\t * Stop chip and reset it.\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_STOP);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,\n\t\t\tADW_CTRL_REG_CMD_RESET);\n\tAdvSleepMilliSecond(100);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,\n\t\t\tADW_CTRL_REG_CMD_WR_IO_REG);\n\n\t/*\n\t * Reset Adv Library error code, if any, and try\n\t * re-initializing the chip.\n\t */\n\tif (sc->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tstatus = AdvInitAsc38C0800Driver(sc);\n\t} else {\n\t\tstatus = AdvInitAsc3550Driver(sc);\n\t}\n\n\t/* Translate initialization return value to status value. */\n\tif (status == 0) {\n\t\tstatus = ADW_TRUE;\n\t} else {\n\t\tstatus = ADW_FALSE;\n\t}\n\n\t/*\n\t * Restore the BIOS signature word.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, bios_sig);\n\n\t/*\n\t * Restore per TID negotiated values.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_async_callback;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic void\nadw_async_callback(sc, code)\n\tADW_SOFTC\t*sc;\n\tu_int8_t\tcode;\n{\n\tswitch (code) {\n\tcase ADV_ASYNC_SCSI_BUS_RESET_DET:\n\t\t/*\n\t\t * The firmware detected a SCSI Bus reset.\n\t\t */\n\t\tbreak;\n\n\tcase ADV_ASYNC_RDMA_FAILURE:\n\t\t/*\n\t\t * Handle RDMA failure by resetting the SCSI Bus and\n\t\t * possibly the chip if it is unresponsive. Log the error\n\t\t * with a unique code.\n\t\t */\n\t\tAdvResetSCSIBus(sc);\n\t\tbreak;\n\n\tcase ADV_HOST_SCSI_BUS_RESET:\n               /*\n                * Host generated SCSI bus reset occurred.\n                */\n              break;\n\n\tdefault:\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "adw_isr_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "1108-1225",
    "snippet": "static void\nadw_isr_callback(sc, scsiq)\n\tADW_SOFTC      *sc;\n\tADW_SCSI_REQ_Q *scsiq;\n{\n\tbus_dma_tag_t   dmat = sc->sc_dmat;\n\tADW_CCB        *ccb;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_sense_data *s1, *s2;\n//\tint\t\t s;\n\n\n\tccb = adw_ccb_phys_kv(sc, scsiq->ccb_ptr);\n\n\tuntimeout(adw_timeout, ccb);\n\n/*\tif(ccb->flags & CCB_ABORTING) {\n\t\tprintf(\"Retrying request\\n\");\n\t\tccb->flags &= ~CCB_ABORTING;\n\t\tccb->flags |= CCB_ABORTED;\n\t\ts = splbio();\n\t\tadw_queue_ccb(sc, ccb);\n\t\tsplx(s);\n\t\treturn;\n\t}\n*/\n\txs = ccb->xs;\n\n\t/*\n         * If we were a data transfer, unload the map that described\n         * the data buffer.\n         */\n\tif (xs->datalen) {\n\t\tbus_dmamap_sync(dmat, ccb->dmamap_xfer,\n\t\t\t (xs->flags & SCSI_DATA_IN) ?\n\t\t\t BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);\n\t\tbus_dmamap_unload(dmat, ccb->dmamap_xfer);\n\t}\n\tif ((ccb->flags & CCB_ALLOC) == 0) {\n\t\tprintf(\"%s: exiting ccb not allocated!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n\t/*\n\t * Check for an underrun condition.\n\t */\n\t/*\n\t * if (xs->request_bufflen != 0 && scsiqp->data_cnt != 0) {\n\t * ASC_DBG1(1, \"adw_isr_callback: underrun condition %lu bytes\\n\",\n\t * scsiqp->data_cnt); underrun = ASC_TRUE; }\n\t */\n\t/*\n\t * 'done_status' contains the command's ending status.\n\t */\n\tswitch (scsiq->done_status) {\n\tcase QD_NO_ERROR:\n\t\tswitch (scsiq->host_status) {\n\t\tcase QHSTA_NO_ERROR:\n\t\t\txs->error = XS_NOERROR;\n\t\t\txs->resid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* QHSTA error occurred. */\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase QD_WITH_ERROR:\n\t\tswitch (scsiq->host_status) {\n\t\tcase QHSTA_NO_ERROR:\n\t\t\tswitch(scsiq->scsi_status) {\n\t\t\tcase SS_CHK_CONDITION:\n\t\t\tcase SS_CMD_TERMINATED:\n\t\t\t\ts1 = &ccb->scsi_sense;\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SS_TARGET_BUSY:\n\t\t\tcase SS_RSERV_CONFLICT:\n\t\t\tcase SS_QUEUE_FULL:\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\tcase SS_CONDITION_MET:\n\t\t\tcase SS_INTERMID:\n\t\t\tcase SS_INTERMID_COND_MET:\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\tcase SS_GOOD:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase QHSTA_M_SEL_TIMEOUT:\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Some other QHSTA error occurred. */\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase QD_ABORTED_BY_HOST:\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tbreak;\n\n\tdefault:\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tbreak;\n\t}\n\n\tadw_free_ccb(sc, ccb);\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adw_free_ccb",
      "static int adw_queue_ccb",
      "static void adw_isr_callback",
      "static void adw_timeout",
      "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
      "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
      "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
      "int             flags;",
      "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adw_free_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "adw_free_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
          "lines": "397-417",
          "snippet": "static void\nadw_free_ccb(sc, ccb)\n\tADW_SOFTC      *sc;\n\tADW_CCB        *ccb;\n{\n\tint             s;\n\n\ts = splbio();\n\n\tadw_reset_ccb(ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n         * If there were none, wake anybody waiting for one to come free,\n         * starting with queued entries.\n         */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adw_free_ccb",
            "static void adw_reset_ccb",
            "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
            "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
            "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
            "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_free_ccb;\nstatic void adw_reset_ccb;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic void\nadw_free_ccb(sc, ccb)\n\tADW_SOFTC      *sc;\n\tADW_CCB        *ccb;\n{\n\tint             s;\n\n\ts = splbio();\n\n\tadw_reset_ccb(ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n         * If there were none, wake anybody waiting for one to come free,\n         * starting with queued entries.\n         */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debugger",
          "args": [],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: exiting ccb not allocated!\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_unload",
          "args": [
            "dmat",
            "ccb->dmamap_xfer"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "dmat",
            "ccb->dmamap_xfer",
            "(xs->flags & SCSI_DATA_IN) ?\n\t\t\t BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "adw_timeout",
            "ccb"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adw_ccb_phys_kv",
          "args": [
            "sc",
            "scsiq->ccb_ptr"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_free_ccb;\nstatic int adw_queue_ccb;\nstatic void adw_isr_callback;\nstatic void adw_timeout;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nint             flags;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic void\nadw_isr_callback(sc, scsiq)\n\tADW_SOFTC      *sc;\n\tADW_SCSI_REQ_Q *scsiq;\n{\n\tbus_dma_tag_t   dmat = sc->sc_dmat;\n\tADW_CCB        *ccb;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_sense_data *s1, *s2;\n//\tint\t\t s;\n\n\n\tccb = adw_ccb_phys_kv(sc, scsiq->ccb_ptr);\n\n\tuntimeout(adw_timeout, ccb);\n\n/*\tif(ccb->flags & CCB_ABORTING) {\n\t\tprintf(\"Retrying request\\n\");\n\t\tccb->flags &= ~CCB_ABORTING;\n\t\tccb->flags |= CCB_ABORTED;\n\t\ts = splbio();\n\t\tadw_queue_ccb(sc, ccb);\n\t\tsplx(s);\n\t\treturn;\n\t}\n*/\n\txs = ccb->xs;\n\n\t/*\n         * If we were a data transfer, unload the map that described\n         * the data buffer.\n         */\n\tif (xs->datalen) {\n\t\tbus_dmamap_sync(dmat, ccb->dmamap_xfer,\n\t\t\t (xs->flags & SCSI_DATA_IN) ?\n\t\t\t BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);\n\t\tbus_dmamap_unload(dmat, ccb->dmamap_xfer);\n\t}\n\tif ((ccb->flags & CCB_ALLOC) == 0) {\n\t\tprintf(\"%s: exiting ccb not allocated!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n\t/*\n\t * Check for an underrun condition.\n\t */\n\t/*\n\t * if (xs->request_bufflen != 0 && scsiqp->data_cnt != 0) {\n\t * ASC_DBG1(1, \"adw_isr_callback: underrun condition %lu bytes\\n\",\n\t * scsiqp->data_cnt); underrun = ASC_TRUE; }\n\t */\n\t/*\n\t * 'done_status' contains the command's ending status.\n\t */\n\tswitch (scsiq->done_status) {\n\tcase QD_NO_ERROR:\n\t\tswitch (scsiq->host_status) {\n\t\tcase QHSTA_NO_ERROR:\n\t\t\txs->error = XS_NOERROR;\n\t\t\txs->resid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* QHSTA error occurred. */\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase QD_WITH_ERROR:\n\t\tswitch (scsiq->host_status) {\n\t\tcase QHSTA_NO_ERROR:\n\t\t\tswitch(scsiq->scsi_status) {\n\t\t\tcase SS_CHK_CONDITION:\n\t\t\tcase SS_CMD_TERMINATED:\n\t\t\t\ts1 = &ccb->scsi_sense;\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SS_TARGET_BUSY:\n\t\t\tcase SS_RSERV_CONFLICT:\n\t\t\tcase SS_QUEUE_FULL:\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\tcase SS_CONDITION_MET:\n\t\t\tcase SS_INTERMID:\n\t\t\tcase SS_INTERMID_COND_MET:\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\tcase SS_GOOD:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase QHSTA_M_SEL_TIMEOUT:\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Some other QHSTA error occurred. */\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase QD_ABORTED_BY_HOST:\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tbreak;\n\n\tdefault:\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tbreak;\n\t}\n\n\tadw_free_ccb(sc, ccb);\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n}"
  },
  {
    "function_name": "adw_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "1055-1095",
    "snippet": "static void\nadw_timeout(arg)\n\tvoid           *arg;\n{\n\tADW_CCB        *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tADW_SOFTC      *sc = sc_link->adapter_softc;\n\tint             s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\t/*\n         * If it has been through before, then a previous abort has failed,\n         * don't try abort again, reset the bus instead.\n         */\n\tif (ccb->flags & CCB_ABORTED) {\n\t/*\n\t * Abort Timed Out\n\t * Lets try resetting the bus!\n\t */\n\t\tprintf(\" AGAIN. Resetting SCSI Bus\\n\");\n\t\tccb->flags &= ~CCB_ABORTED;\n\t\t/* AdvResetSCSIBus() will call sbreset_callback() */\n\t\tAdvResetSCSIBus(sc);\n\t} else {\n\t/*\n\t * Abort the operation that has timed out\n\t */\n\t\tprintf(\"\\n\");\n\t\txs->error = XS_TIMEOUT;\n\t\tccb->flags |= CCB_ABORTING;\n\t\t/* ADW_ABORT_CCB() will implicitly call isr_callback() */\n\t\tADW_ABORT_CCB(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adw_timeout",
      "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
      "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
      "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
      "int             flags;",
      "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_ABORT_CCB",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AdvResetSCSIBus",
          "args": [
            "sc"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "AdvResetSCSIBus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "2077-2154",
          "snippet": "int\nAdvResetSCSIBus(sc)\nADW_SOFTC\t*sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint\t\tstatus;\n\tu_int16_t\twdtr_able, sdtr_able, tagqng_able;\n\tu_int8_t\ttid, max_cmd[ADW_MAX_TID + 1];\n\tu_int16_t\tbios_sig;\n\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++)\n\t{\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * Force the AdvInitAsc3550/38C0800Driver() function to\n\t * perform a SCSI Bus Reset by clearing the BIOS signature word.\n\t * The initialization functions assumes a SCSI Bus Reset is not\n\t * needed if the BIOS signature word is present.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, bios_sig);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, 0);\n\n\t/*\n\t * Stop chip and reset it.\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_STOP);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,\n\t\t\tADW_CTRL_REG_CMD_RESET);\n\tAdvSleepMilliSecond(100);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,\n\t\t\tADW_CTRL_REG_CMD_WR_IO_REG);\n\n\t/*\n\t * Reset Adv Library error code, if any, and try\n\t * re-initializing the chip.\n\t */\n\tif (sc->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tstatus = AdvInitAsc38C0800Driver(sc);\n\t} else {\n\t\tstatus = AdvInitAsc3550Driver(sc);\n\t}\n\n\t/* Translate initialization return value to status value. */\n\tif (status == 0) {\n\t\tstatus = ADW_TRUE;\n\t} else {\n\t\tstatus = ADW_FALSE;\n\t}\n\n\t/*\n\t * Restore the BIOS signature word.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, bios_sig);\n\n\t/*\n\t * Restore per TID negotiated values.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvSleepMilliSecond",
            "ADW_SOFTC\t*sc;",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;",
            "u_int8_t\t\ttid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvSleepMilliSecond;\nADW_SOFTC\t*sc;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\nu_int8_t\t\ttid;\n\nint\nAdvResetSCSIBus(sc)\nADW_SOFTC\t*sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint\t\tstatus;\n\tu_int16_t\twdtr_able, sdtr_able, tagqng_able;\n\tu_int8_t\ttid, max_cmd[ADW_MAX_TID + 1];\n\tu_int16_t\tbios_sig;\n\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++)\n\t{\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * Force the AdvInitAsc3550/38C0800Driver() function to\n\t * perform a SCSI Bus Reset by clearing the BIOS signature word.\n\t * The initialization functions assumes a SCSI Bus Reset is not\n\t * needed if the BIOS signature word is present.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, bios_sig);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, 0);\n\n\t/*\n\t * Stop chip and reset it.\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_STOP);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,\n\t\t\tADW_CTRL_REG_CMD_RESET);\n\tAdvSleepMilliSecond(100);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,\n\t\t\tADW_CTRL_REG_CMD_WR_IO_REG);\n\n\t/*\n\t * Reset Adv Library error code, if any, and try\n\t * re-initializing the chip.\n\t */\n\tif (sc->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tstatus = AdvInitAsc38C0800Driver(sc);\n\t} else {\n\t\tstatus = AdvInitAsc3550Driver(sc);\n\t}\n\n\t/* Translate initialization return value to status value. */\n\tif (status == 0) {\n\t\tstatus = ADW_TRUE;\n\t} else {\n\t\tstatus = ADW_FALSE;\n\t}\n\n\t/*\n\t * Restore the BIOS signature word.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, bios_sig);\n\n\t/*\n\t * Restore per TID negotiated values.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "sc_link"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_timeout;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nint             flags;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic void\nadw_timeout(arg)\n\tvoid           *arg;\n{\n\tADW_CCB        *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tADW_SOFTC      *sc = sc_link->adapter_softc;\n\tint             s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\t/*\n         * If it has been through before, then a previous abort has failed,\n         * don't try abort again, reset the bus instead.\n         */\n\tif (ccb->flags & CCB_ABORTED) {\n\t/*\n\t * Abort Timed Out\n\t * Lets try resetting the bus!\n\t */\n\t\tprintf(\" AGAIN. Resetting SCSI Bus\\n\");\n\t\tccb->flags &= ~CCB_ABORTED;\n\t\t/* AdvResetSCSIBus() will call sbreset_callback() */\n\t\tAdvResetSCSIBus(sc);\n\t} else {\n\t/*\n\t * Abort the operation that has timed out\n\t */\n\t\tprintf(\"\\n\");\n\t\txs->error = XS_TIMEOUT;\n\t\tccb->flags |= CCB_ABORTING;\n\t\t/* ADW_ABORT_CCB() will implicitly call isr_callback() */\n\t\tADW_ABORT_CCB(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "adw_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "1036-1052",
    "snippet": "static int\nadw_poll(sc, xs, count)\n\tADW_SOFTC      *sc;\n\tstruct scsi_xfer *xs;\n\tint             count;\n{\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\tadw_intr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn (0);\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int adw_poll",
      "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
      "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
      "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
      "int             flags;",
      "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "adw_intr",
          "args": [
            "sc"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "adw_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
          "lines": "1006-1030",
          "snippet": "int\nadw_intr(arg)\n\tvoid           *arg;\n{\n\tADW_SOFTC      *sc = arg;\n\tstruct scsi_xfer *xs;\n\n\n\tif(AdvISR(sc) != ADW_FALSE) {\n\t\t/*\n\t         * If there are queue entries in the software queue, try to\n\t         * run the first one.  We should be more or less guaranteed\n\t         * to succeed, since we just freed a CCB.\n\t         *\n\t         * NOTE: adw_scsi_cmd() relies on our calling it with\n\t         * the first entry in the queue.\n\t         */\n\t        if ((xs = sc->sc_queue.lh_first) != NULL)\n\t\t\t(void) adw_scsi_cmd(xs);\n\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int adw_scsi_cmd",
            "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
            "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
            "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
            "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adw_scsi_cmd;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nint\nadw_intr(arg)\n\tvoid           *arg;\n{\n\tADW_SOFTC      *sc = arg;\n\tstruct scsi_xfer *xs;\n\n\n\tif(AdvISR(sc) != ADW_FALSE) {\n\t\t/*\n\t         * If there are queue entries in the software queue, try to\n\t         * run the first one.  We should be more or less guaranteed\n\t         * to succeed, since we just freed a CCB.\n\t         *\n\t         * NOTE: adw_scsi_cmd() relies on our calling it with\n\t         * the first entry in the queue.\n\t         */\n\t        if ((xs = sc->sc_queue.lh_first) != NULL)\n\t\t\t(void) adw_scsi_cmd(xs);\n\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adw_poll;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nint             flags;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic int\nadw_poll(sc, xs, count)\n\tADW_SOFTC      *sc;\n\tstruct scsi_xfer *xs;\n\tint             count;\n{\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\tadw_intr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn (0);\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn (1);\n}"
  },
  {
    "function_name": "adw_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "1006-1030",
    "snippet": "int\nadw_intr(arg)\n\tvoid           *arg;\n{\n\tADW_SOFTC      *sc = arg;\n\tstruct scsi_xfer *xs;\n\n\n\tif(AdvISR(sc) != ADW_FALSE) {\n\t\t/*\n\t         * If there are queue entries in the software queue, try to\n\t         * run the first one.  We should be more or less guaranteed\n\t         * to succeed, since we just freed a CCB.\n\t         *\n\t         * NOTE: adw_scsi_cmd() relies on our calling it with\n\t         * the first entry in the queue.\n\t         */\n\t        if ((xs = sc->sc_queue.lh_first) != NULL)\n\t\t\t(void) adw_scsi_cmd(xs);\n\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int adw_scsi_cmd",
      "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
      "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
      "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
      "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "adw_scsi_cmd",
          "args": [
            "xs"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "adw_scsi_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
          "lines": "738-849",
          "snippet": "static int\nadw_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tADW_SOFTC      *sc = sc_link->adapter_softc;\n\tADW_CCB        *ccb;\n\tint             s, fromqueue = 1, dontqueue = 0, nowait = 0, retry = 0;\n\tint\t\tflags;\n\n\ts = splbio();\t\t/* protect the queue */\n\n\t/*\n         * If we're running the queue from adw_done(), we've been\n         * called with the first queue entry as our argument.\n         */\n\tif (xs == sc->sc_queue.lh_first) {\n\t\txs = adw_dequeue(sc);\n\t\tfromqueue = 1;\n\t\tnowait = 1;\n\t} else {\n\n\t\t/* Polled requests can't be queued for later. */\n\t\tdontqueue = xs->flags & SCSI_POLL;\n\n\t\t/*\n                 * If there are jobs in the queue, run them first.\n                 */\n\t\tif (sc->sc_queue.lh_first != NULL) {\n\t\t\t/*\n                         * If we can't queue, we have to abort, since\n                         * we have to preserve order.\n                         */\n\t\t\tif (dontqueue) {\n\t\t\t\tsplx(s);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\treturn (TRY_AGAIN_LATER);\n\t\t\t}\n\t\t\t/*\n                         * Swap with the first queue entry.\n                         */\n\t\t\tadw_enqueue(sc, xs, 0);\n\t\t\txs = adw_dequeue(sc);\n\t\t\tfromqueue = 1;\n\t\t}\n\t}\n\n\n\t/*\n         * get a ccb to use. If the transfer\n         * is from a buf (possibly from interrupt time)\n         * then we can't allow it to sleep\n         */\n\n\tflags = xs->flags;\n\tif (nowait)\n\t\tflags |= SCSI_NOSLEEP;\n\tif ((ccb = adw_get_ccb(sc, flags)) == NULL) {\n\t\t/*\n                 * If we can't queue, we lose.\n                 */\n\t\tif (dontqueue) {\n\t\t\tsplx(s);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\t\t/*\n                 * Stuff ourselves into the queue, in front\n                 * if we came off in the first place.\n                 */\n\t\tadw_enqueue(sc, xs, fromqueue);\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\tsplx(s);\t\t/* done playing with the queue */\n\n\tccb->xs = xs;\n\tccb->timeout = xs->timeout;\n\n\tif (adw_build_req(xs, ccb, flags)) {\nretryagain:\n\t\ts = splbio();\n\t\tretry = adw_queue_ccb(sc, ccb, retry);\n\t\tsplx(s);\n\n\t\tswitch(retry) {\n\t\tcase ADW_BUSY:\n\t\t\tgoto retryagain;\n\n\t\tcase ADW_ERROR:\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (COMPLETE);\n\t\t\t\n\t\t}\n\n\t\t/*\n\t         * Usually return SUCCESSFULLY QUEUED\n\t         */\n\t\tif ((xs->flags & SCSI_POLL) == 0)\n\t\t\treturn (SUCCESSFULLY_QUEUED);\n\n\t\t/*\n\t         * If we can't use interrupts, poll on completion\n\t         */\n\t\tif (adw_poll(sc, xs, ccb->timeout)) {\n\t\t\tadw_timeout(ccb);\n\t\t\tif (adw_poll(sc, xs, ccb->timeout))\n\t\t\t\tadw_timeout(ccb);\n\t\t}\n\t}\n\treturn (COMPLETE);\n}",
          "includes": [
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adw_enqueue",
            "static struct scsi_xfer *adw_dequeue",
            "static ADW_CCB *adw_get_ccb",
            "static int adw_queue_ccb",
            "static int adw_scsi_cmd",
            "static int adw_build_req",
            "static int adw_poll",
            "static void adw_timeout",
            "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
            "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
            "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
            "int             flags;",
            "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_enqueue;\nstatic struct scsi_xfer *adw_dequeue;\nstatic ADW_CCB *adw_get_ccb;\nstatic int adw_queue_ccb;\nstatic int adw_scsi_cmd;\nstatic int adw_build_req;\nstatic int adw_poll;\nstatic void adw_timeout;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nint             flags;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic int\nadw_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tADW_SOFTC      *sc = sc_link->adapter_softc;\n\tADW_CCB        *ccb;\n\tint             s, fromqueue = 1, dontqueue = 0, nowait = 0, retry = 0;\n\tint\t\tflags;\n\n\ts = splbio();\t\t/* protect the queue */\n\n\t/*\n         * If we're running the queue from adw_done(), we've been\n         * called with the first queue entry as our argument.\n         */\n\tif (xs == sc->sc_queue.lh_first) {\n\t\txs = adw_dequeue(sc);\n\t\tfromqueue = 1;\n\t\tnowait = 1;\n\t} else {\n\n\t\t/* Polled requests can't be queued for later. */\n\t\tdontqueue = xs->flags & SCSI_POLL;\n\n\t\t/*\n                 * If there are jobs in the queue, run them first.\n                 */\n\t\tif (sc->sc_queue.lh_first != NULL) {\n\t\t\t/*\n                         * If we can't queue, we have to abort, since\n                         * we have to preserve order.\n                         */\n\t\t\tif (dontqueue) {\n\t\t\t\tsplx(s);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\treturn (TRY_AGAIN_LATER);\n\t\t\t}\n\t\t\t/*\n                         * Swap with the first queue entry.\n                         */\n\t\t\tadw_enqueue(sc, xs, 0);\n\t\t\txs = adw_dequeue(sc);\n\t\t\tfromqueue = 1;\n\t\t}\n\t}\n\n\n\t/*\n         * get a ccb to use. If the transfer\n         * is from a buf (possibly from interrupt time)\n         * then we can't allow it to sleep\n         */\n\n\tflags = xs->flags;\n\tif (nowait)\n\t\tflags |= SCSI_NOSLEEP;\n\tif ((ccb = adw_get_ccb(sc, flags)) == NULL) {\n\t\t/*\n                 * If we can't queue, we lose.\n                 */\n\t\tif (dontqueue) {\n\t\t\tsplx(s);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\t\t/*\n                 * Stuff ourselves into the queue, in front\n                 * if we came off in the first place.\n                 */\n\t\tadw_enqueue(sc, xs, fromqueue);\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\tsplx(s);\t\t/* done playing with the queue */\n\n\tccb->xs = xs;\n\tccb->timeout = xs->timeout;\n\n\tif (adw_build_req(xs, ccb, flags)) {\nretryagain:\n\t\ts = splbio();\n\t\tretry = adw_queue_ccb(sc, ccb, retry);\n\t\tsplx(s);\n\n\t\tswitch(retry) {\n\t\tcase ADW_BUSY:\n\t\t\tgoto retryagain;\n\n\t\tcase ADW_ERROR:\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (COMPLETE);\n\t\t\t\n\t\t}\n\n\t\t/*\n\t         * Usually return SUCCESSFULLY QUEUED\n\t         */\n\t\tif ((xs->flags & SCSI_POLL) == 0)\n\t\t\treturn (SUCCESSFULLY_QUEUED);\n\n\t\t/*\n\t         * If we can't use interrupts, poll on completion\n\t         */\n\t\tif (adw_poll(sc, xs, ccb->timeout)) {\n\t\t\tadw_timeout(ccb);\n\t\t\tif (adw_poll(sc, xs, ccb->timeout))\n\t\t\t\tadw_timeout(ccb);\n\t\t}\n\t}\n\treturn (COMPLETE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AdvISR",
          "args": [
            "sc"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "AdvISR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "2176-2317",
          "snippet": "int\nAdvISR(sc)\nADW_SOFTC\t*sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int8_t\tint_stat;\n\tu_int16_t\ttarget_bit;\n\tADW_CARRIER\t*free_carrp/*, *ccb_carr*/;\n\tu_int32_t\tirq_next_pa;\n\tADW_SCSI_REQ_Q\t*scsiq;\n\tADW_CCB\t\t*ccb;\n//\tint\t\ti;\n\n\n\t/* Reading the register clears the interrupt. */\n\tint_stat = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_INTR_STATUS_REG);\n\n\tif ((int_stat & (ADW_INTR_STATUS_INTRA | ADW_INTR_STATUS_INTRB |\n\t     ADW_INTR_STATUS_INTRC)) == 0) {\n\t\treturn ADW_FALSE;\n\t}\n\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_control->dmamap_xfer,\n\t\tBUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);\n\tbus_dmamap_unload(sc->sc_dmat, sc->sc_control->dmamap_xfer);\n\n/*\tccb_carr = sc->irq_sp;\n\tfor(i=0; i<2 && ccb_carr != ASC_CQ_STOPPER; i++) {\n\t\tbus_dmamap_sync(sc->sc_dmat, ccb_carr->dmamap_xfer, 0,\n\t\t\tccb_carr->dmamap_xfer->dm_mapsize,\n\t\t\tBUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);\n\t\tbus_dmamap_unload(sc->sc_dmat, ccb_carr->dmamap_xfer);\n\t\tccb_carr = adw_carrier_phys_kv(sc,\n\t\t\tASC_GET_CARRP(ccb_carr->next_vpa));\n\t}\n*/\n\t/*\n\t * Notify the driver of an asynchronous microcode condition by\n\t * calling the ADV_DVC_VAR.async_callback function. The function\n\t * is passed the microcode ASC_MC_INTRB_CODE byte value.\n\t */\n\tif (int_stat & ADW_INTR_STATUS_INTRB) {\n\t\tu_int8_t intrb_code;\n\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_INTRB_CODE, intrb_code);\n\t\tif (intrb_code == ADV_ASYNC_CARRIER_READY_FAILURE &&\n\t\t    sc->carr_pending_cnt != 0) {\n\t\t    ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_A);\n\t\t    if (sc->chip_type == ADV_CHIP_ASC3550) {\n\t\t    \tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_NOP);\n\t\t    }\n\t\t}\n\n\t\tif (sc->async_callback != 0) {\n\t\t    (*(ADW_ASYNC_CALLBACK)sc->async_callback)(sc, intrb_code);\n\t\t}\n\t}\n\n\t/*\n\t * Check if the IRQ stopper carrier contains a completed request.\n\t */\n\twhile (((irq_next_pa = sc->irq_sp->next_vpa) & ASC_RQ_DONE) != 0)\n\t{\n\t\t/*\n\t\t * Get a pointer to the newly completed ADW_SCSI_REQ_Q structure.\n\t\t * The RISC will have set 'areq_vpa' to a virtual address.\n\t\t *\n\t\t * The firmware will have copied the ASC_SCSI_REQ_Q.ccb_ptr\n\t\t * field to the carrier ADV_CARR_T.areq_vpa field. The conversion\n\t\t * below complements the conversion of ASC_SCSI_REQ_Q.scsiq_ptr'\n\t\t * in AdvExeScsiQueue().\n\t\t */\n\t\tccb = adw_ccb_phys_kv(sc, sc->irq_sp->areq_vpa);\n\t\tscsiq = &ccb->scsiq;\n\t\tscsiq->ccb_ptr = sc->irq_sp->areq_vpa;\n\n/*\t\tccb_carr = ccb->carr_list;\n\t\twhile(ccb_carr != ASC_CQ_STOPPER) {\n\t\t\tbus_dmamap_sync(sc->sc_dmat, ccb_carr->dmamap_xfer, 0,\n\t\t\t\tccb_carr->dmamap_xfer->dm_mapsize,\n\t\t\t\tBUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);\n\t\t\tbus_dmamap_unload(sc->sc_dmat, ccb_carr->dmamap_xfer);\n\t\t\tccb_carr = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(ccb_carr->next_vpa));\n\t\t}\n\n\t\tbus_dmamap_sync(sc->sc_dmat, sc->irq_sp->dmamap_xfer, 0,\n\t\t\tsc->irq_sp->dmamap_xfer->dm_mapsize,\n\t\t\tBUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);\n\t\tbus_dmamap_unload(sc->sc_dmat, sc->irq_sp->dmamap_xfer);\n*/\n\t\t/*\n\t\t * Advance the stopper pointer to the next carrier\n\t\t * ignoring the lower four bits. Free the previous\n\t\t * stopper carrier.\n\t\t */\n\t\tfree_carrp = sc->irq_sp;\n\t\tsc->irq_sp = adw_carrier_phys_kv(sc, ASC_GET_CARRP(irq_next_pa));\n\n\t\tfree_carrp->next_vpa = sc->carr_freelist->carr_pa;\n\t\tsc->carr_freelist = free_carrp;\n\t\tsc->carr_pending_cnt--;\n\n\n\t\ttarget_bit = ADW_TID_TO_TIDMASK(scsiq->target_id);\n\n\t\t/*\n\t\t * Clear request microcode control flag.\n\t\t */\n\t\tscsiq->cntl = 0;\n\n\t\t/*\n\t\t * Check Condition handling\n\t\t */\n\t\t/*\n\t\t * If the command that completed was a SCSI INQUIRY and\n\t\t * LUN 0 was sent the command, then process the INQUIRY\n\t\t * command information for the device.\n\t\t */\n\t\tif (scsiq->done_status == QD_NO_ERROR &&\n\t\t    \t scsiq->cdb[0] == INQUIRY &&\n\t\t    \t scsiq->target_lun == 0) {\n\t\t\tAdvInquiryHandling(sc, scsiq);\n\t\t}\n\n\t\t/*\n\t\t * Notify the driver of the completed request by passing\n\t\t * the ADW_SCSI_REQ_Q pointer to its callback function.\n\t\t */\n\t\t(*(ADW_ISR_CALLBACK)sc->isr_callback)(sc, scsiq);\n\t\t/*\n\t\t * Note: After the driver callback function is called, 'scsiq'\n\t\t * can no longer be referenced.\n\t\t *\n\t\t * Fall through and continue processing other completed\n\t\t * requests...\n\t\t */\n\t}\n\n\treturn ADW_TRUE;\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvInquiryHandling",
            "ADW_SOFTC\t*sc;",
            "ADW_SCSI_REQ_Q *scsiq;",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvInquiryHandling;\nADW_SOFTC\t*sc;\nADW_SCSI_REQ_Q *scsiq;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nint\nAdvISR(sc)\nADW_SOFTC\t*sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int8_t\tint_stat;\n\tu_int16_t\ttarget_bit;\n\tADW_CARRIER\t*free_carrp/*, *ccb_carr*/;\n\tu_int32_t\tirq_next_pa;\n\tADW_SCSI_REQ_Q\t*scsiq;\n\tADW_CCB\t\t*ccb;\n//\tint\t\ti;\n\n\n\t/* Reading the register clears the interrupt. */\n\tint_stat = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_INTR_STATUS_REG);\n\n\tif ((int_stat & (ADW_INTR_STATUS_INTRA | ADW_INTR_STATUS_INTRB |\n\t     ADW_INTR_STATUS_INTRC)) == 0) {\n\t\treturn ADW_FALSE;\n\t}\n\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_control->dmamap_xfer,\n\t\tBUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);\n\tbus_dmamap_unload(sc->sc_dmat, sc->sc_control->dmamap_xfer);\n\n/*\tccb_carr = sc->irq_sp;\n\tfor(i=0; i<2 && ccb_carr != ASC_CQ_STOPPER; i++) {\n\t\tbus_dmamap_sync(sc->sc_dmat, ccb_carr->dmamap_xfer, 0,\n\t\t\tccb_carr->dmamap_xfer->dm_mapsize,\n\t\t\tBUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);\n\t\tbus_dmamap_unload(sc->sc_dmat, ccb_carr->dmamap_xfer);\n\t\tccb_carr = adw_carrier_phys_kv(sc,\n\t\t\tASC_GET_CARRP(ccb_carr->next_vpa));\n\t}\n*/\n\t/*\n\t * Notify the driver of an asynchronous microcode condition by\n\t * calling the ADV_DVC_VAR.async_callback function. The function\n\t * is passed the microcode ASC_MC_INTRB_CODE byte value.\n\t */\n\tif (int_stat & ADW_INTR_STATUS_INTRB) {\n\t\tu_int8_t intrb_code;\n\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_INTRB_CODE, intrb_code);\n\t\tif (intrb_code == ADV_ASYNC_CARRIER_READY_FAILURE &&\n\t\t    sc->carr_pending_cnt != 0) {\n\t\t    ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_A);\n\t\t    if (sc->chip_type == ADV_CHIP_ASC3550) {\n\t\t    \tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_NOP);\n\t\t    }\n\t\t}\n\n\t\tif (sc->async_callback != 0) {\n\t\t    (*(ADW_ASYNC_CALLBACK)sc->async_callback)(sc, intrb_code);\n\t\t}\n\t}\n\n\t/*\n\t * Check if the IRQ stopper carrier contains a completed request.\n\t */\n\twhile (((irq_next_pa = sc->irq_sp->next_vpa) & ASC_RQ_DONE) != 0)\n\t{\n\t\t/*\n\t\t * Get a pointer to the newly completed ADW_SCSI_REQ_Q structure.\n\t\t * The RISC will have set 'areq_vpa' to a virtual address.\n\t\t *\n\t\t * The firmware will have copied the ASC_SCSI_REQ_Q.ccb_ptr\n\t\t * field to the carrier ADV_CARR_T.areq_vpa field. The conversion\n\t\t * below complements the conversion of ASC_SCSI_REQ_Q.scsiq_ptr'\n\t\t * in AdvExeScsiQueue().\n\t\t */\n\t\tccb = adw_ccb_phys_kv(sc, sc->irq_sp->areq_vpa);\n\t\tscsiq = &ccb->scsiq;\n\t\tscsiq->ccb_ptr = sc->irq_sp->areq_vpa;\n\n/*\t\tccb_carr = ccb->carr_list;\n\t\twhile(ccb_carr != ASC_CQ_STOPPER) {\n\t\t\tbus_dmamap_sync(sc->sc_dmat, ccb_carr->dmamap_xfer, 0,\n\t\t\t\tccb_carr->dmamap_xfer->dm_mapsize,\n\t\t\t\tBUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);\n\t\t\tbus_dmamap_unload(sc->sc_dmat, ccb_carr->dmamap_xfer);\n\t\t\tccb_carr = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(ccb_carr->next_vpa));\n\t\t}\n\n\t\tbus_dmamap_sync(sc->sc_dmat, sc->irq_sp->dmamap_xfer, 0,\n\t\t\tsc->irq_sp->dmamap_xfer->dm_mapsize,\n\t\t\tBUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);\n\t\tbus_dmamap_unload(sc->sc_dmat, sc->irq_sp->dmamap_xfer);\n*/\n\t\t/*\n\t\t * Advance the stopper pointer to the next carrier\n\t\t * ignoring the lower four bits. Free the previous\n\t\t * stopper carrier.\n\t\t */\n\t\tfree_carrp = sc->irq_sp;\n\t\tsc->irq_sp = adw_carrier_phys_kv(sc, ASC_GET_CARRP(irq_next_pa));\n\n\t\tfree_carrp->next_vpa = sc->carr_freelist->carr_pa;\n\t\tsc->carr_freelist = free_carrp;\n\t\tsc->carr_pending_cnt--;\n\n\n\t\ttarget_bit = ADW_TID_TO_TIDMASK(scsiq->target_id);\n\n\t\t/*\n\t\t * Clear request microcode control flag.\n\t\t */\n\t\tscsiq->cntl = 0;\n\n\t\t/*\n\t\t * Check Condition handling\n\t\t */\n\t\t/*\n\t\t * If the command that completed was a SCSI INQUIRY and\n\t\t * LUN 0 was sent the command, then process the INQUIRY\n\t\t * command information for the device.\n\t\t */\n\t\tif (scsiq->done_status == QD_NO_ERROR &&\n\t\t    \t scsiq->cdb[0] == INQUIRY &&\n\t\t    \t scsiq->target_lun == 0) {\n\t\t\tAdvInquiryHandling(sc, scsiq);\n\t\t}\n\n\t\t/*\n\t\t * Notify the driver of the completed request by passing\n\t\t * the ADW_SCSI_REQ_Q pointer to its callback function.\n\t\t */\n\t\t(*(ADW_ISR_CALLBACK)sc->isr_callback)(sc, scsiq);\n\t\t/*\n\t\t * Note: After the driver callback function is called, 'scsiq'\n\t\t * can no longer be referenced.\n\t\t *\n\t\t * Fall through and continue processing other completed\n\t\t * requests...\n\t\t */\n\t}\n\n\treturn ADW_TRUE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adw_scsi_cmd;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nint\nadw_intr(arg)\n\tvoid           *arg;\n{\n\tADW_SOFTC      *sc = arg;\n\tstruct scsi_xfer *xs;\n\n\n\tif(AdvISR(sc) != ADW_FALSE) {\n\t\t/*\n\t         * If there are queue entries in the software queue, try to\n\t         * run the first one.  We should be more or less guaranteed\n\t         * to succeed, since we just freed a CCB.\n\t         *\n\t         * NOTE: adw_scsi_cmd() relies on our calling it with\n\t         * the first entry in the queue.\n\t         */\n\t        if ((xs = sc->sc_queue.lh_first) != NULL)\n\t\t\t(void) adw_scsi_cmd(xs);\n\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "adw_build_sglist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "960-1003",
    "snippet": "static void\nadw_build_sglist(ccb, scsiqp, sg_block)\n\tADW_CCB        *ccb;\n\tADW_SCSI_REQ_Q *scsiqp;\n\tADW_SG_BLOCK   *sg_block;\n{\n\tu_long          sg_block_next_addr;\t/* block and its next */\n\tu_int32_t       sg_block_physical_addr;\n\tint             i;\t/* how many SG entries */\n\tbus_dma_segment_t *sg_list = &ccb->dmamap_xfer->dm_segs[0];\n\tint             sg_elem_cnt = ccb->dmamap_xfer->dm_nsegs;\n\n\n\tsg_block_next_addr = (u_long) sg_block;\t/* allow math operation */\n\tsg_block_physical_addr = ccb->hashkey +\n\t    offsetof(struct adw_ccb, sg_block[0]);\n\tscsiqp->sg_real_addr = sg_block_physical_addr;\n\n\t/*\n\t * If there are more than NO_OF_SG_PER_BLOCK dma segments (hw sg-list)\n\t * then split the request into multiple sg-list blocks.\n\t */\n\n\tdo {\n\t\tfor (i = 0; i < NO_OF_SG_PER_BLOCK; i++) {\n\t\t\tsg_block->sg_list[i].sg_addr = sg_list->ds_addr;\n\t\t\tsg_block->sg_list[i].sg_count = sg_list->ds_len;\n\n\t\t\tif (--sg_elem_cnt == 0) {\n\t\t\t\t/* last entry, get out */\n\t\t\t\tsg_block->sg_cnt = i + i;\n\t\t\t\tsg_block->sg_ptr = NULL; /* next link = NULL */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsg_list++;\n\t\t}\n\t\tsg_block_next_addr += sizeof(ADW_SG_BLOCK);\n\t\tsg_block_physical_addr += sizeof(ADW_SG_BLOCK);\n\n\t\tsg_block->sg_cnt = NO_OF_SG_PER_BLOCK;\n\t\tsg_block->sg_ptr = sg_block_physical_addr;\n\t\tsg_block = (ADW_SG_BLOCK *) sg_block_next_addr;\t/* virt. addr */\n\t} while (1);\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adw_build_sglist"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_build_sglist;\n\nstatic void\nadw_build_sglist(ccb, scsiqp, sg_block)\n\tADW_CCB        *ccb;\n\tADW_SCSI_REQ_Q *scsiqp;\n\tADW_SG_BLOCK   *sg_block;\n{\n\tu_long          sg_block_next_addr;\t/* block and its next */\n\tu_int32_t       sg_block_physical_addr;\n\tint             i;\t/* how many SG entries */\n\tbus_dma_segment_t *sg_list = &ccb->dmamap_xfer->dm_segs[0];\n\tint             sg_elem_cnt = ccb->dmamap_xfer->dm_nsegs;\n\n\n\tsg_block_next_addr = (u_long) sg_block;\t/* allow math operation */\n\tsg_block_physical_addr = ccb->hashkey +\n\t    offsetof(struct adw_ccb, sg_block[0]);\n\tscsiqp->sg_real_addr = sg_block_physical_addr;\n\n\t/*\n\t * If there are more than NO_OF_SG_PER_BLOCK dma segments (hw sg-list)\n\t * then split the request into multiple sg-list blocks.\n\t */\n\n\tdo {\n\t\tfor (i = 0; i < NO_OF_SG_PER_BLOCK; i++) {\n\t\t\tsg_block->sg_list[i].sg_addr = sg_list->ds_addr;\n\t\t\tsg_block->sg_list[i].sg_count = sg_list->ds_len;\n\n\t\t\tif (--sg_elem_cnt == 0) {\n\t\t\t\t/* last entry, get out */\n\t\t\t\tsg_block->sg_cnt = i + i;\n\t\t\t\tsg_block->sg_ptr = NULL; /* next link = NULL */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsg_list++;\n\t\t}\n\t\tsg_block_next_addr += sizeof(ADW_SG_BLOCK);\n\t\tsg_block_physical_addr += sizeof(ADW_SG_BLOCK);\n\n\t\tsg_block->sg_cnt = NO_OF_SG_PER_BLOCK;\n\t\tsg_block->sg_ptr = sg_block_physical_addr;\n\t\tsg_block = (ADW_SG_BLOCK *) sg_block_next_addr;\t/* virt. addr */\n\t} while (1);\n}"
  },
  {
    "function_name": "adw_build_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "855-954",
    "snippet": "static int\nadw_build_req(xs, ccb, flags)\n\tstruct scsi_xfer *xs;\n\tADW_CCB        *ccb;\n\tint\t\tflags;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tADW_SOFTC      *sc = sc_link->adapter_softc;\n\tbus_dma_tag_t   dmat = sc->sc_dmat;\n\tADW_SCSI_REQ_Q *scsiqp;\n\tint             error;\n\n\tscsiqp = &ccb->scsiq;\n\tbzero(scsiqp, sizeof(ADW_SCSI_REQ_Q));\n\n\t/*\n\t * Set the ADW_SCSI_REQ_Q 'ccb_ptr' to point to the\n\t * physical CCB structure.\n\t */\n\tscsiqp->ccb_ptr = ccb->hashkey;\n\n\t/*\n\t * Build the ADW_SCSI_REQ_Q request.\n\t */\n\n\t/*\n\t * Set CDB length and copy it to the request structure.\n\t */\n\tbcopy(xs->cmd, &scsiqp->cdb, scsiqp->cdb_len = xs->cmdlen);\n\n\tscsiqp->target_id = sc_link->target;\n\tscsiqp->target_lun = sc_link->lun;\n\n\tscsiqp->vsense_addr = &ccb->scsi_sense;\n\tscsiqp->sense_addr = sc->sc_dmamap_control->dm_segs[0].ds_addr +\n\t\t\tADW_CCB_OFF(ccb) + offsetof(struct adw_ccb, scsi_sense);\n/*\tscsiqp->sense_addr = ccb->hashkey +\n\t    offsetof(struct adw_ccb, scsi_sense);\n*/\tscsiqp->sense_len = sizeof(struct scsi_sense_data);\n\n\t/*\n\t * Build ADW_SCSI_REQ_Q for a scatter-gather buffer command.\n\t */\n\tif (xs->datalen) {\n\t\t/*\n                 * Map the DMA transfer.\n                 */\n#ifdef TFS\n\t\tif (xs->flags & SCSI_DATA_UIO) {\n\t\t\terror = bus_dmamap_load_uio(dmat,\n\t\t\t\tccb->dmamap_xfer, (struct uio *) xs->data,\n\t\t\t\t(flags & SCSI_NOSLEEP) ?\n\t\t\t\tBUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\t} else\n#endif\t\t/* TFS */\n\t\t{\n\t\t\terror = bus_dmamap_load(dmat,\n\t\t\t      ccb->dmamap_xfer, xs->data, xs->datalen, NULL,\n\t\t\t\t(flags & SCSI_NOSLEEP) ?\n\t\t\t\tBUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\t}\n\n\t\tif (error) {\n\t\t\tif (error == EFBIG) {\n\t\t\t\tprintf(\"%s: adw_scsi_cmd, more than %d dma\"\n\t\t\t\t       \" segments\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, ADW_MAX_SG_LIST);\n\t\t\t} else {\n\t\t\t\tprintf(\"%s: adw_scsi_cmd, error %d loading\"\n\t\t\t\t       \" dma map\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, error);\n\t\t\t}\n\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tadw_free_ccb(sc, ccb);\n\t\t\treturn (0);\n\t\t}\n\t\tbus_dmamap_sync(dmat, ccb->dmamap_xfer,\n\t\t\t\t(xs->flags & SCSI_DATA_IN) ?\n\t\t\t\tBUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);\n\n\t\t/*\n\t\t * Build scatter-gather list.\n\t\t */\n\t\tscsiqp->data_cnt = xs->datalen;\n\t\tscsiqp->vdata_addr = xs->data;\n\t\tscsiqp->data_addr = ccb->dmamap_xfer->dm_segs[0].ds_addr;\n\t\tbzero(ccb->sg_block, sizeof(ADW_SG_BLOCK) * ADW_NUM_SG_BLOCK);\n\t\tadw_build_sglist(ccb, scsiqp, ccb->sg_block);\n\t} else {\n\t\t/*\n                 * No data xfer, use non S/G values.\n                 */\n\t\tscsiqp->data_cnt = 0;\n\t\tscsiqp->vdata_addr = 0;\n\t\tscsiqp->data_addr = 0;\n\t}\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adw_free_ccb",
      "static int adw_scsi_cmd",
      "static int adw_build_req",
      "static void adw_build_sglist",
      "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
      "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
      "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
      "int             flags;",
      "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "adw_build_sglist",
          "args": [
            "ccb",
            "scsiqp",
            "ccb->sg_block"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "adw_build_sglist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
          "lines": "960-1003",
          "snippet": "static void\nadw_build_sglist(ccb, scsiqp, sg_block)\n\tADW_CCB        *ccb;\n\tADW_SCSI_REQ_Q *scsiqp;\n\tADW_SG_BLOCK   *sg_block;\n{\n\tu_long          sg_block_next_addr;\t/* block and its next */\n\tu_int32_t       sg_block_physical_addr;\n\tint             i;\t/* how many SG entries */\n\tbus_dma_segment_t *sg_list = &ccb->dmamap_xfer->dm_segs[0];\n\tint             sg_elem_cnt = ccb->dmamap_xfer->dm_nsegs;\n\n\n\tsg_block_next_addr = (u_long) sg_block;\t/* allow math operation */\n\tsg_block_physical_addr = ccb->hashkey +\n\t    offsetof(struct adw_ccb, sg_block[0]);\n\tscsiqp->sg_real_addr = sg_block_physical_addr;\n\n\t/*\n\t * If there are more than NO_OF_SG_PER_BLOCK dma segments (hw sg-list)\n\t * then split the request into multiple sg-list blocks.\n\t */\n\n\tdo {\n\t\tfor (i = 0; i < NO_OF_SG_PER_BLOCK; i++) {\n\t\t\tsg_block->sg_list[i].sg_addr = sg_list->ds_addr;\n\t\t\tsg_block->sg_list[i].sg_count = sg_list->ds_len;\n\n\t\t\tif (--sg_elem_cnt == 0) {\n\t\t\t\t/* last entry, get out */\n\t\t\t\tsg_block->sg_cnt = i + i;\n\t\t\t\tsg_block->sg_ptr = NULL; /* next link = NULL */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsg_list++;\n\t\t}\n\t\tsg_block_next_addr += sizeof(ADW_SG_BLOCK);\n\t\tsg_block_physical_addr += sizeof(ADW_SG_BLOCK);\n\n\t\tsg_block->sg_cnt = NO_OF_SG_PER_BLOCK;\n\t\tsg_block->sg_ptr = sg_block_physical_addr;\n\t\tsg_block = (ADW_SG_BLOCK *) sg_block_next_addr;\t/* virt. addr */\n\t} while (1);\n}",
          "includes": [
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adw_build_sglist"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_build_sglist;\n\nstatic void\nadw_build_sglist(ccb, scsiqp, sg_block)\n\tADW_CCB        *ccb;\n\tADW_SCSI_REQ_Q *scsiqp;\n\tADW_SG_BLOCK   *sg_block;\n{\n\tu_long          sg_block_next_addr;\t/* block and its next */\n\tu_int32_t       sg_block_physical_addr;\n\tint             i;\t/* how many SG entries */\n\tbus_dma_segment_t *sg_list = &ccb->dmamap_xfer->dm_segs[0];\n\tint             sg_elem_cnt = ccb->dmamap_xfer->dm_nsegs;\n\n\n\tsg_block_next_addr = (u_long) sg_block;\t/* allow math operation */\n\tsg_block_physical_addr = ccb->hashkey +\n\t    offsetof(struct adw_ccb, sg_block[0]);\n\tscsiqp->sg_real_addr = sg_block_physical_addr;\n\n\t/*\n\t * If there are more than NO_OF_SG_PER_BLOCK dma segments (hw sg-list)\n\t * then split the request into multiple sg-list blocks.\n\t */\n\n\tdo {\n\t\tfor (i = 0; i < NO_OF_SG_PER_BLOCK; i++) {\n\t\t\tsg_block->sg_list[i].sg_addr = sg_list->ds_addr;\n\t\t\tsg_block->sg_list[i].sg_count = sg_list->ds_len;\n\n\t\t\tif (--sg_elem_cnt == 0) {\n\t\t\t\t/* last entry, get out */\n\t\t\t\tsg_block->sg_cnt = i + i;\n\t\t\t\tsg_block->sg_ptr = NULL; /* next link = NULL */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsg_list++;\n\t\t}\n\t\tsg_block_next_addr += sizeof(ADW_SG_BLOCK);\n\t\tsg_block_physical_addr += sizeof(ADW_SG_BLOCK);\n\n\t\tsg_block->sg_cnt = NO_OF_SG_PER_BLOCK;\n\t\tsg_block->sg_ptr = sg_block_physical_addr;\n\t\tsg_block = (ADW_SG_BLOCK *) sg_block_next_addr;\t/* virt. addr */\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "ccb->sg_block",
            "sizeof(ADW_SG_BLOCK) * ADW_NUM_SG_BLOCK"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "dmat",
            "ccb->dmamap_xfer",
            "(xs->flags & SCSI_DATA_IN) ?\n\t\t\t\tBUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adw_free_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "adw_free_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
          "lines": "397-417",
          "snippet": "static void\nadw_free_ccb(sc, ccb)\n\tADW_SOFTC      *sc;\n\tADW_CCB        *ccb;\n{\n\tint             s;\n\n\ts = splbio();\n\n\tadw_reset_ccb(ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n         * If there were none, wake anybody waiting for one to come free,\n         * starting with queued entries.\n         */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adw_free_ccb",
            "static void adw_reset_ccb",
            "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
            "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
            "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
            "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_free_ccb;\nstatic void adw_reset_ccb;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic void\nadw_free_ccb(sc, ccb)\n\tADW_SOFTC      *sc;\n\tADW_CCB        *ccb;\n{\n\tint             s;\n\n\ts = splbio();\n\n\tadw_reset_ccb(ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n         * If there were none, wake anybody waiting for one to come free,\n         * starting with queued entries.\n         */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: adw_scsi_cmd, error %d loading\"\n\t\t\t\t       \" dma map\\n\"",
            "sc->sc_dev.dv_xname",
            "error"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "dmat",
            "ccb->dmamap_xfer",
            "xs->data",
            "xs->datalen",
            "NULL",
            "(flags & SCSI_NOSLEEP) ?\n\t\t\t\tBUS_DMA_NOWAIT : BUS_DMA_WAITOK"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load_uio",
          "args": [
            "dmat",
            "ccb->dmamap_xfer",
            "(struct uio *) xs->data",
            "(flags & SCSI_NOSLEEP) ?\n\t\t\t\tBUS_DMA_NOWAIT : BUS_DMA_WAITOK"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_CCB_OFF",
          "args": [
            "ccb"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "xs->cmd",
            "&scsiqp->cdb",
            "scsiqp->cdb_len = xs->cmdlen"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "scsiqp",
            "sizeof(ADW_SCSI_REQ_Q)"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_free_ccb;\nstatic int adw_scsi_cmd;\nstatic int adw_build_req;\nstatic void adw_build_sglist;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nint             flags;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic int\nadw_build_req(xs, ccb, flags)\n\tstruct scsi_xfer *xs;\n\tADW_CCB        *ccb;\n\tint\t\tflags;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tADW_SOFTC      *sc = sc_link->adapter_softc;\n\tbus_dma_tag_t   dmat = sc->sc_dmat;\n\tADW_SCSI_REQ_Q *scsiqp;\n\tint             error;\n\n\tscsiqp = &ccb->scsiq;\n\tbzero(scsiqp, sizeof(ADW_SCSI_REQ_Q));\n\n\t/*\n\t * Set the ADW_SCSI_REQ_Q 'ccb_ptr' to point to the\n\t * physical CCB structure.\n\t */\n\tscsiqp->ccb_ptr = ccb->hashkey;\n\n\t/*\n\t * Build the ADW_SCSI_REQ_Q request.\n\t */\n\n\t/*\n\t * Set CDB length and copy it to the request structure.\n\t */\n\tbcopy(xs->cmd, &scsiqp->cdb, scsiqp->cdb_len = xs->cmdlen);\n\n\tscsiqp->target_id = sc_link->target;\n\tscsiqp->target_lun = sc_link->lun;\n\n\tscsiqp->vsense_addr = &ccb->scsi_sense;\n\tscsiqp->sense_addr = sc->sc_dmamap_control->dm_segs[0].ds_addr +\n\t\t\tADW_CCB_OFF(ccb) + offsetof(struct adw_ccb, scsi_sense);\n/*\tscsiqp->sense_addr = ccb->hashkey +\n\t    offsetof(struct adw_ccb, scsi_sense);\n*/\tscsiqp->sense_len = sizeof(struct scsi_sense_data);\n\n\t/*\n\t * Build ADW_SCSI_REQ_Q for a scatter-gather buffer command.\n\t */\n\tif (xs->datalen) {\n\t\t/*\n                 * Map the DMA transfer.\n                 */\n#ifdef TFS\n\t\tif (xs->flags & SCSI_DATA_UIO) {\n\t\t\terror = bus_dmamap_load_uio(dmat,\n\t\t\t\tccb->dmamap_xfer, (struct uio *) xs->data,\n\t\t\t\t(flags & SCSI_NOSLEEP) ?\n\t\t\t\tBUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\t} else\n#endif\t\t/* TFS */\n\t\t{\n\t\t\terror = bus_dmamap_load(dmat,\n\t\t\t      ccb->dmamap_xfer, xs->data, xs->datalen, NULL,\n\t\t\t\t(flags & SCSI_NOSLEEP) ?\n\t\t\t\tBUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\t}\n\n\t\tif (error) {\n\t\t\tif (error == EFBIG) {\n\t\t\t\tprintf(\"%s: adw_scsi_cmd, more than %d dma\"\n\t\t\t\t       \" segments\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, ADW_MAX_SG_LIST);\n\t\t\t} else {\n\t\t\t\tprintf(\"%s: adw_scsi_cmd, error %d loading\"\n\t\t\t\t       \" dma map\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, error);\n\t\t\t}\n\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tadw_free_ccb(sc, ccb);\n\t\t\treturn (0);\n\t\t}\n\t\tbus_dmamap_sync(dmat, ccb->dmamap_xfer,\n\t\t\t\t(xs->flags & SCSI_DATA_IN) ?\n\t\t\t\tBUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);\n\n\t\t/*\n\t\t * Build scatter-gather list.\n\t\t */\n\t\tscsiqp->data_cnt = xs->datalen;\n\t\tscsiqp->vdata_addr = xs->data;\n\t\tscsiqp->data_addr = ccb->dmamap_xfer->dm_segs[0].ds_addr;\n\t\tbzero(ccb->sg_block, sizeof(ADW_SG_BLOCK) * ADW_NUM_SG_BLOCK);\n\t\tadw_build_sglist(ccb, scsiqp, ccb->sg_block);\n\t} else {\n\t\t/*\n                 * No data xfer, use non S/G values.\n                 */\n\t\tscsiqp->data_cnt = 0;\n\t\tscsiqp->vdata_addr = 0;\n\t\tscsiqp->data_addr = 0;\n\t}\n\n\treturn (1);\n}"
  },
  {
    "function_name": "adw_scsi_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "738-849",
    "snippet": "static int\nadw_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tADW_SOFTC      *sc = sc_link->adapter_softc;\n\tADW_CCB        *ccb;\n\tint             s, fromqueue = 1, dontqueue = 0, nowait = 0, retry = 0;\n\tint\t\tflags;\n\n\ts = splbio();\t\t/* protect the queue */\n\n\t/*\n         * If we're running the queue from adw_done(), we've been\n         * called with the first queue entry as our argument.\n         */\n\tif (xs == sc->sc_queue.lh_first) {\n\t\txs = adw_dequeue(sc);\n\t\tfromqueue = 1;\n\t\tnowait = 1;\n\t} else {\n\n\t\t/* Polled requests can't be queued for later. */\n\t\tdontqueue = xs->flags & SCSI_POLL;\n\n\t\t/*\n                 * If there are jobs in the queue, run them first.\n                 */\n\t\tif (sc->sc_queue.lh_first != NULL) {\n\t\t\t/*\n                         * If we can't queue, we have to abort, since\n                         * we have to preserve order.\n                         */\n\t\t\tif (dontqueue) {\n\t\t\t\tsplx(s);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\treturn (TRY_AGAIN_LATER);\n\t\t\t}\n\t\t\t/*\n                         * Swap with the first queue entry.\n                         */\n\t\t\tadw_enqueue(sc, xs, 0);\n\t\t\txs = adw_dequeue(sc);\n\t\t\tfromqueue = 1;\n\t\t}\n\t}\n\n\n\t/*\n         * get a ccb to use. If the transfer\n         * is from a buf (possibly from interrupt time)\n         * then we can't allow it to sleep\n         */\n\n\tflags = xs->flags;\n\tif (nowait)\n\t\tflags |= SCSI_NOSLEEP;\n\tif ((ccb = adw_get_ccb(sc, flags)) == NULL) {\n\t\t/*\n                 * If we can't queue, we lose.\n                 */\n\t\tif (dontqueue) {\n\t\t\tsplx(s);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\t\t/*\n                 * Stuff ourselves into the queue, in front\n                 * if we came off in the first place.\n                 */\n\t\tadw_enqueue(sc, xs, fromqueue);\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\tsplx(s);\t\t/* done playing with the queue */\n\n\tccb->xs = xs;\n\tccb->timeout = xs->timeout;\n\n\tif (adw_build_req(xs, ccb, flags)) {\nretryagain:\n\t\ts = splbio();\n\t\tretry = adw_queue_ccb(sc, ccb, retry);\n\t\tsplx(s);\n\n\t\tswitch(retry) {\n\t\tcase ADW_BUSY:\n\t\t\tgoto retryagain;\n\n\t\tcase ADW_ERROR:\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (COMPLETE);\n\t\t\t\n\t\t}\n\n\t\t/*\n\t         * Usually return SUCCESSFULLY QUEUED\n\t         */\n\t\tif ((xs->flags & SCSI_POLL) == 0)\n\t\t\treturn (SUCCESSFULLY_QUEUED);\n\n\t\t/*\n\t         * If we can't use interrupts, poll on completion\n\t         */\n\t\tif (adw_poll(sc, xs, ccb->timeout)) {\n\t\t\tadw_timeout(ccb);\n\t\t\tif (adw_poll(sc, xs, ccb->timeout))\n\t\t\t\tadw_timeout(ccb);\n\t\t}\n\t}\n\treturn (COMPLETE);\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adw_enqueue",
      "static struct scsi_xfer *adw_dequeue",
      "static ADW_CCB *adw_get_ccb",
      "static int adw_queue_ccb",
      "static int adw_scsi_cmd",
      "static int adw_build_req",
      "static int adw_poll",
      "static void adw_timeout",
      "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
      "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
      "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
      "int             flags;",
      "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "adw_timeout",
          "args": [
            "ccb"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "adw_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
          "lines": "1055-1095",
          "snippet": "static void\nadw_timeout(arg)\n\tvoid           *arg;\n{\n\tADW_CCB        *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tADW_SOFTC      *sc = sc_link->adapter_softc;\n\tint             s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\t/*\n         * If it has been through before, then a previous abort has failed,\n         * don't try abort again, reset the bus instead.\n         */\n\tif (ccb->flags & CCB_ABORTED) {\n\t/*\n\t * Abort Timed Out\n\t * Lets try resetting the bus!\n\t */\n\t\tprintf(\" AGAIN. Resetting SCSI Bus\\n\");\n\t\tccb->flags &= ~CCB_ABORTED;\n\t\t/* AdvResetSCSIBus() will call sbreset_callback() */\n\t\tAdvResetSCSIBus(sc);\n\t} else {\n\t/*\n\t * Abort the operation that has timed out\n\t */\n\t\tprintf(\"\\n\");\n\t\txs->error = XS_TIMEOUT;\n\t\tccb->flags |= CCB_ABORTING;\n\t\t/* ADW_ABORT_CCB() will implicitly call isr_callback() */\n\t\tADW_ABORT_CCB(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adw_timeout",
            "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
            "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
            "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
            "int             flags;",
            "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_timeout;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nint             flags;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic void\nadw_timeout(arg)\n\tvoid           *arg;\n{\n\tADW_CCB        *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tADW_SOFTC      *sc = sc_link->adapter_softc;\n\tint             s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\t/*\n         * If it has been through before, then a previous abort has failed,\n         * don't try abort again, reset the bus instead.\n         */\n\tif (ccb->flags & CCB_ABORTED) {\n\t/*\n\t * Abort Timed Out\n\t * Lets try resetting the bus!\n\t */\n\t\tprintf(\" AGAIN. Resetting SCSI Bus\\n\");\n\t\tccb->flags &= ~CCB_ABORTED;\n\t\t/* AdvResetSCSIBus() will call sbreset_callback() */\n\t\tAdvResetSCSIBus(sc);\n\t} else {\n\t/*\n\t * Abort the operation that has timed out\n\t */\n\t\tprintf(\"\\n\");\n\t\txs->error = XS_TIMEOUT;\n\t\tccb->flags |= CCB_ABORTING;\n\t\t/* ADW_ABORT_CCB() will implicitly call isr_callback() */\n\t\tADW_ABORT_CCB(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "adw_poll",
          "args": [
            "sc",
            "xs",
            "ccb->timeout"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "adw_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
          "lines": "1036-1052",
          "snippet": "static int\nadw_poll(sc, xs, count)\n\tADW_SOFTC      *sc;\n\tstruct scsi_xfer *xs;\n\tint             count;\n{\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\tadw_intr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn (0);\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int adw_poll",
            "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
            "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
            "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
            "int             flags;",
            "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adw_poll;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nint             flags;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic int\nadw_poll(sc, xs, count)\n\tADW_SOFTC      *sc;\n\tstruct scsi_xfer *xs;\n\tint             count;\n{\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\tadw_intr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn (0);\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adw_queue_ccb",
          "args": [
            "sc",
            "ccb",
            "retry"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "adw_queue_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
          "lines": "525-560",
          "snippet": "static int\nadw_queue_ccb(sc, ccb, retry)\n\tADW_SOFTC      *sc;\n\tADW_CCB        *ccb;\n\tint\t\tretry;\n{\n\tint\t\terrcode;\n\n\tif(!retry)\n\t\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\n\t\terrcode = AdvExeScsiQueue(sc, &ccb->scsiq);\n\t\tswitch(errcode) {\n\t\tcase ADW_SUCCESS:\n\t\t\tbreak;\n\n\t\tcase ADW_BUSY:\n\t\t\tprintf(\"ADW_BUSY\\n\");\n\t\t\treturn(ADW_BUSY);\n\n\t\tcase ADW_ERROR:\n\t\t\tprintf(\"ADW_ERROR\\n\");\n\t\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n\t\t\treturn(ADW_ERROR);\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(adw_timeout, ccb, (ccb->timeout * hz) / 1000);\n\t}\n\n\treturn(errcode);\n}",
          "includes": [
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int adw_queue_ccb",
            "static void adw_timeout",
            "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
            "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
            "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
            "int             flags;",
            "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adw_queue_ccb;\nstatic void adw_timeout;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nint             flags;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic int\nadw_queue_ccb(sc, ccb, retry)\n\tADW_SOFTC      *sc;\n\tADW_CCB        *ccb;\n\tint\t\tretry;\n{\n\tint\t\terrcode;\n\n\tif(!retry)\n\t\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\n\t\terrcode = AdvExeScsiQueue(sc, &ccb->scsiq);\n\t\tswitch(errcode) {\n\t\tcase ADW_SUCCESS:\n\t\t\tbreak;\n\n\t\tcase ADW_BUSY:\n\t\t\tprintf(\"ADW_BUSY\\n\");\n\t\t\treturn(ADW_BUSY);\n\n\t\tcase ADW_ERROR:\n\t\t\tprintf(\"ADW_ERROR\\n\");\n\t\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n\t\t\treturn(ADW_ERROR);\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(adw_timeout, ccb, (ccb->timeout * hz) / 1000);\n\t}\n\n\treturn(errcode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adw_build_req",
          "args": [
            "xs",
            "ccb",
            "flags"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "adw_build_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
          "lines": "855-954",
          "snippet": "static int\nadw_build_req(xs, ccb, flags)\n\tstruct scsi_xfer *xs;\n\tADW_CCB        *ccb;\n\tint\t\tflags;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tADW_SOFTC      *sc = sc_link->adapter_softc;\n\tbus_dma_tag_t   dmat = sc->sc_dmat;\n\tADW_SCSI_REQ_Q *scsiqp;\n\tint             error;\n\n\tscsiqp = &ccb->scsiq;\n\tbzero(scsiqp, sizeof(ADW_SCSI_REQ_Q));\n\n\t/*\n\t * Set the ADW_SCSI_REQ_Q 'ccb_ptr' to point to the\n\t * physical CCB structure.\n\t */\n\tscsiqp->ccb_ptr = ccb->hashkey;\n\n\t/*\n\t * Build the ADW_SCSI_REQ_Q request.\n\t */\n\n\t/*\n\t * Set CDB length and copy it to the request structure.\n\t */\n\tbcopy(xs->cmd, &scsiqp->cdb, scsiqp->cdb_len = xs->cmdlen);\n\n\tscsiqp->target_id = sc_link->target;\n\tscsiqp->target_lun = sc_link->lun;\n\n\tscsiqp->vsense_addr = &ccb->scsi_sense;\n\tscsiqp->sense_addr = sc->sc_dmamap_control->dm_segs[0].ds_addr +\n\t\t\tADW_CCB_OFF(ccb) + offsetof(struct adw_ccb, scsi_sense);\n/*\tscsiqp->sense_addr = ccb->hashkey +\n\t    offsetof(struct adw_ccb, scsi_sense);\n*/\tscsiqp->sense_len = sizeof(struct scsi_sense_data);\n\n\t/*\n\t * Build ADW_SCSI_REQ_Q for a scatter-gather buffer command.\n\t */\n\tif (xs->datalen) {\n\t\t/*\n                 * Map the DMA transfer.\n                 */\n#ifdef TFS\n\t\tif (xs->flags & SCSI_DATA_UIO) {\n\t\t\terror = bus_dmamap_load_uio(dmat,\n\t\t\t\tccb->dmamap_xfer, (struct uio *) xs->data,\n\t\t\t\t(flags & SCSI_NOSLEEP) ?\n\t\t\t\tBUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\t} else\n#endif\t\t/* TFS */\n\t\t{\n\t\t\terror = bus_dmamap_load(dmat,\n\t\t\t      ccb->dmamap_xfer, xs->data, xs->datalen, NULL,\n\t\t\t\t(flags & SCSI_NOSLEEP) ?\n\t\t\t\tBUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\t}\n\n\t\tif (error) {\n\t\t\tif (error == EFBIG) {\n\t\t\t\tprintf(\"%s: adw_scsi_cmd, more than %d dma\"\n\t\t\t\t       \" segments\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, ADW_MAX_SG_LIST);\n\t\t\t} else {\n\t\t\t\tprintf(\"%s: adw_scsi_cmd, error %d loading\"\n\t\t\t\t       \" dma map\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, error);\n\t\t\t}\n\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tadw_free_ccb(sc, ccb);\n\t\t\treturn (0);\n\t\t}\n\t\tbus_dmamap_sync(dmat, ccb->dmamap_xfer,\n\t\t\t\t(xs->flags & SCSI_DATA_IN) ?\n\t\t\t\tBUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);\n\n\t\t/*\n\t\t * Build scatter-gather list.\n\t\t */\n\t\tscsiqp->data_cnt = xs->datalen;\n\t\tscsiqp->vdata_addr = xs->data;\n\t\tscsiqp->data_addr = ccb->dmamap_xfer->dm_segs[0].ds_addr;\n\t\tbzero(ccb->sg_block, sizeof(ADW_SG_BLOCK) * ADW_NUM_SG_BLOCK);\n\t\tadw_build_sglist(ccb, scsiqp, ccb->sg_block);\n\t} else {\n\t\t/*\n                 * No data xfer, use non S/G values.\n                 */\n\t\tscsiqp->data_cnt = 0;\n\t\tscsiqp->vdata_addr = 0;\n\t\tscsiqp->data_addr = 0;\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adw_free_ccb",
            "static int adw_scsi_cmd",
            "static int adw_build_req",
            "static void adw_build_sglist",
            "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
            "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
            "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
            "int             flags;",
            "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_free_ccb;\nstatic int adw_scsi_cmd;\nstatic int adw_build_req;\nstatic void adw_build_sglist;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nint             flags;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic int\nadw_build_req(xs, ccb, flags)\n\tstruct scsi_xfer *xs;\n\tADW_CCB        *ccb;\n\tint\t\tflags;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tADW_SOFTC      *sc = sc_link->adapter_softc;\n\tbus_dma_tag_t   dmat = sc->sc_dmat;\n\tADW_SCSI_REQ_Q *scsiqp;\n\tint             error;\n\n\tscsiqp = &ccb->scsiq;\n\tbzero(scsiqp, sizeof(ADW_SCSI_REQ_Q));\n\n\t/*\n\t * Set the ADW_SCSI_REQ_Q 'ccb_ptr' to point to the\n\t * physical CCB structure.\n\t */\n\tscsiqp->ccb_ptr = ccb->hashkey;\n\n\t/*\n\t * Build the ADW_SCSI_REQ_Q request.\n\t */\n\n\t/*\n\t * Set CDB length and copy it to the request structure.\n\t */\n\tbcopy(xs->cmd, &scsiqp->cdb, scsiqp->cdb_len = xs->cmdlen);\n\n\tscsiqp->target_id = sc_link->target;\n\tscsiqp->target_lun = sc_link->lun;\n\n\tscsiqp->vsense_addr = &ccb->scsi_sense;\n\tscsiqp->sense_addr = sc->sc_dmamap_control->dm_segs[0].ds_addr +\n\t\t\tADW_CCB_OFF(ccb) + offsetof(struct adw_ccb, scsi_sense);\n/*\tscsiqp->sense_addr = ccb->hashkey +\n\t    offsetof(struct adw_ccb, scsi_sense);\n*/\tscsiqp->sense_len = sizeof(struct scsi_sense_data);\n\n\t/*\n\t * Build ADW_SCSI_REQ_Q for a scatter-gather buffer command.\n\t */\n\tif (xs->datalen) {\n\t\t/*\n                 * Map the DMA transfer.\n                 */\n#ifdef TFS\n\t\tif (xs->flags & SCSI_DATA_UIO) {\n\t\t\terror = bus_dmamap_load_uio(dmat,\n\t\t\t\tccb->dmamap_xfer, (struct uio *) xs->data,\n\t\t\t\t(flags & SCSI_NOSLEEP) ?\n\t\t\t\tBUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\t} else\n#endif\t\t/* TFS */\n\t\t{\n\t\t\terror = bus_dmamap_load(dmat,\n\t\t\t      ccb->dmamap_xfer, xs->data, xs->datalen, NULL,\n\t\t\t\t(flags & SCSI_NOSLEEP) ?\n\t\t\t\tBUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\t}\n\n\t\tif (error) {\n\t\t\tif (error == EFBIG) {\n\t\t\t\tprintf(\"%s: adw_scsi_cmd, more than %d dma\"\n\t\t\t\t       \" segments\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, ADW_MAX_SG_LIST);\n\t\t\t} else {\n\t\t\t\tprintf(\"%s: adw_scsi_cmd, error %d loading\"\n\t\t\t\t       \" dma map\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, error);\n\t\t\t}\n\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tadw_free_ccb(sc, ccb);\n\t\t\treturn (0);\n\t\t}\n\t\tbus_dmamap_sync(dmat, ccb->dmamap_xfer,\n\t\t\t\t(xs->flags & SCSI_DATA_IN) ?\n\t\t\t\tBUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);\n\n\t\t/*\n\t\t * Build scatter-gather list.\n\t\t */\n\t\tscsiqp->data_cnt = xs->datalen;\n\t\tscsiqp->vdata_addr = xs->data;\n\t\tscsiqp->data_addr = ccb->dmamap_xfer->dm_segs[0].ds_addr;\n\t\tbzero(ccb->sg_block, sizeof(ADW_SG_BLOCK) * ADW_NUM_SG_BLOCK);\n\t\tadw_build_sglist(ccb, scsiqp, ccb->sg_block);\n\t} else {\n\t\t/*\n                 * No data xfer, use non S/G values.\n                 */\n\t\tscsiqp->data_cnt = 0;\n\t\tscsiqp->vdata_addr = 0;\n\t\tscsiqp->data_addr = 0;\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adw_enqueue",
          "args": [
            "sc",
            "xs",
            "fromqueue"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "adw_enqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
          "lines": "128-143",
          "snippet": "static void\nadw_enqueue(sc, xs, infront)\n\tADW_SOFTC      *sc;\n\tstruct scsi_xfer *xs;\n\tint             infront;\n{\n\n\tif (infront || sc->sc_queue.lh_first == NULL) {\n\t\tif (sc->sc_queue.lh_first == NULL)\n\t\t\tsc->sc_queuelast = xs;\n\t\tLIST_INSERT_HEAD(&sc->sc_queue, xs, free_list);\n\t\treturn;\n\t}\n\tLIST_INSERT_AFTER(sc->sc_queuelast, xs, free_list);\n\tsc->sc_queuelast = xs;\n}",
          "includes": [
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adw_enqueue",
            "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
            "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
            "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
            "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_enqueue;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic void\nadw_enqueue(sc, xs, infront)\n\tADW_SOFTC      *sc;\n\tstruct scsi_xfer *xs;\n\tint             infront;\n{\n\n\tif (infront || sc->sc_queue.lh_first == NULL) {\n\t\tif (sc->sc_queue.lh_first == NULL)\n\t\t\tsc->sc_queuelast = xs;\n\t\tLIST_INSERT_HEAD(&sc->sc_queue, xs, free_list);\n\t\treturn;\n\t}\n\tLIST_INSERT_AFTER(sc->sc_queuelast, xs, free_list);\n\tsc->sc_queuelast = xs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adw_get_ccb",
          "args": [
            "sc",
            "flags"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adw_dequeue",
          "args": [
            "sc"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adw_dequeue",
          "args": [
            "sc"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_enqueue;\nstatic struct scsi_xfer *adw_dequeue;\nstatic ADW_CCB *adw_get_ccb;\nstatic int adw_queue_ccb;\nstatic int adw_scsi_cmd;\nstatic int adw_build_req;\nstatic int adw_poll;\nstatic void adw_timeout;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nint             flags;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic int\nadw_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tADW_SOFTC      *sc = sc_link->adapter_softc;\n\tADW_CCB        *ccb;\n\tint             s, fromqueue = 1, dontqueue = 0, nowait = 0, retry = 0;\n\tint\t\tflags;\n\n\ts = splbio();\t\t/* protect the queue */\n\n\t/*\n         * If we're running the queue from adw_done(), we've been\n         * called with the first queue entry as our argument.\n         */\n\tif (xs == sc->sc_queue.lh_first) {\n\t\txs = adw_dequeue(sc);\n\t\tfromqueue = 1;\n\t\tnowait = 1;\n\t} else {\n\n\t\t/* Polled requests can't be queued for later. */\n\t\tdontqueue = xs->flags & SCSI_POLL;\n\n\t\t/*\n                 * If there are jobs in the queue, run them first.\n                 */\n\t\tif (sc->sc_queue.lh_first != NULL) {\n\t\t\t/*\n                         * If we can't queue, we have to abort, since\n                         * we have to preserve order.\n                         */\n\t\t\tif (dontqueue) {\n\t\t\t\tsplx(s);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\treturn (TRY_AGAIN_LATER);\n\t\t\t}\n\t\t\t/*\n                         * Swap with the first queue entry.\n                         */\n\t\t\tadw_enqueue(sc, xs, 0);\n\t\t\txs = adw_dequeue(sc);\n\t\t\tfromqueue = 1;\n\t\t}\n\t}\n\n\n\t/*\n         * get a ccb to use. If the transfer\n         * is from a buf (possibly from interrupt time)\n         * then we can't allow it to sleep\n         */\n\n\tflags = xs->flags;\n\tif (nowait)\n\t\tflags |= SCSI_NOSLEEP;\n\tif ((ccb = adw_get_ccb(sc, flags)) == NULL) {\n\t\t/*\n                 * If we can't queue, we lose.\n                 */\n\t\tif (dontqueue) {\n\t\t\tsplx(s);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\t\t/*\n                 * Stuff ourselves into the queue, in front\n                 * if we came off in the first place.\n                 */\n\t\tadw_enqueue(sc, xs, fromqueue);\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\tsplx(s);\t\t/* done playing with the queue */\n\n\tccb->xs = xs;\n\tccb->timeout = xs->timeout;\n\n\tif (adw_build_req(xs, ccb, flags)) {\nretryagain:\n\t\ts = splbio();\n\t\tretry = adw_queue_ccb(sc, ccb, retry);\n\t\tsplx(s);\n\n\t\tswitch(retry) {\n\t\tcase ADW_BUSY:\n\t\t\tgoto retryagain;\n\n\t\tcase ADW_ERROR:\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (COMPLETE);\n\t\t\t\n\t\t}\n\n\t\t/*\n\t         * Usually return SUCCESSFULLY QUEUED\n\t         */\n\t\tif ((xs->flags & SCSI_POLL) == 0)\n\t\t\treturn (SUCCESSFULLY_QUEUED);\n\n\t\t/*\n\t         * If we can't use interrupts, poll on completion\n\t         */\n\t\tif (adw_poll(sc, xs, ccb->timeout)) {\n\t\t\tadw_timeout(ccb);\n\t\t\tif (adw_poll(sc, xs, ccb->timeout))\n\t\t\t\tadw_timeout(ccb);\n\t\t}\n\t}\n\treturn (COMPLETE);\n}"
  },
  {
    "function_name": "adwminphys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "723-731",
    "snippet": "static void\nadwminphys(bp)\n\tstruct buf     *bp;\n{\n\n\tif (bp->b_bcount > ((ADW_MAX_SG_LIST - 1) * PAGE_SIZE))\n\t\tbp->b_bcount = ((ADW_MAX_SG_LIST - 1) * PAGE_SIZE);\n\tminphys(bp);\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adwminphys"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "minphys",
          "args": [
            "bp"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "adwminphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
          "lines": "723-731",
          "snippet": "static void\nadwminphys(bp)\n\tstruct buf     *bp;\n{\n\n\tif (bp->b_bcount > ((ADW_MAX_SG_LIST - 1) * PAGE_SIZE))\n\t\tbp->b_bcount = ((ADW_MAX_SG_LIST - 1) * PAGE_SIZE);\n\tminphys(bp);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adwminphys;\n\nstatic void\nadwminphys(bp)\n\tstruct buf     *bp;\n{\n\n\tif (bp->b_bcount > ((ADW_MAX_SG_LIST - 1) * PAGE_SIZE))\n\t\tbp->b_bcount = ((ADW_MAX_SG_LIST - 1) * PAGE_SIZE);\n\tminphys(bp);\n}"
  },
  {
    "function_name": "adw_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "609-720",
    "snippet": "void\nadw_attach(sc)\n\tADW_SOFTC      *sc;\n{\n\tint             i, error;\n\n\n\tTAILQ_INIT(&sc->sc_free_ccb);\n\tTAILQ_INIT(&sc->sc_waiting_ccb);\n\tLIST_INIT(&sc->sc_queue);\n\n\n\t/*\n         * Allocate the Control Blocks.\n         */\n\terror = adw_alloc_controls(sc);\n\tif (error)\n\t\treturn; /* (error) */ ;\n\n\tbzero(sc->sc_control, sizeof(struct adw_control));\n\n\t/*\n\t * Create and initialize the Control Blocks.\n\t */\n\ti = adw_create_ccbs(sc, sc->sc_control->ccbs, ADW_MAX_CCB);\n\tif (i == 0) {\n\t\tprintf(\"%s: unable to create Control Blocks\\n\",\n\t\t       sc->sc_dev.dv_xname);\n\t\treturn; /* (ENOMEM) */ ;\n\t} else if (i != ADW_MAX_CCB) {\n\t\tprintf(\"%s: WARNING: only %d of %d Control Blocks\"\n\t\t       \" created\\n\",\n\t\t       sc->sc_dev.dv_xname, i, ADW_MAX_CCB);\n\t}\n\n\t/*\n\t * Create and initialize the Carriers.\n\t */\n\terror = adw_alloc_carriers(sc);\n\tif (error)\n\t\treturn; /* (error) */ ;\n\n\tbzero(sc->sc_control->carriers, ADW_CARRIER_SIZE * ADW_MAX_CARRIER);\n\n\ti = adw_create_carriers(sc);\n\tif (i == 0) {\n\t\tprintf(\"%s: unable to create Carriers\\n\",\n\t\t       sc->sc_dev.dv_xname);\n\t\treturn; /* (ENOMEM) */ ;\n\t} else if (i != ADW_MAX_CARRIER) {\n\t\tprintf(\"%s: WARNING: only %d of %d Carriers created\\n\",\n\t\t       sc->sc_dev.dv_xname, i, ADW_MAX_CARRIER);\n\t}\n\n\n\t/*\n\t * Initialize the ASC3550.\n\t */\n\terror = (sc->chip_type == ADV_CHIP_ASC3550)?\n\t\t\tAdvInitAsc3550Driver(sc) :\n\t\t\tAdvInitAsc38C0800Driver(sc);\n\tswitch (error) {\n\tcase ASC_IERR_MCODE_CHKSUM:\n\t\tpanic(\"%s: Microcode checksum error\",\n\t\t      sc->sc_dev.dv_xname);\n\t\tbreak;\n\n\tcase ASC_IERR_ILLEGAL_CONNECTION:\n\t\tpanic(\"%s: All three connectors are in use\",\n\t\t      sc->sc_dev.dv_xname);\n\t\tbreak;\n\n\tcase ASC_IERR_REVERSED_CABLE:\n\t\tpanic(\"%s: Cable is reversed\",\n\t\t      sc->sc_dev.dv_xname);\n\t\tbreak;\n\n\tcase ASC_IERR_SINGLE_END_DEVICE:\n\t\tpanic(\"%s: single-ended device is attached to\"\n\t\t      \" one of the connectors\",\n\t\t      sc->sc_dev.dv_xname);\n\t\tbreak;\n\n\tcase ASC_IERR_NO_CARRIER:\n\t\tpanic(\"%s: no carrier\",\n\t\t      sc->sc_dev.dv_xname);\n\t\tbreak;\n\n\tcase ASC_WARN_BUSRESET_ERROR:\n\t\tprintf(\"%s: WARNING: Bus Reset Error\\n\",\n\t\t      sc->sc_dev.dv_xname);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Fill in the adapter.\n\t */\n\tsc->sc_adapter.scsi_cmd = adw_scsi_cmd;\n\tsc->sc_adapter.scsi_minphys = adwminphys;\n\n\t/*\n         * fill in the prototype scsi_link.\n         */\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->chip_scsi_id;\n\tsc->sc_link.adapter = &sc->sc_adapter;\n\tsc->sc_link.device = &adw_dev;\n\tsc->sc_link.openings = 4;\n\tsc->sc_link.adapter_buswidth = ADW_MAX_TID+1;\n\n\tconfig_found(&sc->sc_dev, &sc->sc_link, scsiprint);\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int adw_alloc_controls",
      "static int adw_alloc_carriers",
      "static int adw_create_carriers",
      "static int adw_create_ccbs",
      "static int adw_scsi_cmd",
      "static void adwminphys",
      "struct scsi_device adw_dev =\n{\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};",
      "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
      "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
      "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
      "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "&sc->sc_dev",
            "&sc->sc_link",
            "scsiprint"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: WARNING: Bus Reset Error\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: no carrier\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: single-ended device is attached to\"\n\t\t      \" one of the connectors\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: Cable is reversed\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: All three connectors are in use\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: Microcode checksum error\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdvInitAsc38C0800Driver",
          "args": [
            "sc"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "AdvInitAsc38C0800Driver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "723-1250",
          "snippet": "int\nAdvInitAsc38C0800Driver(sc)\nADW_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t\twarn_code;\n\tu_int32_t\tsum;\n\tint\t  \tbegin_addr;\n\tint\t   \tend_addr;\n\tu_int16_t\tcode_sum;\n\tint\t   \tword;\n\tint\t   \ti, j;\n\tint\t   \tadv_asc38C0800_expanded_size;\n\tu_int16_t\tscsi_cfg1;\n\tu_int8_t\tbyte;\n\tu_int8_t\ttid;\n\tu_int16_t\tbios_mem[ASC_MC_BIOSLEN/2];\t/* BIOS RISC Memory\n\t\t\t\t\t\t\t\t0x40-0x8F. */\n\tu_int16_t\twdtr_able, sdtr_able, tagqng_able;\n\tu_int8_t\tmax_cmd[ADW_MAX_TID + 1];\n\n\n\twarn_code = 0;\n\n\t/*\n\t * Save the RISC memory BIOS region before writing the microcode.\n\t * The BIOS may already be loaded and using its RISC LRAM region\n\t * so its region must be saved and restored.\n\t *\n\t * Note: This code makes the assumption, which is currently true,\n\t * that a chip reset does not clear RISC LRAM.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t    ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i), bios_mem[i]);\n\t}\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * RAM BIST (RAM Built-In Self Test)\n\t *\n\t * Address : I/O base + offset 0x38h register (byte).\n\t * Function: Bit 7-6(RW) : RAM mode\n\t *\t\t\t    Normal Mode   : 0x00\n\t *\t\t\t    Pre-test Mode : 0x40\n\t *\t\t\t    RAM Test Mode : 0x80\n\t *\t     Bit 5\t : unused\n\t *\t     Bit 4(RO)   : Done bit\n\t *\t     Bit 3-0(RO) : Status\n\t *\t\t\t    Host Error    : 0x08\n\t *\t\t\t    Int_RAM Error : 0x04\n\t *\t\t\t    RISC Error    : 0x02\n\t *\t\t\t    SCSI Error    : 0x01\n\t *\t\t\t    No Error\t  : 0x00\n\t *\n\t * Note: RAM BIST code should be put right here, before loading the\n\t * microcode and after saving the RISC memory BIOS region.\n\t */\n\n\t/*\n\t * LRAM Pre-test\n\t *\n\t * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.\n\t * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return\n\t * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset\n\t * to NORMAL_MODE, return an error too.\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, PRE_TEST_MODE);\n\t\tAdvSleepMilliSecond(10);  /* Wait for 10ms before reading back. */\n\t\tbyte = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST);\n\t\tif ((byte & RAM_TEST_DONE) == 0 || (byte & 0x0F) !=\n\t\t\t\tPRE_TEST_VALUE) {\n\t\t\treturn ASC_IERR_BIST_PRE_TEST;\n\t\t}\n\n\t\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, NORMAL_MODE);\n\t\tAdvSleepMilliSecond(10);  /* Wait for 10ms before reading back. */\n\t\tif (ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST)\n\t\t    != NORMAL_VALUE) {\n\t\t\treturn ASC_IERR_BIST_PRE_TEST;\n\t\t}\n\t}\n\n\t/*\n\t * LRAM Test - It takes about 1.5 ms to run through the test.\n\t *\n\t * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.\n\t * If Done bit not set or Status not 0, save register byte, set the\n\t * err_code, and return an error.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, RAM_TEST_MODE);\n\tAdvSleepMilliSecond(10);  /* Wait for 10ms before checking status. */\n\n\tbyte = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST);\n\tif ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {\n\t\t/* Get here if Done bit not set or Status not 0. */\n\t\treturn ASC_IERR_BIST_RAM_TEST;\n\t}\n\n\t/* We need to reset back to normal mode after LRAM test passes. */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, NORMAL_MODE);\n\n\t/*\n\t * Load the Microcode\n\t *\n\t * Write the microcode image to RISC memory starting at address 0.\n\t *\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\t/* Assume the following compressed format of the microcode buffer:\n\t *\n\t *  254 word (508 byte) table indexed by byte code followed\n\t *  by the following byte codes:\n\t *\n\t *    1-Byte Code:\n\t *\t00: Emit word 0 in table.\n\t *\t01: Emit word 1 in table.\n\t *\t.\n\t *\tFD: Emit word 253 in table.\n\t *\n\t *    Multi-Byte Code:\n\t *\tFE WW WW: (3 byte code) Word to emit is the next word WW WW.\n\t *\tFF BB WW WW: (4 byte code) Emit BB count times next word WW WW.\n\t */\n\tword = 0;\n\tfor (i = 253 * 2; i < adv_asc38C0800_mcode_size; i++) {\n\t\tif (adv_asc38C0800_mcode[i] == 0xff) {\n\t\t\tfor (j = 0; j < adv_asc38C0800_mcode[i + 1]; j++) {\n\t\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,\n\t\t\t\t    (((u_int16_t)\n\t\t\t\t    adv_asc38C0800_mcode[i + 3] << 8) |\n\t\t\t\t    adv_asc38C0800_mcode[i + 2]));\n\t\t\t\tword++;\n\t\t\t}\n\t\t\ti += 3;\n\t\t} else if (adv_asc38C0800_mcode[i] == 0xfe) {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)\n\t\t\t    adv_asc38C0800_mcode[i + 2] << 8) |\n\t\t\t    adv_asc38C0800_mcode[i + 1]));\n\t\t\ti += 2;\n\t\t\tword++;\n\t\t} else {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)\n\t\t\t  adv_asc38C0800_mcode[(adv_asc38C0800_mcode[i] * 2) + 1] << 8) |\n\t\t\t  adv_asc38C0800_mcode[adv_asc38C0800_mcode[i] * 2]));\n\t\t\tword++;\n\t\t}\n\t}\n\n\t/*\n\t * Set 'word' for later use to clear the rest of memory and save\n\t * the expanded mcode size.\n\t */\n\tword *= 2;\n\tadv_asc38C0800_expanded_size = word;\n\n\t/*\n\t * Clear the rest of ASC-38C0800 Internal RAM (16KB).\n\t */\n\tfor (; word < ADV_38C0800_MEMSIZE; word += 2) {\n\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, 0);\n\t}\n\n\t/*\n\t * Verify the microcode checksum.\n\t */\n\tsum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\tfor (word = 0; word < adv_asc38C0800_expanded_size; word += 2) {\n\t\tsum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\n\tif (sum != adv_asc38C0800_mcode_chksum) {\n\t    return ASC_IERR_MCODE_CHKSUM;\n\t}\n\n\t/*\n\t * Restore the RISC memory BIOS region.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\tbios_mem[i]);\n\t}\n\n\t/*\n\t * Calculate and write the microcode code checksum to the microcode\n\t * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_END_ADDR, end_addr);\n\tcode_sum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, begin_addr);\n\tfor (word = begin_addr; word < end_addr; word += 2) {\n\t\tcode_sum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CODE_CHK_SUM, code_sum);\n\n\t/*\n\t * Read microcode version and date.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_DATE,\n\t\t\tsc->cfg.mcode_date);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_NUM,\n\t\t\tsc->cfg.mcode_version);\n\n\t/*\n\t * Set the chip type to indicate the ASC38C0800.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C0800);\n\n\t/*\n\t * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.\n\t * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current\n\t * cable detection and then we are able to read C_DET[3:0].\n\t *\n\t * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1\n\t * Microcode Default Value' section below.\n\t */\n\tscsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1,\n\t\t\tscsi_cfg1 | ADW_DIS_TERM_DRV);\n\n\t/*\n\t * If the PCI Configuration Command Register \"Parity Error Response\n\t * Control\" Bit was clear (0), then set the microcode variable\n\t * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode\n\t * to ignore DMA parity errors.\n\t */\n\tif (sc->cfg.control_flag & CONTROL_FLAG_IGNORE_PERR) {\n\t\t/*\n\t\t * Note: Don't remove the use of a temporary variable in\n\t\t * the following code, otherwise some C compiler\n\t\t * might turn the following lines into a no-op.\n\t\t */\n\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t\tword |= CONTROL_FLAG_IGNORE_PERR;\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t}\n\n\t/*\n\t * For ASC-38C0800, set FIFO_THRESH_80B [6:4] bits and START_CTL_TH [3:2]\n\t * bits for the default FIFO threshold.\n\t *\n\t * Note: ASC-38C0800 FIFO threshold has been changed to 256 bytes.\n\t *\n\t * For DMA Errata #4 set the BC_THRESH_ENB bit.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,\n\t\tBC_THRESH_ENB | FIFO_THRESH_80B | START_CTL_TH | READ_CMD_MRM);\n\n\t/*\n\t * Microcode operating variables for WDTR, SDTR, and command tag\n\t * queuing will be set in AdvInquiryHandling() based on what a\n\t * device reports it is capable of in Inquiry byte 7.\n\t *\n\t * If SCSI Bus Resets have been disabled, then directly set\n\t * SDTR and WDTR from the EEPROM configuration. This will allow\n\t * the BIOS and warm boot to work without a SCSI bus hang on\n\t * the Inquiry caused by host and target mismatched DTR values.\n\t * Without the SCSI Bus Reset, before an Inquiry a device can't\n\t * be assumed to be in Asynchronous, Narrow mode.\n\t */\n\tif ((sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, sc->wdtr_able);\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sc->sdtr_able);\n\t}\n\n\t/*\n\t * Set microcode operating variables for DISC and SDTR_SPEED1,\n\t * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM\n\t * configuration values.\n\t *\n\t * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them\n\t * without determining here whether the device supports SDTR.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DISC_ENABLE, sc->cfg.disc_enable);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED1, sc->sdtr_speed1);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED2, sc->sdtr_speed2);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED3, sc->sdtr_speed3);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED4, sc->sdtr_speed4);\n\n\t/*\n\t * Set SCSI_CFG0 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG0 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG0,\n\t\tADW_PARITY_EN | ADW_SEL_TMO_LONG | ADW_OUR_ID_EN |\n\t\t\tsc->chip_scsi_id);\n\n\t/*\n\t * Determine SCSI_CFG1 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\n\t/* Read current SCSI_CFG1 Register value. */\n\tscsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);\n\n\t/*\n\t * If the internal narrow cable is reversed all of the SCSI_CTRL\n\t * register signals will be set. Check for and return an error if\n\t * this condition is found.\n\t */\n\tif ((ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CTRL) & 0x3F07) ==\n\t\t\t0x3F07) {\n\t\treturn ASC_IERR_REVERSED_CABLE;\n\t}\n\n\t/*\n\t * All kind of combinations of devices attached to one of four connectors\n\t * are acceptable except HVD device attached. For example, LVD device can\n\t * be attached to SE connector while SE device attached to LVD connector.\n\t * If LVD device attached to SE connector, it only runs up to Ultra speed.\n\t *\n\t * If an HVD device is attached to one of LVD connectors, return an error.\n\t * However, there is no way to detect HVD device attached to SE connectors.\n\t */\n\tif (scsi_cfg1 & ADW_HVD) {\n\t\treturn ASC_IERR_HVD_DEVICE;\n\t}\n\n\t/*\n\t * If either SE or LVD automatic termination control is enabled, then\n\t * set the termination value based on a table listed in a_condor.h.\n\t *\n\t * If manual termination was specified with an EEPROM setting then\n\t * 'termination' was set-up in AdvInitFrom38C0800EEPROM() and is ready to\n\t * be 'ored' into SCSI_CFG1.\n\t */\n\tif ((sc->cfg.termination & ADW_TERM_SE) == 0) {\n\t\t/* SE automatic termination control is enabled. */\n\t\tswitch(scsi_cfg1 & ADW_C_DET_SE) {\n\t\t\t/* TERM_SE_HI: on, TERM_SE_LO: on */\n\t\t\tcase 0x1: case 0x2: case 0x3:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_SE;\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_SE_HI: on, TERM_SE_LO: off */\n\t\t\tcase 0x0:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_SE_HI;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((sc->cfg.termination & ADW_TERM_LVD) == 0) {\n\t\t/* LVD automatic termination control is enabled. */\n\t\tswitch(scsi_cfg1 & ADW_C_DET_LVD) {\n\t\t\t/* TERM_LVD_HI: on, TERM_LVD_LO: on */\n\t\t\tcase 0x4: case 0x8: case 0xC:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_LVD;\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_LVD_HI: off, TERM_LVD_LO: off */\n\t\t\tcase 0x0:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Clear any set TERM_SE and TERM_LVD bits.\n\t */\n\tscsi_cfg1 &= (~ADW_TERM_SE & ~ADW_TERM_LVD);\n\n\t/*\n\t * Invert the TERM_SE and TERM_LVD bits and then set 'scsi_cfg1'.\n\t */\n\tscsi_cfg1 |= (~sc->cfg.termination & 0xF0);\n\n\t/*\n\t * Clear BIG_ENDIAN, DIS_TERM_DRV, Terminator Polarity and HVD/LVD/SE bits\n\t * and set possibly modified termination control bits in the Microcode\n\t * SCSI_CFG1 Register Value.\n\t */\n\tscsi_cfg1 &= (~ADW_BIG_ENDIAN & ~ADW_DIS_TERM_DRV &\n\t\t\t~ADW_TERM_POL & ~ADW_HVD_LVD_SE);\n\n\t/*\n\t * Set SCSI_CFG1 Microcode Default Value\n\t *\n\t * Set possibly modified termination control and reset DIS_TERM_DRV\n\t * bits in the Microcode SCSI_CFG1 Register Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);\n\n\t/*\n\t * Set MEM_CFG Microcode Default Value\n\t *\n\t * The microcode will set the MEM_CFG register using this value\n\t * after it is started below.\n\t *\n\t * MEM_CFG may be accessed as a word or byte, but only bits 0-7\n\t * are defined.\n\t *\n\t * ASC-38C0800 has 16KB internal memory.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_MEM_CFG,\n\t\tADW_BIOS_EN | ADW_RAM_SZ_16KB);\n\n\t/*\n\t * Set SEL_MASK Microcode Default Value\n\t *\n\t * The microcode will set the SEL_MASK register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SEL_MASK,\n\t\tADW_TID_TO_TIDMASK(sc->chip_scsi_id));\n\n\n\t/*\n\t * Set-up the Host->RISC Initiator Command Queue (ICQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\n\tif (sc->icq_sp == NULL) {\n\t\tsc->carr_pending_cnt = 0;\n\t\tif ((sc->icq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->icq_sp->next_vpa));\n\n\n\t\t/*\n\t \t * The first command issued will be placed in the stopper carrier.\n\t \t */\n\t\tsc->icq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n\t * Set RISC ICQ physical address start value.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_ICQ, sc->icq_sp->carr_pa);\n\n\t/*\n\t * Set-up the RISC->Host Initiator Response Queue (IRQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\tif (sc->irq_sp == NULL) {\n\t\tif ((sc->irq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->irq_sp->next_vpa));\n\n\t\t/*\n\t \t * The first command completed by the RISC will be placed in\n\t \t * the stopper.\n\t \t *\n\t \t * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is\n\t \t * completed the RISC will set the ASC_RQ_DONE bit.\n\t \t */\n\t\tsc->irq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n\t * Set RISC IRQ physical address start value.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_IRQ, sc->irq_sp->carr_pa);\n\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_INTR_ENABLES,\n\t\t(ADW_INTR_ENABLE_HOST_INTR | ADW_INTR_ENABLE_GLOBAL_INTR));\n\t/*\n\t * Note: Don't remove the use of a temporary variable in\n\t * the following code, otherwise some C compiler\n\t * might turn the following lines into a no-op.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, word);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_PC, word);\n\n\t/* finally, finally, gentlemen, start your engine */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_RUN);\n\n\t/*\n\t * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus\n\t * Resets should be performed. The RISC has to be running\n\t * to issue a SCSI Bus Reset.\n\t */\n\tif (sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {\n\t\t/*\n\t\t * If the BIOS Signature is present in memory, restore the\n\t\t * BIOS Handshake Configuration Table and do not perform\n\t\t * a SCSI Bus Reset.\n\t\t */\n\t\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] ==\n\t\t\t\t0x55AA) {\n\t\t\t/*\n\t\t\t * Restore per TID negotiated values.\n\t\t\t */\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE,\n\t\t\t\t\ttagqng_able);\n\t\t\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\t\t\tADW_WRITE_BYTE_LRAM(iot, ioh,\n\t\t\t\t\t\tASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\t\t\tmax_cmd[tid]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (AdvResetCCB(sc) != ADW_TRUE) {\n\t\t\t\twarn_code = ASC_WARN_BUSRESET_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn warn_code;\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvInquiryHandling",
            "static void AdvSleepMilliSecond",
            "ADW_SOFTC\t*sc;",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;",
            "u_int8_t\t\ttid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvInquiryHandling;\nstatic void AdvSleepMilliSecond;\nADW_SOFTC\t*sc;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\nu_int8_t\t\ttid;\n\nint\nAdvInitAsc38C0800Driver(sc)\nADW_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t\twarn_code;\n\tu_int32_t\tsum;\n\tint\t  \tbegin_addr;\n\tint\t   \tend_addr;\n\tu_int16_t\tcode_sum;\n\tint\t   \tword;\n\tint\t   \ti, j;\n\tint\t   \tadv_asc38C0800_expanded_size;\n\tu_int16_t\tscsi_cfg1;\n\tu_int8_t\tbyte;\n\tu_int8_t\ttid;\n\tu_int16_t\tbios_mem[ASC_MC_BIOSLEN/2];\t/* BIOS RISC Memory\n\t\t\t\t\t\t\t\t0x40-0x8F. */\n\tu_int16_t\twdtr_able, sdtr_able, tagqng_able;\n\tu_int8_t\tmax_cmd[ADW_MAX_TID + 1];\n\n\n\twarn_code = 0;\n\n\t/*\n\t * Save the RISC memory BIOS region before writing the microcode.\n\t * The BIOS may already be loaded and using its RISC LRAM region\n\t * so its region must be saved and restored.\n\t *\n\t * Note: This code makes the assumption, which is currently true,\n\t * that a chip reset does not clear RISC LRAM.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t    ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i), bios_mem[i]);\n\t}\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * RAM BIST (RAM Built-In Self Test)\n\t *\n\t * Address : I/O base + offset 0x38h register (byte).\n\t * Function: Bit 7-6(RW) : RAM mode\n\t *\t\t\t    Normal Mode   : 0x00\n\t *\t\t\t    Pre-test Mode : 0x40\n\t *\t\t\t    RAM Test Mode : 0x80\n\t *\t     Bit 5\t : unused\n\t *\t     Bit 4(RO)   : Done bit\n\t *\t     Bit 3-0(RO) : Status\n\t *\t\t\t    Host Error    : 0x08\n\t *\t\t\t    Int_RAM Error : 0x04\n\t *\t\t\t    RISC Error    : 0x02\n\t *\t\t\t    SCSI Error    : 0x01\n\t *\t\t\t    No Error\t  : 0x00\n\t *\n\t * Note: RAM BIST code should be put right here, before loading the\n\t * microcode and after saving the RISC memory BIOS region.\n\t */\n\n\t/*\n\t * LRAM Pre-test\n\t *\n\t * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.\n\t * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return\n\t * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset\n\t * to NORMAL_MODE, return an error too.\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, PRE_TEST_MODE);\n\t\tAdvSleepMilliSecond(10);  /* Wait for 10ms before reading back. */\n\t\tbyte = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST);\n\t\tif ((byte & RAM_TEST_DONE) == 0 || (byte & 0x0F) !=\n\t\t\t\tPRE_TEST_VALUE) {\n\t\t\treturn ASC_IERR_BIST_PRE_TEST;\n\t\t}\n\n\t\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, NORMAL_MODE);\n\t\tAdvSleepMilliSecond(10);  /* Wait for 10ms before reading back. */\n\t\tif (ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST)\n\t\t    != NORMAL_VALUE) {\n\t\t\treturn ASC_IERR_BIST_PRE_TEST;\n\t\t}\n\t}\n\n\t/*\n\t * LRAM Test - It takes about 1.5 ms to run through the test.\n\t *\n\t * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.\n\t * If Done bit not set or Status not 0, save register byte, set the\n\t * err_code, and return an error.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, RAM_TEST_MODE);\n\tAdvSleepMilliSecond(10);  /* Wait for 10ms before checking status. */\n\n\tbyte = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST);\n\tif ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {\n\t\t/* Get here if Done bit not set or Status not 0. */\n\t\treturn ASC_IERR_BIST_RAM_TEST;\n\t}\n\n\t/* We need to reset back to normal mode after LRAM test passes. */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, NORMAL_MODE);\n\n\t/*\n\t * Load the Microcode\n\t *\n\t * Write the microcode image to RISC memory starting at address 0.\n\t *\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\t/* Assume the following compressed format of the microcode buffer:\n\t *\n\t *  254 word (508 byte) table indexed by byte code followed\n\t *  by the following byte codes:\n\t *\n\t *    1-Byte Code:\n\t *\t00: Emit word 0 in table.\n\t *\t01: Emit word 1 in table.\n\t *\t.\n\t *\tFD: Emit word 253 in table.\n\t *\n\t *    Multi-Byte Code:\n\t *\tFE WW WW: (3 byte code) Word to emit is the next word WW WW.\n\t *\tFF BB WW WW: (4 byte code) Emit BB count times next word WW WW.\n\t */\n\tword = 0;\n\tfor (i = 253 * 2; i < adv_asc38C0800_mcode_size; i++) {\n\t\tif (adv_asc38C0800_mcode[i] == 0xff) {\n\t\t\tfor (j = 0; j < adv_asc38C0800_mcode[i + 1]; j++) {\n\t\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,\n\t\t\t\t    (((u_int16_t)\n\t\t\t\t    adv_asc38C0800_mcode[i + 3] << 8) |\n\t\t\t\t    adv_asc38C0800_mcode[i + 2]));\n\t\t\t\tword++;\n\t\t\t}\n\t\t\ti += 3;\n\t\t} else if (adv_asc38C0800_mcode[i] == 0xfe) {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)\n\t\t\t    adv_asc38C0800_mcode[i + 2] << 8) |\n\t\t\t    adv_asc38C0800_mcode[i + 1]));\n\t\t\ti += 2;\n\t\t\tword++;\n\t\t} else {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)\n\t\t\t  adv_asc38C0800_mcode[(adv_asc38C0800_mcode[i] * 2) + 1] << 8) |\n\t\t\t  adv_asc38C0800_mcode[adv_asc38C0800_mcode[i] * 2]));\n\t\t\tword++;\n\t\t}\n\t}\n\n\t/*\n\t * Set 'word' for later use to clear the rest of memory and save\n\t * the expanded mcode size.\n\t */\n\tword *= 2;\n\tadv_asc38C0800_expanded_size = word;\n\n\t/*\n\t * Clear the rest of ASC-38C0800 Internal RAM (16KB).\n\t */\n\tfor (; word < ADV_38C0800_MEMSIZE; word += 2) {\n\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, 0);\n\t}\n\n\t/*\n\t * Verify the microcode checksum.\n\t */\n\tsum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\tfor (word = 0; word < adv_asc38C0800_expanded_size; word += 2) {\n\t\tsum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\n\tif (sum != adv_asc38C0800_mcode_chksum) {\n\t    return ASC_IERR_MCODE_CHKSUM;\n\t}\n\n\t/*\n\t * Restore the RISC memory BIOS region.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\tbios_mem[i]);\n\t}\n\n\t/*\n\t * Calculate and write the microcode code checksum to the microcode\n\t * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_END_ADDR, end_addr);\n\tcode_sum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, begin_addr);\n\tfor (word = begin_addr; word < end_addr; word += 2) {\n\t\tcode_sum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CODE_CHK_SUM, code_sum);\n\n\t/*\n\t * Read microcode version and date.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_DATE,\n\t\t\tsc->cfg.mcode_date);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_NUM,\n\t\t\tsc->cfg.mcode_version);\n\n\t/*\n\t * Set the chip type to indicate the ASC38C0800.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C0800);\n\n\t/*\n\t * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.\n\t * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current\n\t * cable detection and then we are able to read C_DET[3:0].\n\t *\n\t * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1\n\t * Microcode Default Value' section below.\n\t */\n\tscsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1,\n\t\t\tscsi_cfg1 | ADW_DIS_TERM_DRV);\n\n\t/*\n\t * If the PCI Configuration Command Register \"Parity Error Response\n\t * Control\" Bit was clear (0), then set the microcode variable\n\t * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode\n\t * to ignore DMA parity errors.\n\t */\n\tif (sc->cfg.control_flag & CONTROL_FLAG_IGNORE_PERR) {\n\t\t/*\n\t\t * Note: Don't remove the use of a temporary variable in\n\t\t * the following code, otherwise some C compiler\n\t\t * might turn the following lines into a no-op.\n\t\t */\n\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t\tword |= CONTROL_FLAG_IGNORE_PERR;\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t}\n\n\t/*\n\t * For ASC-38C0800, set FIFO_THRESH_80B [6:4] bits and START_CTL_TH [3:2]\n\t * bits for the default FIFO threshold.\n\t *\n\t * Note: ASC-38C0800 FIFO threshold has been changed to 256 bytes.\n\t *\n\t * For DMA Errata #4 set the BC_THRESH_ENB bit.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,\n\t\tBC_THRESH_ENB | FIFO_THRESH_80B | START_CTL_TH | READ_CMD_MRM);\n\n\t/*\n\t * Microcode operating variables for WDTR, SDTR, and command tag\n\t * queuing will be set in AdvInquiryHandling() based on what a\n\t * device reports it is capable of in Inquiry byte 7.\n\t *\n\t * If SCSI Bus Resets have been disabled, then directly set\n\t * SDTR and WDTR from the EEPROM configuration. This will allow\n\t * the BIOS and warm boot to work without a SCSI bus hang on\n\t * the Inquiry caused by host and target mismatched DTR values.\n\t * Without the SCSI Bus Reset, before an Inquiry a device can't\n\t * be assumed to be in Asynchronous, Narrow mode.\n\t */\n\tif ((sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, sc->wdtr_able);\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sc->sdtr_able);\n\t}\n\n\t/*\n\t * Set microcode operating variables for DISC and SDTR_SPEED1,\n\t * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM\n\t * configuration values.\n\t *\n\t * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them\n\t * without determining here whether the device supports SDTR.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DISC_ENABLE, sc->cfg.disc_enable);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED1, sc->sdtr_speed1);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED2, sc->sdtr_speed2);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED3, sc->sdtr_speed3);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED4, sc->sdtr_speed4);\n\n\t/*\n\t * Set SCSI_CFG0 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG0 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG0,\n\t\tADW_PARITY_EN | ADW_SEL_TMO_LONG | ADW_OUR_ID_EN |\n\t\t\tsc->chip_scsi_id);\n\n\t/*\n\t * Determine SCSI_CFG1 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\n\t/* Read current SCSI_CFG1 Register value. */\n\tscsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);\n\n\t/*\n\t * If the internal narrow cable is reversed all of the SCSI_CTRL\n\t * register signals will be set. Check for and return an error if\n\t * this condition is found.\n\t */\n\tif ((ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CTRL) & 0x3F07) ==\n\t\t\t0x3F07) {\n\t\treturn ASC_IERR_REVERSED_CABLE;\n\t}\n\n\t/*\n\t * All kind of combinations of devices attached to one of four connectors\n\t * are acceptable except HVD device attached. For example, LVD device can\n\t * be attached to SE connector while SE device attached to LVD connector.\n\t * If LVD device attached to SE connector, it only runs up to Ultra speed.\n\t *\n\t * If an HVD device is attached to one of LVD connectors, return an error.\n\t * However, there is no way to detect HVD device attached to SE connectors.\n\t */\n\tif (scsi_cfg1 & ADW_HVD) {\n\t\treturn ASC_IERR_HVD_DEVICE;\n\t}\n\n\t/*\n\t * If either SE or LVD automatic termination control is enabled, then\n\t * set the termination value based on a table listed in a_condor.h.\n\t *\n\t * If manual termination was specified with an EEPROM setting then\n\t * 'termination' was set-up in AdvInitFrom38C0800EEPROM() and is ready to\n\t * be 'ored' into SCSI_CFG1.\n\t */\n\tif ((sc->cfg.termination & ADW_TERM_SE) == 0) {\n\t\t/* SE automatic termination control is enabled. */\n\t\tswitch(scsi_cfg1 & ADW_C_DET_SE) {\n\t\t\t/* TERM_SE_HI: on, TERM_SE_LO: on */\n\t\t\tcase 0x1: case 0x2: case 0x3:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_SE;\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_SE_HI: on, TERM_SE_LO: off */\n\t\t\tcase 0x0:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_SE_HI;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((sc->cfg.termination & ADW_TERM_LVD) == 0) {\n\t\t/* LVD automatic termination control is enabled. */\n\t\tswitch(scsi_cfg1 & ADW_C_DET_LVD) {\n\t\t\t/* TERM_LVD_HI: on, TERM_LVD_LO: on */\n\t\t\tcase 0x4: case 0x8: case 0xC:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_LVD;\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_LVD_HI: off, TERM_LVD_LO: off */\n\t\t\tcase 0x0:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Clear any set TERM_SE and TERM_LVD bits.\n\t */\n\tscsi_cfg1 &= (~ADW_TERM_SE & ~ADW_TERM_LVD);\n\n\t/*\n\t * Invert the TERM_SE and TERM_LVD bits and then set 'scsi_cfg1'.\n\t */\n\tscsi_cfg1 |= (~sc->cfg.termination & 0xF0);\n\n\t/*\n\t * Clear BIG_ENDIAN, DIS_TERM_DRV, Terminator Polarity and HVD/LVD/SE bits\n\t * and set possibly modified termination control bits in the Microcode\n\t * SCSI_CFG1 Register Value.\n\t */\n\tscsi_cfg1 &= (~ADW_BIG_ENDIAN & ~ADW_DIS_TERM_DRV &\n\t\t\t~ADW_TERM_POL & ~ADW_HVD_LVD_SE);\n\n\t/*\n\t * Set SCSI_CFG1 Microcode Default Value\n\t *\n\t * Set possibly modified termination control and reset DIS_TERM_DRV\n\t * bits in the Microcode SCSI_CFG1 Register Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);\n\n\t/*\n\t * Set MEM_CFG Microcode Default Value\n\t *\n\t * The microcode will set the MEM_CFG register using this value\n\t * after it is started below.\n\t *\n\t * MEM_CFG may be accessed as a word or byte, but only bits 0-7\n\t * are defined.\n\t *\n\t * ASC-38C0800 has 16KB internal memory.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_MEM_CFG,\n\t\tADW_BIOS_EN | ADW_RAM_SZ_16KB);\n\n\t/*\n\t * Set SEL_MASK Microcode Default Value\n\t *\n\t * The microcode will set the SEL_MASK register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SEL_MASK,\n\t\tADW_TID_TO_TIDMASK(sc->chip_scsi_id));\n\n\n\t/*\n\t * Set-up the Host->RISC Initiator Command Queue (ICQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\n\tif (sc->icq_sp == NULL) {\n\t\tsc->carr_pending_cnt = 0;\n\t\tif ((sc->icq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->icq_sp->next_vpa));\n\n\n\t\t/*\n\t \t * The first command issued will be placed in the stopper carrier.\n\t \t */\n\t\tsc->icq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n\t * Set RISC ICQ physical address start value.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_ICQ, sc->icq_sp->carr_pa);\n\n\t/*\n\t * Set-up the RISC->Host Initiator Response Queue (IRQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\tif (sc->irq_sp == NULL) {\n\t\tif ((sc->irq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->irq_sp->next_vpa));\n\n\t\t/*\n\t \t * The first command completed by the RISC will be placed in\n\t \t * the stopper.\n\t \t *\n\t \t * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is\n\t \t * completed the RISC will set the ASC_RQ_DONE bit.\n\t \t */\n\t\tsc->irq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n\t * Set RISC IRQ physical address start value.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_IRQ, sc->irq_sp->carr_pa);\n\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_INTR_ENABLES,\n\t\t(ADW_INTR_ENABLE_HOST_INTR | ADW_INTR_ENABLE_GLOBAL_INTR));\n\t/*\n\t * Note: Don't remove the use of a temporary variable in\n\t * the following code, otherwise some C compiler\n\t * might turn the following lines into a no-op.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, word);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_PC, word);\n\n\t/* finally, finally, gentlemen, start your engine */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_RUN);\n\n\t/*\n\t * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus\n\t * Resets should be performed. The RISC has to be running\n\t * to issue a SCSI Bus Reset.\n\t */\n\tif (sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {\n\t\t/*\n\t\t * If the BIOS Signature is present in memory, restore the\n\t\t * BIOS Handshake Configuration Table and do not perform\n\t\t * a SCSI Bus Reset.\n\t\t */\n\t\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] ==\n\t\t\t\t0x55AA) {\n\t\t\t/*\n\t\t\t * Restore per TID negotiated values.\n\t\t\t */\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE,\n\t\t\t\t\ttagqng_able);\n\t\t\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\t\t\tADW_WRITE_BYTE_LRAM(iot, ioh,\n\t\t\t\t\t\tASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\t\t\tmax_cmd[tid]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (AdvResetCCB(sc) != ADW_TRUE) {\n\t\t\t\twarn_code = ASC_WARN_BUSRESET_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn warn_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AdvInitAsc3550Driver",
          "args": [
            "sc"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "AdvInitAsc3550Driver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "217-713",
          "snippet": "int\nAdvInitAsc3550Driver(sc)\nADW_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t\twarn_code;\n\tu_int32_t\tsum;\n\tint\t\tbegin_addr;\n\tint\t\tend_addr;\n\tu_int16_t\tcode_sum;\n\tint\t\tword;\n\tint\t\ti, j;\n\tint\t\tadv_asc3550_expanded_size;\n\tu_int16_t\tscsi_cfg1;\n\tu_int8_t\ttid;\n\tu_int16_t\tbios_mem[ASC_MC_BIOSLEN/2];\t/* BIOS RISC Memory\n\t\t\t\t\t\t\t\t0x40-0x8F. */\n\tu_int16_t\twdtr_able = 0, sdtr_able, tagqng_able;\n\tu_int8_t\tmax_cmd[ADW_MAX_TID + 1];\n\n\n\twarn_code = 0;\n\n\t/*\n\t * Save the RISC memory BIOS region before writing the microcode.\n\t * The BIOS may already be loaded and using its RISC LRAM region\n\t * so its region must be saved and restored.\n\t *\n\t * Note: This code makes the assumption, which is currently true,\n\t * that a chip reset does not clear RISC LRAM.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2*i), bios_mem[i]);\n\t}\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] == 0x55AA) {\n\n\t\tu_int16_t  bios_version, major, minor;\n\n\t\tbios_version = bios_mem[(ASC_MC_BIOS_VERSION-ASC_MC_BIOSMEM)/2];\n\t\tmajor = (bios_version  >> 12) & 0xF;\n\t\tminor = (bios_version  >> 8) & 0xF;\n\t\tif (major < 3 || (major == 3 && minor == 1)) {\n\t\t    /* BIOS 3.1 and earlier location of 'wdtr_able' variable. */\n\t\t    ADW_READ_WORD_LRAM(iot, ioh, 0x120, wdtr_able);\n\t\t} else {\n\t\t    ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\t\t}\n\t}\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * Load the Microcode\n\t *\n\t * Write the microcode image to RISC memory starting at address 0.\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\t/* Assume the following compressed format of the microcode buffer:\n\t *\n\t *  254 word (508 byte) table indexed by byte code followed\n\t *  by the following byte codes:\n\t *\n\t *    1-Byte Code:\n\t *\t00: Emit word 0 in table.\n\t *\t01: Emit word 1 in table.\n\t *\t.\n\t *\tFD: Emit word 253 in table.\n\t *\n\t *    Multi-Byte Code:\n\t *\tFE WW WW: (3 byte code) Word to emit is the next word WW WW.\n\t *\tFF BB WW WW: (4 byte code) Emit BB count times next word WW WW.\n\t */\n\tword = 0;\n\tfor (i = 253 * 2; i < adv_asc3550_mcode_size; i++) {\n\t\tif (adv_asc3550_mcode[i] == 0xff) {\n\t\t\tfor (j = 0; j < adv_asc3550_mcode[i + 1]; j++) {\n\t\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,\n\t\t\t\t  (((u_int16_t)adv_asc3550_mcode[i + 3] << 8) |\n\t\t\t\t  adv_asc3550_mcode[i + 2]));\n\t\t\t\tword++;\n\t\t\t}\n\t\t\ti += 3;\n\t\t} else if (adv_asc3550_mcode[i] == 0xfe) {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,\n\t\t\t    (((u_int16_t)adv_asc3550_mcode[i + 2] << 8) |\n\t\t\t    adv_asc3550_mcode[i + 1]));\n\t\t\ti += 2;\n\t\t\tword++;\n\t\t} else {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)\n\t\t\t adv_asc3550_mcode[(adv_asc3550_mcode[i] * 2) + 1] <<8) |\n\t\t\t adv_asc3550_mcode[adv_asc3550_mcode[i] * 2]));\n\t\t\tword++;\n\t\t}\n\t}\n\n\t/*\n\t * Set 'word' for later use to clear the rest of memory and save\n\t * the expanded mcode size.\n\t */\n\tword *= 2;\n\tadv_asc3550_expanded_size = word;\n\n\t/*\n\t * Clear the rest of ASC-3550 Internal RAM (8KB).\n\t */\n\tfor (; word < ADV_3550_MEMSIZE; word += 2) {\n\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, 0);\n\t}\n\n\t/*\n\t * Verify the microcode checksum.\n\t */\n\tsum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\tfor (word = 0; word < adv_asc3550_expanded_size; word += 2) {\n\t\tsum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\n\tif (sum != adv_asc3550_mcode_chksum) {\n\t\treturn ASC_IERR_MCODE_CHKSUM;\n\t}\n\n\t/*\n\t * Restore the RISC memory BIOS region.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t\tADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\tbios_mem[i]);\n\t}\n\n\t/*\n\t * Calculate and write the microcode code checksum to the microcode\n\t * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_END_ADDR, end_addr);\n\tcode_sum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, begin_addr);\n\tfor (word = begin_addr; word < end_addr; word += 2) {\n\t\tcode_sum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CODE_CHK_SUM, code_sum);\n\n\t/*\n\t * Read and save microcode version and date.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_DATE,\n\t\t\tsc->cfg.mcode_date);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_NUM,\n\t\t\tsc->cfg.mcode_version);\n\n\t/*\n\t * Set the chip type to indicate the ASC3550.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC3550);\n\n\t/*\n\t * If the PCI Configuration Command Register \"Parity Error Response\n\t * Control\" Bit was clear (0), then set the microcode variable\n\t * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode\n\t * to ignore DMA parity errors.\n\t */\n\tif (sc->cfg.control_flag & CONTROL_FLAG_IGNORE_PERR) {\n\t\t/*\n\t\t * Note: Don't remove the use of a temporary variable in\n\t\t * the following code, otherwise some  C compiler\n\t\t * might turn the following lines into a no-op.\n\t\t */\n\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t\tword |= CONTROL_FLAG_IGNORE_PERR;\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t}\n\n\t/*\n\t * For ASC-3550, setting the START_CTL_EMFU [3:2] bits sets a FIFO\n\t * threshold of 128 bytes. This register is only accessible to the host.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,\n\t\t\tSTART_CTL_EMFU | READ_CMD_MRM);\n\n\t/*\n\t * Microcode operating variables for WDTR, SDTR, and command tag\n\t * queuing will be set in AdvInquiryHandling() based on what a\n\t * device reports it is capable of in Inquiry byte 7.\n\t *\n\t * If SCSI Bus Resets haev been disabled, then directly set\n\t * SDTR and WDTR from the EEPROM configuration. This will allow\n\t * the BIOS and warm boot to work without a SCSI bus hang on\n\t * the Inquiry caused by host and target mismatched DTR values.\n\t * Without the SCSI Bus Reset, before an Inquiry a device can't\n\t * be assumed to be in Asynchronous, Narrow mode.\n\t */\n\tif ((sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE,\n\t\t\t\tsc->wdtr_able);\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE,\n\t\t\t\tsc->sdtr_able);\n\t}\n\n\t/*\n\t * Set microcode operating variables for SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 based on the ULTRA EEPROM per TID\n\t * bitmask. These values determine the maximum SDTR speed negotiated\n\t * with a device.\n\t *\n\t * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them\n\t * without determining here whether the device supports SDTR.\n\t *\n\t * 4-bit speed  SDTR speed name\n\t * ===========  ===============\n\t * 0000b (0x0)  SDTR disabled\n\t * 0001b (0x1)  5 Mhz\n\t * 0010b (0x2)  10 Mhz\n\t * 0011b (0x3)  20 Mhz (Ultra)\n\t * 0100b (0x4)  40 Mhz (LVD/Ultra2)\n\t * 0101b (0x5)  80 Mhz (LVD2/Ultra3)\n\t * 0110b (0x6)  Undefined\n\t * .\n\t * 1111b (0xF)  Undefined\n\t */\n\tword = 0;\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tif (ADW_TID_TO_TIDMASK(tid) & sc->ultra_able) {\n\t\t\t/* Set Ultra speed for TID 'tid'. */\n\t\t\tword |= (0x3 << (4 * (tid % 4)));\n\t\t} else {\n\t\t\t/* Set Fast speed for TID 'tid'. */\n\t\t\tword |= (0x2 << (4 * (tid % 4)));\n\t\t}\n\t\t/* Check if done with sdtr_speed1. */\n\t\tif (tid == 3) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED1, word);\n\t\t\tword = 0;\n\t\t/* Check if done with sdtr_speed2. */\n\t\t} else if (tid == 7) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED2, word);\n\t\t\tword = 0;\n\t\t/* Check if done with sdtr_speed3. */\n\t\t} else if (tid == 11) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED3, word);\n\t\t\tword = 0;\n\t\t/* Check if done with sdtr_speed4. */\n\t\t} else if (tid == 15) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED4, word);\n\t\t\t/* End of loop. */\n\t\t}\n\t}\n\n\t/*\n\t * Set microcode operating variable for the disconnect per TID bitmask.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DISC_ENABLE, sc->cfg.disc_enable);\n\n\n\t/*\n\t * Set SCSI_CFG0 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG0 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG0,\n\t\tADW_PARITY_EN | ADW_SEL_TMO_LONG | ADW_OUR_ID_EN |\n\t\t\tsc->chip_scsi_id);\n\n\t/*\n\t * Determine SCSI_CFG1 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\n\t/* Read current SCSI_CFG1 Register value. */\n\tscsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);\n\n\t/*\n\t * If all three connectors are in use, return an error.\n\t */\n\tif ((scsi_cfg1 & CABLE_ILLEGAL_A) == 0 ||\n\t\t(scsi_cfg1 & CABLE_ILLEGAL_B) == 0) {\n\t\treturn ASC_IERR_ILLEGAL_CONNECTION;\n\t}\n\n\t/*\n\t * If the internal narrow cable is reversed all of the SCSI_CTRL\n\t * register signals will be set. Check for and return an error if\n\t * this condition is found.\n\t */\n\tif ((ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CTRL) & 0x3F07) ==\n\t\t\t0x3F07) {\n\t\treturn ASC_IERR_REVERSED_CABLE;\n\t}\n\n\t/*\n\t * If this is a differential board and a single-ended device\n\t * is attached to one of the connectors, return an error.\n\t */\n\tif ((scsi_cfg1 & ADW_DIFF_MODE) && (scsi_cfg1 & ADW_DIFF_SENSE) == 0) {\n\t\treturn ASC_IERR_SINGLE_END_DEVICE;\n\t}\n\n\t/*\n\t * If automatic termination control is enabled, then set the\n\t * termination value based on a table listed in a_condor.h.\n\t *\n\t * If manual termination was specified with an EEPROM setting\n\t * then 'termination' was set-up in AdvInitFrom3550EEPROM() and\n\t * is ready to be 'ored' into SCSI_CFG1.\n\t */\n\tif (sc->cfg.termination == 0) {\n\t\t/*\n\t\t * The software always controls termination by setting TERM_CTL_SEL.\n\t\t * If TERM_CTL_SEL were set to 0, the hardware would set termination.\n\t\t */\n\t\tsc->cfg.termination |= ADW_TERM_CTL_SEL;\n\n\t\tswitch(scsi_cfg1 & ADW_CABLE_DETECT) {\n\t\t\t/* TERM_CTL_H: on, TERM_CTL_L: on */\n\t\t\tcase 0x3: case 0x7: case 0xB: case 0xD: case 0xE: case 0xF:\n\t\t\t\tsc->cfg.termination |= (ADW_TERM_CTL_H | ADW_TERM_CTL_L);\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_CTL_H: on, TERM_CTL_L: off */\n\t\t\tcase 0x1: case 0x5: case 0x9: case 0xA: case 0xC:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_CTL_H;\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_CTL_H: off, TERM_CTL_L: off */\n\t\t\tcase 0x2: case 0x6:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Clear any set TERM_CTL_H and TERM_CTL_L bits.\n\t */\n\tscsi_cfg1 &= ~ADW_TERM_CTL;\n\n\t/*\n\t * Invert the TERM_CTL_H and TERM_CTL_L bits and then\n\t * set 'scsi_cfg1'. The TERM_POL bit does not need to be\n\t * referenced, because the hardware internally inverts\n\t * the Termination High and Low bits if TERM_POL is set.\n\t */\n\tscsi_cfg1 |= (ADW_TERM_CTL_SEL | (~sc->cfg.termination & ADW_TERM_CTL));\n\n\t/*\n\t * Set SCSI_CFG1 Microcode Default Value\n\t *\n\t * Set filter value and possibly modified termination control\n\t * bits in the Microcode SCSI_CFG1 Register Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG1,\n\t\tADW_FLTR_DISABLE | scsi_cfg1);\n\n\t/*\n\t * Set MEM_CFG Microcode Default Value\n\t *\n\t * The microcode will set the MEM_CFG register using this value\n\t * after it is started below.\n\t *\n\t * MEM_CFG may be accessed as a word or byte, but only bits 0-7\n\t * are defined.\n\t *\n\t * ASC-3550 has 8KB internal memory.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_MEM_CFG,\n\t\tADW_BIOS_EN | ADW_RAM_SZ_8KB);\n\n\t/*\n\t * Set SEL_MASK Microcode Default Value\n\t *\n\t * The microcode will set the SEL_MASK register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SEL_MASK,\n\t\tADW_TID_TO_TIDMASK(sc->chip_scsi_id));\n\n\n\t/*\n\t * Set-up the Host->RISC Initiator Command Queue (ICQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\n\tif (sc->icq_sp == NULL) {\n\t\tsc->carr_pending_cnt = 0;\n\t\tif ((sc->icq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->icq_sp->next_vpa));\n\n\t\t/*\n\t \t * The first command issued will be placed in the stopper carrier.\n\t\t */\n\t\tsc->icq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n\t * Set RISC ICQ physical address start value.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_ICQ, sc->icq_sp->carr_pa);\n\n\t/*\n\t * Set-up the RISC->Host Initiator Response Queue (IRQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\tif (sc->irq_sp == NULL) {\n\t\tif ((sc->irq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->irq_sp->next_vpa));\n\n\t\t/*\n \t \t * The first command completed by the RISC will be placed in\n \t \t * the stopper.\n \t \t *\n \t \t * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is\n \t \t * completed the RISC will set the ASC_RQ_DONE bit.\n \t \t */\n\t\tsc->irq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n \t * Set RISC IRQ physical address start value.\n \t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_IRQ, sc->irq_sp->carr_pa);\n\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_INTR_ENABLES,\n\t\t(ADW_INTR_ENABLE_HOST_INTR | ADW_INTR_ENABLE_GLOBAL_INTR));\n\n\t/*\n\t * Note: Don't remove the use of a temporary variable in\n\t * the following code, otherwise some C compiler\n\t * might turn the following lines into a no-op.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, word);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_PC, word);\n\n\t/* finally, finally, gentlemen, start your engine */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_RUN);\n\n\t/*\n\t * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus\n\t * Resets should be performed. The RISC has to be running\n\t * to issue a SCSI Bus Reset.\n\t */\n\tif (sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS)\n\t{\n\t\t/*\n\t\t * If the BIOS Signature is present in memory, restore the\n\t\t * BIOS Handshake Configuration Table and do not perform\n\t\t * a SCSI Bus Reset.\n\t\t */\n\t\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] ==\n\t\t\t\t0x55AA) {\n\t\t\t/*\n\t\t\t * Restore per TID negotiated values.\n\t\t\t */\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE,\n\t\t\t\t\twdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE,\n\t\t\t\t\tsdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE,\n\t\t\t\t\ttagqng_able);\n\t\t\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\t\t\tADW_WRITE_BYTE_LRAM(iot, ioh,\n\t\t\t\t\tASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\t\tmax_cmd[tid]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (AdvResetCCB(sc) != ADW_TRUE) {\n\t\t\t\twarn_code = ASC_WARN_BUSRESET_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n    return warn_code;\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvInquiryHandling",
            "ADW_SOFTC\t*sc;",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;",
            "u_int8_t\t\ttid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvInquiryHandling;\nADW_SOFTC\t*sc;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\nu_int8_t\t\ttid;\n\nint\nAdvInitAsc3550Driver(sc)\nADW_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t\twarn_code;\n\tu_int32_t\tsum;\n\tint\t\tbegin_addr;\n\tint\t\tend_addr;\n\tu_int16_t\tcode_sum;\n\tint\t\tword;\n\tint\t\ti, j;\n\tint\t\tadv_asc3550_expanded_size;\n\tu_int16_t\tscsi_cfg1;\n\tu_int8_t\ttid;\n\tu_int16_t\tbios_mem[ASC_MC_BIOSLEN/2];\t/* BIOS RISC Memory\n\t\t\t\t\t\t\t\t0x40-0x8F. */\n\tu_int16_t\twdtr_able = 0, sdtr_able, tagqng_able;\n\tu_int8_t\tmax_cmd[ADW_MAX_TID + 1];\n\n\n\twarn_code = 0;\n\n\t/*\n\t * Save the RISC memory BIOS region before writing the microcode.\n\t * The BIOS may already be loaded and using its RISC LRAM region\n\t * so its region must be saved and restored.\n\t *\n\t * Note: This code makes the assumption, which is currently true,\n\t * that a chip reset does not clear RISC LRAM.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2*i), bios_mem[i]);\n\t}\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] == 0x55AA) {\n\n\t\tu_int16_t  bios_version, major, minor;\n\n\t\tbios_version = bios_mem[(ASC_MC_BIOS_VERSION-ASC_MC_BIOSMEM)/2];\n\t\tmajor = (bios_version  >> 12) & 0xF;\n\t\tminor = (bios_version  >> 8) & 0xF;\n\t\tif (major < 3 || (major == 3 && minor == 1)) {\n\t\t    /* BIOS 3.1 and earlier location of 'wdtr_able' variable. */\n\t\t    ADW_READ_WORD_LRAM(iot, ioh, 0x120, wdtr_able);\n\t\t} else {\n\t\t    ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\t\t}\n\t}\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * Load the Microcode\n\t *\n\t * Write the microcode image to RISC memory starting at address 0.\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\t/* Assume the following compressed format of the microcode buffer:\n\t *\n\t *  254 word (508 byte) table indexed by byte code followed\n\t *  by the following byte codes:\n\t *\n\t *    1-Byte Code:\n\t *\t00: Emit word 0 in table.\n\t *\t01: Emit word 1 in table.\n\t *\t.\n\t *\tFD: Emit word 253 in table.\n\t *\n\t *    Multi-Byte Code:\n\t *\tFE WW WW: (3 byte code) Word to emit is the next word WW WW.\n\t *\tFF BB WW WW: (4 byte code) Emit BB count times next word WW WW.\n\t */\n\tword = 0;\n\tfor (i = 253 * 2; i < adv_asc3550_mcode_size; i++) {\n\t\tif (adv_asc3550_mcode[i] == 0xff) {\n\t\t\tfor (j = 0; j < adv_asc3550_mcode[i + 1]; j++) {\n\t\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,\n\t\t\t\t  (((u_int16_t)adv_asc3550_mcode[i + 3] << 8) |\n\t\t\t\t  adv_asc3550_mcode[i + 2]));\n\t\t\t\tword++;\n\t\t\t}\n\t\t\ti += 3;\n\t\t} else if (adv_asc3550_mcode[i] == 0xfe) {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,\n\t\t\t    (((u_int16_t)adv_asc3550_mcode[i + 2] << 8) |\n\t\t\t    adv_asc3550_mcode[i + 1]));\n\t\t\ti += 2;\n\t\t\tword++;\n\t\t} else {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)\n\t\t\t adv_asc3550_mcode[(adv_asc3550_mcode[i] * 2) + 1] <<8) |\n\t\t\t adv_asc3550_mcode[adv_asc3550_mcode[i] * 2]));\n\t\t\tword++;\n\t\t}\n\t}\n\n\t/*\n\t * Set 'word' for later use to clear the rest of memory and save\n\t * the expanded mcode size.\n\t */\n\tword *= 2;\n\tadv_asc3550_expanded_size = word;\n\n\t/*\n\t * Clear the rest of ASC-3550 Internal RAM (8KB).\n\t */\n\tfor (; word < ADV_3550_MEMSIZE; word += 2) {\n\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, 0);\n\t}\n\n\t/*\n\t * Verify the microcode checksum.\n\t */\n\tsum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\tfor (word = 0; word < adv_asc3550_expanded_size; word += 2) {\n\t\tsum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\n\tif (sum != adv_asc3550_mcode_chksum) {\n\t\treturn ASC_IERR_MCODE_CHKSUM;\n\t}\n\n\t/*\n\t * Restore the RISC memory BIOS region.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t\tADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\tbios_mem[i]);\n\t}\n\n\t/*\n\t * Calculate and write the microcode code checksum to the microcode\n\t * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_END_ADDR, end_addr);\n\tcode_sum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, begin_addr);\n\tfor (word = begin_addr; word < end_addr; word += 2) {\n\t\tcode_sum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CODE_CHK_SUM, code_sum);\n\n\t/*\n\t * Read and save microcode version and date.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_DATE,\n\t\t\tsc->cfg.mcode_date);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_NUM,\n\t\t\tsc->cfg.mcode_version);\n\n\t/*\n\t * Set the chip type to indicate the ASC3550.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC3550);\n\n\t/*\n\t * If the PCI Configuration Command Register \"Parity Error Response\n\t * Control\" Bit was clear (0), then set the microcode variable\n\t * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode\n\t * to ignore DMA parity errors.\n\t */\n\tif (sc->cfg.control_flag & CONTROL_FLAG_IGNORE_PERR) {\n\t\t/*\n\t\t * Note: Don't remove the use of a temporary variable in\n\t\t * the following code, otherwise some  C compiler\n\t\t * might turn the following lines into a no-op.\n\t\t */\n\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t\tword |= CONTROL_FLAG_IGNORE_PERR;\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t}\n\n\t/*\n\t * For ASC-3550, setting the START_CTL_EMFU [3:2] bits sets a FIFO\n\t * threshold of 128 bytes. This register is only accessible to the host.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,\n\t\t\tSTART_CTL_EMFU | READ_CMD_MRM);\n\n\t/*\n\t * Microcode operating variables for WDTR, SDTR, and command tag\n\t * queuing will be set in AdvInquiryHandling() based on what a\n\t * device reports it is capable of in Inquiry byte 7.\n\t *\n\t * If SCSI Bus Resets haev been disabled, then directly set\n\t * SDTR and WDTR from the EEPROM configuration. This will allow\n\t * the BIOS and warm boot to work without a SCSI bus hang on\n\t * the Inquiry caused by host and target mismatched DTR values.\n\t * Without the SCSI Bus Reset, before an Inquiry a device can't\n\t * be assumed to be in Asynchronous, Narrow mode.\n\t */\n\tif ((sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE,\n\t\t\t\tsc->wdtr_able);\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE,\n\t\t\t\tsc->sdtr_able);\n\t}\n\n\t/*\n\t * Set microcode operating variables for SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 based on the ULTRA EEPROM per TID\n\t * bitmask. These values determine the maximum SDTR speed negotiated\n\t * with a device.\n\t *\n\t * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them\n\t * without determining here whether the device supports SDTR.\n\t *\n\t * 4-bit speed  SDTR speed name\n\t * ===========  ===============\n\t * 0000b (0x0)  SDTR disabled\n\t * 0001b (0x1)  5 Mhz\n\t * 0010b (0x2)  10 Mhz\n\t * 0011b (0x3)  20 Mhz (Ultra)\n\t * 0100b (0x4)  40 Mhz (LVD/Ultra2)\n\t * 0101b (0x5)  80 Mhz (LVD2/Ultra3)\n\t * 0110b (0x6)  Undefined\n\t * .\n\t * 1111b (0xF)  Undefined\n\t */\n\tword = 0;\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tif (ADW_TID_TO_TIDMASK(tid) & sc->ultra_able) {\n\t\t\t/* Set Ultra speed for TID 'tid'. */\n\t\t\tword |= (0x3 << (4 * (tid % 4)));\n\t\t} else {\n\t\t\t/* Set Fast speed for TID 'tid'. */\n\t\t\tword |= (0x2 << (4 * (tid % 4)));\n\t\t}\n\t\t/* Check if done with sdtr_speed1. */\n\t\tif (tid == 3) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED1, word);\n\t\t\tword = 0;\n\t\t/* Check if done with sdtr_speed2. */\n\t\t} else if (tid == 7) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED2, word);\n\t\t\tword = 0;\n\t\t/* Check if done with sdtr_speed3. */\n\t\t} else if (tid == 11) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED3, word);\n\t\t\tword = 0;\n\t\t/* Check if done with sdtr_speed4. */\n\t\t} else if (tid == 15) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED4, word);\n\t\t\t/* End of loop. */\n\t\t}\n\t}\n\n\t/*\n\t * Set microcode operating variable for the disconnect per TID bitmask.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DISC_ENABLE, sc->cfg.disc_enable);\n\n\n\t/*\n\t * Set SCSI_CFG0 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG0 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG0,\n\t\tADW_PARITY_EN | ADW_SEL_TMO_LONG | ADW_OUR_ID_EN |\n\t\t\tsc->chip_scsi_id);\n\n\t/*\n\t * Determine SCSI_CFG1 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\n\t/* Read current SCSI_CFG1 Register value. */\n\tscsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);\n\n\t/*\n\t * If all three connectors are in use, return an error.\n\t */\n\tif ((scsi_cfg1 & CABLE_ILLEGAL_A) == 0 ||\n\t\t(scsi_cfg1 & CABLE_ILLEGAL_B) == 0) {\n\t\treturn ASC_IERR_ILLEGAL_CONNECTION;\n\t}\n\n\t/*\n\t * If the internal narrow cable is reversed all of the SCSI_CTRL\n\t * register signals will be set. Check for and return an error if\n\t * this condition is found.\n\t */\n\tif ((ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CTRL) & 0x3F07) ==\n\t\t\t0x3F07) {\n\t\treturn ASC_IERR_REVERSED_CABLE;\n\t}\n\n\t/*\n\t * If this is a differential board and a single-ended device\n\t * is attached to one of the connectors, return an error.\n\t */\n\tif ((scsi_cfg1 & ADW_DIFF_MODE) && (scsi_cfg1 & ADW_DIFF_SENSE) == 0) {\n\t\treturn ASC_IERR_SINGLE_END_DEVICE;\n\t}\n\n\t/*\n\t * If automatic termination control is enabled, then set the\n\t * termination value based on a table listed in a_condor.h.\n\t *\n\t * If manual termination was specified with an EEPROM setting\n\t * then 'termination' was set-up in AdvInitFrom3550EEPROM() and\n\t * is ready to be 'ored' into SCSI_CFG1.\n\t */\n\tif (sc->cfg.termination == 0) {\n\t\t/*\n\t\t * The software always controls termination by setting TERM_CTL_SEL.\n\t\t * If TERM_CTL_SEL were set to 0, the hardware would set termination.\n\t\t */\n\t\tsc->cfg.termination |= ADW_TERM_CTL_SEL;\n\n\t\tswitch(scsi_cfg1 & ADW_CABLE_DETECT) {\n\t\t\t/* TERM_CTL_H: on, TERM_CTL_L: on */\n\t\t\tcase 0x3: case 0x7: case 0xB: case 0xD: case 0xE: case 0xF:\n\t\t\t\tsc->cfg.termination |= (ADW_TERM_CTL_H | ADW_TERM_CTL_L);\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_CTL_H: on, TERM_CTL_L: off */\n\t\t\tcase 0x1: case 0x5: case 0x9: case 0xA: case 0xC:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_CTL_H;\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_CTL_H: off, TERM_CTL_L: off */\n\t\t\tcase 0x2: case 0x6:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Clear any set TERM_CTL_H and TERM_CTL_L bits.\n\t */\n\tscsi_cfg1 &= ~ADW_TERM_CTL;\n\n\t/*\n\t * Invert the TERM_CTL_H and TERM_CTL_L bits and then\n\t * set 'scsi_cfg1'. The TERM_POL bit does not need to be\n\t * referenced, because the hardware internally inverts\n\t * the Termination High and Low bits if TERM_POL is set.\n\t */\n\tscsi_cfg1 |= (ADW_TERM_CTL_SEL | (~sc->cfg.termination & ADW_TERM_CTL));\n\n\t/*\n\t * Set SCSI_CFG1 Microcode Default Value\n\t *\n\t * Set filter value and possibly modified termination control\n\t * bits in the Microcode SCSI_CFG1 Register Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG1,\n\t\tADW_FLTR_DISABLE | scsi_cfg1);\n\n\t/*\n\t * Set MEM_CFG Microcode Default Value\n\t *\n\t * The microcode will set the MEM_CFG register using this value\n\t * after it is started below.\n\t *\n\t * MEM_CFG may be accessed as a word or byte, but only bits 0-7\n\t * are defined.\n\t *\n\t * ASC-3550 has 8KB internal memory.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_MEM_CFG,\n\t\tADW_BIOS_EN | ADW_RAM_SZ_8KB);\n\n\t/*\n\t * Set SEL_MASK Microcode Default Value\n\t *\n\t * The microcode will set the SEL_MASK register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SEL_MASK,\n\t\tADW_TID_TO_TIDMASK(sc->chip_scsi_id));\n\n\n\t/*\n\t * Set-up the Host->RISC Initiator Command Queue (ICQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\n\tif (sc->icq_sp == NULL) {\n\t\tsc->carr_pending_cnt = 0;\n\t\tif ((sc->icq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->icq_sp->next_vpa));\n\n\t\t/*\n\t \t * The first command issued will be placed in the stopper carrier.\n\t\t */\n\t\tsc->icq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n\t * Set RISC ICQ physical address start value.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_ICQ, sc->icq_sp->carr_pa);\n\n\t/*\n\t * Set-up the RISC->Host Initiator Response Queue (IRQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\tif (sc->irq_sp == NULL) {\n\t\tif ((sc->irq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->irq_sp->next_vpa));\n\n\t\t/*\n \t \t * The first command completed by the RISC will be placed in\n \t \t * the stopper.\n \t \t *\n \t \t * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is\n \t \t * completed the RISC will set the ASC_RQ_DONE bit.\n \t \t */\n\t\tsc->irq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n \t * Set RISC IRQ physical address start value.\n \t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_IRQ, sc->irq_sp->carr_pa);\n\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_INTR_ENABLES,\n\t\t(ADW_INTR_ENABLE_HOST_INTR | ADW_INTR_ENABLE_GLOBAL_INTR));\n\n\t/*\n\t * Note: Don't remove the use of a temporary variable in\n\t * the following code, otherwise some C compiler\n\t * might turn the following lines into a no-op.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, word);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_PC, word);\n\n\t/* finally, finally, gentlemen, start your engine */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_RUN);\n\n\t/*\n\t * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus\n\t * Resets should be performed. The RISC has to be running\n\t * to issue a SCSI Bus Reset.\n\t */\n\tif (sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS)\n\t{\n\t\t/*\n\t\t * If the BIOS Signature is present in memory, restore the\n\t\t * BIOS Handshake Configuration Table and do not perform\n\t\t * a SCSI Bus Reset.\n\t\t */\n\t\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] ==\n\t\t\t\t0x55AA) {\n\t\t\t/*\n\t\t\t * Restore per TID negotiated values.\n\t\t\t */\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE,\n\t\t\t\t\twdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE,\n\t\t\t\t\tsdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE,\n\t\t\t\t\ttagqng_able);\n\t\t\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\t\t\tADW_WRITE_BYTE_LRAM(iot, ioh,\n\t\t\t\t\tASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\t\tmax_cmd[tid]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (AdvResetCCB(sc) != ADW_TRUE) {\n\t\t\t\twarn_code = ASC_WARN_BUSRESET_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n    return warn_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "adw_create_carriers",
          "args": [
            "sc"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "adw_create_carriers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
          "lines": "287-309",
          "snippet": "static int\nadw_create_carriers(sc)\n\tADW_SOFTC\t*sc;\n{\n\tADW_CARRIER\t*carr;\n\tu_int32_t\tcarr_next = NULL;\n\tint\t\ti, error;\n\n\tfor(i=0; i < ADW_MAX_CARRIER; i++) {\n\t\tcarr = (ADW_CARRIER *)(((u_int8_t *)sc->sc_control->carriers) +\n\t\t\t\t(ADW_CARRIER_SIZE * i));\n\t\tif ((error = adw_init_carrier(sc, carr)) != 0) {\n\t\t\tprintf(\"%s: unable to initialize carrier, error = %d\\n\",\n\t\t\t       sc->sc_dev.dv_xname, error);\n\t\t\treturn (i);\n\t\t}\n\t\tcarr->next_vpa = carr_next;\n\t\tcarr_next = carr->carr_pa;\n\t\tcarr->id = i;\n\t}\n\tsc->carr_freelist = carr;\n\treturn (i);\n}",
          "includes": [
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int adw_create_carriers",
            "static int adw_init_carrier",
            "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
            "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
            "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
            "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adw_create_carriers;\nstatic int adw_init_carrier;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic int\nadw_create_carriers(sc)\n\tADW_SOFTC\t*sc;\n{\n\tADW_CARRIER\t*carr;\n\tu_int32_t\tcarr_next = NULL;\n\tint\t\ti, error;\n\n\tfor(i=0; i < ADW_MAX_CARRIER; i++) {\n\t\tcarr = (ADW_CARRIER *)(((u_int8_t *)sc->sc_control->carriers) +\n\t\t\t\t(ADW_CARRIER_SIZE * i));\n\t\tif ((error = adw_init_carrier(sc, carr)) != 0) {\n\t\t\tprintf(\"%s: unable to initialize carrier, error = %d\\n\",\n\t\t\t       sc->sc_dev.dv_xname, error);\n\t\t\treturn (i);\n\t\t}\n\t\tcarr->next_vpa = carr_next;\n\t\tcarr_next = carr->carr_pa;\n\t\tcarr->id = i;\n\t}\n\tsc->carr_freelist = carr;\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->sc_control->carriers",
            "ADW_CARRIER_SIZE * ADW_MAX_CARRIER"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adw_alloc_carriers",
          "args": [
            "sc"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "adw_alloc_carriers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
          "lines": "215-280",
          "snippet": "static int\nadw_alloc_carriers(sc)\n\tADW_SOFTC      *sc;\n{\n\tbus_dma_segment_t seg;\n\tint             error, rseg;\n\n\t/*\n         * Allocate the control structure.\n         */\n\tsc->sc_control->carriers = malloc(ADW_CARRIER_SIZE * ADW_MAX_CARRIER,\n\t\t\tM_DEVBUF, M_WAITOK);\n\tif(!sc->sc_control->carriers) {\n\t\tprintf(\"%s: malloc() failed in allocating carrier structures,\"\n\t\t       \" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\tif ((error = bus_dmamem_alloc(sc->sc_dmat,\n\t\t\tADW_CARRIER_SIZE * ADW_MAX_CARRIER,\n\t\t\tNBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to allocate carrier structures,\"\n\t\t       \" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,\n\t\t\tADW_CARRIER_SIZE * ADW_MAX_CARRIER,\n\t\t\t(caddr_t *) &sc->sc_control->carriers,\n\t\t\tBUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: unable to map carrier structures,\"\n\t\t\t\" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\t/*\n         * Create and load the DMA map used for the control blocks.\n         */\n\tif ((error = bus_dmamap_create(sc->sc_dmat,\n\t\t\tADW_CARRIER_SIZE * ADW_MAX_CARRIER, 1,\n\t\t\tADW_CARRIER_SIZE * ADW_MAX_CARRIER, 0, BUS_DMA_NOWAIT,\n\t\t\t&sc->sc_dmamap_carrier)) != 0) {\n\t\tprintf(\"%s: unable to create carriers DMA map,\"\n\t\t\t\" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamap_load(sc->sc_dmat,\n\t\t\tsc->sc_dmamap_carrier, sc->sc_control->carriers,\n\t\t\tADW_CARRIER_SIZE * ADW_MAX_CARRIER, NULL,\n\t\t\tBUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to load carriers DMA map,\"\n\t\t\t\" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\terror = bus_dmamap_create(sc->sc_dmat, ADW_CARRIER_SIZE* ADW_MAX_CARRIER,\n\t\t\t1, ADW_CARRIER_SIZE * ADW_MAX_CARRIER,\n\t\t\t0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t\t\t&sc->sc_control->dmamap_xfer);\n\tif (error) {\n\t\tprintf(\"%s: unable to create Carrier DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int adw_alloc_carriers",
            "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
            "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
            "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
            "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adw_alloc_carriers;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic int\nadw_alloc_carriers(sc)\n\tADW_SOFTC      *sc;\n{\n\tbus_dma_segment_t seg;\n\tint             error, rseg;\n\n\t/*\n         * Allocate the control structure.\n         */\n\tsc->sc_control->carriers = malloc(ADW_CARRIER_SIZE * ADW_MAX_CARRIER,\n\t\t\tM_DEVBUF, M_WAITOK);\n\tif(!sc->sc_control->carriers) {\n\t\tprintf(\"%s: malloc() failed in allocating carrier structures,\"\n\t\t       \" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\tif ((error = bus_dmamem_alloc(sc->sc_dmat,\n\t\t\tADW_CARRIER_SIZE * ADW_MAX_CARRIER,\n\t\t\tNBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to allocate carrier structures,\"\n\t\t       \" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,\n\t\t\tADW_CARRIER_SIZE * ADW_MAX_CARRIER,\n\t\t\t(caddr_t *) &sc->sc_control->carriers,\n\t\t\tBUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: unable to map carrier structures,\"\n\t\t\t\" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\t/*\n         * Create and load the DMA map used for the control blocks.\n         */\n\tif ((error = bus_dmamap_create(sc->sc_dmat,\n\t\t\tADW_CARRIER_SIZE * ADW_MAX_CARRIER, 1,\n\t\t\tADW_CARRIER_SIZE * ADW_MAX_CARRIER, 0, BUS_DMA_NOWAIT,\n\t\t\t&sc->sc_dmamap_carrier)) != 0) {\n\t\tprintf(\"%s: unable to create carriers DMA map,\"\n\t\t\t\" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamap_load(sc->sc_dmat,\n\t\t\tsc->sc_dmamap_carrier, sc->sc_control->carriers,\n\t\t\tADW_CARRIER_SIZE * ADW_MAX_CARRIER, NULL,\n\t\t\tBUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to load carriers DMA map,\"\n\t\t\t\" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\terror = bus_dmamap_create(sc->sc_dmat, ADW_CARRIER_SIZE* ADW_MAX_CARRIER,\n\t\t\t1, ADW_CARRIER_SIZE * ADW_MAX_CARRIER,\n\t\t\t0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t\t\t&sc->sc_control->dmamap_xfer);\n\tif (error) {\n\t\tprintf(\"%s: unable to create Carrier DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "adw_create_ccbs",
          "args": [
            "sc",
            "sc->sc_control->ccbs",
            "ADW_MAX_CCB"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "adw_create_ccbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
          "lines": "371-391",
          "snippet": "static int\nadw_create_ccbs(sc, ccbstore, count)\n\tADW_SOFTC      *sc;\n\tADW_CCB        *ccbstore;\n\tint             count;\n{\n\tADW_CCB        *ccb;\n\tint             i, error;\n\n\tfor (i = 0; i < count; i++) {\n\t\tccb = &ccbstore[i];\n\t\tif ((error = adw_init_ccb(sc, ccb)) != 0) {\n\t\t\tprintf(\"%s: unable to initialize ccb, error = %d\\n\",\n\t\t\t       sc->sc_dev.dv_xname, error);\n\t\t\treturn (i);\n\t\t}\n\t\tTAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, chain);\n\t}\n\n\treturn (i);\n}",
          "includes": [
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int adw_create_ccbs",
            "static int adw_init_ccb",
            "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
            "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
            "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
            "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adw_create_ccbs;\nstatic int adw_init_ccb;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic int\nadw_create_ccbs(sc, ccbstore, count)\n\tADW_SOFTC      *sc;\n\tADW_CCB        *ccbstore;\n\tint             count;\n{\n\tADW_CCB        *ccb;\n\tint             i, error;\n\n\tfor (i = 0; i < count; i++) {\n\t\tccb = &ccbstore[i];\n\t\tif ((error = adw_init_ccb(sc, ccb)) != 0) {\n\t\t\tprintf(\"%s: unable to initialize ccb, error = %d\\n\",\n\t\t\t       sc->sc_dev.dv_xname, error);\n\t\t\treturn (i);\n\t\t}\n\t\tTAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, chain);\n\t}\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->sc_control",
            "sizeof(struct adw_control)"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adw_alloc_controls",
          "args": [
            "sc"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "adw_alloc_controls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
          "lines": "169-212",
          "snippet": "static int\nadw_alloc_controls(sc)\n\tADW_SOFTC      *sc;\n{\n\tbus_dma_segment_t seg;\n\tint             error, rseg;\n\n\t/*\n         * Allocate the control structure.\n         */\n\tif ((error = bus_dmamem_alloc(sc->sc_dmat, sizeof(struct adw_control),\n\t\t\t   NBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to allocate control structures,\"\n\t\t       \" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,\n\t\t   sizeof(struct adw_control), (caddr_t *) & sc->sc_control,\n\t\t\t\t BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: unable to map control structures, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\t/*\n         * Create and load the DMA map used for the control blocks.\n         */\n\tif ((error = bus_dmamap_create(sc->sc_dmat, sizeof(struct adw_control),\n\t\t\t   1, sizeof(struct adw_control), 0, BUS_DMA_NOWAIT,\n\t\t\t\t       &sc->sc_dmamap_control)) != 0) {\n\t\tprintf(\"%s: unable to create control DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap_control,\n\t\t\t   sc->sc_control, sizeof(struct adw_control), NULL,\n\t\t\t\t     BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to load control DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int adw_alloc_controls",
            "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
            "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
            "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
            "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adw_alloc_controls;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic int\nadw_alloc_controls(sc)\n\tADW_SOFTC      *sc;\n{\n\tbus_dma_segment_t seg;\n\tint             error, rseg;\n\n\t/*\n         * Allocate the control structure.\n         */\n\tif ((error = bus_dmamem_alloc(sc->sc_dmat, sizeof(struct adw_control),\n\t\t\t   NBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to allocate control structures,\"\n\t\t       \" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,\n\t\t   sizeof(struct adw_control), (caddr_t *) & sc->sc_control,\n\t\t\t\t BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: unable to map control structures, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\t/*\n         * Create and load the DMA map used for the control blocks.\n         */\n\tif ((error = bus_dmamap_create(sc->sc_dmat, sizeof(struct adw_control),\n\t\t\t   1, sizeof(struct adw_control), 0, BUS_DMA_NOWAIT,\n\t\t\t\t       &sc->sc_dmamap_control)) != 0) {\n\t\tprintf(\"%s: unable to create control DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap_control,\n\t\t\t   sc->sc_control, sizeof(struct adw_control), NULL,\n\t\t\t\t     BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to load control DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_INIT",
          "args": [
            "&sc->sc_queue"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->sc_waiting_ccb"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->sc_free_ccb"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adw_alloc_controls;\nstatic int adw_alloc_carriers;\nstatic int adw_create_carriers;\nstatic int adw_create_ccbs;\nstatic int adw_scsi_cmd;\nstatic void adwminphys;\nstruct scsi_device adw_dev =\n{\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nvoid\nadw_attach(sc)\n\tADW_SOFTC      *sc;\n{\n\tint             i, error;\n\n\n\tTAILQ_INIT(&sc->sc_free_ccb);\n\tTAILQ_INIT(&sc->sc_waiting_ccb);\n\tLIST_INIT(&sc->sc_queue);\n\n\n\t/*\n         * Allocate the Control Blocks.\n         */\n\terror = adw_alloc_controls(sc);\n\tif (error)\n\t\treturn; /* (error) */ ;\n\n\tbzero(sc->sc_control, sizeof(struct adw_control));\n\n\t/*\n\t * Create and initialize the Control Blocks.\n\t */\n\ti = adw_create_ccbs(sc, sc->sc_control->ccbs, ADW_MAX_CCB);\n\tif (i == 0) {\n\t\tprintf(\"%s: unable to create Control Blocks\\n\",\n\t\t       sc->sc_dev.dv_xname);\n\t\treturn; /* (ENOMEM) */ ;\n\t} else if (i != ADW_MAX_CCB) {\n\t\tprintf(\"%s: WARNING: only %d of %d Control Blocks\"\n\t\t       \" created\\n\",\n\t\t       sc->sc_dev.dv_xname, i, ADW_MAX_CCB);\n\t}\n\n\t/*\n\t * Create and initialize the Carriers.\n\t */\n\terror = adw_alloc_carriers(sc);\n\tif (error)\n\t\treturn; /* (error) */ ;\n\n\tbzero(sc->sc_control->carriers, ADW_CARRIER_SIZE * ADW_MAX_CARRIER);\n\n\ti = adw_create_carriers(sc);\n\tif (i == 0) {\n\t\tprintf(\"%s: unable to create Carriers\\n\",\n\t\t       sc->sc_dev.dv_xname);\n\t\treturn; /* (ENOMEM) */ ;\n\t} else if (i != ADW_MAX_CARRIER) {\n\t\tprintf(\"%s: WARNING: only %d of %d Carriers created\\n\",\n\t\t       sc->sc_dev.dv_xname, i, ADW_MAX_CARRIER);\n\t}\n\n\n\t/*\n\t * Initialize the ASC3550.\n\t */\n\terror = (sc->chip_type == ADV_CHIP_ASC3550)?\n\t\t\tAdvInitAsc3550Driver(sc) :\n\t\t\tAdvInitAsc38C0800Driver(sc);\n\tswitch (error) {\n\tcase ASC_IERR_MCODE_CHKSUM:\n\t\tpanic(\"%s: Microcode checksum error\",\n\t\t      sc->sc_dev.dv_xname);\n\t\tbreak;\n\n\tcase ASC_IERR_ILLEGAL_CONNECTION:\n\t\tpanic(\"%s: All three connectors are in use\",\n\t\t      sc->sc_dev.dv_xname);\n\t\tbreak;\n\n\tcase ASC_IERR_REVERSED_CABLE:\n\t\tpanic(\"%s: Cable is reversed\",\n\t\t      sc->sc_dev.dv_xname);\n\t\tbreak;\n\n\tcase ASC_IERR_SINGLE_END_DEVICE:\n\t\tpanic(\"%s: single-ended device is attached to\"\n\t\t      \" one of the connectors\",\n\t\t      sc->sc_dev.dv_xname);\n\t\tbreak;\n\n\tcase ASC_IERR_NO_CARRIER:\n\t\tpanic(\"%s: no carrier\",\n\t\t      sc->sc_dev.dv_xname);\n\t\tbreak;\n\n\tcase ASC_WARN_BUSRESET_ERROR:\n\t\tprintf(\"%s: WARNING: Bus Reset Error\\n\",\n\t\t      sc->sc_dev.dv_xname);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Fill in the adapter.\n\t */\n\tsc->sc_adapter.scsi_cmd = adw_scsi_cmd;\n\tsc->sc_adapter.scsi_minphys = adwminphys;\n\n\t/*\n         * fill in the prototype scsi_link.\n         */\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->chip_scsi_id;\n\tsc->sc_link.adapter = &sc->sc_adapter;\n\tsc->sc_link.device = &adw_dev;\n\tsc->sc_link.openings = 4;\n\tsc->sc_link.adapter_buswidth = ADW_MAX_TID+1;\n\n\tconfig_found(&sc->sc_dev, &sc->sc_link, scsiprint);\n}"
  },
  {
    "function_name": "adw_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "568-606",
    "snippet": "int\nadw_init(sc)\n\tADW_SOFTC      *sc;\n{\n\tu_int16_t       warn_code;\n\n\n\tsc->cfg.lib_version = (ADW_LIB_VERSION_MAJOR << 8) |\n\t\tADW_LIB_VERSION_MINOR;\n\tsc->cfg.chip_version =\n\t\tADW_GET_CHIP_VERSION(sc->sc_iot, sc->sc_ioh, sc->bus_type);\n\n\t/*\n\t * Reset the chip to start and allow register writes.\n\t */\n\tif (ADW_FIND_SIGNATURE(sc->sc_iot, sc->sc_ioh) == 0) {\n\t\tpanic(\"adw_init: adw_find_signature failed\");\n\t} else {\n\t\tAdvResetChip(sc->sc_iot, sc->sc_ioh);\n\n\t\twarn_code = (sc->chip_type == ADV_CHIP_ASC3550)?\n\t\t\t\tAdvInitFrom3550EEP(sc) :\n\t\t\t\tAdvInitFrom38C0800EEP(sc);\n\n\t\tif (warn_code & ASC_WARN_EEPROM_CHKSUM)\n\t\t\tprintf(\"%s: Bad checksum found. \"\n\t\t\t       \"Setting default values\\n\",\n\t\t\t       sc->sc_dev.dv_xname);\n\t\tif (warn_code & ASC_WARN_EEPROM_TERMINATION)\n\t\t\tprintf(\"%s: Bad bus termination setting.\"\n\t\t\t       \"Using automatic termination.\\n\",\n\t\t\t       sc->sc_dev.dv_xname);\n\t}\n\n\tsc->isr_callback = (ADW_CALLBACK) adw_isr_callback;\n\tsc->async_callback = (ADW_CALLBACK) adw_async_callback;\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adw_isr_callback",
      "static void adw_async_callback",
      "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
      "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
      "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
      "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: Bad bus termination setting.\"\n\t\t\t       \"Using automatic termination.\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AdvInitFrom38C0800EEP",
          "args": [
            "sc"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "AdvInitFrom38C0800EEP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "1424-1618",
          "snippet": "int\nAdvInitFrom38C0800EEP(sc)\nADW_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t\t\twarn_code;\n\tADW_EEP_38C0800_CONFIG\teep_config;\n\tint\t\t\ti;\n\tu_int8_t\t\ttid, termination;\n\tu_int16_t\t\tsdtr_speed = 0;\n\n\n\twarn_code = 0;\n\n\t/*\n\t * Read the board's EEPROM configuration.\n\t *\n\t * Set default values if a bad checksum is found.\n\t */\n\tif (AdvGet38C0800EEPConfig(iot, ioh, &eep_config) != \n\t\t\teep_config.check_sum) {\n\t\twarn_code |= ASC_WARN_EEPROM_CHKSUM;\n\n\t\t/*\n\t\t * Set EEPROM default values.\n\t\t */\n\t\tfor (i = 0; i < sizeof(ADW_EEP_38C0800_CONFIG); i++) {\n\t\t\t*((u_int8_t *) &eep_config + i) =\n\t\t\t\t*((u_int8_t *)&Default_38C0800_EEPROM_Config+i);\n\t\t}\n\n\t\t/*\n\t\t * Assume the 6 byte board serial number that was read\n\t\t * from EEPROM is correct even if the EEPROM checksum\n\t\t * failed.\n\t\t */\n\t\teep_config.serial_number_word3 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 1);\n\n\t\teep_config.serial_number_word2 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 2);\n\n\t\teep_config.serial_number_word1 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 3);\n\n\t\tAdvSet38C0800EEPConfig(iot, ioh, &eep_config);\n\t}\n\t/*\n\t * Set ADV_DVC_VAR and ADV_DVC_CFG variables from the\n\t * EEPROM configuration that was read.\n\t *\n\t * This is the mapping of EEPROM fields to Adv Library fields.\n\t */\n\tsc->wdtr_able = eep_config.wdtr_able;\n\tsc->sdtr_speed1 = eep_config.sdtr_speed1;\n\tsc->sdtr_speed2 = eep_config.sdtr_speed2;\n\tsc->sdtr_speed3 = eep_config.sdtr_speed3;\n\tsc->sdtr_speed4 = eep_config.sdtr_speed4;\n\tsc->tagqng_able = eep_config.tagqng_able;\n\tsc->cfg.disc_enable = eep_config.disc_enable;\n\tsc->max_host_qng = eep_config.max_host_qng;\n\tsc->max_dvc_qng = eep_config.max_dvc_qng;\n\tsc->chip_scsi_id = (eep_config.adapter_scsi_id & ADW_MAX_TID);\n\tsc->start_motor = eep_config.start_motor;\n\tsc->scsi_reset_wait = eep_config.scsi_reset_delay;\n\tsc->bios_ctrl = eep_config.bios_ctrl;\n\tsc->no_scam = eep_config.scam_tolerant;\n\tsc->cfg.serial1 = eep_config.serial_number_word1;\n\tsc->cfg.serial2 = eep_config.serial_number_word2;\n\tsc->cfg.serial3 = eep_config.serial_number_word3;\n\n\t/*\n\t * For every Target ID if any of its 'sdtr_speed[1234]' bits\n\t * are set, then set an 'sdtr_able' bit for it.\n\t */\n\tsc->sdtr_able = 0;\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tif (tid == 0) {\n\t\t\tsdtr_speed = sc->sdtr_speed1;\n\t\t} else if (tid == 4) {\n\t\t\tsdtr_speed = sc->sdtr_speed2;\n\t\t} else if (tid == 8) {\n\t\t\tsdtr_speed = sc->sdtr_speed3;\n\t\t} else if (tid == 12) {\n\t\t\tsdtr_speed = sc->sdtr_speed4;\n\t\t}\n\t\tif (sdtr_speed & ADW_MAX_TID) {\n\t\t\tsc->sdtr_able |= (1 << tid);\n\t\t}\n\t\tsdtr_speed >>= 4;\n\t}\n\n\t/*\n\t * Set the host maximum queuing (max. 253, min. 16) and the per device\n\t * maximum queuing (max. 63, min. 4).\n\t */\n\tif (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {\n\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_host_qng == 0) {\n\t\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t\t} else {\n\t\t\teep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;\n\t\t}\n\t}\n\n\tif (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {\n\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_dvc_qng == 0) {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t\t} else {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;\n\t\t}\n\t}\n\n\t/*\n\t * If 'max_dvc_qng' is greater than 'max_host_qng', then\n\t * set 'max_dvc_qng' to 'max_host_qng'.\n\t */\n\tif (eep_config.max_dvc_qng > eep_config.max_host_qng) {\n\t\teep_config.max_dvc_qng = eep_config.max_host_qng;\n\t}\n\n\t/*\n\t * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'\n\t * values based on possibly adjusted EEPROM values.\n\t */\n\tsc->max_host_qng = eep_config.max_host_qng;\n\tsc->max_dvc_qng = eep_config.max_dvc_qng;\n\n\t/*\n\t * If the EEPROM 'termination' field is set to automatic (0), then set\n\t * the ADV_DVC_CFG 'termination' field to automatic also.\n\t *\n\t * If the termination is specified with a non-zero 'termination'\n\t * value check that a legal value is set and set the ADV_DVC_CFG\n\t * 'termination' field appropriately.\n\t */\n\tif (eep_config.termination_se == 0) {\n\t\ttermination = 0;\t/* auto termination for SE */\n\t} else {\n\t\t/* Enable manual control with low off / high off. */\n\t\tif (eep_config.termination_se == 1) {\n\t\t\ttermination = 0;\n\n\t\t/* Enable manual control with low off / high on. */\n\t\t} else if (eep_config.termination_se == 2) {\n\t\t\ttermination = ADW_TERM_SE_HI;\n\n\t\t/* Enable manual control with low on / high on. */\n\t\t} else if (eep_config.termination_se == 3) {\n\t\t\ttermination = ADW_TERM_SE;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The EEPROM 'termination_se' field contains \n\t\t\t * a bad value.\n\t\t\t * Use automatic termination instead.\n\t\t\t */\n\t\t\ttermination = 0;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\tif (eep_config.termination_lvd == 0) {\n\t\t/* auto termination for LVD */\n\t\tsc->cfg.termination = termination;\n\t} else\n\t{\n\t\t/* Enable manual control with low off / high off. */\n\t\tif (eep_config.termination_lvd == 1) {\n\t\t\tsc->cfg.termination = termination;\n\n\t\t/* Enable manual control with low off / high on. */\n\t\t} else if (eep_config.termination_lvd == 2) {\n\t\t\tsc->cfg.termination = termination | ADW_TERM_LVD_HI;\n\n\t\t/* Enable manual control with low on / high on. */\n\t\t} else if (eep_config.termination_lvd == 3) {\n\t\t\tsc->cfg.termination = termination | ADW_TERM_LVD;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The EEPROM 'termination_lvd' field contains a bad value.\n\t\t\t * Use automatic termination instead.\n\t\t\t */\n\t\t\tsc->cfg.termination = termination;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\treturn warn_code;\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int16_t AdvGet38C0800EEPConfig",
            "static u_int16_t AdvReadEEPWord",
            "static void AdvSet38C0800EEPConfig",
            "static ADW_EEP_38C0800_CONFIG\nDefault_38C0800_EEPROM_Config = {\n\tADW_EEPROM_BIOS_ENABLE,\t/* 00 cfg_lsw */\n\t0x0000,\t\t\t/* 01 cfg_msw */\n\t0xFFFF,\t\t\t/* 02 disc_enable */\n\t0xFFFF,\t\t\t/* 03 wdtr_able */\n\t0x4444,\t\t\t/* 04 sdtr_speed1 */\n\t0xFFFF,\t\t\t/* 05 start_motor */\n\t0xFFFF,\t\t\t/* 06 tagqng_able */\n\t0xFFFF,\t\t\t/* 07 bios_scan */\n\t0,\t\t\t/* 08 scam_tolerant */\n\t7,\t\t\t/* 09 adapter_scsi_id */\n\t0,\t\t\t/*    bios_boot_delay */\n\t3,\t\t\t/* 10 scsi_reset_delay */\n\t0,\t\t\t/*    bios_id_lun */\n\t0,\t\t\t/* 11 termination_se */\n\t0,\t\t\t/*    termination_lvd */\n\t0xFFE7,\t\t\t/* 12 bios_ctrl */\n\t0x4444,\t\t\t/* 13 sdtr_speed2 */\n\t0x4444,\t\t\t/* 14 sdtr_speed3 */\n\tASC_DEF_MAX_HOST_QNG,\t/* 15 max_host_qng */\n\tASC_DEF_MAX_DVC_QNG,\t/*    max_dvc_qng */\n\t0,\t\t\t/* 16 dvc_cntl */\n\t0x4444,\t\t\t/* 17 sdtr_speed4 */\n\t0,\t\t\t/* 18 serial_number_word1 */\n\t0,\t\t\t/* 19 serial_number_word2 */\n\t0,\t\t\t/* 20 serial_number_word3 */\n\t0,\t\t\t/* 21 check_sum */\n\t{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, /* 22-29 oem_name[16] */\n\t0,\t\t\t/* 30 dvc_err_code */\n\t0,\t\t\t/* 31 adv_err_code */\n\t0,\t\t\t/* 32 adv_err_addr */\n\t0,\t\t\t/* 33 saved_dvc_err_code */\n\t0,\t\t\t/* 34 saved_adv_err_code */\n\t0,\t\t\t/* 35 saved_adv_err_addr */\n\t0,\t\t\t/* 36 reserved */\n\t0,\t\t\t/* 37 reserved */\n\t0,\t\t\t/* 38 reserved */\n\t0,\t\t\t/* 39 reserved */\n\t0,\t\t\t/* 40 reserved */\n\t0,\t\t\t/* 41 reserved */\n\t0,\t\t\t/* 42 reserved */\n\t0,\t\t\t/* 43 reserved */\n\t0,\t\t\t/* 44 reserved */\n\t0,\t\t\t/* 45 reserved */\n\t0,\t\t\t/* 46 reserved */\n\t0,\t\t\t/* 47 reserved */\n\t0,\t\t\t/* 48 reserved */\n\t0,\t\t\t/* 49 reserved */\n\t0,\t\t\t/* 50 reserved */\n\t0,\t\t\t/* 51 reserved */\n\t0,\t\t\t/* 52 reserved */\n\t0,\t\t\t/* 53 reserved */\n\t0,\t\t\t/* 54 reserved */\n\t0,\t\t\t/* 55 reserved */\n\t0,\t\t\t/* 56 cisptr_lsw */\n\t0,\t\t\t/* 57 cisprt_msw */\n\tPCI_VENDOR_ADVSYS,\t/* 58 subsysvid */\n\tPCI_PRODUCT_ADVSYS_U2W,\t/* 59 subsysid */\n\t0,\t\t\t/* 60 reserved */\n\t0,\t\t\t/* 61 reserved */\n\t0,\t\t\t/* 62 reserved */\n\t0\t\t\t/* 63 reserved */\n};",
            "ADW_SOFTC\t*sc;",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;",
            "u_int8_t\t\ttid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic u_int16_t AdvGet38C0800EEPConfig;\nstatic u_int16_t AdvReadEEPWord;\nstatic void AdvSet38C0800EEPConfig;\nstatic ADW_EEP_38C0800_CONFIG\nDefault_38C0800_EEPROM_Config = {\n\tADW_EEPROM_BIOS_ENABLE,\t/* 00 cfg_lsw */\n\t0x0000,\t\t\t/* 01 cfg_msw */\n\t0xFFFF,\t\t\t/* 02 disc_enable */\n\t0xFFFF,\t\t\t/* 03 wdtr_able */\n\t0x4444,\t\t\t/* 04 sdtr_speed1 */\n\t0xFFFF,\t\t\t/* 05 start_motor */\n\t0xFFFF,\t\t\t/* 06 tagqng_able */\n\t0xFFFF,\t\t\t/* 07 bios_scan */\n\t0,\t\t\t/* 08 scam_tolerant */\n\t7,\t\t\t/* 09 adapter_scsi_id */\n\t0,\t\t\t/*    bios_boot_delay */\n\t3,\t\t\t/* 10 scsi_reset_delay */\n\t0,\t\t\t/*    bios_id_lun */\n\t0,\t\t\t/* 11 termination_se */\n\t0,\t\t\t/*    termination_lvd */\n\t0xFFE7,\t\t\t/* 12 bios_ctrl */\n\t0x4444,\t\t\t/* 13 sdtr_speed2 */\n\t0x4444,\t\t\t/* 14 sdtr_speed3 */\n\tASC_DEF_MAX_HOST_QNG,\t/* 15 max_host_qng */\n\tASC_DEF_MAX_DVC_QNG,\t/*    max_dvc_qng */\n\t0,\t\t\t/* 16 dvc_cntl */\n\t0x4444,\t\t\t/* 17 sdtr_speed4 */\n\t0,\t\t\t/* 18 serial_number_word1 */\n\t0,\t\t\t/* 19 serial_number_word2 */\n\t0,\t\t\t/* 20 serial_number_word3 */\n\t0,\t\t\t/* 21 check_sum */\n\t{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, /* 22-29 oem_name[16] */\n\t0,\t\t\t/* 30 dvc_err_code */\n\t0,\t\t\t/* 31 adv_err_code */\n\t0,\t\t\t/* 32 adv_err_addr */\n\t0,\t\t\t/* 33 saved_dvc_err_code */\n\t0,\t\t\t/* 34 saved_adv_err_code */\n\t0,\t\t\t/* 35 saved_adv_err_addr */\n\t0,\t\t\t/* 36 reserved */\n\t0,\t\t\t/* 37 reserved */\n\t0,\t\t\t/* 38 reserved */\n\t0,\t\t\t/* 39 reserved */\n\t0,\t\t\t/* 40 reserved */\n\t0,\t\t\t/* 41 reserved */\n\t0,\t\t\t/* 42 reserved */\n\t0,\t\t\t/* 43 reserved */\n\t0,\t\t\t/* 44 reserved */\n\t0,\t\t\t/* 45 reserved */\n\t0,\t\t\t/* 46 reserved */\n\t0,\t\t\t/* 47 reserved */\n\t0,\t\t\t/* 48 reserved */\n\t0,\t\t\t/* 49 reserved */\n\t0,\t\t\t/* 50 reserved */\n\t0,\t\t\t/* 51 reserved */\n\t0,\t\t\t/* 52 reserved */\n\t0,\t\t\t/* 53 reserved */\n\t0,\t\t\t/* 54 reserved */\n\t0,\t\t\t/* 55 reserved */\n\t0,\t\t\t/* 56 cisptr_lsw */\n\t0,\t\t\t/* 57 cisprt_msw */\n\tPCI_VENDOR_ADVSYS,\t/* 58 subsysvid */\n\tPCI_PRODUCT_ADVSYS_U2W,\t/* 59 subsysid */\n\t0,\t\t\t/* 60 reserved */\n\t0,\t\t\t/* 61 reserved */\n\t0,\t\t\t/* 62 reserved */\n\t0\t\t\t/* 63 reserved */\n};\nADW_SOFTC\t*sc;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\nu_int8_t\t\ttid;\n\nint\nAdvInitFrom38C0800EEP(sc)\nADW_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t\t\twarn_code;\n\tADW_EEP_38C0800_CONFIG\teep_config;\n\tint\t\t\ti;\n\tu_int8_t\t\ttid, termination;\n\tu_int16_t\t\tsdtr_speed = 0;\n\n\n\twarn_code = 0;\n\n\t/*\n\t * Read the board's EEPROM configuration.\n\t *\n\t * Set default values if a bad checksum is found.\n\t */\n\tif (AdvGet38C0800EEPConfig(iot, ioh, &eep_config) != \n\t\t\teep_config.check_sum) {\n\t\twarn_code |= ASC_WARN_EEPROM_CHKSUM;\n\n\t\t/*\n\t\t * Set EEPROM default values.\n\t\t */\n\t\tfor (i = 0; i < sizeof(ADW_EEP_38C0800_CONFIG); i++) {\n\t\t\t*((u_int8_t *) &eep_config + i) =\n\t\t\t\t*((u_int8_t *)&Default_38C0800_EEPROM_Config+i);\n\t\t}\n\n\t\t/*\n\t\t * Assume the 6 byte board serial number that was read\n\t\t * from EEPROM is correct even if the EEPROM checksum\n\t\t * failed.\n\t\t */\n\t\teep_config.serial_number_word3 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 1);\n\n\t\teep_config.serial_number_word2 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 2);\n\n\t\teep_config.serial_number_word1 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 3);\n\n\t\tAdvSet38C0800EEPConfig(iot, ioh, &eep_config);\n\t}\n\t/*\n\t * Set ADV_DVC_VAR and ADV_DVC_CFG variables from the\n\t * EEPROM configuration that was read.\n\t *\n\t * This is the mapping of EEPROM fields to Adv Library fields.\n\t */\n\tsc->wdtr_able = eep_config.wdtr_able;\n\tsc->sdtr_speed1 = eep_config.sdtr_speed1;\n\tsc->sdtr_speed2 = eep_config.sdtr_speed2;\n\tsc->sdtr_speed3 = eep_config.sdtr_speed3;\n\tsc->sdtr_speed4 = eep_config.sdtr_speed4;\n\tsc->tagqng_able = eep_config.tagqng_able;\n\tsc->cfg.disc_enable = eep_config.disc_enable;\n\tsc->max_host_qng = eep_config.max_host_qng;\n\tsc->max_dvc_qng = eep_config.max_dvc_qng;\n\tsc->chip_scsi_id = (eep_config.adapter_scsi_id & ADW_MAX_TID);\n\tsc->start_motor = eep_config.start_motor;\n\tsc->scsi_reset_wait = eep_config.scsi_reset_delay;\n\tsc->bios_ctrl = eep_config.bios_ctrl;\n\tsc->no_scam = eep_config.scam_tolerant;\n\tsc->cfg.serial1 = eep_config.serial_number_word1;\n\tsc->cfg.serial2 = eep_config.serial_number_word2;\n\tsc->cfg.serial3 = eep_config.serial_number_word3;\n\n\t/*\n\t * For every Target ID if any of its 'sdtr_speed[1234]' bits\n\t * are set, then set an 'sdtr_able' bit for it.\n\t */\n\tsc->sdtr_able = 0;\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tif (tid == 0) {\n\t\t\tsdtr_speed = sc->sdtr_speed1;\n\t\t} else if (tid == 4) {\n\t\t\tsdtr_speed = sc->sdtr_speed2;\n\t\t} else if (tid == 8) {\n\t\t\tsdtr_speed = sc->sdtr_speed3;\n\t\t} else if (tid == 12) {\n\t\t\tsdtr_speed = sc->sdtr_speed4;\n\t\t}\n\t\tif (sdtr_speed & ADW_MAX_TID) {\n\t\t\tsc->sdtr_able |= (1 << tid);\n\t\t}\n\t\tsdtr_speed >>= 4;\n\t}\n\n\t/*\n\t * Set the host maximum queuing (max. 253, min. 16) and the per device\n\t * maximum queuing (max. 63, min. 4).\n\t */\n\tif (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {\n\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_host_qng == 0) {\n\t\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t\t} else {\n\t\t\teep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;\n\t\t}\n\t}\n\n\tif (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {\n\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_dvc_qng == 0) {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t\t} else {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;\n\t\t}\n\t}\n\n\t/*\n\t * If 'max_dvc_qng' is greater than 'max_host_qng', then\n\t * set 'max_dvc_qng' to 'max_host_qng'.\n\t */\n\tif (eep_config.max_dvc_qng > eep_config.max_host_qng) {\n\t\teep_config.max_dvc_qng = eep_config.max_host_qng;\n\t}\n\n\t/*\n\t * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'\n\t * values based on possibly adjusted EEPROM values.\n\t */\n\tsc->max_host_qng = eep_config.max_host_qng;\n\tsc->max_dvc_qng = eep_config.max_dvc_qng;\n\n\t/*\n\t * If the EEPROM 'termination' field is set to automatic (0), then set\n\t * the ADV_DVC_CFG 'termination' field to automatic also.\n\t *\n\t * If the termination is specified with a non-zero 'termination'\n\t * value check that a legal value is set and set the ADV_DVC_CFG\n\t * 'termination' field appropriately.\n\t */\n\tif (eep_config.termination_se == 0) {\n\t\ttermination = 0;\t/* auto termination for SE */\n\t} else {\n\t\t/* Enable manual control with low off / high off. */\n\t\tif (eep_config.termination_se == 1) {\n\t\t\ttermination = 0;\n\n\t\t/* Enable manual control with low off / high on. */\n\t\t} else if (eep_config.termination_se == 2) {\n\t\t\ttermination = ADW_TERM_SE_HI;\n\n\t\t/* Enable manual control with low on / high on. */\n\t\t} else if (eep_config.termination_se == 3) {\n\t\t\ttermination = ADW_TERM_SE;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The EEPROM 'termination_se' field contains \n\t\t\t * a bad value.\n\t\t\t * Use automatic termination instead.\n\t\t\t */\n\t\t\ttermination = 0;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\tif (eep_config.termination_lvd == 0) {\n\t\t/* auto termination for LVD */\n\t\tsc->cfg.termination = termination;\n\t} else\n\t{\n\t\t/* Enable manual control with low off / high off. */\n\t\tif (eep_config.termination_lvd == 1) {\n\t\t\tsc->cfg.termination = termination;\n\n\t\t/* Enable manual control with low off / high on. */\n\t\t} else if (eep_config.termination_lvd == 2) {\n\t\t\tsc->cfg.termination = termination | ADW_TERM_LVD_HI;\n\n\t\t/* Enable manual control with low on / high on. */\n\t\t} else if (eep_config.termination_lvd == 3) {\n\t\t\tsc->cfg.termination = termination | ADW_TERM_LVD;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The EEPROM 'termination_lvd' field contains a bad value.\n\t\t\t * Use automatic termination instead.\n\t\t\t */\n\t\t\tsc->cfg.termination = termination;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\treturn warn_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AdvInitFrom3550EEP",
          "args": [
            "sc"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "AdvInitFrom3550EEP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "1265-1409",
          "snippet": "int\nAdvInitFrom3550EEP(sc)\nADW_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t\t\twarn_code;\n\tADW_EEP_3550_CONFIG\teep_config;\n\tint\t\t\ti;\n\n\n\twarn_code = 0;\n\n\t/*\n\t * Read the board's EEPROM configuration.\n\t *\n\t * Set default values if a bad checksum is found.\n\t */\n\tif (AdvGet3550EEPConfig(iot, ioh, &eep_config) != eep_config.check_sum){\n\t\twarn_code |= ASC_WARN_EEPROM_CHKSUM;\n\n\t\t/*\n\t\t * Set EEPROM default values.\n\t\t */\n\t\tfor (i = 0; i < sizeof(ADW_EEP_3550_CONFIG); i++) {\n\t\t\t*((u_int8_t *) &eep_config + i) =\n\t\t\t\t*((u_int8_t *) &Default_3550_EEPROM_Config + i);\n\t\t}\n\n\t\t/*\n\t\t * Assume the 6 byte board serial number that was read\n\t\t * from EEPROM is correct even if the EEPROM checksum\n\t\t * failed.\n\t\t */\n\t\teep_config.serial_number_word3 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 1);\n\n\t\teep_config.serial_number_word2 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 2);\n\n\t\teep_config.serial_number_word1 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 3);\n\n\t\tAdvSet3550EEPConfig(iot, ioh, &eep_config);\n\t}\n\t/*\n\t * Set sc_VAR and sc_CFG variables from the\n\t * EEPROM configuration that was read.\n\t *\n\t * This is the mapping of EEPROM fields to Adv Library fields.\n\t */\n\tsc->wdtr_able = eep_config.wdtr_able;\n\tsc->sdtr_able = eep_config.sdtr_able;\n\tsc->ultra_able = eep_config.ultra_able;\n\tsc->tagqng_able = eep_config.tagqng_able;\n\tsc->cfg.disc_enable = eep_config.disc_enable;\n\tsc->max_host_qng = eep_config.max_host_qng;\n\tsc->max_dvc_qng = eep_config.max_dvc_qng;\n\tsc->chip_scsi_id = (eep_config.adapter_scsi_id & ADW_MAX_TID);\n\tsc->start_motor = eep_config.start_motor;\n\tsc->scsi_reset_wait = eep_config.scsi_reset_delay;\n\tsc->bios_ctrl = eep_config.bios_ctrl;\n\tsc->no_scam = eep_config.scam_tolerant;\n\tsc->cfg.serial1 = eep_config.serial_number_word1;\n\tsc->cfg.serial2 = eep_config.serial_number_word2;\n\tsc->cfg.serial3 = eep_config.serial_number_word3;\n\n\t/*\n\t * Set the host maximum queuing (max. 253, min. 16) and the per device\n\t * maximum queuing (max. 63, min. 4).\n\t */\n\tif (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {\n\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG)\n\t{\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_host_qng == 0) {\n\t\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t\t} else {\n\t\t\teep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;\n\t\t}\n\t}\n\n\tif (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {\n\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_dvc_qng == 0) {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t\t} else {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;\n\t\t}\n\t}\n\n\t/*\n\t * If 'max_dvc_qng' is greater than 'max_host_qng', then\n\t * set 'max_dvc_qng' to 'max_host_qng'.\n\t */\n\tif (eep_config.max_dvc_qng > eep_config.max_host_qng) {\n\t\teep_config.max_dvc_qng = eep_config.max_host_qng;\n\t}\n\n\t/*\n\t * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'\n\t * values based on possibly adjusted EEPROM values.\n\t */\n\tsc->max_host_qng = eep_config.max_host_qng;\n\tsc->max_dvc_qng = eep_config.max_dvc_qng;\n\n\n\t/*\n\t * If the EEPROM 'termination' field is set to automatic (0), then set\n\t * the ADV_DVC_CFG 'termination' field to automatic also.\n\t *\n\t * If the termination is specified with a non-zero 'termination'\n\t * value check that a legal value is set and set the ADV_DVC_CFG\n\t * 'termination' field appropriately.\n\t */\n\tif (eep_config.termination == 0) {\n\t\tsc->cfg.termination = 0;    /* auto termination */\n\t} else {\n\t\t/* Enable manual control with low off / high off. */\n\t\tif (eep_config.termination == 1) {\n\t\t\tsc->cfg.termination = ADW_TERM_CTL_SEL;\n\n\t\t/* Enable manual control with low off / high on. */\n\t\t} else if (eep_config.termination == 2) {\n\t\t\tsc->cfg.termination = ADW_TERM_CTL_SEL | ADW_TERM_CTL_H;\n\n\t\t/* Enable manual control with low on / high on. */\n\t\t} else if (eep_config.termination == 3) {\n\t\t\tsc->cfg.termination = ADW_TERM_CTL_SEL |\n\t\t\t\t\tADW_TERM_CTL_H | ADW_TERM_CTL_L;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The EEPROM 'termination' field contains a bad value. Use\n\t\t\t * automatic termination instead.\n\t\t\t */\n\t\t\tsc->cfg.termination = 0;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\treturn warn_code;\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int16_t AdvGet3550EEPConfig",
            "static u_int16_t AdvReadEEPWord",
            "static void AdvSet3550EEPConfig",
            "static ADW_EEP_3550_CONFIG\nDefault_3550_EEPROM_Config = {\n\tADW_EEPROM_BIOS_ENABLE,\t/* cfg_lsw */\n\t0x0000,\t\t\t/* cfg_msw */\n\t0xFFFF,\t\t\t/* disc_enable */\n\t0xFFFF,\t\t\t/* wdtr_able */\n\t0xFFFF,\t\t\t/* sdtr_able */\n\t0xFFFF,\t\t\t/* start_motor */\n\t0xFFFF,\t\t\t/* tagqng_able */\n\t0xFFFF,\t\t\t/* bios_scan */\n\t0,\t\t\t/* scam_tolerant */\n\t7,\t\t\t/* adapter_scsi_id */\n\t0,\t\t\t/* bios_boot_delay */\n\t3,\t\t\t/* scsi_reset_delay */\n\t0,\t\t\t/* bios_id_lun */\n\t0,\t\t\t/* termination */\n\t0,\t\t\t/* reserved1 */\n\t0xFFE7,\t\t\t/* bios_ctrl */\n\t0xFFFF,\t\t\t/* ultra_able */\n\t0,\t\t\t/* reserved2 */\n\tASC_DEF_MAX_HOST_QNG,\t/* max_host_qng */\n\tASC_DEF_MAX_DVC_QNG,\t/* max_dvc_qng */\n\t0,\t\t\t/* dvc_cntl */\n\t0,\t\t\t/* bug_fix */\n\t0,\t\t\t/* serial_number_word1 */\n\t0,\t\t\t/* serial_number_word2 */\n\t0,\t\t\t/* serial_number_word3 */\n\t0,\t\t\t/* check_sum */\n\t{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, /* oem_name[16] */\n\t0,\t\t\t/* dvc_err_code */\n\t0,\t\t\t/* adv_err_code */\n\t0,\t\t\t/* adv_err_addr */\n\t0,\t\t\t/* saved_dvc_err_code */\n\t0,\t\t\t/* saved_adv_err_code */\n\t0,\t\t\t/* saved_adv_err_addr */\n\t0\t\t\t/* num_of_err */\n};",
            "ADW_SOFTC\t*sc;",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic u_int16_t AdvGet3550EEPConfig;\nstatic u_int16_t AdvReadEEPWord;\nstatic void AdvSet3550EEPConfig;\nstatic ADW_EEP_3550_CONFIG\nDefault_3550_EEPROM_Config = {\n\tADW_EEPROM_BIOS_ENABLE,\t/* cfg_lsw */\n\t0x0000,\t\t\t/* cfg_msw */\n\t0xFFFF,\t\t\t/* disc_enable */\n\t0xFFFF,\t\t\t/* wdtr_able */\n\t0xFFFF,\t\t\t/* sdtr_able */\n\t0xFFFF,\t\t\t/* start_motor */\n\t0xFFFF,\t\t\t/* tagqng_able */\n\t0xFFFF,\t\t\t/* bios_scan */\n\t0,\t\t\t/* scam_tolerant */\n\t7,\t\t\t/* adapter_scsi_id */\n\t0,\t\t\t/* bios_boot_delay */\n\t3,\t\t\t/* scsi_reset_delay */\n\t0,\t\t\t/* bios_id_lun */\n\t0,\t\t\t/* termination */\n\t0,\t\t\t/* reserved1 */\n\t0xFFE7,\t\t\t/* bios_ctrl */\n\t0xFFFF,\t\t\t/* ultra_able */\n\t0,\t\t\t/* reserved2 */\n\tASC_DEF_MAX_HOST_QNG,\t/* max_host_qng */\n\tASC_DEF_MAX_DVC_QNG,\t/* max_dvc_qng */\n\t0,\t\t\t/* dvc_cntl */\n\t0,\t\t\t/* bug_fix */\n\t0,\t\t\t/* serial_number_word1 */\n\t0,\t\t\t/* serial_number_word2 */\n\t0,\t\t\t/* serial_number_word3 */\n\t0,\t\t\t/* check_sum */\n\t{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, /* oem_name[16] */\n\t0,\t\t\t/* dvc_err_code */\n\t0,\t\t\t/* adv_err_code */\n\t0,\t\t\t/* adv_err_addr */\n\t0,\t\t\t/* saved_dvc_err_code */\n\t0,\t\t\t/* saved_adv_err_code */\n\t0,\t\t\t/* saved_adv_err_addr */\n\t0\t\t\t/* num_of_err */\n};\nADW_SOFTC\t*sc;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nint\nAdvInitFrom3550EEP(sc)\nADW_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t\t\twarn_code;\n\tADW_EEP_3550_CONFIG\teep_config;\n\tint\t\t\ti;\n\n\n\twarn_code = 0;\n\n\t/*\n\t * Read the board's EEPROM configuration.\n\t *\n\t * Set default values if a bad checksum is found.\n\t */\n\tif (AdvGet3550EEPConfig(iot, ioh, &eep_config) != eep_config.check_sum){\n\t\twarn_code |= ASC_WARN_EEPROM_CHKSUM;\n\n\t\t/*\n\t\t * Set EEPROM default values.\n\t\t */\n\t\tfor (i = 0; i < sizeof(ADW_EEP_3550_CONFIG); i++) {\n\t\t\t*((u_int8_t *) &eep_config + i) =\n\t\t\t\t*((u_int8_t *) &Default_3550_EEPROM_Config + i);\n\t\t}\n\n\t\t/*\n\t\t * Assume the 6 byte board serial number that was read\n\t\t * from EEPROM is correct even if the EEPROM checksum\n\t\t * failed.\n\t\t */\n\t\teep_config.serial_number_word3 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 1);\n\n\t\teep_config.serial_number_word2 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 2);\n\n\t\teep_config.serial_number_word1 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 3);\n\n\t\tAdvSet3550EEPConfig(iot, ioh, &eep_config);\n\t}\n\t/*\n\t * Set sc_VAR and sc_CFG variables from the\n\t * EEPROM configuration that was read.\n\t *\n\t * This is the mapping of EEPROM fields to Adv Library fields.\n\t */\n\tsc->wdtr_able = eep_config.wdtr_able;\n\tsc->sdtr_able = eep_config.sdtr_able;\n\tsc->ultra_able = eep_config.ultra_able;\n\tsc->tagqng_able = eep_config.tagqng_able;\n\tsc->cfg.disc_enable = eep_config.disc_enable;\n\tsc->max_host_qng = eep_config.max_host_qng;\n\tsc->max_dvc_qng = eep_config.max_dvc_qng;\n\tsc->chip_scsi_id = (eep_config.adapter_scsi_id & ADW_MAX_TID);\n\tsc->start_motor = eep_config.start_motor;\n\tsc->scsi_reset_wait = eep_config.scsi_reset_delay;\n\tsc->bios_ctrl = eep_config.bios_ctrl;\n\tsc->no_scam = eep_config.scam_tolerant;\n\tsc->cfg.serial1 = eep_config.serial_number_word1;\n\tsc->cfg.serial2 = eep_config.serial_number_word2;\n\tsc->cfg.serial3 = eep_config.serial_number_word3;\n\n\t/*\n\t * Set the host maximum queuing (max. 253, min. 16) and the per device\n\t * maximum queuing (max. 63, min. 4).\n\t */\n\tif (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {\n\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG)\n\t{\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_host_qng == 0) {\n\t\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t\t} else {\n\t\t\teep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;\n\t\t}\n\t}\n\n\tif (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {\n\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_dvc_qng == 0) {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t\t} else {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;\n\t\t}\n\t}\n\n\t/*\n\t * If 'max_dvc_qng' is greater than 'max_host_qng', then\n\t * set 'max_dvc_qng' to 'max_host_qng'.\n\t */\n\tif (eep_config.max_dvc_qng > eep_config.max_host_qng) {\n\t\teep_config.max_dvc_qng = eep_config.max_host_qng;\n\t}\n\n\t/*\n\t * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'\n\t * values based on possibly adjusted EEPROM values.\n\t */\n\tsc->max_host_qng = eep_config.max_host_qng;\n\tsc->max_dvc_qng = eep_config.max_dvc_qng;\n\n\n\t/*\n\t * If the EEPROM 'termination' field is set to automatic (0), then set\n\t * the ADV_DVC_CFG 'termination' field to automatic also.\n\t *\n\t * If the termination is specified with a non-zero 'termination'\n\t * value check that a legal value is set and set the ADV_DVC_CFG\n\t * 'termination' field appropriately.\n\t */\n\tif (eep_config.termination == 0) {\n\t\tsc->cfg.termination = 0;    /* auto termination */\n\t} else {\n\t\t/* Enable manual control with low off / high off. */\n\t\tif (eep_config.termination == 1) {\n\t\t\tsc->cfg.termination = ADW_TERM_CTL_SEL;\n\n\t\t/* Enable manual control with low off / high on. */\n\t\t} else if (eep_config.termination == 2) {\n\t\t\tsc->cfg.termination = ADW_TERM_CTL_SEL | ADW_TERM_CTL_H;\n\n\t\t/* Enable manual control with low on / high on. */\n\t\t} else if (eep_config.termination == 3) {\n\t\t\tsc->cfg.termination = ADW_TERM_CTL_SEL |\n\t\t\t\t\tADW_TERM_CTL_H | ADW_TERM_CTL_L;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The EEPROM 'termination' field contains a bad value. Use\n\t\t\t * automatic termination instead.\n\t\t\t */\n\t\t\tsc->cfg.termination = 0;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\treturn warn_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AdvResetChip",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "AdvResetChip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "2004-2018",
          "snippet": "void\nAdvResetChip(iot, ioh)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n{\n\n\t/*\n\t * Reset Chip.\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,\n\t\t\tADW_CTRL_REG_CMD_RESET);\n\tAdvSleepMilliSecond(100);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,\n\t\t\tADW_CTRL_REG_CMD_WR_IO_REG);\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvSleepMilliSecond",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvSleepMilliSecond;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nvoid\nAdvResetChip(iot, ioh)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n{\n\n\t/*\n\t * Reset Chip.\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,\n\t\t\tADW_CTRL_REG_CMD_RESET);\n\tAdvSleepMilliSecond(100);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,\n\t\t\tADW_CTRL_REG_CMD_WR_IO_REG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"adw_init: adw_find_signature failed\""
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_FIND_SIGNATURE",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_GET_CHIP_VERSION",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "sc->bus_type"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_isr_callback;\nstatic void adw_async_callback;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nint\nadw_init(sc)\n\tADW_SOFTC      *sc;\n{\n\tu_int16_t       warn_code;\n\n\n\tsc->cfg.lib_version = (ADW_LIB_VERSION_MAJOR << 8) |\n\t\tADW_LIB_VERSION_MINOR;\n\tsc->cfg.chip_version =\n\t\tADW_GET_CHIP_VERSION(sc->sc_iot, sc->sc_ioh, sc->bus_type);\n\n\t/*\n\t * Reset the chip to start and allow register writes.\n\t */\n\tif (ADW_FIND_SIGNATURE(sc->sc_iot, sc->sc_ioh) == 0) {\n\t\tpanic(\"adw_init: adw_find_signature failed\");\n\t} else {\n\t\tAdvResetChip(sc->sc_iot, sc->sc_ioh);\n\n\t\twarn_code = (sc->chip_type == ADV_CHIP_ASC3550)?\n\t\t\t\tAdvInitFrom3550EEP(sc) :\n\t\t\t\tAdvInitFrom38C0800EEP(sc);\n\n\t\tif (warn_code & ASC_WARN_EEPROM_CHKSUM)\n\t\t\tprintf(\"%s: Bad checksum found. \"\n\t\t\t       \"Setting default values\\n\",\n\t\t\t       sc->sc_dev.dv_xname);\n\t\tif (warn_code & ASC_WARN_EEPROM_TERMINATION)\n\t\t\tprintf(\"%s: Bad bus termination setting.\"\n\t\t\t       \"Using automatic termination.\\n\",\n\t\t\t       sc->sc_dev.dv_xname);\n\t}\n\n\tsc->isr_callback = (ADW_CALLBACK) adw_isr_callback;\n\tsc->async_callback = (ADW_CALLBACK) adw_async_callback;\n\n\treturn (0);\n}"
  },
  {
    "function_name": "adw_queue_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "525-560",
    "snippet": "static int\nadw_queue_ccb(sc, ccb, retry)\n\tADW_SOFTC      *sc;\n\tADW_CCB        *ccb;\n\tint\t\tretry;\n{\n\tint\t\terrcode;\n\n\tif(!retry)\n\t\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\n\t\terrcode = AdvExeScsiQueue(sc, &ccb->scsiq);\n\t\tswitch(errcode) {\n\t\tcase ADW_SUCCESS:\n\t\t\tbreak;\n\n\t\tcase ADW_BUSY:\n\t\t\tprintf(\"ADW_BUSY\\n\");\n\t\t\treturn(ADW_BUSY);\n\n\t\tcase ADW_ERROR:\n\t\t\tprintf(\"ADW_ERROR\\n\");\n\t\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n\t\t\treturn(ADW_ERROR);\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(adw_timeout, ccb, (ccb->timeout * hz) / 1000);\n\t}\n\n\treturn(errcode);\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int adw_queue_ccb",
      "static void adw_timeout",
      "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
      "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
      "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
      "int             flags;",
      "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "adw_timeout",
            "ccb",
            "(ccb->timeout * hz) / 1000"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "adw_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
          "lines": "1055-1095",
          "snippet": "static void\nadw_timeout(arg)\n\tvoid           *arg;\n{\n\tADW_CCB        *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tADW_SOFTC      *sc = sc_link->adapter_softc;\n\tint             s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\t/*\n         * If it has been through before, then a previous abort has failed,\n         * don't try abort again, reset the bus instead.\n         */\n\tif (ccb->flags & CCB_ABORTED) {\n\t/*\n\t * Abort Timed Out\n\t * Lets try resetting the bus!\n\t */\n\t\tprintf(\" AGAIN. Resetting SCSI Bus\\n\");\n\t\tccb->flags &= ~CCB_ABORTED;\n\t\t/* AdvResetSCSIBus() will call sbreset_callback() */\n\t\tAdvResetSCSIBus(sc);\n\t} else {\n\t/*\n\t * Abort the operation that has timed out\n\t */\n\t\tprintf(\"\\n\");\n\t\txs->error = XS_TIMEOUT;\n\t\tccb->flags |= CCB_ABORTING;\n\t\t/* ADW_ABORT_CCB() will implicitly call isr_callback() */\n\t\tADW_ABORT_CCB(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adw_timeout",
            "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
            "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
            "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
            "int             flags;",
            "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_timeout;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nint             flags;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic void\nadw_timeout(arg)\n\tvoid           *arg;\n{\n\tADW_CCB        *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tADW_SOFTC      *sc = sc_link->adapter_softc;\n\tint             s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\t/*\n         * If it has been through before, then a previous abort has failed,\n         * don't try abort again, reset the bus instead.\n         */\n\tif (ccb->flags & CCB_ABORTED) {\n\t/*\n\t * Abort Timed Out\n\t * Lets try resetting the bus!\n\t */\n\t\tprintf(\" AGAIN. Resetting SCSI Bus\\n\");\n\t\tccb->flags &= ~CCB_ABORTED;\n\t\t/* AdvResetSCSIBus() will call sbreset_callback() */\n\t\tAdvResetSCSIBus(sc);\n\t} else {\n\t/*\n\t * Abort the operation that has timed out\n\t */\n\t\tprintf(\"\\n\");\n\t\txs->error = XS_TIMEOUT;\n\t\tccb->flags |= CCB_ABORTING;\n\t\t/* ADW_ABORT_CCB() will implicitly call isr_callback() */\n\t\tADW_ABORT_CCB(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&sc->sc_waiting_ccb",
            "ccb",
            "chain"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&sc->sc_waiting_ccb",
            "ccb",
            "chain"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ADW_ERROR\\n\""
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AdvExeScsiQueue",
          "args": [
            "sc",
            "&ccb->scsiq"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "AdvExeScsiQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "1876-2001",
          "snippet": "int\nAdvExeScsiQueue(sc, scsiq)\nADW_SOFTC\t*sc;\nADW_SCSI_REQ_Q\t*scsiq;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tADW_CCB\t\t*ccb;\n\tlong\t\treq_size;\n\tu_int32_t\treq_paddr;\n\tADW_CARRIER\t*new_carrp, *new_freep/*, *ccb_carr;\n\tint\t\ti*/;\n\n\n\t/*\n\t * The ADW_SCSI_REQ_Q 'target_id' field should never exceed ADW_MAX_TID.\n\t */\n\tif (scsiq->target_id > ADW_MAX_TID) {\n\t\tscsiq->host_status = QHSTA_M_INVALID_DEVICE;\n\t\tscsiq->done_status = QD_WITH_ERROR;\n\t\treturn ADW_ERROR;\n\t}\n\n\tccb = adw_ccb_phys_kv(sc, scsiq->ccb_ptr);\n\tccb->carr_list = sc->icq_sp;\n\n\t/*\n\t * Allocate a carrier ensuring at least one carrier always\n\t * remains on the freelist and initialize fields.\n\t */\n\tnew_carrp = sc->carr_freelist;\n        new_freep = adw_carrier_phys_kv( sc, \n\t\t\t\t\t ASC_GET_CARRP( new_carrp->next_vpa) );\n\n\tif (new_freep == NULL) {\n\t\treturn ADW_BUSY;\n\t}\n\tsc->carr_freelist = new_freep;\n\tsc->carr_pending_cnt++;\n\n\t/*\n\t * Set the carrier to be a stopper by setting 'next_vpa'\n\t * to the stopper value. The current stopper will be changed\n\t * below to point to the new stopper.\n\t */\n\tnew_carrp->next_vpa = ASC_CQ_STOPPER;\n\n\treq_size = sizeof(ADW_SCSI_REQ_Q);\n\treq_paddr = sc->sc_dmamap_control->dm_segs[0].ds_addr +\n\t\tADW_CCB_OFF(ccb) + offsetof(struct adw_ccb, scsiq);\n\n\t/* Save physical address of ADW_SCSI_REQ_Q and Carrier. */\n\tscsiq->scsiq_rptr = req_paddr;\n\n\t/*\n\t * Every ADV_CARR_T.carr_pa is byte swapped to little-endian\n\t * order during initialization.\n\t */\n\tscsiq->carr_pa = sc->icq_sp->carr_pa;\n\tscsiq->carr_va = sc->icq_sp->carr_pa;\n\n\t/*\n\t * Use the current stopper to send the ADW_SCSI_REQ_Q command to\n\t * the microcode. The newly allocated stopper will become the new\n\t * stopper.\n\t */\n\tsc->icq_sp->areq_vpa = req_paddr;\n\n\t/*\n\t * Set the 'next_vpa' pointer for the old stopper to be the\n\t * physical address of the new stopper. The RISC can only\n\t * follow physical addresses.\n\t */\n\tsc->icq_sp->next_vpa = new_carrp->carr_pa;\n\n\t/*\n\t * Set the host adapter stopper pointer to point to the new carrier.\n\t */\n\tsc->icq_sp = new_carrp;\n\n/*\tccb_carr = ccb->carr_list;\n\twhile(ccb_carr != ASC_CQ_STOPPER) {\n\t\tbus_dmamap_load(sc->sc_dmat, ccb_carr->dmamap_xfer,\n\t\t\t\tccb_carr, ADW_CARRIER_SIZE,\n\t\t\t\tNULL, BUS_DMA_NOWAIT);\n\t\tbus_dmamap_sync(sc->sc_dmat, ccb_carr->dmamap_xfer, 0,\n\t\t\t\tccb_carr->dmamap_xfer->dm_mapsize,\n\t\t\t\tBUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);\n\t\tccb_carr = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(ccb_carr->next_vpa));\n\t}\n\n\tccb_carr = sc->irq_sp;\n\tfor(i=0; i<2 && ccb_carr != ASC_CQ_STOPPER; i++) {\n\t\tbus_dmamap_load(sc->sc_dmat, ccb_carr->dmamap_xfer,\n\t\t\t\tccb_carr, ADW_CARRIER_SIZE,\n\t\t\t\tNULL, BUS_DMA_NOWAIT);\n\t\tbus_dmamap_sync(sc->sc_dmat, ccb_carr->dmamap_xfer, 0,\n\t\t\t\tccb_carr->dmamap_xfer->dm_mapsize,\n\t\t\t\tBUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);\n\t\tccb_carr = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(ccb_carr->next_vpa));\n\t}\n*/\n\tbus_dmamap_load(sc->sc_dmat, sc->sc_control->dmamap_xfer,\n\t\t\tsc->sc_control->carriers, ADW_CARRIER_SIZE * ADW_MAX_CARRIER,\n\t\t\tNULL, BUS_DMA_NOWAIT);\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_control->dmamap_xfer,\n\t\t\tBUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);\n\n\t/*\n\t * Tickle the RISC to tell it to read its Command Queue Head pointer.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_A);\n\tif (sc->chip_type == ADV_CHIP_ASC3550)\n\t{\n\t\t/*\n\t\t * Clear the tickle value. In the ASC-3550 the RISC flag\n\t\t * command 'clr_tickle_a' does not work unless the host\n\t\t * value is cleared.\n\t\t */\n\t\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_NOP);\n\t}\n\n\treturn ADW_SUCCESS;\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ADW_SOFTC\t*sc;",
            "ADW_SCSI_REQ_Q *scsiq;",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nADW_SOFTC\t*sc;\nADW_SCSI_REQ_Q *scsiq;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nint\nAdvExeScsiQueue(sc, scsiq)\nADW_SOFTC\t*sc;\nADW_SCSI_REQ_Q\t*scsiq;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tADW_CCB\t\t*ccb;\n\tlong\t\treq_size;\n\tu_int32_t\treq_paddr;\n\tADW_CARRIER\t*new_carrp, *new_freep/*, *ccb_carr;\n\tint\t\ti*/;\n\n\n\t/*\n\t * The ADW_SCSI_REQ_Q 'target_id' field should never exceed ADW_MAX_TID.\n\t */\n\tif (scsiq->target_id > ADW_MAX_TID) {\n\t\tscsiq->host_status = QHSTA_M_INVALID_DEVICE;\n\t\tscsiq->done_status = QD_WITH_ERROR;\n\t\treturn ADW_ERROR;\n\t}\n\n\tccb = adw_ccb_phys_kv(sc, scsiq->ccb_ptr);\n\tccb->carr_list = sc->icq_sp;\n\n\t/*\n\t * Allocate a carrier ensuring at least one carrier always\n\t * remains on the freelist and initialize fields.\n\t */\n\tnew_carrp = sc->carr_freelist;\n        new_freep = adw_carrier_phys_kv( sc, \n\t\t\t\t\t ASC_GET_CARRP( new_carrp->next_vpa) );\n\n\tif (new_freep == NULL) {\n\t\treturn ADW_BUSY;\n\t}\n\tsc->carr_freelist = new_freep;\n\tsc->carr_pending_cnt++;\n\n\t/*\n\t * Set the carrier to be a stopper by setting 'next_vpa'\n\t * to the stopper value. The current stopper will be changed\n\t * below to point to the new stopper.\n\t */\n\tnew_carrp->next_vpa = ASC_CQ_STOPPER;\n\n\treq_size = sizeof(ADW_SCSI_REQ_Q);\n\treq_paddr = sc->sc_dmamap_control->dm_segs[0].ds_addr +\n\t\tADW_CCB_OFF(ccb) + offsetof(struct adw_ccb, scsiq);\n\n\t/* Save physical address of ADW_SCSI_REQ_Q and Carrier. */\n\tscsiq->scsiq_rptr = req_paddr;\n\n\t/*\n\t * Every ADV_CARR_T.carr_pa is byte swapped to little-endian\n\t * order during initialization.\n\t */\n\tscsiq->carr_pa = sc->icq_sp->carr_pa;\n\tscsiq->carr_va = sc->icq_sp->carr_pa;\n\n\t/*\n\t * Use the current stopper to send the ADW_SCSI_REQ_Q command to\n\t * the microcode. The newly allocated stopper will become the new\n\t * stopper.\n\t */\n\tsc->icq_sp->areq_vpa = req_paddr;\n\n\t/*\n\t * Set the 'next_vpa' pointer for the old stopper to be the\n\t * physical address of the new stopper. The RISC can only\n\t * follow physical addresses.\n\t */\n\tsc->icq_sp->next_vpa = new_carrp->carr_pa;\n\n\t/*\n\t * Set the host adapter stopper pointer to point to the new carrier.\n\t */\n\tsc->icq_sp = new_carrp;\n\n/*\tccb_carr = ccb->carr_list;\n\twhile(ccb_carr != ASC_CQ_STOPPER) {\n\t\tbus_dmamap_load(sc->sc_dmat, ccb_carr->dmamap_xfer,\n\t\t\t\tccb_carr, ADW_CARRIER_SIZE,\n\t\t\t\tNULL, BUS_DMA_NOWAIT);\n\t\tbus_dmamap_sync(sc->sc_dmat, ccb_carr->dmamap_xfer, 0,\n\t\t\t\tccb_carr->dmamap_xfer->dm_mapsize,\n\t\t\t\tBUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);\n\t\tccb_carr = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(ccb_carr->next_vpa));\n\t}\n\n\tccb_carr = sc->irq_sp;\n\tfor(i=0; i<2 && ccb_carr != ASC_CQ_STOPPER; i++) {\n\t\tbus_dmamap_load(sc->sc_dmat, ccb_carr->dmamap_xfer,\n\t\t\t\tccb_carr, ADW_CARRIER_SIZE,\n\t\t\t\tNULL, BUS_DMA_NOWAIT);\n\t\tbus_dmamap_sync(sc->sc_dmat, ccb_carr->dmamap_xfer, 0,\n\t\t\t\tccb_carr->dmamap_xfer->dm_mapsize,\n\t\t\t\tBUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);\n\t\tccb_carr = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(ccb_carr->next_vpa));\n\t}\n*/\n\tbus_dmamap_load(sc->sc_dmat, sc->sc_control->dmamap_xfer,\n\t\t\tsc->sc_control->carriers, ADW_CARRIER_SIZE * ADW_MAX_CARRIER,\n\t\t\tNULL, BUS_DMA_NOWAIT);\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_control->dmamap_xfer,\n\t\t\tBUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);\n\n\t/*\n\t * Tickle the RISC to tell it to read its Command Queue Head pointer.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_A);\n\tif (sc->chip_type == ADV_CHIP_ASC3550)\n\t{\n\t\t/*\n\t\t * Clear the tickle value. In the ASC-3550 the RISC flag\n\t\t * command 'clr_tickle_a' does not work unless the host\n\t\t * value is cleared.\n\t\t */\n\t\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_NOP);\n\t}\n\n\treturn ADW_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&sc->sc_waiting_ccb",
            "ccb",
            "chain"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adw_queue_ccb;\nstatic void adw_timeout;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nint             flags;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic int\nadw_queue_ccb(sc, ccb, retry)\n\tADW_SOFTC      *sc;\n\tADW_CCB        *ccb;\n\tint\t\tretry;\n{\n\tint\t\terrcode;\n\n\tif(!retry)\n\t\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\n\t\terrcode = AdvExeScsiQueue(sc, &ccb->scsiq);\n\t\tswitch(errcode) {\n\t\tcase ADW_SUCCESS:\n\t\t\tbreak;\n\n\t\tcase ADW_BUSY:\n\t\t\tprintf(\"ADW_BUSY\\n\");\n\t\t\treturn(ADW_BUSY);\n\n\t\tcase ADW_ERROR:\n\t\t\tprintf(\"ADW_ERROR\\n\");\n\t\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n\t\t\treturn(ADW_ERROR);\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(adw_timeout, ccb, (ccb->timeout * hz) / 1000);\n\t}\n\n\treturn(errcode);\n}"
  },
  {
    "function_name": "adw_init_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "429-460",
    "snippet": "static int\nadw_init_ccb(sc, ccb)\n\tADW_SOFTC      *sc;\n\tADW_CCB        *ccb;\n{\n\tint\thashnum, error;\n\n\t/*\n         * Create the DMA map for this CCB.\n         */\n\terror = bus_dmamap_create(sc->sc_dmat,\n\t\t\t\t  (ADW_MAX_SG_LIST - 1) * PAGE_SIZE,\n\t\t\t ADW_MAX_SG_LIST, (ADW_MAX_SG_LIST - 1) * PAGE_SIZE,\n\t\t   0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &ccb->dmamap_xfer);\n\tif (error) {\n\t\tprintf(\"%s: unable to create CCB DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\t/*\n\t * put in the phystokv hash table\n\t * Never gets taken out.\n\t */\n\tccb->hashkey = sc->sc_dmamap_control->dm_segs[0].ds_addr +\n\t    ADW_CCB_OFF(ccb);\n\thashnum = CCB_HASH(ccb->hashkey);\n\tccb->nexthash = sc->sc_ccbhash[hashnum];\n\tsc->sc_ccbhash[hashnum] = ccb;\n\tadw_reset_ccb(ccb);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adw_reset_ccb",
      "static int adw_init_ccb",
      "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
      "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
      "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
      "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "adw_reset_ccb",
          "args": [
            "ccb"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "adw_reset_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
          "lines": "420-426",
          "snippet": "static void\nadw_reset_ccb(ccb)\n\tADW_CCB        *ccb;\n{\n\n\tccb->flags = 0;\n}",
          "includes": [
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adw_reset_ccb",
            "int             flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_reset_ccb;\nint             flags;\n\nstatic void\nadw_reset_ccb(ccb)\n\tADW_CCB        *ccb;\n{\n\n\tccb->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CCB_HASH",
          "args": [
            "ccb->hashkey"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_CCB_OFF",
          "args": [
            "ccb"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unable to create CCB DMA map, error = %d\\n\"",
            "sc->sc_dev.dv_xname",
            "error"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "sc->sc_dmat",
            "(ADW_MAX_SG_LIST - 1) * PAGE_SIZE",
            "ADW_MAX_SG_LIST",
            "(ADW_MAX_SG_LIST - 1) * PAGE_SIZE",
            "0",
            "BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW",
            "&ccb->dmamap_xfer"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_reset_ccb;\nstatic int adw_init_ccb;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic int\nadw_init_ccb(sc, ccb)\n\tADW_SOFTC      *sc;\n\tADW_CCB        *ccb;\n{\n\tint\thashnum, error;\n\n\t/*\n         * Create the DMA map for this CCB.\n         */\n\terror = bus_dmamap_create(sc->sc_dmat,\n\t\t\t\t  (ADW_MAX_SG_LIST - 1) * PAGE_SIZE,\n\t\t\t ADW_MAX_SG_LIST, (ADW_MAX_SG_LIST - 1) * PAGE_SIZE,\n\t\t   0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &ccb->dmamap_xfer);\n\tif (error) {\n\t\tprintf(\"%s: unable to create CCB DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\t/*\n\t * put in the phystokv hash table\n\t * Never gets taken out.\n\t */\n\tccb->hashkey = sc->sc_dmamap_control->dm_segs[0].ds_addr +\n\t    ADW_CCB_OFF(ccb);\n\thashnum = CCB_HASH(ccb->hashkey);\n\tccb->nexthash = sc->sc_ccbhash[hashnum];\n\tsc->sc_ccbhash[hashnum] = ccb;\n\tadw_reset_ccb(ccb);\n\treturn (0);\n}"
  },
  {
    "function_name": "adw_reset_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "420-426",
    "snippet": "static void\nadw_reset_ccb(ccb)\n\tADW_CCB        *ccb;\n{\n\n\tccb->flags = 0;\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adw_reset_ccb",
      "int             flags;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_reset_ccb;\nint             flags;\n\nstatic void\nadw_reset_ccb(ccb)\n\tADW_CCB        *ccb;\n{\n\n\tccb->flags = 0;\n}"
  },
  {
    "function_name": "adw_free_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "397-417",
    "snippet": "static void\nadw_free_ccb(sc, ccb)\n\tADW_SOFTC      *sc;\n\tADW_CCB        *ccb;\n{\n\tint             s;\n\n\ts = splbio();\n\n\tadw_reset_ccb(ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n         * If there were none, wake anybody waiting for one to come free,\n         * starting with queued entries.\n         */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adw_free_ccb",
      "static void adw_reset_ccb",
      "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
      "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
      "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
      "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&sc->sc_free_ccb"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "rln_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "171-214",
          "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&sc->sc_free_ccb",
            "ccb",
            "chain"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adw_reset_ccb",
          "args": [
            "ccb"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "adw_reset_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
          "lines": "420-426",
          "snippet": "static void\nadw_reset_ccb(ccb)\n\tADW_CCB        *ccb;\n{\n\n\tccb->flags = 0;\n}",
          "includes": [
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adw_reset_ccb",
            "int             flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_reset_ccb;\nint             flags;\n\nstatic void\nadw_reset_ccb(ccb)\n\tADW_CCB        *ccb;\n{\n\n\tccb->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_free_ccb;\nstatic void adw_reset_ccb;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic void\nadw_free_ccb(sc, ccb)\n\tADW_SOFTC      *sc;\n\tADW_CCB        *ccb;\n{\n\tint             s;\n\n\ts = splbio();\n\n\tadw_reset_ccb(ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n         * If there were none, wake anybody waiting for one to come free,\n         * starting with queued entries.\n         */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "adw_create_ccbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "371-391",
    "snippet": "static int\nadw_create_ccbs(sc, ccbstore, count)\n\tADW_SOFTC      *sc;\n\tADW_CCB        *ccbstore;\n\tint             count;\n{\n\tADW_CCB        *ccb;\n\tint             i, error;\n\n\tfor (i = 0; i < count; i++) {\n\t\tccb = &ccbstore[i];\n\t\tif ((error = adw_init_ccb(sc, ccb)) != 0) {\n\t\t\tprintf(\"%s: unable to initialize ccb, error = %d\\n\",\n\t\t\t       sc->sc_dev.dv_xname, error);\n\t\t\treturn (i);\n\t\t}\n\t\tTAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, chain);\n\t}\n\n\treturn (i);\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int adw_create_ccbs",
      "static int adw_init_ccb",
      "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
      "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
      "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
      "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&sc->sc_free_ccb",
            "ccb",
            "chain"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unable to initialize ccb, error = %d\\n\"",
            "sc->sc_dev.dv_xname",
            "error"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "adw_init_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "adw_init_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
          "lines": "429-460",
          "snippet": "static int\nadw_init_ccb(sc, ccb)\n\tADW_SOFTC      *sc;\n\tADW_CCB        *ccb;\n{\n\tint\thashnum, error;\n\n\t/*\n         * Create the DMA map for this CCB.\n         */\n\terror = bus_dmamap_create(sc->sc_dmat,\n\t\t\t\t  (ADW_MAX_SG_LIST - 1) * PAGE_SIZE,\n\t\t\t ADW_MAX_SG_LIST, (ADW_MAX_SG_LIST - 1) * PAGE_SIZE,\n\t\t   0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &ccb->dmamap_xfer);\n\tif (error) {\n\t\tprintf(\"%s: unable to create CCB DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\t/*\n\t * put in the phystokv hash table\n\t * Never gets taken out.\n\t */\n\tccb->hashkey = sc->sc_dmamap_control->dm_segs[0].ds_addr +\n\t    ADW_CCB_OFF(ccb);\n\thashnum = CCB_HASH(ccb->hashkey);\n\tccb->nexthash = sc->sc_ccbhash[hashnum];\n\tsc->sc_ccbhash[hashnum] = ccb;\n\tadw_reset_ccb(ccb);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adw_reset_ccb",
            "static int adw_init_ccb",
            "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
            "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
            "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
            "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_reset_ccb;\nstatic int adw_init_ccb;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic int\nadw_init_ccb(sc, ccb)\n\tADW_SOFTC      *sc;\n\tADW_CCB        *ccb;\n{\n\tint\thashnum, error;\n\n\t/*\n         * Create the DMA map for this CCB.\n         */\n\terror = bus_dmamap_create(sc->sc_dmat,\n\t\t\t\t  (ADW_MAX_SG_LIST - 1) * PAGE_SIZE,\n\t\t\t ADW_MAX_SG_LIST, (ADW_MAX_SG_LIST - 1) * PAGE_SIZE,\n\t\t   0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &ccb->dmamap_xfer);\n\tif (error) {\n\t\tprintf(\"%s: unable to create CCB DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\t/*\n\t * put in the phystokv hash table\n\t * Never gets taken out.\n\t */\n\tccb->hashkey = sc->sc_dmamap_control->dm_segs[0].ds_addr +\n\t    ADW_CCB_OFF(ccb);\n\thashnum = CCB_HASH(ccb->hashkey);\n\tccb->nexthash = sc->sc_ccbhash[hashnum];\n\tsc->sc_ccbhash[hashnum] = ccb;\n\tadw_reset_ccb(ccb);\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adw_create_ccbs;\nstatic int adw_init_ccb;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic int\nadw_create_ccbs(sc, ccbstore, count)\n\tADW_SOFTC      *sc;\n\tADW_CCB        *ccbstore;\n\tint             count;\n{\n\tADW_CCB        *ccb;\n\tint             i, error;\n\n\tfor (i = 0; i < count; i++) {\n\t\tccb = &ccbstore[i];\n\t\tif ((error = adw_init_ccb(sc, ccb)) != 0) {\n\t\t\tprintf(\"%s: unable to initialize ccb, error = %d\\n\",\n\t\t\t       sc->sc_dev.dv_xname, error);\n\t\t\treturn (i);\n\t\t}\n\t\tTAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, chain);\n\t}\n\n\treturn (i);\n}"
  },
  {
    "function_name": "adw_init_carrier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "312-344",
    "snippet": "static int\nadw_init_carrier(sc, carr)\n\tADW_SOFTC\t*sc;\n\tADW_CARRIER\t*carr;\n{\n\tu_int32_t\tcarr_pa;\n\tint\t\t/*error, */hashnum;\n\n\t/*\n         * Create the DMA map for all of the Carriers.\n         */\n/*\terror = bus_dmamap_create(sc->sc_dmat, ADW_CARRIER_SIZE,\n\t\t\t1, ADW_CARRIER_SIZE,\n\t\t\t0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t\t\t&carr->dmamap_xfer);\n\tif (error) {\n\t\tprintf(\"%s: unable to create Carrier DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n*/\n\t/*\n\t * put in the phystokv hash table\n\t * Never gets taken out.\n\t */\n\tcarr_pa = ADW_CARRIER_ADDR(sc, carr);\n\tcarr->carr_pa = carr_pa;\n\thashnum = CARRIER_HASH(carr_pa);\n\tcarr->nexthash = sc->sc_carrhash[hashnum];\n\tsc->sc_carrhash[hashnum] = carr;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int adw_init_carrier",
      "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
      "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
      "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
      "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CARRIER_HASH",
          "args": [
            "carr_pa"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_CARRIER_ADDR",
          "args": [
            "sc",
            "carr"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adw_init_carrier;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic int\nadw_init_carrier(sc, carr)\n\tADW_SOFTC\t*sc;\n\tADW_CARRIER\t*carr;\n{\n\tu_int32_t\tcarr_pa;\n\tint\t\t/*error, */hashnum;\n\n\t/*\n         * Create the DMA map for all of the Carriers.\n         */\n/*\terror = bus_dmamap_create(sc->sc_dmat, ADW_CARRIER_SIZE,\n\t\t\t1, ADW_CARRIER_SIZE,\n\t\t\t0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t\t\t&carr->dmamap_xfer);\n\tif (error) {\n\t\tprintf(\"%s: unable to create Carrier DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n*/\n\t/*\n\t * put in the phystokv hash table\n\t * Never gets taken out.\n\t */\n\tcarr_pa = ADW_CARRIER_ADDR(sc, carr);\n\tcarr->carr_pa = carr_pa;\n\thashnum = CARRIER_HASH(carr_pa);\n\tcarr->nexthash = sc->sc_carrhash[hashnum];\n\tsc->sc_carrhash[hashnum] = carr;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "adw_create_carriers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "287-309",
    "snippet": "static int\nadw_create_carriers(sc)\n\tADW_SOFTC\t*sc;\n{\n\tADW_CARRIER\t*carr;\n\tu_int32_t\tcarr_next = NULL;\n\tint\t\ti, error;\n\n\tfor(i=0; i < ADW_MAX_CARRIER; i++) {\n\t\tcarr = (ADW_CARRIER *)(((u_int8_t *)sc->sc_control->carriers) +\n\t\t\t\t(ADW_CARRIER_SIZE * i));\n\t\tif ((error = adw_init_carrier(sc, carr)) != 0) {\n\t\t\tprintf(\"%s: unable to initialize carrier, error = %d\\n\",\n\t\t\t       sc->sc_dev.dv_xname, error);\n\t\t\treturn (i);\n\t\t}\n\t\tcarr->next_vpa = carr_next;\n\t\tcarr_next = carr->carr_pa;\n\t\tcarr->id = i;\n\t}\n\tsc->carr_freelist = carr;\n\treturn (i);\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int adw_create_carriers",
      "static int adw_init_carrier",
      "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
      "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
      "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
      "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unable to initialize carrier, error = %d\\n\"",
            "sc->sc_dev.dv_xname",
            "error"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "adw_init_carrier",
          "args": [
            "sc",
            "carr"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "adw_init_carrier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
          "lines": "312-344",
          "snippet": "static int\nadw_init_carrier(sc, carr)\n\tADW_SOFTC\t*sc;\n\tADW_CARRIER\t*carr;\n{\n\tu_int32_t\tcarr_pa;\n\tint\t\t/*error, */hashnum;\n\n\t/*\n         * Create the DMA map for all of the Carriers.\n         */\n/*\terror = bus_dmamap_create(sc->sc_dmat, ADW_CARRIER_SIZE,\n\t\t\t1, ADW_CARRIER_SIZE,\n\t\t\t0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t\t\t&carr->dmamap_xfer);\n\tif (error) {\n\t\tprintf(\"%s: unable to create Carrier DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n*/\n\t/*\n\t * put in the phystokv hash table\n\t * Never gets taken out.\n\t */\n\tcarr_pa = ADW_CARRIER_ADDR(sc, carr);\n\tcarr->carr_pa = carr_pa;\n\thashnum = CARRIER_HASH(carr_pa);\n\tcarr->nexthash = sc->sc_carrhash[hashnum];\n\tsc->sc_carrhash[hashnum] = carr;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int adw_init_carrier",
            "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
            "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
            "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
            "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adw_init_carrier;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic int\nadw_init_carrier(sc, carr)\n\tADW_SOFTC\t*sc;\n\tADW_CARRIER\t*carr;\n{\n\tu_int32_t\tcarr_pa;\n\tint\t\t/*error, */hashnum;\n\n\t/*\n         * Create the DMA map for all of the Carriers.\n         */\n/*\terror = bus_dmamap_create(sc->sc_dmat, ADW_CARRIER_SIZE,\n\t\t\t1, ADW_CARRIER_SIZE,\n\t\t\t0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t\t\t&carr->dmamap_xfer);\n\tif (error) {\n\t\tprintf(\"%s: unable to create Carrier DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n*/\n\t/*\n\t * put in the phystokv hash table\n\t * Never gets taken out.\n\t */\n\tcarr_pa = ADW_CARRIER_ADDR(sc, carr);\n\tcarr->carr_pa = carr_pa;\n\thashnum = CARRIER_HASH(carr_pa);\n\tcarr->nexthash = sc->sc_carrhash[hashnum];\n\tsc->sc_carrhash[hashnum] = carr;\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adw_create_carriers;\nstatic int adw_init_carrier;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic int\nadw_create_carriers(sc)\n\tADW_SOFTC\t*sc;\n{\n\tADW_CARRIER\t*carr;\n\tu_int32_t\tcarr_next = NULL;\n\tint\t\ti, error;\n\n\tfor(i=0; i < ADW_MAX_CARRIER; i++) {\n\t\tcarr = (ADW_CARRIER *)(((u_int8_t *)sc->sc_control->carriers) +\n\t\t\t\t(ADW_CARRIER_SIZE * i));\n\t\tif ((error = adw_init_carrier(sc, carr)) != 0) {\n\t\t\tprintf(\"%s: unable to initialize carrier, error = %d\\n\",\n\t\t\t       sc->sc_dev.dv_xname, error);\n\t\t\treturn (i);\n\t\t}\n\t\tcarr->next_vpa = carr_next;\n\t\tcarr_next = carr->carr_pa;\n\t\tcarr->id = i;\n\t}\n\tsc->carr_freelist = carr;\n\treturn (i);\n}"
  },
  {
    "function_name": "adw_alloc_carriers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "215-280",
    "snippet": "static int\nadw_alloc_carriers(sc)\n\tADW_SOFTC      *sc;\n{\n\tbus_dma_segment_t seg;\n\tint             error, rseg;\n\n\t/*\n         * Allocate the control structure.\n         */\n\tsc->sc_control->carriers = malloc(ADW_CARRIER_SIZE * ADW_MAX_CARRIER,\n\t\t\tM_DEVBUF, M_WAITOK);\n\tif(!sc->sc_control->carriers) {\n\t\tprintf(\"%s: malloc() failed in allocating carrier structures,\"\n\t\t       \" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\tif ((error = bus_dmamem_alloc(sc->sc_dmat,\n\t\t\tADW_CARRIER_SIZE * ADW_MAX_CARRIER,\n\t\t\tNBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to allocate carrier structures,\"\n\t\t       \" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,\n\t\t\tADW_CARRIER_SIZE * ADW_MAX_CARRIER,\n\t\t\t(caddr_t *) &sc->sc_control->carriers,\n\t\t\tBUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: unable to map carrier structures,\"\n\t\t\t\" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\t/*\n         * Create and load the DMA map used for the control blocks.\n         */\n\tif ((error = bus_dmamap_create(sc->sc_dmat,\n\t\t\tADW_CARRIER_SIZE * ADW_MAX_CARRIER, 1,\n\t\t\tADW_CARRIER_SIZE * ADW_MAX_CARRIER, 0, BUS_DMA_NOWAIT,\n\t\t\t&sc->sc_dmamap_carrier)) != 0) {\n\t\tprintf(\"%s: unable to create carriers DMA map,\"\n\t\t\t\" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamap_load(sc->sc_dmat,\n\t\t\tsc->sc_dmamap_carrier, sc->sc_control->carriers,\n\t\t\tADW_CARRIER_SIZE * ADW_MAX_CARRIER, NULL,\n\t\t\tBUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to load carriers DMA map,\"\n\t\t\t\" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\terror = bus_dmamap_create(sc->sc_dmat, ADW_CARRIER_SIZE* ADW_MAX_CARRIER,\n\t\t\t1, ADW_CARRIER_SIZE * ADW_MAX_CARRIER,\n\t\t\t0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t\t\t&sc->sc_control->dmamap_xfer);\n\tif (error) {\n\t\tprintf(\"%s: unable to create Carrier DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int adw_alloc_carriers",
      "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
      "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
      "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
      "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unable to create Carrier DMA map, error = %d\\n\"",
            "sc->sc_dev.dv_xname",
            "error"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "sc->sc_dmat",
            "ADW_CARRIER_SIZE* ADW_MAX_CARRIER",
            "1",
            "ADW_CARRIER_SIZE * ADW_MAX_CARRIER",
            "0",
            "BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW",
            "&sc->sc_control->dmamap_xfer"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "sc->sc_dmat",
            "sc->sc_dmamap_carrier",
            "sc->sc_control->carriers",
            "ADW_CARRIER_SIZE * ADW_MAX_CARRIER",
            "NULL",
            "BUS_DMA_NOWAIT"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "sc->sc_dmat",
            "ADW_CARRIER_SIZE * ADW_MAX_CARRIER",
            "1",
            "ADW_CARRIER_SIZE * ADW_MAX_CARRIER",
            "0",
            "BUS_DMA_NOWAIT",
            "&sc->sc_dmamap_carrier"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_map",
          "args": [
            "sc->sc_dmat",
            "&seg",
            "rseg",
            "ADW_CARRIER_SIZE * ADW_MAX_CARRIER",
            "(caddr_t *) &sc->sc_control->carriers",
            "BUS_DMA_NOWAIT | BUS_DMA_COHERENT"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_alloc",
          "args": [
            "sc->sc_dmat",
            "ADW_CARRIER_SIZE * ADW_MAX_CARRIER",
            "NBPG",
            "0",
            "&seg",
            "1",
            "&rseg",
            "BUS_DMA_NOWAIT"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "ADW_CARRIER_SIZE * ADW_MAX_CARRIER",
            "M_DEVBUF",
            "M_WAITOK"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adw_alloc_carriers;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic int\nadw_alloc_carriers(sc)\n\tADW_SOFTC      *sc;\n{\n\tbus_dma_segment_t seg;\n\tint             error, rseg;\n\n\t/*\n         * Allocate the control structure.\n         */\n\tsc->sc_control->carriers = malloc(ADW_CARRIER_SIZE * ADW_MAX_CARRIER,\n\t\t\tM_DEVBUF, M_WAITOK);\n\tif(!sc->sc_control->carriers) {\n\t\tprintf(\"%s: malloc() failed in allocating carrier structures,\"\n\t\t       \" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\tif ((error = bus_dmamem_alloc(sc->sc_dmat,\n\t\t\tADW_CARRIER_SIZE * ADW_MAX_CARRIER,\n\t\t\tNBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to allocate carrier structures,\"\n\t\t       \" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,\n\t\t\tADW_CARRIER_SIZE * ADW_MAX_CARRIER,\n\t\t\t(caddr_t *) &sc->sc_control->carriers,\n\t\t\tBUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: unable to map carrier structures,\"\n\t\t\t\" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\t/*\n         * Create and load the DMA map used for the control blocks.\n         */\n\tif ((error = bus_dmamap_create(sc->sc_dmat,\n\t\t\tADW_CARRIER_SIZE * ADW_MAX_CARRIER, 1,\n\t\t\tADW_CARRIER_SIZE * ADW_MAX_CARRIER, 0, BUS_DMA_NOWAIT,\n\t\t\t&sc->sc_dmamap_carrier)) != 0) {\n\t\tprintf(\"%s: unable to create carriers DMA map,\"\n\t\t\t\" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamap_load(sc->sc_dmat,\n\t\t\tsc->sc_dmamap_carrier, sc->sc_control->carriers,\n\t\t\tADW_CARRIER_SIZE * ADW_MAX_CARRIER, NULL,\n\t\t\tBUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to load carriers DMA map,\"\n\t\t\t\" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\terror = bus_dmamap_create(sc->sc_dmat, ADW_CARRIER_SIZE* ADW_MAX_CARRIER,\n\t\t\t1, ADW_CARRIER_SIZE * ADW_MAX_CARRIER,\n\t\t\t0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t\t\t&sc->sc_control->dmamap_xfer);\n\tif (error) {\n\t\tprintf(\"%s: unable to create Carrier DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "adw_alloc_controls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "169-212",
    "snippet": "static int\nadw_alloc_controls(sc)\n\tADW_SOFTC      *sc;\n{\n\tbus_dma_segment_t seg;\n\tint             error, rseg;\n\n\t/*\n         * Allocate the control structure.\n         */\n\tif ((error = bus_dmamem_alloc(sc->sc_dmat, sizeof(struct adw_control),\n\t\t\t   NBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to allocate control structures,\"\n\t\t       \" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,\n\t\t   sizeof(struct adw_control), (caddr_t *) & sc->sc_control,\n\t\t\t\t BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: unable to map control structures, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\t/*\n         * Create and load the DMA map used for the control blocks.\n         */\n\tif ((error = bus_dmamap_create(sc->sc_dmat, sizeof(struct adw_control),\n\t\t\t   1, sizeof(struct adw_control), 0, BUS_DMA_NOWAIT,\n\t\t\t\t       &sc->sc_dmamap_control)) != 0) {\n\t\tprintf(\"%s: unable to create control DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap_control,\n\t\t\t   sc->sc_control, sizeof(struct adw_control), NULL,\n\t\t\t\t     BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to load control DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int adw_alloc_controls",
      "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
      "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
      "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
      "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unable to load control DMA map, error = %d\\n\"",
            "sc->sc_dev.dv_xname",
            "error"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "sc->sc_dmat",
            "sc->sc_dmamap_control",
            "sc->sc_control",
            "sizeof(struct adw_control)",
            "NULL",
            "BUS_DMA_NOWAIT"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "sc->sc_dmat",
            "sizeof(struct adw_control)",
            "1",
            "sizeof(struct adw_control)",
            "0",
            "BUS_DMA_NOWAIT",
            "&sc->sc_dmamap_control"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_map",
          "args": [
            "sc->sc_dmat",
            "&seg",
            "rseg",
            "sizeof(struct adw_control)",
            "(caddr_t *) & sc->sc_control",
            "BUS_DMA_NOWAIT | BUS_DMA_COHERENT"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_alloc",
          "args": [
            "sc->sc_dmat",
            "sizeof(struct adw_control)",
            "NBPG",
            "0",
            "&seg",
            "1",
            "&rseg",
            "BUS_DMA_NOWAIT"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adw_alloc_controls;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic int\nadw_alloc_controls(sc)\n\tADW_SOFTC      *sc;\n{\n\tbus_dma_segment_t seg;\n\tint             error, rseg;\n\n\t/*\n         * Allocate the control structure.\n         */\n\tif ((error = bus_dmamem_alloc(sc->sc_dmat, sizeof(struct adw_control),\n\t\t\t   NBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to allocate control structures,\"\n\t\t       \" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,\n\t\t   sizeof(struct adw_control), (caddr_t *) & sc->sc_control,\n\t\t\t\t BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: unable to map control structures, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\t/*\n         * Create and load the DMA map used for the control blocks.\n         */\n\tif ((error = bus_dmamap_create(sc->sc_dmat, sizeof(struct adw_control),\n\t\t\t   1, sizeof(struct adw_control), 0, BUS_DMA_NOWAIT,\n\t\t\t\t       &sc->sc_dmamap_control)) != 0) {\n\t\tprintf(\"%s: unable to create control DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap_control,\n\t\t\t   sc->sc_control, sizeof(struct adw_control), NULL,\n\t\t\t\t     BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to load control DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "adw_enqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adw.c",
    "lines": "128-143",
    "snippet": "static void\nadw_enqueue(sc, xs, infront)\n\tADW_SOFTC      *sc;\n\tstruct scsi_xfer *xs;\n\tint             infront;\n{\n\n\tif (infront || sc->sc_queue.lh_first == NULL) {\n\t\tif (sc->sc_queue.lh_first == NULL)\n\t\t\tsc->sc_queuelast = xs;\n\t\tLIST_INSERT_HEAD(&sc->sc_queue, xs, free_list);\n\t\treturn;\n\t}\n\tLIST_INSERT_AFTER(sc->sc_queuelast, xs, free_list);\n\tsc->sc_queuelast = xs;\n}",
    "includes": [
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adw_enqueue",
      "static struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;",
      "ADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;",
      "static ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;",
      "ADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIST_INSERT_AFTER",
          "args": [
            "sc->sc_queuelast",
            "xs",
            "free_list"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INSERT_HEAD",
          "args": [
            "&sc->sc_queue",
            "xs",
            "free_list"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adw_enqueue;\nstatic struct scsi_xfer *\nadw_dequeue(sc)\n\tADW_SOFTC      *sc;\nADW_CARRIER *\nadw_carrier_phys_kv(sc, carr_phys)\n\tADW_SOFTC\t*sc;\nstatic ADW_CCB *\nadw_get_ccb(sc, flags)\n\tADW_SOFTC      *sc;\nADW_CCB *\nadw_ccb_phys_kv(sc, ccb_phys)\n\tADW_SOFTC\t*sc;\n\nstatic void\nadw_enqueue(sc, xs, infront)\n\tADW_SOFTC      *sc;\n\tstruct scsi_xfer *xs;\n\tint             infront;\n{\n\n\tif (infront || sc->sc_queue.lh_first == NULL) {\n\t\tif (sc->sc_queue.lh_first == NULL)\n\t\t\tsc->sc_queuelast = xs;\n\t\tLIST_INSERT_HEAD(&sc->sc_queue, xs, free_list);\n\t\treturn;\n\t}\n\tLIST_INSERT_AFTER(sc->sc_queuelast, xs, free_list);\n\tsc->sc_queuelast = xs;\n}"
  }
]