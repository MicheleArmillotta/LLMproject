[
  {
    "function_name": "ess_read_multi_mix_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2678-2693",
    "snippet": "void\ness_read_multi_mix_reg(sc, reg, datap, count)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_int8_t *datap;\n\tbus_size_t count;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tbus_space_read_multi_1(iot, ioh, ESS_MIX_REG_DATA, datap, count);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tess_read_multi_mix_reg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_multi_1",
          "args": [
            "iot",
            "ioh",
            "ESS_MIX_REG_DATA",
            "datap",
            "count"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE1",
          "args": [
            "iot",
            "ioh",
            "ESS_MIX_REG_SELECT",
            "reg"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_read_multi_mix_reg;\n\nvoid\ness_read_multi_mix_reg(sc, reg, datap, count)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_int8_t *datap;\n\tbus_size_t count;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tbus_space_read_multi_1(iot, ioh, ESS_MIX_REG_DATA, datap, count);\n\tsplx(s);\n}"
  },
  {
    "function_name": "ess_set_mreg_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2669-2676",
    "snippet": "void\ness_set_mreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) | mask);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_char\tess_read_mix_reg",
      "void\tess_write_mix_reg",
      "void\tess_set_mreg_bits"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_write_mix_reg",
          "args": [
            "sc",
            "reg",
            "ess_read_mix_reg(sc, reg) | mask"
          ],
          "line": 2675
        },
        "resolved": true,
        "details": {
          "function_name": "ess_write_mix_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2620-2636",
          "snippet": "void\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_write_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_write_mix_reg;\n\nvoid\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_read_mix_reg",
          "args": [
            "sc",
            "reg"
          ],
          "line": 2675
        },
        "resolved": true,
        "details": {
          "function_name": "ess_read_mix_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2641-2658",
          "snippet": "u_char\ness_read_mix_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\tu_char val;\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tval = EREAD1(iot, ioh, ESS_MIX_REG_DATA);\n\tsplx(s);\n\n\tDPRINTFN(2,(\"ess_read_mix_reg: %x=%x\\n\", reg, val));\n\treturn val;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_read_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_mix_reg;\n\nu_char\ness_read_mix_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\tu_char val;\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tval = EREAD1(iot, ioh, ESS_MIX_REG_DATA);\n\tsplx(s);\n\n\tDPRINTFN(2,(\"ess_read_mix_reg: %x=%x\\n\", reg, val));\n\treturn val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_mix_reg;\nvoid\tess_write_mix_reg;\nvoid\tess_set_mreg_bits;\n\nvoid\ness_set_mreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) | mask);\n}"
  },
  {
    "function_name": "ess_clear_mreg_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2660-2667",
    "snippet": "void\ness_clear_mreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) & ~mask);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_char\tess_read_mix_reg",
      "void\tess_write_mix_reg",
      "void\tess_clear_mreg_bits"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_write_mix_reg",
          "args": [
            "sc",
            "reg",
            "ess_read_mix_reg(sc, reg) & ~mask"
          ],
          "line": 2666
        },
        "resolved": true,
        "details": {
          "function_name": "ess_write_mix_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2620-2636",
          "snippet": "void\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_write_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_write_mix_reg;\n\nvoid\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_read_mix_reg",
          "args": [
            "sc",
            "reg"
          ],
          "line": 2666
        },
        "resolved": true,
        "details": {
          "function_name": "ess_read_mix_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2641-2658",
          "snippet": "u_char\ness_read_mix_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\tu_char val;\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tval = EREAD1(iot, ioh, ESS_MIX_REG_DATA);\n\tsplx(s);\n\n\tDPRINTFN(2,(\"ess_read_mix_reg: %x=%x\\n\", reg, val));\n\treturn val;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_read_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_mix_reg;\n\nu_char\ness_read_mix_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\tu_char val;\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tval = EREAD1(iot, ioh, ESS_MIX_REG_DATA);\n\tsplx(s);\n\n\tDPRINTFN(2,(\"ess_read_mix_reg: %x=%x\\n\", reg, val));\n\treturn val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_mix_reg;\nvoid\tess_write_mix_reg;\nvoid\tess_clear_mreg_bits;\n\nvoid\ness_clear_mreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) & ~mask);\n}"
  },
  {
    "function_name": "ess_read_mix_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2641-2658",
    "snippet": "u_char\ness_read_mix_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\tu_char val;\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tval = EREAD1(iot, ioh, ESS_MIX_REG_DATA);\n\tsplx(s);\n\n\tDPRINTFN(2,(\"ess_read_mix_reg: %x=%x\\n\", reg, val));\n\treturn val;\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_char\tess_read_mix_reg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"ess_read_mix_reg: %x=%x\\n\", reg, val)"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD1",
          "args": [
            "iot",
            "ioh",
            "ESS_MIX_REG_DATA"
          ],
          "line": 2653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE1",
          "args": [
            "iot",
            "ioh",
            "ESS_MIX_REG_SELECT",
            "reg"
          ],
          "line": 2652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_mix_reg;\n\nu_char\ness_read_mix_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\tu_char val;\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tval = EREAD1(iot, ioh, ESS_MIX_REG_DATA);\n\tsplx(s);\n\n\tDPRINTFN(2,(\"ess_read_mix_reg: %x=%x\\n\", reg, val));\n\treturn val;\n}"
  },
  {
    "function_name": "ess_write_mix_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2620-2636",
    "snippet": "void\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tess_write_mix_reg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE1",
          "args": [
            "iot",
            "ioh",
            "ESS_MIX_REG_DATA",
            "val"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE1",
          "args": [
            "iot",
            "ioh",
            "ESS_MIX_REG_SELECT",
            "reg"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"ess_write_mix_reg: %x=%x\\n\", reg, val)"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_write_mix_reg;\n\nvoid\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}"
  },
  {
    "function_name": "ess_set_xreg_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2605-2614",
    "snippet": "void\ness_set_xreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tif (ess_write_x_reg(sc, reg, ess_read_x_reg(sc, reg) | mask) == -1)\n\t\tDPRINTF((\"Error setting bits in extended register 0x%02x\\n\",\n\t\t\t reg));\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_char\tess_read_x_reg",
      "int\tess_write_x_reg",
      "void\tess_set_xreg_bits"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"Error setting bits in extended register 0x%02x\\n\",\n\t\t\t reg)"
          ],
          "line": 2612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_write_x_reg",
          "args": [
            "sc",
            "reg",
            "ess_read_x_reg(sc, reg) | mask"
          ],
          "line": 2611
        },
        "resolved": true,
        "details": {
          "function_name": "ess_write_x_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2558-2571",
          "snippet": "int\ness_write_x_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tint error;\n\n\tDPRINTFN(2,(\"ess_write_x_reg: %02x=%02x\\n\", reg, val));\n\tif ((error = ess_wdsp(sc, reg)) == 0)\n\t\terror = ess_wdsp(sc, val);\n\n\treturn error;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_wdsp",
            "int\tess_write_x_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_wdsp;\nint\tess_write_x_reg;\n\nint\ness_write_x_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tint error;\n\n\tDPRINTFN(2,(\"ess_write_x_reg: %02x=%02x\\n\", reg, val));\n\tif ((error = ess_wdsp(sc, reg)) == 0)\n\t\terror = ess_wdsp(sc, val);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_read_x_reg",
          "args": [
            "sc",
            "reg"
          ],
          "line": 2611
        },
        "resolved": true,
        "details": {
          "function_name": "ess_read_x_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2576-2592",
          "snippet": "u_char\ness_read_x_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tint error;\n\tint val;\n\n\tif ((error = ess_wdsp(sc, 0xC0)) == 0)\n\t\terror = ess_wdsp(sc, reg);\n\tif (error)\n\t\tDPRINTF((\"Error reading extended register 0x%02x\\n\", reg));\n/* REVISIT: what if an error is returned above? */\n\tval = ess_rdsp(sc);\n\tDPRINTFN(2,(\"ess_read_x_reg: %02x=%02x\\n\", reg, val));\n\treturn val;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_rdsp",
            "int\tess_wdsp",
            "u_char\tess_read_x_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_rdsp;\nint\tess_wdsp;\nu_char\tess_read_x_reg;\n\nu_char\ness_read_x_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tint error;\n\tint val;\n\n\tif ((error = ess_wdsp(sc, 0xC0)) == 0)\n\t\terror = ess_wdsp(sc, reg);\n\tif (error)\n\t\tDPRINTF((\"Error reading extended register 0x%02x\\n\", reg));\n/* REVISIT: what if an error is returned above? */\n\tval = ess_rdsp(sc);\n\tDPRINTFN(2,(\"ess_read_x_reg: %02x=%02x\\n\", reg, val));\n\treturn val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_x_reg;\nint\tess_write_x_reg;\nvoid\tess_set_xreg_bits;\n\nvoid\ness_set_xreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tif (ess_write_x_reg(sc, reg, ess_read_x_reg(sc, reg) | mask) == -1)\n\t\tDPRINTF((\"Error setting bits in extended register 0x%02x\\n\",\n\t\t\t reg));\n}"
  },
  {
    "function_name": "ess_clear_xreg_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2594-2603",
    "snippet": "void\ness_clear_xreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tif (ess_write_x_reg(sc, reg, ess_read_x_reg(sc, reg) & ~mask) == -1)\n\t\tDPRINTF((\"Error clearing bits in extended register 0x%02x\\n\",\n\t\t\t reg));\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_char\tess_read_x_reg",
      "int\tess_write_x_reg",
      "void\tess_clear_xreg_bits"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"Error clearing bits in extended register 0x%02x\\n\",\n\t\t\t reg)"
          ],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_write_x_reg",
          "args": [
            "sc",
            "reg",
            "ess_read_x_reg(sc, reg) & ~mask"
          ],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "ess_write_x_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2558-2571",
          "snippet": "int\ness_write_x_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tint error;\n\n\tDPRINTFN(2,(\"ess_write_x_reg: %02x=%02x\\n\", reg, val));\n\tif ((error = ess_wdsp(sc, reg)) == 0)\n\t\terror = ess_wdsp(sc, val);\n\n\treturn error;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_wdsp",
            "int\tess_write_x_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_wdsp;\nint\tess_write_x_reg;\n\nint\ness_write_x_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tint error;\n\n\tDPRINTFN(2,(\"ess_write_x_reg: %02x=%02x\\n\", reg, val));\n\tif ((error = ess_wdsp(sc, reg)) == 0)\n\t\terror = ess_wdsp(sc, val);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_read_x_reg",
          "args": [
            "sc",
            "reg"
          ],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "ess_read_x_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2576-2592",
          "snippet": "u_char\ness_read_x_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tint error;\n\tint val;\n\n\tif ((error = ess_wdsp(sc, 0xC0)) == 0)\n\t\terror = ess_wdsp(sc, reg);\n\tif (error)\n\t\tDPRINTF((\"Error reading extended register 0x%02x\\n\", reg));\n/* REVISIT: what if an error is returned above? */\n\tval = ess_rdsp(sc);\n\tDPRINTFN(2,(\"ess_read_x_reg: %02x=%02x\\n\", reg, val));\n\treturn val;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_rdsp",
            "int\tess_wdsp",
            "u_char\tess_read_x_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_rdsp;\nint\tess_wdsp;\nu_char\tess_read_x_reg;\n\nu_char\ness_read_x_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tint error;\n\tint val;\n\n\tif ((error = ess_wdsp(sc, 0xC0)) == 0)\n\t\terror = ess_wdsp(sc, reg);\n\tif (error)\n\t\tDPRINTF((\"Error reading extended register 0x%02x\\n\", reg));\n/* REVISIT: what if an error is returned above? */\n\tval = ess_rdsp(sc);\n\tDPRINTFN(2,(\"ess_read_x_reg: %02x=%02x\\n\", reg, val));\n\treturn val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_x_reg;\nint\tess_write_x_reg;\nvoid\tess_clear_xreg_bits;\n\nvoid\ness_clear_xreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tif (ess_write_x_reg(sc, reg, ess_read_x_reg(sc, reg) & ~mask) == -1)\n\t\tDPRINTF((\"Error clearing bits in extended register 0x%02x\\n\",\n\t\t\t reg));\n}"
  },
  {
    "function_name": "ess_read_x_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2576-2592",
    "snippet": "u_char\ness_read_x_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tint error;\n\tint val;\n\n\tif ((error = ess_wdsp(sc, 0xC0)) == 0)\n\t\terror = ess_wdsp(sc, reg);\n\tif (error)\n\t\tDPRINTF((\"Error reading extended register 0x%02x\\n\", reg));\n/* REVISIT: what if an error is returned above? */\n\tval = ess_rdsp(sc);\n\tDPRINTFN(2,(\"ess_read_x_reg: %02x=%02x\\n\", reg, val));\n\treturn val;\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_rdsp",
      "int\tess_wdsp",
      "u_char\tess_read_x_reg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"ess_read_x_reg: %02x=%02x\\n\", reg, val)"
          ],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_rdsp",
          "args": [
            "sc"
          ],
          "line": 2589
        },
        "resolved": true,
        "details": {
          "function_name": "ess_rdsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2508-2527",
          "snippet": "int\ness_rdsp(sc)\n\tstruct ess_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tfor (i = ESS_READ_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_read_ready(sc)) {\n\t\t\ti = EREAD1(iot, ioh, ESS_DSP_READ);\n\t\t\tDPRINTFN(8,(\"ess_rdsp() = 0x%02x\\n\", i));\n\t\t\treturn i;\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_rdsp: timed out\\n\"));\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_dsp_read_ready",
            "int\tess_rdsp"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_dsp_read_ready;\nint\tess_rdsp;\n\nint\ness_rdsp(sc)\n\tstruct ess_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tfor (i = ESS_READ_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_read_ready(sc)) {\n\t\t\ti = EREAD1(iot, ioh, ESS_DSP_READ);\n\t\t\tDPRINTFN(8,(\"ess_rdsp() = 0x%02x\\n\", i));\n\t\t\treturn i;\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_rdsp: timed out\\n\"));\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"Error reading extended register 0x%02x\\n\", reg)"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_wdsp",
          "args": [
            "sc",
            "reg"
          ],
          "line": 2585
        },
        "resolved": true,
        "details": {
          "function_name": "ess_wdsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2532-2553",
          "snippet": "int\ness_wdsp(sc, v)\n\tstruct ess_softc *sc;\n\tu_char v;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tDPRINTFN(8,(\"ess_wdsp(0x%02x)\\n\", v));\n\n\tfor (i = ESS_WRITE_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_write_ready(sc)) {\n\t\t\tEWRITE1(iot, ioh, ESS_DSP_WRITE, v);\n\t\t\treturn (0);\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_wdsp(0x%02x): timed out\\n\", v));\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_dsp_write_ready",
            "int\tess_wdsp"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_dsp_write_ready;\nint\tess_wdsp;\n\nint\ness_wdsp(sc, v)\n\tstruct ess_softc *sc;\n\tu_char v;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tDPRINTFN(8,(\"ess_wdsp(0x%02x)\\n\", v));\n\n\tfor (i = ESS_WRITE_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_write_ready(sc)) {\n\t\t\tEWRITE1(iot, ioh, ESS_DSP_WRITE, v);\n\t\t\treturn (0);\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_wdsp(0x%02x): timed out\\n\", v));\n\treturn (-1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_rdsp;\nint\tess_wdsp;\nu_char\tess_read_x_reg;\n\nu_char\ness_read_x_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tint error;\n\tint val;\n\n\tif ((error = ess_wdsp(sc, 0xC0)) == 0)\n\t\terror = ess_wdsp(sc, reg);\n\tif (error)\n\t\tDPRINTF((\"Error reading extended register 0x%02x\\n\", reg));\n/* REVISIT: what if an error is returned above? */\n\tval = ess_rdsp(sc);\n\tDPRINTFN(2,(\"ess_read_x_reg: %02x=%02x\\n\", reg, val));\n\treturn val;\n}"
  },
  {
    "function_name": "ess_write_x_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2558-2571",
    "snippet": "int\ness_write_x_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tint error;\n\n\tDPRINTFN(2,(\"ess_write_x_reg: %02x=%02x\\n\", reg, val));\n\tif ((error = ess_wdsp(sc, reg)) == 0)\n\t\terror = ess_wdsp(sc, val);\n\n\treturn error;\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_wdsp",
      "int\tess_write_x_reg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_wdsp",
          "args": [
            "sc",
            "val"
          ],
          "line": 2568
        },
        "resolved": true,
        "details": {
          "function_name": "ess_wdsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2532-2553",
          "snippet": "int\ness_wdsp(sc, v)\n\tstruct ess_softc *sc;\n\tu_char v;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tDPRINTFN(8,(\"ess_wdsp(0x%02x)\\n\", v));\n\n\tfor (i = ESS_WRITE_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_write_ready(sc)) {\n\t\t\tEWRITE1(iot, ioh, ESS_DSP_WRITE, v);\n\t\t\treturn (0);\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_wdsp(0x%02x): timed out\\n\", v));\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_dsp_write_ready",
            "int\tess_wdsp"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_dsp_write_ready;\nint\tess_wdsp;\n\nint\ness_wdsp(sc, v)\n\tstruct ess_softc *sc;\n\tu_char v;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tDPRINTFN(8,(\"ess_wdsp(0x%02x)\\n\", v));\n\n\tfor (i = ESS_WRITE_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_write_ready(sc)) {\n\t\t\tEWRITE1(iot, ioh, ESS_DSP_WRITE, v);\n\t\t\treturn (0);\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_wdsp(0x%02x): timed out\\n\", v));\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"ess_write_x_reg: %02x=%02x\\n\", reg, val)"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_wdsp;\nint\tess_write_x_reg;\n\nint\ness_write_x_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tint error;\n\n\tDPRINTFN(2,(\"ess_write_x_reg: %02x=%02x\\n\", reg, val));\n\tif ((error = ess_wdsp(sc, reg)) == 0)\n\t\terror = ess_wdsp(sc, val);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ess_wdsp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2532-2553",
    "snippet": "int\ness_wdsp(sc, v)\n\tstruct ess_softc *sc;\n\tu_char v;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tDPRINTFN(8,(\"ess_wdsp(0x%02x)\\n\", v));\n\n\tfor (i = ESS_WRITE_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_write_ready(sc)) {\n\t\t\tEWRITE1(iot, ioh, ESS_DSP_WRITE, v);\n\t\t\treturn (0);\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_wdsp(0x%02x): timed out\\n\", v));\n\treturn (-1);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_char\tess_dsp_write_ready",
      "int\tess_wdsp"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ess_wdsp(0x%02x): timed out\\n\", v)"
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EWRITE1",
          "args": [
            "iot",
            "ioh",
            "ESS_DSP_WRITE",
            "v"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_dsp_write_ready",
          "args": [
            "sc"
          ],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "ess_dsp_write_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2497-2502",
          "snippet": "u_char\ness_dsp_write_ready(sc)\n\tstruct ess_softc *sc;\n{\n\treturn ((ess_get_dsp_status(sc) & ESS_DSP_WRITE_BUSY) ? 0 : 1);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_get_dsp_status",
            "u_char\tess_dsp_write_ready"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_get_dsp_status;\nu_char\tess_dsp_write_ready;\n\nu_char\ness_dsp_write_ready(sc)\n\tstruct ess_softc *sc;\n{\n\treturn ((ess_get_dsp_status(sc) & ESS_DSP_WRITE_BUSY) ? 0 : 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "8",
            "(\"ess_wdsp(0x%02x)\\n\", v)"
          ],
          "line": 2541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_dsp_write_ready;\nint\tess_wdsp;\n\nint\ness_wdsp(sc, v)\n\tstruct ess_softc *sc;\n\tu_char v;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tDPRINTFN(8,(\"ess_wdsp(0x%02x)\\n\", v));\n\n\tfor (i = ESS_WRITE_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_write_ready(sc)) {\n\t\t\tEWRITE1(iot, ioh, ESS_DSP_WRITE, v);\n\t\t\treturn (0);\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_wdsp(0x%02x): timed out\\n\", v));\n\treturn (-1);\n}"
  },
  {
    "function_name": "ess_rdsp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2508-2527",
    "snippet": "int\ness_rdsp(sc)\n\tstruct ess_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tfor (i = ESS_READ_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_read_ready(sc)) {\n\t\t\ti = EREAD1(iot, ioh, ESS_DSP_READ);\n\t\t\tDPRINTFN(8,(\"ess_rdsp() = 0x%02x\\n\", i));\n\t\t\treturn i;\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_rdsp: timed out\\n\"));\n\treturn (-1);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_char\tess_dsp_read_ready",
      "int\tess_rdsp"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ess_rdsp: timed out\\n\")"
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10"
          ],
          "line": 2522
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "8",
            "(\"ess_rdsp() = 0x%02x\\n\", i)"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD1",
          "args": [
            "iot",
            "ioh",
            "ESS_DSP_READ"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_dsp_read_ready",
          "args": [
            "sc"
          ],
          "line": 2517
        },
        "resolved": true,
        "details": {
          "function_name": "ess_dsp_read_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2485-2490",
          "snippet": "u_char\ness_dsp_read_ready(sc)\n\tstruct ess_softc *sc;\n{\n\treturn ((ess_get_dsp_status(sc) & ESS_DSP_READ_READY) ? 1 : 0);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_get_dsp_status",
            "u_char\tess_dsp_read_ready"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_get_dsp_status;\nu_char\tess_dsp_read_ready;\n\nu_char\ness_dsp_read_ready(sc)\n\tstruct ess_softc *sc;\n{\n\treturn ((ess_get_dsp_status(sc) & ESS_DSP_READ_READY) ? 1 : 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_dsp_read_ready;\nint\tess_rdsp;\n\nint\ness_rdsp(sc)\n\tstruct ess_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tfor (i = ESS_READ_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_read_ready(sc)) {\n\t\t\ti = EREAD1(iot, ioh, ESS_DSP_READ);\n\t\t\tDPRINTFN(8,(\"ess_rdsp() = 0x%02x\\n\", i));\n\t\t\treturn i;\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_rdsp: timed out\\n\"));\n\treturn (-1);\n}"
  },
  {
    "function_name": "ess_dsp_write_ready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2497-2502",
    "snippet": "u_char\ness_dsp_write_ready(sc)\n\tstruct ess_softc *sc;\n{\n\treturn ((ess_get_dsp_status(sc) & ESS_DSP_WRITE_BUSY) ? 0 : 1);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_char\tess_get_dsp_status",
      "u_char\tess_dsp_write_ready"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_get_dsp_status",
          "args": [
            "sc"
          ],
          "line": 2501
        },
        "resolved": true,
        "details": {
          "function_name": "ess_get_dsp_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2473-2478",
          "snippet": "u_char\ness_get_dsp_status(sc)\n\tstruct ess_softc *sc;\n{\n\treturn (EREAD1(sc->sc_iot, sc->sc_ioh, ESS_DSP_RW_STATUS));\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_get_dsp_status"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_get_dsp_status;\n\nu_char\ness_get_dsp_status(sc)\n\tstruct ess_softc *sc;\n{\n\treturn (EREAD1(sc->sc_iot, sc->sc_ioh, ESS_DSP_RW_STATUS));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_get_dsp_status;\nu_char\tess_dsp_write_ready;\n\nu_char\ness_dsp_write_ready(sc)\n\tstruct ess_softc *sc;\n{\n\treturn ((ess_get_dsp_status(sc) & ESS_DSP_WRITE_BUSY) ? 0 : 1);\n}"
  },
  {
    "function_name": "ess_dsp_read_ready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2485-2490",
    "snippet": "u_char\ness_dsp_read_ready(sc)\n\tstruct ess_softc *sc;\n{\n\treturn ((ess_get_dsp_status(sc) & ESS_DSP_READ_READY) ? 1 : 0);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_char\tess_get_dsp_status",
      "u_char\tess_dsp_read_ready"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_get_dsp_status",
          "args": [
            "sc"
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "ess_get_dsp_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2473-2478",
          "snippet": "u_char\ness_get_dsp_status(sc)\n\tstruct ess_softc *sc;\n{\n\treturn (EREAD1(sc->sc_iot, sc->sc_ioh, ESS_DSP_RW_STATUS));\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_get_dsp_status"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_get_dsp_status;\n\nu_char\ness_get_dsp_status(sc)\n\tstruct ess_softc *sc;\n{\n\treturn (EREAD1(sc->sc_iot, sc->sc_ioh, ESS_DSP_RW_STATUS));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_get_dsp_status;\nu_char\tess_dsp_read_ready;\n\nu_char\ness_dsp_read_ready(sc)\n\tstruct ess_softc *sc;\n{\n\treturn ((ess_get_dsp_status(sc) & ESS_DSP_READ_READY) ? 1 : 0);\n}"
  },
  {
    "function_name": "ess_get_dsp_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2473-2478",
    "snippet": "u_char\ness_get_dsp_status(sc)\n\tstruct ess_softc *sc;\n{\n\treturn (EREAD1(sc->sc_iot, sc->sc_ioh, ESS_DSP_RW_STATUS));\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_char\tess_get_dsp_status"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EREAD1",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "ESS_DSP_RW_STATUS"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_get_dsp_status;\n\nu_char\ness_get_dsp_status(sc)\n\tstruct ess_softc *sc;\n{\n\treturn (EREAD1(sc->sc_iot, sc->sc_ioh, ESS_DSP_RW_STATUS));\n}"
  },
  {
    "function_name": "ess_srtofc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2457-2467",
    "snippet": "u_int\ness_srtofc(rate)\n\tu_int rate;\n{\n\t/*\n\t * The following formula is derived from the information in\n\t * the ES1887 data sheet, based on a roll-off frequency of\n\t * 87%.\n\t */\n\treturn (256 - 200279L / rate);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_int\tess_srtofc"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int\tess_srtofc;\n\nu_int\ness_srtofc(rate)\n\tu_int rate;\n{\n\t/*\n\t * The following formula is derived from the information in\n\t * the ES1887 data sheet, based on a roll-off frequency of\n\t * 87%.\n\t */\n\treturn (256 - 200279L / rate);\n}"
  },
  {
    "function_name": "ess_srtotc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2438-2451",
    "snippet": "u_int\ness_srtotc(rate)\n\tu_int rate;\n{\n\tu_int tc;\n\n\t/* The following formulae are from the ESS data sheet. */\n\tif (rate <= 22050)\n\t\ttc = 128 - 397700L / rate;\n\telse\n\t\ttc = 256 - 795500L / rate;\n\n\treturn (tc);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_int\tess_srtotc"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int\tess_srtotc;\n\nu_int\ness_srtotc(rate)\n\tu_int rate;\n{\n\tu_int tc;\n\n\t/* The following formulae are from the ESS data sheet. */\n\tif (rate <= 22050)\n\t\ttc = 128 - 397700L / rate;\n\telse\n\t\ttc = 256 - 795500L / rate;\n\n\treturn (tc);\n}"
  },
  {
    "function_name": "ess_speaker_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2426-2433",
    "snippet": "void\ness_speaker_off(sc)\n\tstruct ess_softc *sc;\n{\n\t/* Enable mute on left- and right-master volume. */\n\tess_set_mreg_bits(sc, ESS_MREG_VOLUME_LEFT, ESS_VOLUME_MUTE);\n\tess_set_mreg_bits(sc, ESS_MREG_VOLUME_RIGHT, ESS_VOLUME_MUTE);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tess_speaker_off",
      "void\tess_set_mreg_bits"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_set_mreg_bits",
          "args": [
            "sc",
            "ESS_MREG_VOLUME_RIGHT",
            "ESS_VOLUME_MUTE"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "ess_set_mreg_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2669-2676",
          "snippet": "void\ness_set_mreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) | mask);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_read_mix_reg",
            "void\tess_write_mix_reg",
            "void\tess_set_mreg_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_mix_reg;\nvoid\tess_write_mix_reg;\nvoid\tess_set_mreg_bits;\n\nvoid\ness_set_mreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) | mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_speaker_off;\nvoid\tess_set_mreg_bits;\n\nvoid\ness_speaker_off(sc)\n\tstruct ess_softc *sc;\n{\n\t/* Enable mute on left- and right-master volume. */\n\tess_set_mreg_bits(sc, ESS_MREG_VOLUME_LEFT, ESS_VOLUME_MUTE);\n\tess_set_mreg_bits(sc, ESS_MREG_VOLUME_RIGHT, ESS_VOLUME_MUTE);\n}"
  },
  {
    "function_name": "ess_speaker_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2417-2424",
    "snippet": "void\ness_speaker_on(sc)\n\tstruct ess_softc *sc;\n{\n\t/* Disable mute on left- and right-master volume. */\n\tess_clear_mreg_bits(sc, ESS_MREG_VOLUME_LEFT, ESS_VOLUME_MUTE);\n\tess_clear_mreg_bits(sc, ESS_MREG_VOLUME_RIGHT, ESS_VOLUME_MUTE);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tess_speaker_on",
      "void\tess_clear_mreg_bits"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_clear_mreg_bits",
          "args": [
            "sc",
            "ESS_MREG_VOLUME_RIGHT",
            "ESS_VOLUME_MUTE"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "ess_clear_mreg_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2660-2667",
          "snippet": "void\ness_clear_mreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) & ~mask);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_read_mix_reg",
            "void\tess_write_mix_reg",
            "void\tess_clear_mreg_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_mix_reg;\nvoid\tess_write_mix_reg;\nvoid\tess_clear_mreg_bits;\n\nvoid\ness_clear_mreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) & ~mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_speaker_on;\nvoid\tess_clear_mreg_bits;\n\nvoid\ness_speaker_on(sc)\n\tstruct ess_softc *sc;\n{\n\t/* Disable mute on left- and right-master volume. */\n\tess_clear_mreg_bits(sc, ESS_MREG_VOLUME_LEFT, ESS_VOLUME_MUTE);\n\tess_clear_mreg_bits(sc, ESS_MREG_VOLUME_RIGHT, ESS_VOLUME_MUTE);\n}"
  },
  {
    "function_name": "ess_set_in_ports",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2377-2415",
    "snippet": "int\ness_set_in_ports(sc, mask)\n\tstruct ess_softc *sc;\n\tint mask;\n{\n\tmixer_devinfo_t di;\n\tint i, port;\n\n\tDPRINTF((\"ess_set_in_ports: mask=0x%x\\n\", mask));\n\n\t/*\n\t * Get the device info for the record source control,\n\t * including the list of available sources.\n\t */\n\tdi.index = ESS_RECORD_SOURCE;\n\tif (ess_query_devinfo(sc, &di))\n\t\treturn EINVAL;\n\n\t/*\n\t * Set or disable the record volume control for each of the\n\t * possible sources.\n\t */\n\tfor (i = 0; i < di.un.s.num_mem; i++) {\n\t\t/*\n\t\t * Calculate the source port number from its mask.\n\t\t */\n\t\tport = ffs(di.un.s.member[i].mask);\n\n\t\t/*\n\t\t * Set the source gain:\n\t\t *\tto the current value if source is enabled\n\t\t *\tto zero if source is disabled\n\t\t */\n\t\tess_set_gain(sc, port, mask & di.un.s.member[i].mask);\n\t}\n\n\tsc->in_mask = mask;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_query_devinfo",
      "void\tess_set_gain",
      "int\tess_set_in_ports"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_set_gain",
          "args": [
            "sc",
            "port",
            "mask & di.un.s.member[i].mask"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "ess_set_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2247-2341",
          "snippet": "void\ness_set_gain(sc, port, on)\n\tstruct ess_softc *sc;\n\tint port;\n\tint on;\n{\n\tint gain, left, right;\n\tint mix;\n\tint src;\n\tint stereo;\n\n\t/*\n\t * Most gain controls are found in the mixer registers and\n\t * are stereo. Any that are not, must set mix and stereo as\n\t * required.\n\t */\n\tmix = 1;\n\tstereo = 1;\n\n\tswitch (port) {\n\tcase ESS_MASTER_VOL:\n\t\tsrc = ESS_MREG_VOLUME_MASTER;\n\t\tbreak;\n\tcase ESS_DAC_PLAY_VOL:\n\t\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\t\tsrc = ESS_MREG_VOLUME_VOICE;\n\t\telse\n\t\t\tsrc = 0x7C;\n\t\tbreak;\n\tcase ESS_MIC_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_MIC;\n\t\tbreak;\n\tcase ESS_LINE_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_LINE;\n\t\tbreak;\n\tcase ESS_SYNTH_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_SYNTH;\n\t\tbreak;\n\tcase ESS_CD_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_CD;\n\t\tbreak;\n\tcase ESS_AUXB_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_AUXB;\n\t\tbreak;\n\tcase ESS_PCSPEAKER_VOL:\n\t\tsrc = ESS_MREG_VOLUME_PCSPKR;\n\t\tstereo = 0;\n\t\tbreak;\n\tcase ESS_DAC_REC_VOL:\n\t\tsrc = 0x69;\n\t\tbreak;\n\tcase ESS_MIC_REC_VOL:\n\t\tsrc = 0x68;\n\t\tbreak;\n\tcase ESS_LINE_REC_VOL:\n\t\tsrc = 0x6E;\n\t\tbreak;\n\tcase ESS_SYNTH_REC_VOL:\n\t\tsrc = 0x6B;\n\t\tbreak;\n\tcase ESS_CD_REC_VOL:\n\t\tsrc = 0x6A;\n\t\tbreak;\n\tcase ESS_AUXB_REC_VOL:\n\t\tsrc = 0x6C;\n\t\tbreak;\n\tcase ESS_RECORD_VOL:\n\t\tsrc = ESS_XCMD_VOLIN_CTRL;\n\t\tmix = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t/* 1788 doesn't have a separate recording mixer */\n\tif (ESS_USE_AUDIO1(sc->sc_model) && mix && src > 0x62)\n\t\treturn;\n\n\tif (on) {\n\t\tleft = sc->gain[port][ESS_LEFT];\n\t\tright = sc->gain[port][ESS_RIGHT];\n\t} else {\n\t\tleft = right = 0;\n\t}\n\n\tif (stereo)\n\t\tgain = ESS_STEREO_GAIN(left, right);\n\telse\n\t\tgain = ESS_MONO_GAIN(left);\n\n\tif (mix)\n\t\tess_write_mix_reg(sc, src, gain);\n\telse\n\t\tess_write_x_reg(sc, src, gain);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_set_gain",
            "int\tess_write_x_reg",
            "void\tess_write_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_set_gain;\nint\tess_write_x_reg;\nvoid\tess_write_mix_reg;\n\nvoid\ness_set_gain(sc, port, on)\n\tstruct ess_softc *sc;\n\tint port;\n\tint on;\n{\n\tint gain, left, right;\n\tint mix;\n\tint src;\n\tint stereo;\n\n\t/*\n\t * Most gain controls are found in the mixer registers and\n\t * are stereo. Any that are not, must set mix and stereo as\n\t * required.\n\t */\n\tmix = 1;\n\tstereo = 1;\n\n\tswitch (port) {\n\tcase ESS_MASTER_VOL:\n\t\tsrc = ESS_MREG_VOLUME_MASTER;\n\t\tbreak;\n\tcase ESS_DAC_PLAY_VOL:\n\t\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\t\tsrc = ESS_MREG_VOLUME_VOICE;\n\t\telse\n\t\t\tsrc = 0x7C;\n\t\tbreak;\n\tcase ESS_MIC_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_MIC;\n\t\tbreak;\n\tcase ESS_LINE_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_LINE;\n\t\tbreak;\n\tcase ESS_SYNTH_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_SYNTH;\n\t\tbreak;\n\tcase ESS_CD_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_CD;\n\t\tbreak;\n\tcase ESS_AUXB_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_AUXB;\n\t\tbreak;\n\tcase ESS_PCSPEAKER_VOL:\n\t\tsrc = ESS_MREG_VOLUME_PCSPKR;\n\t\tstereo = 0;\n\t\tbreak;\n\tcase ESS_DAC_REC_VOL:\n\t\tsrc = 0x69;\n\t\tbreak;\n\tcase ESS_MIC_REC_VOL:\n\t\tsrc = 0x68;\n\t\tbreak;\n\tcase ESS_LINE_REC_VOL:\n\t\tsrc = 0x6E;\n\t\tbreak;\n\tcase ESS_SYNTH_REC_VOL:\n\t\tsrc = 0x6B;\n\t\tbreak;\n\tcase ESS_CD_REC_VOL:\n\t\tsrc = 0x6A;\n\t\tbreak;\n\tcase ESS_AUXB_REC_VOL:\n\t\tsrc = 0x6C;\n\t\tbreak;\n\tcase ESS_RECORD_VOL:\n\t\tsrc = ESS_XCMD_VOLIN_CTRL;\n\t\tmix = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t/* 1788 doesn't have a separate recording mixer */\n\tif (ESS_USE_AUDIO1(sc->sc_model) && mix && src > 0x62)\n\t\treturn;\n\n\tif (on) {\n\t\tleft = sc->gain[port][ESS_LEFT];\n\t\tright = sc->gain[port][ESS_RIGHT];\n\t} else {\n\t\tleft = right = 0;\n\t}\n\n\tif (stereo)\n\t\tgain = ESS_STEREO_GAIN(left, right);\n\telse\n\t\tgain = ESS_MONO_GAIN(left);\n\n\tif (mix)\n\t\tess_write_mix_reg(sc, src, gain);\n\telse\n\t\tess_write_x_reg(sc, src, gain);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "di.un.s.member[i].mask"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_validate_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1227-1248",
          "snippet": "STATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "ahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_query_devinfo",
          "args": [
            "sc",
            "&di"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "ess_query_devinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "1892-2153",
          "snippet": "int\ness_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTFN(5,(\"ess_query_devinfo: model=%d index=%d\\n\", \n\t\t    sc->sc_model, dip->index));\n\n\t/*\n\t * REVISIT: There are some slight differences between the\n\t *          mixers on the different ESS chips, which can\n\t *          be sorted out using the chip model rather than a\n\t *          separate mixer model.\n\t *          This is currently coded assuming an ES1887; we\n\t *          need to work out which bits are not applicable to\n\t *          the other models (1888 and 888).\n\t */\n\tswitch (dip->index) {\n\tcase ESS_DAC_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNdac);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_MIC_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\t\tdip->next = AUDIO_MIXER_LAST;\n\t\telse\n\t\t\tdip->next = ESS_MIC_PREAMP;\n\t\tstrcpy(dip->label.name, AudioNmicrophone);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_LINE_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNline);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_SYNTH_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNfmsynth);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_CD_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNcd);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_AUXB_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, \"auxb\");\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_INPUT_CLASS:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCinputs);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\n\tcase ESS_MASTER_VOL:\n\t\tdip->mixer_class = ESS_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNmaster);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_PCSPEAKER_VOL:\n\t\tdip->mixer_class = ESS_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, \"pc_speaker\");\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 1;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_OUTPUT_CLASS:\n\t\tdip->mixer_class = ESS_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCoutputs);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\n\tcase ESS_RECORD_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNrecord);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_RECORD_SOURCE:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNsource);\n\t\tif (ESS_USE_AUDIO1(sc->sc_model)) {\n\t\t\t/*\n\t\t\t * The 1788 doesn't use the input mixer control that\n\t\t\t * the 1888 uses, because it's a pain when you only\n\t\t\t * have one mixer. \n\t\t\t * Perhaps it could be emulated by keeping both sets of\n\t\t\t * gain values, and doing a `context switch' of the\n\t\t\t * mixer registers when shifting from playing to\n\t\t\t * recording.\n\t\t\t */\n\t\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\t\tdip->un.e.num_mem = 4;\n\t\t\tstrcpy(dip->un.e.member[0].label.name, AudioNmicrophone);\n\t\t\tdip->un.e.member[0].ord = ESS_SOURCE_MIC;\n\t\t\tstrcpy(dip->un.e.member[1].label.name, AudioNline);\n\t\t\tdip->un.e.member[1].ord = ESS_SOURCE_LINE;\n\t\t\tstrcpy(dip->un.e.member[2].label.name, AudioNcd);\n\t\t\tdip->un.e.member[2].ord = ESS_SOURCE_CD;\n\t\t\tstrcpy(dip->un.e.member[3].label.name, AudioNmixerout);\n\t\t\tdip->un.e.member[3].ord = ESS_SOURCE_MIXER;\n\t\t} else {\n\t\t\tdip->type = AUDIO_MIXER_SET;\n\t\t\tdip->un.s.num_mem = 6;\n\t\t\tstrcpy(dip->un.s.member[0].label.name, AudioNdac);\n\t\t\tdip->un.s.member[0].mask = 1 << ESS_DAC_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[1].label.name, AudioNmicrophone);\n\t\t\tdip->un.s.member[1].mask = 1 << ESS_MIC_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[2].label.name, AudioNline);\n\t\t\tdip->un.s.member[2].mask = 1 << ESS_LINE_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[3].label.name, AudioNfmsynth);\n\t\t\tdip->un.s.member[3].mask = 1 << ESS_SYNTH_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[4].label.name, AudioNcd);\n\t\t\tdip->un.s.member[4].mask = 1 << ESS_CD_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[5].label.name, \"auxb\");\n\t\t\tdip->un.s.member[5].mask = 1 << ESS_AUXB_REC_VOL;\n\t\t}\n\t\treturn (0);\n\n\tcase ESS_RECORD_CLASS:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCrecord);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\n\tcase ESS_RECORD_MONITOR:\n\t\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNmute);\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->mixer_class = ESS_MONITOR_CLASS;\n\t\tdip->un.e.num_mem = 2;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\t\tdip->un.e.member[0].ord = 0;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\t\tdip->un.e.member[1].ord = 1;\n\t\treturn (0);\n\n\tcase ESS_MONITOR_CLASS:\n\t\tdip->mixer_class = ESS_MONITOR_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCmonitor);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\t}\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\treturn (ENXIO);\n\n\tswitch (dip->index) {\n\tcase ESS_DAC_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNdac);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_MIC_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNmicrophone);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_LINE_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNline);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_SYNTH_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNfmsynth);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_CD_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNcd);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_AUXB_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, \"auxb\");\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_MIC_PREAMP:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->prev = ESS_MIC_PLAY_VOL;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNpreamp);\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->un.e.num_mem = 2;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\t\tdip->un.e.member[0].ord = 0;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\t\tdip->un.e.member[1].ord = 1;\n\t\treturn (0);\n\t}\n\n\treturn (ENXIO);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_query_devinfo",
            "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_query_devinfo;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTFN(5,(\"ess_query_devinfo: model=%d index=%d\\n\", \n\t\t    sc->sc_model, dip->index));\n\n\t/*\n\t * REVISIT: There are some slight differences between the\n\t *          mixers on the different ESS chips, which can\n\t *          be sorted out using the chip model rather than a\n\t *          separate mixer model.\n\t *          This is currently coded assuming an ES1887; we\n\t *          need to work out which bits are not applicable to\n\t *          the other models (1888 and 888).\n\t */\n\tswitch (dip->index) {\n\tcase ESS_DAC_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNdac);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_MIC_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\t\tdip->next = AUDIO_MIXER_LAST;\n\t\telse\n\t\t\tdip->next = ESS_MIC_PREAMP;\n\t\tstrcpy(dip->label.name, AudioNmicrophone);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_LINE_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNline);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_SYNTH_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNfmsynth);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_CD_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNcd);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_AUXB_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, \"auxb\");\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_INPUT_CLASS:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCinputs);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\n\tcase ESS_MASTER_VOL:\n\t\tdip->mixer_class = ESS_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNmaster);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_PCSPEAKER_VOL:\n\t\tdip->mixer_class = ESS_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, \"pc_speaker\");\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 1;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_OUTPUT_CLASS:\n\t\tdip->mixer_class = ESS_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCoutputs);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\n\tcase ESS_RECORD_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNrecord);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_RECORD_SOURCE:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNsource);\n\t\tif (ESS_USE_AUDIO1(sc->sc_model)) {\n\t\t\t/*\n\t\t\t * The 1788 doesn't use the input mixer control that\n\t\t\t * the 1888 uses, because it's a pain when you only\n\t\t\t * have one mixer. \n\t\t\t * Perhaps it could be emulated by keeping both sets of\n\t\t\t * gain values, and doing a `context switch' of the\n\t\t\t * mixer registers when shifting from playing to\n\t\t\t * recording.\n\t\t\t */\n\t\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\t\tdip->un.e.num_mem = 4;\n\t\t\tstrcpy(dip->un.e.member[0].label.name, AudioNmicrophone);\n\t\t\tdip->un.e.member[0].ord = ESS_SOURCE_MIC;\n\t\t\tstrcpy(dip->un.e.member[1].label.name, AudioNline);\n\t\t\tdip->un.e.member[1].ord = ESS_SOURCE_LINE;\n\t\t\tstrcpy(dip->un.e.member[2].label.name, AudioNcd);\n\t\t\tdip->un.e.member[2].ord = ESS_SOURCE_CD;\n\t\t\tstrcpy(dip->un.e.member[3].label.name, AudioNmixerout);\n\t\t\tdip->un.e.member[3].ord = ESS_SOURCE_MIXER;\n\t\t} else {\n\t\t\tdip->type = AUDIO_MIXER_SET;\n\t\t\tdip->un.s.num_mem = 6;\n\t\t\tstrcpy(dip->un.s.member[0].label.name, AudioNdac);\n\t\t\tdip->un.s.member[0].mask = 1 << ESS_DAC_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[1].label.name, AudioNmicrophone);\n\t\t\tdip->un.s.member[1].mask = 1 << ESS_MIC_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[2].label.name, AudioNline);\n\t\t\tdip->un.s.member[2].mask = 1 << ESS_LINE_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[3].label.name, AudioNfmsynth);\n\t\t\tdip->un.s.member[3].mask = 1 << ESS_SYNTH_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[4].label.name, AudioNcd);\n\t\t\tdip->un.s.member[4].mask = 1 << ESS_CD_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[5].label.name, \"auxb\");\n\t\t\tdip->un.s.member[5].mask = 1 << ESS_AUXB_REC_VOL;\n\t\t}\n\t\treturn (0);\n\n\tcase ESS_RECORD_CLASS:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCrecord);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\n\tcase ESS_RECORD_MONITOR:\n\t\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNmute);\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->mixer_class = ESS_MONITOR_CLASS;\n\t\tdip->un.e.num_mem = 2;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\t\tdip->un.e.member[0].ord = 0;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\t\tdip->un.e.member[1].ord = 1;\n\t\treturn (0);\n\n\tcase ESS_MONITOR_CLASS:\n\t\tdip->mixer_class = ESS_MONITOR_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCmonitor);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\t}\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\treturn (ENXIO);\n\n\tswitch (dip->index) {\n\tcase ESS_DAC_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNdac);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_MIC_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNmicrophone);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_LINE_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNline);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_SYNTH_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNfmsynth);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_CD_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNcd);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_AUXB_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, \"auxb\");\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_MIC_PREAMP:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->prev = ESS_MIC_PLAY_VOL;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNpreamp);\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->un.e.num_mem = 2;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\t\tdip->un.e.member[0].ord = 0;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\t\tdip->un.e.member[1].ord = 1;\n\t\treturn (0);\n\t}\n\n\treturn (ENXIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ess_set_in_ports: mask=0x%x\\n\", mask)"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_query_devinfo;\nvoid\tess_set_gain;\nint\tess_set_in_ports;\n\nint\ness_set_in_ports(sc, mask)\n\tstruct ess_softc *sc;\n\tint mask;\n{\n\tmixer_devinfo_t di;\n\tint i, port;\n\n\tDPRINTF((\"ess_set_in_ports: mask=0x%x\\n\", mask));\n\n\t/*\n\t * Get the device info for the record source control,\n\t * including the list of available sources.\n\t */\n\tdi.index = ESS_RECORD_SOURCE;\n\tif (ess_query_devinfo(sc, &di))\n\t\treturn EINVAL;\n\n\t/*\n\t * Set or disable the record volume control for each of the\n\t * possible sources.\n\t */\n\tfor (i = 0; i < di.un.s.num_mem; i++) {\n\t\t/*\n\t\t * Calculate the source port number from its mask.\n\t\t */\n\t\tport = ffs(di.un.s.member[i].mask);\n\n\t\t/*\n\t\t * Set the source gain:\n\t\t *\tto the current value if source is enabled\n\t\t *\tto zero if source is disabled\n\t\t */\n\t\tess_set_gain(sc, port, mask & di.un.s.member[i].mask);\n\t}\n\n\tsc->in_mask = mask;\n\treturn (0);\n}"
  },
  {
    "function_name": "ess_set_in_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2344-2374",
    "snippet": "int\ness_set_in_port(sc, ord)\n\tstruct ess_softc *sc;\n\tint ord;\n{\n\tmixer_devinfo_t di;\n\tint i;\n\n\tDPRINTF((\"ess_set_in_port: ord=0x%x\\n\", ord));\n\n\t/*\n\t * Get the device info for the record source control,\n\t * including the list of available sources.\n\t */\n\tdi.index = ESS_RECORD_SOURCE;\n\tif (ess_query_devinfo(sc, &di))\n\t\treturn EINVAL;\n\n\t/* See if the given ord value was anywhere in the list. */\n\tfor (i = 0; i < di.un.e.num_mem; i++) {\n\t\tif (ord == di.un.e.member[i].ord)\n\t\t\tbreak;\n\t}\n\tif (i == di.un.e.num_mem)\n\t\treturn EINVAL;\n\n\tess_write_mix_reg(sc, ESS_MREG_ADC_SOURCE, ord);\n\n\tsc->in_port = ord;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_query_devinfo",
      "int\tess_set_in_port",
      "void\tess_write_mix_reg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_write_mix_reg",
          "args": [
            "sc",
            "ESS_MREG_ADC_SOURCE",
            "ord"
          ],
          "line": 2370
        },
        "resolved": true,
        "details": {
          "function_name": "ess_write_mix_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2620-2636",
          "snippet": "void\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_write_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_write_mix_reg;\n\nvoid\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_query_devinfo",
          "args": [
            "sc",
            "&di"
          ],
          "line": 2359
        },
        "resolved": true,
        "details": {
          "function_name": "ess_query_devinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "1892-2153",
          "snippet": "int\ness_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTFN(5,(\"ess_query_devinfo: model=%d index=%d\\n\", \n\t\t    sc->sc_model, dip->index));\n\n\t/*\n\t * REVISIT: There are some slight differences between the\n\t *          mixers on the different ESS chips, which can\n\t *          be sorted out using the chip model rather than a\n\t *          separate mixer model.\n\t *          This is currently coded assuming an ES1887; we\n\t *          need to work out which bits are not applicable to\n\t *          the other models (1888 and 888).\n\t */\n\tswitch (dip->index) {\n\tcase ESS_DAC_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNdac);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_MIC_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\t\tdip->next = AUDIO_MIXER_LAST;\n\t\telse\n\t\t\tdip->next = ESS_MIC_PREAMP;\n\t\tstrcpy(dip->label.name, AudioNmicrophone);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_LINE_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNline);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_SYNTH_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNfmsynth);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_CD_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNcd);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_AUXB_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, \"auxb\");\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_INPUT_CLASS:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCinputs);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\n\tcase ESS_MASTER_VOL:\n\t\tdip->mixer_class = ESS_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNmaster);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_PCSPEAKER_VOL:\n\t\tdip->mixer_class = ESS_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, \"pc_speaker\");\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 1;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_OUTPUT_CLASS:\n\t\tdip->mixer_class = ESS_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCoutputs);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\n\tcase ESS_RECORD_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNrecord);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_RECORD_SOURCE:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNsource);\n\t\tif (ESS_USE_AUDIO1(sc->sc_model)) {\n\t\t\t/*\n\t\t\t * The 1788 doesn't use the input mixer control that\n\t\t\t * the 1888 uses, because it's a pain when you only\n\t\t\t * have one mixer. \n\t\t\t * Perhaps it could be emulated by keeping both sets of\n\t\t\t * gain values, and doing a `context switch' of the\n\t\t\t * mixer registers when shifting from playing to\n\t\t\t * recording.\n\t\t\t */\n\t\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\t\tdip->un.e.num_mem = 4;\n\t\t\tstrcpy(dip->un.e.member[0].label.name, AudioNmicrophone);\n\t\t\tdip->un.e.member[0].ord = ESS_SOURCE_MIC;\n\t\t\tstrcpy(dip->un.e.member[1].label.name, AudioNline);\n\t\t\tdip->un.e.member[1].ord = ESS_SOURCE_LINE;\n\t\t\tstrcpy(dip->un.e.member[2].label.name, AudioNcd);\n\t\t\tdip->un.e.member[2].ord = ESS_SOURCE_CD;\n\t\t\tstrcpy(dip->un.e.member[3].label.name, AudioNmixerout);\n\t\t\tdip->un.e.member[3].ord = ESS_SOURCE_MIXER;\n\t\t} else {\n\t\t\tdip->type = AUDIO_MIXER_SET;\n\t\t\tdip->un.s.num_mem = 6;\n\t\t\tstrcpy(dip->un.s.member[0].label.name, AudioNdac);\n\t\t\tdip->un.s.member[0].mask = 1 << ESS_DAC_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[1].label.name, AudioNmicrophone);\n\t\t\tdip->un.s.member[1].mask = 1 << ESS_MIC_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[2].label.name, AudioNline);\n\t\t\tdip->un.s.member[2].mask = 1 << ESS_LINE_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[3].label.name, AudioNfmsynth);\n\t\t\tdip->un.s.member[3].mask = 1 << ESS_SYNTH_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[4].label.name, AudioNcd);\n\t\t\tdip->un.s.member[4].mask = 1 << ESS_CD_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[5].label.name, \"auxb\");\n\t\t\tdip->un.s.member[5].mask = 1 << ESS_AUXB_REC_VOL;\n\t\t}\n\t\treturn (0);\n\n\tcase ESS_RECORD_CLASS:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCrecord);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\n\tcase ESS_RECORD_MONITOR:\n\t\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNmute);\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->mixer_class = ESS_MONITOR_CLASS;\n\t\tdip->un.e.num_mem = 2;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\t\tdip->un.e.member[0].ord = 0;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\t\tdip->un.e.member[1].ord = 1;\n\t\treturn (0);\n\n\tcase ESS_MONITOR_CLASS:\n\t\tdip->mixer_class = ESS_MONITOR_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCmonitor);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\t}\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\treturn (ENXIO);\n\n\tswitch (dip->index) {\n\tcase ESS_DAC_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNdac);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_MIC_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNmicrophone);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_LINE_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNline);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_SYNTH_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNfmsynth);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_CD_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNcd);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_AUXB_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, \"auxb\");\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_MIC_PREAMP:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->prev = ESS_MIC_PLAY_VOL;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNpreamp);\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->un.e.num_mem = 2;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\t\tdip->un.e.member[0].ord = 0;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\t\tdip->un.e.member[1].ord = 1;\n\t\treturn (0);\n\t}\n\n\treturn (ENXIO);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_query_devinfo",
            "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_query_devinfo;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTFN(5,(\"ess_query_devinfo: model=%d index=%d\\n\", \n\t\t    sc->sc_model, dip->index));\n\n\t/*\n\t * REVISIT: There are some slight differences between the\n\t *          mixers on the different ESS chips, which can\n\t *          be sorted out using the chip model rather than a\n\t *          separate mixer model.\n\t *          This is currently coded assuming an ES1887; we\n\t *          need to work out which bits are not applicable to\n\t *          the other models (1888 and 888).\n\t */\n\tswitch (dip->index) {\n\tcase ESS_DAC_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNdac);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_MIC_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\t\tdip->next = AUDIO_MIXER_LAST;\n\t\telse\n\t\t\tdip->next = ESS_MIC_PREAMP;\n\t\tstrcpy(dip->label.name, AudioNmicrophone);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_LINE_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNline);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_SYNTH_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNfmsynth);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_CD_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNcd);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_AUXB_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, \"auxb\");\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_INPUT_CLASS:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCinputs);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\n\tcase ESS_MASTER_VOL:\n\t\tdip->mixer_class = ESS_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNmaster);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_PCSPEAKER_VOL:\n\t\tdip->mixer_class = ESS_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, \"pc_speaker\");\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 1;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_OUTPUT_CLASS:\n\t\tdip->mixer_class = ESS_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCoutputs);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\n\tcase ESS_RECORD_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNrecord);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_RECORD_SOURCE:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNsource);\n\t\tif (ESS_USE_AUDIO1(sc->sc_model)) {\n\t\t\t/*\n\t\t\t * The 1788 doesn't use the input mixer control that\n\t\t\t * the 1888 uses, because it's a pain when you only\n\t\t\t * have one mixer. \n\t\t\t * Perhaps it could be emulated by keeping both sets of\n\t\t\t * gain values, and doing a `context switch' of the\n\t\t\t * mixer registers when shifting from playing to\n\t\t\t * recording.\n\t\t\t */\n\t\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\t\tdip->un.e.num_mem = 4;\n\t\t\tstrcpy(dip->un.e.member[0].label.name, AudioNmicrophone);\n\t\t\tdip->un.e.member[0].ord = ESS_SOURCE_MIC;\n\t\t\tstrcpy(dip->un.e.member[1].label.name, AudioNline);\n\t\t\tdip->un.e.member[1].ord = ESS_SOURCE_LINE;\n\t\t\tstrcpy(dip->un.e.member[2].label.name, AudioNcd);\n\t\t\tdip->un.e.member[2].ord = ESS_SOURCE_CD;\n\t\t\tstrcpy(dip->un.e.member[3].label.name, AudioNmixerout);\n\t\t\tdip->un.e.member[3].ord = ESS_SOURCE_MIXER;\n\t\t} else {\n\t\t\tdip->type = AUDIO_MIXER_SET;\n\t\t\tdip->un.s.num_mem = 6;\n\t\t\tstrcpy(dip->un.s.member[0].label.name, AudioNdac);\n\t\t\tdip->un.s.member[0].mask = 1 << ESS_DAC_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[1].label.name, AudioNmicrophone);\n\t\t\tdip->un.s.member[1].mask = 1 << ESS_MIC_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[2].label.name, AudioNline);\n\t\t\tdip->un.s.member[2].mask = 1 << ESS_LINE_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[3].label.name, AudioNfmsynth);\n\t\t\tdip->un.s.member[3].mask = 1 << ESS_SYNTH_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[4].label.name, AudioNcd);\n\t\t\tdip->un.s.member[4].mask = 1 << ESS_CD_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[5].label.name, \"auxb\");\n\t\t\tdip->un.s.member[5].mask = 1 << ESS_AUXB_REC_VOL;\n\t\t}\n\t\treturn (0);\n\n\tcase ESS_RECORD_CLASS:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCrecord);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\n\tcase ESS_RECORD_MONITOR:\n\t\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNmute);\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->mixer_class = ESS_MONITOR_CLASS;\n\t\tdip->un.e.num_mem = 2;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\t\tdip->un.e.member[0].ord = 0;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\t\tdip->un.e.member[1].ord = 1;\n\t\treturn (0);\n\n\tcase ESS_MONITOR_CLASS:\n\t\tdip->mixer_class = ESS_MONITOR_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCmonitor);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\t}\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\treturn (ENXIO);\n\n\tswitch (dip->index) {\n\tcase ESS_DAC_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNdac);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_MIC_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNmicrophone);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_LINE_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNline);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_SYNTH_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNfmsynth);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_CD_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNcd);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_AUXB_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, \"auxb\");\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_MIC_PREAMP:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->prev = ESS_MIC_PLAY_VOL;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNpreamp);\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->un.e.num_mem = 2;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\t\tdip->un.e.member[0].ord = 0;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\t\tdip->un.e.member[1].ord = 1;\n\t\treturn (0);\n\t}\n\n\treturn (ENXIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ess_set_in_port: ord=0x%x\\n\", ord)"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_query_devinfo;\nint\tess_set_in_port;\nvoid\tess_write_mix_reg;\n\nint\ness_set_in_port(sc, ord)\n\tstruct ess_softc *sc;\n\tint ord;\n{\n\tmixer_devinfo_t di;\n\tint i;\n\n\tDPRINTF((\"ess_set_in_port: ord=0x%x\\n\", ord));\n\n\t/*\n\t * Get the device info for the record source control,\n\t * including the list of available sources.\n\t */\n\tdi.index = ESS_RECORD_SOURCE;\n\tif (ess_query_devinfo(sc, &di))\n\t\treturn EINVAL;\n\n\t/* See if the given ord value was anywhere in the list. */\n\tfor (i = 0; i < di.un.e.num_mem; i++) {\n\t\tif (ord == di.un.e.member[i].ord)\n\t\t\tbreak;\n\t}\n\tif (i == di.un.e.num_mem)\n\t\treturn EINVAL;\n\n\tess_write_mix_reg(sc, ESS_MREG_ADC_SOURCE, ord);\n\n\tsc->in_port = ord;\n\treturn (0);\n}"
  },
  {
    "function_name": "ess_set_gain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2247-2341",
    "snippet": "void\ness_set_gain(sc, port, on)\n\tstruct ess_softc *sc;\n\tint port;\n\tint on;\n{\n\tint gain, left, right;\n\tint mix;\n\tint src;\n\tint stereo;\n\n\t/*\n\t * Most gain controls are found in the mixer registers and\n\t * are stereo. Any that are not, must set mix and stereo as\n\t * required.\n\t */\n\tmix = 1;\n\tstereo = 1;\n\n\tswitch (port) {\n\tcase ESS_MASTER_VOL:\n\t\tsrc = ESS_MREG_VOLUME_MASTER;\n\t\tbreak;\n\tcase ESS_DAC_PLAY_VOL:\n\t\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\t\tsrc = ESS_MREG_VOLUME_VOICE;\n\t\telse\n\t\t\tsrc = 0x7C;\n\t\tbreak;\n\tcase ESS_MIC_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_MIC;\n\t\tbreak;\n\tcase ESS_LINE_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_LINE;\n\t\tbreak;\n\tcase ESS_SYNTH_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_SYNTH;\n\t\tbreak;\n\tcase ESS_CD_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_CD;\n\t\tbreak;\n\tcase ESS_AUXB_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_AUXB;\n\t\tbreak;\n\tcase ESS_PCSPEAKER_VOL:\n\t\tsrc = ESS_MREG_VOLUME_PCSPKR;\n\t\tstereo = 0;\n\t\tbreak;\n\tcase ESS_DAC_REC_VOL:\n\t\tsrc = 0x69;\n\t\tbreak;\n\tcase ESS_MIC_REC_VOL:\n\t\tsrc = 0x68;\n\t\tbreak;\n\tcase ESS_LINE_REC_VOL:\n\t\tsrc = 0x6E;\n\t\tbreak;\n\tcase ESS_SYNTH_REC_VOL:\n\t\tsrc = 0x6B;\n\t\tbreak;\n\tcase ESS_CD_REC_VOL:\n\t\tsrc = 0x6A;\n\t\tbreak;\n\tcase ESS_AUXB_REC_VOL:\n\t\tsrc = 0x6C;\n\t\tbreak;\n\tcase ESS_RECORD_VOL:\n\t\tsrc = ESS_XCMD_VOLIN_CTRL;\n\t\tmix = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t/* 1788 doesn't have a separate recording mixer */\n\tif (ESS_USE_AUDIO1(sc->sc_model) && mix && src > 0x62)\n\t\treturn;\n\n\tif (on) {\n\t\tleft = sc->gain[port][ESS_LEFT];\n\t\tright = sc->gain[port][ESS_RIGHT];\n\t} else {\n\t\tleft = right = 0;\n\t}\n\n\tif (stereo)\n\t\tgain = ESS_STEREO_GAIN(left, right);\n\telse\n\t\tgain = ESS_MONO_GAIN(left);\n\n\tif (mix)\n\t\tess_write_mix_reg(sc, src, gain);\n\telse\n\t\tess_write_x_reg(sc, src, gain);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tess_set_gain",
      "int\tess_write_x_reg",
      "void\tess_write_mix_reg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_write_x_reg",
          "args": [
            "sc",
            "src",
            "gain"
          ],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "ess_write_x_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2558-2571",
          "snippet": "int\ness_write_x_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tint error;\n\n\tDPRINTFN(2,(\"ess_write_x_reg: %02x=%02x\\n\", reg, val));\n\tif ((error = ess_wdsp(sc, reg)) == 0)\n\t\terror = ess_wdsp(sc, val);\n\n\treturn error;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_wdsp",
            "int\tess_write_x_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_wdsp;\nint\tess_write_x_reg;\n\nint\ness_write_x_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tint error;\n\n\tDPRINTFN(2,(\"ess_write_x_reg: %02x=%02x\\n\", reg, val));\n\tif ((error = ess_wdsp(sc, reg)) == 0)\n\t\terror = ess_wdsp(sc, val);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_write_mix_reg",
          "args": [
            "sc",
            "src",
            "gain"
          ],
          "line": 2338
        },
        "resolved": true,
        "details": {
          "function_name": "ess_write_mix_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2620-2636",
          "snippet": "void\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_write_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_write_mix_reg;\n\nvoid\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESS_MONO_GAIN",
          "args": [
            "left"
          ],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESS_STEREO_GAIN",
          "args": [
            "left",
            "right"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESS_USE_AUDIO1",
          "args": [
            "sc->sc_model"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESS_USE_AUDIO1",
          "args": [
            "sc->sc_model"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_set_gain;\nint\tess_write_x_reg;\nvoid\tess_write_mix_reg;\n\nvoid\ness_set_gain(sc, port, on)\n\tstruct ess_softc *sc;\n\tint port;\n\tint on;\n{\n\tint gain, left, right;\n\tint mix;\n\tint src;\n\tint stereo;\n\n\t/*\n\t * Most gain controls are found in the mixer registers and\n\t * are stereo. Any that are not, must set mix and stereo as\n\t * required.\n\t */\n\tmix = 1;\n\tstereo = 1;\n\n\tswitch (port) {\n\tcase ESS_MASTER_VOL:\n\t\tsrc = ESS_MREG_VOLUME_MASTER;\n\t\tbreak;\n\tcase ESS_DAC_PLAY_VOL:\n\t\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\t\tsrc = ESS_MREG_VOLUME_VOICE;\n\t\telse\n\t\t\tsrc = 0x7C;\n\t\tbreak;\n\tcase ESS_MIC_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_MIC;\n\t\tbreak;\n\tcase ESS_LINE_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_LINE;\n\t\tbreak;\n\tcase ESS_SYNTH_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_SYNTH;\n\t\tbreak;\n\tcase ESS_CD_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_CD;\n\t\tbreak;\n\tcase ESS_AUXB_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_AUXB;\n\t\tbreak;\n\tcase ESS_PCSPEAKER_VOL:\n\t\tsrc = ESS_MREG_VOLUME_PCSPKR;\n\t\tstereo = 0;\n\t\tbreak;\n\tcase ESS_DAC_REC_VOL:\n\t\tsrc = 0x69;\n\t\tbreak;\n\tcase ESS_MIC_REC_VOL:\n\t\tsrc = 0x68;\n\t\tbreak;\n\tcase ESS_LINE_REC_VOL:\n\t\tsrc = 0x6E;\n\t\tbreak;\n\tcase ESS_SYNTH_REC_VOL:\n\t\tsrc = 0x6B;\n\t\tbreak;\n\tcase ESS_CD_REC_VOL:\n\t\tsrc = 0x6A;\n\t\tbreak;\n\tcase ESS_AUXB_REC_VOL:\n\t\tsrc = 0x6C;\n\t\tbreak;\n\tcase ESS_RECORD_VOL:\n\t\tsrc = ESS_XCMD_VOLIN_CTRL;\n\t\tmix = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t/* 1788 doesn't have a separate recording mixer */\n\tif (ESS_USE_AUDIO1(sc->sc_model) && mix && src > 0x62)\n\t\treturn;\n\n\tif (on) {\n\t\tleft = sc->gain[port][ESS_LEFT];\n\t\tright = sc->gain[port][ESS_RIGHT];\n\t} else {\n\t\tleft = right = 0;\n\t}\n\n\tif (stereo)\n\t\tgain = ESS_STEREO_GAIN(left, right);\n\telse\n\t\tgain = ESS_MONO_GAIN(left);\n\n\tif (mix)\n\t\tess_write_mix_reg(sc, src, gain);\n\telse\n\t\tess_write_x_reg(sc, src, gain);\n}"
  },
  {
    "function_name": "ess_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2225-2245",
    "snippet": "int\ness_reset(sc)\n\tstruct ess_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tsc->sc_audio1.active = 0;\n\tsc->sc_audio2.active = 0;\n\n\tEWRITE1(iot, ioh, ESS_DSP_RESET, ESS_RESET_EXT);\n\tdelay(10000);\n\tEWRITE1(iot, ioh, ESS_DSP_RESET, 0);\n\tif (ess_rdsp(sc) != ESS_MAGIC)\n\t\treturn (1);\n\n\t/* Enable access to the ESS extension commands. */\n\tess_wdsp(sc, ESS_ACMD_ENABLE_EXT);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_reset",
      "int\tess_rdsp",
      "int\tess_wdsp"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_wdsp",
          "args": [
            "sc",
            "ESS_ACMD_ENABLE_EXT"
          ],
          "line": 2242
        },
        "resolved": true,
        "details": {
          "function_name": "ess_wdsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2532-2553",
          "snippet": "int\ness_wdsp(sc, v)\n\tstruct ess_softc *sc;\n\tu_char v;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tDPRINTFN(8,(\"ess_wdsp(0x%02x)\\n\", v));\n\n\tfor (i = ESS_WRITE_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_write_ready(sc)) {\n\t\t\tEWRITE1(iot, ioh, ESS_DSP_WRITE, v);\n\t\t\treturn (0);\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_wdsp(0x%02x): timed out\\n\", v));\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_dsp_write_ready",
            "int\tess_wdsp"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_dsp_write_ready;\nint\tess_wdsp;\n\nint\ness_wdsp(sc, v)\n\tstruct ess_softc *sc;\n\tu_char v;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tDPRINTFN(8,(\"ess_wdsp(0x%02x)\\n\", v));\n\n\tfor (i = ESS_WRITE_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_write_ready(sc)) {\n\t\t\tEWRITE1(iot, ioh, ESS_DSP_WRITE, v);\n\t\t\treturn (0);\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_wdsp(0x%02x): timed out\\n\", v));\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_rdsp",
          "args": [
            "sc"
          ],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "ess_rdsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2508-2527",
          "snippet": "int\ness_rdsp(sc)\n\tstruct ess_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tfor (i = ESS_READ_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_read_ready(sc)) {\n\t\t\ti = EREAD1(iot, ioh, ESS_DSP_READ);\n\t\t\tDPRINTFN(8,(\"ess_rdsp() = 0x%02x\\n\", i));\n\t\t\treturn i;\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_rdsp: timed out\\n\"));\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_dsp_read_ready",
            "int\tess_rdsp"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_dsp_read_ready;\nint\tess_rdsp;\n\nint\ness_rdsp(sc)\n\tstruct ess_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tfor (i = ESS_READ_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_read_ready(sc)) {\n\t\t\ti = EREAD1(iot, ioh, ESS_DSP_READ);\n\t\t\tDPRINTFN(8,(\"ess_rdsp() = 0x%02x\\n\", i));\n\t\t\treturn i;\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_rdsp: timed out\\n\"));\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EWRITE1",
          "args": [
            "iot",
            "ioh",
            "ESS_DSP_RESET",
            "0"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10000"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EWRITE1",
          "args": [
            "iot",
            "ioh",
            "ESS_DSP_RESET",
            "ESS_RESET_EXT"
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_reset;\nint\tess_rdsp;\nint\tess_wdsp;\n\nint\ness_reset(sc)\n\tstruct ess_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tsc->sc_audio1.active = 0;\n\tsc->sc_audio2.active = 0;\n\n\tEWRITE1(iot, ioh, ESS_DSP_RESET, ESS_RESET_EXT);\n\tdelay(10000);\n\tEWRITE1(iot, ioh, ESS_DSP_RESET, 0);\n\tif (ess_rdsp(sc) != ESS_MAGIC)\n\t\treturn (1);\n\n\t/* Enable access to the ESS extension commands. */\n\tess_wdsp(sc, ESS_ACMD_ENABLE_EXT);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "ess_1888_get_props",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2208-2214",
    "snippet": "int\ness_1888_get_props(addr)\n\tvoid *addr;\n{\n\n\treturn (AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT | AUDIO_PROP_FULLDUPLEX);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_1888_get_props",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_1888_get_props;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_1888_get_props(addr)\n\tvoid *addr;\n{\n\n\treturn (AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT | AUDIO_PROP_FULLDUPLEX);\n}"
  },
  {
    "function_name": "ess_1788_get_props",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2200-2206",
    "snippet": "int\ness_1788_get_props(addr)\n\tvoid *addr;\n{\n\n\treturn (AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_1788_get_props",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_1788_get_props;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_1788_get_props(addr)\n\tvoid *addr;\n{\n\n\treturn (AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT);\n}"
  },
  {
    "function_name": "ess_mappage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2190-2198",
    "snippet": "int\ness_mappage(addr, mem, off, prot)\n\tvoid *addr;\n\tvoid *mem;\n\tint off;\n\tint prot;\n{\n\treturn (isa_mappage(mem, off, prot));\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_mappage",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isa_mappage",
          "args": [
            "mem",
            "off",
            "prot"
          ],
          "line": 2197
        },
        "resolved": true,
        "details": {
          "function_name": "isa_mappage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "729-745",
          "snippet": "int\nisa_mappage(mem, off, prot)\n\tvoid *mem;\n\tint off;\n\tint prot;\n{\n\tstruct isa_mem *m;\n\n\tfor(m = isa_mem_head; m && m->kva != (caddr_t)mem; m = m->next)\n\t\t;\n\tif (!m) {\n\t\tprintf(\"isa_mappage: mapping unallocted memory\\n\");\n\t\treturn -1;\n\t}\n\treturn (isa_dmamem_mmap(m->isadev, m->chan, m->addr, m->size, off,\n\t    prot, BUS_DMA_WAITOK));\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct isa_mem {\n\tstruct device *isadev;\n\tint chan;\n\tbus_size_t size;\n\tbus_addr_t addr;\n\tcaddr_t kva;\n\tstruct isa_mem *next;\n} *isa_mem_head = 0;",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;",
            "size_t size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct isa_mem {\n\tstruct device *isadev;\n\tint chan;\n\tbus_size_t size;\n\tbus_addr_t addr;\n\tcaddr_t kva;\n\tstruct isa_mem *next;\n} *isa_mem_head = 0;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\nsize_t size;\n\nint\nisa_mappage(mem, off, prot)\n\tvoid *mem;\n\tint off;\n\tint prot;\n{\n\tstruct isa_mem *m;\n\n\tfor(m = isa_mem_head; m && m->kva != (caddr_t)mem; m = m->next)\n\t\t;\n\tif (!m) {\n\t\tprintf(\"isa_mappage: mapping unallocted memory\\n\");\n\t\treturn -1;\n\t}\n\treturn (isa_dmamem_mmap(m->isadev, m->chan, m->addr, m->size, off,\n\t    prot, BUS_DMA_WAITOK));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_mappage;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_mappage(addr, mem, off, prot)\n\tvoid *addr;\n\tvoid *mem;\n\tint off;\n\tint prot;\n{\n\treturn (isa_mappage(mem, off, prot));\n}"
  },
  {
    "function_name": "ess_round_buffersize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2180-2188",
    "snippet": "unsigned long\ness_round_buffersize(addr, size)\n\tvoid *addr;\n\tunsigned long size;\n{\n\tif (size > MAX_ISADMA)\n\t\tsize = MAX_ISADMA;\n\treturn (size);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;",
      "unsigned long size;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\nunsigned long size;\n\nunsigned long\ness_round_buffersize(addr, size)\n\tvoid *addr;\n\tunsigned long size;\n{\n\tif (size > MAX_ISADMA)\n\t\tsize = MAX_ISADMA;\n\treturn (size);\n}"
  },
  {
    "function_name": "ess_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "2171-2178",
    "snippet": "void\ness_free(addr, ptr, pool)\n\tvoid *addr;\n\tvoid *ptr;\n\tint pool;\n{\n\tisa_free(ptr, pool);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tess_free",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isa_free",
          "args": [
            "ptr",
            "pool"
          ],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "isa_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "708-727",
          "snippet": "void\nisa_free(addr, pool)\n\tvoid *addr;\n\tint pool;\n{\n\tstruct isa_mem **mp, *m;\n\tcaddr_t kva = (caddr_t)addr;\n\n\tfor(mp = &isa_mem_head; *mp && (*mp)->kva != kva; mp = &(*mp)->next)\n\t\t;\n\tm = *mp;\n\tif (!m) {\n\t\tprintf(\"isa_free: freeing unallocted memory\\n\");\n\t\treturn;\n\t}\n\t*mp = m->next;\n\tisa_dmamem_unmap(m->isadev, m->chan, kva, m->size);\n\tisa_dmamem_free(m->isadev, m->chan, m->addr, m->size);\n\tfree(m, pool);\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct isa_mem {\n\tstruct device *isadev;\n\tint chan;\n\tbus_size_t size;\n\tbus_addr_t addr;\n\tcaddr_t kva;\n\tstruct isa_mem *next;\n} *isa_mem_head = 0;",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;",
            "size_t size;",
            "int pool;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct isa_mem {\n\tstruct device *isadev;\n\tint chan;\n\tbus_size_t size;\n\tbus_addr_t addr;\n\tcaddr_t kva;\n\tstruct isa_mem *next;\n} *isa_mem_head = 0;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\nsize_t size;\nint pool;\n\nvoid\nisa_free(addr, pool)\n\tvoid *addr;\n\tint pool;\n{\n\tstruct isa_mem **mp, *m;\n\tcaddr_t kva = (caddr_t)addr;\n\n\tfor(mp = &isa_mem_head; *mp && (*mp)->kva != kva; mp = &(*mp)->next)\n\t\t;\n\tm = *mp;\n\tif (!m) {\n\t\tprintf(\"isa_free: freeing unallocted memory\\n\");\n\t\treturn;\n\t}\n\t*mp = m->next;\n\tisa_dmamem_unmap(m->isadev, m->chan, kva, m->size);\n\tisa_dmamem_free(m->isadev, m->chan, m->addr, m->size);\n\tfree(m, pool);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_free;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nvoid\ness_free(addr, ptr, pool)\n\tvoid *addr;\n\tvoid *ptr;\n\tint pool;\n{\n\tisa_free(ptr, pool);\n}"
  },
  {
    "function_name": "ess_query_devinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1892-2153",
    "snippet": "int\ness_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTFN(5,(\"ess_query_devinfo: model=%d index=%d\\n\", \n\t\t    sc->sc_model, dip->index));\n\n\t/*\n\t * REVISIT: There are some slight differences between the\n\t *          mixers on the different ESS chips, which can\n\t *          be sorted out using the chip model rather than a\n\t *          separate mixer model.\n\t *          This is currently coded assuming an ES1887; we\n\t *          need to work out which bits are not applicable to\n\t *          the other models (1888 and 888).\n\t */\n\tswitch (dip->index) {\n\tcase ESS_DAC_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNdac);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_MIC_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\t\tdip->next = AUDIO_MIXER_LAST;\n\t\telse\n\t\t\tdip->next = ESS_MIC_PREAMP;\n\t\tstrcpy(dip->label.name, AudioNmicrophone);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_LINE_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNline);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_SYNTH_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNfmsynth);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_CD_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNcd);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_AUXB_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, \"auxb\");\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_INPUT_CLASS:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCinputs);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\n\tcase ESS_MASTER_VOL:\n\t\tdip->mixer_class = ESS_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNmaster);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_PCSPEAKER_VOL:\n\t\tdip->mixer_class = ESS_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, \"pc_speaker\");\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 1;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_OUTPUT_CLASS:\n\t\tdip->mixer_class = ESS_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCoutputs);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\n\tcase ESS_RECORD_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNrecord);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_RECORD_SOURCE:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNsource);\n\t\tif (ESS_USE_AUDIO1(sc->sc_model)) {\n\t\t\t/*\n\t\t\t * The 1788 doesn't use the input mixer control that\n\t\t\t * the 1888 uses, because it's a pain when you only\n\t\t\t * have one mixer. \n\t\t\t * Perhaps it could be emulated by keeping both sets of\n\t\t\t * gain values, and doing a `context switch' of the\n\t\t\t * mixer registers when shifting from playing to\n\t\t\t * recording.\n\t\t\t */\n\t\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\t\tdip->un.e.num_mem = 4;\n\t\t\tstrcpy(dip->un.e.member[0].label.name, AudioNmicrophone);\n\t\t\tdip->un.e.member[0].ord = ESS_SOURCE_MIC;\n\t\t\tstrcpy(dip->un.e.member[1].label.name, AudioNline);\n\t\t\tdip->un.e.member[1].ord = ESS_SOURCE_LINE;\n\t\t\tstrcpy(dip->un.e.member[2].label.name, AudioNcd);\n\t\t\tdip->un.e.member[2].ord = ESS_SOURCE_CD;\n\t\t\tstrcpy(dip->un.e.member[3].label.name, AudioNmixerout);\n\t\t\tdip->un.e.member[3].ord = ESS_SOURCE_MIXER;\n\t\t} else {\n\t\t\tdip->type = AUDIO_MIXER_SET;\n\t\t\tdip->un.s.num_mem = 6;\n\t\t\tstrcpy(dip->un.s.member[0].label.name, AudioNdac);\n\t\t\tdip->un.s.member[0].mask = 1 << ESS_DAC_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[1].label.name, AudioNmicrophone);\n\t\t\tdip->un.s.member[1].mask = 1 << ESS_MIC_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[2].label.name, AudioNline);\n\t\t\tdip->un.s.member[2].mask = 1 << ESS_LINE_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[3].label.name, AudioNfmsynth);\n\t\t\tdip->un.s.member[3].mask = 1 << ESS_SYNTH_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[4].label.name, AudioNcd);\n\t\t\tdip->un.s.member[4].mask = 1 << ESS_CD_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[5].label.name, \"auxb\");\n\t\t\tdip->un.s.member[5].mask = 1 << ESS_AUXB_REC_VOL;\n\t\t}\n\t\treturn (0);\n\n\tcase ESS_RECORD_CLASS:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCrecord);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\n\tcase ESS_RECORD_MONITOR:\n\t\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNmute);\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->mixer_class = ESS_MONITOR_CLASS;\n\t\tdip->un.e.num_mem = 2;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\t\tdip->un.e.member[0].ord = 0;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\t\tdip->un.e.member[1].ord = 1;\n\t\treturn (0);\n\n\tcase ESS_MONITOR_CLASS:\n\t\tdip->mixer_class = ESS_MONITOR_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCmonitor);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\t}\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\treturn (ENXIO);\n\n\tswitch (dip->index) {\n\tcase ESS_DAC_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNdac);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_MIC_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNmicrophone);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_LINE_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNline);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_SYNTH_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNfmsynth);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_CD_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNcd);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_AUXB_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, \"auxb\");\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_MIC_PREAMP:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->prev = ESS_MIC_PLAY_VOL;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNpreamp);\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->un.e.num_mem = 2;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\t\tdip->un.e.member[0].ord = 0;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\t\tdip->un.e.member[1].ord = 1;\n\t\treturn (0);\n\t}\n\n\treturn (ENXIO);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_query_devinfo",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[1].label.name",
            "AudioNon"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[0].label.name",
            "AudioNoff"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNpreamp"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "\"auxb\""
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNcd"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNfmsynth"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNline"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmicrophone"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNdac"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESS_USE_AUDIO1",
          "args": [
            "sc->sc_model"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCmonitor"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[1].label.name",
            "AudioNon"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[0].label.name",
            "AudioNoff"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmute"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCrecord"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.s.member[5].label.name",
            "\"auxb\""
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.s.member[4].label.name",
            "AudioNcd"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.s.member[3].label.name",
            "AudioNfmsynth"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.s.member[2].label.name",
            "AudioNline"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.s.member[1].label.name",
            "AudioNmicrophone"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.s.member[0].label.name",
            "AudioNdac"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[3].label.name",
            "AudioNmixerout"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[2].label.name",
            "AudioNcd"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[1].label.name",
            "AudioNline"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[0].label.name",
            "AudioNmicrophone"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESS_USE_AUDIO1",
          "args": [
            "sc->sc_model"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNsource"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNrecord"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCoutputs"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "\"pc_speaker\""
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmaster"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCinputs"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "\"auxb\""
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNcd"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNfmsynth"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNline"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmicrophone"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESS_USE_AUDIO1",
          "args": [
            "sc->sc_model"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNdac"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ess_query_devinfo: model=%d index=%d\\n\", \n\t\t    sc->sc_model, dip->index)"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_query_devinfo;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTFN(5,(\"ess_query_devinfo: model=%d index=%d\\n\", \n\t\t    sc->sc_model, dip->index));\n\n\t/*\n\t * REVISIT: There are some slight differences between the\n\t *          mixers on the different ESS chips, which can\n\t *          be sorted out using the chip model rather than a\n\t *          separate mixer model.\n\t *          This is currently coded assuming an ES1887; we\n\t *          need to work out which bits are not applicable to\n\t *          the other models (1888 and 888).\n\t */\n\tswitch (dip->index) {\n\tcase ESS_DAC_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNdac);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_MIC_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\t\tdip->next = AUDIO_MIXER_LAST;\n\t\telse\n\t\t\tdip->next = ESS_MIC_PREAMP;\n\t\tstrcpy(dip->label.name, AudioNmicrophone);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_LINE_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNline);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_SYNTH_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNfmsynth);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_CD_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNcd);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_AUXB_PLAY_VOL:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, \"auxb\");\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_INPUT_CLASS:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCinputs);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\n\tcase ESS_MASTER_VOL:\n\t\tdip->mixer_class = ESS_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNmaster);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_PCSPEAKER_VOL:\n\t\tdip->mixer_class = ESS_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, \"pc_speaker\");\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 1;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_OUTPUT_CLASS:\n\t\tdip->mixer_class = ESS_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCoutputs);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\n\tcase ESS_RECORD_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNrecord);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_RECORD_SOURCE:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNsource);\n\t\tif (ESS_USE_AUDIO1(sc->sc_model)) {\n\t\t\t/*\n\t\t\t * The 1788 doesn't use the input mixer control that\n\t\t\t * the 1888 uses, because it's a pain when you only\n\t\t\t * have one mixer. \n\t\t\t * Perhaps it could be emulated by keeping both sets of\n\t\t\t * gain values, and doing a `context switch' of the\n\t\t\t * mixer registers when shifting from playing to\n\t\t\t * recording.\n\t\t\t */\n\t\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\t\tdip->un.e.num_mem = 4;\n\t\t\tstrcpy(dip->un.e.member[0].label.name, AudioNmicrophone);\n\t\t\tdip->un.e.member[0].ord = ESS_SOURCE_MIC;\n\t\t\tstrcpy(dip->un.e.member[1].label.name, AudioNline);\n\t\t\tdip->un.e.member[1].ord = ESS_SOURCE_LINE;\n\t\t\tstrcpy(dip->un.e.member[2].label.name, AudioNcd);\n\t\t\tdip->un.e.member[2].ord = ESS_SOURCE_CD;\n\t\t\tstrcpy(dip->un.e.member[3].label.name, AudioNmixerout);\n\t\t\tdip->un.e.member[3].ord = ESS_SOURCE_MIXER;\n\t\t} else {\n\t\t\tdip->type = AUDIO_MIXER_SET;\n\t\t\tdip->un.s.num_mem = 6;\n\t\t\tstrcpy(dip->un.s.member[0].label.name, AudioNdac);\n\t\t\tdip->un.s.member[0].mask = 1 << ESS_DAC_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[1].label.name, AudioNmicrophone);\n\t\t\tdip->un.s.member[1].mask = 1 << ESS_MIC_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[2].label.name, AudioNline);\n\t\t\tdip->un.s.member[2].mask = 1 << ESS_LINE_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[3].label.name, AudioNfmsynth);\n\t\t\tdip->un.s.member[3].mask = 1 << ESS_SYNTH_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[4].label.name, AudioNcd);\n\t\t\tdip->un.s.member[4].mask = 1 << ESS_CD_REC_VOL;\n\t\t\tstrcpy(dip->un.s.member[5].label.name, \"auxb\");\n\t\t\tdip->un.s.member[5].mask = 1 << ESS_AUXB_REC_VOL;\n\t\t}\n\t\treturn (0);\n\n\tcase ESS_RECORD_CLASS:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCrecord);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\n\tcase ESS_RECORD_MONITOR:\n\t\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNmute);\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->mixer_class = ESS_MONITOR_CLASS;\n\t\tdip->un.e.num_mem = 2;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\t\tdip->un.e.member[0].ord = 0;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\t\tdip->un.e.member[1].ord = 1;\n\t\treturn (0);\n\n\tcase ESS_MONITOR_CLASS:\n\t\tdip->mixer_class = ESS_MONITOR_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCmonitor);\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\treturn (0);\n\t}\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\treturn (ENXIO);\n\n\tswitch (dip->index) {\n\tcase ESS_DAC_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNdac);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_MIC_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNmicrophone);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_LINE_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNline);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_SYNTH_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNfmsynth);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_CD_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNcd);\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_AUXB_REC_VOL:\n\t\tdip->mixer_class = ESS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, \"auxb\");\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\n\tcase ESS_MIC_PREAMP:\n\t\tdip->mixer_class = ESS_INPUT_CLASS;\n\t\tdip->prev = ESS_MIC_PLAY_VOL;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNpreamp);\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->un.e.num_mem = 2;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\t\tdip->un.e.member[0].ord = 0;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\t\tdip->un.e.member[1].ord = 1;\n\t\treturn (0);\n\t}\n\n\treturn (ENXIO);\n}"
  },
  {
    "function_name": "ess_get_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1802-1890",
    "snippet": "int\ness_get_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct ess_softc *sc = addr;\n    \n\tDPRINTFN(5,(\"ess_get_port: port=%d\\n\", cp->dev));\n\n\tswitch (cp->dev) {\n\tcase ESS_MASTER_VOL:\n\tcase ESS_DAC_PLAY_VOL:\n\tcase ESS_MIC_PLAY_VOL:\n\tcase ESS_LINE_PLAY_VOL:\n\tcase ESS_SYNTH_PLAY_VOL:\n\tcase ESS_CD_PLAY_VOL:\n\tcase ESS_AUXB_PLAY_VOL:\n\tcase ESS_RECORD_VOL:\n\t\tswitch (cp->un.value.num_channels) {\n\t\tcase 1:\n\t\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = \n\t\t\t\tsc->gain[cp->dev][ESS_LEFT];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = \n\t\t\t\tsc->gain[cp->dev][ESS_LEFT];\n\t\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = \n\t\t\t\tsc->gain[cp->dev][ESS_RIGHT];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EINVAL;\n\t\t}\n\t\treturn (0);\n\n\tcase ESS_PCSPEAKER_VOL:\n\t\tif (cp->un.value.num_channels != 1)\n\t\t\treturn EINVAL;\n\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = \n\t\t\tsc->gain[cp->dev][ESS_LEFT];\n\t\treturn (0);\n\n\tcase ESS_RECORD_SOURCE:\n\t\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\t\tcp->un.ord = sc->in_port;\n\t\telse\n\t\t\tcp->un.mask = sc->in_mask;\n\t\treturn (0);\n\n\tcase ESS_RECORD_MONITOR:\n\t\tcp->un.ord = (ess_read_x_reg(sc, ESS_XCMD_AUDIO_CTRL) &\n\t\t\t      ESS_AUDIO_CTRL_MONITOR) ? 1 : 0;\n\t\treturn (0);\n\t}\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\treturn (EINVAL);\n\n\tswitch (cp->dev) {\n\tcase ESS_DAC_REC_VOL:\n\tcase ESS_MIC_REC_VOL:\n\tcase ESS_LINE_REC_VOL:\n\tcase ESS_SYNTH_REC_VOL:\n\tcase ESS_CD_REC_VOL:\n\tcase ESS_AUXB_REC_VOL:\n\t\tswitch (cp->un.value.num_channels) {\n\t\tcase 1:\n\t\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = \n\t\t\t\tsc->gain[cp->dev][ESS_LEFT];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = \n\t\t\t\tsc->gain[cp->dev][ESS_LEFT];\n\t\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = \n\t\t\t\tsc->gain[cp->dev][ESS_RIGHT];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EINVAL;\n\t\t}\n\t\treturn (0);\n\n\tcase ESS_MIC_PREAMP:\n\t\tcp->un.ord = (ess_read_x_reg(sc, ESS_XCMD_PREAMP_CTRL) &\n\t\t\t      ESS_PREAMP_CTRL_ENABLE) ? 1 : 0;\n\t\treturn (0);\n\t}\n\n\treturn (EINVAL);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_get_port",
      "u_char\tess_read_x_reg",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_read_x_reg",
          "args": [
            "sc",
            "ESS_XCMD_PREAMP_CTRL"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "ess_read_x_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2576-2592",
          "snippet": "u_char\ness_read_x_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tint error;\n\tint val;\n\n\tif ((error = ess_wdsp(sc, 0xC0)) == 0)\n\t\terror = ess_wdsp(sc, reg);\n\tif (error)\n\t\tDPRINTF((\"Error reading extended register 0x%02x\\n\", reg));\n/* REVISIT: what if an error is returned above? */\n\tval = ess_rdsp(sc);\n\tDPRINTFN(2,(\"ess_read_x_reg: %02x=%02x\\n\", reg, val));\n\treturn val;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_rdsp",
            "int\tess_wdsp",
            "u_char\tess_read_x_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_rdsp;\nint\tess_wdsp;\nu_char\tess_read_x_reg;\n\nu_char\ness_read_x_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tint error;\n\tint val;\n\n\tif ((error = ess_wdsp(sc, 0xC0)) == 0)\n\t\terror = ess_wdsp(sc, reg);\n\tif (error)\n\t\tDPRINTF((\"Error reading extended register 0x%02x\\n\", reg));\n/* REVISIT: what if an error is returned above? */\n\tval = ess_rdsp(sc);\n\tDPRINTFN(2,(\"ess_read_x_reg: %02x=%02x\\n\", reg, val));\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESS_USE_AUDIO1",
          "args": [
            "sc->sc_model"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESS_USE_AUDIO1",
          "args": [
            "sc->sc_model"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ess_get_port: port=%d\\n\", cp->dev)"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_get_port;\nu_char\tess_read_x_reg;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_get_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct ess_softc *sc = addr;\n    \n\tDPRINTFN(5,(\"ess_get_port: port=%d\\n\", cp->dev));\n\n\tswitch (cp->dev) {\n\tcase ESS_MASTER_VOL:\n\tcase ESS_DAC_PLAY_VOL:\n\tcase ESS_MIC_PLAY_VOL:\n\tcase ESS_LINE_PLAY_VOL:\n\tcase ESS_SYNTH_PLAY_VOL:\n\tcase ESS_CD_PLAY_VOL:\n\tcase ESS_AUXB_PLAY_VOL:\n\tcase ESS_RECORD_VOL:\n\t\tswitch (cp->un.value.num_channels) {\n\t\tcase 1:\n\t\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = \n\t\t\t\tsc->gain[cp->dev][ESS_LEFT];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = \n\t\t\t\tsc->gain[cp->dev][ESS_LEFT];\n\t\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = \n\t\t\t\tsc->gain[cp->dev][ESS_RIGHT];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EINVAL;\n\t\t}\n\t\treturn (0);\n\n\tcase ESS_PCSPEAKER_VOL:\n\t\tif (cp->un.value.num_channels != 1)\n\t\t\treturn EINVAL;\n\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = \n\t\t\tsc->gain[cp->dev][ESS_LEFT];\n\t\treturn (0);\n\n\tcase ESS_RECORD_SOURCE:\n\t\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\t\tcp->un.ord = sc->in_port;\n\t\telse\n\t\t\tcp->un.mask = sc->in_mask;\n\t\treturn (0);\n\n\tcase ESS_RECORD_MONITOR:\n\t\tcp->un.ord = (ess_read_x_reg(sc, ESS_XCMD_AUDIO_CTRL) &\n\t\t\t      ESS_AUDIO_CTRL_MONITOR) ? 1 : 0;\n\t\treturn (0);\n\t}\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\treturn (EINVAL);\n\n\tswitch (cp->dev) {\n\tcase ESS_DAC_REC_VOL:\n\tcase ESS_MIC_REC_VOL:\n\tcase ESS_LINE_REC_VOL:\n\tcase ESS_SYNTH_REC_VOL:\n\tcase ESS_CD_REC_VOL:\n\tcase ESS_AUXB_REC_VOL:\n\t\tswitch (cp->un.value.num_channels) {\n\t\tcase 1:\n\t\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = \n\t\t\t\tsc->gain[cp->dev][ESS_LEFT];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = \n\t\t\t\tsc->gain[cp->dev][ESS_LEFT];\n\t\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = \n\t\t\t\tsc->gain[cp->dev][ESS_RIGHT];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EINVAL;\n\t\t}\n\t\treturn (0);\n\n\tcase ESS_MIC_PREAMP:\n\t\tcp->un.ord = (ess_read_x_reg(sc, ESS_XCMD_PREAMP_CTRL) &\n\t\t\t      ESS_PREAMP_CTRL_ENABLE) ? 1 : 0;\n\t\treturn (0);\n\t}\n\n\treturn (EINVAL);\n}"
  },
  {
    "function_name": "ess_set_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1661-1800",
    "snippet": "int\ness_set_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct ess_softc *sc = addr;\n\tint lgain, rgain;\n    \n\tDPRINTFN(5,(\"ess_set_port: port=%d num_channels=%d\\n\",\n\t\t    cp->dev, cp->un.value.num_channels));\n\n\tswitch (cp->dev) {\n\t/*\n\t * The following mixer ports are all stereo. If we get a\n\t * single-channel gain value passed in, then we duplicate it\n\t * to both left and right channels.\n\t */\n\tcase ESS_MASTER_VOL:\n\tcase ESS_DAC_PLAY_VOL:\n\tcase ESS_MIC_PLAY_VOL:\n\tcase ESS_LINE_PLAY_VOL:\n\tcase ESS_SYNTH_PLAY_VOL:\n\tcase ESS_CD_PLAY_VOL:\n\tcase ESS_AUXB_PLAY_VOL:\n\tcase ESS_RECORD_VOL:\n\t\tif (cp->type != AUDIO_MIXER_VALUE)\n\t\t\treturn EINVAL;\n\n\t\tswitch (cp->un.value.num_channels) {\n\t\tcase 1:\n\t\t\tlgain = rgain = ESS_4BIT_GAIN(\n\t\t\t  cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tlgain = ESS_4BIT_GAIN(\n\t\t\t  cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT]);\n\t\t\trgain = ESS_4BIT_GAIN(\n\t\t\t  cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EINVAL;\n\t\t}\n\n\t\tsc->gain[cp->dev][ESS_LEFT]  = lgain;\n\t\tsc->gain[cp->dev][ESS_RIGHT] = rgain;\n\t\tess_set_gain(sc, cp->dev, 1);\n\t\treturn (0);\n\n\t/*\n\t * The PC speaker port is mono. If we get a stereo gain value\n\t * passed in, then we return EINVAL.\n\t */\n\tcase ESS_PCSPEAKER_VOL:\n\t\tif (cp->un.value.num_channels != 1)\n\t\t\treturn EINVAL;\n\n\t\tsc->gain[cp->dev][ESS_LEFT] = sc->gain[cp->dev][ESS_RIGHT] =\n\t\t  ESS_3BIT_GAIN(cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);\n\t\tess_set_gain(sc, cp->dev, 1);\n\t\treturn (0);\n\n\tcase ESS_RECORD_SOURCE:\n\t\tif (ESS_USE_AUDIO1(sc->sc_model)) {\n\t\t\tif (cp->type == AUDIO_MIXER_ENUM)\n\t\t\t\treturn (ess_set_in_port(sc, cp->un.ord));\n\t\t\telse\n\t\t\t\treturn (EINVAL);\n\t\t} else {\n\t\t\tif (cp->type == AUDIO_MIXER_SET)\n\t\t\t\treturn (ess_set_in_ports(sc, cp->un.mask));\n\t\t\telse\n\t\t\t\treturn (EINVAL);\n\t\t}\n\t\treturn (0);\n\n\tcase ESS_RECORD_MONITOR:\n\t\tif (cp->type != AUDIO_MIXER_ENUM)\n\t\t\treturn EINVAL;\n\n\t\tif (cp->un.ord)\n\t\t\t/* Enable monitor */\n\t\t\tess_set_xreg_bits(sc, ESS_XCMD_AUDIO_CTRL,\n\t\t\t\t\t  ESS_AUDIO_CTRL_MONITOR);\n\t\telse\n\t\t\t/* Disable monitor */\n\t\t\tess_clear_xreg_bits(sc, ESS_XCMD_AUDIO_CTRL,\n\t\t\t\t\t    ESS_AUDIO_CTRL_MONITOR);\n\t\treturn (0);\n\t}\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\treturn (EINVAL);\n\n\tswitch (cp->dev) {\n\tcase ESS_DAC_REC_VOL:\n\tcase ESS_MIC_REC_VOL:\n\tcase ESS_LINE_REC_VOL:\n\tcase ESS_SYNTH_REC_VOL:\n\tcase ESS_CD_REC_VOL:\n\tcase ESS_AUXB_REC_VOL:\n\t\tif (cp->type != AUDIO_MIXER_VALUE)\n\t\t\treturn EINVAL;\n\n\t\tswitch (cp->un.value.num_channels) {\n\t\tcase 1:\n\t\t\tlgain = rgain = ESS_4BIT_GAIN(\n\t\t\t  cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tlgain = ESS_4BIT_GAIN(\n\t\t\t  cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT]);\n\t\t\trgain = ESS_4BIT_GAIN(\n\t\t\t  cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EINVAL;\n\t\t}\n\n\t\tsc->gain[cp->dev][ESS_LEFT]  = lgain;\n\t\tsc->gain[cp->dev][ESS_RIGHT] = rgain;\n\t\tess_set_gain(sc, cp->dev, 1);\n\t\treturn (0);\n\n\tcase ESS_MIC_PREAMP:\n\t\tif (cp->type != AUDIO_MIXER_ENUM)\n\t\t\treturn EINVAL;\n\n\t\tif (cp->un.ord)\n\t\t\t/* Enable microphone preamp */\n\t\t\tess_set_xreg_bits(sc, ESS_XCMD_PREAMP_CTRL,\n\t\t\t\t\t  ESS_PREAMP_CTRL_ENABLE);\n\t\telse\n\t\t\t/* Disable microphone preamp */\n\t\t\tess_clear_xreg_bits(sc, ESS_XCMD_PREAMP_CTRL,\n\t\t\t\t\t  ESS_PREAMP_CTRL_ENABLE);\n\t\treturn (0);\n\t}\n\n\treturn (EINVAL);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_set_port",
      "void\tess_set_gain",
      "int\tess_set_in_port",
      "int\tess_set_in_ports",
      "void\tess_clear_xreg_bits",
      "void\tess_set_xreg_bits",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_clear_xreg_bits",
          "args": [
            "sc",
            "ESS_XCMD_PREAMP_CTRL",
            "ESS_PREAMP_CTRL_ENABLE"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "ess_clear_xreg_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2594-2603",
          "snippet": "void\ness_clear_xreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tif (ess_write_x_reg(sc, reg, ess_read_x_reg(sc, reg) & ~mask) == -1)\n\t\tDPRINTF((\"Error clearing bits in extended register 0x%02x\\n\",\n\t\t\t reg));\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_read_x_reg",
            "int\tess_write_x_reg",
            "void\tess_clear_xreg_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_x_reg;\nint\tess_write_x_reg;\nvoid\tess_clear_xreg_bits;\n\nvoid\ness_clear_xreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tif (ess_write_x_reg(sc, reg, ess_read_x_reg(sc, reg) & ~mask) == -1)\n\t\tDPRINTF((\"Error clearing bits in extended register 0x%02x\\n\",\n\t\t\t reg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_set_xreg_bits",
          "args": [
            "sc",
            "ESS_XCMD_PREAMP_CTRL",
            "ESS_PREAMP_CTRL_ENABLE"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "ess_set_xreg_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2605-2614",
          "snippet": "void\ness_set_xreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tif (ess_write_x_reg(sc, reg, ess_read_x_reg(sc, reg) | mask) == -1)\n\t\tDPRINTF((\"Error setting bits in extended register 0x%02x\\n\",\n\t\t\t reg));\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_read_x_reg",
            "int\tess_write_x_reg",
            "void\tess_set_xreg_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_x_reg;\nint\tess_write_x_reg;\nvoid\tess_set_xreg_bits;\n\nvoid\ness_set_xreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tif (ess_write_x_reg(sc, reg, ess_read_x_reg(sc, reg) | mask) == -1)\n\t\tDPRINTF((\"Error setting bits in extended register 0x%02x\\n\",\n\t\t\t reg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_set_gain",
          "args": [
            "sc",
            "cp->dev",
            "1"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "ess_set_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2247-2341",
          "snippet": "void\ness_set_gain(sc, port, on)\n\tstruct ess_softc *sc;\n\tint port;\n\tint on;\n{\n\tint gain, left, right;\n\tint mix;\n\tint src;\n\tint stereo;\n\n\t/*\n\t * Most gain controls are found in the mixer registers and\n\t * are stereo. Any that are not, must set mix and stereo as\n\t * required.\n\t */\n\tmix = 1;\n\tstereo = 1;\n\n\tswitch (port) {\n\tcase ESS_MASTER_VOL:\n\t\tsrc = ESS_MREG_VOLUME_MASTER;\n\t\tbreak;\n\tcase ESS_DAC_PLAY_VOL:\n\t\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\t\tsrc = ESS_MREG_VOLUME_VOICE;\n\t\telse\n\t\t\tsrc = 0x7C;\n\t\tbreak;\n\tcase ESS_MIC_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_MIC;\n\t\tbreak;\n\tcase ESS_LINE_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_LINE;\n\t\tbreak;\n\tcase ESS_SYNTH_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_SYNTH;\n\t\tbreak;\n\tcase ESS_CD_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_CD;\n\t\tbreak;\n\tcase ESS_AUXB_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_AUXB;\n\t\tbreak;\n\tcase ESS_PCSPEAKER_VOL:\n\t\tsrc = ESS_MREG_VOLUME_PCSPKR;\n\t\tstereo = 0;\n\t\tbreak;\n\tcase ESS_DAC_REC_VOL:\n\t\tsrc = 0x69;\n\t\tbreak;\n\tcase ESS_MIC_REC_VOL:\n\t\tsrc = 0x68;\n\t\tbreak;\n\tcase ESS_LINE_REC_VOL:\n\t\tsrc = 0x6E;\n\t\tbreak;\n\tcase ESS_SYNTH_REC_VOL:\n\t\tsrc = 0x6B;\n\t\tbreak;\n\tcase ESS_CD_REC_VOL:\n\t\tsrc = 0x6A;\n\t\tbreak;\n\tcase ESS_AUXB_REC_VOL:\n\t\tsrc = 0x6C;\n\t\tbreak;\n\tcase ESS_RECORD_VOL:\n\t\tsrc = ESS_XCMD_VOLIN_CTRL;\n\t\tmix = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t/* 1788 doesn't have a separate recording mixer */\n\tif (ESS_USE_AUDIO1(sc->sc_model) && mix && src > 0x62)\n\t\treturn;\n\n\tif (on) {\n\t\tleft = sc->gain[port][ESS_LEFT];\n\t\tright = sc->gain[port][ESS_RIGHT];\n\t} else {\n\t\tleft = right = 0;\n\t}\n\n\tif (stereo)\n\t\tgain = ESS_STEREO_GAIN(left, right);\n\telse\n\t\tgain = ESS_MONO_GAIN(left);\n\n\tif (mix)\n\t\tess_write_mix_reg(sc, src, gain);\n\telse\n\t\tess_write_x_reg(sc, src, gain);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_set_gain",
            "int\tess_write_x_reg",
            "void\tess_write_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_set_gain;\nint\tess_write_x_reg;\nvoid\tess_write_mix_reg;\n\nvoid\ness_set_gain(sc, port, on)\n\tstruct ess_softc *sc;\n\tint port;\n\tint on;\n{\n\tint gain, left, right;\n\tint mix;\n\tint src;\n\tint stereo;\n\n\t/*\n\t * Most gain controls are found in the mixer registers and\n\t * are stereo. Any that are not, must set mix and stereo as\n\t * required.\n\t */\n\tmix = 1;\n\tstereo = 1;\n\n\tswitch (port) {\n\tcase ESS_MASTER_VOL:\n\t\tsrc = ESS_MREG_VOLUME_MASTER;\n\t\tbreak;\n\tcase ESS_DAC_PLAY_VOL:\n\t\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\t\tsrc = ESS_MREG_VOLUME_VOICE;\n\t\telse\n\t\t\tsrc = 0x7C;\n\t\tbreak;\n\tcase ESS_MIC_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_MIC;\n\t\tbreak;\n\tcase ESS_LINE_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_LINE;\n\t\tbreak;\n\tcase ESS_SYNTH_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_SYNTH;\n\t\tbreak;\n\tcase ESS_CD_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_CD;\n\t\tbreak;\n\tcase ESS_AUXB_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_AUXB;\n\t\tbreak;\n\tcase ESS_PCSPEAKER_VOL:\n\t\tsrc = ESS_MREG_VOLUME_PCSPKR;\n\t\tstereo = 0;\n\t\tbreak;\n\tcase ESS_DAC_REC_VOL:\n\t\tsrc = 0x69;\n\t\tbreak;\n\tcase ESS_MIC_REC_VOL:\n\t\tsrc = 0x68;\n\t\tbreak;\n\tcase ESS_LINE_REC_VOL:\n\t\tsrc = 0x6E;\n\t\tbreak;\n\tcase ESS_SYNTH_REC_VOL:\n\t\tsrc = 0x6B;\n\t\tbreak;\n\tcase ESS_CD_REC_VOL:\n\t\tsrc = 0x6A;\n\t\tbreak;\n\tcase ESS_AUXB_REC_VOL:\n\t\tsrc = 0x6C;\n\t\tbreak;\n\tcase ESS_RECORD_VOL:\n\t\tsrc = ESS_XCMD_VOLIN_CTRL;\n\t\tmix = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t/* 1788 doesn't have a separate recording mixer */\n\tif (ESS_USE_AUDIO1(sc->sc_model) && mix && src > 0x62)\n\t\treturn;\n\n\tif (on) {\n\t\tleft = sc->gain[port][ESS_LEFT];\n\t\tright = sc->gain[port][ESS_RIGHT];\n\t} else {\n\t\tleft = right = 0;\n\t}\n\n\tif (stereo)\n\t\tgain = ESS_STEREO_GAIN(left, right);\n\telse\n\t\tgain = ESS_MONO_GAIN(left);\n\n\tif (mix)\n\t\tess_write_mix_reg(sc, src, gain);\n\telse\n\t\tess_write_x_reg(sc, src, gain);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESS_4BIT_GAIN",
          "args": [
            "cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT]"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESS_4BIT_GAIN",
          "args": [
            "cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT]"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESS_4BIT_GAIN",
          "args": [
            "cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESS_USE_AUDIO1",
          "args": [
            "sc->sc_model"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_set_in_ports",
          "args": [
            "sc",
            "cp->un.mask"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "ess_set_in_ports",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2377-2415",
          "snippet": "int\ness_set_in_ports(sc, mask)\n\tstruct ess_softc *sc;\n\tint mask;\n{\n\tmixer_devinfo_t di;\n\tint i, port;\n\n\tDPRINTF((\"ess_set_in_ports: mask=0x%x\\n\", mask));\n\n\t/*\n\t * Get the device info for the record source control,\n\t * including the list of available sources.\n\t */\n\tdi.index = ESS_RECORD_SOURCE;\n\tif (ess_query_devinfo(sc, &di))\n\t\treturn EINVAL;\n\n\t/*\n\t * Set or disable the record volume control for each of the\n\t * possible sources.\n\t */\n\tfor (i = 0; i < di.un.s.num_mem; i++) {\n\t\t/*\n\t\t * Calculate the source port number from its mask.\n\t\t */\n\t\tport = ffs(di.un.s.member[i].mask);\n\n\t\t/*\n\t\t * Set the source gain:\n\t\t *\tto the current value if source is enabled\n\t\t *\tto zero if source is disabled\n\t\t */\n\t\tess_set_gain(sc, port, mask & di.un.s.member[i].mask);\n\t}\n\n\tsc->in_mask = mask;\n\treturn (0);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_query_devinfo",
            "void\tess_set_gain",
            "int\tess_set_in_ports"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_query_devinfo;\nvoid\tess_set_gain;\nint\tess_set_in_ports;\n\nint\ness_set_in_ports(sc, mask)\n\tstruct ess_softc *sc;\n\tint mask;\n{\n\tmixer_devinfo_t di;\n\tint i, port;\n\n\tDPRINTF((\"ess_set_in_ports: mask=0x%x\\n\", mask));\n\n\t/*\n\t * Get the device info for the record source control,\n\t * including the list of available sources.\n\t */\n\tdi.index = ESS_RECORD_SOURCE;\n\tif (ess_query_devinfo(sc, &di))\n\t\treturn EINVAL;\n\n\t/*\n\t * Set or disable the record volume control for each of the\n\t * possible sources.\n\t */\n\tfor (i = 0; i < di.un.s.num_mem; i++) {\n\t\t/*\n\t\t * Calculate the source port number from its mask.\n\t\t */\n\t\tport = ffs(di.un.s.member[i].mask);\n\n\t\t/*\n\t\t * Set the source gain:\n\t\t *\tto the current value if source is enabled\n\t\t *\tto zero if source is disabled\n\t\t */\n\t\tess_set_gain(sc, port, mask & di.un.s.member[i].mask);\n\t}\n\n\tsc->in_mask = mask;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESS_USE_AUDIO1",
          "args": [
            "sc->sc_model"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESS_3BIT_GAIN",
          "args": [
            "cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESS_4BIT_GAIN",
          "args": [
            "cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT]"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESS_4BIT_GAIN",
          "args": [
            "cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT]"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESS_4BIT_GAIN",
          "args": [
            "cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ess_set_port: port=%d num_channels=%d\\n\",\n\t\t    cp->dev, cp->un.value.num_channels)"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_set_port;\nvoid\tess_set_gain;\nint\tess_set_in_port;\nint\tess_set_in_ports;\nvoid\tess_clear_xreg_bits;\nvoid\tess_set_xreg_bits;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_set_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct ess_softc *sc = addr;\n\tint lgain, rgain;\n    \n\tDPRINTFN(5,(\"ess_set_port: port=%d num_channels=%d\\n\",\n\t\t    cp->dev, cp->un.value.num_channels));\n\n\tswitch (cp->dev) {\n\t/*\n\t * The following mixer ports are all stereo. If we get a\n\t * single-channel gain value passed in, then we duplicate it\n\t * to both left and right channels.\n\t */\n\tcase ESS_MASTER_VOL:\n\tcase ESS_DAC_PLAY_VOL:\n\tcase ESS_MIC_PLAY_VOL:\n\tcase ESS_LINE_PLAY_VOL:\n\tcase ESS_SYNTH_PLAY_VOL:\n\tcase ESS_CD_PLAY_VOL:\n\tcase ESS_AUXB_PLAY_VOL:\n\tcase ESS_RECORD_VOL:\n\t\tif (cp->type != AUDIO_MIXER_VALUE)\n\t\t\treturn EINVAL;\n\n\t\tswitch (cp->un.value.num_channels) {\n\t\tcase 1:\n\t\t\tlgain = rgain = ESS_4BIT_GAIN(\n\t\t\t  cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tlgain = ESS_4BIT_GAIN(\n\t\t\t  cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT]);\n\t\t\trgain = ESS_4BIT_GAIN(\n\t\t\t  cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EINVAL;\n\t\t}\n\n\t\tsc->gain[cp->dev][ESS_LEFT]  = lgain;\n\t\tsc->gain[cp->dev][ESS_RIGHT] = rgain;\n\t\tess_set_gain(sc, cp->dev, 1);\n\t\treturn (0);\n\n\t/*\n\t * The PC speaker port is mono. If we get a stereo gain value\n\t * passed in, then we return EINVAL.\n\t */\n\tcase ESS_PCSPEAKER_VOL:\n\t\tif (cp->un.value.num_channels != 1)\n\t\t\treturn EINVAL;\n\n\t\tsc->gain[cp->dev][ESS_LEFT] = sc->gain[cp->dev][ESS_RIGHT] =\n\t\t  ESS_3BIT_GAIN(cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);\n\t\tess_set_gain(sc, cp->dev, 1);\n\t\treturn (0);\n\n\tcase ESS_RECORD_SOURCE:\n\t\tif (ESS_USE_AUDIO1(sc->sc_model)) {\n\t\t\tif (cp->type == AUDIO_MIXER_ENUM)\n\t\t\t\treturn (ess_set_in_port(sc, cp->un.ord));\n\t\t\telse\n\t\t\t\treturn (EINVAL);\n\t\t} else {\n\t\t\tif (cp->type == AUDIO_MIXER_SET)\n\t\t\t\treturn (ess_set_in_ports(sc, cp->un.mask));\n\t\t\telse\n\t\t\t\treturn (EINVAL);\n\t\t}\n\t\treturn (0);\n\n\tcase ESS_RECORD_MONITOR:\n\t\tif (cp->type != AUDIO_MIXER_ENUM)\n\t\t\treturn EINVAL;\n\n\t\tif (cp->un.ord)\n\t\t\t/* Enable monitor */\n\t\t\tess_set_xreg_bits(sc, ESS_XCMD_AUDIO_CTRL,\n\t\t\t\t\t  ESS_AUDIO_CTRL_MONITOR);\n\t\telse\n\t\t\t/* Disable monitor */\n\t\t\tess_clear_xreg_bits(sc, ESS_XCMD_AUDIO_CTRL,\n\t\t\t\t\t    ESS_AUDIO_CTRL_MONITOR);\n\t\treturn (0);\n\t}\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\treturn (EINVAL);\n\n\tswitch (cp->dev) {\n\tcase ESS_DAC_REC_VOL:\n\tcase ESS_MIC_REC_VOL:\n\tcase ESS_LINE_REC_VOL:\n\tcase ESS_SYNTH_REC_VOL:\n\tcase ESS_CD_REC_VOL:\n\tcase ESS_AUXB_REC_VOL:\n\t\tif (cp->type != AUDIO_MIXER_VALUE)\n\t\t\treturn EINVAL;\n\n\t\tswitch (cp->un.value.num_channels) {\n\t\tcase 1:\n\t\t\tlgain = rgain = ESS_4BIT_GAIN(\n\t\t\t  cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tlgain = ESS_4BIT_GAIN(\n\t\t\t  cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT]);\n\t\t\trgain = ESS_4BIT_GAIN(\n\t\t\t  cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EINVAL;\n\t\t}\n\n\t\tsc->gain[cp->dev][ESS_LEFT]  = lgain;\n\t\tsc->gain[cp->dev][ESS_RIGHT] = rgain;\n\t\tess_set_gain(sc, cp->dev, 1);\n\t\treturn (0);\n\n\tcase ESS_MIC_PREAMP:\n\t\tif (cp->type != AUDIO_MIXER_ENUM)\n\t\t\treturn EINVAL;\n\n\t\tif (cp->un.ord)\n\t\t\t/* Enable microphone preamp */\n\t\t\tess_set_xreg_bits(sc, ESS_XCMD_PREAMP_CTRL,\n\t\t\t\t\t  ESS_PREAMP_CTRL_ENABLE);\n\t\telse\n\t\t\t/* Disable microphone preamp */\n\t\t\tess_clear_xreg_bits(sc, ESS_XCMD_PREAMP_CTRL,\n\t\t\t\t\t  ESS_PREAMP_CTRL_ENABLE);\n\t\treturn (0);\n\t}\n\n\treturn (EINVAL);\n}"
  },
  {
    "function_name": "ess_round_blocksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1653-1659",
    "snippet": "int\ness_round_blocksize(addr, blk)\n\tvoid *addr;\n\tint blk;\n{\n\treturn (blk & -8);\t/* round for max DMA size */\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_round_blocksize",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;",
      "unsigned long size;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_round_blocksize;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\nunsigned long size;\n\nint\ness_round_blocksize(addr, blk)\n\tvoid *addr;\n\tint blk;\n{\n\treturn (blk & -8);\t/* round for max DMA size */\n}"
  },
  {
    "function_name": "ess_audio2_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1622-1651",
    "snippet": "void\ness_audio2_poll(addr)\n\tvoid *addr;\n{\n\tstruct ess_softc *sc = addr;\n\tint dmapos, dmacount;\n\n\tif (!sc->sc_audio2.active)\n\t\treturn;\n\n\tsc->sc_audio2.nintr++;\n\n\tdmapos = isa_dmacount(sc->sc_isa, sc->sc_audio2.drq);\n\tdmacount = sc->sc_audio2.dmapos - dmapos;\n\tif (dmacount < 0)\n\t\tdmacount += sc->sc_audio2.buffersize;\n\tsc->sc_audio2.dmapos = dmapos;\n#if 1\n\tdmacount += sc->sc_audio2.dmacount;\n\twhile (dmacount > sc->sc_audio2.blksize) {\n\t\tdmacount -= sc->sc_audio2.blksize;\n\t\t(*sc->sc_audio2.intr)(sc->sc_audio2.arg);\n\t}\n\tsc->sc_audio2.dmacount = dmacount;\n#else\n\t(*sc->sc_audio2.intr)(sc->sc_audio2.arg, dmacount);\n#endif\n\n\ttimeout(ess_audio2_poll, sc, hz/30);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tess_audio2_poll",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "ess_audio2_poll",
            "sc",
            "hz/30"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "bt_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1300-1345",
          "snippet": "void\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
          ],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_queue_ccb",
            "void bt_collect_mbo",
            "void bt_timeout",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_queue_ccb;\nvoid bt_collect_mbo;\nvoid bt_timeout;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_audio2.arg",
            "dmacount"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_audio2.arg"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_dmacount",
          "args": [
            "sc->sc_isa",
            "sc->sc_audio2.drq"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmacount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "441-488",
          "snippet": "bus_size_t\nisa_dmacount(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tint waport;\n\tbus_size_t nbytes;\n\tint ochan = chan & 3;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmacount: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tisa_dmamask(sc, chan);\n\n\t/*\n\t * We have to shift the byte count by 1.  If we're in auto-initialize\n\t * mode, the count may have wrapped around to the initial value.  We\n\t * can't use the TC bit to check for this case, so instead we compare\n\t * against the original byte count.\n\t * If we're not in auto-initialize mode, then the count will wrap to\n\t * -1, so we also handle that case.\n\t */\n\tif ((chan & 4) == 0) {\n\t\twaport = DMA1_CHN(ochan);\n\t\tnbytes = bus_space_read_1(sc->sc_iot, sc->sc_dma1h,\n\t\t    waport + 1) + 1;\n\t\tnbytes += bus_space_read_1(sc->sc_iot, sc->sc_dma1h,\n\t\t    waport + 1) << 8;\n\t\tnbytes &= 0xffff;\n\t} else {\n\t\twaport = DMA2_CHN(ochan);\n\t\tnbytes = bus_space_read_1(sc->sc_iot, sc->sc_dma2h,\n\t\t    waport + 2) + 1;\n\t\tnbytes += bus_space_read_1(sc->sc_iot, sc->sc_dma2h,\n\t\t    waport + 2) << 8;\n\t\tnbytes <<= 1;\n\t\tnbytes &= 0x1ffff;\n\t}\n\n\tif (nbytes == sc->sc_dmalength[chan])\n\t\tnbytes = 0;\n\n\tisa_dmaunmask(sc, chan);\n\treturn (nbytes);\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void isa_dmaunmask",
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic inline void isa_dmaunmask;\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\n\nbus_size_t\nisa_dmacount(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tint waport;\n\tbus_size_t nbytes;\n\tint ochan = chan & 3;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmacount: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tisa_dmamask(sc, chan);\n\n\t/*\n\t * We have to shift the byte count by 1.  If we're in auto-initialize\n\t * mode, the count may have wrapped around to the initial value.  We\n\t * can't use the TC bit to check for this case, so instead we compare\n\t * against the original byte count.\n\t * If we're not in auto-initialize mode, then the count will wrap to\n\t * -1, so we also handle that case.\n\t */\n\tif ((chan & 4) == 0) {\n\t\twaport = DMA1_CHN(ochan);\n\t\tnbytes = bus_space_read_1(sc->sc_iot, sc->sc_dma1h,\n\t\t    waport + 1) + 1;\n\t\tnbytes += bus_space_read_1(sc->sc_iot, sc->sc_dma1h,\n\t\t    waport + 1) << 8;\n\t\tnbytes &= 0xffff;\n\t} else {\n\t\twaport = DMA2_CHN(ochan);\n\t\tnbytes = bus_space_read_1(sc->sc_iot, sc->sc_dma2h,\n\t\t    waport + 2) + 1;\n\t\tnbytes += bus_space_read_1(sc->sc_iot, sc->sc_dma2h,\n\t\t    waport + 2) << 8;\n\t\tnbytes <<= 1;\n\t\tnbytes &= 0x1ffff;\n\t}\n\n\tif (nbytes == sc->sc_dmalength[chan])\n\t\tnbytes = 0;\n\n\tisa_dmaunmask(sc, chan);\n\treturn (nbytes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_audio2_poll;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nvoid\ness_audio2_poll(addr)\n\tvoid *addr;\n{\n\tstruct ess_softc *sc = addr;\n\tint dmapos, dmacount;\n\n\tif (!sc->sc_audio2.active)\n\t\treturn;\n\n\tsc->sc_audio2.nintr++;\n\n\tdmapos = isa_dmacount(sc->sc_isa, sc->sc_audio2.drq);\n\tdmacount = sc->sc_audio2.dmapos - dmapos;\n\tif (dmacount < 0)\n\t\tdmacount += sc->sc_audio2.buffersize;\n\tsc->sc_audio2.dmapos = dmapos;\n#if 1\n\tdmacount += sc->sc_audio2.dmacount;\n\twhile (dmacount > sc->sc_audio2.blksize) {\n\t\tdmacount -= sc->sc_audio2.blksize;\n\t\t(*sc->sc_audio2.intr)(sc->sc_audio2.arg);\n\t}\n\tsc->sc_audio2.dmacount = dmacount;\n#else\n\t(*sc->sc_audio2.intr)(sc->sc_audio2.arg, dmacount);\n#endif\n\n\ttimeout(ess_audio2_poll, sc, hz/30);\n}"
  },
  {
    "function_name": "ess_audio1_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1591-1620",
    "snippet": "void\ness_audio1_poll(addr)\n\tvoid *addr;\n{\n\tstruct ess_softc *sc = addr;\n\tint dmapos, dmacount;\n\n\tif (!sc->sc_audio1.active)\n\t\treturn;\n\n\tsc->sc_audio1.nintr++;\n\n\tdmapos = isa_dmacount(sc->sc_isa, sc->sc_audio1.drq);\n\tdmacount = sc->sc_audio1.dmapos - dmapos;\n\tif (dmacount < 0)\n\t\tdmacount += sc->sc_audio1.buffersize;\n\tsc->sc_audio1.dmapos = dmapos;\n#if 1\n\tdmacount += sc->sc_audio1.dmacount;\n\twhile (dmacount > sc->sc_audio1.blksize) {\n\t\tdmacount -= sc->sc_audio1.blksize;\n\t\t(*sc->sc_audio1.intr)(sc->sc_audio1.arg);\n\t}\n\tsc->sc_audio1.dmacount = dmacount;\n#else\n\t(*sc->sc_audio1.intr)(sc->sc_audio1.arg, dmacount);\n#endif\n\n\ttimeout(ess_audio1_poll, sc, hz/30);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tess_audio1_poll",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "ess_audio1_poll",
            "sc",
            "hz/30"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "bt_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1300-1345",
          "snippet": "void\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
          ],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_queue_ccb",
            "void bt_collect_mbo",
            "void bt_timeout",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_queue_ccb;\nvoid bt_collect_mbo;\nvoid bt_timeout;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_audio1.arg",
            "dmacount"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_audio1.arg"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_dmacount",
          "args": [
            "sc->sc_isa",
            "sc->sc_audio1.drq"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmacount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "441-488",
          "snippet": "bus_size_t\nisa_dmacount(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tint waport;\n\tbus_size_t nbytes;\n\tint ochan = chan & 3;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmacount: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tisa_dmamask(sc, chan);\n\n\t/*\n\t * We have to shift the byte count by 1.  If we're in auto-initialize\n\t * mode, the count may have wrapped around to the initial value.  We\n\t * can't use the TC bit to check for this case, so instead we compare\n\t * against the original byte count.\n\t * If we're not in auto-initialize mode, then the count will wrap to\n\t * -1, so we also handle that case.\n\t */\n\tif ((chan & 4) == 0) {\n\t\twaport = DMA1_CHN(ochan);\n\t\tnbytes = bus_space_read_1(sc->sc_iot, sc->sc_dma1h,\n\t\t    waport + 1) + 1;\n\t\tnbytes += bus_space_read_1(sc->sc_iot, sc->sc_dma1h,\n\t\t    waport + 1) << 8;\n\t\tnbytes &= 0xffff;\n\t} else {\n\t\twaport = DMA2_CHN(ochan);\n\t\tnbytes = bus_space_read_1(sc->sc_iot, sc->sc_dma2h,\n\t\t    waport + 2) + 1;\n\t\tnbytes += bus_space_read_1(sc->sc_iot, sc->sc_dma2h,\n\t\t    waport + 2) << 8;\n\t\tnbytes <<= 1;\n\t\tnbytes &= 0x1ffff;\n\t}\n\n\tif (nbytes == sc->sc_dmalength[chan])\n\t\tnbytes = 0;\n\n\tisa_dmaunmask(sc, chan);\n\treturn (nbytes);\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void isa_dmaunmask",
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic inline void isa_dmaunmask;\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\n\nbus_size_t\nisa_dmacount(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tint waport;\n\tbus_size_t nbytes;\n\tint ochan = chan & 3;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmacount: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tisa_dmamask(sc, chan);\n\n\t/*\n\t * We have to shift the byte count by 1.  If we're in auto-initialize\n\t * mode, the count may have wrapped around to the initial value.  We\n\t * can't use the TC bit to check for this case, so instead we compare\n\t * against the original byte count.\n\t * If we're not in auto-initialize mode, then the count will wrap to\n\t * -1, so we also handle that case.\n\t */\n\tif ((chan & 4) == 0) {\n\t\twaport = DMA1_CHN(ochan);\n\t\tnbytes = bus_space_read_1(sc->sc_iot, sc->sc_dma1h,\n\t\t    waport + 1) + 1;\n\t\tnbytes += bus_space_read_1(sc->sc_iot, sc->sc_dma1h,\n\t\t    waport + 1) << 8;\n\t\tnbytes &= 0xffff;\n\t} else {\n\t\twaport = DMA2_CHN(ochan);\n\t\tnbytes = bus_space_read_1(sc->sc_iot, sc->sc_dma2h,\n\t\t    waport + 2) + 1;\n\t\tnbytes += bus_space_read_1(sc->sc_iot, sc->sc_dma2h,\n\t\t    waport + 2) << 8;\n\t\tnbytes <<= 1;\n\t\tnbytes &= 0x1ffff;\n\t}\n\n\tif (nbytes == sc->sc_dmalength[chan])\n\t\tnbytes = 0;\n\n\tisa_dmaunmask(sc, chan);\n\treturn (nbytes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_audio1_poll;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nvoid\ness_audio1_poll(addr)\n\tvoid *addr;\n{\n\tstruct ess_softc *sc = addr;\n\tint dmapos, dmacount;\n\n\tif (!sc->sc_audio1.active)\n\t\treturn;\n\n\tsc->sc_audio1.nintr++;\n\n\tdmapos = isa_dmacount(sc->sc_isa, sc->sc_audio1.drq);\n\tdmacount = sc->sc_audio1.dmapos - dmapos;\n\tif (dmacount < 0)\n\t\tdmacount += sc->sc_audio1.buffersize;\n\tsc->sc_audio1.dmapos = dmapos;\n#if 1\n\tdmacount += sc->sc_audio1.dmacount;\n\twhile (dmacount > sc->sc_audio1.blksize) {\n\t\tdmacount -= sc->sc_audio1.blksize;\n\t\t(*sc->sc_audio1.intr)(sc->sc_audio1.arg);\n\t}\n\tsc->sc_audio1.dmacount = dmacount;\n#else\n\t(*sc->sc_audio1.intr)(sc->sc_audio1.arg, dmacount);\n#endif\n\n\ttimeout(ess_audio1_poll, sc, hz/30);\n}"
  },
  {
    "function_name": "ess_audio2_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1566-1589",
    "snippet": "int\ness_audio2_intr(arg)\n\tvoid *arg;\n{\n\tstruct ess_softc *sc = arg;\n\tu_int8_t reg;\n\n\tDPRINTFN(1,(\"ess_audio2_intr: intr=%p\\n\", sc->sc_audio2.intr));\n\n\t/* Check and clear interrupt on Audio2. */\n\treg = ess_read_mix_reg(sc, ESS_MREG_AUDIO2_CTRL2);\n\tif ((reg & ESS_AUDIO2_CTRL2_IRQ_LATCH) == 0)\n\t\treturn (0);\n\treg &= ~ESS_AUDIO2_CTRL2_IRQ_LATCH;\n\tess_write_mix_reg(sc, ESS_MREG_AUDIO2_CTRL2, reg);\n\n\tsc->sc_audio2.nintr++;\n\n\tif (sc->sc_audio2.active) {\n\t\t(*sc->sc_audio2.intr)(sc->sc_audio2.arg);\n\t\treturn (1);\n\t} else\n\t\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_audio2_intr",
      "u_char\tess_read_mix_reg",
      "void\tess_write_mix_reg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_audio2.arg"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_write_mix_reg",
          "args": [
            "sc",
            "ESS_MREG_AUDIO2_CTRL2",
            "reg"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "ess_write_mix_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2620-2636",
          "snippet": "void\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_write_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_write_mix_reg;\n\nvoid\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_read_mix_reg",
          "args": [
            "sc",
            "ESS_MREG_AUDIO2_CTRL2"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "ess_read_mix_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2641-2658",
          "snippet": "u_char\ness_read_mix_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\tu_char val;\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tval = EREAD1(iot, ioh, ESS_MIX_REG_DATA);\n\tsplx(s);\n\n\tDPRINTFN(2,(\"ess_read_mix_reg: %x=%x\\n\", reg, val));\n\treturn val;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_read_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_mix_reg;\n\nu_char\ness_read_mix_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\tu_char val;\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tval = EREAD1(iot, ioh, ESS_MIX_REG_DATA);\n\tsplx(s);\n\n\tDPRINTFN(2,(\"ess_read_mix_reg: %x=%x\\n\", reg, val));\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ess_audio2_intr: intr=%p\\n\", sc->sc_audio2.intr)"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_audio2_intr;\nu_char\tess_read_mix_reg;\nvoid\tess_write_mix_reg;\n\nint\ness_audio2_intr(arg)\n\tvoid *arg;\n{\n\tstruct ess_softc *sc = arg;\n\tu_int8_t reg;\n\n\tDPRINTFN(1,(\"ess_audio2_intr: intr=%p\\n\", sc->sc_audio2.intr));\n\n\t/* Check and clear interrupt on Audio2. */\n\treg = ess_read_mix_reg(sc, ESS_MREG_AUDIO2_CTRL2);\n\tif ((reg & ESS_AUDIO2_CTRL2_IRQ_LATCH) == 0)\n\t\treturn (0);\n\treg &= ~ESS_AUDIO2_CTRL2_IRQ_LATCH;\n\tess_write_mix_reg(sc, ESS_MREG_AUDIO2_CTRL2, reg);\n\n\tsc->sc_audio2.nintr++;\n\n\tif (sc->sc_audio2.active) {\n\t\t(*sc->sc_audio2.intr)(sc->sc_audio2.arg);\n\t\treturn (1);\n\t} else\n\t\treturn (0);\n}"
  },
  {
    "function_name": "ess_audio1_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1542-1564",
    "snippet": "int\ness_audio1_intr(arg)\n\tvoid *arg;\n{\n\tstruct ess_softc *sc = arg;\n\tu_int8_t reg;\n\n\tDPRINTFN(1,(\"ess_audio1_intr: intr=%p\\n\", sc->sc_audio1.intr));\n\n\t/* Check and clear interrupt on Audio1. */\n\treg = EREAD1(sc->sc_iot, sc->sc_ioh, ESS_DSP_RW_STATUS);\n\tif ((reg & ESS_DSP_READ_OFLOW) == 0)\n\t\treturn (0);\n\treg = EREAD1(sc->sc_iot, sc->sc_ioh, ESS_CLEAR_INTR);\n\n\tsc->sc_audio1.nintr++;\n\n\tif (sc->sc_audio1.active) {\n\t\t(*sc->sc_audio1.intr)(sc->sc_audio1.arg);\n\t\treturn (1);\n\t} else\n\t\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_audio1_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_audio1.arg"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD1",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "ESS_CLEAR_INTR"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD1",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "ESS_DSP_RW_STATUS"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ess_audio1_intr: intr=%p\\n\", sc->sc_audio1.intr)"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_audio1_intr;\n\nint\ness_audio1_intr(arg)\n\tvoid *arg;\n{\n\tstruct ess_softc *sc = arg;\n\tu_int8_t reg;\n\n\tDPRINTFN(1,(\"ess_audio1_intr: intr=%p\\n\", sc->sc_audio1.intr));\n\n\t/* Check and clear interrupt on Audio1. */\n\treg = EREAD1(sc->sc_iot, sc->sc_ioh, ESS_DSP_RW_STATUS);\n\tif ((reg & ESS_DSP_READ_OFLOW) == 0)\n\t\treturn (0);\n\treg = EREAD1(sc->sc_iot, sc->sc_ioh, ESS_CLEAR_INTR);\n\n\tsc->sc_audio1.nintr++;\n\n\tif (sc->sc_audio1.active) {\n\t\t(*sc->sc_audio1.intr)(sc->sc_audio1.arg);\n\t\treturn (1);\n\t} else\n\t\treturn (0);\n}"
  },
  {
    "function_name": "ess_audio2_halt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1521-1540",
    "snippet": "int\ness_audio2_halt(addr)\n\tvoid *addr;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTF((\"ess_audio2_halt: sc=%p\\n\", sc));\n\n\tif (sc->sc_audio2.active) {\n\t\tess_clear_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL1,\n\t\t    ESS_AUDIO2_CTRL1_DAC_ENABLE |\n\t\t    ESS_AUDIO2_CTRL1_FIFO_ENABLE);\n\t\tisa_dmaabort(sc->sc_isa, sc->sc_audio2.drq);\n\t\tif (sc->sc_audio2.polled)\n\t\t\tuntimeout(ess_audio2_poll, sc);\n\t\tsc->sc_audio2.active = 0;\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_audio2_halt",
      "void\tess_audio2_poll",
      "void\tess_clear_mreg_bits",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "ess_audio2_poll",
            "sc"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_dmaabort",
          "args": [
            "sc->sc_isa",
            "sc->sc_audio2.drq"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmaabort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "424-439",
          "snippet": "void\nisa_dmaabort(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmaabort: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tisa_dmamask(sc, chan);\n\tbus_dmamap_unload(sc->sc_dmat, sc->sc_dmamaps[chan]);\n\tsc->sc_dmareads &= ~(1 << chan);\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\n\nvoid\nisa_dmaabort(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmaabort: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tisa_dmamask(sc, chan);\n\tbus_dmamap_unload(sc->sc_dmat, sc->sc_dmamaps[chan]);\n\tsc->sc_dmareads &= ~(1 << chan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_clear_mreg_bits",
          "args": [
            "sc",
            "ESS_MREG_AUDIO2_CTRL1",
            "ESS_AUDIO2_CTRL1_DAC_ENABLE |\n\t\t    ESS_AUDIO2_CTRL1_FIFO_ENABLE"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "ess_clear_mreg_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2660-2667",
          "snippet": "void\ness_clear_mreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) & ~mask);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_read_mix_reg",
            "void\tess_write_mix_reg",
            "void\tess_clear_mreg_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_mix_reg;\nvoid\tess_write_mix_reg;\nvoid\tess_clear_mreg_bits;\n\nvoid\ness_clear_mreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ess_audio2_halt: sc=%p\\n\", sc)"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_audio2_halt;\nvoid\tess_audio2_poll;\nvoid\tess_clear_mreg_bits;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_audio2_halt(addr)\n\tvoid *addr;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTF((\"ess_audio2_halt: sc=%p\\n\", sc));\n\n\tif (sc->sc_audio2.active) {\n\t\tess_clear_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL1,\n\t\t    ESS_AUDIO2_CTRL1_DAC_ENABLE |\n\t\t    ESS_AUDIO2_CTRL1_FIFO_ENABLE);\n\t\tisa_dmaabort(sc->sc_isa, sc->sc_audio2.drq);\n\t\tif (sc->sc_audio2.polled)\n\t\t\tuntimeout(ess_audio2_poll, sc);\n\t\tsc->sc_audio2.active = 0;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "ess_audio1_halt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1501-1519",
    "snippet": "int\ness_audio1_halt(addr)\n\tvoid *addr;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTF((\"ess_audio1_halt: sc=%p\\n\", sc));\n\n\tif (sc->sc_audio1.active) {\n\t\tess_clear_xreg_bits(sc, ESS_XCMD_AUDIO1_CTRL2,\n\t\t    ESS_AUDIO1_CTRL2_FIFO_ENABLE);\n\t\tisa_dmaabort(sc->sc_isa, sc->sc_audio1.drq);\n\t\tif (sc->sc_audio1.polled)\n\t\t\tuntimeout(ess_audio1_poll, sc);\n\t\tsc->sc_audio1.active = 0;\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_audio1_halt",
      "void\tess_audio1_poll",
      "void\tess_clear_xreg_bits",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "ess_audio1_poll",
            "sc"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_dmaabort",
          "args": [
            "sc->sc_isa",
            "sc->sc_audio1.drq"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmaabort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "424-439",
          "snippet": "void\nisa_dmaabort(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmaabort: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tisa_dmamask(sc, chan);\n\tbus_dmamap_unload(sc->sc_dmat, sc->sc_dmamaps[chan]);\n\tsc->sc_dmareads &= ~(1 << chan);\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\n\nvoid\nisa_dmaabort(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmaabort: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tisa_dmamask(sc, chan);\n\tbus_dmamap_unload(sc->sc_dmat, sc->sc_dmamaps[chan]);\n\tsc->sc_dmareads &= ~(1 << chan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_clear_xreg_bits",
          "args": [
            "sc",
            "ESS_XCMD_AUDIO1_CTRL2",
            "ESS_AUDIO1_CTRL2_FIFO_ENABLE"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "ess_clear_xreg_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2594-2603",
          "snippet": "void\ness_clear_xreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tif (ess_write_x_reg(sc, reg, ess_read_x_reg(sc, reg) & ~mask) == -1)\n\t\tDPRINTF((\"Error clearing bits in extended register 0x%02x\\n\",\n\t\t\t reg));\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_read_x_reg",
            "int\tess_write_x_reg",
            "void\tess_clear_xreg_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_x_reg;\nint\tess_write_x_reg;\nvoid\tess_clear_xreg_bits;\n\nvoid\ness_clear_xreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tif (ess_write_x_reg(sc, reg, ess_read_x_reg(sc, reg) & ~mask) == -1)\n\t\tDPRINTF((\"Error clearing bits in extended register 0x%02x\\n\",\n\t\t\t reg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ess_audio1_halt: sc=%p\\n\", sc)"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_audio1_halt;\nvoid\tess_audio1_poll;\nvoid\tess_clear_xreg_bits;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_audio1_halt(addr)\n\tvoid *addr;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTF((\"ess_audio1_halt: sc=%p\\n\", sc));\n\n\tif (sc->sc_audio1.active) {\n\t\tess_clear_xreg_bits(sc, ESS_XCMD_AUDIO1_CTRL2,\n\t\t    ESS_AUDIO1_CTRL2_FIFO_ENABLE);\n\t\tisa_dmaabort(sc->sc_isa, sc->sc_audio1.drq);\n\t\tif (sc->sc_audio1.polled)\n\t\t\tuntimeout(ess_audio1_poll, sc);\n\t\tsc->sc_audio1.active = 0;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "ess_audio1_trigger_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1423-1499",
    "snippet": "int\ness_audio1_trigger_input(addr, start, end, blksize, intr, arg, param)\n\tvoid *addr;\n\tvoid *start, *end;\n\tint blksize;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n\tstruct audio_params *param;\n{\n\tstruct ess_softc *sc = addr;\n\tu_int8_t reg;\n\n\tDPRINTFN(1, (\"ess_audio1_trigger_input: sc=%p start=%p end=%p blksize=%d intr=%p(%p)\\n\",\n\t    addr, start, end, blksize, intr, arg));\n\n\tif (sc->sc_audio1.active)\n\t\tpanic(\"ess_audio1_trigger_input: already running\");\n\n\tsc->sc_audio1.active = 1;\n\tsc->sc_audio1.intr = intr;\n\tsc->sc_audio1.arg = arg;\n\tif (sc->sc_audio1.polled) {\n\t\tsc->sc_audio1.dmapos = 0;\n\t\tsc->sc_audio1.buffersize = (char *)end - (char *)start;\n\t\tsc->sc_audio1.dmacount = 0;\n\t\tsc->sc_audio1.blksize = blksize;\n\t\ttimeout(ess_audio1_poll, sc, hz/30);\n\t}\n\n\treg = ess_read_x_reg(sc, ESS_XCMD_AUDIO_CTRL);\n\tif (param->channels == 2) {\n\t\treg &= ~ESS_AUDIO_CTRL_MONO;\n\t\treg |= ESS_AUDIO_CTRL_STEREO;\n\t} else {\n\t\treg |= ESS_AUDIO_CTRL_MONO;\n\t\treg &= ~ESS_AUDIO_CTRL_STEREO;\n\t}\n\tess_write_x_reg(sc, ESS_XCMD_AUDIO_CTRL, reg);\n\n\treg = ess_read_x_reg(sc, ESS_XCMD_AUDIO1_CTRL1);\n\tif (param->precision * param->factor == 16)\n\t\treg |= ESS_AUDIO1_CTRL1_FIFO_SIZE;\n\telse\n\t\treg &= ~ESS_AUDIO1_CTRL1_FIFO_SIZE;\n\tif (param->channels == 2)\n\t\treg |= ESS_AUDIO1_CTRL1_FIFO_STEREO;\n\telse\n\t\treg &= ~ESS_AUDIO1_CTRL1_FIFO_STEREO;\n\tif (param->encoding == AUDIO_ENCODING_SLINEAR_BE ||\n\t    param->encoding == AUDIO_ENCODING_SLINEAR_LE)\n\t\treg |= ESS_AUDIO1_CTRL1_FIFO_SIGNED;\n\telse\n\t\treg &= ~ESS_AUDIO1_CTRL1_FIFO_SIGNED;\n\treg |= ESS_AUDIO1_CTRL1_FIFO_CONNECT;\n\tess_write_x_reg(sc, ESS_XCMD_AUDIO1_CTRL1, reg);\n\n\tisa_dmastart(sc->sc_isa, sc->sc_audio1.drq, start, \n\t\t     (char *)end - (char *)start, NULL,\n\t    DMAMODE_READ | DMAMODE_LOOP, BUS_DMA_NOWAIT);\n\n\t/* Program transfer count registers with 2's complement of count. */\n\tblksize = -blksize;\n\tess_write_x_reg(sc, ESS_XCMD_XFER_COUNTLO, blksize);\n\tess_write_x_reg(sc, ESS_XCMD_XFER_COUNTHI, blksize >> 8);\n\n\t/* Use 4 bytes per input DMA. */\n\tess_set_xreg_bits(sc, ESS_XCMD_DEMAND_CTRL, ESS_DEMAND_CTRL_DEMAND_4);\n\n\t/* Start auto-init DMA */\n  \tess_wdsp(sc, ESS_ACMD_DISABLE_SPKR);\n\treg = ess_read_x_reg(sc, ESS_XCMD_AUDIO1_CTRL2);\n\treg |= ESS_AUDIO1_CTRL2_DMA_READ | ESS_AUDIO1_CTRL2_ADC_ENABLE;\n\treg |= ESS_AUDIO1_CTRL2_FIFO_ENABLE | ESS_AUDIO1_CTRL2_AUTO_INIT;\n\tess_write_x_reg(sc, ESS_XCMD_AUDIO1_CTRL2, reg);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_audio1_trigger_input",
      "void\tess_audio1_poll",
      "unsigned long ess_round_buffersize __P((void *, unsigned long));",
      "int\tess_wdsp",
      "u_char\tess_read_x_reg",
      "int\tess_write_x_reg",
      "void\tess_set_xreg_bits",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_write_x_reg",
          "args": [
            "sc",
            "ESS_XCMD_AUDIO1_CTRL2",
            "reg"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "ess_write_x_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2558-2571",
          "snippet": "int\ness_write_x_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tint error;\n\n\tDPRINTFN(2,(\"ess_write_x_reg: %02x=%02x\\n\", reg, val));\n\tif ((error = ess_wdsp(sc, reg)) == 0)\n\t\terror = ess_wdsp(sc, val);\n\n\treturn error;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_wdsp",
            "int\tess_write_x_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_wdsp;\nint\tess_write_x_reg;\n\nint\ness_write_x_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tint error;\n\n\tDPRINTFN(2,(\"ess_write_x_reg: %02x=%02x\\n\", reg, val));\n\tif ((error = ess_wdsp(sc, reg)) == 0)\n\t\terror = ess_wdsp(sc, val);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_read_x_reg",
          "args": [
            "sc",
            "ESS_XCMD_AUDIO1_CTRL2"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "ess_read_x_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2576-2592",
          "snippet": "u_char\ness_read_x_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tint error;\n\tint val;\n\n\tif ((error = ess_wdsp(sc, 0xC0)) == 0)\n\t\terror = ess_wdsp(sc, reg);\n\tif (error)\n\t\tDPRINTF((\"Error reading extended register 0x%02x\\n\", reg));\n/* REVISIT: what if an error is returned above? */\n\tval = ess_rdsp(sc);\n\tDPRINTFN(2,(\"ess_read_x_reg: %02x=%02x\\n\", reg, val));\n\treturn val;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_rdsp",
            "int\tess_wdsp",
            "u_char\tess_read_x_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_rdsp;\nint\tess_wdsp;\nu_char\tess_read_x_reg;\n\nu_char\ness_read_x_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tint error;\n\tint val;\n\n\tif ((error = ess_wdsp(sc, 0xC0)) == 0)\n\t\terror = ess_wdsp(sc, reg);\n\tif (error)\n\t\tDPRINTF((\"Error reading extended register 0x%02x\\n\", reg));\n/* REVISIT: what if an error is returned above? */\n\tval = ess_rdsp(sc);\n\tDPRINTFN(2,(\"ess_read_x_reg: %02x=%02x\\n\", reg, val));\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_wdsp",
          "args": [
            "sc",
            "ESS_ACMD_DISABLE_SPKR"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "ess_wdsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2532-2553",
          "snippet": "int\ness_wdsp(sc, v)\n\tstruct ess_softc *sc;\n\tu_char v;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tDPRINTFN(8,(\"ess_wdsp(0x%02x)\\n\", v));\n\n\tfor (i = ESS_WRITE_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_write_ready(sc)) {\n\t\t\tEWRITE1(iot, ioh, ESS_DSP_WRITE, v);\n\t\t\treturn (0);\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_wdsp(0x%02x): timed out\\n\", v));\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_dsp_write_ready",
            "int\tess_wdsp"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_dsp_write_ready;\nint\tess_wdsp;\n\nint\ness_wdsp(sc, v)\n\tstruct ess_softc *sc;\n\tu_char v;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tDPRINTFN(8,(\"ess_wdsp(0x%02x)\\n\", v));\n\n\tfor (i = ESS_WRITE_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_write_ready(sc)) {\n\t\t\tEWRITE1(iot, ioh, ESS_DSP_WRITE, v);\n\t\t\treturn (0);\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_wdsp(0x%02x): timed out\\n\", v));\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_set_xreg_bits",
          "args": [
            "sc",
            "ESS_XCMD_DEMAND_CTRL",
            "ESS_DEMAND_CTRL_DEMAND_4"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "ess_set_xreg_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2605-2614",
          "snippet": "void\ness_set_xreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tif (ess_write_x_reg(sc, reg, ess_read_x_reg(sc, reg) | mask) == -1)\n\t\tDPRINTF((\"Error setting bits in extended register 0x%02x\\n\",\n\t\t\t reg));\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_read_x_reg",
            "int\tess_write_x_reg",
            "void\tess_set_xreg_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_x_reg;\nint\tess_write_x_reg;\nvoid\tess_set_xreg_bits;\n\nvoid\ness_set_xreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tif (ess_write_x_reg(sc, reg, ess_read_x_reg(sc, reg) | mask) == -1)\n\t\tDPRINTF((\"Error setting bits in extended register 0x%02x\\n\",\n\t\t\t reg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_dmastart",
          "args": [
            "sc->sc_isa",
            "sc->sc_audio1.drq",
            "start",
            "(char *)end - (char *)start",
            "NULL",
            "DMAMODE_READ | DMAMODE_LOOP",
            "BUS_DMA_NOWAIT"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmastart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "288-422",
          "snippet": "int\nisa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)\n\tstruct device *isadev;\n\tint chan;\n\tvoid *addr;\n\tbus_size_t nbytes;\n\tstruct proc *p;\n\tint flags;\n\tint busdmaflags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\tbus_addr_t dmaaddr;\n\tint waport;\n\tint ochan = chan & 3;\n\tint error;\n#ifdef __ISADMA_COMPAT\n\tint compat = busdmaflags & BUS_DMA_BUS1;\n\n\tbusdmaflags &= ~BUS_DMA_BUS1;\n#endif /* __ISADMA_COMPAT */\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, \"\n\t    \"flags 0x%x, dmaflags 0x%x\\n\",\n\t    chan, addr, nbytes, p, flags, busdmaflags);\n#endif\n\n\tif (chan & 4) {\n\t\tif (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx, addr %p\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes, addr);\n\t\t\tgoto lose;\n\t\t}\n\t} else {\n\t\tif (nbytes > (1 << 16)) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes);\n\t\t\tgoto lose;\n\t\t}\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\tif (dmam == NULL) {\n#ifdef __ISADMA_COMPAT\n\t\tif (compat)\n\t\t\tdmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];\n\t\telse\n#endif /* __ISADMA_COMPAT */\n\t\tpanic(\"isa_dmastart: no DMA map for chan %d\", chan);\n\t}\n\n\terror = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,\n\t    busdmaflags);\n\tif (error)\n\t\treturn (error);\n\n#ifdef ISADMA_DEBUG\n\t__asm(\".globl isa_dmastart_afterload ; isa_dmastart_afterload:\");\n#endif\n\n\tif (flags & DMAMODE_READ) {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);\n\t\tsc->sc_dmareads |= (1 << chan);\n\t} else {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);\n\t\tsc->sc_dmareads &= ~(1 << chan);\n\t}\n\n\tdmaaddr = dmam->dm_segs[0].ds_addr;\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"     dmaaddr 0x%lx\\n\", dmaaddr);\n\n\t__asm(\".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:\");\n#endif\n\n\tsc->sc_dmalength[chan] = nbytes;\n\n\tisa_dmamask(sc, chan);\n\tsc->sc_dmafinished &= ~(1 << chan);\n\n\tif ((chan & 4) == 0) {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA1_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (nbytes >> 8) & 0xff);\n\t} else {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA2_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);\n\t\tdmaaddr >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tnbytes >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (nbytes >> 8) & 0xff);\n\t}\n\n\tisa_dmaunmask(sc, chan);\n\treturn (0);\n\n lose:\n\tpanic(\"isa_dmastart\");\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dmapageport[2][4] = {\n\t{0x7, 0x3, 0x1, 0x2},\n\t{0xf, 0xb, 0x9, 0xa}\n};",
            "static u_int8_t dmamode[4] = {\n\tDMA37MD_READ | DMA37MD_SINGLE,\n\tDMA37MD_WRITE | DMA37MD_SINGLE,\n\tDMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,\n\tDMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP\n};",
            "static inline void isa_dmaunmask",
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int dmapageport[2][4] = {\n\t{0x7, 0x3, 0x1, 0x2},\n\t{0xf, 0xb, 0x9, 0xa}\n};\nstatic u_int8_t dmamode[4] = {\n\tDMA37MD_READ | DMA37MD_SINGLE,\n\tDMA37MD_WRITE | DMA37MD_SINGLE,\n\tDMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,\n\tDMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP\n};\nstatic inline void isa_dmaunmask;\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\nint flags;\n\nint\nisa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)\n\tstruct device *isadev;\n\tint chan;\n\tvoid *addr;\n\tbus_size_t nbytes;\n\tstruct proc *p;\n\tint flags;\n\tint busdmaflags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\tbus_addr_t dmaaddr;\n\tint waport;\n\tint ochan = chan & 3;\n\tint error;\n#ifdef __ISADMA_COMPAT\n\tint compat = busdmaflags & BUS_DMA_BUS1;\n\n\tbusdmaflags &= ~BUS_DMA_BUS1;\n#endif /* __ISADMA_COMPAT */\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, \"\n\t    \"flags 0x%x, dmaflags 0x%x\\n\",\n\t    chan, addr, nbytes, p, flags, busdmaflags);\n#endif\n\n\tif (chan & 4) {\n\t\tif (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx, addr %p\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes, addr);\n\t\t\tgoto lose;\n\t\t}\n\t} else {\n\t\tif (nbytes > (1 << 16)) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes);\n\t\t\tgoto lose;\n\t\t}\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\tif (dmam == NULL) {\n#ifdef __ISADMA_COMPAT\n\t\tif (compat)\n\t\t\tdmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];\n\t\telse\n#endif /* __ISADMA_COMPAT */\n\t\tpanic(\"isa_dmastart: no DMA map for chan %d\", chan);\n\t}\n\n\terror = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,\n\t    busdmaflags);\n\tif (error)\n\t\treturn (error);\n\n#ifdef ISADMA_DEBUG\n\t__asm(\".globl isa_dmastart_afterload ; isa_dmastart_afterload:\");\n#endif\n\n\tif (flags & DMAMODE_READ) {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);\n\t\tsc->sc_dmareads |= (1 << chan);\n\t} else {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);\n\t\tsc->sc_dmareads &= ~(1 << chan);\n\t}\n\n\tdmaaddr = dmam->dm_segs[0].ds_addr;\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"     dmaaddr 0x%lx\\n\", dmaaddr);\n\n\t__asm(\".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:\");\n#endif\n\n\tsc->sc_dmalength[chan] = nbytes;\n\n\tisa_dmamask(sc, chan);\n\tsc->sc_dmafinished &= ~(1 << chan);\n\n\tif ((chan & 4) == 0) {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA1_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (nbytes >> 8) & 0xff);\n\t} else {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA2_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);\n\t\tdmaaddr >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tnbytes >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (nbytes >> 8) & 0xff);\n\t}\n\n\tisa_dmaunmask(sc, chan);\n\treturn (0);\n\n lose:\n\tpanic(\"isa_dmastart\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "ess_audio1_poll",
            "sc",
            "hz/30"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "bt_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1300-1345",
          "snippet": "void\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
          ],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_queue_ccb",
            "void bt_collect_mbo",
            "void bt_timeout",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_queue_ccb;\nvoid bt_collect_mbo;\nvoid bt_timeout;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ess_audio1_trigger_input: already running\""
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ess_audio1_trigger_input: sc=%p start=%p end=%p blksize=%d intr=%p(%p)\\n\",\n\t    addr, start, end, blksize, intr, arg)"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_audio1_trigger_input;\nvoid\tess_audio1_poll;\nunsigned long ess_round_buffersize __P((void *, unsigned long));\nint\tess_wdsp;\nu_char\tess_read_x_reg;\nint\tess_write_x_reg;\nvoid\tess_set_xreg_bits;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_audio1_trigger_input(addr, start, end, blksize, intr, arg, param)\n\tvoid *addr;\n\tvoid *start, *end;\n\tint blksize;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n\tstruct audio_params *param;\n{\n\tstruct ess_softc *sc = addr;\n\tu_int8_t reg;\n\n\tDPRINTFN(1, (\"ess_audio1_trigger_input: sc=%p start=%p end=%p blksize=%d intr=%p(%p)\\n\",\n\t    addr, start, end, blksize, intr, arg));\n\n\tif (sc->sc_audio1.active)\n\t\tpanic(\"ess_audio1_trigger_input: already running\");\n\n\tsc->sc_audio1.active = 1;\n\tsc->sc_audio1.intr = intr;\n\tsc->sc_audio1.arg = arg;\n\tif (sc->sc_audio1.polled) {\n\t\tsc->sc_audio1.dmapos = 0;\n\t\tsc->sc_audio1.buffersize = (char *)end - (char *)start;\n\t\tsc->sc_audio1.dmacount = 0;\n\t\tsc->sc_audio1.blksize = blksize;\n\t\ttimeout(ess_audio1_poll, sc, hz/30);\n\t}\n\n\treg = ess_read_x_reg(sc, ESS_XCMD_AUDIO_CTRL);\n\tif (param->channels == 2) {\n\t\treg &= ~ESS_AUDIO_CTRL_MONO;\n\t\treg |= ESS_AUDIO_CTRL_STEREO;\n\t} else {\n\t\treg |= ESS_AUDIO_CTRL_MONO;\n\t\treg &= ~ESS_AUDIO_CTRL_STEREO;\n\t}\n\tess_write_x_reg(sc, ESS_XCMD_AUDIO_CTRL, reg);\n\n\treg = ess_read_x_reg(sc, ESS_XCMD_AUDIO1_CTRL1);\n\tif (param->precision * param->factor == 16)\n\t\treg |= ESS_AUDIO1_CTRL1_FIFO_SIZE;\n\telse\n\t\treg &= ~ESS_AUDIO1_CTRL1_FIFO_SIZE;\n\tif (param->channels == 2)\n\t\treg |= ESS_AUDIO1_CTRL1_FIFO_STEREO;\n\telse\n\t\treg &= ~ESS_AUDIO1_CTRL1_FIFO_STEREO;\n\tif (param->encoding == AUDIO_ENCODING_SLINEAR_BE ||\n\t    param->encoding == AUDIO_ENCODING_SLINEAR_LE)\n\t\treg |= ESS_AUDIO1_CTRL1_FIFO_SIGNED;\n\telse\n\t\treg &= ~ESS_AUDIO1_CTRL1_FIFO_SIGNED;\n\treg |= ESS_AUDIO1_CTRL1_FIFO_CONNECT;\n\tess_write_x_reg(sc, ESS_XCMD_AUDIO1_CTRL1, reg);\n\n\tisa_dmastart(sc->sc_isa, sc->sc_audio1.drq, start, \n\t\t     (char *)end - (char *)start, NULL,\n\t    DMAMODE_READ | DMAMODE_LOOP, BUS_DMA_NOWAIT);\n\n\t/* Program transfer count registers with 2's complement of count. */\n\tblksize = -blksize;\n\tess_write_x_reg(sc, ESS_XCMD_XFER_COUNTLO, blksize);\n\tess_write_x_reg(sc, ESS_XCMD_XFER_COUNTHI, blksize >> 8);\n\n\t/* Use 4 bytes per input DMA. */\n\tess_set_xreg_bits(sc, ESS_XCMD_DEMAND_CTRL, ESS_DEMAND_CTRL_DEMAND_4);\n\n\t/* Start auto-init DMA */\n  \tess_wdsp(sc, ESS_ACMD_DISABLE_SPKR);\n\treg = ess_read_x_reg(sc, ESS_XCMD_AUDIO1_CTRL2);\n\treg |= ESS_AUDIO1_CTRL2_DMA_READ | ESS_AUDIO1_CTRL2_ADC_ENABLE;\n\treg |= ESS_AUDIO1_CTRL2_FIFO_ENABLE | ESS_AUDIO1_CTRL2_AUTO_INIT;\n\tess_write_x_reg(sc, ESS_XCMD_AUDIO1_CTRL2, reg);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "ess_audio2_trigger_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1354-1421",
    "snippet": "int\ness_audio2_trigger_output(addr, start, end, blksize, intr, arg, param)\n\tvoid *addr;\n\tvoid *start, *end;\n\tint blksize;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n\tstruct audio_params *param;\n{\n\tstruct ess_softc *sc = addr;\n\tu_int8_t reg;\n\n\tDPRINTFN(1, (\"ess_audio2_trigger_output: sc=%p start=%p end=%p blksize=%d intr=%p(%p)\\n\",\n\t    addr, start, end, blksize, intr, arg));\n\n\tif (sc->sc_audio2.active)\n\t\tpanic(\"ess_audio2_trigger_output: already running\");\n\n\tsc->sc_audio2.active = 1;\n\tsc->sc_audio2.intr = intr;\n\tsc->sc_audio2.arg = arg;\n\tif (sc->sc_audio2.polled) {\n\t\tsc->sc_audio2.dmapos = 0;\n\t\tsc->sc_audio2.buffersize = (char *)end - (char *)start;\n\t\tsc->sc_audio2.dmacount = 0;\n\t\tsc->sc_audio2.blksize = blksize;\n\t\ttimeout(ess_audio2_poll, sc, hz/30);\n\t}\n\n\treg = ess_read_mix_reg(sc, ESS_MREG_AUDIO2_CTRL2);\n\tif (param->precision * param->factor == 16)\n\t\treg |= ESS_AUDIO2_CTRL2_FIFO_SIZE;\n\telse\n\t\treg &= ~ESS_AUDIO2_CTRL2_FIFO_SIZE;\n\tif (param->channels == 2)\n\t\treg |= ESS_AUDIO2_CTRL2_CHANNELS;\n\telse\n\t\treg &= ~ESS_AUDIO2_CTRL2_CHANNELS;\n\tif (param->encoding == AUDIO_ENCODING_SLINEAR_BE ||\n\t    param->encoding == AUDIO_ENCODING_SLINEAR_LE)\n\t\treg |= ESS_AUDIO2_CTRL2_FIFO_SIGNED;\n\telse\n\t\treg &= ~ESS_AUDIO2_CTRL2_FIFO_SIGNED;\n\tess_write_mix_reg(sc, ESS_MREG_AUDIO2_CTRL2, reg);\n\n\tisa_dmastart(sc->sc_isa, sc->sc_audio2.drq, start, \n\t\t     (char *)end - (char *)start, NULL,\n\t    DMAMODE_WRITE | DMAMODE_LOOP, BUS_DMA_NOWAIT);\n\n\tif (IS16BITDRQ(sc->sc_audio2.drq))\n\t\tblksize >>= 1;\t/* use word count for 16 bit DMA */\n\t/* Program transfer count registers with 2's complement of count. */\n\tblksize = -blksize;\n\tess_write_mix_reg(sc, ESS_MREG_XFER_COUNTLO, blksize);\n\tess_write_mix_reg(sc, ESS_MREG_XFER_COUNTHI, blksize >> 8);\n\n\treg = ess_read_mix_reg(sc, ESS_MREG_AUDIO2_CTRL1);\n\tif (IS16BITDRQ(sc->sc_audio2.drq))\n\t\treg |= ESS_AUDIO2_CTRL1_XFER_SIZE;\n\telse\n\t\treg &= ~ESS_AUDIO2_CTRL1_XFER_SIZE;\n\treg |= ESS_AUDIO2_CTRL1_DEMAND_8;\n\treg |= ESS_AUDIO2_CTRL1_DAC_ENABLE | ESS_AUDIO2_CTRL1_FIFO_ENABLE |\n\t       ESS_AUDIO2_CTRL1_AUTO_INIT;\n\tess_write_mix_reg(sc, ESS_MREG_AUDIO2_CTRL1, reg);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_audio2_trigger_output",
      "void\tess_audio2_poll",
      "unsigned long ess_round_buffersize __P((void *, unsigned long));",
      "u_char\tess_read_mix_reg",
      "void\tess_write_mix_reg",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_write_mix_reg",
          "args": [
            "sc",
            "ESS_MREG_AUDIO2_CTRL1",
            "reg"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "ess_write_mix_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2620-2636",
          "snippet": "void\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_write_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_write_mix_reg;\n\nvoid\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS16BITDRQ",
          "args": [
            "sc->sc_audio2.drq"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_read_mix_reg",
          "args": [
            "sc",
            "ESS_MREG_AUDIO2_CTRL1"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "ess_read_mix_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2641-2658",
          "snippet": "u_char\ness_read_mix_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\tu_char val;\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tval = EREAD1(iot, ioh, ESS_MIX_REG_DATA);\n\tsplx(s);\n\n\tDPRINTFN(2,(\"ess_read_mix_reg: %x=%x\\n\", reg, val));\n\treturn val;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_read_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_mix_reg;\n\nu_char\ness_read_mix_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\tu_char val;\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tval = EREAD1(iot, ioh, ESS_MIX_REG_DATA);\n\tsplx(s);\n\n\tDPRINTFN(2,(\"ess_read_mix_reg: %x=%x\\n\", reg, val));\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS16BITDRQ",
          "args": [
            "sc->sc_audio2.drq"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_dmastart",
          "args": [
            "sc->sc_isa",
            "sc->sc_audio2.drq",
            "start",
            "(char *)end - (char *)start",
            "NULL",
            "DMAMODE_WRITE | DMAMODE_LOOP",
            "BUS_DMA_NOWAIT"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmastart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "288-422",
          "snippet": "int\nisa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)\n\tstruct device *isadev;\n\tint chan;\n\tvoid *addr;\n\tbus_size_t nbytes;\n\tstruct proc *p;\n\tint flags;\n\tint busdmaflags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\tbus_addr_t dmaaddr;\n\tint waport;\n\tint ochan = chan & 3;\n\tint error;\n#ifdef __ISADMA_COMPAT\n\tint compat = busdmaflags & BUS_DMA_BUS1;\n\n\tbusdmaflags &= ~BUS_DMA_BUS1;\n#endif /* __ISADMA_COMPAT */\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, \"\n\t    \"flags 0x%x, dmaflags 0x%x\\n\",\n\t    chan, addr, nbytes, p, flags, busdmaflags);\n#endif\n\n\tif (chan & 4) {\n\t\tif (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx, addr %p\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes, addr);\n\t\t\tgoto lose;\n\t\t}\n\t} else {\n\t\tif (nbytes > (1 << 16)) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes);\n\t\t\tgoto lose;\n\t\t}\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\tif (dmam == NULL) {\n#ifdef __ISADMA_COMPAT\n\t\tif (compat)\n\t\t\tdmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];\n\t\telse\n#endif /* __ISADMA_COMPAT */\n\t\tpanic(\"isa_dmastart: no DMA map for chan %d\", chan);\n\t}\n\n\terror = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,\n\t    busdmaflags);\n\tif (error)\n\t\treturn (error);\n\n#ifdef ISADMA_DEBUG\n\t__asm(\".globl isa_dmastart_afterload ; isa_dmastart_afterload:\");\n#endif\n\n\tif (flags & DMAMODE_READ) {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);\n\t\tsc->sc_dmareads |= (1 << chan);\n\t} else {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);\n\t\tsc->sc_dmareads &= ~(1 << chan);\n\t}\n\n\tdmaaddr = dmam->dm_segs[0].ds_addr;\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"     dmaaddr 0x%lx\\n\", dmaaddr);\n\n\t__asm(\".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:\");\n#endif\n\n\tsc->sc_dmalength[chan] = nbytes;\n\n\tisa_dmamask(sc, chan);\n\tsc->sc_dmafinished &= ~(1 << chan);\n\n\tif ((chan & 4) == 0) {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA1_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (nbytes >> 8) & 0xff);\n\t} else {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA2_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);\n\t\tdmaaddr >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tnbytes >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (nbytes >> 8) & 0xff);\n\t}\n\n\tisa_dmaunmask(sc, chan);\n\treturn (0);\n\n lose:\n\tpanic(\"isa_dmastart\");\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dmapageport[2][4] = {\n\t{0x7, 0x3, 0x1, 0x2},\n\t{0xf, 0xb, 0x9, 0xa}\n};",
            "static u_int8_t dmamode[4] = {\n\tDMA37MD_READ | DMA37MD_SINGLE,\n\tDMA37MD_WRITE | DMA37MD_SINGLE,\n\tDMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,\n\tDMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP\n};",
            "static inline void isa_dmaunmask",
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int dmapageport[2][4] = {\n\t{0x7, 0x3, 0x1, 0x2},\n\t{0xf, 0xb, 0x9, 0xa}\n};\nstatic u_int8_t dmamode[4] = {\n\tDMA37MD_READ | DMA37MD_SINGLE,\n\tDMA37MD_WRITE | DMA37MD_SINGLE,\n\tDMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,\n\tDMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP\n};\nstatic inline void isa_dmaunmask;\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\nint flags;\n\nint\nisa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)\n\tstruct device *isadev;\n\tint chan;\n\tvoid *addr;\n\tbus_size_t nbytes;\n\tstruct proc *p;\n\tint flags;\n\tint busdmaflags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\tbus_addr_t dmaaddr;\n\tint waport;\n\tint ochan = chan & 3;\n\tint error;\n#ifdef __ISADMA_COMPAT\n\tint compat = busdmaflags & BUS_DMA_BUS1;\n\n\tbusdmaflags &= ~BUS_DMA_BUS1;\n#endif /* __ISADMA_COMPAT */\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, \"\n\t    \"flags 0x%x, dmaflags 0x%x\\n\",\n\t    chan, addr, nbytes, p, flags, busdmaflags);\n#endif\n\n\tif (chan & 4) {\n\t\tif (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx, addr %p\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes, addr);\n\t\t\tgoto lose;\n\t\t}\n\t} else {\n\t\tif (nbytes > (1 << 16)) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes);\n\t\t\tgoto lose;\n\t\t}\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\tif (dmam == NULL) {\n#ifdef __ISADMA_COMPAT\n\t\tif (compat)\n\t\t\tdmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];\n\t\telse\n#endif /* __ISADMA_COMPAT */\n\t\tpanic(\"isa_dmastart: no DMA map for chan %d\", chan);\n\t}\n\n\terror = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,\n\t    busdmaflags);\n\tif (error)\n\t\treturn (error);\n\n#ifdef ISADMA_DEBUG\n\t__asm(\".globl isa_dmastart_afterload ; isa_dmastart_afterload:\");\n#endif\n\n\tif (flags & DMAMODE_READ) {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);\n\t\tsc->sc_dmareads |= (1 << chan);\n\t} else {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);\n\t\tsc->sc_dmareads &= ~(1 << chan);\n\t}\n\n\tdmaaddr = dmam->dm_segs[0].ds_addr;\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"     dmaaddr 0x%lx\\n\", dmaaddr);\n\n\t__asm(\".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:\");\n#endif\n\n\tsc->sc_dmalength[chan] = nbytes;\n\n\tisa_dmamask(sc, chan);\n\tsc->sc_dmafinished &= ~(1 << chan);\n\n\tif ((chan & 4) == 0) {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA1_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (nbytes >> 8) & 0xff);\n\t} else {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA2_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);\n\t\tdmaaddr >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tnbytes >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (nbytes >> 8) & 0xff);\n\t}\n\n\tisa_dmaunmask(sc, chan);\n\treturn (0);\n\n lose:\n\tpanic(\"isa_dmastart\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "ess_audio2_poll",
            "sc",
            "hz/30"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "bt_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1300-1345",
          "snippet": "void\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
          ],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_queue_ccb",
            "void bt_collect_mbo",
            "void bt_timeout",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_queue_ccb;\nvoid bt_collect_mbo;\nvoid bt_timeout;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ess_audio2_trigger_output: already running\""
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ess_audio2_trigger_output: sc=%p start=%p end=%p blksize=%d intr=%p(%p)\\n\",\n\t    addr, start, end, blksize, intr, arg)"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_audio2_trigger_output;\nvoid\tess_audio2_poll;\nunsigned long ess_round_buffersize __P((void *, unsigned long));\nu_char\tess_read_mix_reg;\nvoid\tess_write_mix_reg;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_audio2_trigger_output(addr, start, end, blksize, intr, arg, param)\n\tvoid *addr;\n\tvoid *start, *end;\n\tint blksize;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n\tstruct audio_params *param;\n{\n\tstruct ess_softc *sc = addr;\n\tu_int8_t reg;\n\n\tDPRINTFN(1, (\"ess_audio2_trigger_output: sc=%p start=%p end=%p blksize=%d intr=%p(%p)\\n\",\n\t    addr, start, end, blksize, intr, arg));\n\n\tif (sc->sc_audio2.active)\n\t\tpanic(\"ess_audio2_trigger_output: already running\");\n\n\tsc->sc_audio2.active = 1;\n\tsc->sc_audio2.intr = intr;\n\tsc->sc_audio2.arg = arg;\n\tif (sc->sc_audio2.polled) {\n\t\tsc->sc_audio2.dmapos = 0;\n\t\tsc->sc_audio2.buffersize = (char *)end - (char *)start;\n\t\tsc->sc_audio2.dmacount = 0;\n\t\tsc->sc_audio2.blksize = blksize;\n\t\ttimeout(ess_audio2_poll, sc, hz/30);\n\t}\n\n\treg = ess_read_mix_reg(sc, ESS_MREG_AUDIO2_CTRL2);\n\tif (param->precision * param->factor == 16)\n\t\treg |= ESS_AUDIO2_CTRL2_FIFO_SIZE;\n\telse\n\t\treg &= ~ESS_AUDIO2_CTRL2_FIFO_SIZE;\n\tif (param->channels == 2)\n\t\treg |= ESS_AUDIO2_CTRL2_CHANNELS;\n\telse\n\t\treg &= ~ESS_AUDIO2_CTRL2_CHANNELS;\n\tif (param->encoding == AUDIO_ENCODING_SLINEAR_BE ||\n\t    param->encoding == AUDIO_ENCODING_SLINEAR_LE)\n\t\treg |= ESS_AUDIO2_CTRL2_FIFO_SIGNED;\n\telse\n\t\treg &= ~ESS_AUDIO2_CTRL2_FIFO_SIGNED;\n\tess_write_mix_reg(sc, ESS_MREG_AUDIO2_CTRL2, reg);\n\n\tisa_dmastart(sc->sc_isa, sc->sc_audio2.drq, start, \n\t\t     (char *)end - (char *)start, NULL,\n\t    DMAMODE_WRITE | DMAMODE_LOOP, BUS_DMA_NOWAIT);\n\n\tif (IS16BITDRQ(sc->sc_audio2.drq))\n\t\tblksize >>= 1;\t/* use word count for 16 bit DMA */\n\t/* Program transfer count registers with 2's complement of count. */\n\tblksize = -blksize;\n\tess_write_mix_reg(sc, ESS_MREG_XFER_COUNTLO, blksize);\n\tess_write_mix_reg(sc, ESS_MREG_XFER_COUNTHI, blksize >> 8);\n\n\treg = ess_read_mix_reg(sc, ESS_MREG_AUDIO2_CTRL1);\n\tif (IS16BITDRQ(sc->sc_audio2.drq))\n\t\treg |= ESS_AUDIO2_CTRL1_XFER_SIZE;\n\telse\n\t\treg &= ~ESS_AUDIO2_CTRL1_XFER_SIZE;\n\treg |= ESS_AUDIO2_CTRL1_DEMAND_8;\n\treg |= ESS_AUDIO2_CTRL1_DAC_ENABLE | ESS_AUDIO2_CTRL1_FIFO_ENABLE |\n\t       ESS_AUDIO2_CTRL1_AUTO_INIT;\n\tess_write_mix_reg(sc, ESS_MREG_AUDIO2_CTRL1, reg);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "ess_audio1_trigger_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1276-1352",
    "snippet": "int\ness_audio1_trigger_output(addr, start, end, blksize, intr, arg, param)\n\tvoid *addr;\n\tvoid *start, *end;\n\tint blksize;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n\tstruct audio_params *param;\n{\n\tstruct ess_softc *sc = addr;\n\tu_int8_t reg;\n\n\tDPRINTFN(1, (\"ess_audio1_trigger_output: sc=%p start=%p end=%p blksize=%d intr=%p(%p)\\n\",\n\t    addr, start, end, blksize, intr, arg));\n\n\tif (sc->sc_audio1.active)\n\t\tpanic(\"ess_audio1_trigger_output: already running\");\n\n\tsc->sc_audio1.active = 1;\n\tsc->sc_audio1.intr = intr;\n\tsc->sc_audio1.arg = arg;\n\tif (sc->sc_audio1.polled) {\n\t\tsc->sc_audio1.dmapos = 0;\n\t\tsc->sc_audio1.buffersize = (char *)end - (char *)start;\n\t\tsc->sc_audio1.dmacount = 0;\n\t\tsc->sc_audio1.blksize = blksize;\n\t\ttimeout(ess_audio1_poll, sc, hz/30);\n\t}\n\n\treg = ess_read_x_reg(sc, ESS_XCMD_AUDIO_CTRL);\n\tif (param->channels == 2) {\n\t\treg &= ~ESS_AUDIO_CTRL_MONO;\n\t\treg |= ESS_AUDIO_CTRL_STEREO;\n\t} else {\n\t\treg |= ESS_AUDIO_CTRL_MONO;\n\t\treg &= ~ESS_AUDIO_CTRL_STEREO;\n\t}\n\tess_write_x_reg(sc, ESS_XCMD_AUDIO_CTRL, reg);\n\n\treg = ess_read_x_reg(sc, ESS_XCMD_AUDIO1_CTRL1);\n\tif (param->precision * param->factor == 16)\n\t\treg |= ESS_AUDIO1_CTRL1_FIFO_SIZE;\n\telse\n\t\treg &= ~ESS_AUDIO1_CTRL1_FIFO_SIZE;\n\tif (param->channels == 2)\n\t\treg |= ESS_AUDIO1_CTRL1_FIFO_STEREO;\n\telse\n\t\treg &= ~ESS_AUDIO1_CTRL1_FIFO_STEREO;\n\tif (param->encoding == AUDIO_ENCODING_SLINEAR_BE ||\n\t    param->encoding == AUDIO_ENCODING_SLINEAR_LE)\n\t\treg |= ESS_AUDIO1_CTRL1_FIFO_SIGNED;\n\telse\n\t\treg &= ~ESS_AUDIO1_CTRL1_FIFO_SIGNED;\n\treg |= ESS_AUDIO1_CTRL1_FIFO_CONNECT;\n\tess_write_x_reg(sc, ESS_XCMD_AUDIO1_CTRL1, reg);\n\n\tisa_dmastart(sc->sc_isa, sc->sc_audio1.drq, start, \n\t\t     (char *)end - (char *)start, NULL,\n\t    DMAMODE_WRITE | DMAMODE_LOOP, BUS_DMA_NOWAIT);\n\n\t/* Program transfer count registers with 2's complement of count. */\n\tblksize = -blksize;\n\tess_write_x_reg(sc, ESS_XCMD_XFER_COUNTLO, blksize);\n\tess_write_x_reg(sc, ESS_XCMD_XFER_COUNTHI, blksize >> 8);\n\n\t/* Use 4 bytes per output DMA. */\n\tess_set_xreg_bits(sc, ESS_XCMD_DEMAND_CTRL, ESS_DEMAND_CTRL_DEMAND_4);\n\n\t/* Start auto-init DMA */\n  \tess_wdsp(sc, ESS_ACMD_ENABLE_SPKR);\n\treg = ess_read_x_reg(sc, ESS_XCMD_AUDIO1_CTRL2);\n\treg &= ~(ESS_AUDIO1_CTRL2_DMA_READ | ESS_AUDIO1_CTRL2_ADC_ENABLE);\n\treg |= ESS_AUDIO1_CTRL2_FIFO_ENABLE | ESS_AUDIO1_CTRL2_AUTO_INIT;\n\tess_write_x_reg(sc, ESS_XCMD_AUDIO1_CTRL2, reg);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_audio1_trigger_output",
      "void\tess_audio1_poll",
      "unsigned long ess_round_buffersize __P((void *, unsigned long));",
      "int\tess_wdsp",
      "u_char\tess_read_x_reg",
      "int\tess_write_x_reg",
      "void\tess_set_xreg_bits",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_write_x_reg",
          "args": [
            "sc",
            "ESS_XCMD_AUDIO1_CTRL2",
            "reg"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "ess_write_x_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2558-2571",
          "snippet": "int\ness_write_x_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tint error;\n\n\tDPRINTFN(2,(\"ess_write_x_reg: %02x=%02x\\n\", reg, val));\n\tif ((error = ess_wdsp(sc, reg)) == 0)\n\t\terror = ess_wdsp(sc, val);\n\n\treturn error;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_wdsp",
            "int\tess_write_x_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_wdsp;\nint\tess_write_x_reg;\n\nint\ness_write_x_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tint error;\n\n\tDPRINTFN(2,(\"ess_write_x_reg: %02x=%02x\\n\", reg, val));\n\tif ((error = ess_wdsp(sc, reg)) == 0)\n\t\terror = ess_wdsp(sc, val);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_read_x_reg",
          "args": [
            "sc",
            "ESS_XCMD_AUDIO1_CTRL2"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "ess_read_x_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2576-2592",
          "snippet": "u_char\ness_read_x_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tint error;\n\tint val;\n\n\tif ((error = ess_wdsp(sc, 0xC0)) == 0)\n\t\terror = ess_wdsp(sc, reg);\n\tif (error)\n\t\tDPRINTF((\"Error reading extended register 0x%02x\\n\", reg));\n/* REVISIT: what if an error is returned above? */\n\tval = ess_rdsp(sc);\n\tDPRINTFN(2,(\"ess_read_x_reg: %02x=%02x\\n\", reg, val));\n\treturn val;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_rdsp",
            "int\tess_wdsp",
            "u_char\tess_read_x_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_rdsp;\nint\tess_wdsp;\nu_char\tess_read_x_reg;\n\nu_char\ness_read_x_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tint error;\n\tint val;\n\n\tif ((error = ess_wdsp(sc, 0xC0)) == 0)\n\t\terror = ess_wdsp(sc, reg);\n\tif (error)\n\t\tDPRINTF((\"Error reading extended register 0x%02x\\n\", reg));\n/* REVISIT: what if an error is returned above? */\n\tval = ess_rdsp(sc);\n\tDPRINTFN(2,(\"ess_read_x_reg: %02x=%02x\\n\", reg, val));\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_wdsp",
          "args": [
            "sc",
            "ESS_ACMD_ENABLE_SPKR"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "ess_wdsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2532-2553",
          "snippet": "int\ness_wdsp(sc, v)\n\tstruct ess_softc *sc;\n\tu_char v;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tDPRINTFN(8,(\"ess_wdsp(0x%02x)\\n\", v));\n\n\tfor (i = ESS_WRITE_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_write_ready(sc)) {\n\t\t\tEWRITE1(iot, ioh, ESS_DSP_WRITE, v);\n\t\t\treturn (0);\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_wdsp(0x%02x): timed out\\n\", v));\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_dsp_write_ready",
            "int\tess_wdsp"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_dsp_write_ready;\nint\tess_wdsp;\n\nint\ness_wdsp(sc, v)\n\tstruct ess_softc *sc;\n\tu_char v;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tDPRINTFN(8,(\"ess_wdsp(0x%02x)\\n\", v));\n\n\tfor (i = ESS_WRITE_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_write_ready(sc)) {\n\t\t\tEWRITE1(iot, ioh, ESS_DSP_WRITE, v);\n\t\t\treturn (0);\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_wdsp(0x%02x): timed out\\n\", v));\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_set_xreg_bits",
          "args": [
            "sc",
            "ESS_XCMD_DEMAND_CTRL",
            "ESS_DEMAND_CTRL_DEMAND_4"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "ess_set_xreg_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2605-2614",
          "snippet": "void\ness_set_xreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tif (ess_write_x_reg(sc, reg, ess_read_x_reg(sc, reg) | mask) == -1)\n\t\tDPRINTF((\"Error setting bits in extended register 0x%02x\\n\",\n\t\t\t reg));\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_read_x_reg",
            "int\tess_write_x_reg",
            "void\tess_set_xreg_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_x_reg;\nint\tess_write_x_reg;\nvoid\tess_set_xreg_bits;\n\nvoid\ness_set_xreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tif (ess_write_x_reg(sc, reg, ess_read_x_reg(sc, reg) | mask) == -1)\n\t\tDPRINTF((\"Error setting bits in extended register 0x%02x\\n\",\n\t\t\t reg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_dmastart",
          "args": [
            "sc->sc_isa",
            "sc->sc_audio1.drq",
            "start",
            "(char *)end - (char *)start",
            "NULL",
            "DMAMODE_WRITE | DMAMODE_LOOP",
            "BUS_DMA_NOWAIT"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmastart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "288-422",
          "snippet": "int\nisa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)\n\tstruct device *isadev;\n\tint chan;\n\tvoid *addr;\n\tbus_size_t nbytes;\n\tstruct proc *p;\n\tint flags;\n\tint busdmaflags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\tbus_addr_t dmaaddr;\n\tint waport;\n\tint ochan = chan & 3;\n\tint error;\n#ifdef __ISADMA_COMPAT\n\tint compat = busdmaflags & BUS_DMA_BUS1;\n\n\tbusdmaflags &= ~BUS_DMA_BUS1;\n#endif /* __ISADMA_COMPAT */\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, \"\n\t    \"flags 0x%x, dmaflags 0x%x\\n\",\n\t    chan, addr, nbytes, p, flags, busdmaflags);\n#endif\n\n\tif (chan & 4) {\n\t\tif (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx, addr %p\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes, addr);\n\t\t\tgoto lose;\n\t\t}\n\t} else {\n\t\tif (nbytes > (1 << 16)) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes);\n\t\t\tgoto lose;\n\t\t}\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\tif (dmam == NULL) {\n#ifdef __ISADMA_COMPAT\n\t\tif (compat)\n\t\t\tdmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];\n\t\telse\n#endif /* __ISADMA_COMPAT */\n\t\tpanic(\"isa_dmastart: no DMA map for chan %d\", chan);\n\t}\n\n\terror = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,\n\t    busdmaflags);\n\tif (error)\n\t\treturn (error);\n\n#ifdef ISADMA_DEBUG\n\t__asm(\".globl isa_dmastart_afterload ; isa_dmastart_afterload:\");\n#endif\n\n\tif (flags & DMAMODE_READ) {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);\n\t\tsc->sc_dmareads |= (1 << chan);\n\t} else {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);\n\t\tsc->sc_dmareads &= ~(1 << chan);\n\t}\n\n\tdmaaddr = dmam->dm_segs[0].ds_addr;\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"     dmaaddr 0x%lx\\n\", dmaaddr);\n\n\t__asm(\".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:\");\n#endif\n\n\tsc->sc_dmalength[chan] = nbytes;\n\n\tisa_dmamask(sc, chan);\n\tsc->sc_dmafinished &= ~(1 << chan);\n\n\tif ((chan & 4) == 0) {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA1_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (nbytes >> 8) & 0xff);\n\t} else {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA2_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);\n\t\tdmaaddr >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tnbytes >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (nbytes >> 8) & 0xff);\n\t}\n\n\tisa_dmaunmask(sc, chan);\n\treturn (0);\n\n lose:\n\tpanic(\"isa_dmastart\");\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dmapageport[2][4] = {\n\t{0x7, 0x3, 0x1, 0x2},\n\t{0xf, 0xb, 0x9, 0xa}\n};",
            "static u_int8_t dmamode[4] = {\n\tDMA37MD_READ | DMA37MD_SINGLE,\n\tDMA37MD_WRITE | DMA37MD_SINGLE,\n\tDMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,\n\tDMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP\n};",
            "static inline void isa_dmaunmask",
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int dmapageport[2][4] = {\n\t{0x7, 0x3, 0x1, 0x2},\n\t{0xf, 0xb, 0x9, 0xa}\n};\nstatic u_int8_t dmamode[4] = {\n\tDMA37MD_READ | DMA37MD_SINGLE,\n\tDMA37MD_WRITE | DMA37MD_SINGLE,\n\tDMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,\n\tDMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP\n};\nstatic inline void isa_dmaunmask;\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\nint flags;\n\nint\nisa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)\n\tstruct device *isadev;\n\tint chan;\n\tvoid *addr;\n\tbus_size_t nbytes;\n\tstruct proc *p;\n\tint flags;\n\tint busdmaflags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\tbus_addr_t dmaaddr;\n\tint waport;\n\tint ochan = chan & 3;\n\tint error;\n#ifdef __ISADMA_COMPAT\n\tint compat = busdmaflags & BUS_DMA_BUS1;\n\n\tbusdmaflags &= ~BUS_DMA_BUS1;\n#endif /* __ISADMA_COMPAT */\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, \"\n\t    \"flags 0x%x, dmaflags 0x%x\\n\",\n\t    chan, addr, nbytes, p, flags, busdmaflags);\n#endif\n\n\tif (chan & 4) {\n\t\tif (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx, addr %p\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes, addr);\n\t\t\tgoto lose;\n\t\t}\n\t} else {\n\t\tif (nbytes > (1 << 16)) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes);\n\t\t\tgoto lose;\n\t\t}\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\tif (dmam == NULL) {\n#ifdef __ISADMA_COMPAT\n\t\tif (compat)\n\t\t\tdmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];\n\t\telse\n#endif /* __ISADMA_COMPAT */\n\t\tpanic(\"isa_dmastart: no DMA map for chan %d\", chan);\n\t}\n\n\terror = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,\n\t    busdmaflags);\n\tif (error)\n\t\treturn (error);\n\n#ifdef ISADMA_DEBUG\n\t__asm(\".globl isa_dmastart_afterload ; isa_dmastart_afterload:\");\n#endif\n\n\tif (flags & DMAMODE_READ) {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);\n\t\tsc->sc_dmareads |= (1 << chan);\n\t} else {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);\n\t\tsc->sc_dmareads &= ~(1 << chan);\n\t}\n\n\tdmaaddr = dmam->dm_segs[0].ds_addr;\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"     dmaaddr 0x%lx\\n\", dmaaddr);\n\n\t__asm(\".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:\");\n#endif\n\n\tsc->sc_dmalength[chan] = nbytes;\n\n\tisa_dmamask(sc, chan);\n\tsc->sc_dmafinished &= ~(1 << chan);\n\n\tif ((chan & 4) == 0) {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA1_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (nbytes >> 8) & 0xff);\n\t} else {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA2_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);\n\t\tdmaaddr >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tnbytes >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (nbytes >> 8) & 0xff);\n\t}\n\n\tisa_dmaunmask(sc, chan);\n\treturn (0);\n\n lose:\n\tpanic(\"isa_dmastart\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "ess_audio1_poll",
            "sc",
            "hz/30"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "bt_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1300-1345",
          "snippet": "void\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
          ],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_queue_ccb",
            "void bt_collect_mbo",
            "void bt_timeout",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_queue_ccb;\nvoid bt_collect_mbo;\nvoid bt_timeout;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ess_audio1_trigger_output: already running\""
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ess_audio1_trigger_output: sc=%p start=%p end=%p blksize=%d intr=%p(%p)\\n\",\n\t    addr, start, end, blksize, intr, arg)"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_audio1_trigger_output;\nvoid\tess_audio1_poll;\nunsigned long ess_round_buffersize __P((void *, unsigned long));\nint\tess_wdsp;\nu_char\tess_read_x_reg;\nint\tess_write_x_reg;\nvoid\tess_set_xreg_bits;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_audio1_trigger_output(addr, start, end, blksize, intr, arg, param)\n\tvoid *addr;\n\tvoid *start, *end;\n\tint blksize;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n\tstruct audio_params *param;\n{\n\tstruct ess_softc *sc = addr;\n\tu_int8_t reg;\n\n\tDPRINTFN(1, (\"ess_audio1_trigger_output: sc=%p start=%p end=%p blksize=%d intr=%p(%p)\\n\",\n\t    addr, start, end, blksize, intr, arg));\n\n\tif (sc->sc_audio1.active)\n\t\tpanic(\"ess_audio1_trigger_output: already running\");\n\n\tsc->sc_audio1.active = 1;\n\tsc->sc_audio1.intr = intr;\n\tsc->sc_audio1.arg = arg;\n\tif (sc->sc_audio1.polled) {\n\t\tsc->sc_audio1.dmapos = 0;\n\t\tsc->sc_audio1.buffersize = (char *)end - (char *)start;\n\t\tsc->sc_audio1.dmacount = 0;\n\t\tsc->sc_audio1.blksize = blksize;\n\t\ttimeout(ess_audio1_poll, sc, hz/30);\n\t}\n\n\treg = ess_read_x_reg(sc, ESS_XCMD_AUDIO_CTRL);\n\tif (param->channels == 2) {\n\t\treg &= ~ESS_AUDIO_CTRL_MONO;\n\t\treg |= ESS_AUDIO_CTRL_STEREO;\n\t} else {\n\t\treg |= ESS_AUDIO_CTRL_MONO;\n\t\treg &= ~ESS_AUDIO_CTRL_STEREO;\n\t}\n\tess_write_x_reg(sc, ESS_XCMD_AUDIO_CTRL, reg);\n\n\treg = ess_read_x_reg(sc, ESS_XCMD_AUDIO1_CTRL1);\n\tif (param->precision * param->factor == 16)\n\t\treg |= ESS_AUDIO1_CTRL1_FIFO_SIZE;\n\telse\n\t\treg &= ~ESS_AUDIO1_CTRL1_FIFO_SIZE;\n\tif (param->channels == 2)\n\t\treg |= ESS_AUDIO1_CTRL1_FIFO_STEREO;\n\telse\n\t\treg &= ~ESS_AUDIO1_CTRL1_FIFO_STEREO;\n\tif (param->encoding == AUDIO_ENCODING_SLINEAR_BE ||\n\t    param->encoding == AUDIO_ENCODING_SLINEAR_LE)\n\t\treg |= ESS_AUDIO1_CTRL1_FIFO_SIGNED;\n\telse\n\t\treg &= ~ESS_AUDIO1_CTRL1_FIFO_SIGNED;\n\treg |= ESS_AUDIO1_CTRL1_FIFO_CONNECT;\n\tess_write_x_reg(sc, ESS_XCMD_AUDIO1_CTRL1, reg);\n\n\tisa_dmastart(sc->sc_isa, sc->sc_audio1.drq, start, \n\t\t     (char *)end - (char *)start, NULL,\n\t    DMAMODE_WRITE | DMAMODE_LOOP, BUS_DMA_NOWAIT);\n\n\t/* Program transfer count registers with 2's complement of count. */\n\tblksize = -blksize;\n\tess_write_x_reg(sc, ESS_XCMD_XFER_COUNTLO, blksize);\n\tess_write_x_reg(sc, ESS_XCMD_XFER_COUNTHI, blksize >> 8);\n\n\t/* Use 4 bytes per output DMA. */\n\tess_set_xreg_bits(sc, ESS_XCMD_DEMAND_CTRL, ESS_DEMAND_CTRL_DEMAND_4);\n\n\t/* Start auto-init DMA */\n  \tess_wdsp(sc, ESS_ACMD_ENABLE_SPKR);\n\treg = ess_read_x_reg(sc, ESS_XCMD_AUDIO1_CTRL2);\n\treg &= ~(ESS_AUDIO1_CTRL2_DMA_READ | ESS_AUDIO1_CTRL2_ADC_ENABLE);\n\treg |= ESS_AUDIO1_CTRL2_FIFO_ENABLE | ESS_AUDIO1_CTRL2_AUTO_INIT;\n\tess_write_x_reg(sc, ESS_XCMD_AUDIO1_CTRL2, reg);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "ess_set_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1185-1274",
    "snippet": "int\ness_set_params(addr, setmode, usemode, play, rec)\n\tvoid *addr;\n\tint setmode, usemode;\n\tstruct audio_params *play, *rec;\n{\n\tstruct ess_softc *sc = addr;\n\tstruct audio_params *p;\n\tint mode;\n\tint rate;\n\n\tDPRINTF((\"ess_set_params: set=%d use=%d\\n\", setmode, usemode));\n\n\t/*\n\t * The ES1887 manual (page 39, `Full-Duplex DMA Mode') claims that in\n\t * full-duplex operation the sample rates must be the same for both\n\t * channels.  This appears to be false; the only bit in common is the\n\t * clock source selection.  However, we'll be conservative here.\n\t * - mycroft\n\t */\n\tif (play->sample_rate != rec->sample_rate &&\n\t    usemode == (AUMODE_PLAY | AUMODE_RECORD)) {\n\t\tif (setmode == AUMODE_PLAY) {\n\t\t\trec->sample_rate = play->sample_rate;\n\t\t\tsetmode |= AUMODE_RECORD;\n\t\t} else if (setmode == AUMODE_RECORD) {\n\t\t\tplay->sample_rate = rec->sample_rate;\n\t\t\tsetmode |= AUMODE_PLAY;\n\t\t} else\n\t\t\treturn (EINVAL);\n\t}\n\n\tfor (mode = AUMODE_RECORD; mode != -1; \n\t     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {\n\t\tif ((setmode & mode) == 0)\n\t\t\tcontinue;\n\n\t\tp = mode == AUMODE_PLAY ? play : rec;\n\n\t\tif (p->sample_rate < ESS_MINRATE ||\n\t\t    p->sample_rate > ESS_MAXRATE ||\n\t\t    (p->precision != 8 && p->precision != 16) ||\n\t\t    (p->channels != 1 && p->channels != 2))\n\t\t\treturn (EINVAL);\n\n\t\tp->factor = 1;\n\t\tp->sw_code = 0;\n\t\tswitch (p->encoding) {\n\t\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\t\tif (p->precision == 16)\n\t\t\t\tp->sw_code = swap_bytes;\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_SLINEAR_LE:\n\t\tcase AUDIO_ENCODING_ULINEAR_LE:\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_ULAW:\n\t\t\tif (mode == AUMODE_PLAY) {\n\t\t\t\tp->factor = 2;\n\t\t\t\tp->sw_code = mulaw_to_ulinear16;\n\t\t\t} else\n\t\t\t\tp->sw_code = ulinear8_to_mulaw;\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_ALAW:\n\t\t\tif (mode == AUMODE_PLAY) {\n\t\t\t\tp->factor = 2;\n\t\t\t\tp->sw_code = alaw_to_ulinear16;\n\t\t\t} else\n\t\t\t\tp->sw_code = ulinear8_to_alaw;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\t}\n\n\tif (usemode == AUMODE_RECORD)\n\t\trate = rec->sample_rate;\n\telse\n\t\trate = play->sample_rate;\n\n\tess_write_x_reg(sc, ESS_XCMD_SAMPLE_RATE, ess_srtotc(rate));\n\tess_write_x_reg(sc, ESS_XCMD_FILTER_CLOCK, ess_srtofc(rate));\n\n\tif (!ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tess_write_mix_reg(sc, ESS_MREG_SAMPLE_RATE, ess_srtotc(rate));\n\t\tess_write_mix_reg(sc, ESS_MREG_FILTER_CLOCK, ess_srtofc(rate));\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_set_params",
      "u_int\tess_srtotc",
      "u_int\tess_srtofc",
      "int\tess_write_x_reg",
      "void\tess_write_mix_reg",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_write_mix_reg",
          "args": [
            "sc",
            "ESS_MREG_FILTER_CLOCK",
            "ess_srtofc(rate)"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "ess_write_mix_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2620-2636",
          "snippet": "void\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_write_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_write_mix_reg;\n\nvoid\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_srtofc",
          "args": [
            "rate"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "ess_srtofc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2457-2467",
          "snippet": "u_int\ness_srtofc(rate)\n\tu_int rate;\n{\n\t/*\n\t * The following formula is derived from the information in\n\t * the ES1887 data sheet, based on a roll-off frequency of\n\t * 87%.\n\t */\n\treturn (256 - 200279L / rate);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_int\tess_srtofc"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int\tess_srtofc;\n\nu_int\ness_srtofc(rate)\n\tu_int rate;\n{\n\t/*\n\t * The following formula is derived from the information in\n\t * the ES1887 data sheet, based on a roll-off frequency of\n\t * 87%.\n\t */\n\treturn (256 - 200279L / rate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_srtotc",
          "args": [
            "rate"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "ess_srtotc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2438-2451",
          "snippet": "u_int\ness_srtotc(rate)\n\tu_int rate;\n{\n\tu_int tc;\n\n\t/* The following formulae are from the ESS data sheet. */\n\tif (rate <= 22050)\n\t\ttc = 128 - 397700L / rate;\n\telse\n\t\ttc = 256 - 795500L / rate;\n\n\treturn (tc);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_int\tess_srtotc"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int\tess_srtotc;\n\nu_int\ness_srtotc(rate)\n\tu_int rate;\n{\n\tu_int tc;\n\n\t/* The following formulae are from the ESS data sheet. */\n\tif (rate <= 22050)\n\t\ttc = 128 - 397700L / rate;\n\telse\n\t\ttc = 256 - 795500L / rate;\n\n\treturn (tc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESS_USE_AUDIO1",
          "args": [
            "sc->sc_model"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_write_x_reg",
          "args": [
            "sc",
            "ESS_XCMD_FILTER_CLOCK",
            "ess_srtofc(rate)"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "ess_write_x_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2558-2571",
          "snippet": "int\ness_write_x_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tint error;\n\n\tDPRINTFN(2,(\"ess_write_x_reg: %02x=%02x\\n\", reg, val));\n\tif ((error = ess_wdsp(sc, reg)) == 0)\n\t\terror = ess_wdsp(sc, val);\n\n\treturn error;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_wdsp",
            "int\tess_write_x_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_wdsp;\nint\tess_write_x_reg;\n\nint\ness_write_x_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tint error;\n\n\tDPRINTFN(2,(\"ess_write_x_reg: %02x=%02x\\n\", reg, val));\n\tif ((error = ess_wdsp(sc, reg)) == 0)\n\t\terror = ess_wdsp(sc, val);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ess_set_params: set=%d use=%d\\n\", setmode, usemode)"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_set_params;\nu_int\tess_srtotc;\nu_int\tess_srtofc;\nint\tess_write_x_reg;\nvoid\tess_write_mix_reg;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_set_params(addr, setmode, usemode, play, rec)\n\tvoid *addr;\n\tint setmode, usemode;\n\tstruct audio_params *play, *rec;\n{\n\tstruct ess_softc *sc = addr;\n\tstruct audio_params *p;\n\tint mode;\n\tint rate;\n\n\tDPRINTF((\"ess_set_params: set=%d use=%d\\n\", setmode, usemode));\n\n\t/*\n\t * The ES1887 manual (page 39, `Full-Duplex DMA Mode') claims that in\n\t * full-duplex operation the sample rates must be the same for both\n\t * channels.  This appears to be false; the only bit in common is the\n\t * clock source selection.  However, we'll be conservative here.\n\t * - mycroft\n\t */\n\tif (play->sample_rate != rec->sample_rate &&\n\t    usemode == (AUMODE_PLAY | AUMODE_RECORD)) {\n\t\tif (setmode == AUMODE_PLAY) {\n\t\t\trec->sample_rate = play->sample_rate;\n\t\t\tsetmode |= AUMODE_RECORD;\n\t\t} else if (setmode == AUMODE_RECORD) {\n\t\t\tplay->sample_rate = rec->sample_rate;\n\t\t\tsetmode |= AUMODE_PLAY;\n\t\t} else\n\t\t\treturn (EINVAL);\n\t}\n\n\tfor (mode = AUMODE_RECORD; mode != -1; \n\t     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {\n\t\tif ((setmode & mode) == 0)\n\t\t\tcontinue;\n\n\t\tp = mode == AUMODE_PLAY ? play : rec;\n\n\t\tif (p->sample_rate < ESS_MINRATE ||\n\t\t    p->sample_rate > ESS_MAXRATE ||\n\t\t    (p->precision != 8 && p->precision != 16) ||\n\t\t    (p->channels != 1 && p->channels != 2))\n\t\t\treturn (EINVAL);\n\n\t\tp->factor = 1;\n\t\tp->sw_code = 0;\n\t\tswitch (p->encoding) {\n\t\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\t\tif (p->precision == 16)\n\t\t\t\tp->sw_code = swap_bytes;\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_SLINEAR_LE:\n\t\tcase AUDIO_ENCODING_ULINEAR_LE:\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_ULAW:\n\t\t\tif (mode == AUMODE_PLAY) {\n\t\t\t\tp->factor = 2;\n\t\t\t\tp->sw_code = mulaw_to_ulinear16;\n\t\t\t} else\n\t\t\t\tp->sw_code = ulinear8_to_mulaw;\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_ALAW:\n\t\t\tif (mode == AUMODE_PLAY) {\n\t\t\t\tp->factor = 2;\n\t\t\t\tp->sw_code = alaw_to_ulinear16;\n\t\t\t} else\n\t\t\t\tp->sw_code = ulinear8_to_alaw;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\t}\n\n\tif (usemode == AUMODE_RECORD)\n\t\trate = rec->sample_rate;\n\telse\n\t\trate = play->sample_rate;\n\n\tess_write_x_reg(sc, ESS_XCMD_SAMPLE_RATE, ess_srtotc(rate));\n\tess_write_x_reg(sc, ESS_XCMD_FILTER_CLOCK, ess_srtofc(rate));\n\n\tif (!ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tess_write_mix_reg(sc, ESS_MREG_SAMPLE_RATE, ess_srtotc(rate));\n\t\tess_write_mix_reg(sc, ESS_MREG_FILTER_CLOCK, ess_srtofc(rate));\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "ess_query_encoding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1123-1183",
    "snippet": "int\ness_query_encoding(addr, fp)\n\tvoid *addr;\n\tstruct audio_encoding *fp;\n{\n\t/*struct ess_softc *sc = addr;*/\n\n\tswitch (fp->index) {\n\tcase 0:\n\t\tstrcpy(fp->name, AudioEulinear);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR;\n\t\tfp->precision = 8;\n\t\tfp->flags = 0;\n\t\treturn (0);\n\tcase 1:\n\t\tstrcpy(fp->name, AudioEmulaw);\n\t\tfp->encoding = AUDIO_ENCODING_ULAW;\n\t\tfp->precision = 8;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 2:\n\t\tstrcpy(fp->name, AudioEalaw);\n\t\tfp->encoding = AUDIO_ENCODING_ALAW;\n\t\tfp->precision = 8;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 3:\n\t\tstrcpy(fp->name, AudioEslinear);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR;\n\t\tfp->precision = 8;\n\t\tfp->flags = 0;\n\t\treturn (0);\n\tcase 4:\n\t\tstrcpy(fp->name, AudioEslinear_le);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR_LE;\n\t\tfp->precision = 16;\n\t\tfp->flags = 0;\n\t\treturn (0);\n\tcase 5:\n\t\tstrcpy(fp->name, AudioEulinear_le);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR_LE;\n\t\tfp->precision = 16;\n\t\tfp->flags = 0;\n\t\treturn (0);\n\tcase 6:\n\t\tstrcpy(fp->name, AudioEslinear_be);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR_BE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 7:\n\t\tstrcpy(fp->name, AudioEulinear_be);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR_BE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tdefault:\n\t\treturn EINVAL;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_query_encoding",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;",
      "int pool, flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEulinear_be"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEslinear_be"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEulinear_le"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEslinear_le"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEslinear"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEalaw"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEmulaw"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEulinear"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_query_encoding;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\nint pool, flags;\n\nint\ness_query_encoding(addr, fp)\n\tvoid *addr;\n\tstruct audio_encoding *fp;\n{\n\t/*struct ess_softc *sc = addr;*/\n\n\tswitch (fp->index) {\n\tcase 0:\n\t\tstrcpy(fp->name, AudioEulinear);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR;\n\t\tfp->precision = 8;\n\t\tfp->flags = 0;\n\t\treturn (0);\n\tcase 1:\n\t\tstrcpy(fp->name, AudioEmulaw);\n\t\tfp->encoding = AUDIO_ENCODING_ULAW;\n\t\tfp->precision = 8;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 2:\n\t\tstrcpy(fp->name, AudioEalaw);\n\t\tfp->encoding = AUDIO_ENCODING_ALAW;\n\t\tfp->precision = 8;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 3:\n\t\tstrcpy(fp->name, AudioEslinear);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR;\n\t\tfp->precision = 8;\n\t\tfp->flags = 0;\n\t\treturn (0);\n\tcase 4:\n\t\tstrcpy(fp->name, AudioEslinear_le);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR_LE;\n\t\tfp->precision = 16;\n\t\tfp->flags = 0;\n\t\treturn (0);\n\tcase 5:\n\t\tstrcpy(fp->name, AudioEulinear_le);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR_LE;\n\t\tfp->precision = 16;\n\t\tfp->flags = 0;\n\t\treturn (0);\n\tcase 6:\n\t\tstrcpy(fp->name, AudioEslinear_be);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR_BE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 7:\n\t\tstrcpy(fp->name, AudioEulinear_be);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR_BE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tdefault:\n\t\treturn EINVAL;\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "ess_getdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1114-1121",
    "snippet": "int\ness_getdev(addr, retp)\n\tvoid *addr;\n\tstruct audio_device *retp;\n{\n\t*retp = ess_device;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_getdev",
      "int\tess_getdev",
      "struct audio_device ess_device = {\n\t\"ESS Technology\",\n\t\"x\",\n\t\"ess\"\n};",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_getdev;\nint\tess_getdev;\nstruct audio_device ess_device = {\n\t\"ESS Technology\",\n\t\"x\",\n\t\"ess\"\n};\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_getdev(addr, retp)\n\tvoid *addr;\n\tstruct audio_device *retp;\n{\n\t*retp = ess_device;\n\treturn (0);\n}"
  },
  {
    "function_name": "ess_speaker_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1096-1112",
    "snippet": "int\ness_speaker_ctl(addr, newstate)\n\tvoid *addr;\n\tint newstate;\n{\n\tstruct ess_softc *sc = addr;\n\n\tif ((newstate == SPKR_ON) && (sc->spkr_state == SPKR_OFF)) {\n\t\tess_speaker_on(sc);\n\t\tsc->spkr_state = SPKR_ON;\n\t}\n\tif ((newstate == SPKR_OFF) && (sc->spkr_state == SPKR_ON)) {\n\t\tess_speaker_off(sc);\n\t\tsc->spkr_state = SPKR_OFF;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_speaker_ctl",
      "void\tess_speaker_on",
      "void\tess_speaker_off",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_speaker_off",
          "args": [
            "sc"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "ess_speaker_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2426-2433",
          "snippet": "void\ness_speaker_off(sc)\n\tstruct ess_softc *sc;\n{\n\t/* Enable mute on left- and right-master volume. */\n\tess_set_mreg_bits(sc, ESS_MREG_VOLUME_LEFT, ESS_VOLUME_MUTE);\n\tess_set_mreg_bits(sc, ESS_MREG_VOLUME_RIGHT, ESS_VOLUME_MUTE);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_speaker_off",
            "void\tess_set_mreg_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_speaker_off;\nvoid\tess_set_mreg_bits;\n\nvoid\ness_speaker_off(sc)\n\tstruct ess_softc *sc;\n{\n\t/* Enable mute on left- and right-master volume. */\n\tess_set_mreg_bits(sc, ESS_MREG_VOLUME_LEFT, ESS_VOLUME_MUTE);\n\tess_set_mreg_bits(sc, ESS_MREG_VOLUME_RIGHT, ESS_VOLUME_MUTE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_speaker_on",
          "args": [
            "sc"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "ess_speaker_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2417-2424",
          "snippet": "void\ness_speaker_on(sc)\n\tstruct ess_softc *sc;\n{\n\t/* Disable mute on left- and right-master volume. */\n\tess_clear_mreg_bits(sc, ESS_MREG_VOLUME_LEFT, ESS_VOLUME_MUTE);\n\tess_clear_mreg_bits(sc, ESS_MREG_VOLUME_RIGHT, ESS_VOLUME_MUTE);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_speaker_on",
            "void\tess_clear_mreg_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_speaker_on;\nvoid\tess_clear_mreg_bits;\n\nvoid\ness_speaker_on(sc)\n\tstruct ess_softc *sc;\n{\n\t/* Disable mute on left- and right-master volume. */\n\tess_clear_mreg_bits(sc, ESS_MREG_VOLUME_LEFT, ESS_VOLUME_MUTE);\n\tess_clear_mreg_bits(sc, ESS_MREG_VOLUME_RIGHT, ESS_VOLUME_MUTE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_speaker_ctl;\nvoid\tess_speaker_on;\nvoid\tess_speaker_off;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_speaker_ctl(addr, newstate)\n\tvoid *addr;\n\tint newstate;\n{\n\tstruct ess_softc *sc = addr;\n\n\tif ((newstate == SPKR_ON) && (sc->spkr_state == SPKR_OFF)) {\n\t\tess_speaker_on(sc);\n\t\tsc->spkr_state = SPKR_ON;\n\t}\n\tif ((newstate == SPKR_OFF) && (sc->spkr_state == SPKR_ON)) {\n\t\tess_speaker_off(sc);\n\t\tsc->spkr_state = SPKR_OFF;\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "ess_drain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1087-1093",
    "snippet": "int\ness_drain(addr)\n\tvoid *addr;\n{\n\ttsleep(addr, PWAIT | PCATCH, \"essdr\", hz/20); /* XXX */\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_drain",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "addr",
            "PWAIT | PCATCH",
            "\"essdr\"",
            "hz/20"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_drain;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_drain(addr)\n\tvoid *addr;\n{\n\ttsleep(addr, PWAIT | PCATCH, \"essdr\", hz/20); /* XXX */\n\treturn (0);\n}"
  },
  {
    "function_name": "ess_1888_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1065-1081",
    "snippet": "void\ness_1888_close(addr)\n\tvoid *addr;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTF((\"ess_1888_close: sc=%p\\n\", sc));\n\n\tess_speaker_off(sc);\n\tsc->spkr_state = SPKR_OFF;\n\n\tess_audio1_halt(sc);\n\tess_audio2_halt(sc);\n\n\tsc->sc_open = 0;\n\tDPRINTF((\"ess_1888_close: closed\\n\"));\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tess_1888_close",
      "int\tess_audio1_halt",
      "int\tess_audio2_halt",
      "void\tess_speaker_off",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ess_1888_close: closed\\n\")"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_audio2_halt",
          "args": [
            "sc"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "ess_audio2_halt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "1521-1540",
          "snippet": "int\ness_audio2_halt(addr)\n\tvoid *addr;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTF((\"ess_audio2_halt: sc=%p\\n\", sc));\n\n\tif (sc->sc_audio2.active) {\n\t\tess_clear_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL1,\n\t\t    ESS_AUDIO2_CTRL1_DAC_ENABLE |\n\t\t    ESS_AUDIO2_CTRL1_FIFO_ENABLE);\n\t\tisa_dmaabort(sc->sc_isa, sc->sc_audio2.drq);\n\t\tif (sc->sc_audio2.polled)\n\t\t\tuntimeout(ess_audio2_poll, sc);\n\t\tsc->sc_audio2.active = 0;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_audio2_halt",
            "void\tess_audio2_poll",
            "void\tess_clear_mreg_bits",
            "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_audio2_halt;\nvoid\tess_audio2_poll;\nvoid\tess_clear_mreg_bits;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_audio2_halt(addr)\n\tvoid *addr;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTF((\"ess_audio2_halt: sc=%p\\n\", sc));\n\n\tif (sc->sc_audio2.active) {\n\t\tess_clear_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL1,\n\t\t    ESS_AUDIO2_CTRL1_DAC_ENABLE |\n\t\t    ESS_AUDIO2_CTRL1_FIFO_ENABLE);\n\t\tisa_dmaabort(sc->sc_isa, sc->sc_audio2.drq);\n\t\tif (sc->sc_audio2.polled)\n\t\t\tuntimeout(ess_audio2_poll, sc);\n\t\tsc->sc_audio2.active = 0;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_audio1_halt",
          "args": [
            "sc"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "ess_audio1_halt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "1501-1519",
          "snippet": "int\ness_audio1_halt(addr)\n\tvoid *addr;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTF((\"ess_audio1_halt: sc=%p\\n\", sc));\n\n\tif (sc->sc_audio1.active) {\n\t\tess_clear_xreg_bits(sc, ESS_XCMD_AUDIO1_CTRL2,\n\t\t    ESS_AUDIO1_CTRL2_FIFO_ENABLE);\n\t\tisa_dmaabort(sc->sc_isa, sc->sc_audio1.drq);\n\t\tif (sc->sc_audio1.polled)\n\t\t\tuntimeout(ess_audio1_poll, sc);\n\t\tsc->sc_audio1.active = 0;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_audio1_halt",
            "void\tess_audio1_poll",
            "void\tess_clear_xreg_bits",
            "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_audio1_halt;\nvoid\tess_audio1_poll;\nvoid\tess_clear_xreg_bits;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_audio1_halt(addr)\n\tvoid *addr;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTF((\"ess_audio1_halt: sc=%p\\n\", sc));\n\n\tif (sc->sc_audio1.active) {\n\t\tess_clear_xreg_bits(sc, ESS_XCMD_AUDIO1_CTRL2,\n\t\t    ESS_AUDIO1_CTRL2_FIFO_ENABLE);\n\t\tisa_dmaabort(sc->sc_isa, sc->sc_audio1.drq);\n\t\tif (sc->sc_audio1.polled)\n\t\t\tuntimeout(ess_audio1_poll, sc);\n\t\tsc->sc_audio1.active = 0;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_speaker_off",
          "args": [
            "sc"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "ess_speaker_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2426-2433",
          "snippet": "void\ness_speaker_off(sc)\n\tstruct ess_softc *sc;\n{\n\t/* Enable mute on left- and right-master volume. */\n\tess_set_mreg_bits(sc, ESS_MREG_VOLUME_LEFT, ESS_VOLUME_MUTE);\n\tess_set_mreg_bits(sc, ESS_MREG_VOLUME_RIGHT, ESS_VOLUME_MUTE);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_speaker_off",
            "void\tess_set_mreg_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_speaker_off;\nvoid\tess_set_mreg_bits;\n\nvoid\ness_speaker_off(sc)\n\tstruct ess_softc *sc;\n{\n\t/* Enable mute on left- and right-master volume. */\n\tess_set_mreg_bits(sc, ESS_MREG_VOLUME_LEFT, ESS_VOLUME_MUTE);\n\tess_set_mreg_bits(sc, ESS_MREG_VOLUME_RIGHT, ESS_VOLUME_MUTE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ess_1888_close: sc=%p\\n\", sc)"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_1888_close;\nint\tess_audio1_halt;\nint\tess_audio2_halt;\nvoid\tess_speaker_off;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nvoid\ness_1888_close(addr)\n\tvoid *addr;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTF((\"ess_1888_close: sc=%p\\n\", sc));\n\n\tess_speaker_off(sc);\n\tsc->spkr_state = SPKR_OFF;\n\n\tess_audio1_halt(sc);\n\tess_audio2_halt(sc);\n\n\tsc->sc_open = 0;\n\tDPRINTF((\"ess_1888_close: closed\\n\"));\n}"
  },
  {
    "function_name": "ess_1788_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1048-1063",
    "snippet": "void\ness_1788_close(addr)\n\tvoid *addr;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTF((\"ess_1788_close: sc=%p\\n\", sc));\n\n\tess_speaker_off(sc);\n\tsc->spkr_state = SPKR_OFF;\n\n\tess_audio1_halt(sc);\n\n\tsc->sc_open = 0;\n\tDPRINTF((\"ess_1788_close: closed\\n\"));\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tess_1788_close",
      "int\tess_audio1_halt",
      "void\tess_speaker_off",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ess_1788_close: closed\\n\")"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_audio1_halt",
          "args": [
            "sc"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "ess_audio1_halt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "1501-1519",
          "snippet": "int\ness_audio1_halt(addr)\n\tvoid *addr;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTF((\"ess_audio1_halt: sc=%p\\n\", sc));\n\n\tif (sc->sc_audio1.active) {\n\t\tess_clear_xreg_bits(sc, ESS_XCMD_AUDIO1_CTRL2,\n\t\t    ESS_AUDIO1_CTRL2_FIFO_ENABLE);\n\t\tisa_dmaabort(sc->sc_isa, sc->sc_audio1.drq);\n\t\tif (sc->sc_audio1.polled)\n\t\t\tuntimeout(ess_audio1_poll, sc);\n\t\tsc->sc_audio1.active = 0;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_audio1_halt",
            "void\tess_audio1_poll",
            "void\tess_clear_xreg_bits",
            "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_audio1_halt;\nvoid\tess_audio1_poll;\nvoid\tess_clear_xreg_bits;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_audio1_halt(addr)\n\tvoid *addr;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTF((\"ess_audio1_halt: sc=%p\\n\", sc));\n\n\tif (sc->sc_audio1.active) {\n\t\tess_clear_xreg_bits(sc, ESS_XCMD_AUDIO1_CTRL2,\n\t\t    ESS_AUDIO1_CTRL2_FIFO_ENABLE);\n\t\tisa_dmaabort(sc->sc_isa, sc->sc_audio1.drq);\n\t\tif (sc->sc_audio1.polled)\n\t\t\tuntimeout(ess_audio1_poll, sc);\n\t\tsc->sc_audio1.active = 0;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_speaker_off",
          "args": [
            "sc"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "ess_speaker_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2426-2433",
          "snippet": "void\ness_speaker_off(sc)\n\tstruct ess_softc *sc;\n{\n\t/* Enable mute on left- and right-master volume. */\n\tess_set_mreg_bits(sc, ESS_MREG_VOLUME_LEFT, ESS_VOLUME_MUTE);\n\tess_set_mreg_bits(sc, ESS_MREG_VOLUME_RIGHT, ESS_VOLUME_MUTE);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_speaker_off",
            "void\tess_set_mreg_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_speaker_off;\nvoid\tess_set_mreg_bits;\n\nvoid\ness_speaker_off(sc)\n\tstruct ess_softc *sc;\n{\n\t/* Enable mute on left- and right-master volume. */\n\tess_set_mreg_bits(sc, ESS_MREG_VOLUME_LEFT, ESS_VOLUME_MUTE);\n\tess_set_mreg_bits(sc, ESS_MREG_VOLUME_RIGHT, ESS_VOLUME_MUTE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ess_1788_close: sc=%p\\n\", sc)"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_1788_close;\nint\tess_audio1_halt;\nvoid\tess_speaker_off;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nvoid\ness_1788_close(addr)\n\tvoid *addr;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTF((\"ess_1788_close: sc=%p\\n\", sc));\n\n\tess_speaker_off(sc);\n\tsc->spkr_state = SPKR_OFF;\n\n\tess_audio1_halt(sc);\n\n\tsc->sc_open = 0;\n\tDPRINTF((\"ess_1788_close: closed\\n\"));\n}"
  },
  {
    "function_name": "ess_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "1027-1046",
    "snippet": "int\ness_open(addr, flags)\n\tvoid *addr;\n\tint flags;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTF((\"ess_open: sc=%p\\n\", sc));\n    \n\tif (sc->sc_open != 0 || ess_reset(sc) != 0)\n\t\treturn ENXIO;\n\n\tess_setup(sc);\t\t/* because we did a reset */\n\n\tsc->sc_open = 1;\n\n\tDPRINTF((\"ess_open: opened\\n\"));\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_open",
      "void\tess_setup",
      "int\tess_reset",
      "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;",
      "int pool, flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ess_open: opened\\n\")"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_setup",
          "args": [
            "sc"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "ess_setup_sc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "778-796",
          "snippet": "int\ness_setup_sc(sc, doinit)\n\tstruct ess_softc *sc;\n\tint doinit;\n{\n\t/* Reset the chip. */\n\tif (ess_reset(sc) != 0) {\n\t\tDPRINTF((\"ess_setup_sc: couldn't reset chip\\n\"));\n\t\treturn (1);\n\t}\n\n\t/* Identify the ESS chip, and check that it is supported. */\n\tif (ess_identify(sc)) {\n\t\tDPRINTF((\"ess_setup_sc: couldn't identify\\n\"));\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_setup_sc",
            "int\tess_identify",
            "int\tess_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_setup_sc;\nint\tess_identify;\nint\tess_reset;\n\nint\ness_setup_sc(sc, doinit)\n\tstruct ess_softc *sc;\n\tint doinit;\n{\n\t/* Reset the chip. */\n\tif (ess_reset(sc) != 0) {\n\t\tDPRINTF((\"ess_setup_sc: couldn't reset chip\\n\"));\n\t\treturn (1);\n\t}\n\n\t/* Identify the ESS chip, and check that it is supported. */\n\tif (ess_identify(sc)) {\n\t\tDPRINTF((\"ess_setup_sc: couldn't identify\\n\"));\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_reset",
          "args": [
            "sc"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "ess_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2225-2245",
          "snippet": "int\ness_reset(sc)\n\tstruct ess_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tsc->sc_audio1.active = 0;\n\tsc->sc_audio2.active = 0;\n\n\tEWRITE1(iot, ioh, ESS_DSP_RESET, ESS_RESET_EXT);\n\tdelay(10000);\n\tEWRITE1(iot, ioh, ESS_DSP_RESET, 0);\n\tif (ess_rdsp(sc) != ESS_MAGIC)\n\t\treturn (1);\n\n\t/* Enable access to the ESS extension commands. */\n\tess_wdsp(sc, ESS_ACMD_ENABLE_EXT);\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_reset",
            "int\tess_rdsp",
            "int\tess_wdsp"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_reset;\nint\tess_rdsp;\nint\tess_wdsp;\n\nint\ness_reset(sc)\n\tstruct ess_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tsc->sc_audio1.active = 0;\n\tsc->sc_audio2.active = 0;\n\n\tEWRITE1(iot, ioh, ESS_DSP_RESET, ESS_RESET_EXT);\n\tdelay(10000);\n\tEWRITE1(iot, ioh, ESS_DSP_RESET, 0);\n\tif (ess_rdsp(sc) != ESS_MAGIC)\n\t\treturn (1);\n\n\t/* Enable access to the ESS extension commands. */\n\tess_wdsp(sc, ESS_ACMD_ENABLE_EXT);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ess_open: sc=%p\\n\", sc)"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_open;\nvoid\tess_setup;\nint\tess_reset;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\nint pool, flags;\n\nint\ness_open(addr, flags)\n\tvoid *addr;\n\tint flags;\n{\n\tstruct ess_softc *sc = addr;\n\n\tDPRINTF((\"ess_open: sc=%p\\n\", sc));\n    \n\tif (sc->sc_open != 0 || ess_reset(sc) != 0)\n\t\treturn ENXIO;\n\n\tess_setup(sc);\t\t/* because we did a reset */\n\n\tsc->sc_open = 1;\n\n\tDPRINTF((\"ess_open: opened\\n\"));\n\n\treturn (0);\n}"
  },
  {
    "function_name": "essattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "884-1021",
    "snippet": "void\nessattach(sc)\n\tstruct ess_softc *sc;\n{\n\tstruct audio_attach_args arg;\n\tstruct audio_params pparams, rparams;\n\tint i;\n\tu_int v;\n\n\tif (ess_setup_sc(sc, 0)) {\n\t\tprintf(\": setup failed\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\": ESS Technology ES%s [version 0x%04x]\\n\", \n\t       essmodel[sc->sc_model], sc->sc_version);\n\n\tsc->sc_audio1.polled = sc->sc_audio1.irq == -1;\n\tif (!sc->sc_audio1.polled) {\n\t\tsc->sc_audio1.ih = isa_intr_establish(sc->sc_ic,\n\t\t    sc->sc_audio1.irq, sc->sc_audio1.ist, IPL_AUDIO,\n\t\t    ess_audio1_intr, sc, sc->sc_dev.dv_xname);\n\t\tprintf(\"%s: audio1 interrupting at irq %d\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->sc_audio1.irq);\n\t} else\n\t\tprintf(\"%s: audio1 polled\\n\", sc->sc_dev.dv_xname);\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_audio1.drq,\n\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t       sc->sc_dev.dv_xname, sc->sc_audio1.drq);\n\t\treturn;\n\t}\n\n\tif (!ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tsc->sc_audio2.polled = sc->sc_audio2.irq == -1;\n\t\tif (!sc->sc_audio2.polled) {\n\t\t\tsc->sc_audio2.ih = isa_intr_establish(sc->sc_ic,\n\t\t\t    sc->sc_audio2.irq, sc->sc_audio2.ist, IPL_AUDIO,\n\t\t\t    ess_audio2_intr, sc, sc->sc_dev.dv_xname);\n\t\t\tprintf(\"%s: audio2 interrupting at irq %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sc->sc_audio2.irq);\n\t\t} else\n\t\t\tprintf(\"%s: audio2 polled\\n\", sc->sc_dev.dv_xname);\n\t\tif (isa_dmamap_create(sc->sc_isa, sc->sc_audio2.drq,\n\t\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t\t       sc->sc_dev.dv_xname, sc->sc_audio2.drq);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* \n\t * Set record and play parameters to default values defined in\n\t * generic audio driver.\n\t */\n\tpparams = audio_default;\n\trparams = audio_default;\n\tess_set_params(sc, AUMODE_RECORD|AUMODE_PLAY, 0, &pparams, &rparams);\n\n\t/* Do a hardware reset on the mixer. */\n\tess_write_mix_reg(sc, ESS_MIX_RESET, ESS_MIX_RESET);\n\n\t/*\n\t * Set volume of Audio 1 to zero and disable Audio 1 DAC input\n\t * to playback mixer, since playback is always through Audio 2.\n\t */\n\tif (!ESS_USE_AUDIO1(sc->sc_model))\n\t\tess_write_mix_reg(sc, ESS_MREG_VOLUME_VOICE, 0);\n\tess_wdsp(sc, ESS_ACMD_DISABLE_SPKR);\n\n\tif (ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tess_write_mix_reg(sc, ESS_MREG_ADC_SOURCE, ESS_SOURCE_MIC);\n\t\tsc->in_port = ESS_SOURCE_MIC;\n\t\tsc->ndevs = ESS_1788_NDEVS;\n\t} else {\n\t\t/*\n\t\t * Set hardware record source to use output of the record\n\t\t * mixer. We do the selection of record source in software by\n\t\t * setting the gain of the unused sources to zero. (See\n\t\t * ess_set_in_ports.)\n\t\t */\n\t\tess_write_mix_reg(sc, ESS_MREG_ADC_SOURCE, ESS_SOURCE_MIXER);\n\t\tsc->in_mask = 1 << ESS_MIC_REC_VOL;\n\t\tsc->ndevs = ESS_1888_NDEVS;\n\t\tess_clear_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, 0x10);\n\t\tess_set_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, 0x08);\n\t}\n\n\t/*\n\t * Set gain on each mixer device to a sensible value.\n\t * Devices not normally used are turned off, and other devices\n\t * are set to 50% volume.\n\t */\n\tfor (i = 0; i < sc->ndevs; i++) {\n\t\tswitch (i) {\n\t\tcase ESS_MIC_PLAY_VOL:\n\t\tcase ESS_LINE_PLAY_VOL:\n\t\tcase ESS_CD_PLAY_VOL:\n\t\tcase ESS_AUXB_PLAY_VOL:\n\t\tcase ESS_DAC_REC_VOL:\n\t\tcase ESS_LINE_REC_VOL:\n\t\tcase ESS_SYNTH_REC_VOL:\n\t\tcase ESS_CD_REC_VOL:\n\t\tcase ESS_AUXB_REC_VOL:\n\t\t\tv = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tv = ESS_4BIT_GAIN(AUDIO_MAX_GAIN / 2);\n\t\t\tbreak;\n\t\t}\n\t\tsc->gain[i][ESS_LEFT] = sc->gain[i][ESS_RIGHT] = v;\n\t\tess_set_gain(sc, i, 1);\n\t}\n\n\tess_setup(sc);\n\n\t/* Disable the speaker until the device is opened.  */\n\tess_speaker_off(sc);\n\tsc->spkr_state = SPKR_OFF;\n\n\tsprintf(ess_device.name, \"ES%s\", essmodel[sc->sc_model]);\n\tsprintf(ess_device.version, \"0x%04x\", sc->sc_version);\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\taudio_attach_mi(&ess_1788_hw_if, sc, &sc->sc_dev);\n\telse\n\t\taudio_attach_mi(&ess_1888_hw_if, sc, &sc->sc_dev);\n\n\targ.type = AUDIODEV_TYPE_OPL;\n\targ.hwif = 0;\n\targ.hdl = 0;\n\t(void)config_found(&sc->sc_dev, &arg, audioprint);\n\n#ifdef AUDIO_DEBUG\n\tif (essdebug > 0)\n\t\tess_printsc(sc);\n#endif\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_setup_sc",
      "int\tess_set_params",
      "int\tess_audio1_intr",
      "int\tess_audio2_intr",
      "void\tess_speaker_off",
      "void\tess_setup",
      "void\tess_set_gain",
      "int\tess_set_in_ports",
      "int\tess_wdsp",
      "void\tess_write_mix_reg",
      "void\tess_clear_mreg_bits",
      "void\tess_set_mreg_bits",
      "static char *essmodel[] = {\n\t\"unsupported\",\n\t\"1888\",\n\t\"1887\",\n\t\"888\",\n\t\"1788\",\n\t\"1869\",\n\t\"1879\",\n\t\"1868\",\n\t\"1878\",\n};",
      "struct audio_device ess_device = {\n\t\"ESS Technology\",\n\t\"x\",\n\t\"ess\"\n};",
      "struct audio_hw_if ess_1788_hw_if = {\n\tess_open,\n\tess_1788_close,\n\tess_drain,\n\tess_query_encoding,\n\tess_set_params,\n\tess_round_blocksize,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tess_audio1_halt,\n\tess_audio1_halt,\n\tess_speaker_ctl,\n\tess_getdev,\n\tNULL,\n\tess_set_port,\n\tess_get_port,\n\tess_query_devinfo,\n\tess_malloc,\n\tess_free,\n\tess_round_buffersize,\n\tess_mappage,\n\tess_1788_get_props,\n\tess_audio1_trigger_output,\n\tess_audio1_trigger_input,\n};",
      "struct audio_hw_if ess_1888_hw_if = {\n\tess_open,\n\tess_1888_close,\n\tess_drain,\n\tess_query_encoding,\n\tess_set_params,\n\tess_round_blocksize,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tess_audio2_halt,\n\tess_audio1_halt,\n\tess_speaker_ctl,\n\tess_getdev,\n\tNULL,\n\tess_set_port,\n\tess_get_port,\n\tess_query_devinfo,\n\tess_malloc,\n\tess_free,\n\tess_round_buffersize,\n\tess_mappage,\n\tess_1888_get_props,\n\tess_audio2_trigger_output,\n\tess_audio1_trigger_input,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_printsc",
          "args": [
            "sc"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "ess_printsc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "274-298",
          "snippet": "void\ness_printsc(sc)\n\tstruct ess_softc *sc;\n{\n\tint i;\n    \n\tprintf(\"open %d iobase 0x%x outport %u inport %u speaker %s\\n\",\n\t       (int)sc->sc_open, sc->sc_iobase, sc->out_port,\n\t       sc->in_port, sc->spkr_state ? \"on\" : \"off\");\n\n\tprintf(\"audio1: dmachan %d irq %d nintr %lu intr %p arg %p\\n\",\n\t       sc->sc_audio1.drq, sc->sc_audio1.irq, sc->sc_audio1.nintr,\n\t       sc->sc_audio1.intr, sc->sc_audio1.arg);\n\n\tif (!ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tprintf(\"audio2: dmachan %d irq %d nintr %lu intr %p arg %p\\n\",\n\t\t       sc->sc_audio2.drq, sc->sc_audio2.irq, sc->sc_audio2.nintr,\n\t\t       sc->sc_audio2.intr, sc->sc_audio2.arg);\n\t}\n\n\tprintf(\"gain:\");\n\tfor (i = 0; i < sc->ndevs; i++)\n\t\tprintf(\" %u,%u\", sc->gain[i][ESS_LEFT], sc->gain[i][ESS_RIGHT]);\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ness_printsc(sc)\n\tstruct ess_softc *sc;\n{\n\tint i;\n    \n\tprintf(\"open %d iobase 0x%x outport %u inport %u speaker %s\\n\",\n\t       (int)sc->sc_open, sc->sc_iobase, sc->out_port,\n\t       sc->in_port, sc->spkr_state ? \"on\" : \"off\");\n\n\tprintf(\"audio1: dmachan %d irq %d nintr %lu intr %p arg %p\\n\",\n\t       sc->sc_audio1.drq, sc->sc_audio1.irq, sc->sc_audio1.nintr,\n\t       sc->sc_audio1.intr, sc->sc_audio1.arg);\n\n\tif (!ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tprintf(\"audio2: dmachan %d irq %d nintr %lu intr %p arg %p\\n\",\n\t\t       sc->sc_audio2.drq, sc->sc_audio2.irq, sc->sc_audio2.nintr,\n\t\t       sc->sc_audio2.intr, sc->sc_audio2.arg);\n\t}\n\n\tprintf(\"gain:\");\n\tfor (i = 0; i < sc->ndevs; i++)\n\t\tprintf(\" %u,%u\", sc->gain[i][ESS_LEFT], sc->gain[i][ESS_RIGHT]);\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "&sc->sc_dev",
            "&arg",
            "audioprint"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_attach_mi",
          "args": [
            "&ess_1888_hw_if",
            "sc",
            "&sc->sc_dev"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "audio_attach_mi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "394-408",
          "snippet": "void\naudio_attach_mi(ahwp, hdlp, dev)\n\tstruct audio_hw_if *ahwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n\tif (ahwp != NULL) {\n\t\targ.type = AUDIODEV_TYPE_AUDIO;\n\t\targ.hwif = ahwp;\n\t\targ.hdl = hdlp;\n\t\t(void)config_found(dev, &arg, audioprint);\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_attach_mi(ahwp, hdlp, dev)\n\tstruct audio_hw_if *ahwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n\tif (ahwp != NULL) {\n\t\targ.type = AUDIODEV_TYPE_AUDIO;\n\t\targ.hwif = ahwp;\n\t\targ.hdl = hdlp;\n\t\t(void)config_found(dev, &arg, audioprint);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESS_USE_AUDIO1",
          "args": [
            "sc->sc_model"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ess_device.version",
            "\"0x%04x\"",
            "sc->sc_version"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ess_device.name",
            "\"ES%s\"",
            "essmodel[sc->sc_model]"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_speaker_off",
          "args": [
            "sc"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "ess_speaker_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2426-2433",
          "snippet": "void\ness_speaker_off(sc)\n\tstruct ess_softc *sc;\n{\n\t/* Enable mute on left- and right-master volume. */\n\tess_set_mreg_bits(sc, ESS_MREG_VOLUME_LEFT, ESS_VOLUME_MUTE);\n\tess_set_mreg_bits(sc, ESS_MREG_VOLUME_RIGHT, ESS_VOLUME_MUTE);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_speaker_off",
            "void\tess_set_mreg_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_speaker_off;\nvoid\tess_set_mreg_bits;\n\nvoid\ness_speaker_off(sc)\n\tstruct ess_softc *sc;\n{\n\t/* Enable mute on left- and right-master volume. */\n\tess_set_mreg_bits(sc, ESS_MREG_VOLUME_LEFT, ESS_VOLUME_MUTE);\n\tess_set_mreg_bits(sc, ESS_MREG_VOLUME_RIGHT, ESS_VOLUME_MUTE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_setup",
          "args": [
            "sc"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "ess_setup_sc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "778-796",
          "snippet": "int\ness_setup_sc(sc, doinit)\n\tstruct ess_softc *sc;\n\tint doinit;\n{\n\t/* Reset the chip. */\n\tif (ess_reset(sc) != 0) {\n\t\tDPRINTF((\"ess_setup_sc: couldn't reset chip\\n\"));\n\t\treturn (1);\n\t}\n\n\t/* Identify the ESS chip, and check that it is supported. */\n\tif (ess_identify(sc)) {\n\t\tDPRINTF((\"ess_setup_sc: couldn't identify\\n\"));\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_setup_sc",
            "int\tess_identify",
            "int\tess_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_setup_sc;\nint\tess_identify;\nint\tess_reset;\n\nint\ness_setup_sc(sc, doinit)\n\tstruct ess_softc *sc;\n\tint doinit;\n{\n\t/* Reset the chip. */\n\tif (ess_reset(sc) != 0) {\n\t\tDPRINTF((\"ess_setup_sc: couldn't reset chip\\n\"));\n\t\treturn (1);\n\t}\n\n\t/* Identify the ESS chip, and check that it is supported. */\n\tif (ess_identify(sc)) {\n\t\tDPRINTF((\"ess_setup_sc: couldn't identify\\n\"));\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_set_gain",
          "args": [
            "sc",
            "i",
            "1"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "ess_set_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2247-2341",
          "snippet": "void\ness_set_gain(sc, port, on)\n\tstruct ess_softc *sc;\n\tint port;\n\tint on;\n{\n\tint gain, left, right;\n\tint mix;\n\tint src;\n\tint stereo;\n\n\t/*\n\t * Most gain controls are found in the mixer registers and\n\t * are stereo. Any that are not, must set mix and stereo as\n\t * required.\n\t */\n\tmix = 1;\n\tstereo = 1;\n\n\tswitch (port) {\n\tcase ESS_MASTER_VOL:\n\t\tsrc = ESS_MREG_VOLUME_MASTER;\n\t\tbreak;\n\tcase ESS_DAC_PLAY_VOL:\n\t\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\t\tsrc = ESS_MREG_VOLUME_VOICE;\n\t\telse\n\t\t\tsrc = 0x7C;\n\t\tbreak;\n\tcase ESS_MIC_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_MIC;\n\t\tbreak;\n\tcase ESS_LINE_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_LINE;\n\t\tbreak;\n\tcase ESS_SYNTH_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_SYNTH;\n\t\tbreak;\n\tcase ESS_CD_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_CD;\n\t\tbreak;\n\tcase ESS_AUXB_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_AUXB;\n\t\tbreak;\n\tcase ESS_PCSPEAKER_VOL:\n\t\tsrc = ESS_MREG_VOLUME_PCSPKR;\n\t\tstereo = 0;\n\t\tbreak;\n\tcase ESS_DAC_REC_VOL:\n\t\tsrc = 0x69;\n\t\tbreak;\n\tcase ESS_MIC_REC_VOL:\n\t\tsrc = 0x68;\n\t\tbreak;\n\tcase ESS_LINE_REC_VOL:\n\t\tsrc = 0x6E;\n\t\tbreak;\n\tcase ESS_SYNTH_REC_VOL:\n\t\tsrc = 0x6B;\n\t\tbreak;\n\tcase ESS_CD_REC_VOL:\n\t\tsrc = 0x6A;\n\t\tbreak;\n\tcase ESS_AUXB_REC_VOL:\n\t\tsrc = 0x6C;\n\t\tbreak;\n\tcase ESS_RECORD_VOL:\n\t\tsrc = ESS_XCMD_VOLIN_CTRL;\n\t\tmix = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t/* 1788 doesn't have a separate recording mixer */\n\tif (ESS_USE_AUDIO1(sc->sc_model) && mix && src > 0x62)\n\t\treturn;\n\n\tif (on) {\n\t\tleft = sc->gain[port][ESS_LEFT];\n\t\tright = sc->gain[port][ESS_RIGHT];\n\t} else {\n\t\tleft = right = 0;\n\t}\n\n\tif (stereo)\n\t\tgain = ESS_STEREO_GAIN(left, right);\n\telse\n\t\tgain = ESS_MONO_GAIN(left);\n\n\tif (mix)\n\t\tess_write_mix_reg(sc, src, gain);\n\telse\n\t\tess_write_x_reg(sc, src, gain);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_set_gain",
            "int\tess_write_x_reg",
            "void\tess_write_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_set_gain;\nint\tess_write_x_reg;\nvoid\tess_write_mix_reg;\n\nvoid\ness_set_gain(sc, port, on)\n\tstruct ess_softc *sc;\n\tint port;\n\tint on;\n{\n\tint gain, left, right;\n\tint mix;\n\tint src;\n\tint stereo;\n\n\t/*\n\t * Most gain controls are found in the mixer registers and\n\t * are stereo. Any that are not, must set mix and stereo as\n\t * required.\n\t */\n\tmix = 1;\n\tstereo = 1;\n\n\tswitch (port) {\n\tcase ESS_MASTER_VOL:\n\t\tsrc = ESS_MREG_VOLUME_MASTER;\n\t\tbreak;\n\tcase ESS_DAC_PLAY_VOL:\n\t\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\t\tsrc = ESS_MREG_VOLUME_VOICE;\n\t\telse\n\t\t\tsrc = 0x7C;\n\t\tbreak;\n\tcase ESS_MIC_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_MIC;\n\t\tbreak;\n\tcase ESS_LINE_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_LINE;\n\t\tbreak;\n\tcase ESS_SYNTH_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_SYNTH;\n\t\tbreak;\n\tcase ESS_CD_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_CD;\n\t\tbreak;\n\tcase ESS_AUXB_PLAY_VOL:\n\t\tsrc = ESS_MREG_VOLUME_AUXB;\n\t\tbreak;\n\tcase ESS_PCSPEAKER_VOL:\n\t\tsrc = ESS_MREG_VOLUME_PCSPKR;\n\t\tstereo = 0;\n\t\tbreak;\n\tcase ESS_DAC_REC_VOL:\n\t\tsrc = 0x69;\n\t\tbreak;\n\tcase ESS_MIC_REC_VOL:\n\t\tsrc = 0x68;\n\t\tbreak;\n\tcase ESS_LINE_REC_VOL:\n\t\tsrc = 0x6E;\n\t\tbreak;\n\tcase ESS_SYNTH_REC_VOL:\n\t\tsrc = 0x6B;\n\t\tbreak;\n\tcase ESS_CD_REC_VOL:\n\t\tsrc = 0x6A;\n\t\tbreak;\n\tcase ESS_AUXB_REC_VOL:\n\t\tsrc = 0x6C;\n\t\tbreak;\n\tcase ESS_RECORD_VOL:\n\t\tsrc = ESS_XCMD_VOLIN_CTRL;\n\t\tmix = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t/* 1788 doesn't have a separate recording mixer */\n\tif (ESS_USE_AUDIO1(sc->sc_model) && mix && src > 0x62)\n\t\treturn;\n\n\tif (on) {\n\t\tleft = sc->gain[port][ESS_LEFT];\n\t\tright = sc->gain[port][ESS_RIGHT];\n\t} else {\n\t\tleft = right = 0;\n\t}\n\n\tif (stereo)\n\t\tgain = ESS_STEREO_GAIN(left, right);\n\telse\n\t\tgain = ESS_MONO_GAIN(left);\n\n\tif (mix)\n\t\tess_write_mix_reg(sc, src, gain);\n\telse\n\t\tess_write_x_reg(sc, src, gain);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESS_4BIT_GAIN",
          "args": [
            "AUDIO_MAX_GAIN / 2"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_set_mreg_bits",
          "args": [
            "sc",
            "ESS_MREG_AUDIO2_CTRL2",
            "0x08"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "ess_set_mreg_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2669-2676",
          "snippet": "void\ness_set_mreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) | mask);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_read_mix_reg",
            "void\tess_write_mix_reg",
            "void\tess_set_mreg_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_mix_reg;\nvoid\tess_write_mix_reg;\nvoid\tess_set_mreg_bits;\n\nvoid\ness_set_mreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_clear_mreg_bits",
          "args": [
            "sc",
            "ESS_MREG_AUDIO2_CTRL2",
            "0x10"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "ess_clear_mreg_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2660-2667",
          "snippet": "void\ness_clear_mreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) & ~mask);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_read_mix_reg",
            "void\tess_write_mix_reg",
            "void\tess_clear_mreg_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_mix_reg;\nvoid\tess_write_mix_reg;\nvoid\tess_clear_mreg_bits;\n\nvoid\ness_clear_mreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_write_mix_reg",
          "args": [
            "sc",
            "ESS_MREG_ADC_SOURCE",
            "ESS_SOURCE_MIXER"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "ess_write_mix_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2620-2636",
          "snippet": "void\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_write_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_write_mix_reg;\n\nvoid\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESS_USE_AUDIO1",
          "args": [
            "sc->sc_model"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_wdsp",
          "args": [
            "sc",
            "ESS_ACMD_DISABLE_SPKR"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "ess_wdsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2532-2553",
          "snippet": "int\ness_wdsp(sc, v)\n\tstruct ess_softc *sc;\n\tu_char v;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tDPRINTFN(8,(\"ess_wdsp(0x%02x)\\n\", v));\n\n\tfor (i = ESS_WRITE_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_write_ready(sc)) {\n\t\t\tEWRITE1(iot, ioh, ESS_DSP_WRITE, v);\n\t\t\treturn (0);\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_wdsp(0x%02x): timed out\\n\", v));\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_dsp_write_ready",
            "int\tess_wdsp"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_dsp_write_ready;\nint\tess_wdsp;\n\nint\ness_wdsp(sc, v)\n\tstruct ess_softc *sc;\n\tu_char v;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tDPRINTFN(8,(\"ess_wdsp(0x%02x)\\n\", v));\n\n\tfor (i = ESS_WRITE_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_write_ready(sc)) {\n\t\t\tEWRITE1(iot, ioh, ESS_DSP_WRITE, v);\n\t\t\treturn (0);\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_wdsp(0x%02x): timed out\\n\", v));\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESS_USE_AUDIO1",
          "args": [
            "sc->sc_model"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_set_params",
          "args": [
            "sc",
            "AUMODE_RECORD|AUMODE_PLAY",
            "0",
            "&pparams",
            "&rparams"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "ess_set_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "1185-1274",
          "snippet": "int\ness_set_params(addr, setmode, usemode, play, rec)\n\tvoid *addr;\n\tint setmode, usemode;\n\tstruct audio_params *play, *rec;\n{\n\tstruct ess_softc *sc = addr;\n\tstruct audio_params *p;\n\tint mode;\n\tint rate;\n\n\tDPRINTF((\"ess_set_params: set=%d use=%d\\n\", setmode, usemode));\n\n\t/*\n\t * The ES1887 manual (page 39, `Full-Duplex DMA Mode') claims that in\n\t * full-duplex operation the sample rates must be the same for both\n\t * channels.  This appears to be false; the only bit in common is the\n\t * clock source selection.  However, we'll be conservative here.\n\t * - mycroft\n\t */\n\tif (play->sample_rate != rec->sample_rate &&\n\t    usemode == (AUMODE_PLAY | AUMODE_RECORD)) {\n\t\tif (setmode == AUMODE_PLAY) {\n\t\t\trec->sample_rate = play->sample_rate;\n\t\t\tsetmode |= AUMODE_RECORD;\n\t\t} else if (setmode == AUMODE_RECORD) {\n\t\t\tplay->sample_rate = rec->sample_rate;\n\t\t\tsetmode |= AUMODE_PLAY;\n\t\t} else\n\t\t\treturn (EINVAL);\n\t}\n\n\tfor (mode = AUMODE_RECORD; mode != -1; \n\t     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {\n\t\tif ((setmode & mode) == 0)\n\t\t\tcontinue;\n\n\t\tp = mode == AUMODE_PLAY ? play : rec;\n\n\t\tif (p->sample_rate < ESS_MINRATE ||\n\t\t    p->sample_rate > ESS_MAXRATE ||\n\t\t    (p->precision != 8 && p->precision != 16) ||\n\t\t    (p->channels != 1 && p->channels != 2))\n\t\t\treturn (EINVAL);\n\n\t\tp->factor = 1;\n\t\tp->sw_code = 0;\n\t\tswitch (p->encoding) {\n\t\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\t\tif (p->precision == 16)\n\t\t\t\tp->sw_code = swap_bytes;\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_SLINEAR_LE:\n\t\tcase AUDIO_ENCODING_ULINEAR_LE:\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_ULAW:\n\t\t\tif (mode == AUMODE_PLAY) {\n\t\t\t\tp->factor = 2;\n\t\t\t\tp->sw_code = mulaw_to_ulinear16;\n\t\t\t} else\n\t\t\t\tp->sw_code = ulinear8_to_mulaw;\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_ALAW:\n\t\t\tif (mode == AUMODE_PLAY) {\n\t\t\t\tp->factor = 2;\n\t\t\t\tp->sw_code = alaw_to_ulinear16;\n\t\t\t} else\n\t\t\t\tp->sw_code = ulinear8_to_alaw;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\t}\n\n\tif (usemode == AUMODE_RECORD)\n\t\trate = rec->sample_rate;\n\telse\n\t\trate = play->sample_rate;\n\n\tess_write_x_reg(sc, ESS_XCMD_SAMPLE_RATE, ess_srtotc(rate));\n\tess_write_x_reg(sc, ESS_XCMD_FILTER_CLOCK, ess_srtofc(rate));\n\n\tif (!ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tess_write_mix_reg(sc, ESS_MREG_SAMPLE_RATE, ess_srtotc(rate));\n\t\tess_write_mix_reg(sc, ESS_MREG_FILTER_CLOCK, ess_srtofc(rate));\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_set_params",
            "u_int\tess_srtotc",
            "u_int\tess_srtofc",
            "int\tess_write_x_reg",
            "void\tess_write_mix_reg",
            "void *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_set_params;\nu_int\tess_srtotc;\nu_int\tess_srtofc;\nint\tess_write_x_reg;\nvoid\tess_write_mix_reg;\nvoid *\ness_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\ness_set_params(addr, setmode, usemode, play, rec)\n\tvoid *addr;\n\tint setmode, usemode;\n\tstruct audio_params *play, *rec;\n{\n\tstruct ess_softc *sc = addr;\n\tstruct audio_params *p;\n\tint mode;\n\tint rate;\n\n\tDPRINTF((\"ess_set_params: set=%d use=%d\\n\", setmode, usemode));\n\n\t/*\n\t * The ES1887 manual (page 39, `Full-Duplex DMA Mode') claims that in\n\t * full-duplex operation the sample rates must be the same for both\n\t * channels.  This appears to be false; the only bit in common is the\n\t * clock source selection.  However, we'll be conservative here.\n\t * - mycroft\n\t */\n\tif (play->sample_rate != rec->sample_rate &&\n\t    usemode == (AUMODE_PLAY | AUMODE_RECORD)) {\n\t\tif (setmode == AUMODE_PLAY) {\n\t\t\trec->sample_rate = play->sample_rate;\n\t\t\tsetmode |= AUMODE_RECORD;\n\t\t} else if (setmode == AUMODE_RECORD) {\n\t\t\tplay->sample_rate = rec->sample_rate;\n\t\t\tsetmode |= AUMODE_PLAY;\n\t\t} else\n\t\t\treturn (EINVAL);\n\t}\n\n\tfor (mode = AUMODE_RECORD; mode != -1; \n\t     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {\n\t\tif ((setmode & mode) == 0)\n\t\t\tcontinue;\n\n\t\tp = mode == AUMODE_PLAY ? play : rec;\n\n\t\tif (p->sample_rate < ESS_MINRATE ||\n\t\t    p->sample_rate > ESS_MAXRATE ||\n\t\t    (p->precision != 8 && p->precision != 16) ||\n\t\t    (p->channels != 1 && p->channels != 2))\n\t\t\treturn (EINVAL);\n\n\t\tp->factor = 1;\n\t\tp->sw_code = 0;\n\t\tswitch (p->encoding) {\n\t\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\t\tif (p->precision == 16)\n\t\t\t\tp->sw_code = swap_bytes;\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_SLINEAR_LE:\n\t\tcase AUDIO_ENCODING_ULINEAR_LE:\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_ULAW:\n\t\t\tif (mode == AUMODE_PLAY) {\n\t\t\t\tp->factor = 2;\n\t\t\t\tp->sw_code = mulaw_to_ulinear16;\n\t\t\t} else\n\t\t\t\tp->sw_code = ulinear8_to_mulaw;\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_ALAW:\n\t\t\tif (mode == AUMODE_PLAY) {\n\t\t\t\tp->factor = 2;\n\t\t\t\tp->sw_code = alaw_to_ulinear16;\n\t\t\t} else\n\t\t\t\tp->sw_code = ulinear8_to_alaw;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\t}\n\n\tif (usemode == AUMODE_RECORD)\n\t\trate = rec->sample_rate;\n\telse\n\t\trate = play->sample_rate;\n\n\tess_write_x_reg(sc, ESS_XCMD_SAMPLE_RATE, ess_srtotc(rate));\n\tess_write_x_reg(sc, ESS_XCMD_FILTER_CLOCK, ess_srtofc(rate));\n\n\tif (!ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tess_write_mix_reg(sc, ESS_MREG_SAMPLE_RATE, ess_srtotc(rate));\n\t\tess_write_mix_reg(sc, ESS_MREG_FILTER_CLOCK, ess_srtofc(rate));\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: can't create map for drq %d\\n\"",
            "sc->sc_dev.dv_xname",
            "sc->sc_audio2.drq"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_dmamap_create",
          "args": [
            "sc->sc_isa",
            "sc->sc_audio2.drq",
            "MAX_ISADMA",
            "BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmamap_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "220-255",
          "snippet": "int\nisa_dmamap_create(isadev, chan, size, flags)\n\tstruct device *isadev;\n\tint chan;\n\tbus_size_t size;\n\tint flags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_size_t maxsize;\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n\tif (chan & 4)\n\t\tmaxsize = (1 << 17);\n\telse\n\t\tmaxsize = (1 << 16);\n\n\tif (size > maxsize)\n\t\treturn (EINVAL);\n\n\tif (ISA_DRQ_ISFREE(sc, chan) == 0) {\n\t\tprintf(\"%s: drq %d is not free\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n\tISA_DRQ_ALLOC(sc, chan);\n\n\treturn (bus_dmamap_create(sc->sc_dmat, size, 1, size, maxsize,\n\t    flags, &sc->sc_dmamaps[chan]));\n\n lose:\n\tpanic(\"isa_dmamap_create\");\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;",
            "size_t size;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\nsize_t size;\nint flags;\n\nint\nisa_dmamap_create(isadev, chan, size, flags)\n\tstruct device *isadev;\n\tint chan;\n\tbus_size_t size;\n\tint flags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_size_t maxsize;\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n\tif (chan & 4)\n\t\tmaxsize = (1 << 17);\n\telse\n\t\tmaxsize = (1 << 16);\n\n\tif (size > maxsize)\n\t\treturn (EINVAL);\n\n\tif (ISA_DRQ_ISFREE(sc, chan) == 0) {\n\t\tprintf(\"%s: drq %d is not free\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n\tISA_DRQ_ALLOC(sc, chan);\n\n\treturn (bus_dmamap_create(sc->sc_dmat, size, 1, size, maxsize,\n\t    flags, &sc->sc_dmamaps[chan]));\n\n lose:\n\tpanic(\"isa_dmamap_create\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "sc->sc_ic",
            "sc->sc_audio2.irq",
            "sc->sc_audio2.ist",
            "IPL_AUDIO",
            "ess_audio2_intr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESS_USE_AUDIO1",
          "args": [
            "sc->sc_model"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "sc->sc_ic",
            "sc->sc_audio1.irq",
            "sc->sc_audio1.ist",
            "IPL_AUDIO",
            "ess_audio1_intr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_setup_sc;\nint\tess_set_params;\nint\tess_audio1_intr;\nint\tess_audio2_intr;\nvoid\tess_speaker_off;\nvoid\tess_setup;\nvoid\tess_set_gain;\nint\tess_set_in_ports;\nint\tess_wdsp;\nvoid\tess_write_mix_reg;\nvoid\tess_clear_mreg_bits;\nvoid\tess_set_mreg_bits;\nstatic char *essmodel[] = {\n\t\"unsupported\",\n\t\"1888\",\n\t\"1887\",\n\t\"888\",\n\t\"1788\",\n\t\"1869\",\n\t\"1879\",\n\t\"1868\",\n\t\"1878\",\n};\nstruct audio_device ess_device = {\n\t\"ESS Technology\",\n\t\"x\",\n\t\"ess\"\n};\nstruct audio_hw_if ess_1788_hw_if = {\n\tess_open,\n\tess_1788_close,\n\tess_drain,\n\tess_query_encoding,\n\tess_set_params,\n\tess_round_blocksize,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tess_audio1_halt,\n\tess_audio1_halt,\n\tess_speaker_ctl,\n\tess_getdev,\n\tNULL,\n\tess_set_port,\n\tess_get_port,\n\tess_query_devinfo,\n\tess_malloc,\n\tess_free,\n\tess_round_buffersize,\n\tess_mappage,\n\tess_1788_get_props,\n\tess_audio1_trigger_output,\n\tess_audio1_trigger_input,\n};\nstruct audio_hw_if ess_1888_hw_if = {\n\tess_open,\n\tess_1888_close,\n\tess_drain,\n\tess_query_encoding,\n\tess_set_params,\n\tess_round_blocksize,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tess_audio2_halt,\n\tess_audio1_halt,\n\tess_speaker_ctl,\n\tess_getdev,\n\tNULL,\n\tess_set_port,\n\tess_get_port,\n\tess_query_devinfo,\n\tess_malloc,\n\tess_free,\n\tess_round_buffersize,\n\tess_mappage,\n\tess_1888_get_props,\n\tess_audio2_trigger_output,\n\tess_audio1_trigger_input,\n};\n\nvoid\nessattach(sc)\n\tstruct ess_softc *sc;\n{\n\tstruct audio_attach_args arg;\n\tstruct audio_params pparams, rparams;\n\tint i;\n\tu_int v;\n\n\tif (ess_setup_sc(sc, 0)) {\n\t\tprintf(\": setup failed\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\": ESS Technology ES%s [version 0x%04x]\\n\", \n\t       essmodel[sc->sc_model], sc->sc_version);\n\n\tsc->sc_audio1.polled = sc->sc_audio1.irq == -1;\n\tif (!sc->sc_audio1.polled) {\n\t\tsc->sc_audio1.ih = isa_intr_establish(sc->sc_ic,\n\t\t    sc->sc_audio1.irq, sc->sc_audio1.ist, IPL_AUDIO,\n\t\t    ess_audio1_intr, sc, sc->sc_dev.dv_xname);\n\t\tprintf(\"%s: audio1 interrupting at irq %d\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->sc_audio1.irq);\n\t} else\n\t\tprintf(\"%s: audio1 polled\\n\", sc->sc_dev.dv_xname);\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_audio1.drq,\n\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t       sc->sc_dev.dv_xname, sc->sc_audio1.drq);\n\t\treturn;\n\t}\n\n\tif (!ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tsc->sc_audio2.polled = sc->sc_audio2.irq == -1;\n\t\tif (!sc->sc_audio2.polled) {\n\t\t\tsc->sc_audio2.ih = isa_intr_establish(sc->sc_ic,\n\t\t\t    sc->sc_audio2.irq, sc->sc_audio2.ist, IPL_AUDIO,\n\t\t\t    ess_audio2_intr, sc, sc->sc_dev.dv_xname);\n\t\t\tprintf(\"%s: audio2 interrupting at irq %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sc->sc_audio2.irq);\n\t\t} else\n\t\t\tprintf(\"%s: audio2 polled\\n\", sc->sc_dev.dv_xname);\n\t\tif (isa_dmamap_create(sc->sc_isa, sc->sc_audio2.drq,\n\t\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t\t       sc->sc_dev.dv_xname, sc->sc_audio2.drq);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* \n\t * Set record and play parameters to default values defined in\n\t * generic audio driver.\n\t */\n\tpparams = audio_default;\n\trparams = audio_default;\n\tess_set_params(sc, AUMODE_RECORD|AUMODE_PLAY, 0, &pparams, &rparams);\n\n\t/* Do a hardware reset on the mixer. */\n\tess_write_mix_reg(sc, ESS_MIX_RESET, ESS_MIX_RESET);\n\n\t/*\n\t * Set volume of Audio 1 to zero and disable Audio 1 DAC input\n\t * to playback mixer, since playback is always through Audio 2.\n\t */\n\tif (!ESS_USE_AUDIO1(sc->sc_model))\n\t\tess_write_mix_reg(sc, ESS_MREG_VOLUME_VOICE, 0);\n\tess_wdsp(sc, ESS_ACMD_DISABLE_SPKR);\n\n\tif (ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tess_write_mix_reg(sc, ESS_MREG_ADC_SOURCE, ESS_SOURCE_MIC);\n\t\tsc->in_port = ESS_SOURCE_MIC;\n\t\tsc->ndevs = ESS_1788_NDEVS;\n\t} else {\n\t\t/*\n\t\t * Set hardware record source to use output of the record\n\t\t * mixer. We do the selection of record source in software by\n\t\t * setting the gain of the unused sources to zero. (See\n\t\t * ess_set_in_ports.)\n\t\t */\n\t\tess_write_mix_reg(sc, ESS_MREG_ADC_SOURCE, ESS_SOURCE_MIXER);\n\t\tsc->in_mask = 1 << ESS_MIC_REC_VOL;\n\t\tsc->ndevs = ESS_1888_NDEVS;\n\t\tess_clear_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, 0x10);\n\t\tess_set_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, 0x08);\n\t}\n\n\t/*\n\t * Set gain on each mixer device to a sensible value.\n\t * Devices not normally used are turned off, and other devices\n\t * are set to 50% volume.\n\t */\n\tfor (i = 0; i < sc->ndevs; i++) {\n\t\tswitch (i) {\n\t\tcase ESS_MIC_PLAY_VOL:\n\t\tcase ESS_LINE_PLAY_VOL:\n\t\tcase ESS_CD_PLAY_VOL:\n\t\tcase ESS_AUXB_PLAY_VOL:\n\t\tcase ESS_DAC_REC_VOL:\n\t\tcase ESS_LINE_REC_VOL:\n\t\tcase ESS_SYNTH_REC_VOL:\n\t\tcase ESS_CD_REC_VOL:\n\t\tcase ESS_AUXB_REC_VOL:\n\t\t\tv = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tv = ESS_4BIT_GAIN(AUDIO_MAX_GAIN / 2);\n\t\t\tbreak;\n\t\t}\n\t\tsc->gain[i][ESS_LEFT] = sc->gain[i][ESS_RIGHT] = v;\n\t\tess_set_gain(sc, i, 1);\n\t}\n\n\tess_setup(sc);\n\n\t/* Disable the speaker until the device is opened.  */\n\tess_speaker_off(sc);\n\tsc->spkr_state = SPKR_OFF;\n\n\tsprintf(ess_device.name, \"ES%s\", essmodel[sc->sc_model]);\n\tsprintf(ess_device.version, \"0x%04x\", sc->sc_version);\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\taudio_attach_mi(&ess_1788_hw_if, sc, &sc->sc_dev);\n\telse\n\t\taudio_attach_mi(&ess_1888_hw_if, sc, &sc->sc_dev);\n\n\targ.type = AUDIODEV_TYPE_OPL;\n\targ.hwif = 0;\n\targ.hdl = 0;\n\t(void)config_found(&sc->sc_dev, &arg, audioprint);\n\n#ifdef AUDIO_DEBUG\n\tif (essdebug > 0)\n\t\tess_printsc(sc);\n#endif\n}"
  },
  {
    "function_name": "essmatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "801-877",
    "snippet": "int\nessmatch(sc)\n\tstruct ess_softc *sc;\n{\n\tif (!ESS_BASE_VALID(sc->sc_iobase)) {\n\t\tprintf(\"ess: configured iobase 0x%x invalid\\n\", sc->sc_iobase);\n\t\treturn (0);\n\t}\n\n\t/* Configure the ESS chip for the desired audio base address. */\n\tif (ess_config_addr(sc))\n\t\treturn (0);\n\n\tif (ess_setup_sc(sc, 1)) \n\t\treturn (0);\n\n\tif (sc->sc_model == ESS_UNSUPPORTED) {\n\t\tDPRINTF((\"ess: Unsupported model\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* Check that requested DMA channels are valid and different. */\n\tif (!ESS_DRQ1_VALID(sc->sc_audio1.drq)) {\n\t\tprintf(\"ess: record drq %d invalid\\n\", sc->sc_audio1.drq);\n\t\treturn (0);\n\t}\n\tif (!isa_drq_isfree(sc->sc_isa, sc->sc_audio1.drq))\n\t\treturn (0);\n\tif (!ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tif (!ESS_DRQ2_VALID(sc->sc_audio2.drq)) {\n\t\t\tprintf(\"ess: play drq %d invalid\\n\", sc->sc_audio2.drq);\n\t\t\treturn (0);\n\t\t}\n\t\tif (sc->sc_audio1.drq == sc->sc_audio2.drq) {\n\t\t\tprintf(\"ess: play and record drq both %d\\n\",\n\t\t\t       sc->sc_audio1.drq);\n\t\t\treturn (0);\n\t\t}\n\t\tif (!isa_drq_isfree(sc->sc_isa, sc->sc_audio2.drq))\n\t\t\treturn (0);\n\t}\n\t\n\t/* \n\t * The 1887 has an additional IRQ mode where both channels are mapped\n\t * to the same IRQ.\n\t */\n\tif (sc->sc_model == ESS_1887 &&\n\t    sc->sc_audio1.irq == sc->sc_audio2.irq &&\n\t    sc->sc_audio1.irq != -1 &&\n\t    ESS_IRQ12_VALID(sc->sc_audio1.irq))\n\t\tgoto irq_not1888;\n\n\t/* Check that requested IRQ lines are valid and different. */\n\tif (sc->sc_audio1.irq != -1 &&\n\t    !ESS_IRQ1_VALID(sc->sc_audio1.irq)) {\n\t\tprintf(\"ess: record irq %d invalid\\n\", sc->sc_audio1.irq);\n\t\treturn (0);\n\t}\n\tif (!ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tif (sc->sc_audio2.irq != -1 &&\n\t\t    !ESS_IRQ2_VALID(sc->sc_audio2.irq)) {\n\t\t\tprintf(\"ess: play irq %d invalid\\n\", sc->sc_audio2.irq);\n\t\t\treturn (0);\n\t\t}\n\t\tif (sc->sc_audio1.irq == sc->sc_audio2.irq &&\n\t\t    sc->sc_audio1.irq != -1) {\n\t\t\tprintf(\"ess: play and record irq both %d\\n\",\n\t\t\t       sc->sc_audio1.irq);\n\t\t\treturn (0);\n\t\t}\n\t}\n\nirq_not1888:\n\t/* XXX should we check IRQs as well? */\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_setup_sc",
      "int\tess_config_addr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ess: play and record irq both %d\\n\"",
            "sc->sc_audio1.irq"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESS_IRQ2_VALID",
          "args": [
            "sc->sc_audio2.irq"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESS_USE_AUDIO1",
          "args": [
            "sc->sc_model"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESS_IRQ1_VALID",
          "args": [
            "sc->sc_audio1.irq"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESS_IRQ12_VALID",
          "args": [
            "sc->sc_audio1.irq"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_drq_isfree",
          "args": [
            "sc->sc_isa",
            "sc->sc_audio2.drq"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "isa_drq_isfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "658-669",
          "snippet": "int\nisa_drq_isfree(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_drq_isfree: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\treturn ISA_DRQ_ISFREE(sc, chan);\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\n\nint\nisa_drq_isfree(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_drq_isfree: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\treturn ISA_DRQ_ISFREE(sc, chan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESS_DRQ2_VALID",
          "args": [
            "sc->sc_audio2.drq"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESS_USE_AUDIO1",
          "args": [
            "sc->sc_model"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESS_DRQ1_VALID",
          "args": [
            "sc->sc_audio1.drq"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ess: Unsupported model\\n\")"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_setup_sc",
          "args": [
            "sc",
            "1"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "ess_setup_sc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "778-796",
          "snippet": "int\ness_setup_sc(sc, doinit)\n\tstruct ess_softc *sc;\n\tint doinit;\n{\n\t/* Reset the chip. */\n\tif (ess_reset(sc) != 0) {\n\t\tDPRINTF((\"ess_setup_sc: couldn't reset chip\\n\"));\n\t\treturn (1);\n\t}\n\n\t/* Identify the ESS chip, and check that it is supported. */\n\tif (ess_identify(sc)) {\n\t\tDPRINTF((\"ess_setup_sc: couldn't identify\\n\"));\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_setup_sc",
            "int\tess_identify",
            "int\tess_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_setup_sc;\nint\tess_identify;\nint\tess_reset;\n\nint\ness_setup_sc(sc, doinit)\n\tstruct ess_softc *sc;\n\tint doinit;\n{\n\t/* Reset the chip. */\n\tif (ess_reset(sc) != 0) {\n\t\tDPRINTF((\"ess_setup_sc: couldn't reset chip\\n\"));\n\t\treturn (1);\n\t}\n\n\t/* Identify the ESS chip, and check that it is supported. */\n\tif (ess_identify(sc)) {\n\t\tDPRINTF((\"ess_setup_sc: couldn't identify\\n\"));\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_config_addr",
          "args": [
            "sc"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "ess_config_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "351-427",
          "snippet": "int\ness_config_addr(sc)\n\tstruct ess_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tbus_space_tag_t iot = sc->sc_iot;\n\n\t/*\n\t * Configure using the System Control Register method.  This\n\t * method is used when the AMODE line is tied high, which is\n\t * the case for the Shark, but not for the evaluation board.\n\t */\n\n\tbus_space_handle_t scr_access_ioh;\n\tbus_space_handle_t scr_ioh;\n\tu_short scr_value;\n\n\t/*\n\t * Set the SCR bit to enable audio.\n\t */\n\tscr_value = ESS_SCR_AUDIO_ENABLE;\n\n\t/*\n\t * Set the SCR bits necessary to select the specified audio\n\t * base address.\n\t */\n\tswitch(iobase) {\n\tcase 0x220:\n\t\tscr_value |= ESS_SCR_AUDIO_220;\n\t\tbreak;\n\tcase 0x230:\n\t\tscr_value |= ESS_SCR_AUDIO_230;\n\t\tbreak;\n\tcase 0x240:\n\t\tscr_value |= ESS_SCR_AUDIO_240;\n\t\tbreak;\n\tcase 0x250:\n\t\tscr_value |= ESS_SCR_AUDIO_250;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"ess: configured iobase 0x%x invalid\\n\", iobase);\n\t\treturn (1);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Get a mapping for the System Control Register (SCR) access\n\t * registers and the SCR data registers.\n\t */\n\tif (bus_space_map(iot, ESS_SCR_ACCESS_BASE, ESS_SCR_ACCESS_PORTS,\n\t\t\t  0, &scr_access_ioh)) {\n\t\tprintf(\"ess: can't map SCR access registers\\n\");\n\t\treturn (1);\n\t}\n\tif (bus_space_map(iot, ESS_SCR_BASE, ESS_SCR_PORTS,\n\t\t\t  0, &scr_ioh)) {\n\t\tprintf(\"ess: can't map SCR registers\\n\");\n\t\tbus_space_unmap(iot, scr_access_ioh, ESS_SCR_ACCESS_PORTS);\n\t\treturn (1);\n\t}\n\n\t/* Unlock the SCR. */\n\tEWRITE1(iot, scr_access_ioh, ESS_SCR_UNLOCK, 0);\n\n\t/* Write the base address information into SCR[0]. */\n\tEWRITE1(iot, scr_ioh, ESS_SCR_INDEX, 0);\n\tEWRITE1(iot, scr_ioh, ESS_SCR_DATA, scr_value);\n\t\n\t/* Lock the SCR. */\n\tEWRITE1(iot, scr_access_ioh, ESS_SCR_LOCK, 0);\n\n\t/* Unmap the SCR access ports and the SCR data ports. */\n\tbus_space_unmap(iot, scr_access_ioh, ESS_SCR_ACCESS_PORTS);\n\tbus_space_unmap(iot, scr_ioh, ESS_SCR_PORTS);\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_config_addr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_config_addr;\n\nint\ness_config_addr(sc)\n\tstruct ess_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tbus_space_tag_t iot = sc->sc_iot;\n\n\t/*\n\t * Configure using the System Control Register method.  This\n\t * method is used when the AMODE line is tied high, which is\n\t * the case for the Shark, but not for the evaluation board.\n\t */\n\n\tbus_space_handle_t scr_access_ioh;\n\tbus_space_handle_t scr_ioh;\n\tu_short scr_value;\n\n\t/*\n\t * Set the SCR bit to enable audio.\n\t */\n\tscr_value = ESS_SCR_AUDIO_ENABLE;\n\n\t/*\n\t * Set the SCR bits necessary to select the specified audio\n\t * base address.\n\t */\n\tswitch(iobase) {\n\tcase 0x220:\n\t\tscr_value |= ESS_SCR_AUDIO_220;\n\t\tbreak;\n\tcase 0x230:\n\t\tscr_value |= ESS_SCR_AUDIO_230;\n\t\tbreak;\n\tcase 0x240:\n\t\tscr_value |= ESS_SCR_AUDIO_240;\n\t\tbreak;\n\tcase 0x250:\n\t\tscr_value |= ESS_SCR_AUDIO_250;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"ess: configured iobase 0x%x invalid\\n\", iobase);\n\t\treturn (1);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Get a mapping for the System Control Register (SCR) access\n\t * registers and the SCR data registers.\n\t */\n\tif (bus_space_map(iot, ESS_SCR_ACCESS_BASE, ESS_SCR_ACCESS_PORTS,\n\t\t\t  0, &scr_access_ioh)) {\n\t\tprintf(\"ess: can't map SCR access registers\\n\");\n\t\treturn (1);\n\t}\n\tif (bus_space_map(iot, ESS_SCR_BASE, ESS_SCR_PORTS,\n\t\t\t  0, &scr_ioh)) {\n\t\tprintf(\"ess: can't map SCR registers\\n\");\n\t\tbus_space_unmap(iot, scr_access_ioh, ESS_SCR_ACCESS_PORTS);\n\t\treturn (1);\n\t}\n\n\t/* Unlock the SCR. */\n\tEWRITE1(iot, scr_access_ioh, ESS_SCR_UNLOCK, 0);\n\n\t/* Write the base address information into SCR[0]. */\n\tEWRITE1(iot, scr_ioh, ESS_SCR_INDEX, 0);\n\tEWRITE1(iot, scr_ioh, ESS_SCR_DATA, scr_value);\n\t\n\t/* Lock the SCR. */\n\tEWRITE1(iot, scr_access_ioh, ESS_SCR_LOCK, 0);\n\n\t/* Unmap the SCR access ports and the SCR data ports. */\n\tbus_space_unmap(iot, scr_access_ioh, ESS_SCR_ACCESS_PORTS);\n\tbus_space_unmap(iot, scr_ioh, ESS_SCR_PORTS);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESS_BASE_VALID",
          "args": [
            "sc->sc_iobase"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_setup_sc;\nint\tess_config_addr;\n\nint\nessmatch(sc)\n\tstruct ess_softc *sc;\n{\n\tif (!ESS_BASE_VALID(sc->sc_iobase)) {\n\t\tprintf(\"ess: configured iobase 0x%x invalid\\n\", sc->sc_iobase);\n\t\treturn (0);\n\t}\n\n\t/* Configure the ESS chip for the desired audio base address. */\n\tif (ess_config_addr(sc))\n\t\treturn (0);\n\n\tif (ess_setup_sc(sc, 1)) \n\t\treturn (0);\n\n\tif (sc->sc_model == ESS_UNSUPPORTED) {\n\t\tDPRINTF((\"ess: Unsupported model\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* Check that requested DMA channels are valid and different. */\n\tif (!ESS_DRQ1_VALID(sc->sc_audio1.drq)) {\n\t\tprintf(\"ess: record drq %d invalid\\n\", sc->sc_audio1.drq);\n\t\treturn (0);\n\t}\n\tif (!isa_drq_isfree(sc->sc_isa, sc->sc_audio1.drq))\n\t\treturn (0);\n\tif (!ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tif (!ESS_DRQ2_VALID(sc->sc_audio2.drq)) {\n\t\t\tprintf(\"ess: play drq %d invalid\\n\", sc->sc_audio2.drq);\n\t\t\treturn (0);\n\t\t}\n\t\tif (sc->sc_audio1.drq == sc->sc_audio2.drq) {\n\t\t\tprintf(\"ess: play and record drq both %d\\n\",\n\t\t\t       sc->sc_audio1.drq);\n\t\t\treturn (0);\n\t\t}\n\t\tif (!isa_drq_isfree(sc->sc_isa, sc->sc_audio2.drq))\n\t\t\treturn (0);\n\t}\n\t\n\t/* \n\t * The 1887 has an additional IRQ mode where both channels are mapped\n\t * to the same IRQ.\n\t */\n\tif (sc->sc_model == ESS_1887 &&\n\t    sc->sc_audio1.irq == sc->sc_audio2.irq &&\n\t    sc->sc_audio1.irq != -1 &&\n\t    ESS_IRQ12_VALID(sc->sc_audio1.irq))\n\t\tgoto irq_not1888;\n\n\t/* Check that requested IRQ lines are valid and different. */\n\tif (sc->sc_audio1.irq != -1 &&\n\t    !ESS_IRQ1_VALID(sc->sc_audio1.irq)) {\n\t\tprintf(\"ess: record irq %d invalid\\n\", sc->sc_audio1.irq);\n\t\treturn (0);\n\t}\n\tif (!ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tif (sc->sc_audio2.irq != -1 &&\n\t\t    !ESS_IRQ2_VALID(sc->sc_audio2.irq)) {\n\t\t\tprintf(\"ess: play irq %d invalid\\n\", sc->sc_audio2.irq);\n\t\t\treturn (0);\n\t\t}\n\t\tif (sc->sc_audio1.irq == sc->sc_audio2.irq &&\n\t\t    sc->sc_audio1.irq != -1) {\n\t\t\tprintf(\"ess: play and record irq both %d\\n\",\n\t\t\t       sc->sc_audio1.irq);\n\t\t\treturn (0);\n\t\t}\n\t}\n\nirq_not1888:\n\t/* XXX should we check IRQs as well? */\n\n\treturn (1);\n}"
  },
  {
    "function_name": "ess_setup_sc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "778-796",
    "snippet": "int\ness_setup_sc(sc, doinit)\n\tstruct ess_softc *sc;\n\tint doinit;\n{\n\t/* Reset the chip. */\n\tif (ess_reset(sc) != 0) {\n\t\tDPRINTF((\"ess_setup_sc: couldn't reset chip\\n\"));\n\t\treturn (1);\n\t}\n\n\t/* Identify the ESS chip, and check that it is supported. */\n\tif (ess_identify(sc)) {\n\t\tDPRINTF((\"ess_setup_sc: couldn't identify\\n\"));\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_setup_sc",
      "int\tess_identify",
      "int\tess_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ess_setup_sc: couldn't identify\\n\")"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_identify",
          "args": [
            "sc"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "ess_identify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "618-775",
          "snippet": "int\ness_identify(sc)\n\tstruct ess_softc *sc;\n{\n\tu_char reg1;\n\tu_char reg2;\n\tu_char reg3;\n\tu_int8_t ident[4];\n\n\tsc->sc_model = ESS_UNSUPPORTED;\n\tsc->sc_version = 0;\n\n\tmemset(ident, 0, sizeof(ident));\n\n\t/*\n\t * 1. Check legacy ID bytes.  These should be 0x68 0x8n, where\n\t *    n >= 8 for an ES1887 or an ES888.  Other values indicate\n\t *    earlier (unsupported) chips.\n\t */\n\tess_wdsp(sc, ESS_ACMD_LEGACY_ID);\n\n\tif ((reg1 = ess_rdsp(sc)) != 0x68) {\n\t\tprintf(\"ess: First ID byte wrong (0x%02x)\\n\", reg1);\n\t\treturn 1;\n\t}\n\n\treg2 = ess_rdsp(sc);\n\tif (((reg2 & 0xf0) != 0x80) ||\n\t    ((reg2 & 0x0f) < 8)) {\n\t\tprintf(\"ess: Second ID byte wrong (0x%02x)\\n\", reg2);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Store the ID bytes as the version.\n\t */\n\tsc->sc_version = (reg1 << 8) + reg2;\n\n\n\t/*\n\t * 2. Verify we can change bit 2 in mixer register 0x64.  This\n\t *    should be possible on all supported chips.\n\t */\n\treg1 = ess_read_mix_reg(sc, ESS_MREG_VOLUME_CTRL);\n\treg2 = reg1 ^ 0x04;  /* toggle bit 2 */\n\t\n\tess_write_mix_reg(sc, ESS_MREG_VOLUME_CTRL, reg2);\n\t\n\tif (ess_read_mix_reg(sc, ESS_MREG_VOLUME_CTRL) != reg2) {\n\t\tprintf(\"ess: Hardware error (unable to toggle bit 2 of mixer register 0x64)\\n\");\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Restore the original value of mixer register 0x64.\n\t */\n\tess_write_mix_reg(sc, ESS_MREG_VOLUME_CTRL, reg1);\n\n\n\t/*\n\t * 3. Verify we can change the value of mixer register \n\t *    ESS_MREG_SAMPLE_RATE.\n\t *    This is possible on the 1888/1887/888, but not on the 1788.\n\t *    It is not necessary to restore the value of this mixer register.\n\t */\n\treg1 = ess_read_mix_reg(sc, ESS_MREG_SAMPLE_RATE);\n\treg2 = reg1 ^ 0xff;  /* toggle all bits */\n\n\tess_write_mix_reg(sc, ESS_MREG_SAMPLE_RATE, reg2);\n\t\n\tif (ess_read_mix_reg(sc, ESS_MREG_SAMPLE_RATE) != reg2) {\n\t\t/* If we got this far before failing, it's a 1788. */\n\t\tsc->sc_model = ESS_1788;\n\n\t\t/*\n\t\t * Identify ESS model for ES18[67]8.\n\t\t */\n\t\tess_read_multi_mix_reg(sc, 0x40, ident, sizeof(ident));\n\t\tif(ident[0] == 0x18) {\n\t\t\tswitch(ident[1]) {\n\t\t\tcase 0x68:\n\t\t\t\tsc->sc_model = ESS_1868;\n\t\t\t\tbreak;\n\t\t\tcase 0x78:\n\t\t\t\tsc->sc_model = ESS_1878;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/*\n\t\t * 4. Determine if we can change bit 5 in mixer register 0x64.\n\t\t *    This determines whether we have an ES1887:\n\t\t *\n\t\t *    - can change indicates ES1887\n\t\t *    - can't change indicates ES1888 or ES888\n\t\t */\n\t\treg1 = ess_read_mix_reg(sc, ESS_MREG_VOLUME_CTRL);\n\t\treg2 = reg1 ^ 0x20;  /* toggle bit 5 */\n\t\n\t\tess_write_mix_reg(sc, ESS_MREG_VOLUME_CTRL, reg2);\n\t\n\t\tif (ess_read_mix_reg(sc, ESS_MREG_VOLUME_CTRL) == reg2) {\n\t\t\tsc->sc_model = ESS_1887;\n\n\t\t\t/*\n\t\t\t * Restore the original value of mixer register 0x64.\n\t\t\t */\n\t\t\tess_write_mix_reg(sc, ESS_MREG_VOLUME_CTRL, reg1);\n\n\t\t\t/*\n\t\t\t * Identify ESS model for ES18[67]9.\n\t\t\t */\n\t\t\tess_read_multi_mix_reg(sc, 0x40, ident, sizeof(ident));\n\t\t\tif(ident[0] == 0x18) {\n\t\t\t\tswitch(ident[1]) {\n\t\t\t\tcase 0x69:\n\t\t\t\t\tsc->sc_model = ESS_1869;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x79:\n\t\t\t\t\tsc->sc_model = ESS_1879;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * 5. Determine if we can change the value of mixer\n\t\t\t *    register 0x69 independently of mixer register\n\t\t\t *    0x68. This determines which chip we have:\n\t\t\t *\n\t\t\t *    - can modify idependently indicates ES888\n\t\t\t *    - register 0x69 is an alias of 0x68 indicates ES1888\n\t\t\t */\n\t\t\treg1 = ess_read_mix_reg(sc, 0x68);\n\t\t\treg2 = ess_read_mix_reg(sc, 0x69);\n\t\t\treg3 = reg2 ^ 0xff;  /* toggle all bits */\n\n\t\t\t/*\n\t\t\t * Write different values to each register.\n\t\t\t */\n\t\t\tess_write_mix_reg(sc, 0x68, reg2);\n\t\t\tess_write_mix_reg(sc, 0x69, reg3);\n\n\t\t\tif (ess_read_mix_reg(sc, 0x68) == reg2 &&\n\t\t\t    ess_read_mix_reg(sc, 0x69) == reg3)\n\t\t\t\tsc->sc_model = ESS_888;\n\t\t\telse\n\t\t\t\tsc->sc_model = ESS_1888;\n\t\t\n\t\t\t/*\n\t\t\t * Restore the original value of the registers.\n\t\t\t */\n\t\t\tess_write_mix_reg(sc, 0x68, reg1);\n\t\t\tess_write_mix_reg(sc, 0x69, reg2);\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_identify",
            "int\tess_rdsp",
            "int\tess_wdsp",
            "u_char\tess_read_mix_reg",
            "void\tess_write_mix_reg",
            "void\tess_read_multi_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_identify;\nint\tess_rdsp;\nint\tess_wdsp;\nu_char\tess_read_mix_reg;\nvoid\tess_write_mix_reg;\nvoid\tess_read_multi_mix_reg;\n\nint\ness_identify(sc)\n\tstruct ess_softc *sc;\n{\n\tu_char reg1;\n\tu_char reg2;\n\tu_char reg3;\n\tu_int8_t ident[4];\n\n\tsc->sc_model = ESS_UNSUPPORTED;\n\tsc->sc_version = 0;\n\n\tmemset(ident, 0, sizeof(ident));\n\n\t/*\n\t * 1. Check legacy ID bytes.  These should be 0x68 0x8n, where\n\t *    n >= 8 for an ES1887 or an ES888.  Other values indicate\n\t *    earlier (unsupported) chips.\n\t */\n\tess_wdsp(sc, ESS_ACMD_LEGACY_ID);\n\n\tif ((reg1 = ess_rdsp(sc)) != 0x68) {\n\t\tprintf(\"ess: First ID byte wrong (0x%02x)\\n\", reg1);\n\t\treturn 1;\n\t}\n\n\treg2 = ess_rdsp(sc);\n\tif (((reg2 & 0xf0) != 0x80) ||\n\t    ((reg2 & 0x0f) < 8)) {\n\t\tprintf(\"ess: Second ID byte wrong (0x%02x)\\n\", reg2);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Store the ID bytes as the version.\n\t */\n\tsc->sc_version = (reg1 << 8) + reg2;\n\n\n\t/*\n\t * 2. Verify we can change bit 2 in mixer register 0x64.  This\n\t *    should be possible on all supported chips.\n\t */\n\treg1 = ess_read_mix_reg(sc, ESS_MREG_VOLUME_CTRL);\n\treg2 = reg1 ^ 0x04;  /* toggle bit 2 */\n\t\n\tess_write_mix_reg(sc, ESS_MREG_VOLUME_CTRL, reg2);\n\t\n\tif (ess_read_mix_reg(sc, ESS_MREG_VOLUME_CTRL) != reg2) {\n\t\tprintf(\"ess: Hardware error (unable to toggle bit 2 of mixer register 0x64)\\n\");\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Restore the original value of mixer register 0x64.\n\t */\n\tess_write_mix_reg(sc, ESS_MREG_VOLUME_CTRL, reg1);\n\n\n\t/*\n\t * 3. Verify we can change the value of mixer register \n\t *    ESS_MREG_SAMPLE_RATE.\n\t *    This is possible on the 1888/1887/888, but not on the 1788.\n\t *    It is not necessary to restore the value of this mixer register.\n\t */\n\treg1 = ess_read_mix_reg(sc, ESS_MREG_SAMPLE_RATE);\n\treg2 = reg1 ^ 0xff;  /* toggle all bits */\n\n\tess_write_mix_reg(sc, ESS_MREG_SAMPLE_RATE, reg2);\n\t\n\tif (ess_read_mix_reg(sc, ESS_MREG_SAMPLE_RATE) != reg2) {\n\t\t/* If we got this far before failing, it's a 1788. */\n\t\tsc->sc_model = ESS_1788;\n\n\t\t/*\n\t\t * Identify ESS model for ES18[67]8.\n\t\t */\n\t\tess_read_multi_mix_reg(sc, 0x40, ident, sizeof(ident));\n\t\tif(ident[0] == 0x18) {\n\t\t\tswitch(ident[1]) {\n\t\t\tcase 0x68:\n\t\t\t\tsc->sc_model = ESS_1868;\n\t\t\t\tbreak;\n\t\t\tcase 0x78:\n\t\t\t\tsc->sc_model = ESS_1878;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/*\n\t\t * 4. Determine if we can change bit 5 in mixer register 0x64.\n\t\t *    This determines whether we have an ES1887:\n\t\t *\n\t\t *    - can change indicates ES1887\n\t\t *    - can't change indicates ES1888 or ES888\n\t\t */\n\t\treg1 = ess_read_mix_reg(sc, ESS_MREG_VOLUME_CTRL);\n\t\treg2 = reg1 ^ 0x20;  /* toggle bit 5 */\n\t\n\t\tess_write_mix_reg(sc, ESS_MREG_VOLUME_CTRL, reg2);\n\t\n\t\tif (ess_read_mix_reg(sc, ESS_MREG_VOLUME_CTRL) == reg2) {\n\t\t\tsc->sc_model = ESS_1887;\n\n\t\t\t/*\n\t\t\t * Restore the original value of mixer register 0x64.\n\t\t\t */\n\t\t\tess_write_mix_reg(sc, ESS_MREG_VOLUME_CTRL, reg1);\n\n\t\t\t/*\n\t\t\t * Identify ESS model for ES18[67]9.\n\t\t\t */\n\t\t\tess_read_multi_mix_reg(sc, 0x40, ident, sizeof(ident));\n\t\t\tif(ident[0] == 0x18) {\n\t\t\t\tswitch(ident[1]) {\n\t\t\t\tcase 0x69:\n\t\t\t\t\tsc->sc_model = ESS_1869;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x79:\n\t\t\t\t\tsc->sc_model = ESS_1879;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * 5. Determine if we can change the value of mixer\n\t\t\t *    register 0x69 independently of mixer register\n\t\t\t *    0x68. This determines which chip we have:\n\t\t\t *\n\t\t\t *    - can modify idependently indicates ES888\n\t\t\t *    - register 0x69 is an alias of 0x68 indicates ES1888\n\t\t\t */\n\t\t\treg1 = ess_read_mix_reg(sc, 0x68);\n\t\t\treg2 = ess_read_mix_reg(sc, 0x69);\n\t\t\treg3 = reg2 ^ 0xff;  /* toggle all bits */\n\n\t\t\t/*\n\t\t\t * Write different values to each register.\n\t\t\t */\n\t\t\tess_write_mix_reg(sc, 0x68, reg2);\n\t\t\tess_write_mix_reg(sc, 0x69, reg3);\n\n\t\t\tif (ess_read_mix_reg(sc, 0x68) == reg2 &&\n\t\t\t    ess_read_mix_reg(sc, 0x69) == reg3)\n\t\t\t\tsc->sc_model = ESS_888;\n\t\t\telse\n\t\t\t\tsc->sc_model = ESS_1888;\n\t\t\n\t\t\t/*\n\t\t\t * Restore the original value of the registers.\n\t\t\t */\n\t\t\tess_write_mix_reg(sc, 0x68, reg1);\n\t\t\tess_write_mix_reg(sc, 0x69, reg2);\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ess_setup_sc: couldn't reset chip\\n\")"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_reset",
          "args": [
            "sc"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "ess_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2225-2245",
          "snippet": "int\ness_reset(sc)\n\tstruct ess_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tsc->sc_audio1.active = 0;\n\tsc->sc_audio2.active = 0;\n\n\tEWRITE1(iot, ioh, ESS_DSP_RESET, ESS_RESET_EXT);\n\tdelay(10000);\n\tEWRITE1(iot, ioh, ESS_DSP_RESET, 0);\n\tif (ess_rdsp(sc) != ESS_MAGIC)\n\t\treturn (1);\n\n\t/* Enable access to the ESS extension commands. */\n\tess_wdsp(sc, ESS_ACMD_ENABLE_EXT);\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_reset",
            "int\tess_rdsp",
            "int\tess_wdsp"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_reset;\nint\tess_rdsp;\nint\tess_wdsp;\n\nint\ness_reset(sc)\n\tstruct ess_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tsc->sc_audio1.active = 0;\n\tsc->sc_audio2.active = 0;\n\n\tEWRITE1(iot, ioh, ESS_DSP_RESET, ESS_RESET_EXT);\n\tdelay(10000);\n\tEWRITE1(iot, ioh, ESS_DSP_RESET, 0);\n\tif (ess_rdsp(sc) != ESS_MAGIC)\n\t\treturn (1);\n\n\t/* Enable access to the ESS extension commands. */\n\tess_wdsp(sc, ESS_ACMD_ENABLE_EXT);\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_setup_sc;\nint\tess_identify;\nint\tess_reset;\n\nint\ness_setup_sc(sc, doinit)\n\tstruct ess_softc *sc;\n\tint doinit;\n{\n\t/* Reset the chip. */\n\tif (ess_reset(sc) != 0) {\n\t\tDPRINTF((\"ess_setup_sc: couldn't reset chip\\n\"));\n\t\treturn (1);\n\t}\n\n\t/* Identify the ESS chip, and check that it is supported. */\n\tif (ess_identify(sc)) {\n\t\tDPRINTF((\"ess_setup_sc: couldn't identify\\n\"));\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "ess_identify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "618-775",
    "snippet": "int\ness_identify(sc)\n\tstruct ess_softc *sc;\n{\n\tu_char reg1;\n\tu_char reg2;\n\tu_char reg3;\n\tu_int8_t ident[4];\n\n\tsc->sc_model = ESS_UNSUPPORTED;\n\tsc->sc_version = 0;\n\n\tmemset(ident, 0, sizeof(ident));\n\n\t/*\n\t * 1. Check legacy ID bytes.  These should be 0x68 0x8n, where\n\t *    n >= 8 for an ES1887 or an ES888.  Other values indicate\n\t *    earlier (unsupported) chips.\n\t */\n\tess_wdsp(sc, ESS_ACMD_LEGACY_ID);\n\n\tif ((reg1 = ess_rdsp(sc)) != 0x68) {\n\t\tprintf(\"ess: First ID byte wrong (0x%02x)\\n\", reg1);\n\t\treturn 1;\n\t}\n\n\treg2 = ess_rdsp(sc);\n\tif (((reg2 & 0xf0) != 0x80) ||\n\t    ((reg2 & 0x0f) < 8)) {\n\t\tprintf(\"ess: Second ID byte wrong (0x%02x)\\n\", reg2);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Store the ID bytes as the version.\n\t */\n\tsc->sc_version = (reg1 << 8) + reg2;\n\n\n\t/*\n\t * 2. Verify we can change bit 2 in mixer register 0x64.  This\n\t *    should be possible on all supported chips.\n\t */\n\treg1 = ess_read_mix_reg(sc, ESS_MREG_VOLUME_CTRL);\n\treg2 = reg1 ^ 0x04;  /* toggle bit 2 */\n\t\n\tess_write_mix_reg(sc, ESS_MREG_VOLUME_CTRL, reg2);\n\t\n\tif (ess_read_mix_reg(sc, ESS_MREG_VOLUME_CTRL) != reg2) {\n\t\tprintf(\"ess: Hardware error (unable to toggle bit 2 of mixer register 0x64)\\n\");\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Restore the original value of mixer register 0x64.\n\t */\n\tess_write_mix_reg(sc, ESS_MREG_VOLUME_CTRL, reg1);\n\n\n\t/*\n\t * 3. Verify we can change the value of mixer register \n\t *    ESS_MREG_SAMPLE_RATE.\n\t *    This is possible on the 1888/1887/888, but not on the 1788.\n\t *    It is not necessary to restore the value of this mixer register.\n\t */\n\treg1 = ess_read_mix_reg(sc, ESS_MREG_SAMPLE_RATE);\n\treg2 = reg1 ^ 0xff;  /* toggle all bits */\n\n\tess_write_mix_reg(sc, ESS_MREG_SAMPLE_RATE, reg2);\n\t\n\tif (ess_read_mix_reg(sc, ESS_MREG_SAMPLE_RATE) != reg2) {\n\t\t/* If we got this far before failing, it's a 1788. */\n\t\tsc->sc_model = ESS_1788;\n\n\t\t/*\n\t\t * Identify ESS model for ES18[67]8.\n\t\t */\n\t\tess_read_multi_mix_reg(sc, 0x40, ident, sizeof(ident));\n\t\tif(ident[0] == 0x18) {\n\t\t\tswitch(ident[1]) {\n\t\t\tcase 0x68:\n\t\t\t\tsc->sc_model = ESS_1868;\n\t\t\t\tbreak;\n\t\t\tcase 0x78:\n\t\t\t\tsc->sc_model = ESS_1878;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/*\n\t\t * 4. Determine if we can change bit 5 in mixer register 0x64.\n\t\t *    This determines whether we have an ES1887:\n\t\t *\n\t\t *    - can change indicates ES1887\n\t\t *    - can't change indicates ES1888 or ES888\n\t\t */\n\t\treg1 = ess_read_mix_reg(sc, ESS_MREG_VOLUME_CTRL);\n\t\treg2 = reg1 ^ 0x20;  /* toggle bit 5 */\n\t\n\t\tess_write_mix_reg(sc, ESS_MREG_VOLUME_CTRL, reg2);\n\t\n\t\tif (ess_read_mix_reg(sc, ESS_MREG_VOLUME_CTRL) == reg2) {\n\t\t\tsc->sc_model = ESS_1887;\n\n\t\t\t/*\n\t\t\t * Restore the original value of mixer register 0x64.\n\t\t\t */\n\t\t\tess_write_mix_reg(sc, ESS_MREG_VOLUME_CTRL, reg1);\n\n\t\t\t/*\n\t\t\t * Identify ESS model for ES18[67]9.\n\t\t\t */\n\t\t\tess_read_multi_mix_reg(sc, 0x40, ident, sizeof(ident));\n\t\t\tif(ident[0] == 0x18) {\n\t\t\t\tswitch(ident[1]) {\n\t\t\t\tcase 0x69:\n\t\t\t\t\tsc->sc_model = ESS_1869;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x79:\n\t\t\t\t\tsc->sc_model = ESS_1879;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * 5. Determine if we can change the value of mixer\n\t\t\t *    register 0x69 independently of mixer register\n\t\t\t *    0x68. This determines which chip we have:\n\t\t\t *\n\t\t\t *    - can modify idependently indicates ES888\n\t\t\t *    - register 0x69 is an alias of 0x68 indicates ES1888\n\t\t\t */\n\t\t\treg1 = ess_read_mix_reg(sc, 0x68);\n\t\t\treg2 = ess_read_mix_reg(sc, 0x69);\n\t\t\treg3 = reg2 ^ 0xff;  /* toggle all bits */\n\n\t\t\t/*\n\t\t\t * Write different values to each register.\n\t\t\t */\n\t\t\tess_write_mix_reg(sc, 0x68, reg2);\n\t\t\tess_write_mix_reg(sc, 0x69, reg3);\n\n\t\t\tif (ess_read_mix_reg(sc, 0x68) == reg2 &&\n\t\t\t    ess_read_mix_reg(sc, 0x69) == reg3)\n\t\t\t\tsc->sc_model = ESS_888;\n\t\t\telse\n\t\t\t\tsc->sc_model = ESS_1888;\n\t\t\n\t\t\t/*\n\t\t\t * Restore the original value of the registers.\n\t\t\t */\n\t\t\tess_write_mix_reg(sc, 0x68, reg1);\n\t\t\tess_write_mix_reg(sc, 0x69, reg2);\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_identify",
      "int\tess_rdsp",
      "int\tess_wdsp",
      "u_char\tess_read_mix_reg",
      "void\tess_write_mix_reg",
      "void\tess_read_multi_mix_reg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_write_mix_reg",
          "args": [
            "sc",
            "0x69",
            "reg2"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "ess_write_mix_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2620-2636",
          "snippet": "void\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_write_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_write_mix_reg;\n\nvoid\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_read_mix_reg",
          "args": [
            "sc",
            "0x69"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "ess_read_mix_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2641-2658",
          "snippet": "u_char\ness_read_mix_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\tu_char val;\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tval = EREAD1(iot, ioh, ESS_MIX_REG_DATA);\n\tsplx(s);\n\n\tDPRINTFN(2,(\"ess_read_mix_reg: %x=%x\\n\", reg, val));\n\treturn val;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_read_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_mix_reg;\n\nu_char\ness_read_mix_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\tu_char val;\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tval = EREAD1(iot, ioh, ESS_MIX_REG_DATA);\n\tsplx(s);\n\n\tDPRINTFN(2,(\"ess_read_mix_reg: %x=%x\\n\", reg, val));\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_read_multi_mix_reg",
          "args": [
            "sc",
            "0x40",
            "ident",
            "sizeof(ident)"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "ess_read_multi_mix_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2678-2693",
          "snippet": "void\ness_read_multi_mix_reg(sc, reg, datap, count)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_int8_t *datap;\n\tbus_size_t count;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tbus_space_read_multi_1(iot, ioh, ESS_MIX_REG_DATA, datap, count);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_read_multi_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_read_multi_mix_reg;\n\nvoid\ness_read_multi_mix_reg(sc, reg, datap, count)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_int8_t *datap;\n\tbus_size_t count;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tbus_space_read_multi_1(iot, ioh, ESS_MIX_REG_DATA, datap, count);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ess: Hardware error (unable to toggle bit 2 of mixer register 0x64)\\n\""
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_rdsp",
          "args": [
            "sc"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "ess_rdsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2508-2527",
          "snippet": "int\ness_rdsp(sc)\n\tstruct ess_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tfor (i = ESS_READ_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_read_ready(sc)) {\n\t\t\ti = EREAD1(iot, ioh, ESS_DSP_READ);\n\t\t\tDPRINTFN(8,(\"ess_rdsp() = 0x%02x\\n\", i));\n\t\t\treturn i;\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_rdsp: timed out\\n\"));\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_dsp_read_ready",
            "int\tess_rdsp"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_dsp_read_ready;\nint\tess_rdsp;\n\nint\ness_rdsp(sc)\n\tstruct ess_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tfor (i = ESS_READ_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_read_ready(sc)) {\n\t\t\ti = EREAD1(iot, ioh, ESS_DSP_READ);\n\t\t\tDPRINTFN(8,(\"ess_rdsp() = 0x%02x\\n\", i));\n\t\t\treturn i;\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_rdsp: timed out\\n\"));\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_wdsp",
          "args": [
            "sc",
            "ESS_ACMD_LEGACY_ID"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "ess_wdsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2532-2553",
          "snippet": "int\ness_wdsp(sc, v)\n\tstruct ess_softc *sc;\n\tu_char v;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tDPRINTFN(8,(\"ess_wdsp(0x%02x)\\n\", v));\n\n\tfor (i = ESS_WRITE_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_write_ready(sc)) {\n\t\t\tEWRITE1(iot, ioh, ESS_DSP_WRITE, v);\n\t\t\treturn (0);\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_wdsp(0x%02x): timed out\\n\", v));\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_dsp_write_ready",
            "int\tess_wdsp"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_dsp_write_ready;\nint\tess_wdsp;\n\nint\ness_wdsp(sc, v)\n\tstruct ess_softc *sc;\n\tu_char v;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\tDPRINTFN(8,(\"ess_wdsp(0x%02x)\\n\", v));\n\n\tfor (i = ESS_WRITE_TIMEOUT; i > 0; --i) {\n\t\tif (ess_dsp_write_ready(sc)) {\n\t\t\tEWRITE1(iot, ioh, ESS_DSP_WRITE, v);\n\t\t\treturn (0);\n\t\t} else\n\t\t\tdelay(10);\n\t}\n\n\tDPRINTF((\"ess_wdsp(0x%02x): timed out\\n\", v));\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ident",
            "0",
            "sizeof(ident)"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_identify;\nint\tess_rdsp;\nint\tess_wdsp;\nu_char\tess_read_mix_reg;\nvoid\tess_write_mix_reg;\nvoid\tess_read_multi_mix_reg;\n\nint\ness_identify(sc)\n\tstruct ess_softc *sc;\n{\n\tu_char reg1;\n\tu_char reg2;\n\tu_char reg3;\n\tu_int8_t ident[4];\n\n\tsc->sc_model = ESS_UNSUPPORTED;\n\tsc->sc_version = 0;\n\n\tmemset(ident, 0, sizeof(ident));\n\n\t/*\n\t * 1. Check legacy ID bytes.  These should be 0x68 0x8n, where\n\t *    n >= 8 for an ES1887 or an ES888.  Other values indicate\n\t *    earlier (unsupported) chips.\n\t */\n\tess_wdsp(sc, ESS_ACMD_LEGACY_ID);\n\n\tif ((reg1 = ess_rdsp(sc)) != 0x68) {\n\t\tprintf(\"ess: First ID byte wrong (0x%02x)\\n\", reg1);\n\t\treturn 1;\n\t}\n\n\treg2 = ess_rdsp(sc);\n\tif (((reg2 & 0xf0) != 0x80) ||\n\t    ((reg2 & 0x0f) < 8)) {\n\t\tprintf(\"ess: Second ID byte wrong (0x%02x)\\n\", reg2);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Store the ID bytes as the version.\n\t */\n\tsc->sc_version = (reg1 << 8) + reg2;\n\n\n\t/*\n\t * 2. Verify we can change bit 2 in mixer register 0x64.  This\n\t *    should be possible on all supported chips.\n\t */\n\treg1 = ess_read_mix_reg(sc, ESS_MREG_VOLUME_CTRL);\n\treg2 = reg1 ^ 0x04;  /* toggle bit 2 */\n\t\n\tess_write_mix_reg(sc, ESS_MREG_VOLUME_CTRL, reg2);\n\t\n\tif (ess_read_mix_reg(sc, ESS_MREG_VOLUME_CTRL) != reg2) {\n\t\tprintf(\"ess: Hardware error (unable to toggle bit 2 of mixer register 0x64)\\n\");\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Restore the original value of mixer register 0x64.\n\t */\n\tess_write_mix_reg(sc, ESS_MREG_VOLUME_CTRL, reg1);\n\n\n\t/*\n\t * 3. Verify we can change the value of mixer register \n\t *    ESS_MREG_SAMPLE_RATE.\n\t *    This is possible on the 1888/1887/888, but not on the 1788.\n\t *    It is not necessary to restore the value of this mixer register.\n\t */\n\treg1 = ess_read_mix_reg(sc, ESS_MREG_SAMPLE_RATE);\n\treg2 = reg1 ^ 0xff;  /* toggle all bits */\n\n\tess_write_mix_reg(sc, ESS_MREG_SAMPLE_RATE, reg2);\n\t\n\tif (ess_read_mix_reg(sc, ESS_MREG_SAMPLE_RATE) != reg2) {\n\t\t/* If we got this far before failing, it's a 1788. */\n\t\tsc->sc_model = ESS_1788;\n\n\t\t/*\n\t\t * Identify ESS model for ES18[67]8.\n\t\t */\n\t\tess_read_multi_mix_reg(sc, 0x40, ident, sizeof(ident));\n\t\tif(ident[0] == 0x18) {\n\t\t\tswitch(ident[1]) {\n\t\t\tcase 0x68:\n\t\t\t\tsc->sc_model = ESS_1868;\n\t\t\t\tbreak;\n\t\t\tcase 0x78:\n\t\t\t\tsc->sc_model = ESS_1878;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/*\n\t\t * 4. Determine if we can change bit 5 in mixer register 0x64.\n\t\t *    This determines whether we have an ES1887:\n\t\t *\n\t\t *    - can change indicates ES1887\n\t\t *    - can't change indicates ES1888 or ES888\n\t\t */\n\t\treg1 = ess_read_mix_reg(sc, ESS_MREG_VOLUME_CTRL);\n\t\treg2 = reg1 ^ 0x20;  /* toggle bit 5 */\n\t\n\t\tess_write_mix_reg(sc, ESS_MREG_VOLUME_CTRL, reg2);\n\t\n\t\tif (ess_read_mix_reg(sc, ESS_MREG_VOLUME_CTRL) == reg2) {\n\t\t\tsc->sc_model = ESS_1887;\n\n\t\t\t/*\n\t\t\t * Restore the original value of mixer register 0x64.\n\t\t\t */\n\t\t\tess_write_mix_reg(sc, ESS_MREG_VOLUME_CTRL, reg1);\n\n\t\t\t/*\n\t\t\t * Identify ESS model for ES18[67]9.\n\t\t\t */\n\t\t\tess_read_multi_mix_reg(sc, 0x40, ident, sizeof(ident));\n\t\t\tif(ident[0] == 0x18) {\n\t\t\t\tswitch(ident[1]) {\n\t\t\t\tcase 0x69:\n\t\t\t\t\tsc->sc_model = ESS_1869;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x79:\n\t\t\t\t\tsc->sc_model = ESS_1879;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * 5. Determine if we can change the value of mixer\n\t\t\t *    register 0x69 independently of mixer register\n\t\t\t *    0x68. This determines which chip we have:\n\t\t\t *\n\t\t\t *    - can modify idependently indicates ES888\n\t\t\t *    - register 0x69 is an alias of 0x68 indicates ES1888\n\t\t\t */\n\t\t\treg1 = ess_read_mix_reg(sc, 0x68);\n\t\t\treg2 = ess_read_mix_reg(sc, 0x69);\n\t\t\treg3 = reg2 ^ 0xff;  /* toggle all bits */\n\n\t\t\t/*\n\t\t\t * Write different values to each register.\n\t\t\t */\n\t\t\tess_write_mix_reg(sc, 0x68, reg2);\n\t\t\tess_write_mix_reg(sc, 0x69, reg3);\n\n\t\t\tif (ess_read_mix_reg(sc, 0x68) == reg2 &&\n\t\t\t    ess_read_mix_reg(sc, 0x69) == reg3)\n\t\t\t\tsc->sc_model = ESS_888;\n\t\t\telse\n\t\t\t\tsc->sc_model = ESS_1888;\n\t\t\n\t\t\t/*\n\t\t\t * Restore the original value of the registers.\n\t\t\t */\n\t\t\tess_write_mix_reg(sc, 0x68, reg1);\n\t\t\tess_write_mix_reg(sc, 0x69, reg2);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ess_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "599-608",
    "snippet": "void\ness_setup(sc)\n\tstruct ess_softc *sc;\n{\n\n\tess_config_irq(sc);\n\tess_config_drq(sc);\n\n\tDPRINTFN(2,(\"ess_setup: done\\n\"));\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tess_config_irq",
      "void\tess_config_drq",
      "void\tess_setup"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"ess_setup: done\\n\")"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_config_drq",
          "args": [
            "sc"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "ess_config_drq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "535-594",
          "snippet": "void\ness_config_drq(sc)\n\tstruct ess_softc *sc;\n{\n\tint v;\n\n\tDPRINTFN(2,(\"ess_config_drq\\n\"));\n\n\t/* Configure Audio 1 (record) for DMA on the appropriate channel. */\n\tv = ESS_DRQ_CTRL_PU | ESS_DRQ_CTRL_EXT;\n\tswitch (sc->sc_audio1.drq) {\n\tcase 0:\n\t\tv |= ESS_DRQ_CTRL_DRQA;\n\t\tbreak;\n\tcase 1:\n\t\tv |= ESS_DRQ_CTRL_DRQB;\n\t\tbreak;\n\tcase 3:\n\t\tv |= ESS_DRQ_CTRL_DRQC;\n\t\tbreak;\n#ifdef DIAGNOSTIC\n\tdefault:\n\t\tprintf(\"ess_config_drq: configured dma chan %d not supported for Audio 1\\n\", \n\t\t       sc->sc_audio1.drq);\n\t\treturn;\n#endif\n\t}\n\t/* Set DRQ1 */\n\tess_write_x_reg(sc, ESS_XCMD_DRQ_CTRL, v);\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\treturn;\n\n\t/* Configure DRQ2 */\n\tv = ESS_AUDIO2_CTRL3_DRQ_PD;\n\tswitch (sc->sc_audio2.drq) {\n\tcase 0:\n\t\tv |= ESS_AUDIO2_CTRL3_DRQA;\n\t\tbreak;\n\tcase 1:\n\t\tv |= ESS_AUDIO2_CTRL3_DRQB;\n\t\tbreak;\n\tcase 3:\n\t\tv |= ESS_AUDIO2_CTRL3_DRQC;\n\t\tbreak;\n\tcase 5:\n\t\tv |= ESS_AUDIO2_CTRL3_DRQD;\n\t\tbreak;\n#ifdef DIAGNOSTIC\n\tdefault:\n\t\tprintf(\"ess_config_drq: configured dma chan %d not supported for Audio 2\\n\", \n\t\t       sc->sc_audio2.drq);\n\t\treturn;\n#endif\n\t}\n\tess_write_mix_reg(sc, ESS_MREG_AUDIO2_CTRL3, v);\n\t/* Enable DMA 2 */\n\tess_set_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, \n\t\t\t  ESS_AUDIO2_CTRL2_DMA_ENABLE);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_config_drq",
            "int\tess_write_x_reg",
            "void\tess_write_mix_reg",
            "void\tess_set_mreg_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_config_drq;\nint\tess_write_x_reg;\nvoid\tess_write_mix_reg;\nvoid\tess_set_mreg_bits;\n\nvoid\ness_config_drq(sc)\n\tstruct ess_softc *sc;\n{\n\tint v;\n\n\tDPRINTFN(2,(\"ess_config_drq\\n\"));\n\n\t/* Configure Audio 1 (record) for DMA on the appropriate channel. */\n\tv = ESS_DRQ_CTRL_PU | ESS_DRQ_CTRL_EXT;\n\tswitch (sc->sc_audio1.drq) {\n\tcase 0:\n\t\tv |= ESS_DRQ_CTRL_DRQA;\n\t\tbreak;\n\tcase 1:\n\t\tv |= ESS_DRQ_CTRL_DRQB;\n\t\tbreak;\n\tcase 3:\n\t\tv |= ESS_DRQ_CTRL_DRQC;\n\t\tbreak;\n#ifdef DIAGNOSTIC\n\tdefault:\n\t\tprintf(\"ess_config_drq: configured dma chan %d not supported for Audio 1\\n\", \n\t\t       sc->sc_audio1.drq);\n\t\treturn;\n#endif\n\t}\n\t/* Set DRQ1 */\n\tess_write_x_reg(sc, ESS_XCMD_DRQ_CTRL, v);\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\treturn;\n\n\t/* Configure DRQ2 */\n\tv = ESS_AUDIO2_CTRL3_DRQ_PD;\n\tswitch (sc->sc_audio2.drq) {\n\tcase 0:\n\t\tv |= ESS_AUDIO2_CTRL3_DRQA;\n\t\tbreak;\n\tcase 1:\n\t\tv |= ESS_AUDIO2_CTRL3_DRQB;\n\t\tbreak;\n\tcase 3:\n\t\tv |= ESS_AUDIO2_CTRL3_DRQC;\n\t\tbreak;\n\tcase 5:\n\t\tv |= ESS_AUDIO2_CTRL3_DRQD;\n\t\tbreak;\n#ifdef DIAGNOSTIC\n\tdefault:\n\t\tprintf(\"ess_config_drq: configured dma chan %d not supported for Audio 2\\n\", \n\t\t       sc->sc_audio2.drq);\n\t\treturn;\n#endif\n\t}\n\tess_write_mix_reg(sc, ESS_MREG_AUDIO2_CTRL3, v);\n\t/* Enable DMA 2 */\n\tess_set_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, \n\t\t\t  ESS_AUDIO2_CTRL2_DMA_ENABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_config_irq",
          "args": [
            "sc"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "ess_config_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "445-532",
          "snippet": "void\ness_config_irq(sc)\n\tstruct ess_softc *sc;\n{\n\tint v;\n\n\tDPRINTFN(2,(\"ess_config_irq\\n\"));\n\n\tif (sc->sc_model == ESS_1887 &&\n\t    sc->sc_audio1.irq == sc->sc_audio2.irq &&\n\t    sc->sc_audio1.irq != -1) {\n\t\t/* Use new method, both interrupts are the same. */\n\t\tv = ESS_IS_SELECT_IRQ;\t/* enable intrs */\n\t\tswitch (sc->sc_audio1.irq) {\n\t\tcase 5:\n\t\t\tv |= ESS_IS_INTRB;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tv |= ESS_IS_INTRC;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tv |= ESS_IS_INTRA;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tv |= ESS_IS_INTRD;\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tv |= ESS_IS_INTRE;\n\t\t\tbreak;\n#ifdef DIAGNOSTIC\n\t\tdefault:\n\t\t\tprintf(\"ess_config_irq: configured irq %d not supported for Audio 1\\n\", \n\t\t\t       sc->sc_audio1.irq);\n\t\t\treturn;\n#endif\n\t\t}\n\t\t/* Set the IRQ */\n\t\tess_write_mix_reg(sc, ESS_MREG_INTR_ST, v);\n\t\treturn;\n\t}\n\n\tif (sc->sc_model == ESS_1887) {\n\t\t/* Tell the 1887 to use the old interrupt method. */\n\t\tess_write_mix_reg(sc, ESS_MREG_INTR_ST, ESS_IS_ES1888);\n\t}\n\n\tif (sc->sc_audio1.polled) {\n\t\t/* Turn off Audio1 interrupts. */\n\t\tv = 0;\n\t} else {\n\t\t/* Configure Audio 1 for the appropriate IRQ line. */\n\t\tv = ESS_IRQ_CTRL_MASK | ESS_IRQ_CTRL_EXT; /* All intrs on */\n\t\tswitch (sc->sc_audio1.irq) {\n\t\tcase 5:\n\t\t\tv |= ESS_IRQ_CTRL_INTRB;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tv |= ESS_IRQ_CTRL_INTRC;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tv |= ESS_IRQ_CTRL_INTRA;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tv |= ESS_IRQ_CTRL_INTRD;\n\t\t\tbreak;\n#ifdef DIAGNOSTIC\n\t\tdefault:\n\t\t\tprintf(\"ess: configured irq %d not supported for Audio 1\\n\", \n\t\t\t       sc->sc_audio1.irq);\n\t\t\treturn;\n#endif\n\t\t}\n\t}\n\tess_write_x_reg(sc, ESS_XCMD_IRQ_CTRL, v);\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\treturn;\n\n\tif (sc->sc_audio2.polled) {\n\t\t/* Turn off Audio2 interrupts. */\n\t\tess_clear_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, \n\t\t\t\t    ESS_AUDIO2_CTRL2_IRQ2_ENABLE);\n\t} else {\n\t\t/* Audio2 is hardwired to INTRE in this mode. */\n\t\tess_set_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, \n\t\t\t\t  ESS_AUDIO2_CTRL2_IRQ2_ENABLE);\n\t}\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_config_irq",
            "int\tess_write_x_reg",
            "void\tess_write_mix_reg",
            "void\tess_clear_mreg_bits",
            "void\tess_set_mreg_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_config_irq;\nint\tess_write_x_reg;\nvoid\tess_write_mix_reg;\nvoid\tess_clear_mreg_bits;\nvoid\tess_set_mreg_bits;\n\nvoid\ness_config_irq(sc)\n\tstruct ess_softc *sc;\n{\n\tint v;\n\n\tDPRINTFN(2,(\"ess_config_irq\\n\"));\n\n\tif (sc->sc_model == ESS_1887 &&\n\t    sc->sc_audio1.irq == sc->sc_audio2.irq &&\n\t    sc->sc_audio1.irq != -1) {\n\t\t/* Use new method, both interrupts are the same. */\n\t\tv = ESS_IS_SELECT_IRQ;\t/* enable intrs */\n\t\tswitch (sc->sc_audio1.irq) {\n\t\tcase 5:\n\t\t\tv |= ESS_IS_INTRB;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tv |= ESS_IS_INTRC;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tv |= ESS_IS_INTRA;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tv |= ESS_IS_INTRD;\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tv |= ESS_IS_INTRE;\n\t\t\tbreak;\n#ifdef DIAGNOSTIC\n\t\tdefault:\n\t\t\tprintf(\"ess_config_irq: configured irq %d not supported for Audio 1\\n\", \n\t\t\t       sc->sc_audio1.irq);\n\t\t\treturn;\n#endif\n\t\t}\n\t\t/* Set the IRQ */\n\t\tess_write_mix_reg(sc, ESS_MREG_INTR_ST, v);\n\t\treturn;\n\t}\n\n\tif (sc->sc_model == ESS_1887) {\n\t\t/* Tell the 1887 to use the old interrupt method. */\n\t\tess_write_mix_reg(sc, ESS_MREG_INTR_ST, ESS_IS_ES1888);\n\t}\n\n\tif (sc->sc_audio1.polled) {\n\t\t/* Turn off Audio1 interrupts. */\n\t\tv = 0;\n\t} else {\n\t\t/* Configure Audio 1 for the appropriate IRQ line. */\n\t\tv = ESS_IRQ_CTRL_MASK | ESS_IRQ_CTRL_EXT; /* All intrs on */\n\t\tswitch (sc->sc_audio1.irq) {\n\t\tcase 5:\n\t\t\tv |= ESS_IRQ_CTRL_INTRB;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tv |= ESS_IRQ_CTRL_INTRC;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tv |= ESS_IRQ_CTRL_INTRA;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tv |= ESS_IRQ_CTRL_INTRD;\n\t\t\tbreak;\n#ifdef DIAGNOSTIC\n\t\tdefault:\n\t\t\tprintf(\"ess: configured irq %d not supported for Audio 1\\n\", \n\t\t\t       sc->sc_audio1.irq);\n\t\t\treturn;\n#endif\n\t\t}\n\t}\n\tess_write_x_reg(sc, ESS_XCMD_IRQ_CTRL, v);\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\treturn;\n\n\tif (sc->sc_audio2.polled) {\n\t\t/* Turn off Audio2 interrupts. */\n\t\tess_clear_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, \n\t\t\t\t    ESS_AUDIO2_CTRL2_IRQ2_ENABLE);\n\t} else {\n\t\t/* Audio2 is hardwired to INTRE in this mode. */\n\t\tess_set_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, \n\t\t\t\t  ESS_AUDIO2_CTRL2_IRQ2_ENABLE);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_config_irq;\nvoid\tess_config_drq;\nvoid\tess_setup;\n\nvoid\ness_setup(sc)\n\tstruct ess_softc *sc;\n{\n\n\tess_config_irq(sc);\n\tess_config_drq(sc);\n\n\tDPRINTFN(2,(\"ess_setup: done\\n\"));\n}"
  },
  {
    "function_name": "ess_config_drq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "535-594",
    "snippet": "void\ness_config_drq(sc)\n\tstruct ess_softc *sc;\n{\n\tint v;\n\n\tDPRINTFN(2,(\"ess_config_drq\\n\"));\n\n\t/* Configure Audio 1 (record) for DMA on the appropriate channel. */\n\tv = ESS_DRQ_CTRL_PU | ESS_DRQ_CTRL_EXT;\n\tswitch (sc->sc_audio1.drq) {\n\tcase 0:\n\t\tv |= ESS_DRQ_CTRL_DRQA;\n\t\tbreak;\n\tcase 1:\n\t\tv |= ESS_DRQ_CTRL_DRQB;\n\t\tbreak;\n\tcase 3:\n\t\tv |= ESS_DRQ_CTRL_DRQC;\n\t\tbreak;\n#ifdef DIAGNOSTIC\n\tdefault:\n\t\tprintf(\"ess_config_drq: configured dma chan %d not supported for Audio 1\\n\", \n\t\t       sc->sc_audio1.drq);\n\t\treturn;\n#endif\n\t}\n\t/* Set DRQ1 */\n\tess_write_x_reg(sc, ESS_XCMD_DRQ_CTRL, v);\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\treturn;\n\n\t/* Configure DRQ2 */\n\tv = ESS_AUDIO2_CTRL3_DRQ_PD;\n\tswitch (sc->sc_audio2.drq) {\n\tcase 0:\n\t\tv |= ESS_AUDIO2_CTRL3_DRQA;\n\t\tbreak;\n\tcase 1:\n\t\tv |= ESS_AUDIO2_CTRL3_DRQB;\n\t\tbreak;\n\tcase 3:\n\t\tv |= ESS_AUDIO2_CTRL3_DRQC;\n\t\tbreak;\n\tcase 5:\n\t\tv |= ESS_AUDIO2_CTRL3_DRQD;\n\t\tbreak;\n#ifdef DIAGNOSTIC\n\tdefault:\n\t\tprintf(\"ess_config_drq: configured dma chan %d not supported for Audio 2\\n\", \n\t\t       sc->sc_audio2.drq);\n\t\treturn;\n#endif\n\t}\n\tess_write_mix_reg(sc, ESS_MREG_AUDIO2_CTRL3, v);\n\t/* Enable DMA 2 */\n\tess_set_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, \n\t\t\t  ESS_AUDIO2_CTRL2_DMA_ENABLE);\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tess_config_drq",
      "int\tess_write_x_reg",
      "void\tess_write_mix_reg",
      "void\tess_set_mreg_bits"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_set_mreg_bits",
          "args": [
            "sc",
            "ESS_MREG_AUDIO2_CTRL2",
            "ESS_AUDIO2_CTRL2_DMA_ENABLE"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "ess_set_mreg_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2669-2676",
          "snippet": "void\ness_set_mreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) | mask);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_read_mix_reg",
            "void\tess_write_mix_reg",
            "void\tess_set_mreg_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_mix_reg;\nvoid\tess_write_mix_reg;\nvoid\tess_set_mreg_bits;\n\nvoid\ness_set_mreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_write_mix_reg",
          "args": [
            "sc",
            "ESS_MREG_AUDIO2_CTRL3",
            "v"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "ess_write_mix_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2620-2636",
          "snippet": "void\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_write_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_write_mix_reg;\n\nvoid\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ess_config_drq: configured dma chan %d not supported for Audio 2\\n\"",
            "sc->sc_audio2.drq"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESS_USE_AUDIO1",
          "args": [
            "sc->sc_model"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_write_x_reg",
          "args": [
            "sc",
            "ESS_XCMD_DRQ_CTRL",
            "v"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "ess_write_x_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2558-2571",
          "snippet": "int\ness_write_x_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tint error;\n\n\tDPRINTFN(2,(\"ess_write_x_reg: %02x=%02x\\n\", reg, val));\n\tif ((error = ess_wdsp(sc, reg)) == 0)\n\t\terror = ess_wdsp(sc, val);\n\n\treturn error;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_wdsp",
            "int\tess_write_x_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_wdsp;\nint\tess_write_x_reg;\n\nint\ness_write_x_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tint error;\n\n\tDPRINTFN(2,(\"ess_write_x_reg: %02x=%02x\\n\", reg, val));\n\tif ((error = ess_wdsp(sc, reg)) == 0)\n\t\terror = ess_wdsp(sc, val);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"ess_config_drq\\n\")"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_config_drq;\nint\tess_write_x_reg;\nvoid\tess_write_mix_reg;\nvoid\tess_set_mreg_bits;\n\nvoid\ness_config_drq(sc)\n\tstruct ess_softc *sc;\n{\n\tint v;\n\n\tDPRINTFN(2,(\"ess_config_drq\\n\"));\n\n\t/* Configure Audio 1 (record) for DMA on the appropriate channel. */\n\tv = ESS_DRQ_CTRL_PU | ESS_DRQ_CTRL_EXT;\n\tswitch (sc->sc_audio1.drq) {\n\tcase 0:\n\t\tv |= ESS_DRQ_CTRL_DRQA;\n\t\tbreak;\n\tcase 1:\n\t\tv |= ESS_DRQ_CTRL_DRQB;\n\t\tbreak;\n\tcase 3:\n\t\tv |= ESS_DRQ_CTRL_DRQC;\n\t\tbreak;\n#ifdef DIAGNOSTIC\n\tdefault:\n\t\tprintf(\"ess_config_drq: configured dma chan %d not supported for Audio 1\\n\", \n\t\t       sc->sc_audio1.drq);\n\t\treturn;\n#endif\n\t}\n\t/* Set DRQ1 */\n\tess_write_x_reg(sc, ESS_XCMD_DRQ_CTRL, v);\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\treturn;\n\n\t/* Configure DRQ2 */\n\tv = ESS_AUDIO2_CTRL3_DRQ_PD;\n\tswitch (sc->sc_audio2.drq) {\n\tcase 0:\n\t\tv |= ESS_AUDIO2_CTRL3_DRQA;\n\t\tbreak;\n\tcase 1:\n\t\tv |= ESS_AUDIO2_CTRL3_DRQB;\n\t\tbreak;\n\tcase 3:\n\t\tv |= ESS_AUDIO2_CTRL3_DRQC;\n\t\tbreak;\n\tcase 5:\n\t\tv |= ESS_AUDIO2_CTRL3_DRQD;\n\t\tbreak;\n#ifdef DIAGNOSTIC\n\tdefault:\n\t\tprintf(\"ess_config_drq: configured dma chan %d not supported for Audio 2\\n\", \n\t\t       sc->sc_audio2.drq);\n\t\treturn;\n#endif\n\t}\n\tess_write_mix_reg(sc, ESS_MREG_AUDIO2_CTRL3, v);\n\t/* Enable DMA 2 */\n\tess_set_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, \n\t\t\t  ESS_AUDIO2_CTRL2_DMA_ENABLE);\n}"
  },
  {
    "function_name": "ess_config_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "445-532",
    "snippet": "void\ness_config_irq(sc)\n\tstruct ess_softc *sc;\n{\n\tint v;\n\n\tDPRINTFN(2,(\"ess_config_irq\\n\"));\n\n\tif (sc->sc_model == ESS_1887 &&\n\t    sc->sc_audio1.irq == sc->sc_audio2.irq &&\n\t    sc->sc_audio1.irq != -1) {\n\t\t/* Use new method, both interrupts are the same. */\n\t\tv = ESS_IS_SELECT_IRQ;\t/* enable intrs */\n\t\tswitch (sc->sc_audio1.irq) {\n\t\tcase 5:\n\t\t\tv |= ESS_IS_INTRB;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tv |= ESS_IS_INTRC;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tv |= ESS_IS_INTRA;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tv |= ESS_IS_INTRD;\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tv |= ESS_IS_INTRE;\n\t\t\tbreak;\n#ifdef DIAGNOSTIC\n\t\tdefault:\n\t\t\tprintf(\"ess_config_irq: configured irq %d not supported for Audio 1\\n\", \n\t\t\t       sc->sc_audio1.irq);\n\t\t\treturn;\n#endif\n\t\t}\n\t\t/* Set the IRQ */\n\t\tess_write_mix_reg(sc, ESS_MREG_INTR_ST, v);\n\t\treturn;\n\t}\n\n\tif (sc->sc_model == ESS_1887) {\n\t\t/* Tell the 1887 to use the old interrupt method. */\n\t\tess_write_mix_reg(sc, ESS_MREG_INTR_ST, ESS_IS_ES1888);\n\t}\n\n\tif (sc->sc_audio1.polled) {\n\t\t/* Turn off Audio1 interrupts. */\n\t\tv = 0;\n\t} else {\n\t\t/* Configure Audio 1 for the appropriate IRQ line. */\n\t\tv = ESS_IRQ_CTRL_MASK | ESS_IRQ_CTRL_EXT; /* All intrs on */\n\t\tswitch (sc->sc_audio1.irq) {\n\t\tcase 5:\n\t\t\tv |= ESS_IRQ_CTRL_INTRB;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tv |= ESS_IRQ_CTRL_INTRC;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tv |= ESS_IRQ_CTRL_INTRA;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tv |= ESS_IRQ_CTRL_INTRD;\n\t\t\tbreak;\n#ifdef DIAGNOSTIC\n\t\tdefault:\n\t\t\tprintf(\"ess: configured irq %d not supported for Audio 1\\n\", \n\t\t\t       sc->sc_audio1.irq);\n\t\t\treturn;\n#endif\n\t\t}\n\t}\n\tess_write_x_reg(sc, ESS_XCMD_IRQ_CTRL, v);\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\treturn;\n\n\tif (sc->sc_audio2.polled) {\n\t\t/* Turn off Audio2 interrupts. */\n\t\tess_clear_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, \n\t\t\t\t    ESS_AUDIO2_CTRL2_IRQ2_ENABLE);\n\t} else {\n\t\t/* Audio2 is hardwired to INTRE in this mode. */\n\t\tess_set_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, \n\t\t\t\t  ESS_AUDIO2_CTRL2_IRQ2_ENABLE);\n\t}\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tess_config_irq",
      "int\tess_write_x_reg",
      "void\tess_write_mix_reg",
      "void\tess_clear_mreg_bits",
      "void\tess_set_mreg_bits"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ess_set_mreg_bits",
          "args": [
            "sc",
            "ESS_MREG_AUDIO2_CTRL2",
            "ESS_AUDIO2_CTRL2_IRQ2_ENABLE"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "ess_set_mreg_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2669-2676",
          "snippet": "void\ness_set_mreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) | mask);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_read_mix_reg",
            "void\tess_write_mix_reg",
            "void\tess_set_mreg_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_mix_reg;\nvoid\tess_write_mix_reg;\nvoid\tess_set_mreg_bits;\n\nvoid\ness_set_mreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_clear_mreg_bits",
          "args": [
            "sc",
            "ESS_MREG_AUDIO2_CTRL2",
            "ESS_AUDIO2_CTRL2_IRQ2_ENABLE"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "ess_clear_mreg_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2660-2667",
          "snippet": "void\ness_clear_mreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) & ~mask);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_read_mix_reg",
            "void\tess_write_mix_reg",
            "void\tess_clear_mreg_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_mix_reg;\nvoid\tess_write_mix_reg;\nvoid\tess_clear_mreg_bits;\n\nvoid\ness_clear_mreg_bits(sc, reg, mask)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char mask;\n{\n\tess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESS_USE_AUDIO1",
          "args": [
            "sc->sc_model"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess_write_x_reg",
          "args": [
            "sc",
            "ESS_XCMD_IRQ_CTRL",
            "v"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "ess_write_x_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2558-2571",
          "snippet": "int\ness_write_x_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tint error;\n\n\tDPRINTFN(2,(\"ess_write_x_reg: %02x=%02x\\n\", reg, val));\n\tif ((error = ess_wdsp(sc, reg)) == 0)\n\t\terror = ess_wdsp(sc, val);\n\n\treturn error;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_wdsp",
            "int\tess_write_x_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_wdsp;\nint\tess_write_x_reg;\n\nint\ness_write_x_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tint error;\n\n\tDPRINTFN(2,(\"ess_write_x_reg: %02x=%02x\\n\", reg, val));\n\tif ((error = ess_wdsp(sc, reg)) == 0)\n\t\terror = ess_wdsp(sc, val);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ess: configured irq %d not supported for Audio 1\\n\"",
            "sc->sc_audio1.irq"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_write_mix_reg",
          "args": [
            "sc",
            "ESS_MREG_INTR_ST",
            "ESS_IS_ES1888"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "ess_write_mix_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2620-2636",
          "snippet": "void\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tess_write_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_write_mix_reg;\n\nvoid\ness_write_mix_reg(sc, reg, val)\n\tstruct ess_softc *sc;\n\tu_char reg;\n\tu_char val;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\n\tDPRINTFN(2,(\"ess_write_mix_reg: %x=%x\\n\", reg, val));\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tEWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"ess_config_irq\\n\")"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tess_config_irq;\nint\tess_write_x_reg;\nvoid\tess_write_mix_reg;\nvoid\tess_clear_mreg_bits;\nvoid\tess_set_mreg_bits;\n\nvoid\ness_config_irq(sc)\n\tstruct ess_softc *sc;\n{\n\tint v;\n\n\tDPRINTFN(2,(\"ess_config_irq\\n\"));\n\n\tif (sc->sc_model == ESS_1887 &&\n\t    sc->sc_audio1.irq == sc->sc_audio2.irq &&\n\t    sc->sc_audio1.irq != -1) {\n\t\t/* Use new method, both interrupts are the same. */\n\t\tv = ESS_IS_SELECT_IRQ;\t/* enable intrs */\n\t\tswitch (sc->sc_audio1.irq) {\n\t\tcase 5:\n\t\t\tv |= ESS_IS_INTRB;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tv |= ESS_IS_INTRC;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tv |= ESS_IS_INTRA;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tv |= ESS_IS_INTRD;\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tv |= ESS_IS_INTRE;\n\t\t\tbreak;\n#ifdef DIAGNOSTIC\n\t\tdefault:\n\t\t\tprintf(\"ess_config_irq: configured irq %d not supported for Audio 1\\n\", \n\t\t\t       sc->sc_audio1.irq);\n\t\t\treturn;\n#endif\n\t\t}\n\t\t/* Set the IRQ */\n\t\tess_write_mix_reg(sc, ESS_MREG_INTR_ST, v);\n\t\treturn;\n\t}\n\n\tif (sc->sc_model == ESS_1887) {\n\t\t/* Tell the 1887 to use the old interrupt method. */\n\t\tess_write_mix_reg(sc, ESS_MREG_INTR_ST, ESS_IS_ES1888);\n\t}\n\n\tif (sc->sc_audio1.polled) {\n\t\t/* Turn off Audio1 interrupts. */\n\t\tv = 0;\n\t} else {\n\t\t/* Configure Audio 1 for the appropriate IRQ line. */\n\t\tv = ESS_IRQ_CTRL_MASK | ESS_IRQ_CTRL_EXT; /* All intrs on */\n\t\tswitch (sc->sc_audio1.irq) {\n\t\tcase 5:\n\t\t\tv |= ESS_IRQ_CTRL_INTRB;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tv |= ESS_IRQ_CTRL_INTRC;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tv |= ESS_IRQ_CTRL_INTRA;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tv |= ESS_IRQ_CTRL_INTRD;\n\t\t\tbreak;\n#ifdef DIAGNOSTIC\n\t\tdefault:\n\t\t\tprintf(\"ess: configured irq %d not supported for Audio 1\\n\", \n\t\t\t       sc->sc_audio1.irq);\n\t\t\treturn;\n#endif\n\t\t}\n\t}\n\tess_write_x_reg(sc, ESS_XCMD_IRQ_CTRL, v);\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\treturn;\n\n\tif (sc->sc_audio2.polled) {\n\t\t/* Turn off Audio2 interrupts. */\n\t\tess_clear_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, \n\t\t\t\t    ESS_AUDIO2_CTRL2_IRQ2_ENABLE);\n\t} else {\n\t\t/* Audio2 is hardwired to INTRE in this mode. */\n\t\tess_set_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, \n\t\t\t\t  ESS_AUDIO2_CTRL2_IRQ2_ENABLE);\n\t}\n}"
  },
  {
    "function_name": "ess_config_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "351-427",
    "snippet": "int\ness_config_addr(sc)\n\tstruct ess_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tbus_space_tag_t iot = sc->sc_iot;\n\n\t/*\n\t * Configure using the System Control Register method.  This\n\t * method is used when the AMODE line is tied high, which is\n\t * the case for the Shark, but not for the evaluation board.\n\t */\n\n\tbus_space_handle_t scr_access_ioh;\n\tbus_space_handle_t scr_ioh;\n\tu_short scr_value;\n\n\t/*\n\t * Set the SCR bit to enable audio.\n\t */\n\tscr_value = ESS_SCR_AUDIO_ENABLE;\n\n\t/*\n\t * Set the SCR bits necessary to select the specified audio\n\t * base address.\n\t */\n\tswitch(iobase) {\n\tcase 0x220:\n\t\tscr_value |= ESS_SCR_AUDIO_220;\n\t\tbreak;\n\tcase 0x230:\n\t\tscr_value |= ESS_SCR_AUDIO_230;\n\t\tbreak;\n\tcase 0x240:\n\t\tscr_value |= ESS_SCR_AUDIO_240;\n\t\tbreak;\n\tcase 0x250:\n\t\tscr_value |= ESS_SCR_AUDIO_250;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"ess: configured iobase 0x%x invalid\\n\", iobase);\n\t\treturn (1);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Get a mapping for the System Control Register (SCR) access\n\t * registers and the SCR data registers.\n\t */\n\tif (bus_space_map(iot, ESS_SCR_ACCESS_BASE, ESS_SCR_ACCESS_PORTS,\n\t\t\t  0, &scr_access_ioh)) {\n\t\tprintf(\"ess: can't map SCR access registers\\n\");\n\t\treturn (1);\n\t}\n\tif (bus_space_map(iot, ESS_SCR_BASE, ESS_SCR_PORTS,\n\t\t\t  0, &scr_ioh)) {\n\t\tprintf(\"ess: can't map SCR registers\\n\");\n\t\tbus_space_unmap(iot, scr_access_ioh, ESS_SCR_ACCESS_PORTS);\n\t\treturn (1);\n\t}\n\n\t/* Unlock the SCR. */\n\tEWRITE1(iot, scr_access_ioh, ESS_SCR_UNLOCK, 0);\n\n\t/* Write the base address information into SCR[0]. */\n\tEWRITE1(iot, scr_ioh, ESS_SCR_INDEX, 0);\n\tEWRITE1(iot, scr_ioh, ESS_SCR_DATA, scr_value);\n\t\n\t/* Lock the SCR. */\n\tEWRITE1(iot, scr_access_ioh, ESS_SCR_LOCK, 0);\n\n\t/* Unmap the SCR access ports and the SCR data ports. */\n\tbus_space_unmap(iot, scr_access_ioh, ESS_SCR_ACCESS_PORTS);\n\tbus_space_unmap(iot, scr_ioh, ESS_SCR_PORTS);\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tess_config_addr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "scr_ioh",
            "ESS_SCR_PORTS"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "scr_access_ioh",
            "ESS_SCR_ACCESS_PORTS"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE1",
          "args": [
            "iot",
            "scr_access_ioh",
            "ESS_SCR_LOCK",
            "0"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE1",
          "args": [
            "iot",
            "scr_ioh",
            "ESS_SCR_DATA",
            "scr_value"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE1",
          "args": [
            "iot",
            "scr_ioh",
            "ESS_SCR_INDEX",
            "0"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE1",
          "args": [
            "iot",
            "scr_access_ioh",
            "ESS_SCR_UNLOCK",
            "0"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "scr_access_ioh",
            "ESS_SCR_ACCESS_PORTS"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ess: can't map SCR registers\\n\""
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "ESS_SCR_BASE",
            "ESS_SCR_PORTS",
            "0",
            "&scr_ioh"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "ESS_SCR_ACCESS_BASE",
            "ESS_SCR_ACCESS_PORTS",
            "0",
            "&scr_access_ioh"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_config_addr;\n\nint\ness_config_addr(sc)\n\tstruct ess_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tbus_space_tag_t iot = sc->sc_iot;\n\n\t/*\n\t * Configure using the System Control Register method.  This\n\t * method is used when the AMODE line is tied high, which is\n\t * the case for the Shark, but not for the evaluation board.\n\t */\n\n\tbus_space_handle_t scr_access_ioh;\n\tbus_space_handle_t scr_ioh;\n\tu_short scr_value;\n\n\t/*\n\t * Set the SCR bit to enable audio.\n\t */\n\tscr_value = ESS_SCR_AUDIO_ENABLE;\n\n\t/*\n\t * Set the SCR bits necessary to select the specified audio\n\t * base address.\n\t */\n\tswitch(iobase) {\n\tcase 0x220:\n\t\tscr_value |= ESS_SCR_AUDIO_220;\n\t\tbreak;\n\tcase 0x230:\n\t\tscr_value |= ESS_SCR_AUDIO_230;\n\t\tbreak;\n\tcase 0x240:\n\t\tscr_value |= ESS_SCR_AUDIO_240;\n\t\tbreak;\n\tcase 0x250:\n\t\tscr_value |= ESS_SCR_AUDIO_250;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"ess: configured iobase 0x%x invalid\\n\", iobase);\n\t\treturn (1);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Get a mapping for the System Control Register (SCR) access\n\t * registers and the SCR data registers.\n\t */\n\tif (bus_space_map(iot, ESS_SCR_ACCESS_BASE, ESS_SCR_ACCESS_PORTS,\n\t\t\t  0, &scr_access_ioh)) {\n\t\tprintf(\"ess: can't map SCR access registers\\n\");\n\t\treturn (1);\n\t}\n\tif (bus_space_map(iot, ESS_SCR_BASE, ESS_SCR_PORTS,\n\t\t\t  0, &scr_ioh)) {\n\t\tprintf(\"ess: can't map SCR registers\\n\");\n\t\tbus_space_unmap(iot, scr_access_ioh, ESS_SCR_ACCESS_PORTS);\n\t\treturn (1);\n\t}\n\n\t/* Unlock the SCR. */\n\tEWRITE1(iot, scr_access_ioh, ESS_SCR_UNLOCK, 0);\n\n\t/* Write the base address information into SCR[0]. */\n\tEWRITE1(iot, scr_ioh, ESS_SCR_INDEX, 0);\n\tEWRITE1(iot, scr_ioh, ESS_SCR_DATA, scr_value);\n\t\n\t/* Lock the SCR. */\n\tEWRITE1(iot, scr_access_ioh, ESS_SCR_LOCK, 0);\n\n\t/* Unmap the SCR access ports and the SCR data ports. */\n\tbus_space_unmap(iot, scr_access_ioh, ESS_SCR_ACCESS_PORTS);\n\tbus_space_unmap(iot, scr_ioh, ESS_SCR_PORTS);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ess_dump_mixer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "300-344",
    "snippet": "void\ness_dump_mixer(sc)\n\tstruct ess_softc *sc;\n{\n\tprintf(\"ESS_DAC_PLAY_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x7C, ess_read_mix_reg(sc, 0x7C));\n\tprintf(\"ESS_MIC_PLAY_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x1A, ess_read_mix_reg(sc, 0x1A));\n\tprintf(\"ESS_LINE_PLAY_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x3E, ess_read_mix_reg(sc, 0x3E));\n\tprintf(\"ESS_SYNTH_PLAY_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x36, ess_read_mix_reg(sc, 0x36));\n\tprintf(\"ESS_CD_PLAY_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x38, ess_read_mix_reg(sc, 0x38));\n\tprintf(\"ESS_AUXB_PLAY_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x3A, ess_read_mix_reg(sc, 0x3A));\n\tprintf(\"ESS_MASTER_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x32, ess_read_mix_reg(sc, 0x32));\n\tprintf(\"ESS_PCSPEAKER_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x3C, ess_read_mix_reg(sc, 0x3C));\n\tprintf(\"ESS_DAC_REC_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x69, ess_read_mix_reg(sc, 0x69));\n\tprintf(\"ESS_MIC_REC_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x68, ess_read_mix_reg(sc, 0x68));\n\tprintf(\"ESS_LINE_REC_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x6E, ess_read_mix_reg(sc, 0x6E));\n\tprintf(\"ESS_SYNTH_REC_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x6B, ess_read_mix_reg(sc, 0x6B));\n\tprintf(\"ESS_CD_REC_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x6A, ess_read_mix_reg(sc, 0x6A));\n\tprintf(\"ESS_AUXB_REC_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x6C, ess_read_mix_reg(sc, 0x6C));\n\tprintf(\"ESS_RECORD_VOL: x reg 0x%02x=0x%02x\\n\",\n\t       0xB4, ess_read_x_reg(sc, 0xB4));\n\tprintf(\"Audio 1 play vol (unused): mix reg 0x%02x=0x%02x\\n\",\n\t       0x14, ess_read_mix_reg(sc, 0x14));\n\n\tprintf(\"ESS_MIC_PREAMP: x reg 0x%02x=0x%02x\\n\",\n\t       ESS_XCMD_PREAMP_CTRL, ess_read_x_reg(sc, ESS_XCMD_PREAMP_CTRL));\n\tprintf(\"ESS_RECORD_MONITOR: x reg 0x%02x=0x%02x\\n\",\n\t       ESS_XCMD_AUDIO_CTRL, ess_read_x_reg(sc, ESS_XCMD_AUDIO_CTRL));\n\tprintf(\"Record source: mix reg 0x%02x=0x%02x, 0x%02x=0x%02x\\n\",\n\t       ESS_MREG_ADC_SOURCE, ess_read_mix_reg(sc, ESS_MREG_ADC_SOURCE),\n\t       ESS_MREG_AUDIO2_CTRL2, ess_read_mix_reg(sc, ESS_MREG_AUDIO2_CTRL2));\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_char\tess_read_x_reg",
      "u_char\tess_read_mix_reg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Record source: mix reg 0x%02x=0x%02x, 0x%02x=0x%02x\\n\"",
            "ESS_MREG_ADC_SOURCE",
            "ess_read_mix_reg(sc, ESS_MREG_ADC_SOURCE)",
            "ESS_MREG_AUDIO2_CTRL2",
            "ess_read_mix_reg(sc, ESS_MREG_AUDIO2_CTRL2)"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_read_mix_reg",
          "args": [
            "sc",
            "ESS_MREG_AUDIO2_CTRL2"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "ess_read_mix_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2641-2658",
          "snippet": "u_char\ness_read_mix_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\tu_char val;\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tval = EREAD1(iot, ioh, ESS_MIX_REG_DATA);\n\tsplx(s);\n\n\tDPRINTFN(2,(\"ess_read_mix_reg: %x=%x\\n\", reg, val));\n\treturn val;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_char\tess_read_mix_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_mix_reg;\n\nu_char\ness_read_mix_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint s;\n\tu_char val;\n\n\ts = splaudio();\n\tEWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);\n\tval = EREAD1(iot, ioh, ESS_MIX_REG_DATA);\n\tsplx(s);\n\n\tDPRINTFN(2,(\"ess_read_mix_reg: %x=%x\\n\", reg, val));\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ess_read_x_reg",
          "args": [
            "sc",
            "ESS_XCMD_AUDIO_CTRL"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "ess_read_x_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "2576-2592",
          "snippet": "u_char\ness_read_x_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tint error;\n\tint val;\n\n\tif ((error = ess_wdsp(sc, 0xC0)) == 0)\n\t\terror = ess_wdsp(sc, reg);\n\tif (error)\n\t\tDPRINTF((\"Error reading extended register 0x%02x\\n\", reg));\n/* REVISIT: what if an error is returned above? */\n\tval = ess_rdsp(sc);\n\tDPRINTFN(2,(\"ess_read_x_reg: %02x=%02x\\n\", reg, val));\n\treturn val;\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_rdsp",
            "int\tess_wdsp",
            "u_char\tess_read_x_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_rdsp;\nint\tess_wdsp;\nu_char\tess_read_x_reg;\n\nu_char\ness_read_x_reg(sc, reg)\n\tstruct ess_softc *sc;\n\tu_char reg;\n{\n\tint error;\n\tint val;\n\n\tif ((error = ess_wdsp(sc, 0xC0)) == 0)\n\t\terror = ess_wdsp(sc, reg);\n\tif (error)\n\t\tDPRINTF((\"Error reading extended register 0x%02x\\n\", reg));\n/* REVISIT: what if an error is returned above? */\n\tval = ess_rdsp(sc);\n\tDPRINTFN(2,(\"ess_read_x_reg: %02x=%02x\\n\", reg, val));\n\treturn val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_char\tess_read_x_reg;\nu_char\tess_read_mix_reg;\n\nvoid\ness_dump_mixer(sc)\n\tstruct ess_softc *sc;\n{\n\tprintf(\"ESS_DAC_PLAY_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x7C, ess_read_mix_reg(sc, 0x7C));\n\tprintf(\"ESS_MIC_PLAY_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x1A, ess_read_mix_reg(sc, 0x1A));\n\tprintf(\"ESS_LINE_PLAY_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x3E, ess_read_mix_reg(sc, 0x3E));\n\tprintf(\"ESS_SYNTH_PLAY_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x36, ess_read_mix_reg(sc, 0x36));\n\tprintf(\"ESS_CD_PLAY_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x38, ess_read_mix_reg(sc, 0x38));\n\tprintf(\"ESS_AUXB_PLAY_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x3A, ess_read_mix_reg(sc, 0x3A));\n\tprintf(\"ESS_MASTER_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x32, ess_read_mix_reg(sc, 0x32));\n\tprintf(\"ESS_PCSPEAKER_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x3C, ess_read_mix_reg(sc, 0x3C));\n\tprintf(\"ESS_DAC_REC_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x69, ess_read_mix_reg(sc, 0x69));\n\tprintf(\"ESS_MIC_REC_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x68, ess_read_mix_reg(sc, 0x68));\n\tprintf(\"ESS_LINE_REC_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x6E, ess_read_mix_reg(sc, 0x6E));\n\tprintf(\"ESS_SYNTH_REC_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x6B, ess_read_mix_reg(sc, 0x6B));\n\tprintf(\"ESS_CD_REC_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x6A, ess_read_mix_reg(sc, 0x6A));\n\tprintf(\"ESS_AUXB_REC_VOL: mix reg 0x%02x=0x%02x\\n\",\n\t       0x6C, ess_read_mix_reg(sc, 0x6C));\n\tprintf(\"ESS_RECORD_VOL: x reg 0x%02x=0x%02x\\n\",\n\t       0xB4, ess_read_x_reg(sc, 0xB4));\n\tprintf(\"Audio 1 play vol (unused): mix reg 0x%02x=0x%02x\\n\",\n\t       0x14, ess_read_mix_reg(sc, 0x14));\n\n\tprintf(\"ESS_MIC_PREAMP: x reg 0x%02x=0x%02x\\n\",\n\t       ESS_XCMD_PREAMP_CTRL, ess_read_x_reg(sc, ESS_XCMD_PREAMP_CTRL));\n\tprintf(\"ESS_RECORD_MONITOR: x reg 0x%02x=0x%02x\\n\",\n\t       ESS_XCMD_AUDIO_CTRL, ess_read_x_reg(sc, ESS_XCMD_AUDIO_CTRL));\n\tprintf(\"Record source: mix reg 0x%02x=0x%02x, 0x%02x=0x%02x\\n\",\n\t       ESS_MREG_ADC_SOURCE, ess_read_mix_reg(sc, ESS_MREG_ADC_SOURCE),\n\t       ESS_MREG_AUDIO2_CTRL2, ess_read_mix_reg(sc, ESS_MREG_AUDIO2_CTRL2));\n}"
  },
  {
    "function_name": "ess_printsc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
    "lines": "274-298",
    "snippet": "void\ness_printsc(sc)\n\tstruct ess_softc *sc;\n{\n\tint i;\n    \n\tprintf(\"open %d iobase 0x%x outport %u inport %u speaker %s\\n\",\n\t       (int)sc->sc_open, sc->sc_iobase, sc->out_port,\n\t       sc->in_port, sc->spkr_state ? \"on\" : \"off\");\n\n\tprintf(\"audio1: dmachan %d irq %d nintr %lu intr %p arg %p\\n\",\n\t       sc->sc_audio1.drq, sc->sc_audio1.irq, sc->sc_audio1.nintr,\n\t       sc->sc_audio1.intr, sc->sc_audio1.arg);\n\n\tif (!ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tprintf(\"audio2: dmachan %d irq %d nintr %lu intr %p arg %p\\n\",\n\t\t       sc->sc_audio2.drq, sc->sc_audio2.irq, sc->sc_audio2.nintr,\n\t\t       sc->sc_audio2.intr, sc->sc_audio2.arg);\n\t}\n\n\tprintf(\"gain:\");\n\tfor (i = 0; i < sc->ndevs; i++)\n\t\tprintf(\" %u,%u\", sc->gain[i][ESS_LEFT], sc->gain[i][ESS_RIGHT]);\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESS_USE_AUDIO1",
          "args": [
            "sc->sc_model"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ness_printsc(sc)\n\tstruct ess_softc *sc;\n{\n\tint i;\n    \n\tprintf(\"open %d iobase 0x%x outport %u inport %u speaker %s\\n\",\n\t       (int)sc->sc_open, sc->sc_iobase, sc->out_port,\n\t       sc->in_port, sc->spkr_state ? \"on\" : \"off\");\n\n\tprintf(\"audio1: dmachan %d irq %d nintr %lu intr %p arg %p\\n\",\n\t       sc->sc_audio1.drq, sc->sc_audio1.irq, sc->sc_audio1.nintr,\n\t       sc->sc_audio1.intr, sc->sc_audio1.arg);\n\n\tif (!ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tprintf(\"audio2: dmachan %d irq %d nintr %lu intr %p arg %p\\n\",\n\t\t       sc->sc_audio2.drq, sc->sc_audio2.irq, sc->sc_audio2.nintr,\n\t\t       sc->sc_audio2.intr, sc->sc_audio2.arg);\n\t}\n\n\tprintf(\"gain:\");\n\tfor (i = 0; i < sc->ndevs; i++)\n\t\tprintf(\" %u,%u\", sc->gain[i][ESS_LEFT], sc->gain[i][ESS_RIGHT]);\n\tprintf(\"\\n\");\n}"
  }
]