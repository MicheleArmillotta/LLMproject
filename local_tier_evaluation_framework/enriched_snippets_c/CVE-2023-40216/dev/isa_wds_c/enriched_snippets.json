[
  {
    "function_name": "wds_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "1399-1450",
    "snippet": "void\nwds_timeout(arg)\n\tvoid *arg;\n{\n\tstruct wds_scb *scb = arg;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_link *sc_link;\n\tstruct wds_softc *sc;\n\tint s;\n\n\ts = splbio();\n#ifdef notyet\n\tisadma_copyfrombuf((caddr_t)scb, SCB_PHYS_SIZE, 1, scb->scb_phys);\n#endif\n\txs = scb->xs;\n\tsc_link = xs->sc_link;\n\tsc = sc_link->adapter_softc;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n#ifdef WDSDIAG\n\t/*\n\t * If The scb's mbx is not free, then the board has gone south?\n\t */\n\twds_collect_mbo(sc);\n\tif (scb->flags & SCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (scb->flags & SCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tscb->xs->error = XS_TIMEOUT;\n\t\tscb->timeout = WDS_ABORT_TIMEOUT;\n\t\tscb->flags |= SCB_ABORT;\n\t\twds_queue_scb(sc, scb);\n\t}\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tWDS_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
    ],
    "globals_used": [
      "wds_finish_scbs __P((struct wds_softc *));",
      "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
      "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
      "void\twds_queue_scb",
      "void\twds_collect_mbo",
      "void\twds_timeout",
      "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
      "int flags;",
      "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
      "int flags;",
      "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;",
      "u_long scb_phys;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_queue_scb",
          "args": [
            "sc",
            "scb"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "wds_queue_scb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "653-661",
          "snippet": "void\nwds_queue_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_scb, scb, chain);\n\twds_start_scbs(sc);\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wds_finish_scbs __P((struct wds_softc *));",
            "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
            "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
            "void\twds_queue_scb",
            "void\twds_start_scbs",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nvoid\twds_queue_scb;\nvoid\twds_start_scbs;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nvoid\nwds_queue_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_scb, scb, chain);\n\twds_start_scbs(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debugger",
          "args": [],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_collect_mbo",
          "args": [
            "sc"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "wds_collect_mbo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "666-691",
          "snippet": "void\nwds_collect_mbo(sc)\n\tstruct wds_softc *sc;\n{\n\tstruct wds_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef WDSDIAG\n\tstruct wds_scb *scb;\n#endif\n\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != WDS_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef WDSDIAG\n\t\tscb = wds_scb_phys_kv(sc, phystol(wmbo->scb_addr));\n\t\tscb->flags &= ~SCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\twds_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\twmbx\t(&sc->sc_mbx)"
          ],
          "globals_used": [
            "wds_finish_scbs __P((struct wds_softc *));",
            "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
            "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
            "struct\twds_scb *wds_scb_phys_kv",
            "void\twds_collect_mbo",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(&sc->sc_mbx)\n\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nstruct\twds_scb *wds_scb_phys_kv;\nvoid\twds_collect_mbo;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nvoid\nwds_collect_mbo(sc)\n\tstruct wds_softc *sc;\n{\n\tstruct wds_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef WDSDIAG\n\tstruct wds_scb *scb;\n#endif\n\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != WDS_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef WDSDIAG\n\t\tscb = wds_scb_phys_kv(sc, phystol(wmbo->scb_addr));\n\t\tscb->flags &= ~SCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\twds_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "sc_link"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_copyfrombuf",
          "args": [
            "(caddr_t)scb",
            "SCB_PHYS_SIZE",
            "1",
            "scb->scb_phys"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tWDS_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nvoid\twds_queue_scb;\nvoid\twds_collect_mbo;\nvoid\twds_timeout;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\nu_long scb_phys;\n\nvoid\nwds_timeout(arg)\n\tvoid *arg;\n{\n\tstruct wds_scb *scb = arg;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_link *sc_link;\n\tstruct wds_softc *sc;\n\tint s;\n\n\ts = splbio();\n#ifdef notyet\n\tisadma_copyfrombuf((caddr_t)scb, SCB_PHYS_SIZE, 1, scb->scb_phys);\n#endif\n\txs = scb->xs;\n\tsc_link = xs->sc_link;\n\tsc = sc_link->adapter_softc;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n#ifdef WDSDIAG\n\t/*\n\t * If The scb's mbx is not free, then the board has gone south?\n\t */\n\twds_collect_mbo(sc);\n\tif (scb->flags & SCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (scb->flags & SCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tscb->xs->error = XS_TIMEOUT;\n\t\tscb->timeout = WDS_ABORT_TIMEOUT;\n\t\tscb->flags |= SCB_ABORT;\n\t\twds_queue_scb(sc, scb);\n\t}\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "wds_ipoll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "1374-1397",
    "snippet": "int\nwds_ipoll(sc, scb, count)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n\tint count;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_IRQ)\n\t\t\twdsintr(sc);\n\t\tif (scb->flags & SCB_DONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
      "wds_finish_scbs __P((struct wds_softc *));",
      "int     wdsintr",
      "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
      "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
      "int\twds_ipoll",
      "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
      "int flags;",
      "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
      "int flags;",
      "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdsintr",
          "args": [
            "sc"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "wdsintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "398-433",
          "snippet": "int\nwdsintr(arg)\n\tvoid *arg;\n{\n\tstruct wds_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_char c;\n\n\t/* Was it really an interrupt from the board? */\n\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_IRQ) == 0)\n\t\treturn 0;\n\n\t/* Get the interrupt status byte. */\n\tc = bus_space_read_1(iot, ioh, WDS_IRQSTAT) & WDSI_MASK;\n\n\t/* Acknowledge (which resets) the interrupt. */\n\tbus_space_write_1(iot, ioh, WDS_IRQACK, 0x00);\n\n\tswitch (c) {\n\tcase WDSI_MSVC:\n\t\twds_finish_scbs(sc);\n\t\tbreak;\n\n\tcase WDSI_MFREE:\n\t\twds_start_scbs(sc);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: unrecognized interrupt type %02x\",\n\t\t    sc->sc_dev.dv_xname, c);\n\t\tbreak;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
            "wds_finish_scbs __P((struct wds_softc *));",
            "int     wdsintr",
            "void\twds_start_scbs",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nwds_finish_scbs __P((struct wds_softc *));\nint     wdsintr;\nvoid\twds_start_scbs;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nint\nwdsintr(arg)\n\tvoid *arg;\n{\n\tstruct wds_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_char c;\n\n\t/* Was it really an interrupt from the board? */\n\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_IRQ) == 0)\n\t\treturn 0;\n\n\t/* Get the interrupt status byte. */\n\tc = bus_space_read_1(iot, ioh, WDS_IRQSTAT) & WDSI_MASK;\n\n\t/* Acknowledge (which resets) the interrupt. */\n\tbus_space_write_1(iot, ioh, WDS_IRQACK, 0x00);\n\n\tswitch (c) {\n\tcase WDSI_MSVC:\n\t\twds_finish_scbs(sc);\n\t\tbreak;\n\n\tcase WDSI_MFREE:\n\t\twds_start_scbs(sc);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: unrecognized interrupt type %02x\",\n\t\t    sc->sc_dev.dv_xname, c);\n\t\tbreak;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "WDS_STAT"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nwds_finish_scbs __P((struct wds_softc *));\nint     wdsintr;\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nint\twds_ipoll;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nint\nwds_ipoll(sc, scb, count)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n\tint count;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_IRQ)\n\t\t\twdsintr(sc);\n\t\tif (scb->flags & SCB_DONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "wds_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "1346-1369",
    "snippet": "int\nwds_poll(sc, xs, count)\n\tstruct wds_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_IRQ)\n\t\t\twdsintr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
      "wds_finish_scbs __P((struct wds_softc *));",
      "int     wdsintr",
      "int\twds_poll",
      "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
      "int flags;",
      "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
      "int flags;",
      "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdsintr",
          "args": [
            "sc"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "wdsintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "398-433",
          "snippet": "int\nwdsintr(arg)\n\tvoid *arg;\n{\n\tstruct wds_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_char c;\n\n\t/* Was it really an interrupt from the board? */\n\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_IRQ) == 0)\n\t\treturn 0;\n\n\t/* Get the interrupt status byte. */\n\tc = bus_space_read_1(iot, ioh, WDS_IRQSTAT) & WDSI_MASK;\n\n\t/* Acknowledge (which resets) the interrupt. */\n\tbus_space_write_1(iot, ioh, WDS_IRQACK, 0x00);\n\n\tswitch (c) {\n\tcase WDSI_MSVC:\n\t\twds_finish_scbs(sc);\n\t\tbreak;\n\n\tcase WDSI_MFREE:\n\t\twds_start_scbs(sc);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: unrecognized interrupt type %02x\",\n\t\t    sc->sc_dev.dv_xname, c);\n\t\tbreak;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
            "wds_finish_scbs __P((struct wds_softc *));",
            "int     wdsintr",
            "void\twds_start_scbs",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nwds_finish_scbs __P((struct wds_softc *));\nint     wdsintr;\nvoid\twds_start_scbs;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nint\nwdsintr(arg)\n\tvoid *arg;\n{\n\tstruct wds_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_char c;\n\n\t/* Was it really an interrupt from the board? */\n\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_IRQ) == 0)\n\t\treturn 0;\n\n\t/* Get the interrupt status byte. */\n\tc = bus_space_read_1(iot, ioh, WDS_IRQSTAT) & WDSI_MASK;\n\n\t/* Acknowledge (which resets) the interrupt. */\n\tbus_space_write_1(iot, ioh, WDS_IRQACK, 0x00);\n\n\tswitch (c) {\n\tcase WDSI_MSVC:\n\t\twds_finish_scbs(sc);\n\t\tbreak;\n\n\tcase WDSI_MFREE:\n\t\twds_start_scbs(sc);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: unrecognized interrupt type %02x\",\n\t\t    sc->sc_dev.dv_xname, c);\n\t\tbreak;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "WDS_STAT"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nwds_finish_scbs __P((struct wds_softc *));\nint     wdsintr;\nint\twds_poll;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nint\nwds_poll(sc, xs, count)\n\tstruct wds_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_IRQ)\n\t\t\twdsintr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "wds_sense",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "1296-1341",
    "snippet": "void\nwds_sense(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct scsi_sense *ss = (void *)&scb->sense.scb;\n\tint s;\n\n\t/* XXXXX */\n\n\t/* Send sense request SCSI command. */\n\txs->error = XS_SENSE;\n\tscb->flags |= SCB_SENSE;\n\n\t/* First, save the return values */\n\tif (NEEDBUFFER(sc) && xs->datalen) {\n\t\tif (xs->flags & SCSI_DATA_IN)\n\t\t\tbcopy(scb->buf->data, xs->data, xs->datalen);\n\t}\n\n\t/* Next, setup a request sense command block */\n\tbzero(ss, sizeof(*ss));\n\tss->opcode = REQUEST_SENSE;\n\tss->byte2 = xs->sc_link->lun << 5;\n\tss->length = sizeof(struct scsi_sense_data);\n\n\t/* Set up some of the command fields. */\n\tscb->sense.targ = scb->cmd.targ;\n\tscb->sense.write = 0x80;\n\tscb->sense.opcode = WDSX_SCSICMD;\n\tltophys(KVTOPHYS(&scb->sense_data), scb->sense.data);\n\tltophys(sizeof(struct scsi_sense_data), scb->sense.len);\n\n\ts = splbio();\n\twds_queue_scb(sc, scb);\n\tsplx(s);\n\n\t/*\n\t * There's no reason for us to poll here.  There are two cases:\n\t * 1) If it's a polling operation, then we're called from the interrupt\n\t *    handler, and we return and continue polling.\n\t * 2) If it's an interrupt-driven operation, then it gets completed\n\t *    later on when the REQUEST SENSE finishes.\n\t */\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct wds_buf {\n\tu_char data[BUFLEN];\n\tint    busy;\n\tTAILQ_ENTRY(wds_buf) chain;\n} wds_buffer[BUFCNT];",
      "wds_finish_scbs __P((struct wds_softc *));",
      "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
      "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
      "void\twds_queue_scb",
      "void\twds_sense",
      "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
      "int flags;",
      "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
      "int flags;",
      "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_queue_scb",
          "args": [
            "sc",
            "scb"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "wds_queue_scb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "653-661",
          "snippet": "void\nwds_queue_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_scb, scb, chain);\n\twds_start_scbs(sc);\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wds_finish_scbs __P((struct wds_softc *));",
            "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
            "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
            "void\twds_queue_scb",
            "void\twds_start_scbs",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nvoid\twds_queue_scb;\nvoid\twds_start_scbs;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nvoid\nwds_queue_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_scb, scb, chain);\n\twds_start_scbs(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "sizeof(struct scsi_sense_data)",
            "scb->sense.len"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "KVTOPHYS(&scb->sense_data)",
            "scb->sense.data"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "&scb->sense_data"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "ss",
            "sizeof(*ss)"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "scb->buf->data",
            "xs->data",
            "xs->datalen"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NEEDBUFFER",
          "args": [
            "sc"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstruct wds_buf {\n\tu_char data[BUFLEN];\n\tint    busy;\n\tTAILQ_ENTRY(wds_buf) chain;\n} wds_buffer[BUFCNT];\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nvoid\twds_queue_scb;\nvoid\twds_sense;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nvoid\nwds_sense(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct scsi_sense *ss = (void *)&scb->sense.scb;\n\tint s;\n\n\t/* XXXXX */\n\n\t/* Send sense request SCSI command. */\n\txs->error = XS_SENSE;\n\tscb->flags |= SCB_SENSE;\n\n\t/* First, save the return values */\n\tif (NEEDBUFFER(sc) && xs->datalen) {\n\t\tif (xs->flags & SCSI_DATA_IN)\n\t\t\tbcopy(scb->buf->data, xs->data, xs->datalen);\n\t}\n\n\t/* Next, setup a request sense command block */\n\tbzero(ss, sizeof(*ss));\n\tss->opcode = REQUEST_SENSE;\n\tss->byte2 = xs->sc_link->lun << 5;\n\tss->length = sizeof(struct scsi_sense_data);\n\n\t/* Set up some of the command fields. */\n\tscb->sense.targ = scb->cmd.targ;\n\tscb->sense.write = 0x80;\n\tscb->sense.opcode = WDSX_SCSICMD;\n\tltophys(KVTOPHYS(&scb->sense_data), scb->sense.data);\n\tltophys(sizeof(struct scsi_sense_data), scb->sense.len);\n\n\ts = splbio();\n\twds_queue_scb(sc, scb);\n\tsplx(s);\n\n\t/*\n\t * There's no reason for us to poll here.  There are two cases:\n\t * 1) If it's a polling operation, then we're called from the interrupt\n\t *    handler, and we return and continue polling.\n\t * 2) If it's an interrupt-driven operation, then it gets completed\n\t *    later on when the REQUEST SENSE finishes.\n\t */\n}"
  },
  {
    "function_name": "wds_scsi_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "1041-1291",
    "snippet": "int\nwds_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct wds_softc *sc = sc_link->adapter_softc;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct wds_scb *scb;\n\tstruct wds_scat_gath *sg;\n\tint seg;\n\tu_long thiskv, thisphys, nextphys;\n\tint bytes_this_seg, bytes_this_page, datalen, flags;\n#ifdef TFS\n\tstruct iovec *iovp;\n#endif\n\tint s;\n#ifdef notyet\n\tint mflags;\n#endif\n\n\tif (xs->flags & SCSI_RESET) {\n\t\t/* XXX Fix me! */\n\t\tprintf(\"%s: reset!\\n\", sc->sc_dev.dv_xname);\n\t\twds_init(sc);\n\t\treturn COMPLETE;\n\t}\n\n\tflags = xs->flags;\n#ifdef notyet\n\tif (flags & SCSI_NOSLEEP)\n\t\tmflags = ISADMA_MAP_BOUNCE;\n\telse\n\t\tmflags = ISADMA_MAP_BOUNCE | ISADMA_MAP_WAITOK;\n#endif\n\tif ((scb = wds_get_scb(sc, flags, NEEDBUFFER(sc))) == NULL) {\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn TRY_AGAIN_LATER;\n\t}\n\tscb->xs = xs;\n\tscb->timeout = xs->timeout;\n\n\tif (xs->flags & SCSI_DATA_UIO) {\n\t\t/* XXX Fix me! */\n\t\t/* Let's not worry about UIO. There isn't any code for the *\n\t\t * non-SG boards anyway! */\n\t\tprintf(\"%s: UIO is untested and disabled!\\n\", sc->sc_dev.dv_xname);\n\t\tgoto bad;\n\t}\n\n\t/* Zero out the command structure. */\n\tbzero(&scb->cmd, sizeof scb->cmd);\n\tbcopy(xs->cmd, &scb->cmd.scb, xs->cmdlen < 12 ? xs->cmdlen : 12);\n\n\t/* Set up some of the command fields. */\n\tscb->cmd.targ = (xs->sc_link->target << 5) | xs->sc_link->lun;\n\n\t/* NOTE: cmd.write may be OK as 0x40 (disable direction checking)\n\t * on boards other than the WD-7000V-ASE. Need this for the ASE:\n \t */\n\tscb->cmd.write = (xs->flags & SCSI_DATA_IN) ? 0x80 : 0x00;\n\n\tif (!NEEDBUFFER(sc) && xs->datalen) {\n\t\tsg = scb->scat_gath;\n\t\tseg = 0;\n#ifdef TFS\n\t\tif (flags & SCSI_DATA_UIO) {\n\t\t\tiovp = ((struct uio *)xs->data)->uio_iov;\n\t\t\tdatalen = ((struct uio *)xs->data)->uio_iovcnt;\n\t\t\txs->datalen = 0;\n\t\t\twhile (datalen && seg < WDS_NSEG) {\n\t\t\t\tltophys(iovp->iov_base, sg->seg_addr);\n\t\t\t\tltophys(iovp->iov_len, sg->seg_len);\n\t\t\t\txs->datalen += iovp->iov_len;\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"UIO(0x%x@0x%x)\",\n\t\t\t\t    iovp->iov_len, iovp->iov_base));\n\t\t\t\tsg++;\n\t\t\t\tiovp++;\n\t\t\t\tseg++;\n\t\t\t\tdatalen--;\n\t\t\t}\n\t\t} else\n#endif /* TFS */\n\t\t{\n\t\t\t/*\n\t\t\t * Set up the scatter-gather block.\n\t\t\t */\n\t\t\tSC_DEBUG(sc_link, SDEV_DB4,\n\t\t\t    (\"%d @0x%x:- \", xs->datalen, xs->data));\n\n#ifdef notyet\n\t\t\tscb->data_nseg = isadma_map(xs->data, xs->datalen,\n\t\t\t\t\t\t    scb->data_phys, mflags);\n\t\t\tfor (seg = 0; seg < scb->data_nseg; seg++) {\n\t\t\t\tltophys(scb->data_phys[seg].addr,\n\t\t\t\t       sg[seg].seg_addr);\n\t\t\t\tltophys(scb->data_phys[seg].length,\n\t\t\t\t       sg[seg].seg_len);\n\t\t\t}\n#else\n\t\t\tdatalen = xs->datalen;\n\t\t\tthiskv = (int)xs->data;\n\t\t\tthisphys = KVTOPHYS(xs->data);\n\n\t\t\twhile (datalen && seg < WDS_NSEG) {\n\t\t\t\tbytes_this_seg = 0;\n\n\t\t\t\t/* put in the base address */\n\t\t\t\tltophys(thisphys, sg->seg_addr);\n\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"0x%x\", thisphys));\n\n\t\t\t\t/* do it at least once */\n\t\t\t\tnextphys = thisphys;\n\t\t\t\twhile (datalen && thisphys == nextphys) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This page is contiguous (physically)\n\t\t\t\t\t * with the the last, just extend the\n\t\t\t\t\t * length\n\t\t\t\t\t */\n\t\t\t\t\t/* check it fits on the ISA bus */\n\t\t\t\t\tif (thisphys > 0xFFFFFF) {\n\t\t\t\t\t\tprintf(\"%s: DMA beyond\"\n\t\t\t\t\t\t\t\" end of ISA\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t\t/* how far to the end of the page */\n\t\t\t\t\tnextphys = (thisphys & ~PGOFSET) + NBPG;\n\t\t\t\t\tbytes_this_page = nextphys - thisphys;\n\t\t\t\t\t/**** or the data ****/\n\t\t\t\t\tbytes_this_page = min(bytes_this_page,\n\t\t\t\t\t\t\t      datalen);\n\t\t\t\t\tbytes_this_seg += bytes_this_page;\n\t\t\t\t\tdatalen -= bytes_this_page;\n\n\t\t\t\t\t/* get more ready for the next page */\n\t\t\t\t\tthiskv = (thiskv & ~PGOFSET) + NBPG;\n\t\t\t\t\tif (datalen)\n\t\t\t\t\t\tthisphys = KVTOPHYS(thiskv);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * next page isn't contiguous, finish the seg\n\t\t\t\t */\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4,\n\t\t\t\t    (\"(0x%x)\", bytes_this_seg));\n\t\t\t\tltophys(bytes_this_seg, sg->seg_len);\n\t\t\t\tsg++;\n\t\t\t\tseg++;\n#endif\n\t\t\t}\n\t\t}\n\t\t/* end of iov/kv decision */\n\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"\\n\"));\n\t\tif (datalen) {\n\t\t\t/*\n\t\t\t * there's still data, must have run out of segs!\n\t\t\t */\n\t\t\tprintf(\"%s: wds_scsi_cmd, more than %d dma segs\\n\",\n\t\t\t    sc->sc_dev.dv_xname, WDS_NSEG);\n\t\t\tgoto bad;\n\t\t}\n#ifdef notyet\n\t\tif (scb->data_nseg == 0) {\n\t\t\tprintf(\"%s: wds_scsi_cmd, cannot map\\n\",\n\t\t\t       sc->sc_dev.dv_xname);\n\t\t\tgoto bad;\n\t\t} else if (flags & SCSI_DATA_OUT)\n\t\t\tisadma_copytobuf(xs->data, xs->datalen,\n\t\t\t\t\t scb->data_nseg, scb->data_phys);\n\t\tltophys((unsigned)((struct wds_scb *)(scb->scb_phys[0].addr))->scat_gath,\n\t\t\tscb->data_addr);\n\t\tltophys(scb->data_nseg * sizeof(struct wds_scat_gath),\n\t\t\tscb->data_length);\n#else\n\t\tscb->cmd.opcode = WDSX_SCSISG;\n\t\tltophys(KVTOPHYS(scb->scat_gath), scb->cmd.data);\n\t\tltophys(seg * sizeof(struct wds_scat_gath), scb->cmd.len);\n#endif\n\t} else if (xs->datalen > 0) {\n\t\t/* The board is an ASC or ASE. Do not use scatter/gather. */\n\t\tif (xs->datalen > BUFLEN) {\n\t\t\tprintf(\"%s: wds_scsi_cmd, I/O too large for bounce buffer\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (xs->flags & SCSI_DATA_OUT)\n\t\t\tbcopy(xs->data, scb->buf->data, xs->datalen);\n\t\telse\n\t\t\tbzero(scb->buf->data, xs->datalen);\n\t\tscb->cmd.opcode = WDSX_SCSICMD;\n\t\tltophys(KVTOPHYS(scb->buf->data), scb->cmd.data);\n\t\tltophys(xs->datalen, scb->cmd.len);\n\t} else {\n\t\tscb->cmd.opcode = WDSX_SCSICMD;\n\t\tltophys(0, scb->cmd.data);\n\t\tltophys(0, scb->cmd.len);\n\t}\n\n\tscb->cmd.stat = 0x00;\n\tscb->cmd.venderr = 0x00;\n\tltophys(0, scb->cmd.link);\n\n\t/* XXX Do we really want to do this? */\n\tif (flags & SCSI_POLL) {\n\t\t/* Will poll card, await result. */\n\t\tbus_space_write_1(iot, ioh, WDS_HCR, WDSH_DRQEN);\n\t\tscb->flags |= SCB_POLLED;\n\t} else {\n\t\t/* Will send command, let interrupt routine handle result. */\n\t\tbus_space_write_1(iot, ioh, WDS_HCR, WDSH_IRQEN | WDSH_DRQEN);\n\t}\n\n\ts = splbio();\n\twds_queue_scb(sc, scb);\n\n#ifdef notyet\n\tif (VOLATILE_XS(xs)) {\n\t\twhile ((scb->xs->flags & ITSDONE) == 0) {\n\t\t\ttsleep(scb, PRIBIO, \"wdswait\", 0);\n\t\t}\n\t\tif (scb->data_nseg) {\n\t\t\tif (flags & SCSI_DATA_IN)\n\t\t\t\tisadma_copyfrombuf(xs->data, xs->datalen,\n\t\t\t\t    scb->data_nseg, scb->data_phys);\n\t\t\tisadma_unmap(xs->data, xs->datalen,\n\t\t\t    scb->data_nseg, scb->data_phys);\n\t\t}\n\t\twds_free_scb(sc, scb);\n\t\tscsi_done(xs);\n\t\tsplx(s);\n\t\treturn COMPLETE;\n\t}\n#endif\n\tsplx(s);\n\n\tif ((flags & SCSI_POLL) == 0)\n\t\treturn SUCCESSFULLY_QUEUED;\n\n\tif (wds_poll(sc, xs, scb->timeout)) {\n\t\twds_timeout(scb);\n\t\tif (wds_poll(sc, xs, scb->timeout))\n\t\t\twds_timeout(scb);\n\t}\n\treturn COMPLETE;\n\nbad:\n\txs->error = XS_DRIVER_STUFFUP;\n\twds_free_scb(sc, scb);\n\treturn COMPLETE;\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define BUFLEN (64*1024)"
    ],
    "globals_used": [
      "struct wds_buf {\n\tu_char data[BUFLEN];\n\tint    busy;\n\tTAILQ_ENTRY(wds_buf) chain;\n} wds_buffer[BUFCNT];",
      "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
      "wds_finish_scbs __P((struct wds_softc *));",
      "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
      "void    wds_free_scb",
      "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
      "struct\twds_scb *wds_get_scb",
      "void\twds_queue_scb",
      "void\twds_init",
      "int     wds_scsi_cmd",
      "int\twds_poll",
      "void\twds_timeout",
      "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
      "int flags;",
      "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
      "int flags;",
      "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;",
      "u_long scb_phys;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wds_free_scb",
          "args": [
            "sc",
            "scb"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "wds_free_scb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "447-477",
          "snippet": "void\nwds_free_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\tint s;\n\n\tif (scb->buf != 0) {\n\t\twds_free_buf(sc, scb->buf);\n\t\tscb->buf = 0;\n\t}\n\n\ts = splbio();\n\n#ifdef notyet\n\tif (scb->scb_phys[0].addr)\n\t        isadma_unmap((caddr_t)scb, SCB_PHYS_SIZE, 1, scb->scb_phys);\n#endif\n\n\twds_reset_scb(sc, scb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_scb, scb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (scb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_scb);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wds_finish_scbs __P((struct wds_softc *));",
            "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
            "void    wds_free_scb",
            "void\twds_free_buf",
            "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;",
            "u_long scb_phys;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nvoid    wds_free_scb;\nvoid\twds_free_buf;\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\nu_long scb_phys;\n\nvoid\nwds_free_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\tint s;\n\n\tif (scb->buf != 0) {\n\t\twds_free_buf(sc, scb->buf);\n\t\tscb->buf = 0;\n\t}\n\n\ts = splbio();\n\n#ifdef notyet\n\tif (scb->scb_phys[0].addr)\n\t        isadma_unmap((caddr_t)scb, SCB_PHYS_SIZE, 1, scb->scb_phys);\n#endif\n\n\twds_reset_scb(sc, scb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_scb, scb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (scb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_scb);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wds_timeout",
          "args": [
            "scb"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "wds_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "1399-1450",
          "snippet": "void\nwds_timeout(arg)\n\tvoid *arg;\n{\n\tstruct wds_scb *scb = arg;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_link *sc_link;\n\tstruct wds_softc *sc;\n\tint s;\n\n\ts = splbio();\n#ifdef notyet\n\tisadma_copyfrombuf((caddr_t)scb, SCB_PHYS_SIZE, 1, scb->scb_phys);\n#endif\n\txs = scb->xs;\n\tsc_link = xs->sc_link;\n\tsc = sc_link->adapter_softc;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n#ifdef WDSDIAG\n\t/*\n\t * If The scb's mbx is not free, then the board has gone south?\n\t */\n\twds_collect_mbo(sc);\n\tif (scb->flags & SCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (scb->flags & SCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tscb->xs->error = XS_TIMEOUT;\n\t\tscb->timeout = WDS_ABORT_TIMEOUT;\n\t\tscb->flags |= SCB_ABORT;\n\t\twds_queue_scb(sc, scb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tWDS_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
          ],
          "globals_used": [
            "wds_finish_scbs __P((struct wds_softc *));",
            "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
            "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
            "void\twds_queue_scb",
            "void\twds_collect_mbo",
            "void\twds_timeout",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;",
            "u_long scb_phys;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tWDS_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nvoid\twds_queue_scb;\nvoid\twds_collect_mbo;\nvoid\twds_timeout;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\nu_long scb_phys;\n\nvoid\nwds_timeout(arg)\n\tvoid *arg;\n{\n\tstruct wds_scb *scb = arg;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_link *sc_link;\n\tstruct wds_softc *sc;\n\tint s;\n\n\ts = splbio();\n#ifdef notyet\n\tisadma_copyfrombuf((caddr_t)scb, SCB_PHYS_SIZE, 1, scb->scb_phys);\n#endif\n\txs = scb->xs;\n\tsc_link = xs->sc_link;\n\tsc = sc_link->adapter_softc;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n#ifdef WDSDIAG\n\t/*\n\t * If The scb's mbx is not free, then the board has gone south?\n\t */\n\twds_collect_mbo(sc);\n\tif (scb->flags & SCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (scb->flags & SCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tscb->xs->error = XS_TIMEOUT;\n\t\tscb->timeout = WDS_ABORT_TIMEOUT;\n\t\tscb->flags |= SCB_ABORT;\n\t\twds_queue_scb(sc, scb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wds_poll",
          "args": [
            "sc",
            "xs",
            "scb->timeout"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "wds_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "1346-1369",
          "snippet": "int\nwds_poll(sc, xs, count)\n\tstruct wds_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_IRQ)\n\t\t\twdsintr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
            "wds_finish_scbs __P((struct wds_softc *));",
            "int     wdsintr",
            "int\twds_poll",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nwds_finish_scbs __P((struct wds_softc *));\nint     wdsintr;\nint\twds_poll;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nint\nwds_poll(sc, xs, count)\n\tstruct wds_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_IRQ)\n\t\t\twdsintr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_unmap",
          "args": [
            "xs->data",
            "xs->datalen",
            "scb->data_nseg",
            "scb->data_phys"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_copyfrombuf",
          "args": [
            "xs->data",
            "xs->datalen",
            "scb->data_nseg",
            "scb->data_phys"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "scb",
            "PRIBIO",
            "\"wdswait\"",
            "0"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOLATILE_XS",
          "args": [
            "xs"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_queue_scb",
          "args": [
            "sc",
            "scb"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "wds_queue_scb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "653-661",
          "snippet": "void\nwds_queue_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_scb, scb, chain);\n\twds_start_scbs(sc);\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wds_finish_scbs __P((struct wds_softc *));",
            "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
            "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
            "void\twds_queue_scb",
            "void\twds_start_scbs",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nvoid\twds_queue_scb;\nvoid\twds_start_scbs;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nvoid\nwds_queue_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_scb, scb, chain);\n\twds_start_scbs(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "WDS_HCR",
            "WDSH_IRQEN | WDSH_DRQEN"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "WDS_HCR",
            "WDSH_DRQEN"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "0",
            "scb->cmd.link"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "0",
            "scb->cmd.len"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "0",
            "scb->cmd.data"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "xs->datalen",
            "scb->cmd.len"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "KVTOPHYS(scb->buf->data)",
            "scb->cmd.data"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "scb->buf->data"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "scb->buf->data",
            "xs->datalen"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "xs->data",
            "scb->buf->data",
            "xs->datalen"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: wds_scsi_cmd, I/O too large for bounce buffer\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "seg * sizeof(struct wds_scat_gath)",
            "scb->cmd.len"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "KVTOPHYS(scb->scat_gath)",
            "scb->cmd.data"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "scb->scat_gath"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "scb->data_nseg * sizeof(struct wds_scat_gath)",
            "scb->data_length"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "(unsigned)((struct wds_scb *)(scb->scb_phys[0].addr))->scat_gath",
            "scb->data_addr"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_copytobuf",
          "args": [
            "xs->data",
            "xs->datalen",
            "scb->data_nseg",
            "scb->data_phys"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUGN",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"\\n\")"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "bytes_this_seg",
            "sg->seg_len"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUGN",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"(0x%x)\", bytes_this_seg)"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "thiskv"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bytes_this_page",
            "datalen"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "wdsminphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "1029-1036",
          "snippet": "void\nwdsminphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > ((WDS_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((WDS_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void    wdsminphys"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid    wdsminphys;\n\nvoid\nwdsminphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > ((WDS_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((WDS_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SC_DEBUGN",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"0x%x\", thisphys)"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "thisphys",
            "sg->seg_addr"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "xs->data"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "scb->data_phys[seg].length",
            "sg[seg].seg_len"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "scb->data_phys[seg].addr",
            "sg[seg].seg_addr"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_map",
          "args": [
            "xs->data",
            "xs->datalen",
            "scb->data_phys",
            "mflags"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUG",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"%d @0x%x:- \", xs->datalen, xs->data)"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUGN",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"UIO(0x%x@0x%x)\",\n\t\t\t\t    iovp->iov_len, iovp->iov_base)"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "iovp->iov_len",
            "sg->seg_len"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "iovp->iov_base",
            "sg->seg_addr"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEEDBUFFER",
          "args": [
            "sc"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&scb->cmd",
            "sizeof scb->cmd"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_get_scb",
          "args": [
            "sc",
            "flags",
            "NEEDBUFFER(sc)"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEEDBUFFER",
          "args": [
            "sc"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_init",
          "args": [
            "sc"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "wds_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "923-978",
          "snippet": "void\nwds_init(sc)\n\tstruct wds_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct wds_setup init;\n\tu_char c;\n\tint i;\n#ifdef notyet\n\tstruct isadma_seg mbx_phys[1];\n#endif\n\n\t/*\n\t * Set up initial mail box for round-robin operation.\n\t */\n\tfor (i = 0; i < WDS_MBX_SIZE; i++) {\n\t\twmbx->mbo[i].cmd = WDS_MBO_FREE;\n\t\twmbx->mbi[i].stat = WDS_MBI_FREE;\n\t}\n\twmbx->cmbo = wmbx->tmbo = &wmbx->mbo[0];\n\twmbx->tmbi = &wmbx->mbi[0];\n\tsc->sc_mbofull = 0;\n\n\t/* Clear the buffers. */\n\tTAILQ_INIT(&wds_free_buffer);\n\tfor (i = 0; i < BUFCNT; i++) {\n\t\twds_buffer[i].busy = 0;\n\t\tTAILQ_INSERT_HEAD(&wds_free_buffer, &wds_buffer[i], chain);\n\t}\n\n\tinit.opcode = WDSC_INIT;\n\tinit.scsi_id = sc->sc_scsi_dev;\n\t/* Record scsi id of controller for use in scsi_attach */\n\tsc->sc_scsi_dev = init.scsi_id;\n\tinit.buson_t = 48;\n\tinit.busoff_t = 24;\n\tinit.xx = 0;\n#ifdef notyet\n\tif (isadma_map((caddr_t)(wmbx), sizeof(struct wds_mbx),\n\t    mbx_phys, ISADMA_MAP_CONTIG) != 1)\n\t\tpanic(\"wds_init: cannot map mail box\");\n\tltophys(mbx_phys[0].addr, init.mbaddr);\n#else\n\tltophys(KVTOPHYS(wmbx), init.mbaddr);\n#endif\n\tinit.nomb = init.nimb = WDS_MBX_SIZE;\n\twds_cmd(sc, (u_char *)&init, sizeof init);\n\n\twds_wait(iot, ioh, WDS_STAT, WDSS_INIT, WDSS_INIT);\n\n\tc = WDSC_DISUNSOL;\n\twds_cmd(sc, &c, sizeof c);\n\n\tbus_space_write_1(iot, ioh, WDS_HCR, WDSH_DRQEN);\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define BUFCNT 8",
            "#define\twmbx\t(&sc->sc_mbx)",
            "#define WDS_MBX_SIZE\t16"
          ],
          "globals_used": [
            "TAILQ_HEAD(, wds_buf) wds_free_buffer;",
            "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
            "int     wds_cmd",
            "wds_finish_scbs __P((struct wds_softc *));",
            "void\twds_init",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define BUFCNT 8\n#define\twmbx\t(&sc->sc_mbx)\n#define WDS_MBX_SIZE\t16\n\nTAILQ_HEAD(, wds_buf) wds_free_buffer;\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nint     wds_cmd;\nwds_finish_scbs __P((struct wds_softc *));\nvoid\twds_init;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nvoid\nwds_init(sc)\n\tstruct wds_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct wds_setup init;\n\tu_char c;\n\tint i;\n#ifdef notyet\n\tstruct isadma_seg mbx_phys[1];\n#endif\n\n\t/*\n\t * Set up initial mail box for round-robin operation.\n\t */\n\tfor (i = 0; i < WDS_MBX_SIZE; i++) {\n\t\twmbx->mbo[i].cmd = WDS_MBO_FREE;\n\t\twmbx->mbi[i].stat = WDS_MBI_FREE;\n\t}\n\twmbx->cmbo = wmbx->tmbo = &wmbx->mbo[0];\n\twmbx->tmbi = &wmbx->mbi[0];\n\tsc->sc_mbofull = 0;\n\n\t/* Clear the buffers. */\n\tTAILQ_INIT(&wds_free_buffer);\n\tfor (i = 0; i < BUFCNT; i++) {\n\t\twds_buffer[i].busy = 0;\n\t\tTAILQ_INSERT_HEAD(&wds_free_buffer, &wds_buffer[i], chain);\n\t}\n\n\tinit.opcode = WDSC_INIT;\n\tinit.scsi_id = sc->sc_scsi_dev;\n\t/* Record scsi id of controller for use in scsi_attach */\n\tsc->sc_scsi_dev = init.scsi_id;\n\tinit.buson_t = 48;\n\tinit.busoff_t = 24;\n\tinit.xx = 0;\n#ifdef notyet\n\tif (isadma_map((caddr_t)(wmbx), sizeof(struct wds_mbx),\n\t    mbx_phys, ISADMA_MAP_CONTIG) != 1)\n\t\tpanic(\"wds_init: cannot map mail box\");\n\tltophys(mbx_phys[0].addr, init.mbaddr);\n#else\n\tltophys(KVTOPHYS(wmbx), init.mbaddr);\n#endif\n\tinit.nomb = init.nimb = WDS_MBX_SIZE;\n\twds_cmd(sc, (u_char *)&init, sizeof init);\n\n\twds_wait(iot, ioh, WDS_STAT, WDSS_INIT, WDSS_INIT);\n\n\tc = WDSC_DISUNSOL;\n\twds_cmd(sc, &c, sizeof c);\n\n\tbus_space_write_1(iot, ioh, WDS_HCR, WDSH_DRQEN);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define BUFLEN (64*1024)\n\nstruct wds_buf {\n\tu_char data[BUFLEN];\n\tint    busy;\n\tTAILQ_ENTRY(wds_buf) chain;\n} wds_buffer[BUFCNT];\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nvoid    wds_free_scb;\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nstruct\twds_scb *wds_get_scb;\nvoid\twds_queue_scb;\nvoid\twds_init;\nint     wds_scsi_cmd;\nint\twds_poll;\nvoid\twds_timeout;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\nu_long scb_phys;\n\nint\nwds_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct wds_softc *sc = sc_link->adapter_softc;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct wds_scb *scb;\n\tstruct wds_scat_gath *sg;\n\tint seg;\n\tu_long thiskv, thisphys, nextphys;\n\tint bytes_this_seg, bytes_this_page, datalen, flags;\n#ifdef TFS\n\tstruct iovec *iovp;\n#endif\n\tint s;\n#ifdef notyet\n\tint mflags;\n#endif\n\n\tif (xs->flags & SCSI_RESET) {\n\t\t/* XXX Fix me! */\n\t\tprintf(\"%s: reset!\\n\", sc->sc_dev.dv_xname);\n\t\twds_init(sc);\n\t\treturn COMPLETE;\n\t}\n\n\tflags = xs->flags;\n#ifdef notyet\n\tif (flags & SCSI_NOSLEEP)\n\t\tmflags = ISADMA_MAP_BOUNCE;\n\telse\n\t\tmflags = ISADMA_MAP_BOUNCE | ISADMA_MAP_WAITOK;\n#endif\n\tif ((scb = wds_get_scb(sc, flags, NEEDBUFFER(sc))) == NULL) {\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn TRY_AGAIN_LATER;\n\t}\n\tscb->xs = xs;\n\tscb->timeout = xs->timeout;\n\n\tif (xs->flags & SCSI_DATA_UIO) {\n\t\t/* XXX Fix me! */\n\t\t/* Let's not worry about UIO. There isn't any code for the *\n\t\t * non-SG boards anyway! */\n\t\tprintf(\"%s: UIO is untested and disabled!\\n\", sc->sc_dev.dv_xname);\n\t\tgoto bad;\n\t}\n\n\t/* Zero out the command structure. */\n\tbzero(&scb->cmd, sizeof scb->cmd);\n\tbcopy(xs->cmd, &scb->cmd.scb, xs->cmdlen < 12 ? xs->cmdlen : 12);\n\n\t/* Set up some of the command fields. */\n\tscb->cmd.targ = (xs->sc_link->target << 5) | xs->sc_link->lun;\n\n\t/* NOTE: cmd.write may be OK as 0x40 (disable direction checking)\n\t * on boards other than the WD-7000V-ASE. Need this for the ASE:\n \t */\n\tscb->cmd.write = (xs->flags & SCSI_DATA_IN) ? 0x80 : 0x00;\n\n\tif (!NEEDBUFFER(sc) && xs->datalen) {\n\t\tsg = scb->scat_gath;\n\t\tseg = 0;\n#ifdef TFS\n\t\tif (flags & SCSI_DATA_UIO) {\n\t\t\tiovp = ((struct uio *)xs->data)->uio_iov;\n\t\t\tdatalen = ((struct uio *)xs->data)->uio_iovcnt;\n\t\t\txs->datalen = 0;\n\t\t\twhile (datalen && seg < WDS_NSEG) {\n\t\t\t\tltophys(iovp->iov_base, sg->seg_addr);\n\t\t\t\tltophys(iovp->iov_len, sg->seg_len);\n\t\t\t\txs->datalen += iovp->iov_len;\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"UIO(0x%x@0x%x)\",\n\t\t\t\t    iovp->iov_len, iovp->iov_base));\n\t\t\t\tsg++;\n\t\t\t\tiovp++;\n\t\t\t\tseg++;\n\t\t\t\tdatalen--;\n\t\t\t}\n\t\t} else\n#endif /* TFS */\n\t\t{\n\t\t\t/*\n\t\t\t * Set up the scatter-gather block.\n\t\t\t */\n\t\t\tSC_DEBUG(sc_link, SDEV_DB4,\n\t\t\t    (\"%d @0x%x:- \", xs->datalen, xs->data));\n\n#ifdef notyet\n\t\t\tscb->data_nseg = isadma_map(xs->data, xs->datalen,\n\t\t\t\t\t\t    scb->data_phys, mflags);\n\t\t\tfor (seg = 0; seg < scb->data_nseg; seg++) {\n\t\t\t\tltophys(scb->data_phys[seg].addr,\n\t\t\t\t       sg[seg].seg_addr);\n\t\t\t\tltophys(scb->data_phys[seg].length,\n\t\t\t\t       sg[seg].seg_len);\n\t\t\t}\n#else\n\t\t\tdatalen = xs->datalen;\n\t\t\tthiskv = (int)xs->data;\n\t\t\tthisphys = KVTOPHYS(xs->data);\n\n\t\t\twhile (datalen && seg < WDS_NSEG) {\n\t\t\t\tbytes_this_seg = 0;\n\n\t\t\t\t/* put in the base address */\n\t\t\t\tltophys(thisphys, sg->seg_addr);\n\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"0x%x\", thisphys));\n\n\t\t\t\t/* do it at least once */\n\t\t\t\tnextphys = thisphys;\n\t\t\t\twhile (datalen && thisphys == nextphys) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This page is contiguous (physically)\n\t\t\t\t\t * with the the last, just extend the\n\t\t\t\t\t * length\n\t\t\t\t\t */\n\t\t\t\t\t/* check it fits on the ISA bus */\n\t\t\t\t\tif (thisphys > 0xFFFFFF) {\n\t\t\t\t\t\tprintf(\"%s: DMA beyond\"\n\t\t\t\t\t\t\t\" end of ISA\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t\t/* how far to the end of the page */\n\t\t\t\t\tnextphys = (thisphys & ~PGOFSET) + NBPG;\n\t\t\t\t\tbytes_this_page = nextphys - thisphys;\n\t\t\t\t\t/**** or the data ****/\n\t\t\t\t\tbytes_this_page = min(bytes_this_page,\n\t\t\t\t\t\t\t      datalen);\n\t\t\t\t\tbytes_this_seg += bytes_this_page;\n\t\t\t\t\tdatalen -= bytes_this_page;\n\n\t\t\t\t\t/* get more ready for the next page */\n\t\t\t\t\tthiskv = (thiskv & ~PGOFSET) + NBPG;\n\t\t\t\t\tif (datalen)\n\t\t\t\t\t\tthisphys = KVTOPHYS(thiskv);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * next page isn't contiguous, finish the seg\n\t\t\t\t */\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4,\n\t\t\t\t    (\"(0x%x)\", bytes_this_seg));\n\t\t\t\tltophys(bytes_this_seg, sg->seg_len);\n\t\t\t\tsg++;\n\t\t\t\tseg++;\n#endif\n\t\t\t}\n\t\t}\n\t\t/* end of iov/kv decision */\n\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"\\n\"));\n\t\tif (datalen) {\n\t\t\t/*\n\t\t\t * there's still data, must have run out of segs!\n\t\t\t */\n\t\t\tprintf(\"%s: wds_scsi_cmd, more than %d dma segs\\n\",\n\t\t\t    sc->sc_dev.dv_xname, WDS_NSEG);\n\t\t\tgoto bad;\n\t\t}\n#ifdef notyet\n\t\tif (scb->data_nseg == 0) {\n\t\t\tprintf(\"%s: wds_scsi_cmd, cannot map\\n\",\n\t\t\t       sc->sc_dev.dv_xname);\n\t\t\tgoto bad;\n\t\t} else if (flags & SCSI_DATA_OUT)\n\t\t\tisadma_copytobuf(xs->data, xs->datalen,\n\t\t\t\t\t scb->data_nseg, scb->data_phys);\n\t\tltophys((unsigned)((struct wds_scb *)(scb->scb_phys[0].addr))->scat_gath,\n\t\t\tscb->data_addr);\n\t\tltophys(scb->data_nseg * sizeof(struct wds_scat_gath),\n\t\t\tscb->data_length);\n#else\n\t\tscb->cmd.opcode = WDSX_SCSISG;\n\t\tltophys(KVTOPHYS(scb->scat_gath), scb->cmd.data);\n\t\tltophys(seg * sizeof(struct wds_scat_gath), scb->cmd.len);\n#endif\n\t} else if (xs->datalen > 0) {\n\t\t/* The board is an ASC or ASE. Do not use scatter/gather. */\n\t\tif (xs->datalen > BUFLEN) {\n\t\t\tprintf(\"%s: wds_scsi_cmd, I/O too large for bounce buffer\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (xs->flags & SCSI_DATA_OUT)\n\t\t\tbcopy(xs->data, scb->buf->data, xs->datalen);\n\t\telse\n\t\t\tbzero(scb->buf->data, xs->datalen);\n\t\tscb->cmd.opcode = WDSX_SCSICMD;\n\t\tltophys(KVTOPHYS(scb->buf->data), scb->cmd.data);\n\t\tltophys(xs->datalen, scb->cmd.len);\n\t} else {\n\t\tscb->cmd.opcode = WDSX_SCSICMD;\n\t\tltophys(0, scb->cmd.data);\n\t\tltophys(0, scb->cmd.len);\n\t}\n\n\tscb->cmd.stat = 0x00;\n\tscb->cmd.venderr = 0x00;\n\tltophys(0, scb->cmd.link);\n\n\t/* XXX Do we really want to do this? */\n\tif (flags & SCSI_POLL) {\n\t\t/* Will poll card, await result. */\n\t\tbus_space_write_1(iot, ioh, WDS_HCR, WDSH_DRQEN);\n\t\tscb->flags |= SCB_POLLED;\n\t} else {\n\t\t/* Will send command, let interrupt routine handle result. */\n\t\tbus_space_write_1(iot, ioh, WDS_HCR, WDSH_IRQEN | WDSH_DRQEN);\n\t}\n\n\ts = splbio();\n\twds_queue_scb(sc, scb);\n\n#ifdef notyet\n\tif (VOLATILE_XS(xs)) {\n\t\twhile ((scb->xs->flags & ITSDONE) == 0) {\n\t\t\ttsleep(scb, PRIBIO, \"wdswait\", 0);\n\t\t}\n\t\tif (scb->data_nseg) {\n\t\t\tif (flags & SCSI_DATA_IN)\n\t\t\t\tisadma_copyfrombuf(xs->data, xs->datalen,\n\t\t\t\t    scb->data_nseg, scb->data_phys);\n\t\t\tisadma_unmap(xs->data, xs->datalen,\n\t\t\t    scb->data_nseg, scb->data_phys);\n\t\t}\n\t\twds_free_scb(sc, scb);\n\t\tscsi_done(xs);\n\t\tsplx(s);\n\t\treturn COMPLETE;\n\t}\n#endif\n\tsplx(s);\n\n\tif ((flags & SCSI_POLL) == 0)\n\t\treturn SUCCESSFULLY_QUEUED;\n\n\tif (wds_poll(sc, xs, scb->timeout)) {\n\t\twds_timeout(scb);\n\t\tif (wds_poll(sc, xs, scb->timeout))\n\t\t\twds_timeout(scb);\n\t}\n\treturn COMPLETE;\n\nbad:\n\txs->error = XS_DRIVER_STUFFUP;\n\twds_free_scb(sc, scb);\n\treturn COMPLETE;\n}"
  },
  {
    "function_name": "wdsminphys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "1029-1036",
    "snippet": "void\nwdsminphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > ((WDS_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((WDS_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void    wdsminphys"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "minphys",
          "args": [
            "bp"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "wdsminphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "1029-1036",
          "snippet": "void\nwdsminphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > ((WDS_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((WDS_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid    wdsminphys;\n\nvoid\nwdsminphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > ((WDS_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((WDS_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}"
  },
  {
    "function_name": "wds_inquire_setup_information",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "983-1027",
    "snippet": "void\nwds_inquire_setup_information(sc)\n\tstruct wds_softc *sc;\n{\n\tstruct wds_scb *scb;\n\tu_char *j;\n\tint s;\n\n\tif ((scb = wds_get_scb(sc, SCSI_NOSLEEP, 0)) == NULL) {\n\t\tprintf(\"%s: no request slot available in getvers()!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\tscb->xs = NULL;\n\tscb->timeout = 40;\n\n\tbzero(&scb->cmd, sizeof scb->cmd);\n\tscb->cmd.write = 0x80;\n\tscb->cmd.opcode = WDSX_GETFIRMREV;\n\n\t/* Will poll card, await result. */\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, WDS_HCR, WDSH_DRQEN);\n\tscb->flags |= SCB_POLLED;\n\n\ts = splbio();\n\twds_queue_scb(sc, scb);\n\tsplx(s);\n\n\tif (wds_ipoll(sc, scb, scb->timeout))\n\t\tgoto out;\n\n\t/* Print the version number. */\n\tprintf(\": version %x.%02x \", scb->cmd.targ, scb->cmd.scb.opcode);\n\tsc->sc_revision = (scb->cmd.targ << 8) | scb->cmd.scb.opcode;\n\t/* Print out the version string. */\n\tj = 2 + &(scb->cmd.targ);\n\twhile ((*j >= 32) && (*j < 128)) {\n\t\tprintf(\"%c\", *j);\n\t\tj++;\n\t}\n\nout:\n\tprintf(\"\\n\");\n\twds_free_scb(sc, scb);\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "wds_finish_scbs __P((struct wds_softc *));",
      "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
      "void    wds_free_scb",
      "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
      "struct\twds_scb *wds_get_scb",
      "void\twds_queue_scb",
      "void\twds_inquire_setup_information",
      "int\twds_ipoll",
      "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
      "int flags;",
      "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
      "int flags;",
      "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wds_free_scb",
          "args": [
            "sc",
            "scb"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "wds_free_scb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "447-477",
          "snippet": "void\nwds_free_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\tint s;\n\n\tif (scb->buf != 0) {\n\t\twds_free_buf(sc, scb->buf);\n\t\tscb->buf = 0;\n\t}\n\n\ts = splbio();\n\n#ifdef notyet\n\tif (scb->scb_phys[0].addr)\n\t        isadma_unmap((caddr_t)scb, SCB_PHYS_SIZE, 1, scb->scb_phys);\n#endif\n\n\twds_reset_scb(sc, scb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_scb, scb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (scb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_scb);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wds_finish_scbs __P((struct wds_softc *));",
            "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
            "void    wds_free_scb",
            "void\twds_free_buf",
            "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;",
            "u_long scb_phys;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nvoid    wds_free_scb;\nvoid\twds_free_buf;\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\nu_long scb_phys;\n\nvoid\nwds_free_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\tint s;\n\n\tif (scb->buf != 0) {\n\t\twds_free_buf(sc, scb->buf);\n\t\tscb->buf = 0;\n\t}\n\n\ts = splbio();\n\n#ifdef notyet\n\tif (scb->scb_phys[0].addr)\n\t        isadma_unmap((caddr_t)scb, SCB_PHYS_SIZE, 1, scb->scb_phys);\n#endif\n\n\twds_reset_scb(sc, scb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_scb, scb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (scb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_scb);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wds_ipoll",
          "args": [
            "sc",
            "scb",
            "scb->timeout"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "wds_ipoll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "1374-1397",
          "snippet": "int\nwds_ipoll(sc, scb, count)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n\tint count;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_IRQ)\n\t\t\twdsintr(sc);\n\t\tif (scb->flags & SCB_DONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
            "wds_finish_scbs __P((struct wds_softc *));",
            "int     wdsintr",
            "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
            "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
            "int\twds_ipoll",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nwds_finish_scbs __P((struct wds_softc *));\nint     wdsintr;\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nint\twds_ipoll;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nint\nwds_ipoll(sc, scb, count)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n\tint count;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_IRQ)\n\t\t\twdsintr(sc);\n\t\tif (scb->flags & SCB_DONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_queue_scb",
          "args": [
            "sc",
            "scb"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "wds_queue_scb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "653-661",
          "snippet": "void\nwds_queue_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_scb, scb, chain);\n\twds_start_scbs(sc);\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wds_finish_scbs __P((struct wds_softc *));",
            "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
            "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
            "void\twds_queue_scb",
            "void\twds_start_scbs",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nvoid\twds_queue_scb;\nvoid\twds_start_scbs;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nvoid\nwds_queue_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_scb, scb, chain);\n\twds_start_scbs(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "WDS_HCR",
            "WDSH_DRQEN"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&scb->cmd",
            "sizeof scb->cmd"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_get_scb",
          "args": [
            "sc",
            "SCSI_NOSLEEP",
            "0"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nvoid    wds_free_scb;\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nstruct\twds_scb *wds_get_scb;\nvoid\twds_queue_scb;\nvoid\twds_inquire_setup_information;\nint\twds_ipoll;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nvoid\nwds_inquire_setup_information(sc)\n\tstruct wds_softc *sc;\n{\n\tstruct wds_scb *scb;\n\tu_char *j;\n\tint s;\n\n\tif ((scb = wds_get_scb(sc, SCSI_NOSLEEP, 0)) == NULL) {\n\t\tprintf(\"%s: no request slot available in getvers()!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\tscb->xs = NULL;\n\tscb->timeout = 40;\n\n\tbzero(&scb->cmd, sizeof scb->cmd);\n\tscb->cmd.write = 0x80;\n\tscb->cmd.opcode = WDSX_GETFIRMREV;\n\n\t/* Will poll card, await result. */\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, WDS_HCR, WDSH_DRQEN);\n\tscb->flags |= SCB_POLLED;\n\n\ts = splbio();\n\twds_queue_scb(sc, scb);\n\tsplx(s);\n\n\tif (wds_ipoll(sc, scb, scb->timeout))\n\t\tgoto out;\n\n\t/* Print the version number. */\n\tprintf(\": version %x.%02x \", scb->cmd.targ, scb->cmd.scb.opcode);\n\tsc->sc_revision = (scb->cmd.targ << 8) | scb->cmd.scb.opcode;\n\t/* Print out the version string. */\n\tj = 2 + &(scb->cmd.targ);\n\twhile ((*j >= 32) && (*j < 128)) {\n\t\tprintf(\"%c\", *j);\n\t\tj++;\n\t}\n\nout:\n\tprintf(\"\\n\");\n\twds_free_scb(sc, scb);\n}"
  },
  {
    "function_name": "wds_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "923-978",
    "snippet": "void\nwds_init(sc)\n\tstruct wds_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct wds_setup init;\n\tu_char c;\n\tint i;\n#ifdef notyet\n\tstruct isadma_seg mbx_phys[1];\n#endif\n\n\t/*\n\t * Set up initial mail box for round-robin operation.\n\t */\n\tfor (i = 0; i < WDS_MBX_SIZE; i++) {\n\t\twmbx->mbo[i].cmd = WDS_MBO_FREE;\n\t\twmbx->mbi[i].stat = WDS_MBI_FREE;\n\t}\n\twmbx->cmbo = wmbx->tmbo = &wmbx->mbo[0];\n\twmbx->tmbi = &wmbx->mbi[0];\n\tsc->sc_mbofull = 0;\n\n\t/* Clear the buffers. */\n\tTAILQ_INIT(&wds_free_buffer);\n\tfor (i = 0; i < BUFCNT; i++) {\n\t\twds_buffer[i].busy = 0;\n\t\tTAILQ_INSERT_HEAD(&wds_free_buffer, &wds_buffer[i], chain);\n\t}\n\n\tinit.opcode = WDSC_INIT;\n\tinit.scsi_id = sc->sc_scsi_dev;\n\t/* Record scsi id of controller for use in scsi_attach */\n\tsc->sc_scsi_dev = init.scsi_id;\n\tinit.buson_t = 48;\n\tinit.busoff_t = 24;\n\tinit.xx = 0;\n#ifdef notyet\n\tif (isadma_map((caddr_t)(wmbx), sizeof(struct wds_mbx),\n\t    mbx_phys, ISADMA_MAP_CONTIG) != 1)\n\t\tpanic(\"wds_init: cannot map mail box\");\n\tltophys(mbx_phys[0].addr, init.mbaddr);\n#else\n\tltophys(KVTOPHYS(wmbx), init.mbaddr);\n#endif\n\tinit.nomb = init.nimb = WDS_MBX_SIZE;\n\twds_cmd(sc, (u_char *)&init, sizeof init);\n\n\twds_wait(iot, ioh, WDS_STAT, WDSS_INIT, WDSS_INIT);\n\n\tc = WDSC_DISUNSOL;\n\twds_cmd(sc, &c, sizeof c);\n\n\tbus_space_write_1(iot, ioh, WDS_HCR, WDSH_DRQEN);\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define BUFCNT 8",
      "#define\twmbx\t(&sc->sc_mbx)",
      "#define WDS_MBX_SIZE\t16"
    ],
    "globals_used": [
      "TAILQ_HEAD(, wds_buf) wds_free_buffer;",
      "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
      "int     wds_cmd",
      "wds_finish_scbs __P((struct wds_softc *));",
      "void\twds_init",
      "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
      "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
      "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "WDS_HCR",
            "WDSH_DRQEN"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_cmd",
          "args": [
            "sc",
            "&c",
            "sizeof c"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "wds_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "218-239",
          "snippet": "int\nwds_cmd(sc, ibuf, icnt)\n\tstruct wds_softc *sc;\n\tu_int8_t *ibuf;\n\tint icnt;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int8_t c;\n\n\twds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);\n\n\twhile (icnt--) {\n\t\tbus_space_write_1(iot, ioh, WDS_CMD, *ibuf++);\n\t\twds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);\n\t\tc = bus_space_read_1(iot, ioh, WDS_STAT);\n\t\tif (c & WDSS_REJ)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
            "int     wds_cmd",
            "wds_finish_scbs __P((struct wds_softc *));",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nint     wds_cmd;\nwds_finish_scbs __P((struct wds_softc *));\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nint\nwds_cmd(sc, ibuf, icnt)\n\tstruct wds_softc *sc;\n\tu_int8_t *ibuf;\n\tint icnt;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int8_t c;\n\n\twds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);\n\n\twhile (icnt--) {\n\t\tbus_space_write_1(iot, ioh, WDS_CMD, *ibuf++);\n\t\twds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);\n\t\tc = bus_space_read_1(iot, ioh, WDS_STAT);\n\t\tif (c & WDSS_REJ)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wds_wait",
          "args": [
            "iot",
            "ioh",
            "WDS_STAT",
            "WDSS_INIT",
            "WDSS_INIT"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "wds_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "203-213",
          "snippet": "integrate void\nwds_wait(iot, ioh, port, mask, val)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint port;\n\tint mask;\n\tint val;\n{\n\twhile ((bus_space_read_1(iot, ioh, port) & mask) != val)\n\t\t;\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tintegrate\tstatic inline",
            "#define\tintegrate"
          ],
          "globals_used": [
            "integrate void",
            "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
            "integrate void",
            "integrate void",
            "integrate void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nintegrate void;\nintegrate void;\nintegrate void;\n\nintegrate void\nwds_wait(iot, ioh, port, mask, val)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint port;\n\tint mask;\n\tint val;\n{\n\twhile ((bus_space_read_1(iot, ioh, port) & mask) != val)\n\t\t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "KVTOPHYS(wmbx)",
            "init.mbaddr"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "wmbx"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "mbx_phys[0].addr",
            "init.mbaddr"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wds_init: cannot map mail box\""
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_map",
          "args": [
            "(caddr_t)(wmbx)",
            "sizeof(struct wds_mbx)",
            "mbx_phys",
            "ISADMA_MAP_CONTIG"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "wmbx"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&wds_free_buffer",
            "&wds_buffer[i]",
            "chain"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&wds_free_buffer"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define BUFCNT 8\n#define\twmbx\t(&sc->sc_mbx)\n#define WDS_MBX_SIZE\t16\n\nTAILQ_HEAD(, wds_buf) wds_free_buffer;\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nint     wds_cmd;\nwds_finish_scbs __P((struct wds_softc *));\nvoid\twds_init;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nvoid\nwds_init(sc)\n\tstruct wds_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct wds_setup init;\n\tu_char c;\n\tint i;\n#ifdef notyet\n\tstruct isadma_seg mbx_phys[1];\n#endif\n\n\t/*\n\t * Set up initial mail box for round-robin operation.\n\t */\n\tfor (i = 0; i < WDS_MBX_SIZE; i++) {\n\t\twmbx->mbo[i].cmd = WDS_MBO_FREE;\n\t\twmbx->mbi[i].stat = WDS_MBI_FREE;\n\t}\n\twmbx->cmbo = wmbx->tmbo = &wmbx->mbo[0];\n\twmbx->tmbi = &wmbx->mbi[0];\n\tsc->sc_mbofull = 0;\n\n\t/* Clear the buffers. */\n\tTAILQ_INIT(&wds_free_buffer);\n\tfor (i = 0; i < BUFCNT; i++) {\n\t\twds_buffer[i].busy = 0;\n\t\tTAILQ_INSERT_HEAD(&wds_free_buffer, &wds_buffer[i], chain);\n\t}\n\n\tinit.opcode = WDSC_INIT;\n\tinit.scsi_id = sc->sc_scsi_dev;\n\t/* Record scsi id of controller for use in scsi_attach */\n\tsc->sc_scsi_dev = init.scsi_id;\n\tinit.buson_t = 48;\n\tinit.busoff_t = 24;\n\tinit.xx = 0;\n#ifdef notyet\n\tif (isadma_map((caddr_t)(wmbx), sizeof(struct wds_mbx),\n\t    mbx_phys, ISADMA_MAP_CONTIG) != 1)\n\t\tpanic(\"wds_init: cannot map mail box\");\n\tltophys(mbx_phys[0].addr, init.mbaddr);\n#else\n\tltophys(KVTOPHYS(wmbx), init.mbaddr);\n#endif\n\tinit.nomb = init.nimb = WDS_MBX_SIZE;\n\twds_cmd(sc, (u_char *)&init, sizeof init);\n\n\twds_wait(iot, ioh, WDS_STAT, WDSS_INIT, WDSS_INIT);\n\n\tc = WDSC_DISUNSOL;\n\twds_cmd(sc, &c, sizeof c);\n\n\tbus_space_write_1(iot, ioh, WDS_HCR, WDSH_DRQEN);\n}"
  },
  {
    "function_name": "wds_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "851-918",
    "snippet": "int\nwds_find(ia, sc)\n\tstruct isa_attach_args *ia;\n\tstruct wds_softc *sc;\n{\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tu_char c;\n\tint i;\n\n\t/*\n\t * Sending a command causes the CMDRDY bit to clear.\n \t */\n\tc = bus_space_read_1(iot, ioh, WDS_STAT);\n\tfor (i = 0; i < 4; i++)\n\t\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_RDY) != 0) {\n\t\t\tgoto ready;\n\t\tdelay(10);\n\t}\n\treturn (0);\n\nready:\n\tbus_space_write_1(iot, ioh, WDS_CMD, WDSC_NOOP);\n\tif (bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_RDY)\n\t\treturn (0);\n\n\tbus_space_write_1(iot, ioh, WDS_HCR, WDSH_SCSIRESET|WDSH_ASCRESET);\n\tdelay(10000);\n\tbus_space_write_1(iot, ioh, WDS_HCR, 0x00);\n\tdelay(500000);\n\twds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);\n\tif (bus_space_read_1(iot, ioh, WDS_IRQSTAT) != 1)\n\t\tif (bus_space_read_1(iot, ioh, WDS_IRQSTAT) != 7)\n\t\t\tprintf(\"%s: failed reset!!! %2x\\n\",\n\t\t\t    sc ? sc->sc_dev.dv_xname : \"wds?\",\n\t\t\t    bus_space_read_1(iot, ioh, WDS_IRQSTAT));\n\n\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & (WDSS_RDY)) != WDSS_RDY) {\n\t\tprintf(\"%s: waiting for controller to become ready.\",\n\t\t    sc ? sc->sc_dev.dv_xname : \"wds?\");\n\t\tfor (i = 0; i < 20; i++) {\n\t\t\tif ((bus_space_read_1(iot, ioh, WDS_STAT) &\n\t\t\t    (WDSS_RDY)) == WDSS_RDY)\n\t\t\t\tbreak;\n\t\t\tprintf(\".\");\n\t\t\tdelay(10000);\n\t\t}\n\t\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & (WDSS_RDY)) !=\n\t\t    WDSS_RDY) {\n\t\t\tprintf(\" failed\\n\");\n\t\t\treturn (0);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tif (sc != NULL) {\n\t\t/* XXX Can we do this better? */\n\t\t/* who are we on the scsi bus? */\n\t\tsc->sc_scsi_dev = 7;\n\n\t\tsc->sc_iot = iot;\n\t\tsc->sc_ioh = ioh;\n\t\tsc->sc_irq = ia->ia_irq;\n\t\tsc->sc_drq = ia->ia_drq;\n\t}\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
      "wds_finish_scbs __P((struct wds_softc *));",
      "int\twds_find",
      "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
      "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
      "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "WDS_STAT"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10000"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "WDS_STAT"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "WDS_STAT"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "WDS_IRQSTAT"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "WDS_IRQSTAT"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "WDS_IRQSTAT"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_wait",
          "args": [
            "iot",
            "ioh",
            "WDS_STAT",
            "WDSS_RDY",
            "WDSS_RDY"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "wds_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "203-213",
          "snippet": "integrate void\nwds_wait(iot, ioh, port, mask, val)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint port;\n\tint mask;\n\tint val;\n{\n\twhile ((bus_space_read_1(iot, ioh, port) & mask) != val)\n\t\t;\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tintegrate\tstatic inline",
            "#define\tintegrate"
          ],
          "globals_used": [
            "integrate void",
            "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
            "integrate void",
            "integrate void",
            "integrate void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nintegrate void;\nintegrate void;\nintegrate void;\n\nintegrate void\nwds_wait(iot, ioh, port, mask, val)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint port;\n\tint mask;\n\tint val;\n{\n\twhile ((bus_space_read_1(iot, ioh, port) & mask) != val)\n\t\t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "WDS_HCR",
            "0x00"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "WDS_HCR",
            "WDSH_SCSIRESET|WDSH_ASCRESET"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "WDS_STAT"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "WDS_CMD",
            "WDSC_NOOP"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "WDS_STAT"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "WDS_STAT"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nwds_finish_scbs __P((struct wds_softc *));\nint\twds_find;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nint\nwds_find(ia, sc)\n\tstruct isa_attach_args *ia;\n\tstruct wds_softc *sc;\n{\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tu_char c;\n\tint i;\n\n\t/*\n\t * Sending a command causes the CMDRDY bit to clear.\n \t */\n\tc = bus_space_read_1(iot, ioh, WDS_STAT);\n\tfor (i = 0; i < 4; i++)\n\t\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_RDY) != 0) {\n\t\t\tgoto ready;\n\t\tdelay(10);\n\t}\n\treturn (0);\n\nready:\n\tbus_space_write_1(iot, ioh, WDS_CMD, WDSC_NOOP);\n\tif (bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_RDY)\n\t\treturn (0);\n\n\tbus_space_write_1(iot, ioh, WDS_HCR, WDSH_SCSIRESET|WDSH_ASCRESET);\n\tdelay(10000);\n\tbus_space_write_1(iot, ioh, WDS_HCR, 0x00);\n\tdelay(500000);\n\twds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);\n\tif (bus_space_read_1(iot, ioh, WDS_IRQSTAT) != 1)\n\t\tif (bus_space_read_1(iot, ioh, WDS_IRQSTAT) != 7)\n\t\t\tprintf(\"%s: failed reset!!! %2x\\n\",\n\t\t\t    sc ? sc->sc_dev.dv_xname : \"wds?\",\n\t\t\t    bus_space_read_1(iot, ioh, WDS_IRQSTAT));\n\n\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & (WDSS_RDY)) != WDSS_RDY) {\n\t\tprintf(\"%s: waiting for controller to become ready.\",\n\t\t    sc ? sc->sc_dev.dv_xname : \"wds?\");\n\t\tfor (i = 0; i < 20; i++) {\n\t\t\tif ((bus_space_read_1(iot, ioh, WDS_STAT) &\n\t\t\t    (WDSS_RDY)) == WDSS_RDY)\n\t\t\t\tbreak;\n\t\t\tprintf(\".\");\n\t\t\tdelay(10000);\n\t\t}\n\t\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & (WDSS_RDY)) !=\n\t\t    WDSS_RDY) {\n\t\t\tprintf(\" failed\\n\");\n\t\t\treturn (0);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tif (sc != NULL) {\n\t\t/* XXX Can we do this better? */\n\t\t/* who are we on the scsi bus? */\n\t\tsc->sc_scsi_dev = 7;\n\n\t\tsc->sc_iot = iot;\n\t\tsc->sc_ioh = ioh;\n\t\tsc->sc_irq = ia->ia_irq;\n\t\tsc->sc_drq = ia->ia_drq;\n\t}\n\n\treturn (1);\n}"
  },
  {
    "function_name": "wds_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "752-849",
    "snippet": "void\nwds_done(sc, scb, stat)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n\tu_int8_t stat;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\n\t/* XXXXX */\n\n\t/* Don't release the SCB if it was an internal command. */\n\tif (xs == 0) {\n\t\tscb->flags |= SCB_DONE;\n\t\treturn;\n\t}\n\n\t/* Sense handling. */\n\tif (xs->error == XS_SENSE) {\n\t\tbcopy(&scb->sense_data, &xs->sense, sizeof (struct scsi_sense_data));\n\t} else {\n\t\tif (xs->error == XS_NOERROR) {\n\t\t\t/* If all went well, or an error is acceptable. */\n\t\t\tif (stat == WDS_MBI_OK) {\n\t\t\t\t/* OK, set the result */\n\t\t\t\txs->resid = 0;\n\t\t\t} else {\n\t\t\t\t/* Check the mailbox status. */\n\t\t\t\tswitch (stat) {\n\t\t\t\tcase WDS_MBI_OKERR:\n\t\t\t\t\t/* SCSI error recorded in scb, counts as WDS_MBI_OK */\n\t\t\t\t\tswitch (scb->cmd.venderr) {\n\t\t\t\t\tcase 0x00:\n\t\t\t\t\t\tprintf(\"%s: Is this an error?\\n\", sc->sc_dev.dv_xname);\n\t\t\t\t\t\txs->error = XS_DRIVER_STUFFUP; /* Experiment */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x01:\n\t\t\t\t\t\t/*printf(\"%s: OK, see SCSI error field.\\n\", sc->sc_dev.dv_xname);*/\n\t\t\t\t\t\tif (scb->cmd.stat == SCSI_CHECK) {\n\t\t\t\t\t\t\t/* Do sense. */\n\t\t\t\t\t\t\twds_sense (sc, scb);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (scb->cmd.stat == SCSI_BUSY) {\n\t\t\t\t\t\t\txs->error = XS_BUSY;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x40:\n\t\t\t\t\t\t/*printf(\"%s: DMA underrun!\\n\", sc->sc_dev.dv_xname);*/\n\t\t\t\t\t\t/* Hits this if the target returns fewer that datalen bytes (eg my CD-ROM,\n\t\t\t\t\t\twhich returns a short version string, or if DMA is turned off etc. */\n\t\t\t\t\t\txs->resid = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintf(\"%s: VENDOR ERROR %02x, scsi %02x\\n\", sc->sc_dev.dv_xname, scb->cmd.venderr, scb->cmd.stat);\n\t\t\t\t\t\txs->error = XS_DRIVER_STUFFUP; /* Experiment */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase WDS_MBI_ETIME:\n\t\t\t\t\t/*\n\t\t\t\t\t * The documentation isn't clear on\n\t\t\t\t\t * what conditions might generate this,\n\t\t\t\t\t * but selection timeouts are the only\n\t\t\t\t\t * one I can think of.\n\t\t\t\t\t */\n\t\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WDS_MBI_ERESET:\n\t\t\t\tcase WDS_MBI_ETARCMD:\n\t\t\t\tcase WDS_MBI_ERESEL:\n\t\t\t\tcase WDS_MBI_ESEL:\n\t\t\t\tcase WDS_MBI_EABORT:\n\t\t\t\tcase WDS_MBI_ESRESET:\n\t\t\t\tcase WDS_MBI_EHRESET:\n\t\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} /* else sense */\n\n\t\tif (NEEDBUFFER(sc) && xs->datalen) {\n\t\t\tif (xs->flags & SCSI_DATA_IN)\n\t\t\t\tbcopy(scb->buf->data, xs->data, xs->datalen);\n\t\t}\n\t} /* XS_NOERROR */\n\n#ifdef notyet\n\tif (scb->data_nseg) {\n\t\tif (xs->flags & SCSI_DATA_IN)\n\t\t\tisadma_copyfrombuf(xs->data, xs->datalen,\n\t\t\t    scb->data_nseg, scb->data_phys);\n\t\tisadma_unmap(xs->data, xs->datalen,\n\t\t    scb->data_nseg, scb->data_phys);\n\t}\n#endif\n\twds_free_scb(sc, scb);\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct wds_buf {\n\tu_char data[BUFLEN];\n\tint    busy;\n\tTAILQ_ENTRY(wds_buf) chain;\n} wds_buffer[BUFCNT];",
      "wds_finish_scbs __P((struct wds_softc *));",
      "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
      "void    wds_free_scb",
      "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
      "void    wds_done",
      "void\twds_sense",
      "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
      "int flags;",
      "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
      "int flags;",
      "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_free_scb",
          "args": [
            "sc",
            "scb"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "wds_free_scb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "447-477",
          "snippet": "void\nwds_free_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\tint s;\n\n\tif (scb->buf != 0) {\n\t\twds_free_buf(sc, scb->buf);\n\t\tscb->buf = 0;\n\t}\n\n\ts = splbio();\n\n#ifdef notyet\n\tif (scb->scb_phys[0].addr)\n\t        isadma_unmap((caddr_t)scb, SCB_PHYS_SIZE, 1, scb->scb_phys);\n#endif\n\n\twds_reset_scb(sc, scb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_scb, scb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (scb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_scb);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wds_finish_scbs __P((struct wds_softc *));",
            "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
            "void    wds_free_scb",
            "void\twds_free_buf",
            "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;",
            "u_long scb_phys;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nvoid    wds_free_scb;\nvoid\twds_free_buf;\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\nu_long scb_phys;\n\nvoid\nwds_free_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\tint s;\n\n\tif (scb->buf != 0) {\n\t\twds_free_buf(sc, scb->buf);\n\t\tscb->buf = 0;\n\t}\n\n\ts = splbio();\n\n#ifdef notyet\n\tif (scb->scb_phys[0].addr)\n\t        isadma_unmap((caddr_t)scb, SCB_PHYS_SIZE, 1, scb->scb_phys);\n#endif\n\n\twds_reset_scb(sc, scb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_scb, scb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (scb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_scb);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isadma_unmap",
          "args": [
            "xs->data",
            "xs->datalen",
            "scb->data_nseg",
            "scb->data_phys"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_copyfrombuf",
          "args": [
            "xs->data",
            "xs->datalen",
            "scb->data_nseg",
            "scb->data_phys"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "scb->buf->data",
            "xs->data",
            "xs->datalen"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NEEDBUFFER",
          "args": [
            "sc"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: VENDOR ERROR %02x, scsi %02x\\n\"",
            "sc->sc_dev.dv_xname",
            "scb->cmd.venderr",
            "scb->cmd.stat"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wds_sense",
          "args": [
            "sc",
            "scb"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "wds_sense",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "1296-1341",
          "snippet": "void\nwds_sense(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct scsi_sense *ss = (void *)&scb->sense.scb;\n\tint s;\n\n\t/* XXXXX */\n\n\t/* Send sense request SCSI command. */\n\txs->error = XS_SENSE;\n\tscb->flags |= SCB_SENSE;\n\n\t/* First, save the return values */\n\tif (NEEDBUFFER(sc) && xs->datalen) {\n\t\tif (xs->flags & SCSI_DATA_IN)\n\t\t\tbcopy(scb->buf->data, xs->data, xs->datalen);\n\t}\n\n\t/* Next, setup a request sense command block */\n\tbzero(ss, sizeof(*ss));\n\tss->opcode = REQUEST_SENSE;\n\tss->byte2 = xs->sc_link->lun << 5;\n\tss->length = sizeof(struct scsi_sense_data);\n\n\t/* Set up some of the command fields. */\n\tscb->sense.targ = scb->cmd.targ;\n\tscb->sense.write = 0x80;\n\tscb->sense.opcode = WDSX_SCSICMD;\n\tltophys(KVTOPHYS(&scb->sense_data), scb->sense.data);\n\tltophys(sizeof(struct scsi_sense_data), scb->sense.len);\n\n\ts = splbio();\n\twds_queue_scb(sc, scb);\n\tsplx(s);\n\n\t/*\n\t * There's no reason for us to poll here.  There are two cases:\n\t * 1) If it's a polling operation, then we're called from the interrupt\n\t *    handler, and we return and continue polling.\n\t * 2) If it's an interrupt-driven operation, then it gets completed\n\t *    later on when the REQUEST SENSE finishes.\n\t */\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wds_buf {\n\tu_char data[BUFLEN];\n\tint    busy;\n\tTAILQ_ENTRY(wds_buf) chain;\n} wds_buffer[BUFCNT];",
            "wds_finish_scbs __P((struct wds_softc *));",
            "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
            "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
            "void\twds_queue_scb",
            "void\twds_sense",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstruct wds_buf {\n\tu_char data[BUFLEN];\n\tint    busy;\n\tTAILQ_ENTRY(wds_buf) chain;\n} wds_buffer[BUFCNT];\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nvoid\twds_queue_scb;\nvoid\twds_sense;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nvoid\nwds_sense(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct scsi_sense *ss = (void *)&scb->sense.scb;\n\tint s;\n\n\t/* XXXXX */\n\n\t/* Send sense request SCSI command. */\n\txs->error = XS_SENSE;\n\tscb->flags |= SCB_SENSE;\n\n\t/* First, save the return values */\n\tif (NEEDBUFFER(sc) && xs->datalen) {\n\t\tif (xs->flags & SCSI_DATA_IN)\n\t\t\tbcopy(scb->buf->data, xs->data, xs->datalen);\n\t}\n\n\t/* Next, setup a request sense command block */\n\tbzero(ss, sizeof(*ss));\n\tss->opcode = REQUEST_SENSE;\n\tss->byte2 = xs->sc_link->lun << 5;\n\tss->length = sizeof(struct scsi_sense_data);\n\n\t/* Set up some of the command fields. */\n\tscb->sense.targ = scb->cmd.targ;\n\tscb->sense.write = 0x80;\n\tscb->sense.opcode = WDSX_SCSICMD;\n\tltophys(KVTOPHYS(&scb->sense_data), scb->sense.data);\n\tltophys(sizeof(struct scsi_sense_data), scb->sense.len);\n\n\ts = splbio();\n\twds_queue_scb(sc, scb);\n\tsplx(s);\n\n\t/*\n\t * There's no reason for us to poll here.  There are two cases:\n\t * 1) If it's a polling operation, then we're called from the interrupt\n\t *    handler, and we return and continue polling.\n\t * 2) If it's an interrupt-driven operation, then it gets completed\n\t *    later on when the REQUEST SENSE finishes.\n\t */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstruct wds_buf {\n\tu_char data[BUFLEN];\n\tint    busy;\n\tTAILQ_ENTRY(wds_buf) chain;\n} wds_buffer[BUFCNT];\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nvoid    wds_free_scb;\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nvoid    wds_done;\nvoid\twds_sense;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nvoid\nwds_done(sc, scb, stat)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n\tu_int8_t stat;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\n\t/* XXXXX */\n\n\t/* Don't release the SCB if it was an internal command. */\n\tif (xs == 0) {\n\t\tscb->flags |= SCB_DONE;\n\t\treturn;\n\t}\n\n\t/* Sense handling. */\n\tif (xs->error == XS_SENSE) {\n\t\tbcopy(&scb->sense_data, &xs->sense, sizeof (struct scsi_sense_data));\n\t} else {\n\t\tif (xs->error == XS_NOERROR) {\n\t\t\t/* If all went well, or an error is acceptable. */\n\t\t\tif (stat == WDS_MBI_OK) {\n\t\t\t\t/* OK, set the result */\n\t\t\t\txs->resid = 0;\n\t\t\t} else {\n\t\t\t\t/* Check the mailbox status. */\n\t\t\t\tswitch (stat) {\n\t\t\t\tcase WDS_MBI_OKERR:\n\t\t\t\t\t/* SCSI error recorded in scb, counts as WDS_MBI_OK */\n\t\t\t\t\tswitch (scb->cmd.venderr) {\n\t\t\t\t\tcase 0x00:\n\t\t\t\t\t\tprintf(\"%s: Is this an error?\\n\", sc->sc_dev.dv_xname);\n\t\t\t\t\t\txs->error = XS_DRIVER_STUFFUP; /* Experiment */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x01:\n\t\t\t\t\t\t/*printf(\"%s: OK, see SCSI error field.\\n\", sc->sc_dev.dv_xname);*/\n\t\t\t\t\t\tif (scb->cmd.stat == SCSI_CHECK) {\n\t\t\t\t\t\t\t/* Do sense. */\n\t\t\t\t\t\t\twds_sense (sc, scb);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (scb->cmd.stat == SCSI_BUSY) {\n\t\t\t\t\t\t\txs->error = XS_BUSY;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x40:\n\t\t\t\t\t\t/*printf(\"%s: DMA underrun!\\n\", sc->sc_dev.dv_xname);*/\n\t\t\t\t\t\t/* Hits this if the target returns fewer that datalen bytes (eg my CD-ROM,\n\t\t\t\t\t\twhich returns a short version string, or if DMA is turned off etc. */\n\t\t\t\t\t\txs->resid = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintf(\"%s: VENDOR ERROR %02x, scsi %02x\\n\", sc->sc_dev.dv_xname, scb->cmd.venderr, scb->cmd.stat);\n\t\t\t\t\t\txs->error = XS_DRIVER_STUFFUP; /* Experiment */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase WDS_MBI_ETIME:\n\t\t\t\t\t/*\n\t\t\t\t\t * The documentation isn't clear on\n\t\t\t\t\t * what conditions might generate this,\n\t\t\t\t\t * but selection timeouts are the only\n\t\t\t\t\t * one I can think of.\n\t\t\t\t\t */\n\t\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WDS_MBI_ERESET:\n\t\t\t\tcase WDS_MBI_ETARCMD:\n\t\t\t\tcase WDS_MBI_ERESEL:\n\t\t\t\tcase WDS_MBI_ESEL:\n\t\t\t\tcase WDS_MBI_EABORT:\n\t\t\t\tcase WDS_MBI_ESRESET:\n\t\t\t\tcase WDS_MBI_EHRESET:\n\t\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} /* else sense */\n\n\t\tif (NEEDBUFFER(sc) && xs->datalen) {\n\t\t\tif (xs->flags & SCSI_DATA_IN)\n\t\t\t\tbcopy(scb->buf->data, xs->data, xs->datalen);\n\t\t}\n\t} /* XS_NOERROR */\n\n#ifdef notyet\n\tif (scb->data_nseg) {\n\t\tif (xs->flags & SCSI_DATA_IN)\n\t\t\tisadma_copyfrombuf(xs->data, xs->datalen,\n\t\t\t    scb->data_nseg, scb->data_phys);\n\t\tisadma_unmap(xs->data, xs->datalen,\n\t\t    scb->data_nseg, scb->data_phys);\n\t}\n#endif\n\twds_free_scb(sc, scb);\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n}"
  },
  {
    "function_name": "wds_start_scbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "696-747",
    "snippet": "void\nwds_start_scbs(sc)\n\tstruct wds_softc *sc;\n{\n\tstruct wds_mbx_out *wmbo;\t/* Mail Box Out pointer */\n\tstruct wds_scb *scb;\n\tu_char c;\n\n\twmbo = wmbx->tmbo;\n\n\twhile ((scb = sc->sc_waiting_scb.tqh_first) != NULL) {\n\t\tif (sc->sc_mbofull >= WDS_MBX_SIZE) {\n\t\t\twds_collect_mbo(sc);\n\t\t\tif (sc->sc_mbofull >= WDS_MBX_SIZE) {\n\t\t\t\tc = WDSC_IRQMFREE;\n\t\t\t\twds_cmd(sc, &c, sizeof c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_scb, scb, chain);\n#ifdef WDSDIAG\n\t\tscb->flags |= SCB_SENDING;\n#endif\n\n\t\t/* Link scb to mbo. */\n#ifdef notyet\n\t\tisadma_copytobuf((caddr_t)scb, SCB_PHYS_SIZE,\n\t\t    1, scb->scb_phys);\n\t\tltophys(scb->scb_phys[0].addr, wmbo->scb_addr);\n#else\n\t\tif (scb->flags & SCB_SENSE)\n\t\t\tltophys(KVTOPHYS(&scb->sense), wmbo->scb_addr);\n\t\telse\n\t\t\tltophys(KVTOPHYS(&scb->cmd), wmbo->scb_addr);\n#endif\n\t\t/* XXX What about aborts? */\n\t\twmbo->cmd = WDS_MBO_START;\n\n\t\t/* Tell the card to poll immediately. */\n\t\tc = WDSC_MSTART(wmbo - wmbx->mbo);\n\t\twds_cmd(sc, &c, sizeof c);\n\n\t\tif ((scb->flags & SCB_POLLED) == 0)\n\t\t\ttimeout(wds_timeout, scb, (scb->timeout * hz) / 1000);\n\n\t\t++sc->sc_mbofull;\n\t\twds_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->tmbo = wmbo;\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\twmbx\t(&sc->sc_mbx)",
      "#define WDS_MBX_SIZE\t16"
    ],
    "globals_used": [
      "int     wds_cmd",
      "wds_finish_scbs __P((struct wds_softc *));",
      "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
      "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
      "void\twds_collect_mbo",
      "void\twds_start_scbs",
      "void\twds_timeout",
      "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
      "int flags;",
      "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
      "int flags;",
      "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;",
      "u_long scb_phys;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wds_nextmbx",
          "args": [
            "wmbo",
            "wmbx",
            "mbo"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "wds_timeout",
            "scb",
            "(scb->timeout * hz) / 1000"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "wds_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "1399-1450",
          "snippet": "void\nwds_timeout(arg)\n\tvoid *arg;\n{\n\tstruct wds_scb *scb = arg;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_link *sc_link;\n\tstruct wds_softc *sc;\n\tint s;\n\n\ts = splbio();\n#ifdef notyet\n\tisadma_copyfrombuf((caddr_t)scb, SCB_PHYS_SIZE, 1, scb->scb_phys);\n#endif\n\txs = scb->xs;\n\tsc_link = xs->sc_link;\n\tsc = sc_link->adapter_softc;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n#ifdef WDSDIAG\n\t/*\n\t * If The scb's mbx is not free, then the board has gone south?\n\t */\n\twds_collect_mbo(sc);\n\tif (scb->flags & SCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (scb->flags & SCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tscb->xs->error = XS_TIMEOUT;\n\t\tscb->timeout = WDS_ABORT_TIMEOUT;\n\t\tscb->flags |= SCB_ABORT;\n\t\twds_queue_scb(sc, scb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tWDS_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
          ],
          "globals_used": [
            "wds_finish_scbs __P((struct wds_softc *));",
            "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
            "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
            "void\twds_queue_scb",
            "void\twds_collect_mbo",
            "void\twds_timeout",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;",
            "u_long scb_phys;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tWDS_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nvoid\twds_queue_scb;\nvoid\twds_collect_mbo;\nvoid\twds_timeout;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\nu_long scb_phys;\n\nvoid\nwds_timeout(arg)\n\tvoid *arg;\n{\n\tstruct wds_scb *scb = arg;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_link *sc_link;\n\tstruct wds_softc *sc;\n\tint s;\n\n\ts = splbio();\n#ifdef notyet\n\tisadma_copyfrombuf((caddr_t)scb, SCB_PHYS_SIZE, 1, scb->scb_phys);\n#endif\n\txs = scb->xs;\n\tsc_link = xs->sc_link;\n\tsc = sc_link->adapter_softc;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n#ifdef WDSDIAG\n\t/*\n\t * If The scb's mbx is not free, then the board has gone south?\n\t */\n\twds_collect_mbo(sc);\n\tif (scb->flags & SCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (scb->flags & SCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tscb->xs->error = XS_TIMEOUT;\n\t\tscb->timeout = WDS_ABORT_TIMEOUT;\n\t\tscb->flags |= SCB_ABORT;\n\t\twds_queue_scb(sc, scb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wds_cmd",
          "args": [
            "sc",
            "&c",
            "sizeof c"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "wds_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "218-239",
          "snippet": "int\nwds_cmd(sc, ibuf, icnt)\n\tstruct wds_softc *sc;\n\tu_int8_t *ibuf;\n\tint icnt;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int8_t c;\n\n\twds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);\n\n\twhile (icnt--) {\n\t\tbus_space_write_1(iot, ioh, WDS_CMD, *ibuf++);\n\t\twds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);\n\t\tc = bus_space_read_1(iot, ioh, WDS_STAT);\n\t\tif (c & WDSS_REJ)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
            "int     wds_cmd",
            "wds_finish_scbs __P((struct wds_softc *));",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nint     wds_cmd;\nwds_finish_scbs __P((struct wds_softc *));\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nint\nwds_cmd(sc, ibuf, icnt)\n\tstruct wds_softc *sc;\n\tu_int8_t *ibuf;\n\tint icnt;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int8_t c;\n\n\twds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);\n\n\twhile (icnt--) {\n\t\tbus_space_write_1(iot, ioh, WDS_CMD, *ibuf++);\n\t\twds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);\n\t\tc = bus_space_read_1(iot, ioh, WDS_STAT);\n\t\tif (c & WDSS_REJ)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDSC_MSTART",
          "args": [
            "wmbo - wmbx->mbo"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "KVTOPHYS(&scb->cmd)",
            "wmbo->scb_addr"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "&scb->cmd"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "KVTOPHYS(&scb->sense)",
            "wmbo->scb_addr"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "&scb->sense"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "scb->scb_phys[0].addr",
            "wmbo->scb_addr"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_copytobuf",
          "args": [
            "(caddr_t)scb",
            "SCB_PHYS_SIZE",
            "1",
            "scb->scb_phys"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&sc->sc_waiting_scb",
            "scb",
            "chain"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_collect_mbo",
          "args": [
            "sc"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "wds_collect_mbo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "666-691",
          "snippet": "void\nwds_collect_mbo(sc)\n\tstruct wds_softc *sc;\n{\n\tstruct wds_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef WDSDIAG\n\tstruct wds_scb *scb;\n#endif\n\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != WDS_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef WDSDIAG\n\t\tscb = wds_scb_phys_kv(sc, phystol(wmbo->scb_addr));\n\t\tscb->flags &= ~SCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\twds_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\twmbx\t(&sc->sc_mbx)"
          ],
          "globals_used": [
            "wds_finish_scbs __P((struct wds_softc *));",
            "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
            "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
            "struct\twds_scb *wds_scb_phys_kv",
            "void\twds_collect_mbo",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(&sc->sc_mbx)\n\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nstruct\twds_scb *wds_scb_phys_kv;\nvoid\twds_collect_mbo;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nvoid\nwds_collect_mbo(sc)\n\tstruct wds_softc *sc;\n{\n\tstruct wds_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef WDSDIAG\n\tstruct wds_scb *scb;\n#endif\n\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != WDS_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef WDSDIAG\n\t\tscb = wds_scb_phys_kv(sc, phystol(wmbo->scb_addr));\n\t\tscb->flags &= ~SCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\twds_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(&sc->sc_mbx)\n#define WDS_MBX_SIZE\t16\n\nint     wds_cmd;\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nvoid\twds_collect_mbo;\nvoid\twds_start_scbs;\nvoid\twds_timeout;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\nu_long scb_phys;\n\nvoid\nwds_start_scbs(sc)\n\tstruct wds_softc *sc;\n{\n\tstruct wds_mbx_out *wmbo;\t/* Mail Box Out pointer */\n\tstruct wds_scb *scb;\n\tu_char c;\n\n\twmbo = wmbx->tmbo;\n\n\twhile ((scb = sc->sc_waiting_scb.tqh_first) != NULL) {\n\t\tif (sc->sc_mbofull >= WDS_MBX_SIZE) {\n\t\t\twds_collect_mbo(sc);\n\t\t\tif (sc->sc_mbofull >= WDS_MBX_SIZE) {\n\t\t\t\tc = WDSC_IRQMFREE;\n\t\t\t\twds_cmd(sc, &c, sizeof c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_scb, scb, chain);\n#ifdef WDSDIAG\n\t\tscb->flags |= SCB_SENDING;\n#endif\n\n\t\t/* Link scb to mbo. */\n#ifdef notyet\n\t\tisadma_copytobuf((caddr_t)scb, SCB_PHYS_SIZE,\n\t\t    1, scb->scb_phys);\n\t\tltophys(scb->scb_phys[0].addr, wmbo->scb_addr);\n#else\n\t\tif (scb->flags & SCB_SENSE)\n\t\t\tltophys(KVTOPHYS(&scb->sense), wmbo->scb_addr);\n\t\telse\n\t\t\tltophys(KVTOPHYS(&scb->cmd), wmbo->scb_addr);\n#endif\n\t\t/* XXX What about aborts? */\n\t\twmbo->cmd = WDS_MBO_START;\n\n\t\t/* Tell the card to poll immediately. */\n\t\tc = WDSC_MSTART(wmbo - wmbx->mbo);\n\t\twds_cmd(sc, &c, sizeof c);\n\n\t\tif ((scb->flags & SCB_POLLED) == 0)\n\t\t\ttimeout(wds_timeout, scb, (scb->timeout * hz) / 1000);\n\n\t\t++sc->sc_mbofull;\n\t\twds_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->tmbo = wmbo;\n}"
  },
  {
    "function_name": "wds_collect_mbo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "666-691",
    "snippet": "void\nwds_collect_mbo(sc)\n\tstruct wds_softc *sc;\n{\n\tstruct wds_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef WDSDIAG\n\tstruct wds_scb *scb;\n#endif\n\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != WDS_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef WDSDIAG\n\t\tscb = wds_scb_phys_kv(sc, phystol(wmbo->scb_addr));\n\t\tscb->flags &= ~SCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\twds_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\twmbx\t(&sc->sc_mbx)"
    ],
    "globals_used": [
      "wds_finish_scbs __P((struct wds_softc *));",
      "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
      "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
      "struct\twds_scb *wds_scb_phys_kv",
      "void\twds_collect_mbo",
      "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
      "int flags;",
      "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
      "int flags;",
      "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wds_nextmbx",
          "args": [
            "wmbo",
            "wmbx",
            "mbo"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_scb_phys_kv",
          "args": [
            "sc",
            "phystol(wmbo->scb_addr)"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phystol",
          "args": [
            "wmbo->scb_addr"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(&sc->sc_mbx)\n\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nstruct\twds_scb *wds_scb_phys_kv;\nvoid\twds_collect_mbo;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nvoid\nwds_collect_mbo(sc)\n\tstruct wds_softc *sc;\n{\n\tstruct wds_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef WDSDIAG\n\tstruct wds_scb *scb;\n#endif\n\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != WDS_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef WDSDIAG\n\t\tscb = wds_scb_phys_kv(sc, phystol(wmbo->scb_addr));\n\t\tscb->flags &= ~SCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\twds_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}"
  },
  {
    "function_name": "wds_queue_scb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "653-661",
    "snippet": "void\nwds_queue_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_scb, scb, chain);\n\twds_start_scbs(sc);\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "wds_finish_scbs __P((struct wds_softc *));",
      "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
      "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
      "void\twds_queue_scb",
      "void\twds_start_scbs",
      "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
      "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
      "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wds_start_scbs",
          "args": [
            "sc"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "wds_start_scbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "696-747",
          "snippet": "void\nwds_start_scbs(sc)\n\tstruct wds_softc *sc;\n{\n\tstruct wds_mbx_out *wmbo;\t/* Mail Box Out pointer */\n\tstruct wds_scb *scb;\n\tu_char c;\n\n\twmbo = wmbx->tmbo;\n\n\twhile ((scb = sc->sc_waiting_scb.tqh_first) != NULL) {\n\t\tif (sc->sc_mbofull >= WDS_MBX_SIZE) {\n\t\t\twds_collect_mbo(sc);\n\t\t\tif (sc->sc_mbofull >= WDS_MBX_SIZE) {\n\t\t\t\tc = WDSC_IRQMFREE;\n\t\t\t\twds_cmd(sc, &c, sizeof c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_scb, scb, chain);\n#ifdef WDSDIAG\n\t\tscb->flags |= SCB_SENDING;\n#endif\n\n\t\t/* Link scb to mbo. */\n#ifdef notyet\n\t\tisadma_copytobuf((caddr_t)scb, SCB_PHYS_SIZE,\n\t\t    1, scb->scb_phys);\n\t\tltophys(scb->scb_phys[0].addr, wmbo->scb_addr);\n#else\n\t\tif (scb->flags & SCB_SENSE)\n\t\t\tltophys(KVTOPHYS(&scb->sense), wmbo->scb_addr);\n\t\telse\n\t\t\tltophys(KVTOPHYS(&scb->cmd), wmbo->scb_addr);\n#endif\n\t\t/* XXX What about aborts? */\n\t\twmbo->cmd = WDS_MBO_START;\n\n\t\t/* Tell the card to poll immediately. */\n\t\tc = WDSC_MSTART(wmbo - wmbx->mbo);\n\t\twds_cmd(sc, &c, sizeof c);\n\n\t\tif ((scb->flags & SCB_POLLED) == 0)\n\t\t\ttimeout(wds_timeout, scb, (scb->timeout * hz) / 1000);\n\n\t\t++sc->sc_mbofull;\n\t\twds_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->tmbo = wmbo;\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\twmbx\t(&sc->sc_mbx)",
            "#define WDS_MBX_SIZE\t16"
          ],
          "globals_used": [
            "int     wds_cmd",
            "wds_finish_scbs __P((struct wds_softc *));",
            "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
            "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
            "void\twds_collect_mbo",
            "void\twds_start_scbs",
            "void\twds_timeout",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;",
            "u_long scb_phys;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(&sc->sc_mbx)\n#define WDS_MBX_SIZE\t16\n\nint     wds_cmd;\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nvoid\twds_collect_mbo;\nvoid\twds_start_scbs;\nvoid\twds_timeout;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\nu_long scb_phys;\n\nvoid\nwds_start_scbs(sc)\n\tstruct wds_softc *sc;\n{\n\tstruct wds_mbx_out *wmbo;\t/* Mail Box Out pointer */\n\tstruct wds_scb *scb;\n\tu_char c;\n\n\twmbo = wmbx->tmbo;\n\n\twhile ((scb = sc->sc_waiting_scb.tqh_first) != NULL) {\n\t\tif (sc->sc_mbofull >= WDS_MBX_SIZE) {\n\t\t\twds_collect_mbo(sc);\n\t\t\tif (sc->sc_mbofull >= WDS_MBX_SIZE) {\n\t\t\t\tc = WDSC_IRQMFREE;\n\t\t\t\twds_cmd(sc, &c, sizeof c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_scb, scb, chain);\n#ifdef WDSDIAG\n\t\tscb->flags |= SCB_SENDING;\n#endif\n\n\t\t/* Link scb to mbo. */\n#ifdef notyet\n\t\tisadma_copytobuf((caddr_t)scb, SCB_PHYS_SIZE,\n\t\t    1, scb->scb_phys);\n\t\tltophys(scb->scb_phys[0].addr, wmbo->scb_addr);\n#else\n\t\tif (scb->flags & SCB_SENSE)\n\t\t\tltophys(KVTOPHYS(&scb->sense), wmbo->scb_addr);\n\t\telse\n\t\t\tltophys(KVTOPHYS(&scb->cmd), wmbo->scb_addr);\n#endif\n\t\t/* XXX What about aborts? */\n\t\twmbo->cmd = WDS_MBO_START;\n\n\t\t/* Tell the card to poll immediately. */\n\t\tc = WDSC_MSTART(wmbo - wmbx->mbo);\n\t\twds_cmd(sc, &c, sizeof c);\n\n\t\tif ((scb->flags & SCB_POLLED) == 0)\n\t\t\ttimeout(wds_timeout, scb, (scb->timeout * hz) / 1000);\n\n\t\t++sc->sc_mbofull;\n\t\twds_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->tmbo = wmbo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&sc->sc_waiting_scb",
            "scb",
            "chain"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nvoid\twds_queue_scb;\nvoid\twds_start_scbs;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nvoid\nwds_queue_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_scb, scb, chain);\n\twds_start_scbs(sc);\n}"
  },
  {
    "function_name": "wds_init_scb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "501-518",
    "snippet": "integrate void\nwds_init_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\tint hashnum;\n\n\tbzero(scb, sizeof(struct wds_scb));\n\t/*\n\t * put in the phystokv hash table\n\t * Never gets taken out.\n\t */\n\tscb->hashkey = KVTOPHYS(scb);\n\thashnum = SCB_HASH(scb->hashkey);\n\tscb->nexthash = sc->sc_scbhash[hashnum];\n\tsc->sc_scbhash[hashnum] = scb;\n\twds_reset_scb(sc, scb);\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tintegrate\tstatic inline",
      "#define\tintegrate"
    ],
    "globals_used": [
      "integrate void",
      "integrate void",
      "wds_finish_scbs __P((struct wds_softc *));",
      "integrate void",
      "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
      "integrate void",
      "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
      "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
      "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
      "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wds_reset_scb",
          "args": [
            "sc",
            "scb"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "wds_reset_scb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "435-442",
          "snippet": "integrate void\nwds_reset_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\n\tscb->flags = 0;\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tintegrate\tstatic inline",
            "#define\tintegrate"
          ],
          "globals_used": [
            "integrate void",
            "integrate void",
            "wds_finish_scbs __P((struct wds_softc *));",
            "integrate void",
            "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
            "integrate void",
            "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\nintegrate void;\nwds_finish_scbs __P((struct wds_softc *));\nintegrate void;\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nintegrate void;\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nintegrate void\nwds_reset_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\n\tscb->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCB_HASH",
          "args": [
            "scb->hashkey"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "scb"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "scb",
            "sizeof(struct wds_scb)"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\nintegrate void;\nwds_finish_scbs __P((struct wds_softc *));\nintegrate void;\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nintegrate void;\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nintegrate void\nwds_init_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\tint hashnum;\n\n\tbzero(scb, sizeof(struct wds_scb));\n\t/*\n\t * put in the phystokv hash table\n\t * Never gets taken out.\n\t */\n\tscb->hashkey = KVTOPHYS(scb);\n\thashnum = SCB_HASH(scb->hashkey);\n\tscb->nexthash = sc->sc_scbhash[hashnum];\n\tsc->sc_scbhash[hashnum] = scb;\n\twds_reset_scb(sc, scb);\n}"
  },
  {
    "function_name": "wds_free_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "479-499",
    "snippet": "void\nwds_free_buf(sc, buf)\n\tstruct wds_softc *sc;\n\tstruct wds_buf *buf;\n{\n\tint s;\n\n\ts = splbio();\n\n\tbuf->busy = 0;\n\tTAILQ_INSERT_HEAD(&wds_free_buffer, buf, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (buf->chain.tqe_next == 0)\n\t\twakeup(&wds_free_buffer);\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "TAILQ_HEAD(, wds_buf) wds_free_buffer;",
      "wds_finish_scbs __P((struct wds_softc *));",
      "void\twds_free_buf",
      "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
      "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
      "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&wds_free_buffer"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&wds_free_buffer",
            "buf",
            "chain"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nTAILQ_HEAD(, wds_buf) wds_free_buffer;\nwds_finish_scbs __P((struct wds_softc *));\nvoid\twds_free_buf;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nvoid\nwds_free_buf(sc, buf)\n\tstruct wds_softc *sc;\n\tstruct wds_buf *buf;\n{\n\tint s;\n\n\ts = splbio();\n\n\tbuf->busy = 0;\n\tTAILQ_INSERT_HEAD(&wds_free_buffer, buf, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (buf->chain.tqe_next == 0)\n\t\twakeup(&wds_free_buffer);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "wds_free_scb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "447-477",
    "snippet": "void\nwds_free_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\tint s;\n\n\tif (scb->buf != 0) {\n\t\twds_free_buf(sc, scb->buf);\n\t\tscb->buf = 0;\n\t}\n\n\ts = splbio();\n\n#ifdef notyet\n\tif (scb->scb_phys[0].addr)\n\t        isadma_unmap((caddr_t)scb, SCB_PHYS_SIZE, 1, scb->scb_phys);\n#endif\n\n\twds_reset_scb(sc, scb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_scb, scb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (scb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_scb);\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "wds_finish_scbs __P((struct wds_softc *));",
      "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
      "void    wds_free_scb",
      "void\twds_free_buf",
      "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
      "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
      "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
      "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;",
      "u_long scb_phys;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&sc->sc_free_scb"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&sc->sc_free_scb",
            "scb",
            "chain"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_reset_scb",
          "args": [
            "sc",
            "scb"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "wds_reset_scb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "435-442",
          "snippet": "integrate void\nwds_reset_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\n\tscb->flags = 0;\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tintegrate\tstatic inline",
            "#define\tintegrate"
          ],
          "globals_used": [
            "integrate void",
            "integrate void",
            "wds_finish_scbs __P((struct wds_softc *));",
            "integrate void",
            "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
            "integrate void",
            "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\nintegrate void;\nwds_finish_scbs __P((struct wds_softc *));\nintegrate void;\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nintegrate void;\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nintegrate void\nwds_reset_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\n\tscb->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isadma_unmap",
          "args": [
            "(caddr_t)scb",
            "SCB_PHYS_SIZE",
            "1",
            "scb->scb_phys"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_free_buf",
          "args": [
            "sc",
            "scb->buf"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "wds_free_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "479-499",
          "snippet": "void\nwds_free_buf(sc, buf)\n\tstruct wds_softc *sc;\n\tstruct wds_buf *buf;\n{\n\tint s;\n\n\ts = splbio();\n\n\tbuf->busy = 0;\n\tTAILQ_INSERT_HEAD(&wds_free_buffer, buf, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (buf->chain.tqe_next == 0)\n\t\twakeup(&wds_free_buffer);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "TAILQ_HEAD(, wds_buf) wds_free_buffer;",
            "wds_finish_scbs __P((struct wds_softc *));",
            "void\twds_free_buf",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nTAILQ_HEAD(, wds_buf) wds_free_buffer;\nwds_finish_scbs __P((struct wds_softc *));\nvoid\twds_free_buf;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nvoid\nwds_free_buf(sc, buf)\n\tstruct wds_softc *sc;\n\tstruct wds_buf *buf;\n{\n\tint s;\n\n\ts = splbio();\n\n\tbuf->busy = 0;\n\tTAILQ_INSERT_HEAD(&wds_free_buffer, buf, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (buf->chain.tqe_next == 0)\n\t\twakeup(&wds_free_buffer);\n\n\tsplx(s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nvoid    wds_free_scb;\nvoid\twds_free_buf;\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\nu_long scb_phys;\n\nvoid\nwds_free_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\tint s;\n\n\tif (scb->buf != 0) {\n\t\twds_free_buf(sc, scb->buf);\n\t\tscb->buf = 0;\n\t}\n\n\ts = splbio();\n\n#ifdef notyet\n\tif (scb->scb_phys[0].addr)\n\t        isadma_unmap((caddr_t)scb, SCB_PHYS_SIZE, 1, scb->scb_phys);\n#endif\n\n\twds_reset_scb(sc, scb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_scb, scb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (scb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_scb);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "wds_reset_scb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "435-442",
    "snippet": "integrate void\nwds_reset_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\n\tscb->flags = 0;\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tintegrate\tstatic inline",
      "#define\tintegrate"
    ],
    "globals_used": [
      "integrate void",
      "integrate void",
      "wds_finish_scbs __P((struct wds_softc *));",
      "integrate void",
      "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
      "integrate void",
      "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
      "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
      "int flags;",
      "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
      "int flags;",
      "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\nintegrate void;\nwds_finish_scbs __P((struct wds_softc *));\nintegrate void;\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nintegrate void;\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nintegrate void\nwds_reset_scb(sc, scb)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n{\n\n\tscb->flags = 0;\n}"
  },
  {
    "function_name": "wdsintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "398-433",
    "snippet": "int\nwdsintr(arg)\n\tvoid *arg;\n{\n\tstruct wds_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_char c;\n\n\t/* Was it really an interrupt from the board? */\n\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_IRQ) == 0)\n\t\treturn 0;\n\n\t/* Get the interrupt status byte. */\n\tc = bus_space_read_1(iot, ioh, WDS_IRQSTAT) & WDSI_MASK;\n\n\t/* Acknowledge (which resets) the interrupt. */\n\tbus_space_write_1(iot, ioh, WDS_IRQACK, 0x00);\n\n\tswitch (c) {\n\tcase WDSI_MSVC:\n\t\twds_finish_scbs(sc);\n\t\tbreak;\n\n\tcase WDSI_MFREE:\n\t\twds_start_scbs(sc);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: unrecognized interrupt type %02x\",\n\t\t    sc->sc_dev.dv_xname, c);\n\t\tbreak;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
      "wds_finish_scbs __P((struct wds_softc *));",
      "int     wdsintr",
      "void\twds_start_scbs",
      "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
      "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
      "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unrecognized interrupt type %02x\"",
            "sc->sc_dev.dv_xname",
            "c"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wds_start_scbs",
          "args": [
            "sc"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "wds_start_scbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "696-747",
          "snippet": "void\nwds_start_scbs(sc)\n\tstruct wds_softc *sc;\n{\n\tstruct wds_mbx_out *wmbo;\t/* Mail Box Out pointer */\n\tstruct wds_scb *scb;\n\tu_char c;\n\n\twmbo = wmbx->tmbo;\n\n\twhile ((scb = sc->sc_waiting_scb.tqh_first) != NULL) {\n\t\tif (sc->sc_mbofull >= WDS_MBX_SIZE) {\n\t\t\twds_collect_mbo(sc);\n\t\t\tif (sc->sc_mbofull >= WDS_MBX_SIZE) {\n\t\t\t\tc = WDSC_IRQMFREE;\n\t\t\t\twds_cmd(sc, &c, sizeof c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_scb, scb, chain);\n#ifdef WDSDIAG\n\t\tscb->flags |= SCB_SENDING;\n#endif\n\n\t\t/* Link scb to mbo. */\n#ifdef notyet\n\t\tisadma_copytobuf((caddr_t)scb, SCB_PHYS_SIZE,\n\t\t    1, scb->scb_phys);\n\t\tltophys(scb->scb_phys[0].addr, wmbo->scb_addr);\n#else\n\t\tif (scb->flags & SCB_SENSE)\n\t\t\tltophys(KVTOPHYS(&scb->sense), wmbo->scb_addr);\n\t\telse\n\t\t\tltophys(KVTOPHYS(&scb->cmd), wmbo->scb_addr);\n#endif\n\t\t/* XXX What about aborts? */\n\t\twmbo->cmd = WDS_MBO_START;\n\n\t\t/* Tell the card to poll immediately. */\n\t\tc = WDSC_MSTART(wmbo - wmbx->mbo);\n\t\twds_cmd(sc, &c, sizeof c);\n\n\t\tif ((scb->flags & SCB_POLLED) == 0)\n\t\t\ttimeout(wds_timeout, scb, (scb->timeout * hz) / 1000);\n\n\t\t++sc->sc_mbofull;\n\t\twds_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->tmbo = wmbo;\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\twmbx\t(&sc->sc_mbx)",
            "#define WDS_MBX_SIZE\t16"
          ],
          "globals_used": [
            "int     wds_cmd",
            "wds_finish_scbs __P((struct wds_softc *));",
            "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
            "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
            "void\twds_collect_mbo",
            "void\twds_start_scbs",
            "void\twds_timeout",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;",
            "u_long scb_phys;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(&sc->sc_mbx)\n#define WDS_MBX_SIZE\t16\n\nint     wds_cmd;\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nvoid\twds_collect_mbo;\nvoid\twds_start_scbs;\nvoid\twds_timeout;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\nu_long scb_phys;\n\nvoid\nwds_start_scbs(sc)\n\tstruct wds_softc *sc;\n{\n\tstruct wds_mbx_out *wmbo;\t/* Mail Box Out pointer */\n\tstruct wds_scb *scb;\n\tu_char c;\n\n\twmbo = wmbx->tmbo;\n\n\twhile ((scb = sc->sc_waiting_scb.tqh_first) != NULL) {\n\t\tif (sc->sc_mbofull >= WDS_MBX_SIZE) {\n\t\t\twds_collect_mbo(sc);\n\t\t\tif (sc->sc_mbofull >= WDS_MBX_SIZE) {\n\t\t\t\tc = WDSC_IRQMFREE;\n\t\t\t\twds_cmd(sc, &c, sizeof c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_scb, scb, chain);\n#ifdef WDSDIAG\n\t\tscb->flags |= SCB_SENDING;\n#endif\n\n\t\t/* Link scb to mbo. */\n#ifdef notyet\n\t\tisadma_copytobuf((caddr_t)scb, SCB_PHYS_SIZE,\n\t\t    1, scb->scb_phys);\n\t\tltophys(scb->scb_phys[0].addr, wmbo->scb_addr);\n#else\n\t\tif (scb->flags & SCB_SENSE)\n\t\t\tltophys(KVTOPHYS(&scb->sense), wmbo->scb_addr);\n\t\telse\n\t\t\tltophys(KVTOPHYS(&scb->cmd), wmbo->scb_addr);\n#endif\n\t\t/* XXX What about aborts? */\n\t\twmbo->cmd = WDS_MBO_START;\n\n\t\t/* Tell the card to poll immediately. */\n\t\tc = WDSC_MSTART(wmbo - wmbx->mbo);\n\t\twds_cmd(sc, &c, sizeof c);\n\n\t\tif ((scb->flags & SCB_POLLED) == 0)\n\t\t\ttimeout(wds_timeout, scb, (scb->timeout * hz) / 1000);\n\n\t\t++sc->sc_mbofull;\n\t\twds_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->tmbo = wmbo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wds_finish_scbs",
          "args": [
            "sc"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "wds_finish_scbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "334-393",
          "snippet": "integrate void\nwds_finish_scbs(sc)\n\tstruct wds_softc *sc;\n{\n\tstruct wds_mbx_in *wmbi;\n\tstruct wds_scb *scb;\n\tint i;\n\n\twmbi = wmbx->tmbi;\n\n\tif (wmbi->stat == WDS_MBI_FREE) {\n\t\tfor (i = 0; i < WDS_MBX_SIZE; i++) {\n\t\t\tif (wmbi->stat != WDS_MBI_FREE) {\n\t\t\t\tprintf(\"%s: mbi not in round-robin order\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tgoto AGAIN;\n\t\t\t}\n\t\t\twds_nextmbx(wmbi, wmbx, mbi);\n\t\t}\n#ifdef WDSDIAGnot\n\t\tprintf(\"%s: mbi interrupt with no full mailboxes\\n\",\n\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\treturn;\n\t}\n\nAGAIN:\n\tdo {\n\t\tscb = wds_scb_phys_kv(sc, phystol(wmbi->scb_addr));\n\t\tif (!scb) {\n\t\t\tprintf(\"%s: bad mbi scb pointer; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto next;\n\t\t}\n\n#ifdef WDSDEBUG\n\t\tif (wds_debug) {\n\t\t\tu_int8_t *cp = (u_int8_t *)&scb->cmd.scb;\n\t\t\tprintf(\"op=%x %x %x %x %x %x\\n\",\n\t\t\t    cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);\n\t\t\tprintf(\"stat %x for mbi addr = 0x%08x, \",\n\t\t\t    wmbi->stat, wmbi);\n\t\t\tprintf(\"scb addr = 0x%x\\n\", scb);\n\t\t}\n#endif /* WDSDEBUG */\n\n\t\tuntimeout(wds_timeout, scb);\n#ifdef notyet\n\t\tisadma_copyfrombuf((caddr_t)scb, SCB_PHYS_SIZE,\n\t\t    1, scb->scb_phys);\n#endif\n\t\twds_done(sc, scb, wmbi->stat);\n\n\tnext:\n\t\twmbi->stat = WDS_MBI_FREE;\n\t\twds_nextmbx(wmbi, wmbx, mbi);\n\t} while (wmbi->stat != WDS_MBI_FREE);\n\n\twmbx->tmbi = wmbi;\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\twmbx\t(&sc->sc_mbx)",
            "#define WDS_MBX_SIZE\t16",
            "#define\tintegrate\tstatic inline",
            "#define\tintegrate"
          ],
          "globals_used": [
            "integrate void",
            "integrate void",
            "wds_finish_scbs __P((struct wds_softc *));",
            "integrate void",
            "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
            "integrate void",
            "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
            "struct\twds_scb *wds_scb_phys_kv",
            "void    wds_done",
            "void\twds_timeout",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;",
            "u_long scb_phys;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(&sc->sc_mbx)\n#define WDS_MBX_SIZE\t16\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\nintegrate void;\nwds_finish_scbs __P((struct wds_softc *));\nintegrate void;\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nintegrate void;\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nstruct\twds_scb *wds_scb_phys_kv;\nvoid    wds_done;\nvoid\twds_timeout;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\nu_long scb_phys;\n\nintegrate void\nwds_finish_scbs(sc)\n\tstruct wds_softc *sc;\n{\n\tstruct wds_mbx_in *wmbi;\n\tstruct wds_scb *scb;\n\tint i;\n\n\twmbi = wmbx->tmbi;\n\n\tif (wmbi->stat == WDS_MBI_FREE) {\n\t\tfor (i = 0; i < WDS_MBX_SIZE; i++) {\n\t\t\tif (wmbi->stat != WDS_MBI_FREE) {\n\t\t\t\tprintf(\"%s: mbi not in round-robin order\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tgoto AGAIN;\n\t\t\t}\n\t\t\twds_nextmbx(wmbi, wmbx, mbi);\n\t\t}\n#ifdef WDSDIAGnot\n\t\tprintf(\"%s: mbi interrupt with no full mailboxes\\n\",\n\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\treturn;\n\t}\n\nAGAIN:\n\tdo {\n\t\tscb = wds_scb_phys_kv(sc, phystol(wmbi->scb_addr));\n\t\tif (!scb) {\n\t\t\tprintf(\"%s: bad mbi scb pointer; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto next;\n\t\t}\n\n#ifdef WDSDEBUG\n\t\tif (wds_debug) {\n\t\t\tu_int8_t *cp = (u_int8_t *)&scb->cmd.scb;\n\t\t\tprintf(\"op=%x %x %x %x %x %x\\n\",\n\t\t\t    cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);\n\t\t\tprintf(\"stat %x for mbi addr = 0x%08x, \",\n\t\t\t    wmbi->stat, wmbi);\n\t\t\tprintf(\"scb addr = 0x%x\\n\", scb);\n\t\t}\n#endif /* WDSDEBUG */\n\n\t\tuntimeout(wds_timeout, scb);\n#ifdef notyet\n\t\tisadma_copyfrombuf((caddr_t)scb, SCB_PHYS_SIZE,\n\t\t    1, scb->scb_phys);\n#endif\n\t\twds_done(sc, scb, wmbi->stat);\n\n\tnext:\n\t\twmbi->stat = WDS_MBI_FREE;\n\t\twds_nextmbx(wmbi, wmbx, mbi);\n\t} while (wmbi->stat != WDS_MBI_FREE);\n\n\twmbx->tmbi = wmbi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "WDS_IRQACK",
            "0x00"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "WDS_IRQSTAT"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "WDS_STAT"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nwds_finish_scbs __P((struct wds_softc *));\nint     wdsintr;\nvoid\twds_start_scbs;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nint\nwdsintr(arg)\n\tvoid *arg;\n{\n\tstruct wds_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_char c;\n\n\t/* Was it really an interrupt from the board? */\n\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_IRQ) == 0)\n\t\treturn 0;\n\n\t/* Get the interrupt status byte. */\n\tc = bus_space_read_1(iot, ioh, WDS_IRQSTAT) & WDSI_MASK;\n\n\t/* Acknowledge (which resets) the interrupt. */\n\tbus_space_write_1(iot, ioh, WDS_IRQACK, 0x00);\n\n\tswitch (c) {\n\tcase WDSI_MSVC:\n\t\twds_finish_scbs(sc);\n\t\tbreak;\n\n\tcase WDSI_MFREE:\n\t\twds_start_scbs(sc);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: unrecognized interrupt type %02x\",\n\t\t    sc->sc_dev.dv_xname, c);\n\t\tbreak;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "wds_finish_scbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "334-393",
    "snippet": "integrate void\nwds_finish_scbs(sc)\n\tstruct wds_softc *sc;\n{\n\tstruct wds_mbx_in *wmbi;\n\tstruct wds_scb *scb;\n\tint i;\n\n\twmbi = wmbx->tmbi;\n\n\tif (wmbi->stat == WDS_MBI_FREE) {\n\t\tfor (i = 0; i < WDS_MBX_SIZE; i++) {\n\t\t\tif (wmbi->stat != WDS_MBI_FREE) {\n\t\t\t\tprintf(\"%s: mbi not in round-robin order\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tgoto AGAIN;\n\t\t\t}\n\t\t\twds_nextmbx(wmbi, wmbx, mbi);\n\t\t}\n#ifdef WDSDIAGnot\n\t\tprintf(\"%s: mbi interrupt with no full mailboxes\\n\",\n\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\treturn;\n\t}\n\nAGAIN:\n\tdo {\n\t\tscb = wds_scb_phys_kv(sc, phystol(wmbi->scb_addr));\n\t\tif (!scb) {\n\t\t\tprintf(\"%s: bad mbi scb pointer; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto next;\n\t\t}\n\n#ifdef WDSDEBUG\n\t\tif (wds_debug) {\n\t\t\tu_int8_t *cp = (u_int8_t *)&scb->cmd.scb;\n\t\t\tprintf(\"op=%x %x %x %x %x %x\\n\",\n\t\t\t    cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);\n\t\t\tprintf(\"stat %x for mbi addr = 0x%08x, \",\n\t\t\t    wmbi->stat, wmbi);\n\t\t\tprintf(\"scb addr = 0x%x\\n\", scb);\n\t\t}\n#endif /* WDSDEBUG */\n\n\t\tuntimeout(wds_timeout, scb);\n#ifdef notyet\n\t\tisadma_copyfrombuf((caddr_t)scb, SCB_PHYS_SIZE,\n\t\t    1, scb->scb_phys);\n#endif\n\t\twds_done(sc, scb, wmbi->stat);\n\n\tnext:\n\t\twmbi->stat = WDS_MBI_FREE;\n\t\twds_nextmbx(wmbi, wmbx, mbi);\n\t} while (wmbi->stat != WDS_MBI_FREE);\n\n\twmbx->tmbi = wmbi;\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\twmbx\t(&sc->sc_mbx)",
      "#define WDS_MBX_SIZE\t16",
      "#define\tintegrate\tstatic inline",
      "#define\tintegrate"
    ],
    "globals_used": [
      "integrate void",
      "integrate void",
      "wds_finish_scbs __P((struct wds_softc *));",
      "integrate void",
      "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
      "integrate void",
      "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
      "struct\twds_scb *wds_scb_phys_kv",
      "void    wds_done",
      "void\twds_timeout",
      "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
      "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
      "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;",
      "u_long scb_phys;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wds_nextmbx",
          "args": [
            "wmbi",
            "wmbx",
            "mbi"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_done",
          "args": [
            "sc",
            "scb",
            "wmbi->stat"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "wds_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "752-849",
          "snippet": "void\nwds_done(sc, scb, stat)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n\tu_int8_t stat;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\n\t/* XXXXX */\n\n\t/* Don't release the SCB if it was an internal command. */\n\tif (xs == 0) {\n\t\tscb->flags |= SCB_DONE;\n\t\treturn;\n\t}\n\n\t/* Sense handling. */\n\tif (xs->error == XS_SENSE) {\n\t\tbcopy(&scb->sense_data, &xs->sense, sizeof (struct scsi_sense_data));\n\t} else {\n\t\tif (xs->error == XS_NOERROR) {\n\t\t\t/* If all went well, or an error is acceptable. */\n\t\t\tif (stat == WDS_MBI_OK) {\n\t\t\t\t/* OK, set the result */\n\t\t\t\txs->resid = 0;\n\t\t\t} else {\n\t\t\t\t/* Check the mailbox status. */\n\t\t\t\tswitch (stat) {\n\t\t\t\tcase WDS_MBI_OKERR:\n\t\t\t\t\t/* SCSI error recorded in scb, counts as WDS_MBI_OK */\n\t\t\t\t\tswitch (scb->cmd.venderr) {\n\t\t\t\t\tcase 0x00:\n\t\t\t\t\t\tprintf(\"%s: Is this an error?\\n\", sc->sc_dev.dv_xname);\n\t\t\t\t\t\txs->error = XS_DRIVER_STUFFUP; /* Experiment */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x01:\n\t\t\t\t\t\t/*printf(\"%s: OK, see SCSI error field.\\n\", sc->sc_dev.dv_xname);*/\n\t\t\t\t\t\tif (scb->cmd.stat == SCSI_CHECK) {\n\t\t\t\t\t\t\t/* Do sense. */\n\t\t\t\t\t\t\twds_sense (sc, scb);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (scb->cmd.stat == SCSI_BUSY) {\n\t\t\t\t\t\t\txs->error = XS_BUSY;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x40:\n\t\t\t\t\t\t/*printf(\"%s: DMA underrun!\\n\", sc->sc_dev.dv_xname);*/\n\t\t\t\t\t\t/* Hits this if the target returns fewer that datalen bytes (eg my CD-ROM,\n\t\t\t\t\t\twhich returns a short version string, or if DMA is turned off etc. */\n\t\t\t\t\t\txs->resid = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintf(\"%s: VENDOR ERROR %02x, scsi %02x\\n\", sc->sc_dev.dv_xname, scb->cmd.venderr, scb->cmd.stat);\n\t\t\t\t\t\txs->error = XS_DRIVER_STUFFUP; /* Experiment */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase WDS_MBI_ETIME:\n\t\t\t\t\t/*\n\t\t\t\t\t * The documentation isn't clear on\n\t\t\t\t\t * what conditions might generate this,\n\t\t\t\t\t * but selection timeouts are the only\n\t\t\t\t\t * one I can think of.\n\t\t\t\t\t */\n\t\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WDS_MBI_ERESET:\n\t\t\t\tcase WDS_MBI_ETARCMD:\n\t\t\t\tcase WDS_MBI_ERESEL:\n\t\t\t\tcase WDS_MBI_ESEL:\n\t\t\t\tcase WDS_MBI_EABORT:\n\t\t\t\tcase WDS_MBI_ESRESET:\n\t\t\t\tcase WDS_MBI_EHRESET:\n\t\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} /* else sense */\n\n\t\tif (NEEDBUFFER(sc) && xs->datalen) {\n\t\t\tif (xs->flags & SCSI_DATA_IN)\n\t\t\t\tbcopy(scb->buf->data, xs->data, xs->datalen);\n\t\t}\n\t} /* XS_NOERROR */\n\n#ifdef notyet\n\tif (scb->data_nseg) {\n\t\tif (xs->flags & SCSI_DATA_IN)\n\t\t\tisadma_copyfrombuf(xs->data, xs->datalen,\n\t\t\t    scb->data_nseg, scb->data_phys);\n\t\tisadma_unmap(xs->data, xs->datalen,\n\t\t    scb->data_nseg, scb->data_phys);\n\t}\n#endif\n\twds_free_scb(sc, scb);\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wds_buf {\n\tu_char data[BUFLEN];\n\tint    busy;\n\tTAILQ_ENTRY(wds_buf) chain;\n} wds_buffer[BUFCNT];",
            "wds_finish_scbs __P((struct wds_softc *));",
            "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
            "void    wds_free_scb",
            "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
            "void    wds_done",
            "void\twds_sense",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstruct wds_buf {\n\tu_char data[BUFLEN];\n\tint    busy;\n\tTAILQ_ENTRY(wds_buf) chain;\n} wds_buffer[BUFCNT];\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nvoid    wds_free_scb;\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nvoid    wds_done;\nvoid\twds_sense;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nvoid\nwds_done(sc, scb, stat)\n\tstruct wds_softc *sc;\n\tstruct wds_scb *scb;\n\tu_int8_t stat;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\n\t/* XXXXX */\n\n\t/* Don't release the SCB if it was an internal command. */\n\tif (xs == 0) {\n\t\tscb->flags |= SCB_DONE;\n\t\treturn;\n\t}\n\n\t/* Sense handling. */\n\tif (xs->error == XS_SENSE) {\n\t\tbcopy(&scb->sense_data, &xs->sense, sizeof (struct scsi_sense_data));\n\t} else {\n\t\tif (xs->error == XS_NOERROR) {\n\t\t\t/* If all went well, or an error is acceptable. */\n\t\t\tif (stat == WDS_MBI_OK) {\n\t\t\t\t/* OK, set the result */\n\t\t\t\txs->resid = 0;\n\t\t\t} else {\n\t\t\t\t/* Check the mailbox status. */\n\t\t\t\tswitch (stat) {\n\t\t\t\tcase WDS_MBI_OKERR:\n\t\t\t\t\t/* SCSI error recorded in scb, counts as WDS_MBI_OK */\n\t\t\t\t\tswitch (scb->cmd.venderr) {\n\t\t\t\t\tcase 0x00:\n\t\t\t\t\t\tprintf(\"%s: Is this an error?\\n\", sc->sc_dev.dv_xname);\n\t\t\t\t\t\txs->error = XS_DRIVER_STUFFUP; /* Experiment */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x01:\n\t\t\t\t\t\t/*printf(\"%s: OK, see SCSI error field.\\n\", sc->sc_dev.dv_xname);*/\n\t\t\t\t\t\tif (scb->cmd.stat == SCSI_CHECK) {\n\t\t\t\t\t\t\t/* Do sense. */\n\t\t\t\t\t\t\twds_sense (sc, scb);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (scb->cmd.stat == SCSI_BUSY) {\n\t\t\t\t\t\t\txs->error = XS_BUSY;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x40:\n\t\t\t\t\t\t/*printf(\"%s: DMA underrun!\\n\", sc->sc_dev.dv_xname);*/\n\t\t\t\t\t\t/* Hits this if the target returns fewer that datalen bytes (eg my CD-ROM,\n\t\t\t\t\t\twhich returns a short version string, or if DMA is turned off etc. */\n\t\t\t\t\t\txs->resid = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintf(\"%s: VENDOR ERROR %02x, scsi %02x\\n\", sc->sc_dev.dv_xname, scb->cmd.venderr, scb->cmd.stat);\n\t\t\t\t\t\txs->error = XS_DRIVER_STUFFUP; /* Experiment */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase WDS_MBI_ETIME:\n\t\t\t\t\t/*\n\t\t\t\t\t * The documentation isn't clear on\n\t\t\t\t\t * what conditions might generate this,\n\t\t\t\t\t * but selection timeouts are the only\n\t\t\t\t\t * one I can think of.\n\t\t\t\t\t */\n\t\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WDS_MBI_ERESET:\n\t\t\t\tcase WDS_MBI_ETARCMD:\n\t\t\t\tcase WDS_MBI_ERESEL:\n\t\t\t\tcase WDS_MBI_ESEL:\n\t\t\t\tcase WDS_MBI_EABORT:\n\t\t\t\tcase WDS_MBI_ESRESET:\n\t\t\t\tcase WDS_MBI_EHRESET:\n\t\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} /* else sense */\n\n\t\tif (NEEDBUFFER(sc) && xs->datalen) {\n\t\t\tif (xs->flags & SCSI_DATA_IN)\n\t\t\t\tbcopy(scb->buf->data, xs->data, xs->datalen);\n\t\t}\n\t} /* XS_NOERROR */\n\n#ifdef notyet\n\tif (scb->data_nseg) {\n\t\tif (xs->flags & SCSI_DATA_IN)\n\t\t\tisadma_copyfrombuf(xs->data, xs->datalen,\n\t\t\t    scb->data_nseg, scb->data_phys);\n\t\tisadma_unmap(xs->data, xs->datalen,\n\t\t    scb->data_nseg, scb->data_phys);\n\t}\n#endif\n\twds_free_scb(sc, scb);\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isadma_copyfrombuf",
          "args": [
            "(caddr_t)scb",
            "SCB_PHYS_SIZE",
            "1",
            "scb->scb_phys"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "wds_timeout",
            "scb"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"scb addr = 0x%x\\n\"",
            "scb"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wds_scb_phys_kv",
          "args": [
            "sc",
            "phystol(wmbi->scb_addr)"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phystol",
          "args": [
            "wmbi->scb_addr"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_nextmbx",
          "args": [
            "wmbi",
            "wmbx",
            "mbi"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(&sc->sc_mbx)\n#define WDS_MBX_SIZE\t16\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\nintegrate void;\nwds_finish_scbs __P((struct wds_softc *));\nintegrate void;\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nintegrate void;\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nstruct\twds_scb *wds_scb_phys_kv;\nvoid    wds_done;\nvoid\twds_timeout;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\nu_long scb_phys;\n\nintegrate void\nwds_finish_scbs(sc)\n\tstruct wds_softc *sc;\n{\n\tstruct wds_mbx_in *wmbi;\n\tstruct wds_scb *scb;\n\tint i;\n\n\twmbi = wmbx->tmbi;\n\n\tif (wmbi->stat == WDS_MBI_FREE) {\n\t\tfor (i = 0; i < WDS_MBX_SIZE; i++) {\n\t\t\tif (wmbi->stat != WDS_MBI_FREE) {\n\t\t\t\tprintf(\"%s: mbi not in round-robin order\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tgoto AGAIN;\n\t\t\t}\n\t\t\twds_nextmbx(wmbi, wmbx, mbi);\n\t\t}\n#ifdef WDSDIAGnot\n\t\tprintf(\"%s: mbi interrupt with no full mailboxes\\n\",\n\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\treturn;\n\t}\n\nAGAIN:\n\tdo {\n\t\tscb = wds_scb_phys_kv(sc, phystol(wmbi->scb_addr));\n\t\tif (!scb) {\n\t\t\tprintf(\"%s: bad mbi scb pointer; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto next;\n\t\t}\n\n#ifdef WDSDEBUG\n\t\tif (wds_debug) {\n\t\t\tu_int8_t *cp = (u_int8_t *)&scb->cmd.scb;\n\t\t\tprintf(\"op=%x %x %x %x %x %x\\n\",\n\t\t\t    cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);\n\t\t\tprintf(\"stat %x for mbi addr = 0x%08x, \",\n\t\t\t    wmbi->stat, wmbi);\n\t\t\tprintf(\"scb addr = 0x%x\\n\", scb);\n\t\t}\n#endif /* WDSDEBUG */\n\n\t\tuntimeout(wds_timeout, scb);\n#ifdef notyet\n\t\tisadma_copyfrombuf((caddr_t)scb, SCB_PHYS_SIZE,\n\t\t    1, scb->scb_phys);\n#endif\n\t\twds_done(sc, scb, wmbi->stat);\n\n\tnext:\n\t\twmbi->stat = WDS_MBI_FREE;\n\t\twds_nextmbx(wmbi, wmbx, mbi);\n\t} while (wmbi->stat != WDS_MBI_FREE);\n\n\twmbx->tmbi = wmbi;\n}"
  },
  {
    "function_name": "wdsattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "284-332",
    "snippet": "void\nwdsattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tstruct wds_softc *sc = (void *)self;\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\n\tif (bus_space_map(iot, ia->ia_iobase, WDS_IO_PORTS, 0, &ioh)) {\n\t\tprintf(\"%s: can't map i/o space\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tif (!wds_find(ia, sc))\n\t\tpanic(\"wdsattach: wds_find of %s failed\", self->dv_xname);\n\twds_init(sc);\n\n\tif (sc->sc_drq != DRQUNK)\n\t\tisadma_cascade(sc->sc_drq);\n\n\tTAILQ_INIT(&sc->sc_free_scb);\n\tTAILQ_INIT(&sc->sc_waiting_scb);\n\twds_inquire_setup_information(sc);\n\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n#ifdef notyet\n\tsc->sc_link.channel = SCSI_CHANNEL_ONLY_ONE;\n#endif\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->sc_scsi_dev;\n\tsc->sc_link.adapter = &wds_switch;\n\tsc->sc_link.device = &wds_dev;\n\t/* XXX */\n\t/* I don't think the -ASE can handle openings > 1. */\n\t/* It gives Vendor Error 26 whenever I try it.     */\n\tsc->sc_link.openings = 1;\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, sc->sc_irq, IST_EDGE,\n\t    IPL_BIO, wdsintr, sc, sc->sc_dev.dv_xname);\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n\tconfig_found(self, &sc->sc_link, wdsprint);\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
      "wds_finish_scbs __P((struct wds_softc *));",
      "int     wdsintr",
      "int\twds_find",
      "void\twds_init",
      "void\twds_inquire_setup_information",
      "int\twdsprint",
      "struct scsi_adapter wds_switch = {\n\twds_scsi_cmd,\n\twdsminphys,\n\t0,\n\t0,\n};",
      "struct scsi_device wds_dev = {\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};",
      "void\twdsattach",
      "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
      "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
      "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "self",
            "&sc->sc_link",
            "wdsprint"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "sc->sc_irq",
            "IST_EDGE",
            "IPL_BIO",
            "wdsintr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_inquire_setup_information",
          "args": [
            "sc"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "wds_inquire_setup_information",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "983-1027",
          "snippet": "void\nwds_inquire_setup_information(sc)\n\tstruct wds_softc *sc;\n{\n\tstruct wds_scb *scb;\n\tu_char *j;\n\tint s;\n\n\tif ((scb = wds_get_scb(sc, SCSI_NOSLEEP, 0)) == NULL) {\n\t\tprintf(\"%s: no request slot available in getvers()!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\tscb->xs = NULL;\n\tscb->timeout = 40;\n\n\tbzero(&scb->cmd, sizeof scb->cmd);\n\tscb->cmd.write = 0x80;\n\tscb->cmd.opcode = WDSX_GETFIRMREV;\n\n\t/* Will poll card, await result. */\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, WDS_HCR, WDSH_DRQEN);\n\tscb->flags |= SCB_POLLED;\n\n\ts = splbio();\n\twds_queue_scb(sc, scb);\n\tsplx(s);\n\n\tif (wds_ipoll(sc, scb, scb->timeout))\n\t\tgoto out;\n\n\t/* Print the version number. */\n\tprintf(\": version %x.%02x \", scb->cmd.targ, scb->cmd.scb.opcode);\n\tsc->sc_revision = (scb->cmd.targ << 8) | scb->cmd.scb.opcode;\n\t/* Print out the version string. */\n\tj = 2 + &(scb->cmd.targ);\n\twhile ((*j >= 32) && (*j < 128)) {\n\t\tprintf(\"%c\", *j);\n\t\tj++;\n\t}\n\nout:\n\tprintf(\"\\n\");\n\twds_free_scb(sc, scb);\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wds_finish_scbs __P((struct wds_softc *));",
            "wds_reset_scb __P((struct wds_softc *, struct wds_scb *));",
            "void    wds_free_scb",
            "wds_init_scb __P((struct wds_softc *, struct wds_scb *));",
            "struct\twds_scb *wds_get_scb",
            "void\twds_queue_scb",
            "void\twds_inquire_setup_information",
            "int\twds_ipoll",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "int flags;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_finish_scbs __P((struct wds_softc *));\nwds_reset_scb __P((struct wds_softc *, struct wds_scb *));\nvoid    wds_free_scb;\nwds_init_scb __P((struct wds_softc *, struct wds_scb *));\nstruct\twds_scb *wds_get_scb;\nvoid\twds_queue_scb;\nvoid\twds_inquire_setup_information;\nint\twds_ipoll;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nint flags;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nvoid\nwds_inquire_setup_information(sc)\n\tstruct wds_softc *sc;\n{\n\tstruct wds_scb *scb;\n\tu_char *j;\n\tint s;\n\n\tif ((scb = wds_get_scb(sc, SCSI_NOSLEEP, 0)) == NULL) {\n\t\tprintf(\"%s: no request slot available in getvers()!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\tscb->xs = NULL;\n\tscb->timeout = 40;\n\n\tbzero(&scb->cmd, sizeof scb->cmd);\n\tscb->cmd.write = 0x80;\n\tscb->cmd.opcode = WDSX_GETFIRMREV;\n\n\t/* Will poll card, await result. */\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, WDS_HCR, WDSH_DRQEN);\n\tscb->flags |= SCB_POLLED;\n\n\ts = splbio();\n\twds_queue_scb(sc, scb);\n\tsplx(s);\n\n\tif (wds_ipoll(sc, scb, scb->timeout))\n\t\tgoto out;\n\n\t/* Print the version number. */\n\tprintf(\": version %x.%02x \", scb->cmd.targ, scb->cmd.scb.opcode);\n\tsc->sc_revision = (scb->cmd.targ << 8) | scb->cmd.scb.opcode;\n\t/* Print out the version string. */\n\tj = 2 + &(scb->cmd.targ);\n\twhile ((*j >= 32) && (*j < 128)) {\n\t\tprintf(\"%c\", *j);\n\t\tj++;\n\t}\n\nout:\n\tprintf(\"\\n\");\n\twds_free_scb(sc, scb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->sc_waiting_scb"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->sc_free_scb"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_cascade",
          "args": [
            "sc->sc_drq"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_init",
          "args": [
            "sc"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "wds_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "923-978",
          "snippet": "void\nwds_init(sc)\n\tstruct wds_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct wds_setup init;\n\tu_char c;\n\tint i;\n#ifdef notyet\n\tstruct isadma_seg mbx_phys[1];\n#endif\n\n\t/*\n\t * Set up initial mail box for round-robin operation.\n\t */\n\tfor (i = 0; i < WDS_MBX_SIZE; i++) {\n\t\twmbx->mbo[i].cmd = WDS_MBO_FREE;\n\t\twmbx->mbi[i].stat = WDS_MBI_FREE;\n\t}\n\twmbx->cmbo = wmbx->tmbo = &wmbx->mbo[0];\n\twmbx->tmbi = &wmbx->mbi[0];\n\tsc->sc_mbofull = 0;\n\n\t/* Clear the buffers. */\n\tTAILQ_INIT(&wds_free_buffer);\n\tfor (i = 0; i < BUFCNT; i++) {\n\t\twds_buffer[i].busy = 0;\n\t\tTAILQ_INSERT_HEAD(&wds_free_buffer, &wds_buffer[i], chain);\n\t}\n\n\tinit.opcode = WDSC_INIT;\n\tinit.scsi_id = sc->sc_scsi_dev;\n\t/* Record scsi id of controller for use in scsi_attach */\n\tsc->sc_scsi_dev = init.scsi_id;\n\tinit.buson_t = 48;\n\tinit.busoff_t = 24;\n\tinit.xx = 0;\n#ifdef notyet\n\tif (isadma_map((caddr_t)(wmbx), sizeof(struct wds_mbx),\n\t    mbx_phys, ISADMA_MAP_CONTIG) != 1)\n\t\tpanic(\"wds_init: cannot map mail box\");\n\tltophys(mbx_phys[0].addr, init.mbaddr);\n#else\n\tltophys(KVTOPHYS(wmbx), init.mbaddr);\n#endif\n\tinit.nomb = init.nimb = WDS_MBX_SIZE;\n\twds_cmd(sc, (u_char *)&init, sizeof init);\n\n\twds_wait(iot, ioh, WDS_STAT, WDSS_INIT, WDSS_INIT);\n\n\tc = WDSC_DISUNSOL;\n\twds_cmd(sc, &c, sizeof c);\n\n\tbus_space_write_1(iot, ioh, WDS_HCR, WDSH_DRQEN);\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define BUFCNT 8",
            "#define\twmbx\t(&sc->sc_mbx)",
            "#define WDS_MBX_SIZE\t16"
          ],
          "globals_used": [
            "TAILQ_HEAD(, wds_buf) wds_free_buffer;",
            "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
            "int     wds_cmd",
            "wds_finish_scbs __P((struct wds_softc *));",
            "void\twds_init",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define BUFCNT 8\n#define\twmbx\t(&sc->sc_mbx)\n#define WDS_MBX_SIZE\t16\n\nTAILQ_HEAD(, wds_buf) wds_free_buffer;\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nint     wds_cmd;\nwds_finish_scbs __P((struct wds_softc *));\nvoid\twds_init;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nvoid\nwds_init(sc)\n\tstruct wds_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct wds_setup init;\n\tu_char c;\n\tint i;\n#ifdef notyet\n\tstruct isadma_seg mbx_phys[1];\n#endif\n\n\t/*\n\t * Set up initial mail box for round-robin operation.\n\t */\n\tfor (i = 0; i < WDS_MBX_SIZE; i++) {\n\t\twmbx->mbo[i].cmd = WDS_MBO_FREE;\n\t\twmbx->mbi[i].stat = WDS_MBI_FREE;\n\t}\n\twmbx->cmbo = wmbx->tmbo = &wmbx->mbo[0];\n\twmbx->tmbi = &wmbx->mbi[0];\n\tsc->sc_mbofull = 0;\n\n\t/* Clear the buffers. */\n\tTAILQ_INIT(&wds_free_buffer);\n\tfor (i = 0; i < BUFCNT; i++) {\n\t\twds_buffer[i].busy = 0;\n\t\tTAILQ_INSERT_HEAD(&wds_free_buffer, &wds_buffer[i], chain);\n\t}\n\n\tinit.opcode = WDSC_INIT;\n\tinit.scsi_id = sc->sc_scsi_dev;\n\t/* Record scsi id of controller for use in scsi_attach */\n\tsc->sc_scsi_dev = init.scsi_id;\n\tinit.buson_t = 48;\n\tinit.busoff_t = 24;\n\tinit.xx = 0;\n#ifdef notyet\n\tif (isadma_map((caddr_t)(wmbx), sizeof(struct wds_mbx),\n\t    mbx_phys, ISADMA_MAP_CONTIG) != 1)\n\t\tpanic(\"wds_init: cannot map mail box\");\n\tltophys(mbx_phys[0].addr, init.mbaddr);\n#else\n\tltophys(KVTOPHYS(wmbx), init.mbaddr);\n#endif\n\tinit.nomb = init.nimb = WDS_MBX_SIZE;\n\twds_cmd(sc, (u_char *)&init, sizeof init);\n\n\twds_wait(iot, ioh, WDS_STAT, WDSS_INIT, WDSS_INIT);\n\n\tc = WDSC_DISUNSOL;\n\twds_cmd(sc, &c, sizeof c);\n\n\tbus_space_write_1(iot, ioh, WDS_HCR, WDSH_DRQEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wdsattach: wds_find of %s failed\"",
            "self->dv_xname"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_find",
          "args": [
            "ia",
            "sc"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "wds_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "851-918",
          "snippet": "int\nwds_find(ia, sc)\n\tstruct isa_attach_args *ia;\n\tstruct wds_softc *sc;\n{\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tu_char c;\n\tint i;\n\n\t/*\n\t * Sending a command causes the CMDRDY bit to clear.\n \t */\n\tc = bus_space_read_1(iot, ioh, WDS_STAT);\n\tfor (i = 0; i < 4; i++)\n\t\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_RDY) != 0) {\n\t\t\tgoto ready;\n\t\tdelay(10);\n\t}\n\treturn (0);\n\nready:\n\tbus_space_write_1(iot, ioh, WDS_CMD, WDSC_NOOP);\n\tif (bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_RDY)\n\t\treturn (0);\n\n\tbus_space_write_1(iot, ioh, WDS_HCR, WDSH_SCSIRESET|WDSH_ASCRESET);\n\tdelay(10000);\n\tbus_space_write_1(iot, ioh, WDS_HCR, 0x00);\n\tdelay(500000);\n\twds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);\n\tif (bus_space_read_1(iot, ioh, WDS_IRQSTAT) != 1)\n\t\tif (bus_space_read_1(iot, ioh, WDS_IRQSTAT) != 7)\n\t\t\tprintf(\"%s: failed reset!!! %2x\\n\",\n\t\t\t    sc ? sc->sc_dev.dv_xname : \"wds?\",\n\t\t\t    bus_space_read_1(iot, ioh, WDS_IRQSTAT));\n\n\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & (WDSS_RDY)) != WDSS_RDY) {\n\t\tprintf(\"%s: waiting for controller to become ready.\",\n\t\t    sc ? sc->sc_dev.dv_xname : \"wds?\");\n\t\tfor (i = 0; i < 20; i++) {\n\t\t\tif ((bus_space_read_1(iot, ioh, WDS_STAT) &\n\t\t\t    (WDSS_RDY)) == WDSS_RDY)\n\t\t\t\tbreak;\n\t\t\tprintf(\".\");\n\t\t\tdelay(10000);\n\t\t}\n\t\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & (WDSS_RDY)) !=\n\t\t    WDSS_RDY) {\n\t\t\tprintf(\" failed\\n\");\n\t\t\treturn (0);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tif (sc != NULL) {\n\t\t/* XXX Can we do this better? */\n\t\t/* who are we on the scsi bus? */\n\t\tsc->sc_scsi_dev = 7;\n\n\t\tsc->sc_iot = iot;\n\t\tsc->sc_ioh = ioh;\n\t\tsc->sc_irq = ia->ia_irq;\n\t\tsc->sc_drq = ia->ia_drq;\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
            "wds_finish_scbs __P((struct wds_softc *));",
            "int\twds_find",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nwds_finish_scbs __P((struct wds_softc *));\nint\twds_find;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nint\nwds_find(ia, sc)\n\tstruct isa_attach_args *ia;\n\tstruct wds_softc *sc;\n{\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tu_char c;\n\tint i;\n\n\t/*\n\t * Sending a command causes the CMDRDY bit to clear.\n \t */\n\tc = bus_space_read_1(iot, ioh, WDS_STAT);\n\tfor (i = 0; i < 4; i++)\n\t\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_RDY) != 0) {\n\t\t\tgoto ready;\n\t\tdelay(10);\n\t}\n\treturn (0);\n\nready:\n\tbus_space_write_1(iot, ioh, WDS_CMD, WDSC_NOOP);\n\tif (bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_RDY)\n\t\treturn (0);\n\n\tbus_space_write_1(iot, ioh, WDS_HCR, WDSH_SCSIRESET|WDSH_ASCRESET);\n\tdelay(10000);\n\tbus_space_write_1(iot, ioh, WDS_HCR, 0x00);\n\tdelay(500000);\n\twds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);\n\tif (bus_space_read_1(iot, ioh, WDS_IRQSTAT) != 1)\n\t\tif (bus_space_read_1(iot, ioh, WDS_IRQSTAT) != 7)\n\t\t\tprintf(\"%s: failed reset!!! %2x\\n\",\n\t\t\t    sc ? sc->sc_dev.dv_xname : \"wds?\",\n\t\t\t    bus_space_read_1(iot, ioh, WDS_IRQSTAT));\n\n\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & (WDSS_RDY)) != WDSS_RDY) {\n\t\tprintf(\"%s: waiting for controller to become ready.\",\n\t\t    sc ? sc->sc_dev.dv_xname : \"wds?\");\n\t\tfor (i = 0; i < 20; i++) {\n\t\t\tif ((bus_space_read_1(iot, ioh, WDS_STAT) &\n\t\t\t    (WDSS_RDY)) == WDSS_RDY)\n\t\t\t\tbreak;\n\t\t\tprintf(\".\");\n\t\t\tdelay(10000);\n\t\t}\n\t\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & (WDSS_RDY)) !=\n\t\t    WDSS_RDY) {\n\t\t\tprintf(\" failed\\n\");\n\t\t\treturn (0);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tif (sc != NULL) {\n\t\t/* XXX Can we do this better? */\n\t\t/* who are we on the scsi bus? */\n\t\tsc->sc_scsi_dev = 7;\n\n\t\tsc->sc_iot = iot;\n\t\tsc->sc_ioh = ioh;\n\t\tsc->sc_irq = ia->ia_irq;\n\t\tsc->sc_drq = ia->ia_drq;\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: can't map i/o space\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "ia->ia_iobase",
            "WDS_IO_PORTS",
            "0",
            "&ioh"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nwds_finish_scbs __P((struct wds_softc *));\nint     wdsintr;\nint\twds_find;\nvoid\twds_init;\nvoid\twds_inquire_setup_information;\nint\twdsprint;\nstruct scsi_adapter wds_switch = {\n\twds_scsi_cmd,\n\twdsminphys,\n\t0,\n\t0,\n};\nstruct scsi_device wds_dev = {\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};\nvoid\twdsattach;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nvoid\nwdsattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tstruct wds_softc *sc = (void *)self;\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\n\tif (bus_space_map(iot, ia->ia_iobase, WDS_IO_PORTS, 0, &ioh)) {\n\t\tprintf(\"%s: can't map i/o space\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tif (!wds_find(ia, sc))\n\t\tpanic(\"wdsattach: wds_find of %s failed\", self->dv_xname);\n\twds_init(sc);\n\n\tif (sc->sc_drq != DRQUNK)\n\t\tisadma_cascade(sc->sc_drq);\n\n\tTAILQ_INIT(&sc->sc_free_scb);\n\tTAILQ_INIT(&sc->sc_waiting_scb);\n\twds_inquire_setup_information(sc);\n\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n#ifdef notyet\n\tsc->sc_link.channel = SCSI_CHANNEL_ONLY_ONE;\n#endif\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->sc_scsi_dev;\n\tsc->sc_link.adapter = &wds_switch;\n\tsc->sc_link.device = &wds_dev;\n\t/* XXX */\n\t/* I don't think the -ASE can handle openings > 1. */\n\t/* It gives Vendor Error 26 whenever I try it.     */\n\tsc->sc_link.openings = 1;\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, sc->sc_irq, IST_EDGE,\n\t    IPL_BIO, wdsintr, sc, sc->sc_dev.dv_xname);\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n\tconfig_found(self, &sc->sc_link, wdsprint);\n}"
  },
  {
    "function_name": "wdsprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "270-279",
    "snippet": "int\nwdsprint(aux, name)\n\tvoid *aux;\n\tconst char *name;\n{\n\n\tif (name != NULL)\n\t\tprintf(\"%s: scsibus \", name);\n\treturn UNCONF;\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twdsprint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: scsibus \"",
            "name"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\twdsprint;\n\nint\nwdsprint(aux, name)\n\tvoid *aux;\n\tconst char *name;\n{\n\n\tif (name != NULL)\n\t\tprintf(\"%s: scsibus \", name);\n\treturn UNCONF;\n}"
  },
  {
    "function_name": "wdsprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "244-268",
    "snippet": "int\nwdsprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tregister struct isa_attach_args *ia = aux;\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tint rv;\n\n\tif (bus_space_map(iot, ia->ia_iobase, WDS_IO_PORTS, 0, &ioh))\n\t\treturn (0);\n\n\t/* See if there is a unit at this location. */\n\trv = wds_find(ia, NULL);\n\n\tbus_space_unmap(iot, ioh, WDS_IO_PORTS);\n\n\tif (rv) {\n\t\tia->ia_msize = 0;\n\t\tia->ia_iosize = WDS_IO_PORTS;\n\t}\n\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
      "int\twds_find",
      "int\twdsprobe"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh",
            "WDS_IO_PORTS"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_find",
          "args": [
            "ia",
            "NULL"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "wds_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "851-918",
          "snippet": "int\nwds_find(ia, sc)\n\tstruct isa_attach_args *ia;\n\tstruct wds_softc *sc;\n{\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tu_char c;\n\tint i;\n\n\t/*\n\t * Sending a command causes the CMDRDY bit to clear.\n \t */\n\tc = bus_space_read_1(iot, ioh, WDS_STAT);\n\tfor (i = 0; i < 4; i++)\n\t\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_RDY) != 0) {\n\t\t\tgoto ready;\n\t\tdelay(10);\n\t}\n\treturn (0);\n\nready:\n\tbus_space_write_1(iot, ioh, WDS_CMD, WDSC_NOOP);\n\tif (bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_RDY)\n\t\treturn (0);\n\n\tbus_space_write_1(iot, ioh, WDS_HCR, WDSH_SCSIRESET|WDSH_ASCRESET);\n\tdelay(10000);\n\tbus_space_write_1(iot, ioh, WDS_HCR, 0x00);\n\tdelay(500000);\n\twds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);\n\tif (bus_space_read_1(iot, ioh, WDS_IRQSTAT) != 1)\n\t\tif (bus_space_read_1(iot, ioh, WDS_IRQSTAT) != 7)\n\t\t\tprintf(\"%s: failed reset!!! %2x\\n\",\n\t\t\t    sc ? sc->sc_dev.dv_xname : \"wds?\",\n\t\t\t    bus_space_read_1(iot, ioh, WDS_IRQSTAT));\n\n\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & (WDSS_RDY)) != WDSS_RDY) {\n\t\tprintf(\"%s: waiting for controller to become ready.\",\n\t\t    sc ? sc->sc_dev.dv_xname : \"wds?\");\n\t\tfor (i = 0; i < 20; i++) {\n\t\t\tif ((bus_space_read_1(iot, ioh, WDS_STAT) &\n\t\t\t    (WDSS_RDY)) == WDSS_RDY)\n\t\t\t\tbreak;\n\t\t\tprintf(\".\");\n\t\t\tdelay(10000);\n\t\t}\n\t\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & (WDSS_RDY)) !=\n\t\t    WDSS_RDY) {\n\t\t\tprintf(\" failed\\n\");\n\t\t\treturn (0);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tif (sc != NULL) {\n\t\t/* XXX Can we do this better? */\n\t\t/* who are we on the scsi bus? */\n\t\tsc->sc_scsi_dev = 7;\n\n\t\tsc->sc_iot = iot;\n\t\tsc->sc_ioh = ioh;\n\t\tsc->sc_irq = ia->ia_irq;\n\t\tsc->sc_drq = ia->ia_drq;\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
            "wds_finish_scbs __P((struct wds_softc *));",
            "int\twds_find",
            "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
            "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
            "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nwds_finish_scbs __P((struct wds_softc *));\nint\twds_find;\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nint\nwds_find(ia, sc)\n\tstruct isa_attach_args *ia;\n\tstruct wds_softc *sc;\n{\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tu_char c;\n\tint i;\n\n\t/*\n\t * Sending a command causes the CMDRDY bit to clear.\n \t */\n\tc = bus_space_read_1(iot, ioh, WDS_STAT);\n\tfor (i = 0; i < 4; i++)\n\t\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_RDY) != 0) {\n\t\t\tgoto ready;\n\t\tdelay(10);\n\t}\n\treturn (0);\n\nready:\n\tbus_space_write_1(iot, ioh, WDS_CMD, WDSC_NOOP);\n\tif (bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_RDY)\n\t\treturn (0);\n\n\tbus_space_write_1(iot, ioh, WDS_HCR, WDSH_SCSIRESET|WDSH_ASCRESET);\n\tdelay(10000);\n\tbus_space_write_1(iot, ioh, WDS_HCR, 0x00);\n\tdelay(500000);\n\twds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);\n\tif (bus_space_read_1(iot, ioh, WDS_IRQSTAT) != 1)\n\t\tif (bus_space_read_1(iot, ioh, WDS_IRQSTAT) != 7)\n\t\t\tprintf(\"%s: failed reset!!! %2x\\n\",\n\t\t\t    sc ? sc->sc_dev.dv_xname : \"wds?\",\n\t\t\t    bus_space_read_1(iot, ioh, WDS_IRQSTAT));\n\n\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & (WDSS_RDY)) != WDSS_RDY) {\n\t\tprintf(\"%s: waiting for controller to become ready.\",\n\t\t    sc ? sc->sc_dev.dv_xname : \"wds?\");\n\t\tfor (i = 0; i < 20; i++) {\n\t\t\tif ((bus_space_read_1(iot, ioh, WDS_STAT) &\n\t\t\t    (WDSS_RDY)) == WDSS_RDY)\n\t\t\t\tbreak;\n\t\t\tprintf(\".\");\n\t\t\tdelay(10000);\n\t\t}\n\t\tif ((bus_space_read_1(iot, ioh, WDS_STAT) & (WDSS_RDY)) !=\n\t\t    WDSS_RDY) {\n\t\t\tprintf(\" failed\\n\");\n\t\t\treturn (0);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tif (sc != NULL) {\n\t\t/* XXX Can we do this better? */\n\t\t/* who are we on the scsi bus? */\n\t\tsc->sc_scsi_dev = 7;\n\n\t\tsc->sc_iot = iot;\n\t\tsc->sc_ioh = ioh;\n\t\tsc->sc_irq = ia->ia_irq;\n\t\tsc->sc_drq = ia->ia_drq;\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "ia->ia_iobase",
            "WDS_IO_PORTS",
            "0",
            "&ioh"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nint\twds_find;\nint\twdsprobe;\n\nint\nwdsprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tregister struct isa_attach_args *ia = aux;\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tint rv;\n\n\tif (bus_space_map(iot, ia->ia_iobase, WDS_IO_PORTS, 0, &ioh))\n\t\treturn (0);\n\n\t/* See if there is a unit at this location. */\n\trv = wds_find(ia, NULL);\n\n\tbus_space_unmap(iot, ioh, WDS_IO_PORTS);\n\n\tif (rv) {\n\t\tia->ia_msize = 0;\n\t\tia->ia_iosize = WDS_IO_PORTS;\n\t}\n\n\treturn (rv);\n}"
  },
  {
    "function_name": "wds_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "218-239",
    "snippet": "int\nwds_cmd(sc, ibuf, icnt)\n\tstruct wds_softc *sc;\n\tu_int8_t *ibuf;\n\tint icnt;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int8_t c;\n\n\twds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);\n\n\twhile (icnt--) {\n\t\tbus_space_write_1(iot, ioh, WDS_CMD, *ibuf++);\n\t\twds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);\n\t\tc = bus_space_read_1(iot, ioh, WDS_STAT);\n\t\tif (c & WDSS_REJ)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
      "int     wds_cmd",
      "wds_finish_scbs __P((struct wds_softc *));",
      "struct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;",
      "struct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;",
      "struct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "WDS_STAT"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wds_wait",
          "args": [
            "iot",
            "ioh",
            "WDS_STAT",
            "WDSS_RDY",
            "WDSS_RDY"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "wds_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
          "lines": "203-213",
          "snippet": "integrate void\nwds_wait(iot, ioh, port, mask, val)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint port;\n\tint mask;\n\tint val;\n{\n\twhile ((bus_space_read_1(iot, ioh, port) & mask) != val)\n\t\t;\n}",
          "includes": [
            "#include <dev/isa/wdsreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tintegrate\tstatic inline",
            "#define\tintegrate"
          ],
          "globals_used": [
            "integrate void",
            "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
            "integrate void",
            "integrate void",
            "integrate void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nintegrate void;\nintegrate void;\nintegrate void;\n\nintegrate void\nwds_wait(iot, ioh, port, mask, val)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint port;\n\tint mask;\n\tint val;\n{\n\twhile ((bus_space_read_1(iot, ioh, port) & mask) != val)\n\t\t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "WDS_CMD",
            "*ibuf++"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nint     wds_cmd;\nwds_finish_scbs __P((struct wds_softc *));\nstruct wds_scb *\nwds_get_scb(sc, flags, needbuffer)\n\tstruct wds_softc *sc;\nstruct wds_buf *\nwds_get_buf(sc, flags)\n\tstruct wds_softc *sc;\nstruct wds_scb *\nwds_scb_phys_kv(sc, scb_phys)\n\tstruct wds_softc *sc;\n\nint\nwds_cmd(sc, ibuf, icnt)\n\tstruct wds_softc *sc;\n\tu_int8_t *ibuf;\n\tint icnt;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int8_t c;\n\n\twds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);\n\n\twhile (icnt--) {\n\t\tbus_space_write_1(iot, ioh, WDS_CMD, *ibuf++);\n\t\twds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);\n\t\tc = bus_space_read_1(iot, ioh, WDS_STAT);\n\t\tif (c & WDSS_REJ)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "wds_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wds.c",
    "lines": "203-213",
    "snippet": "integrate void\nwds_wait(iot, ioh, port, mask, val)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint port;\n\tint mask;\n\tint val;\n{\n\twhile ((bus_space_read_1(iot, ioh, port) & mask) != val)\n\t\t;\n}",
    "includes": [
      "#include <dev/isa/wdsreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tintegrate\tstatic inline",
      "#define\tintegrate"
    ],
    "globals_used": [
      "integrate void",
      "wds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));",
      "integrate void",
      "integrate void",
      "integrate void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "port"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wdsreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\nwds_wait\n    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));\nintegrate void;\nintegrate void;\nintegrate void;\n\nintegrate void\nwds_wait(iot, ioh, port, mask, val)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint port;\n\tint mask;\n\tint val;\n{\n\twhile ((bus_space_read_1(iot, ioh, port) & mask) != val)\n\t\t;\n}"
  }
]