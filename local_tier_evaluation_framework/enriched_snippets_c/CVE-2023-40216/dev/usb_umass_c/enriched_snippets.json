[
  {
    "function_name": "umass_atapi_probedev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "3412-3474",
    "snippet": "Static void\numass_atapi_probedev(atapi, target)\n\tstruct atapibus_softc *atapi;\n\tint target;\n{\n\tstruct scsipi_link *sc_link;\n\tstruct scsipibus_attach_args sa;\n\tstruct ata_drive_datas *drvp = &atapi->sc_drvs[target];\n\tchar vendor[33], product[65], revision[17];\n\tstruct scsipi_inquiry_data inqbuf;\n\n\tDPRINTF(UDMASS_SCSI,(\"umass_atapi_probedev: atapi=%p target=%d\\n\",\n\t\t\t     atapi, target));\n\n\tif (atapi->sc_link[target])\n\t\treturn;\n\n\tsc_link = malloc(sizeof(*sc_link), M_DEVBUF, M_NOWAIT); \n\tif (sc_link == NULL) {\n\t\tprintf(\"%s: can't allocate link for drive %d\\n\",\n\t\t       atapi->sc_dev.dv_xname, target);\n\t\treturn;       \n\t}\n\t*sc_link = *atapi->adapter_link;\n\n\tDIF(UDMASS_UPPER, sc_link->flags |= DEBUGLEVEL);\n\n\t/* Fill generic parts of the link. */\n\tsc_link->active = 0;\n\tsc_link->scsipi_atapi.drive = target;\n\tsc_link->device = &umass_dev;\n\tTAILQ_INIT(&sc_link->pending_xfers);\n\n\tDPRINTF(UDMASS_SCSI, (\"umass_atapi_probedev: doing inquiry\\n\"));\n\t/* Now go ask the device all about itself. */\n\tmemset(&inqbuf, 0, sizeof(inqbuf));\n\tif (scsipi_inquire(sc_link, &inqbuf, XS_CTL_DISCOVERY) != 0)\n\t\tgoto bad;\n\n\tscsipi_strvis(vendor, 33, inqbuf.vendor, 8);\n\tscsipi_strvis(product, 65, inqbuf.product, 16);\n\tscsipi_strvis(revision, 17, inqbuf.revision, 4);\n\n\tsa.sa_sc_link = sc_link;\n\tsa.sa_inqbuf.type = inqbuf.device;\n\tsa.sa_inqbuf.removable = inqbuf.dev_qual2 & SID_REMOVABLE ?\n\t    T_REMOV : T_FIXED;\n\tif (sa.sa_inqbuf.removable)\n\t\tsc_link->flags |= SDEV_REMOVABLE;\n\t/* XXX how? sc_link->scsipi_atapi.cap |= ACAP_LEN;*/\n\tsa.sa_inqbuf.vendor = vendor;\n\tsa.sa_inqbuf.product = product;\n\tsa.sa_inqbuf.revision = revision;\n\tsa.sa_inqptr = NULL;\n\n\tdrvp->drv_softc = atapi_probedev(atapi, target, sc_link, &sa);\n\t/* atapi_probedev() frees the scsipi_link when there is no device. */\n\treturn;\n\nbad:\n\tfree(sc_link, M_DEVBUF);\n\treturn;\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UDMASS_SCSI\t0x00020000\t/* scsi */",
      "#define UDMASS_UPPER\t0x00008000\t/* upper layer */"
    ],
    "globals_used": [
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "struct scsipi_link *sc_link = xs->sc_link;",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sc_link",
            "M_DEVBUF"
          ],
          "line": 3472
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atapi_probedev",
          "args": [
            "atapi",
            "target",
            "sc_link",
            "&sa"
          ],
          "line": 3467
        },
        "resolved": true,
        "details": {
          "function_name": "umass_atapi_probedev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "3412-3474",
          "snippet": "Static void\numass_atapi_probedev(atapi, target)\n\tstruct atapibus_softc *atapi;\n\tint target;\n{\n\tstruct scsipi_link *sc_link;\n\tstruct scsipibus_attach_args sa;\n\tstruct ata_drive_datas *drvp = &atapi->sc_drvs[target];\n\tchar vendor[33], product[65], revision[17];\n\tstruct scsipi_inquiry_data inqbuf;\n\n\tDPRINTF(UDMASS_SCSI,(\"umass_atapi_probedev: atapi=%p target=%d\\n\",\n\t\t\t     atapi, target));\n\n\tif (atapi->sc_link[target])\n\t\treturn;\n\n\tsc_link = malloc(sizeof(*sc_link), M_DEVBUF, M_NOWAIT); \n\tif (sc_link == NULL) {\n\t\tprintf(\"%s: can't allocate link for drive %d\\n\",\n\t\t       atapi->sc_dev.dv_xname, target);\n\t\treturn;       \n\t}\n\t*sc_link = *atapi->adapter_link;\n\n\tDIF(UDMASS_UPPER, sc_link->flags |= DEBUGLEVEL);\n\n\t/* Fill generic parts of the link. */\n\tsc_link->active = 0;\n\tsc_link->scsipi_atapi.drive = target;\n\tsc_link->device = &umass_dev;\n\tTAILQ_INIT(&sc_link->pending_xfers);\n\n\tDPRINTF(UDMASS_SCSI, (\"umass_atapi_probedev: doing inquiry\\n\"));\n\t/* Now go ask the device all about itself. */\n\tmemset(&inqbuf, 0, sizeof(inqbuf));\n\tif (scsipi_inquire(sc_link, &inqbuf, XS_CTL_DISCOVERY) != 0)\n\t\tgoto bad;\n\n\tscsipi_strvis(vendor, 33, inqbuf.vendor, 8);\n\tscsipi_strvis(product, 65, inqbuf.product, 16);\n\tscsipi_strvis(revision, 17, inqbuf.revision, 4);\n\n\tsa.sa_sc_link = sc_link;\n\tsa.sa_inqbuf.type = inqbuf.device;\n\tsa.sa_inqbuf.removable = inqbuf.dev_qual2 & SID_REMOVABLE ?\n\t    T_REMOV : T_FIXED;\n\tif (sa.sa_inqbuf.removable)\n\t\tsc_link->flags |= SDEV_REMOVABLE;\n\t/* XXX how? sc_link->scsipi_atapi.cap |= ACAP_LEN;*/\n\tsa.sa_inqbuf.vendor = vendor;\n\tsa.sa_inqbuf.product = product;\n\tsa.sa_inqbuf.revision = revision;\n\tsa.sa_inqptr = NULL;\n\n\tdrvp->drv_softc = atapi_probedev(atapi, target, sc_link, &sa);\n\t/* atapi_probedev() frees the scsipi_link when there is no device. */\n\treturn;\n\nbad:\n\tfree(sc_link, M_DEVBUF);\n\treturn;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "scsipi_strvis",
          "args": [
            "revision",
            "17",
            "inqbuf.revision",
            "4"
          ],
          "line": 3453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scsipi_strvis",
          "args": [
            "product",
            "65",
            "inqbuf.product",
            "16"
          ],
          "line": 3452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scsipi_strvis",
          "args": [
            "vendor",
            "33",
            "inqbuf.vendor",
            "8"
          ],
          "line": 3451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scsipi_inquire",
          "args": [
            "sc_link",
            "&inqbuf",
            "XS_CTL_DISCOVERY"
          ],
          "line": 3448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&inqbuf",
            "0",
            "sizeof(inqbuf)"
          ],
          "line": 3447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"umass_atapi_probedev: doing inquiry\\n\")"
          ],
          "line": 3445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc_link->pending_xfers"
          ],
          "line": 3443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIF",
          "args": [
            "UDMASS_UPPER",
            "sc_link->flags |= DEBUGLEVEL"
          ],
          "line": 3437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: can't allocate link for drive %d\\n\"",
            "atapi->sc_dev.dv_xname",
            "target"
          ],
          "line": 3431
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*sc_link)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 3429
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"umass_atapi_probedev: atapi=%p target=%d\\n\",\n\t\t\t     atapi, target)"
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_SCSI\t0x00020000\t/* scsi */\n#define UDMASS_UPPER\t0x00008000\t/* upper layer */\n\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nstruct scsipi_link *sc_link = xs->sc_link;\nint s;\n\nStatic void\numass_atapi_probedev(atapi, target)\n\tstruct atapibus_softc *atapi;\n\tint target;\n{\n\tstruct scsipi_link *sc_link;\n\tstruct scsipibus_attach_args sa;\n\tstruct ata_drive_datas *drvp = &atapi->sc_drvs[target];\n\tchar vendor[33], product[65], revision[17];\n\tstruct scsipi_inquiry_data inqbuf;\n\n\tDPRINTF(UDMASS_SCSI,(\"umass_atapi_probedev: atapi=%p target=%d\\n\",\n\t\t\t     atapi, target));\n\n\tif (atapi->sc_link[target])\n\t\treturn;\n\n\tsc_link = malloc(sizeof(*sc_link), M_DEVBUF, M_NOWAIT); \n\tif (sc_link == NULL) {\n\t\tprintf(\"%s: can't allocate link for drive %d\\n\",\n\t\t       atapi->sc_dev.dv_xname, target);\n\t\treturn;       \n\t}\n\t*sc_link = *atapi->adapter_link;\n\n\tDIF(UDMASS_UPPER, sc_link->flags |= DEBUGLEVEL);\n\n\t/* Fill generic parts of the link. */\n\tsc_link->active = 0;\n\tsc_link->scsipi_atapi.drive = target;\n\tsc_link->device = &umass_dev;\n\tTAILQ_INIT(&sc_link->pending_xfers);\n\n\tDPRINTF(UDMASS_SCSI, (\"umass_atapi_probedev: doing inquiry\\n\"));\n\t/* Now go ask the device all about itself. */\n\tmemset(&inqbuf, 0, sizeof(inqbuf));\n\tif (scsipi_inquire(sc_link, &inqbuf, XS_CTL_DISCOVERY) != 0)\n\t\tgoto bad;\n\n\tscsipi_strvis(vendor, 33, inqbuf.vendor, 8);\n\tscsipi_strvis(product, 65, inqbuf.product, 16);\n\tscsipi_strvis(revision, 17, inqbuf.revision, 4);\n\n\tsa.sa_sc_link = sc_link;\n\tsa.sa_inqbuf.type = inqbuf.device;\n\tsa.sa_inqbuf.removable = inqbuf.dev_qual2 & SID_REMOVABLE ?\n\t    T_REMOV : T_FIXED;\n\tif (sa.sa_inqbuf.removable)\n\t\tsc_link->flags |= SDEV_REMOVABLE;\n\t/* XXX how? sc_link->scsipi_atapi.cap |= ACAP_LEN;*/\n\tsa.sa_inqbuf.vendor = vendor;\n\tsa.sa_inqbuf.product = product;\n\tsa.sa_inqbuf.revision = revision;\n\tsa.sa_inqptr = NULL;\n\n\tdrvp->drv_softc = atapi_probedev(atapi, target, sc_link, &sa);\n\t/* atapi_probedev() frees the scsipi_link when there is no device. */\n\treturn;\n\nbad:\n\tfree(sc_link, M_DEVBUF);\n\treturn;\n}"
  },
  {
    "function_name": "umass_scsipi_sense_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "3345-3409",
    "snippet": "Static void\numass_scsipi_sense_cb(struct umass_softc *sc, void *priv, int residue,\n\t\t      int status)\n{\n\tstruct scsipi_xfer *xs = priv;\n\tint s;\n\tint bytes_received;\n\n\tDPRINTF(UDMASS_CMD,(\"umass_scsipi_sense_cb: xs=%p residue=%d \"\n\t    \"status=%d\\n\", xs, residue, status));\n\n\tswitch (status) {\n\tcase STATUS_CMD_OK:\n\tcase STATUS_CMD_UNKNOWN:\n\t\t/* getting sense data succeeded */\n\t\tif ((xs->cmd->opcode == INQUIRY)\n\t\t    && (xs->resid < xs->datalen)) {\n\t\t\t/* Some drivers return SENSE errors even after INQUIRY\n\t\t\t * The upper layer doesn't like that.\n\t\t\t */\n\t\t\txs->error = XS_NOERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tbytes_received = sizeof(xs->sense) - residue;\n\n\t\tif (bytes_received < 8 || \n\t\t    (bytes_received < xs->sense.extra_len + 8)) \n\t\t\txs->error = XS_SHORTSENSE;\n\t        else\n\t\t\txs->error = XS_SENSE;\n\n#if defined(__OpenBSD__)\n\t\t/* Note that this test may need to be revised\n\t\t   with QIC-157a/SCSI tape drives that return\n\t\t   ILI, EOM in the high bits of flags.\n\t         */\n\t\tif ((xs->sense.error_code & SSD_ERRCODE) == 0x70 &&\n\t\t    (xs->sense.flags == 0))\n\t\t\txs->error = XS_NOERROR;\n#endif\n\t\t\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF(UDMASS_SCSI, (\"%s: Autosense failed, status %d\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), status));\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tbreak;\n\t}\n\n#if defined(__NetBSD__)\n\txs->xs_status |= XS_STS_DONE;\n#endif\n#if defined(__OpenBSD__)\n\txs->flags |= ITSDONE;\n#endif\n\n\tDPRINTF(UDMASS_CMD,(\"umass_scsipi_sense_cb: return xs->error=%d, \"\n\t\t\"xs->xs_status=0x%x xs->resid=%d\\n\", xs->error, xs->xs_status,\n\t\txs->resid));\n\n\ts = splbio();\n\tscsipi_done(xs);\n\tsplx(s);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define STATUS_CMD_UNKNOWN\t1\t/* will have to fetch sense */",
      "#define STATUS_CMD_OK\t\t0\t/* everything ok */",
      "#define UDMASS_CMD\t0x80000000",
      "#define UDMASS_SCSI\t0x00020000\t/* scsi */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "umass_bbb_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "umass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
      "Static void",
      "Static int",
      "Static void",
      "umass_cbi_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "umass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
      "Static void",
      "struct scsipi_xfer *xs = priv;",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 3408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scsipi_done",
          "args": [
            "xs"
          ],
          "line": 3407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 3406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_CMD",
            "(\"umass_scsipi_sense_cb: return xs->error=%d, \"\n\t\t\"xs->xs_status=0x%x xs->resid=%d\\n\", xs->error, xs->xs_status,\n\t\txs->resid)"
          ],
          "line": 3402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s: Autosense failed, status %d\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), status)"
          ],
          "line": 3389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_CMD",
            "(\"umass_scsipi_sense_cb: xs=%p residue=%d \"\n\t    \"status=%d\\n\", xs, residue, status)"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define STATUS_CMD_UNKNOWN\t1\t/* will have to fetch sense */\n#define STATUS_CMD_OK\t\t0\t/* everything ok */\n#define UDMASS_CMD\t0x80000000\n#define UDMASS_SCSI\t0x00020000\t/* scsi */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\numass_bbb_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\numass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\nStatic int;\nStatic void;\numass_cbi_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\numass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\nstruct scsipi_xfer *xs = priv;\nint s;\n\nStatic void\numass_scsipi_sense_cb(struct umass_softc *sc, void *priv, int residue,\n\t\t      int status)\n{\n\tstruct scsipi_xfer *xs = priv;\n\tint s;\n\tint bytes_received;\n\n\tDPRINTF(UDMASS_CMD,(\"umass_scsipi_sense_cb: xs=%p residue=%d \"\n\t    \"status=%d\\n\", xs, residue, status));\n\n\tswitch (status) {\n\tcase STATUS_CMD_OK:\n\tcase STATUS_CMD_UNKNOWN:\n\t\t/* getting sense data succeeded */\n\t\tif ((xs->cmd->opcode == INQUIRY)\n\t\t    && (xs->resid < xs->datalen)) {\n\t\t\t/* Some drivers return SENSE errors even after INQUIRY\n\t\t\t * The upper layer doesn't like that.\n\t\t\t */\n\t\t\txs->error = XS_NOERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tbytes_received = sizeof(xs->sense) - residue;\n\n\t\tif (bytes_received < 8 || \n\t\t    (bytes_received < xs->sense.extra_len + 8)) \n\t\t\txs->error = XS_SHORTSENSE;\n\t        else\n\t\t\txs->error = XS_SENSE;\n\n#if defined(__OpenBSD__)\n\t\t/* Note that this test may need to be revised\n\t\t   with QIC-157a/SCSI tape drives that return\n\t\t   ILI, EOM in the high bits of flags.\n\t         */\n\t\tif ((xs->sense.error_code & SSD_ERRCODE) == 0x70 &&\n\t\t    (xs->sense.flags == 0))\n\t\t\txs->error = XS_NOERROR;\n#endif\n\t\t\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF(UDMASS_SCSI, (\"%s: Autosense failed, status %d\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), status));\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tbreak;\n\t}\n\n#if defined(__NetBSD__)\n\txs->xs_status |= XS_STS_DONE;\n#endif\n#if defined(__OpenBSD__)\n\txs->flags |= ITSDONE;\n#endif\n\n\tDPRINTF(UDMASS_CMD,(\"umass_scsipi_sense_cb: return xs->error=%d, \"\n\t\t\"xs->xs_status=0x%x xs->resid=%d\\n\", xs->error, xs->xs_status,\n\t\txs->resid));\n\n\ts = splbio();\n\tscsipi_done(xs);\n\tsplx(s);\n}"
  },
  {
    "function_name": "umass_scsipi_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "3249-3269",
    "snippet": "int\numass_scsipi_ioctl(link, cmd, arg, flag, p)\n\tstruct scsipi_link *link;\n\tu_long cmd;\n\tcaddr_t arg;\n\tint flag;\n\tstruct proc *p;\n{\n\t/*struct umass_softc *sc = link->adapter_softc;*/\n\n\tswitch (cmd) {\n#if 0\n\tcase SCBUSIORESET:\n\t\tccb->ccb_h.status = CAM_REQ_INPROG;\n\t\tumass_reset(sc, umass_cam_cb, (void *) ccb);\n\t\treturn (0);\n#endif\n\tdefault:\n\t\treturn (ENOTTY);\n\t}\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "umass_bbb_reset\t__P((struct umass_softc *sc, int status));",
      "umass_cbi_reset\t__P((struct umass_softc *sc, int status));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "umass_reset",
          "args": [
            "sc",
            "umass_cam_cb",
            "(void *) ccb"
          ],
          "line": 3263
        },
        "resolved": true,
        "details": {
          "function_name": "umass_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "1365-1373",
          "snippet": "Static void\numass_reset(struct umass_softc *sc, transfer_cb_f cb, void *priv)\n{\n\tsc->transfer_cb = cb;\n\tsc->transfer_priv = priv;\n\n\t/* The reset is a forced reset, so no error (yet) */\n\tsc->reset(sc, STATUS_CMD_OK);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define STATUS_CMD_OK\t\t0\t/* everything ok */"
          ],
          "globals_used": [
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "Static void",
            "Static void",
            "Static void",
            "umass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "umass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
            "Static void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define STATUS_CMD_OK\t\t0\t/* everything ok */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\numass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\numass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\n\nStatic void\numass_reset(struct umass_softc *sc, transfer_cb_f cb, void *priv)\n{\n\tsc->transfer_cb = cb;\n\tsc->transfer_priv = priv;\n\n\t/* The reset is a forced reset, so no error (yet) */\n\tsc->reset(sc, STATUS_CMD_OK);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\numass_disco\t\t__P((struct umass_softc *sc));\numass_init_shuttle\t__P((struct umass_softc *sc));\numass_bbb_reset\t__P((struct umass_softc *sc, int status));\numass_cbi_reset\t__P((struct umass_softc *sc, int status));\n\nint\numass_scsipi_ioctl(link, cmd, arg, flag, p)\n\tstruct scsipi_link *link;\n\tu_long cmd;\n\tcaddr_t arg;\n\tint flag;\n\tstruct proc *p;\n{\n\t/*struct umass_softc *sc = link->adapter_softc;*/\n\n\tswitch (cmd) {\n#if 0\n\tcase SCBUSIORESET:\n\t\tccb->ccb_h.status = CAM_REQ_INPROG;\n\t\tumass_reset(sc, umass_cam_cb, (void *) ccb);\n\t\treturn (0);\n#endif\n\tdefault:\n\t\treturn (ENOTTY);\n\t}\n}"
  },
  {
    "function_name": "umass_scsipi_minphys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "3240-3247",
    "snippet": "Static void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE",
      "#define UMASS_MAX_TRANSFER_SIZE\t\t65536"
    ],
    "globals_used": [
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "minphys",
          "args": [
            "bp"
          ],
          "line": 3246
        },
        "resolved": true,
        "details": {
          "function_name": "umass_scsipi_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "3240-3247",
          "snippet": "Static void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE\n#define UMASS_MAX_TRANSFER_SIZE\t\t65536\n\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\n\nStatic void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}"
  },
  {
    "function_name": "umass_scsipi_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "3078-3238",
    "snippet": "Static int\numass_scsipi_cmd(xs)\n\tstruct scsipi_xfer *xs;\n{\n\tstruct scsipi_link *sc_link = xs->sc_link;\n\tstruct umass_softc *sc = sc_link->adapter_softc;\n\tint cmdlen;\n\tint dir;\n\n#if defined(__NetBSD__)\n\tDIF(UDMASS_UPPER, sc_link->flags |= DEBUGLEVEL);\n#endif\n#if defined(__OpenBSD__)\n\tDIF(UDMASS_UPPER, sc_link->flags |= SCSIDEBUG_LEVEL);\n#endif\n\n#if defined(__NetBSD__)\n\tDPRINTF(UDMASS_CMD, (\"%s: umass_scsi_cmd:  %d:%d xs=%p cmd=0x%02x \"\n\t    \"(quirks=0x%x, poll=%d)\\n\", USBDEVNAME(sc->sc_dev),\n\t    sc_link->scsipi_scsi.target, sc_link->scsipi_scsi.lun,\n\t    xs, xs->cmd->opcode, sc_link->quirks, \n\t    xs->xs_control & XS_CTL_POLL));\n#endif\n#if defined(__OpenBSD__)\n\tDPRINTF(UDMASS_CMD, (\"%s: umass_scsi_cmd:  %d:%d xs=%p cmd=0x%02x \"\n\t    \"(quirks=0x%x, poll=%d)\\n\", USBDEVNAME(sc->sc_dev),\n\t    sc_link->target, sc_link->lun,\n\t    xs, xs->cmd->opcode, sc_link->quirks, \n\t    xs->xs_control & XS_CTL_POLL));\n#endif\n\n#if defined(USB_DEBUG) && defined(SCSIDEBUG)\n\tif (umassdebug & UDMASS_SCSI)\n\t\tshow_scsipi_xs(xs);\n\telse if (umassdebug & ~UDMASS_CMD)\n\t\tshow_scsipi_cmd(xs);\n#endif\n\n\tif (sc->sc_dying) {\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tgoto done;\n\t}\n\n#ifdef UMASS_DEBUG\n#if defined(__NetBSD__)\n\tif ((sc_link->type == BUS_ATAPI ? \n\t     sc_link->scsipi_atapi.drive : sc_link->scsipi_scsi.target) \n\t    != UMASS_SCSIID_DEVICE) {\n\t\tDPRINTF(UDMASS_SCSI, (\"%s: wrong SCSI ID %d\\n\",\n\t\t    USBDEVNAME(sc->sc_dev),\n\t\t    sc_link->scsipi_scsi.target));\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tgoto done;\n\t}\n#endif\n#if defined(__OpenBSD__)\n\tif (sc_link->target != UMASS_SCSIID_DEVICE) {\n\t\tDPRINTF(UDMASS_SCSI, (\"%s: wrong SCSI ID %d\\n\",\n\t\t    USBDEVNAME(sc->sc_dev),\n\t\t    sc_link->target));\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tgoto done;\n\t}\n#endif\n#endif\n\n\n\n\tif (xs->cmd->opcode == SCSI_MODE_SENSE &&\n\t    (sc_link->quirks & SDEV_NOMODESENSE)) {\n\t\t/*printf(\"%s: SCSI_MODE_SENSE\\n\", USBDEVNAME(sc->sc_dev));*/\n\t\txs->error = XS_TIMEOUT;\n\t\tgoto done;\n\t}\n\n\tif (xs->cmd->opcode == START_STOP &&\n\t    (sc->quirks & NO_START_STOP)) {\n\t\t/*printf(\"%s: START_STOP\\n\", USBDEVNAME(sc->sc_dev));*/\n\t\txs->error = XS_NOERROR;\n\t\tgoto done;\n\t}\n\n\tdir = DIR_NONE;\n\tif (xs->datalen) {\n\t\tswitch (xs->xs_control & (XS_CTL_DATA_IN | XS_CTL_DATA_OUT)) {\n\t\tcase XS_CTL_DATA_IN:\n\t\t\tdir = DIR_IN;\n\t\t\tbreak;\n\t\tcase XS_CTL_DATA_OUT:\n\t\t\tdir = DIR_OUT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (xs->datalen > UMASS_MAX_TRANSFER_SIZE) {\n\t\tprintf(\"umass_cmd: large datalen, %d\\n\", xs->datalen);\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tgoto done;\n\t}\n\n\tcmdlen = xs->cmdlen;\n\t/* All UFI commands are 12 bytes.  We'll get a few garbage bytes by extending... */\n\tif (sc->proto & PROTO_UFI)\n\t\tcmdlen = UFI_PROTO_LEN;\n\n\tif (xs->xs_control & XS_CTL_POLL) {\n\t\t/* Use sync transfer. XXX Broken! */\n\t\tDPRINTF(UDMASS_SCSI, (\"umass_scsi_cmd: sync dir=%d\\n\", dir));\n\t\tsc->sc_xfer_flags = USBD_SYNCHRONOUS;\n\t\tsc->sc_sync_status = USBD_INVAL;\n#if defined(__NetBSD__)\n\t\tsc->transfer(sc, sc_link->scsipi_scsi.lun, xs->cmd, cmdlen,\n#endif\n#if defined(__OpenBSD__)\n\t\tsc->transfer(sc, sc_link->lun, xs->cmd, cmdlen,\n#endif\n\t\t\t     xs->data, xs->datalen, dir, 0, xs);\n\t\tsc->sc_xfer_flags = 0;\n\t\tDPRINTF(UDMASS_SCSI, (\"umass_scsi_cmd: done err=%d\\n\", \n\t\t\t\t      sc->sc_sync_status));\n\t\tswitch (sc->sc_sync_status) {\n\t\tcase USBD_NORMAL_COMPLETION:\n\t\t\txs->error = XS_NOERROR;\n\t\t\tbreak;\n\t\tcase USBD_TIMEOUT:\n\t\t\txs->error = XS_TIMEOUT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tbreak;\n\t\t}\n\t\tgoto done;\n\t} else {\n\t\tDPRINTF(UDMASS_SCSI, (\"umass_scsi_cmd: async dir=%d, cmdlen=%d\"\n\t\t\t\t      \" datalen=%d\\n\",\n\t\t\t\t      dir, cmdlen, xs->datalen));\n#if defined(__NetBSD__)\n\t\tsc->transfer(sc, sc_link->scsipi_scsi.lun, xs->cmd, cmdlen,\n#endif\n#if defined(__OpenBSD__)\n\t\tsc->transfer(sc, sc_link->lun, xs->cmd, cmdlen,\n#endif\n\t\t    xs->data, xs->datalen, dir, umass_scsipi_cb, xs);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\n\t/* Return if command finishes early. */\n done:\n#if defined(__NetBSD__)\n\txs->xs_status |= XS_STS_DONE;\n#endif\n#if defined(__OpenBSD__)\n\txs->flags |= ITSDONE;\n#endif\n\t\n\tscsipi_done(xs);\n\tif (xs->xs_control & XS_CTL_POLL)\n\t\treturn (COMPLETE);\n\telse\n\t\treturn (SUCCESSFULLY_QUEUED);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE",
      "#define UMASS_SCSIID_DEVICE\t0x01",
      "#define UMASS_MAX_TRANSFER_SIZE\t\t65536",
      "#define DIR_OUT\t\t2",
      "#define DIR_IN\t\t1",
      "#define DIR_NONE\t0",
      "#define UFI_PROTO_LEN 12",
      "#define UDMASS_CMD\t0x80000000",
      "#define UDMASS_SCSI\t0x00020000\t/* scsi */",
      "#define UDMASS_UPPER\t0x00008000\t/* upper layer */"
    ],
    "globals_used": [
      "__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "umass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "umass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
      "struct scsipi_xfer *xs = priv;",
      "struct scsipi_link *sc_link = xs->sc_link;",
      "int cmdlen;",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scsipi_done",
          "args": [
            "xs"
          ],
          "line": 3233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->transfer",
          "args": [
            "sc",
            "sc_link->lun",
            "xs->cmd",
            "cmdlen",
            "#endifxs->data",
            "xs->datalen",
            "dir",
            "umass_scsipi_cb",
            "xs"
          ],
          "line": 3215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->transfer",
          "args": [
            "sc",
            "sc_link->scsipi_scsi.lun",
            "xs->cmd",
            "cmdlen",
            "#endif\n#if defined(__OpenBSD__"
          ],
          "line": 3215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"umass_scsi_cmd: async dir=%d, cmdlen=%d\"\n\t\t\t\t      \" datalen=%d\\n\",\n\t\t\t\t      dir, cmdlen, xs->datalen)"
          ],
          "line": 3211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"umass_scsi_cmd: done err=%d\\n\", \n\t\t\t\t      sc->sc_sync_status)"
          ],
          "line": 3196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->transfer",
          "args": [
            "sc",
            "sc_link->lun",
            "xs->cmd",
            "cmdlen",
            "#endifxs->data",
            "xs->datalen",
            "dir",
            "0",
            "xs"
          ],
          "line": 3189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->transfer",
          "args": [
            "sc",
            "sc_link->scsipi_scsi.lun",
            "xs->cmd",
            "cmdlen",
            "#endif\n#if defined(__OpenBSD__"
          ],
          "line": 3189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"umass_scsi_cmd: sync dir=%d\\n\", dir)"
          ],
          "line": 3185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"umass_cmd: large datalen, %d\\n\"",
            "xs->datalen"
          ],
          "line": 3173
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s: wrong SCSI ID %d\\n\",\n\t\t    USBDEVNAME(sc->sc_dev),\n\t\t    sc_link->target)"
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 3136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s: wrong SCSI ID %d\\n\",\n\t\t    USBDEVNAME(sc->sc_dev),\n\t\t    sc_link->scsipi_scsi.target)"
          ],
          "line": 3126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 3127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_scsipi_cmd",
          "args": [
            "xs"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_scsipi_xs",
          "args": [
            "xs"
          ],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_CMD",
            "(\"%s: umass_scsi_cmd:  %d:%d xs=%p cmd=0x%02x \"\n\t    \"(quirks=0x%x, poll=%d)\\n\", USBDEVNAME(sc->sc_dev),\n\t    sc_link->target, sc_link->lun,\n\t    xs, xs->cmd->opcode, sc_link->quirks, \n\t    xs->xs_control & XS_CTL_POLL)"
          ],
          "line": 3102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 3103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_CMD",
            "(\"%s: umass_scsi_cmd:  %d:%d xs=%p cmd=0x%02x \"\n\t    \"(quirks=0x%x, poll=%d)\\n\", USBDEVNAME(sc->sc_dev),\n\t    sc_link->scsipi_scsi.target, sc_link->scsipi_scsi.lun,\n\t    xs, xs->cmd->opcode, sc_link->quirks, \n\t    xs->xs_control & XS_CTL_POLL)"
          ],
          "line": 3095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 3096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIF",
          "args": [
            "UDMASS_UPPER",
            "sc_link->flags |= SCSIDEBUG_LEVEL"
          ],
          "line": 3091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIF",
          "args": [
            "UDMASS_UPPER",
            "sc_link->flags |= DEBUGLEVEL"
          ],
          "line": 3088
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE\n#define UMASS_SCSIID_DEVICE\t0x01\n#define UMASS_MAX_TRANSFER_SIZE\t\t65536\n#define DIR_OUT\t\t2\n#define DIR_IN\t\t1\n#define DIR_NONE\t0\n#define UFI_PROTO_LEN 12\n#define UDMASS_CMD\t0x80000000\n#define UDMASS_SCSI\t0x00020000\t/* scsi */\n#define UDMASS_UPPER\t0x00008000\t/* upper layer */\n\n__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\numass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));\nStatic int;\nStatic void;\nStatic void;\nStatic void;\numass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nstruct scsipi_xfer *xs = priv;\nstruct scsipi_link *sc_link = xs->sc_link;\nint cmdlen;\nint s;\n\nStatic int\numass_scsipi_cmd(xs)\n\tstruct scsipi_xfer *xs;\n{\n\tstruct scsipi_link *sc_link = xs->sc_link;\n\tstruct umass_softc *sc = sc_link->adapter_softc;\n\tint cmdlen;\n\tint dir;\n\n#if defined(__NetBSD__)\n\tDIF(UDMASS_UPPER, sc_link->flags |= DEBUGLEVEL);\n#endif\n#if defined(__OpenBSD__)\n\tDIF(UDMASS_UPPER, sc_link->flags |= SCSIDEBUG_LEVEL);\n#endif\n\n#if defined(__NetBSD__)\n\tDPRINTF(UDMASS_CMD, (\"%s: umass_scsi_cmd:  %d:%d xs=%p cmd=0x%02x \"\n\t    \"(quirks=0x%x, poll=%d)\\n\", USBDEVNAME(sc->sc_dev),\n\t    sc_link->scsipi_scsi.target, sc_link->scsipi_scsi.lun,\n\t    xs, xs->cmd->opcode, sc_link->quirks, \n\t    xs->xs_control & XS_CTL_POLL));\n#endif\n#if defined(__OpenBSD__)\n\tDPRINTF(UDMASS_CMD, (\"%s: umass_scsi_cmd:  %d:%d xs=%p cmd=0x%02x \"\n\t    \"(quirks=0x%x, poll=%d)\\n\", USBDEVNAME(sc->sc_dev),\n\t    sc_link->target, sc_link->lun,\n\t    xs, xs->cmd->opcode, sc_link->quirks, \n\t    xs->xs_control & XS_CTL_POLL));\n#endif\n\n#if defined(USB_DEBUG) && defined(SCSIDEBUG)\n\tif (umassdebug & UDMASS_SCSI)\n\t\tshow_scsipi_xs(xs);\n\telse if (umassdebug & ~UDMASS_CMD)\n\t\tshow_scsipi_cmd(xs);\n#endif\n\n\tif (sc->sc_dying) {\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tgoto done;\n\t}\n\n#ifdef UMASS_DEBUG\n#if defined(__NetBSD__)\n\tif ((sc_link->type == BUS_ATAPI ? \n\t     sc_link->scsipi_atapi.drive : sc_link->scsipi_scsi.target) \n\t    != UMASS_SCSIID_DEVICE) {\n\t\tDPRINTF(UDMASS_SCSI, (\"%s: wrong SCSI ID %d\\n\",\n\t\t    USBDEVNAME(sc->sc_dev),\n\t\t    sc_link->scsipi_scsi.target));\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tgoto done;\n\t}\n#endif\n#if defined(__OpenBSD__)\n\tif (sc_link->target != UMASS_SCSIID_DEVICE) {\n\t\tDPRINTF(UDMASS_SCSI, (\"%s: wrong SCSI ID %d\\n\",\n\t\t    USBDEVNAME(sc->sc_dev),\n\t\t    sc_link->target));\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tgoto done;\n\t}\n#endif\n#endif\n\n\n\n\tif (xs->cmd->opcode == SCSI_MODE_SENSE &&\n\t    (sc_link->quirks & SDEV_NOMODESENSE)) {\n\t\t/*printf(\"%s: SCSI_MODE_SENSE\\n\", USBDEVNAME(sc->sc_dev));*/\n\t\txs->error = XS_TIMEOUT;\n\t\tgoto done;\n\t}\n\n\tif (xs->cmd->opcode == START_STOP &&\n\t    (sc->quirks & NO_START_STOP)) {\n\t\t/*printf(\"%s: START_STOP\\n\", USBDEVNAME(sc->sc_dev));*/\n\t\txs->error = XS_NOERROR;\n\t\tgoto done;\n\t}\n\n\tdir = DIR_NONE;\n\tif (xs->datalen) {\n\t\tswitch (xs->xs_control & (XS_CTL_DATA_IN | XS_CTL_DATA_OUT)) {\n\t\tcase XS_CTL_DATA_IN:\n\t\t\tdir = DIR_IN;\n\t\t\tbreak;\n\t\tcase XS_CTL_DATA_OUT:\n\t\t\tdir = DIR_OUT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (xs->datalen > UMASS_MAX_TRANSFER_SIZE) {\n\t\tprintf(\"umass_cmd: large datalen, %d\\n\", xs->datalen);\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tgoto done;\n\t}\n\n\tcmdlen = xs->cmdlen;\n\t/* All UFI commands are 12 bytes.  We'll get a few garbage bytes by extending... */\n\tif (sc->proto & PROTO_UFI)\n\t\tcmdlen = UFI_PROTO_LEN;\n\n\tif (xs->xs_control & XS_CTL_POLL) {\n\t\t/* Use sync transfer. XXX Broken! */\n\t\tDPRINTF(UDMASS_SCSI, (\"umass_scsi_cmd: sync dir=%d\\n\", dir));\n\t\tsc->sc_xfer_flags = USBD_SYNCHRONOUS;\n\t\tsc->sc_sync_status = USBD_INVAL;\n#if defined(__NetBSD__)\n\t\tsc->transfer(sc, sc_link->scsipi_scsi.lun, xs->cmd, cmdlen,\n#endif\n#if defined(__OpenBSD__)\n\t\tsc->transfer(sc, sc_link->lun, xs->cmd, cmdlen,\n#endif\n\t\t\t     xs->data, xs->datalen, dir, 0, xs);\n\t\tsc->sc_xfer_flags = 0;\n\t\tDPRINTF(UDMASS_SCSI, (\"umass_scsi_cmd: done err=%d\\n\", \n\t\t\t\t      sc->sc_sync_status));\n\t\tswitch (sc->sc_sync_status) {\n\t\tcase USBD_NORMAL_COMPLETION:\n\t\t\txs->error = XS_NOERROR;\n\t\t\tbreak;\n\t\tcase USBD_TIMEOUT:\n\t\t\txs->error = XS_TIMEOUT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tbreak;\n\t\t}\n\t\tgoto done;\n\t} else {\n\t\tDPRINTF(UDMASS_SCSI, (\"umass_scsi_cmd: async dir=%d, cmdlen=%d\"\n\t\t\t\t      \" datalen=%d\\n\",\n\t\t\t\t      dir, cmdlen, xs->datalen));\n#if defined(__NetBSD__)\n\t\tsc->transfer(sc, sc_link->scsipi_scsi.lun, xs->cmd, cmdlen,\n#endif\n#if defined(__OpenBSD__)\n\t\tsc->transfer(sc, sc_link->lun, xs->cmd, cmdlen,\n#endif\n\t\t    xs->data, xs->datalen, dir, umass_scsipi_cb, xs);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\n\t/* Return if command finishes early. */\n done:\n#if defined(__NetBSD__)\n\txs->xs_status |= XS_STS_DONE;\n#endif\n#if defined(__OpenBSD__)\n\txs->flags |= ITSDONE;\n#endif\n\t\n\tscsipi_done(xs);\n\tif (xs->xs_control & XS_CTL_POLL)\n\t\treturn (COMPLETE);\n\telse\n\t\treturn (SUCCESSFULLY_QUEUED);\n}"
  },
  {
    "function_name": "umass_dump_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "3041-3067",
    "snippet": "Static void\numass_dump_buffer(struct umass_softc *sc, u_int8_t *buffer, int buflen,\n\t\t  int printlen)\n{\n\tint i, j;\n\tchar s1[40];\n\tchar s2[40];\n\tchar s3[5];\n\n\ts1[0] = '\\0';\n\ts3[0] = '\\0';\n\n\tsprintf(s2, \" buffer=%p, buflen=%d\", buffer, buflen);\n\tfor (i = 0; i < buflen && i < printlen; i++) {\n\t\tj = i % 16;\n\t\tif (j == 0 && i != 0) {\n\t\t\tDPRINTF(UDMASS_GEN, (\"%s: 0x %s%s\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev), s1, s2));\n\t\t\ts2[0] = '\\0';\n\t\t}\n\t\tsprintf(&s1[j*2], \"%02x\", buffer[i] & 0xff);\n\t}\n\tif (buflen > printlen)\n\t\tsprintf(s3, \" ...\");\n\tDPRINTF(UDMASS_GEN, (\"%s: 0x %s%s%s\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), s1, s2, s3));\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UDMASS_GEN\t0x00010000\t/* general */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_GEN",
            "(\"%s: 0x %s%s%s\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), s1, s2, s3)"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s3",
            "\" ...\""
          ],
          "line": 3064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "&s1[j*2]",
            "\"%02x\"",
            "buffer[i] & 0xff"
          ],
          "line": 3061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_GEN",
            "(\"%s: 0x %s%s\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev), s1, s2)"
          ],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 3058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s2",
            "\" buffer=%p, buflen=%d\"",
            "buffer",
            "buflen"
          ],
          "line": 3053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_GEN\t0x00010000\t/* general */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nint s;\n\nStatic void\numass_dump_buffer(struct umass_softc *sc, u_int8_t *buffer, int buflen,\n\t\t  int printlen)\n{\n\tint i, j;\n\tchar s1[40];\n\tchar s2[40];\n\tchar s3[5];\n\n\ts1[0] = '\\0';\n\ts3[0] = '\\0';\n\n\tsprintf(s2, \" buffer=%p, buflen=%d\", buffer, buflen);\n\tfor (i = 0; i < buflen && i < printlen; i++) {\n\t\tj = i % 16;\n\t\tif (j == 0 && i != 0) {\n\t\t\tDPRINTF(UDMASS_GEN, (\"%s: 0x %s%s\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev), s1, s2));\n\t\t\ts2[0] = '\\0';\n\t\t}\n\t\tsprintf(&s1[j*2], \"%02x\", buffer[i] & 0xff);\n\t}\n\tif (buflen > printlen)\n\t\tsprintf(s3, \" ...\");\n\tDPRINTF(UDMASS_GEN, (\"%s: 0x %s%s%s\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), s1, s2, s3));\n}"
  },
  {
    "function_name": "umass_bbb_dump_csw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "3024-3039",
    "snippet": "Static void\numass_bbb_dump_csw(struct umass_softc *sc, umass_bbb_csw_t *csw)\n{\n\tint sig = UGETDW(csw->dCSWSignature);\n\tint tag = UGETW(csw->dCSWTag);\n\tint res = UGETDW(csw->dCSWDataResidue);\n\tint status = csw->bCSWStatus;\n\n\tDPRINTF(UDMASS_BBB, (\"%s: CSW %d: sig = 0x%08x (%s), tag = %d, \"\n\t\t\"res = %d, status = 0x%02x (%s)\\n\", USBDEVNAME(sc->sc_dev),\n\t\ttag, sig, (sig == CSWSIGNATURE?\t \"valid\":\"invalid\"),\n\t\ttag, res,\n\t\tstatus, (status == CSWSTATUS_GOOD? \"good\":\n\t\t\t (status == CSWSTATUS_FAILED? \"failed\":\n\t\t\t  (status == CSWSTATUS_PHASE? \"phase\":\"<invalid>\")))));\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "umass_bbb_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "umass_cbi_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "Static void",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_BBB",
            "(\"%s: CSW %d: sig = 0x%08x (%s), tag = %d, \"\n\t\t\"res = %d, status = 0x%02x (%s)\\n\", USBDEVNAME(sc->sc_dev),\n\t\ttag, sig, (sig == CSWSIGNATURE?\t \"valid\":\"invalid\"),\n\t\ttag, res,\n\t\tstatus, (status == CSWSTATUS_GOOD? \"good\":\n\t\t\t (status == CSWSTATUS_FAILED? \"failed\":\n\t\t\t  (status == CSWSTATUS_PHASE? \"phase\":\"<invalid>\"))))"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETDW",
          "args": [
            "csw->dCSWDataResidue"
          ],
          "line": 3029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "csw->dCSWTag"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETDW",
          "args": [
            "csw->dCSWSignature"
          ],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\numass_bbb_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\numass_cbi_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nint s;\n\nStatic void\numass_bbb_dump_csw(struct umass_softc *sc, umass_bbb_csw_t *csw)\n{\n\tint sig = UGETDW(csw->dCSWSignature);\n\tint tag = UGETW(csw->dCSWTag);\n\tint res = UGETDW(csw->dCSWDataResidue);\n\tint status = csw->bCSWStatus;\n\n\tDPRINTF(UDMASS_BBB, (\"%s: CSW %d: sig = 0x%08x (%s), tag = %d, \"\n\t\t\"res = %d, status = 0x%02x (%s)\\n\", USBDEVNAME(sc->sc_dev),\n\t\ttag, sig, (sig == CSWSIGNATURE?\t \"valid\":\"invalid\"),\n\t\ttag, res,\n\t\tstatus, (status == CSWSTATUS_GOOD? \"good\":\n\t\t\t (status == CSWSTATUS_FAILED? \"failed\":\n\t\t\t  (status == CSWSTATUS_PHASE? \"phase\":\"<invalid>\")))));\n}"
  },
  {
    "function_name": "umass_bbb_dump_cbw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "3006-3022",
    "snippet": "Static void\numass_bbb_dump_cbw(struct umass_softc *sc, umass_bbb_cbw_t *cbw)\n{\n\tint clen = cbw->bCDBLength;\n\tint dlen = UGETDW(cbw->dCBWDataTransferLength);\n\tu_int8_t *c = cbw->CBWCDB;\n\tint tag = UGETDW(cbw->dCBWTag);\n\tint flags = cbw->bCBWFlags;\n\n\tDPRINTF(UDMASS_BBB, (\"%s: CBW %d: cmd = %db \"\n\t\t\"(0x%02x%02x%02x%02x%02x%02x%s), \"\n\t\t\"data = %d bytes, dir = %s\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), tag, clen,\n\t\tc[0], c[1], c[2], c[3], c[4], c[5], (clen > 6? \"...\":\"\"),\n\t\tdlen, (flags == CBWFLAGS_IN? \"in\":\n\t\t       (flags == CBWFLAGS_OUT? \"out\":\"<invalid>\"))));\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_BBB",
            "(\"%s: CBW %d: cmd = %db \"\n\t\t\"(0x%02x%02x%02x%02x%02x%02x%s), \"\n\t\t\"data = %d bytes, dir = %s\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), tag, clen,\n\t\tc[0], c[1], c[2], c[3], c[4], c[5], (clen > 6? \"...\":\"\"),\n\t\tdlen, (flags == CBWFLAGS_IN? \"in\":\n\t\t       (flags == CBWFLAGS_OUT? \"out\":\"<invalid>\")))"
          ],
          "line": 3015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 3018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETDW",
          "args": [
            "cbw->dCBWTag"
          ],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETDW",
          "args": [
            "cbw->dCBWDataTransferLength"
          ],
          "line": 3010
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nint s;\n\nStatic void\numass_bbb_dump_cbw(struct umass_softc *sc, umass_bbb_cbw_t *cbw)\n{\n\tint clen = cbw->bCDBLength;\n\tint dlen = UGETDW(cbw->dCBWDataTransferLength);\n\tu_int8_t *c = cbw->CBWCDB;\n\tint tag = UGETDW(cbw->dCBWTag);\n\tint flags = cbw->bCBWFlags;\n\n\tDPRINTF(UDMASS_BBB, (\"%s: CBW %d: cmd = %db \"\n\t\t\"(0x%02x%02x%02x%02x%02x%02x%s), \"\n\t\t\"data = %d bytes, dir = %s\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), tag, clen,\n\t\tc[0], c[1], c[2], c[3], c[4], c[5], (clen > 6? \"...\":\"\"),\n\t\tdlen, (flags == CBWFLAGS_IN? \"in\":\n\t\t       (flags == CBWFLAGS_OUT? \"out\":\"<invalid>\"))));\n}"
  },
  {
    "function_name": "umass_8070_transform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "2995-3000",
    "snippet": "Static int\numass_8070_transform(struct umass_softc *sc, unsigned char *cmd, int cmdlen,\n\t\t     unsigned char **rcmd, int *rcmdlen)\n{\n\treturn 0;\t/* failure */\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "int cmdlen;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nint cmdlen;\n\nStatic int\numass_8070_transform(struct umass_softc *sc, unsigned char *cmd, int cmdlen,\n\t\t     unsigned char **rcmd, int *rcmdlen)\n{\n\treturn 0;\t/* failure */\n}"
  },
  {
    "function_name": "umass_ufi_transform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "2950-2990",
    "snippet": "Static int\numass_ufi_transform(struct umass_softc *sc, unsigned char *cmd, int cmdlen,\n\t\t    unsigned char **rcmd, int *rcmdlen)\n{\n\t*rcmd = cmd;\n\t/* A UFI command is always 12 bytes in length */\n\t/* XXX cmd[(cmdlen+1)..12] contains garbage */\n\t*rcmdlen = 12;\n\n\tswitch (cmd[0]) {\n\tcase TEST_UNIT_READY:\n\t\tif (sc->quirks &  NO_TEST_UNIT_READY) {\n\t\t\tDPRINTF(UDMASS_UFI, (\"%s: Converted TEST_UNIT_READY \"\n\t\t\t\t\"to START_UNIT\\n\", USBDEVNAME(sc->sc_dev)));\n\t\t\tcmd[0] = START_STOP_UNIT;\n\t\t\tcmd[4] = SSS_START;\n\t\t}\n\t\treturn 1;\n\tcase INQUIRY:\n\tcase START_STOP_UNIT:\n\tcase MODE_SENSE:\n\tcase PREVENT_ALLOW:\n\tcase READ_10:\n\tcase READ_12:\n\tcase READ_CAPACITY:\n\tcase REQUEST_SENSE:\n\tcase REZERO_UNIT:\n\tcase POSITION_TO_ELEMENT:\t/* SEEK_10 */\n\tcase SEND_DIAGNOSTIC:\n\tcase WRITE_10:\n\tcase WRITE_12:\n\t/* FORMAT_UNIT */\n\t/* MODE_SELECT */\n\t/* READ_FORMAT_CAPACITY */\n\t/* VERIFY */\n\t/* WRITE_AND_VERIFY */\n\t\treturn 1;\t/* success */\n\tdefault:\n\t\treturn 0;\t/* success */\n\t}\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UDMASS_UFI\t0x00040000\t/* ufi command set */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "int cmdlen;",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_UFI",
            "(\"%s: Converted TEST_UNIT_READY \"\n\t\t\t\t\"to START_UNIT\\n\", USBDEVNAME(sc->sc_dev))"
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2963
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_UFI\t0x00040000\t/* ufi command set */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nint cmdlen;\nint s;\n\nStatic int\numass_ufi_transform(struct umass_softc *sc, unsigned char *cmd, int cmdlen,\n\t\t    unsigned char **rcmd, int *rcmdlen)\n{\n\t*rcmd = cmd;\n\t/* A UFI command is always 12 bytes in length */\n\t/* XXX cmd[(cmdlen+1)..12] contains garbage */\n\t*rcmdlen = 12;\n\n\tswitch (cmd[0]) {\n\tcase TEST_UNIT_READY:\n\t\tif (sc->quirks &  NO_TEST_UNIT_READY) {\n\t\t\tDPRINTF(UDMASS_UFI, (\"%s: Converted TEST_UNIT_READY \"\n\t\t\t\t\"to START_UNIT\\n\", USBDEVNAME(sc->sc_dev)));\n\t\t\tcmd[0] = START_STOP_UNIT;\n\t\t\tcmd[4] = SSS_START;\n\t\t}\n\t\treturn 1;\n\tcase INQUIRY:\n\tcase START_STOP_UNIT:\n\tcase MODE_SENSE:\n\tcase PREVENT_ALLOW:\n\tcase READ_10:\n\tcase READ_12:\n\tcase READ_CAPACITY:\n\tcase REQUEST_SENSE:\n\tcase REZERO_UNIT:\n\tcase POSITION_TO_ELEMENT:\t/* SEEK_10 */\n\tcase SEND_DIAGNOSTIC:\n\tcase WRITE_10:\n\tcase WRITE_12:\n\t/* FORMAT_UNIT */\n\t/* MODE_SELECT */\n\t/* READ_FORMAT_CAPACITY */\n\t/* VERIFY */\n\t/* WRITE_AND_VERIFY */\n\t\treturn 1;\t/* success */\n\tdefault:\n\t\treturn 0;\t/* success */\n\t}\n}"
  },
  {
    "function_name": "umass_scsi_transform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "2925-2944",
    "snippet": "Static int\numass_scsi_transform(struct umass_softc *sc, unsigned char *cmd, int cmdlen,\n\t\t     unsigned char **rcmd, int *rcmdlen)\n{\n\t*rcmd = cmd;\t\t/* trivial copy */\n\t*rcmdlen = cmdlen;\n\n\tswitch (cmd[0]) {\n\tcase TEST_UNIT_READY:\n\t\tif (sc->quirks & NO_TEST_UNIT_READY) {\n\t\t\tDPRINTF(UDMASS_SCSI, (\"%s: Converted TEST_UNIT_READY \"\n\t\t\t\t\"to START_UNIT\\n\", USBDEVNAME(sc->sc_dev)));\n\t\t\tcmd[0] = START_STOP_UNIT;\n\t\t\tcmd[4] = SSS_START;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 1;\t\t/* success */\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UDMASS_SCSI\t0x00020000\t/* scsi */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "int cmdlen;",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s: Converted TEST_UNIT_READY \"\n\t\t\t\t\"to START_UNIT\\n\", USBDEVNAME(sc->sc_dev))"
          ],
          "line": 2935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_SCSI\t0x00020000\t/* scsi */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nint cmdlen;\nint s;\n\nStatic int\numass_scsi_transform(struct umass_softc *sc, unsigned char *cmd, int cmdlen,\n\t\t     unsigned char **rcmd, int *rcmdlen)\n{\n\t*rcmd = cmd;\t\t/* trivial copy */\n\t*rcmdlen = cmdlen;\n\n\tswitch (cmd[0]) {\n\tcase TEST_UNIT_READY:\n\t\tif (sc->quirks & NO_TEST_UNIT_READY) {\n\t\t\tDPRINTF(UDMASS_SCSI, (\"%s: Converted TEST_UNIT_READY \"\n\t\t\t\t\"to START_UNIT\\n\", USBDEVNAME(sc->sc_dev)));\n\t\t\tcmd[0] = START_STOP_UNIT;\n\t\t\tcmd[4] = SSS_START;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 1;\t\t/* success */\n}"
  },
  {
    "function_name": "umass_driver_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "2892-2912",
    "snippet": "Static int\numass_driver_load(module_t mod, int what, void *arg)\n{\n\tint err;\n\n\tswitch (what) {\n\tcase MOD_UNLOAD:\n\t\terr = umass_cam_detach_sim();\n\t\tif (err)\n\t\t\treturn(err);\n\t\treturn(usbd_driver_load(mod, what, arg));\n\tcase MOD_LOAD:\n\t\t/* We don't attach to CAM at this point, because it will try\n\t\t * and malloc memory for it. This is not possible when the\n\t\t * boot loader loads umass as a module before the kernel\n\t\t * has been bootstrapped.\n\t\t */\n\tdefault:\n\t\treturn(usbd_driver_load(mod, what, arg));\n\t}\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "umass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "umass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_driver_load",
          "args": [
            "mod",
            "what",
            "arg"
          ],
          "line": 2910
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_driver_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1144-1150",
          "snippet": "int\nusbd_driver_load(module_t mod, int what, void *arg)\n{\n\t/* XXX should implement something like a function that removes all generic devices */\n \n \treturn (0);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nusbd_driver_load(module_t mod, int what, void *arg)\n{\n\t/* XXX should implement something like a function that removes all generic devices */\n \n \treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "umass_cam_detach_sim",
          "args": [],
          "line": 2899
        },
        "resolved": true,
        "details": {
          "function_name": "umass_cam_detach_sim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "2440-2464",
          "snippet": "Static int\numass_cam_detach_sim()\n{\n\tif (umass_sim)\n\t\treturn(EBUSY);\t/* XXX CAM can't handle disappearing SIMs yet */\n\n\tif (umass_path) {\n\t\t/* XXX do we need to send an asynchroneous event for the SIM?\n\t\txpt_async(AC_LOST_DEVICE, umass_path, NULL);\n\t\t */\n\t\txpt_free_path(umass_path);\n\t\tumass_path = NULL;\n\t}\n\n\tif (umass_sim) {\n\t\tif (xpt_bus_deregister(cam_sim_path(umass_sim)))\n\t\t\tcam_sim_free(umass_sim, /*free_devq*/TRUE);\n\t\telse\n\t\t\treturn(EBUSY);\n\n\t\tumass_sim = NULL;\n\t}\n\n\treturn(0);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cam_sim *umass_sim;",
            "struct cam_path *umass_path;",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\nstruct cam_sim *umass_sim;\nstruct cam_path *umass_path;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\n\nStatic int\numass_cam_detach_sim()\n{\n\tif (umass_sim)\n\t\treturn(EBUSY);\t/* XXX CAM can't handle disappearing SIMs yet */\n\n\tif (umass_path) {\n\t\t/* XXX do we need to send an asynchroneous event for the SIM?\n\t\txpt_async(AC_LOST_DEVICE, umass_path, NULL);\n\t\t */\n\t\txpt_free_path(umass_path);\n\t\tumass_path = NULL;\n\t}\n\n\tif (umass_sim) {\n\t\tif (xpt_bus_deregister(cam_sim_path(umass_sim)))\n\t\t\tcam_sim_free(umass_sim, /*free_devq*/TRUE);\n\t\telse\n\t\t\treturn(EBUSY);\n\n\t\tumass_sim = NULL;\n\t}\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\numass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));\nStatic int;\nStatic void;\nStatic void;\nStatic void;\numass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\n\nStatic int\numass_driver_load(module_t mod, int what, void *arg)\n{\n\tint err;\n\n\tswitch (what) {\n\tcase MOD_UNLOAD:\n\t\terr = umass_cam_detach_sim();\n\t\tif (err)\n\t\t\treturn(err);\n\t\treturn(usbd_driver_load(mod, what, arg));\n\tcase MOD_LOAD:\n\t\t/* We don't attach to CAM at this point, because it will try\n\t\t * and malloc memory for it. This is not possible when the\n\t\t * boot loader loads umass as a module before the kernel\n\t\t * has been bootstrapped.\n\t\t */\n\tdefault:\n\t\treturn(usbd_driver_load(mod, what, arg));\n\t}\n}"
  },
  {
    "function_name": "umass_cam_sense_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "2846-2889",
    "snippet": "Static void\numass_cam_sense_cb(struct umass_softc *sc, void *priv, int residue, int status)\n{\n\tunion ccb *ccb = (union ccb *) priv;\n\tstruct ccb_scsiio *csio = &ccb->csio;\t\t/* deref union */\n\n\tswitch (status) {\n\tcase STATUS_CMD_OK:\n\tcase STATUS_CMD_UNKNOWN:\n\t\t/* Getting sense data succeeded. The length of the sense data\n\t\t * is not returned in any way. The sense data itself contains\n\t\t * the length of the sense data that is valid.\n\t\t */\n\t\tif (sc->quirks & RS_NO_CLEAR_UA\n\t\t    && csio->cdb_io.cdb_bytes[0] == INQUIRY\n\t\t    && (csio->sense_data.flags & SSD_KEY)\n\t\t\t\t\t\t== SSD_KEY_UNIT_ATTENTION) {\n\t\t\t/* Ignore unit attention errors in the case where\n\t\t\t * the Unit Attention state is not cleared on\n\t\t\t * REQUEST SENSE. They will appear again at the next\n\t\t\t * command.\n\t\t\t */\n\t\t\tccb->ccb_h.status = CAM_REQ_CMP;\n\t\t} else if ((csio->sense_data.flags & SSD_KEY)\n\t\t\t\t\t\t== SSD_KEY_NO_SENSE) {\n\t\t\t/* No problem after all (in the case of CBI without\n\t\t\t * CCI)\n\t\t\t */\n\t\t\tccb->ccb_h.status = CAM_REQ_CMP;\n\t\t} else {\n\t\t\tccb->ccb_h.status = CAM_SCSI_STATUS_ERROR\n\t\t\t\t\t    | CAM_AUTOSNS_VALID;\n\t\t\tcsio->scsi_status = SCSI_STATUS_CHECK_COND;\n\t\t}\n\t\txpt_done(ccb);\n\t\tbreak;\n\n\tdefault:\n\t\tDPRINTF(UDMASS_SCSI, (\"%s: Autosense failed, status %d\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), status));\n\t\tccb->ccb_h.status = CAM_AUTOSENSE_FAIL;\n\t\txpt_done(ccb);\n\t}\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define STATUS_CMD_UNKNOWN\t1\t/* will have to fetch sense */",
      "#define STATUS_CMD_OK\t\t0\t/* everything ok */",
      "#define UDMASS_SCSI\t0x00020000\t/* scsi */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "umass_bbb_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "umass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
      "Static void",
      "Static int",
      "Static void",
      "umass_cbi_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "umass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
      "Static void",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xpt_done",
          "args": [
            "ccb"
          ],
          "line": 2887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s: Autosense failed, status %d\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), status)"
          ],
          "line": 2884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_done",
          "args": [
            "ccb"
          ],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define STATUS_CMD_UNKNOWN\t1\t/* will have to fetch sense */\n#define STATUS_CMD_OK\t\t0\t/* everything ok */\n#define UDMASS_SCSI\t0x00020000\t/* scsi */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\numass_bbb_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\numass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\nStatic int;\nStatic void;\numass_cbi_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\numass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\nint s;\n\nStatic void\numass_cam_sense_cb(struct umass_softc *sc, void *priv, int residue, int status)\n{\n\tunion ccb *ccb = (union ccb *) priv;\n\tstruct ccb_scsiio *csio = &ccb->csio;\t\t/* deref union */\n\n\tswitch (status) {\n\tcase STATUS_CMD_OK:\n\tcase STATUS_CMD_UNKNOWN:\n\t\t/* Getting sense data succeeded. The length of the sense data\n\t\t * is not returned in any way. The sense data itself contains\n\t\t * the length of the sense data that is valid.\n\t\t */\n\t\tif (sc->quirks & RS_NO_CLEAR_UA\n\t\t    && csio->cdb_io.cdb_bytes[0] == INQUIRY\n\t\t    && (csio->sense_data.flags & SSD_KEY)\n\t\t\t\t\t\t== SSD_KEY_UNIT_ATTENTION) {\n\t\t\t/* Ignore unit attention errors in the case where\n\t\t\t * the Unit Attention state is not cleared on\n\t\t\t * REQUEST SENSE. They will appear again at the next\n\t\t\t * command.\n\t\t\t */\n\t\t\tccb->ccb_h.status = CAM_REQ_CMP;\n\t\t} else if ((csio->sense_data.flags & SSD_KEY)\n\t\t\t\t\t\t== SSD_KEY_NO_SENSE) {\n\t\t\t/* No problem after all (in the case of CBI without\n\t\t\t * CCI)\n\t\t\t */\n\t\t\tccb->ccb_h.status = CAM_REQ_CMP;\n\t\t} else {\n\t\t\tccb->ccb_h.status = CAM_SCSI_STATUS_ERROR\n\t\t\t\t\t    | CAM_AUTOSNS_VALID;\n\t\t\tcsio->scsi_status = SCSI_STATUS_CHECK_COND;\n\t\t}\n\t\txpt_done(ccb);\n\t\tbreak;\n\n\tdefault:\n\t\tDPRINTF(UDMASS_SCSI, (\"%s: Autosense failed, status %d\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), status));\n\t\tccb->ccb_h.status = CAM_AUTOSENSE_FAIL;\n\t\txpt_done(ccb);\n\t}\n}"
  },
  {
    "function_name": "umass_cam_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "2771-2842",
    "snippet": "Static void\numass_cam_cb(struct umass_softc *sc, void *priv, int residue, int status)\n{\n\tunion ccb *ccb = (union ccb *) priv;\n\tstruct ccb_scsiio *csio = &ccb->csio;\t\t/* deref union */\n\n\tcsio->resid = residue;\n\n\tswitch (status) {\n\tcase STATUS_CMD_OK:\n\t\tccb->ccb_h.status = CAM_REQ_CMP;\n\t\txpt_done(ccb);\n\t\tbreak;\n\n\tcase STATUS_CMD_UNKNOWN:\n\tcase STATUS_CMD_FAILED:\n\t\tswitch (ccb->ccb_h.func_code) {\n\t\tcase XPT_SCSI_IO:\n\t\t{\n\t\t\tunsigned char *cmd;\n\t\t\tint cmdlen;\n\n\t\t\t/* fetch sense data */\n\t\t\tDPRINTF(UDMASS_SCSI,(\"%s: Fetching %db sense data\\n\",\n\t\t\t        USBDEVNAME(sc->sc_dev),\n\t\t\t        sc->cam_scsi_sense.length));\n\n\t\t\tsc->cam_scsi_sense.length = csio->sense_len;\n\n\t\t\tif (sc->transform(sc, (char *) &sc->cam_scsi_sense,\n\t\t\t\t      sizeof(sc->cam_scsi_sense),\n\t\t\t\t      &cmd, &cmdlen)) {\n\t\t\t\tsc->transfer(sc, ccb->ccb_h.target_lun,\n\t\t\t\t\t     cmd, cmdlen,\n\t\t\t\t\t     &csio->sense_data,\n\t\t\t\t\t     csio->sense_len, DIR_IN,\n\t\t\t\t\t     umass_cam_sense_cb, (void *) ccb);\n\t\t\t} else {\n#ifdef UMASS_DEBUG\n\t\t\t\tpanic(\"transform(REQUEST_SENSE) failed\\n\");\n#else \n\t\t\t\tcsio->resid = sc->transfer_datalen;\n\t\t\t\tccb->ccb_h.status = CAM_REQ_CMP_ERR;\n\t\t\t\txpt_done(ccb);\n#endif\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase XPT_RESET_DEV: /* Reset failed */\n\t\t\tccb->ccb_h.status = CAM_REQ_CMP_ERR;\n\t\t\txpt_done(ccb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpanic(\"umass_cam_cb called for func_code %d\\n\",\n\t\t\t      ccb->ccb_h.func_code);\n\t\t}\n\t\tbreak;\n\n\tcase STATUS_WIRE_FAILED:\n\t\t/* the wire protocol failed and will have recovered\n\t\t * (hopefully).\t We return an error to CAM and let CAM retry\n\t\t * the command if necessary.\n\t\t */\n\t\tccb->ccb_h.status = CAM_REQ_CMP_ERR;\n\t\txpt_done(ccb);\n\t\tbreak;\n\n\tdefault:\n\t\tpanic(\"%s: Unknown status %d in umass_cam_cb\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), status);\n\t}\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define STATUS_WIRE_FAILED\t3\t/* couldn't even get command across */",
      "#define STATUS_CMD_FAILED\t2\t/* transfer was ok, command failed */",
      "#define STATUS_CMD_UNKNOWN\t1\t/* will have to fetch sense */",
      "#define STATUS_CMD_OK\t\t0\t/* everything ok */",
      "#define DIR_IN\t\t1",
      "#define UDMASS_SCSI\t0x00020000\t/* scsi */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "umass_bbb_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "umass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
      "Static void",
      "Static int",
      "Static void",
      "umass_cbi_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "umass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
      "Static void",
      "int cmdlen;",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: Unknown status %d in umass_cam_cb\\n\"",
            "USBDEVNAME(sc->sc_dev)",
            "status"
          ],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_done",
          "args": [
            "ccb"
          ],
          "line": 2835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"umass_cam_cb called for func_code %d\\n\"",
            "ccb->ccb_h.func_code"
          ],
          "line": 2824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_done",
          "args": [
            "ccb"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_done",
          "args": [
            "ccb"
          ],
          "line": 2814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"transform(REQUEST_SENSE) failed\\n\""
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->transfer",
          "args": [
            "sc",
            "ccb->ccb_h.target_lun",
            "cmd",
            "cmdlen",
            "&csio->sense_data",
            "csio->sense_len",
            "DIR_IN",
            "umass_cam_sense_cb",
            "(void *) ccb"
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->transform",
          "args": [
            "sc",
            "(char *) &sc->cam_scsi_sense",
            "sizeof(sc->cam_scsi_sense)",
            "&cmd",
            "&cmdlen"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s: Fetching %db sense data\\n\",\n\t\t\t        USBDEVNAME(sc->sc_dev),\n\t\t\t        sc->cam_scsi_sense.length)"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_done",
          "args": [
            "ccb"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define STATUS_WIRE_FAILED\t3\t/* couldn't even get command across */\n#define STATUS_CMD_FAILED\t2\t/* transfer was ok, command failed */\n#define STATUS_CMD_UNKNOWN\t1\t/* will have to fetch sense */\n#define STATUS_CMD_OK\t\t0\t/* everything ok */\n#define DIR_IN\t\t1\n#define UDMASS_SCSI\t0x00020000\t/* scsi */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\numass_bbb_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\numass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\nStatic int;\nStatic void;\numass_cbi_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\numass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\nint cmdlen;\nint s;\n\nStatic void\numass_cam_cb(struct umass_softc *sc, void *priv, int residue, int status)\n{\n\tunion ccb *ccb = (union ccb *) priv;\n\tstruct ccb_scsiio *csio = &ccb->csio;\t\t/* deref union */\n\n\tcsio->resid = residue;\n\n\tswitch (status) {\n\tcase STATUS_CMD_OK:\n\t\tccb->ccb_h.status = CAM_REQ_CMP;\n\t\txpt_done(ccb);\n\t\tbreak;\n\n\tcase STATUS_CMD_UNKNOWN:\n\tcase STATUS_CMD_FAILED:\n\t\tswitch (ccb->ccb_h.func_code) {\n\t\tcase XPT_SCSI_IO:\n\t\t{\n\t\t\tunsigned char *cmd;\n\t\t\tint cmdlen;\n\n\t\t\t/* fetch sense data */\n\t\t\tDPRINTF(UDMASS_SCSI,(\"%s: Fetching %db sense data\\n\",\n\t\t\t        USBDEVNAME(sc->sc_dev),\n\t\t\t        sc->cam_scsi_sense.length));\n\n\t\t\tsc->cam_scsi_sense.length = csio->sense_len;\n\n\t\t\tif (sc->transform(sc, (char *) &sc->cam_scsi_sense,\n\t\t\t\t      sizeof(sc->cam_scsi_sense),\n\t\t\t\t      &cmd, &cmdlen)) {\n\t\t\t\tsc->transfer(sc, ccb->ccb_h.target_lun,\n\t\t\t\t\t     cmd, cmdlen,\n\t\t\t\t\t     &csio->sense_data,\n\t\t\t\t\t     csio->sense_len, DIR_IN,\n\t\t\t\t\t     umass_cam_sense_cb, (void *) ccb);\n\t\t\t} else {\n#ifdef UMASS_DEBUG\n\t\t\t\tpanic(\"transform(REQUEST_SENSE) failed\\n\");\n#else \n\t\t\t\tcsio->resid = sc->transfer_datalen;\n\t\t\t\tccb->ccb_h.status = CAM_REQ_CMP_ERR;\n\t\t\t\txpt_done(ccb);\n#endif\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase XPT_RESET_DEV: /* Reset failed */\n\t\t\tccb->ccb_h.status = CAM_REQ_CMP_ERR;\n\t\t\txpt_done(ccb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpanic(\"umass_cam_cb called for func_code %d\\n\",\n\t\t\t      ccb->ccb_h.func_code);\n\t\t}\n\t\tbreak;\n\n\tcase STATUS_WIRE_FAILED:\n\t\t/* the wire protocol failed and will have recovered\n\t\t * (hopefully).\t We return an error to CAM and let CAM retry\n\t\t * the command if necessary.\n\t\t */\n\t\tccb->ccb_h.status = CAM_REQ_CMP_ERR;\n\t\txpt_done(ccb);\n\t\tbreak;\n\n\tdefault:\n\t\tpanic(\"%s: Unknown status %d in umass_cam_cb\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), status);\n\t}\n}"
  },
  {
    "function_name": "umass_cam_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "2753-2764",
    "snippet": "Static void\numass_cam_poll(struct cam_sim *sim)\n{\n#ifdef UMASS_DEBUG\n\tstruct umass_softc *sc = (struct umass_softc *) sim->softc;\n\n\tDPRINTF(UDMASS_SCSI, (\"%s: CAM poll\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n#endif\n\n\t/* nop */\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UDMASS_SCSI\t0x00020000\t/* scsi */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s: CAM poll\\n\",\n\t\tUSBDEVNAME(sc->sc_dev))"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_SCSI\t0x00020000\t/* scsi */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nint s;\n\nStatic void\numass_cam_poll(struct cam_sim *sim)\n{\n#ifdef UMASS_DEBUG\n\tstruct umass_softc *sc = (struct umass_softc *) sim->softc;\n\n\tDPRINTF(UDMASS_SCSI, (\"%s: CAM poll\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n#endif\n\n\t/* nop */\n}"
  },
  {
    "function_name": "umass_cam_action",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "2491-2747",
    "snippet": "Static void\numass_cam_action(struct cam_sim *sim, union ccb *ccb)\n{\n\tstruct umass_softc *sc = devclass_get_softc(umass_devclass,\n\t\t\t\t\t       ccb->ccb_h.target_id);\n\n\t/* The softc is still there, but marked as going away. umass_cam_detach\n\t * has not yet notified CAM of the lost device however.\n\t */\n\tif (sc && sc->sc_dying) {\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:func_code 0x%04x: \"\n\t\t\t\"Invalid target (gone)\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\tccb->ccb_h.func_code));\n\t\tccb->ccb_h.status = CAM_TID_INVALID;\n\t\txpt_done(ccb);\n\t\treturn;\n\t}\n\n\t/* Verify, depending on the operation to perform, that we either got a\n\t * valid sc, because an existing target was referenced, or otherwise\n\t * the SIM is addressed.\n\t *\n\t * This avoids bombing out at a printf and does give the CAM layer some\n\t * sensible feedback on errors.\n\t */\n\tswitch (ccb->ccb_h.func_code) {\n\tcase XPT_SCSI_IO:\n\tcase XPT_RESET_DEV:\n\tcase XPT_GET_TRAN_SETTINGS:\n\tcase XPT_SET_TRAN_SETTINGS:\n\tcase XPT_CALC_GEOMETRY:\n\t\t/* the opcodes requiring a target. These should never occur. */\n\t\tif (sc == NULL) {\n\t\t\tprintf(\"%s:%d:%d:%d:func_code 0x%04x: \"\n\t\t\t\t\"Invalid target\\n\",\n\t\t\t\tDEVNAME_SIM, UMASS_SCSI_BUS,\n\t\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\t\tccb->ccb_h.func_code);\n\n\t\t\tccb->ccb_h.status = CAM_TID_INVALID;\n\t\t\txpt_done(ccb);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase XPT_PATH_INQ:\n\tcase XPT_NOOP:\n\t\t/* The opcodes sometimes aimed at a target (sc is valid),\n\t\t * sometimes aimed at the SIM (sc is invalid and target is\n\t\t * CAM_TARGET_WILDCARD)\n\t\t */\n\t\tif (sc == NULL && ccb->ccb_h.target_id != CAM_TARGET_WILDCARD) {\n\t\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:func_code 0x%04x: \"\n\t\t\t\t\"Invalid target\\n\",\n\t\t\t\tDEVNAME_SIM, UMASS_SCSI_BUS,\n\t\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\t\tccb->ccb_h.func_code));\n\n\t\t\tccb->ccb_h.status = CAM_TID_INVALID;\n\t\t\txpt_done(ccb);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/* XXX Hm, we should check the input parameters */\n\t}\n\n\t/* Perform the requested action */\n\tswitch (ccb->ccb_h.func_code) {\n\tcase XPT_SCSI_IO:\n\t{\n\t\tstruct ccb_scsiio *csio = &ccb->csio;\t/* deref union */\n\t\tint dir;\n\t\tunsigned char *cmd;\n\t\tint cmdlen;\n\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:XPT_SCSI_IO: \"\n\t\t\t\"cmd: 0x%02x, flags: 0x%02x, \"\n\t\t\t\"%db cmd/%db data/%db sense\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\tcsio->cdb_io.cdb_bytes[0],\n\t\t\tccb->ccb_h.flags & CAM_DIR_MASK,\n\t\t\tcsio->cdb_len, csio->dxfer_len,\n\t\t\tcsio->sense_len));\n\n\t\t/* clear the end of the buffer to make sure we don't send out\n\t\t * garbage.\n\t\t */\n\t\tDIF(UDMASS_SCSI, if ((ccb->ccb_h.flags & CAM_DIR_MASK)\n\t\t\t\t     == CAM_DIR_OUT)\n\t\t\t\t\tumass_dump_buffer(sc, csio->data_ptr,\n\t\t\t\t\t\tcsio->dxfer_len, 48));\n\n\t\tif (sc->transfer_state != TSTATE_IDLE) {\n\t\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:XPT_SCSI_IO: \"\n\t\t\t\t\"I/O requested while busy (state %d, %s)\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\t\tsc->transfer_state,states[sc->transfer_state]));\n\t\t\tccb->ccb_h.status = CAM_SCSI_BUSY;\n\t\t\txpt_done(ccb);\n\t\t\treturn;\n\t\t}\n\n\t\tswitch(ccb->ccb_h.flags&CAM_DIR_MASK) {\n\t\tcase CAM_DIR_IN:\n\t\t\tdir = DIR_IN;\n\t\t\tbreak;\n\t\tcase CAM_DIR_OUT:\n\t\t\tdir = DIR_OUT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdir = DIR_NONE;\n\t\t}\n\n\t\tccb->ccb_h.status = CAM_REQ_INPROG | CAM_SIM_QUEUED;\n\t\tif (sc->transform(sc, csio->cdb_io.cdb_bytes, csio->cdb_len,\n\t\t\t\t  &cmd, &cmdlen)) {\n\t\t\tsc->transfer(sc, ccb->ccb_h.target_lun, cmd, cmdlen,\n\t\t\t\t     csio->data_ptr,\n\t\t\t\t     csio->dxfer_len, dir,\n\t\t\t\t     umass_cam_cb, (void *) ccb);\n\t\t} else {\n\t\t\tccb->ccb_h.status = CAM_REQ_INVALID;\n\t\t\txpt_done(ccb);\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase XPT_PATH_INQ:\n\t{\n\t\tstruct ccb_pathinq *cpi = &ccb->cpi;\n\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:XPT_PATH_INQ:.\\n\",\n\t\t\t(sc == NULL? DEVNAME_SIM:USBDEVNAME(sc->sc_dev)),\n\t\t\tUMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun));\n\n\t\t/* host specific information */\n\t\tcpi->version_num = 1;\n\t\tcpi->hba_inquiry = 0;\n\t\tcpi->target_sprt = 0;\n\t\tcpi->hba_misc = 0;\n\t\tcpi->hba_eng_cnt = 0;\n\t\tcpi->max_target = UMASS_SCSIID_MAX;\t/* one target */\n\t\tcpi->max_lun = 0;\t/* no LUN's supported */\n\t\tcpi->initiator_id = UMASS_SCSIID_HOST;\n\t\tstrncpy(cpi->sim_vid, \"FreeBSD\", SIM_IDLEN);\n\t\tstrncpy(cpi->hba_vid, \"USB SCSI\", HBA_IDLEN);\n\t\tstrncpy(cpi->dev_name, cam_sim_name(sim), DEV_IDLEN);\n\t\tcpi->unit_number = cam_sim_unit(sim);\n\t\tcpi->bus_id = UMASS_SCSI_BUS;\n\t\tif (sc) {\n\t\t\tcpi->base_transfer_speed = sc->transfer_speed;\n\t\t\tcpi->max_lun = sc->maxlun;\n\t\t}\n\n\t\tcpi->ccb_h.status = CAM_REQ_CMP;\n\t\txpt_done(ccb);\n\t\tbreak;\n\t}\n\tcase XPT_RESET_DEV:\n\t{\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:XPT_RESET_DEV:.\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun));\n\n\t\tccb->ccb_h.status = CAM_REQ_INPROG;\n\t\tumass_reset(sc, umass_cam_cb, (void *) ccb);\n\t\tbreak;\n\t} \n\tcase XPT_GET_TRAN_SETTINGS:\n\t{\n\t\tstruct ccb_trans_settings *cts = &ccb->cts;\n\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:XPT_GET_TRAN_SETTINGS:.\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun));\n\n\t\tcts->valid = 0;\n\t\tcts->flags = 0;\t\t/* no disconnection, tagging */\n\n\t\tccb->ccb_h.status = CAM_REQ_CMP;\n\t\txpt_done(ccb);\n\t\tbreak;\n\t}\n\tcase XPT_SET_TRAN_SETTINGS:\n\t{\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:XPT_SET_TRAN_SETTINGS:.\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun));\n\n\t\tccb->ccb_h.status = CAM_FUNC_NOTAVAIL;\n\t\txpt_done(ccb);\n\t\tbreak;\n\t}\n\tcase XPT_CALC_GEOMETRY:\n\t{\n\t\tstruct ccb_calc_geometry *ccg = &ccb->ccg;\n\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:XPT_CALC_GEOMETRY: \"\n\t\t\t\"Volume size = %d\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\tccg->volume_size));\n\n\t\t/* XXX We should probably ask the drive for the details\n\t\t *     instead of cluching them up ourselves\n\t\t */\n\t\tif (sc->drive == ZIP_100) {\n\t\t\tccg->heads = 64;\n\t\t\tccg->secs_per_track = 32;\n\t\t\tccg->cylinders = ccg->volume_size / ccg->heads\n\t\t\t\t\t  / ccg->secs_per_track;\n\t\t\tccb->ccb_h.status = CAM_REQ_CMP;\n\t\t\tbreak;\n\t\t} else if (sc->proto & PROTO_UFI) {\n\t\t\tccg->heads = 2;\n\t\t\tif (ccg->volume_size == 2880)\n\t\t\t\tccg->secs_per_track = 18;\n\t\t\telse\n\t\t\t\tccg->secs_per_track = 9;\n\t\t\tccg->cylinders = 80;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tccb->ccb_h.status = CAM_REQ_CMP_ERR;\n\t\t}\n\n\t\txpt_done(ccb);\n\t\tbreak;\n\t}\n\tcase XPT_NOOP:\n\t{\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:XPT_NOOP:.\\n\",\n\t\t\t(sc == NULL? DEVNAME_SIM:USBDEVNAME(sc->sc_dev)),\n\t\t\tUMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun));\n\n\t\tccb->ccb_h.status = CAM_REQ_CMP;\n\t\txpt_done(ccb);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:func_code 0x%04x: \"\n\t\t\t\"Not implemented\\n\",\n\t\t\t(sc == NULL? DEVNAME_SIM:USBDEVNAME(sc->sc_dev)),\n\t\t\tUMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\tccb->ccb_h.func_code));\n\n\t\tccb->ccb_h.status = CAM_FUNC_NOTAVAIL;\n\t\txpt_done(ccb);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UMASS_SCSIID_HOST\t0x00",
      "#define UMASS_SCSIID_HOST\tUMASS_SCSIID_MAX",
      "#define UMASS_SCSIID_MAX\t3\t/* maximum number of drives expected */",
      "#define UMASS_SCSIID_MAX\t32\t/* maximum number of drives expected */",
      "#define UMASS_SCSI_BUS\t\t0",
      "#define DEVNAME_SIM\t\"umass-\"",
      "#define DIR_OUT\t\t2",
      "#define DIR_IN\t\t1",
      "#define DIR_NONE\t0",
      "#define UDMASS_SCSI\t0x00020000\t/* scsi */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "umass_bbb_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "umass_cbi_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "Static void",
      "int cmdlen;",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xpt_done",
          "args": [
            "ccb"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s:%d:%d:%d:func_code 0x%04x: \"\n\t\t\t\"Not implemented\\n\",\n\t\t\t(sc == NULL? DEVNAME_SIM:USBDEVNAME(sc->sc_dev)),\n\t\t\tUMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\tccb->ccb_h.func_code)"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_done",
          "args": [
            "ccb"
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s:%d:%d:%d:XPT_NOOP:.\\n\",\n\t\t\t(sc == NULL? DEVNAME_SIM:USBDEVNAME(sc->sc_dev)),\n\t\t\tUMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun)"
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_done",
          "args": [
            "ccb"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s:%d:%d:%d:XPT_CALC_GEOMETRY: \"\n\t\t\t\"Volume size = %d\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\tccg->volume_size)"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_done",
          "args": [
            "ccb"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s:%d:%d:%d:XPT_SET_TRAN_SETTINGS:.\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun)"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_done",
          "args": [
            "ccb"
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s:%d:%d:%d:XPT_GET_TRAN_SETTINGS:.\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun)"
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umass_reset",
          "args": [
            "sc",
            "umass_cam_cb",
            "(void *) ccb"
          ],
          "line": 2661
        },
        "resolved": true,
        "details": {
          "function_name": "umass_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "1365-1373",
          "snippet": "Static void\numass_reset(struct umass_softc *sc, transfer_cb_f cb, void *priv)\n{\n\tsc->transfer_cb = cb;\n\tsc->transfer_priv = priv;\n\n\t/* The reset is a forced reset, so no error (yet) */\n\tsc->reset(sc, STATUS_CMD_OK);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define STATUS_CMD_OK\t\t0\t/* everything ok */"
          ],
          "globals_used": [
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "Static void",
            "Static void",
            "Static void",
            "umass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "umass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
            "Static void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define STATUS_CMD_OK\t\t0\t/* everything ok */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\numass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\numass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\n\nStatic void\numass_reset(struct umass_softc *sc, transfer_cb_f cb, void *priv)\n{\n\tsc->transfer_cb = cb;\n\tsc->transfer_priv = priv;\n\n\t/* The reset is a forced reset, so no error (yet) */\n\tsc->reset(sc, STATUS_CMD_OK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s:%d:%d:%d:XPT_RESET_DEV:.\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun)"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_done",
          "args": [
            "ccb"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cam_sim_unit",
          "args": [
            "sim"
          ],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "cpi->dev_name",
            "cam_sim_name(sim)",
            "DEV_IDLEN"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cam_sim_name",
          "args": [
            "sim"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "cpi->hba_vid",
            "\"USB SCSI\"",
            "HBA_IDLEN"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "cpi->sim_vid",
            "\"FreeBSD\"",
            "SIM_IDLEN"
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s:%d:%d:%d:XPT_PATH_INQ:.\\n\",\n\t\t\t(sc == NULL? DEVNAME_SIM:USBDEVNAME(sc->sc_dev)),\n\t\t\tUMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun)"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_done",
          "args": [
            "ccb"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->transfer",
          "args": [
            "sc",
            "ccb->ccb_h.target_lun",
            "cmd",
            "cmdlen",
            "csio->data_ptr",
            "csio->dxfer_len",
            "dir",
            "umass_cam_cb",
            "(void *) ccb"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->transform",
          "args": [
            "sc",
            "csio->cdb_io.cdb_bytes",
            "csio->cdb_len",
            "&cmd",
            "&cmdlen"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_done",
          "args": [
            "ccb"
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s:%d:%d:%d:XPT_SCSI_IO: \"\n\t\t\t\t\"I/O requested while busy (state %d, %s)\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\t\tsc->transfer_state,states[sc->transfer_state])"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIF",
          "args": [
            "UDMASS_SCSI",
            "if ((ccb->ccb_h.flags & CAM_DIR_MASK)\n\t\t\t\t     == CAM_DIR_OUT)umass_dump_buffer(sc, csio->data_ptr,\n\t\t\t\t\t\tcsio->dxfer_len, 48)"
          ],
          "line": 2581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umass_dump_buffer",
          "args": [
            "sc",
            "csio->data_ptr",
            "csio->dxfer_len",
            "48"
          ],
          "line": 2583
        },
        "resolved": true,
        "details": {
          "function_name": "umass_dump_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "3041-3067",
          "snippet": "Static void\numass_dump_buffer(struct umass_softc *sc, u_int8_t *buffer, int buflen,\n\t\t  int printlen)\n{\n\tint i, j;\n\tchar s1[40];\n\tchar s2[40];\n\tchar s3[5];\n\n\ts1[0] = '\\0';\n\ts3[0] = '\\0';\n\n\tsprintf(s2, \" buffer=%p, buflen=%d\", buffer, buflen);\n\tfor (i = 0; i < buflen && i < printlen; i++) {\n\t\tj = i % 16;\n\t\tif (j == 0 && i != 0) {\n\t\t\tDPRINTF(UDMASS_GEN, (\"%s: 0x %s%s\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev), s1, s2));\n\t\t\ts2[0] = '\\0';\n\t\t}\n\t\tsprintf(&s1[j*2], \"%02x\", buffer[i] & 0xff);\n\t}\n\tif (buflen > printlen)\n\t\tsprintf(s3, \" ...\");\n\tDPRINTF(UDMASS_GEN, (\"%s: 0x %s%s%s\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), s1, s2, s3));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UDMASS_GEN\t0x00010000\t/* general */"
          ],
          "globals_used": [
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_GEN\t0x00010000\t/* general */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nint s;\n\nStatic void\numass_dump_buffer(struct umass_softc *sc, u_int8_t *buffer, int buflen,\n\t\t  int printlen)\n{\n\tint i, j;\n\tchar s1[40];\n\tchar s2[40];\n\tchar s3[5];\n\n\ts1[0] = '\\0';\n\ts3[0] = '\\0';\n\n\tsprintf(s2, \" buffer=%p, buflen=%d\", buffer, buflen);\n\tfor (i = 0; i < buflen && i < printlen; i++) {\n\t\tj = i % 16;\n\t\tif (j == 0 && i != 0) {\n\t\t\tDPRINTF(UDMASS_GEN, (\"%s: 0x %s%s\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev), s1, s2));\n\t\t\ts2[0] = '\\0';\n\t\t}\n\t\tsprintf(&s1[j*2], \"%02x\", buffer[i] & 0xff);\n\t}\n\tif (buflen > printlen)\n\t\tsprintf(s3, \" ...\");\n\tDPRINTF(UDMASS_GEN, (\"%s: 0x %s%s%s\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), s1, s2, s3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "if",
          "args": [
            "(ccb->ccb_h.flags & CAM_DIR_MASK)\n\t\t\t\t     == CAM_DIR_OUT"
          ],
          "line": 2581
        },
        "resolved": true,
        "details": {
          "function_name": "aue_ifmedia_sts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "1666-1679",
          "snippet": "Static void\naue_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\tstruct mii_data\t\t*mii = GET_MII(sc);\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tmii_pollstat(mii);\n\tifmr->ifm_active = mii->mii_media_active;\n\tifmr->ifm_status = mii->mii_media_status;\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "aue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "aue_watchdog\t__P((struct ifnet *));",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "aue_ifmedia_upd\t__P((struct ifnet *));",
            "Static void",
            "aue_ifmedia_sts\t__P((struct ifnet *, struct ifmediareq *));",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\naue_ifmedia_sts\t__P((struct ifnet *, struct ifmediareq *));\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\tstruct mii_data\t\t*mii = GET_MII(sc);\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tmii_pollstat(mii);\n\tifmr->ifm_active = mii->mii_media_active;\n\tifmr->ifm_status = mii->mii_media_status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s:%d:%d:%d:XPT_SCSI_IO: \"\n\t\t\t\"cmd: 0x%02x, flags: 0x%02x, \"\n\t\t\t\"%db cmd/%db data/%db sense\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\tcsio->cdb_io.cdb_bytes[0],\n\t\t\tccb->ccb_h.flags & CAM_DIR_MASK,\n\t\t\tcsio->cdb_len, csio->dxfer_len,\n\t\t\tcsio->sense_len)"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_done",
          "args": [
            "ccb"
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s:%d:%d:%d:func_code 0x%04x: \"\n\t\t\t\t\"Invalid target\\n\",\n\t\t\t\tDEVNAME_SIM, UMASS_SCSI_BUS,\n\t\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\t\tccb->ccb_h.func_code)"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_done",
          "args": [
            "ccb"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s:%d:%d:%d:func_code 0x%04x: \"\n\t\t\t\t\"Invalid target\\n\"",
            "DEVNAME_SIM",
            "UMASS_SCSI_BUS",
            "ccb->ccb_h.target_id",
            "ccb->ccb_h.target_lun",
            "ccb->ccb_h.func_code"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xpt_done",
          "args": [
            "ccb"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s:%d:%d:%d:func_code 0x%04x: \"\n\t\t\t\"Invalid target (gone)\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\tccb->ccb_h.func_code)"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devclass_get_softc",
          "args": [
            "umass_devclass",
            "ccb->ccb_h.target_id"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UMASS_SCSIID_HOST\t0x00\n#define UMASS_SCSIID_HOST\tUMASS_SCSIID_MAX\n#define UMASS_SCSIID_MAX\t3\t/* maximum number of drives expected */\n#define UMASS_SCSIID_MAX\t32\t/* maximum number of drives expected */\n#define UMASS_SCSI_BUS\t\t0\n#define DEVNAME_SIM\t\"umass-\"\n#define DIR_OUT\t\t2\n#define DIR_IN\t\t1\n#define DIR_NONE\t0\n#define UDMASS_SCSI\t0x00020000\t/* scsi */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\numass_bbb_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\numass_cbi_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nint cmdlen;\nint s;\n\nStatic void\numass_cam_action(struct cam_sim *sim, union ccb *ccb)\n{\n\tstruct umass_softc *sc = devclass_get_softc(umass_devclass,\n\t\t\t\t\t       ccb->ccb_h.target_id);\n\n\t/* The softc is still there, but marked as going away. umass_cam_detach\n\t * has not yet notified CAM of the lost device however.\n\t */\n\tif (sc && sc->sc_dying) {\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:func_code 0x%04x: \"\n\t\t\t\"Invalid target (gone)\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\tccb->ccb_h.func_code));\n\t\tccb->ccb_h.status = CAM_TID_INVALID;\n\t\txpt_done(ccb);\n\t\treturn;\n\t}\n\n\t/* Verify, depending on the operation to perform, that we either got a\n\t * valid sc, because an existing target was referenced, or otherwise\n\t * the SIM is addressed.\n\t *\n\t * This avoids bombing out at a printf and does give the CAM layer some\n\t * sensible feedback on errors.\n\t */\n\tswitch (ccb->ccb_h.func_code) {\n\tcase XPT_SCSI_IO:\n\tcase XPT_RESET_DEV:\n\tcase XPT_GET_TRAN_SETTINGS:\n\tcase XPT_SET_TRAN_SETTINGS:\n\tcase XPT_CALC_GEOMETRY:\n\t\t/* the opcodes requiring a target. These should never occur. */\n\t\tif (sc == NULL) {\n\t\t\tprintf(\"%s:%d:%d:%d:func_code 0x%04x: \"\n\t\t\t\t\"Invalid target\\n\",\n\t\t\t\tDEVNAME_SIM, UMASS_SCSI_BUS,\n\t\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\t\tccb->ccb_h.func_code);\n\n\t\t\tccb->ccb_h.status = CAM_TID_INVALID;\n\t\t\txpt_done(ccb);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase XPT_PATH_INQ:\n\tcase XPT_NOOP:\n\t\t/* The opcodes sometimes aimed at a target (sc is valid),\n\t\t * sometimes aimed at the SIM (sc is invalid and target is\n\t\t * CAM_TARGET_WILDCARD)\n\t\t */\n\t\tif (sc == NULL && ccb->ccb_h.target_id != CAM_TARGET_WILDCARD) {\n\t\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:func_code 0x%04x: \"\n\t\t\t\t\"Invalid target\\n\",\n\t\t\t\tDEVNAME_SIM, UMASS_SCSI_BUS,\n\t\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\t\tccb->ccb_h.func_code));\n\n\t\t\tccb->ccb_h.status = CAM_TID_INVALID;\n\t\t\txpt_done(ccb);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/* XXX Hm, we should check the input parameters */\n\t}\n\n\t/* Perform the requested action */\n\tswitch (ccb->ccb_h.func_code) {\n\tcase XPT_SCSI_IO:\n\t{\n\t\tstruct ccb_scsiio *csio = &ccb->csio;\t/* deref union */\n\t\tint dir;\n\t\tunsigned char *cmd;\n\t\tint cmdlen;\n\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:XPT_SCSI_IO: \"\n\t\t\t\"cmd: 0x%02x, flags: 0x%02x, \"\n\t\t\t\"%db cmd/%db data/%db sense\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\tcsio->cdb_io.cdb_bytes[0],\n\t\t\tccb->ccb_h.flags & CAM_DIR_MASK,\n\t\t\tcsio->cdb_len, csio->dxfer_len,\n\t\t\tcsio->sense_len));\n\n\t\t/* clear the end of the buffer to make sure we don't send out\n\t\t * garbage.\n\t\t */\n\t\tDIF(UDMASS_SCSI, if ((ccb->ccb_h.flags & CAM_DIR_MASK)\n\t\t\t\t     == CAM_DIR_OUT)\n\t\t\t\t\tumass_dump_buffer(sc, csio->data_ptr,\n\t\t\t\t\t\tcsio->dxfer_len, 48));\n\n\t\tif (sc->transfer_state != TSTATE_IDLE) {\n\t\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:XPT_SCSI_IO: \"\n\t\t\t\t\"I/O requested while busy (state %d, %s)\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\t\tsc->transfer_state,states[sc->transfer_state]));\n\t\t\tccb->ccb_h.status = CAM_SCSI_BUSY;\n\t\t\txpt_done(ccb);\n\t\t\treturn;\n\t\t}\n\n\t\tswitch(ccb->ccb_h.flags&CAM_DIR_MASK) {\n\t\tcase CAM_DIR_IN:\n\t\t\tdir = DIR_IN;\n\t\t\tbreak;\n\t\tcase CAM_DIR_OUT:\n\t\t\tdir = DIR_OUT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdir = DIR_NONE;\n\t\t}\n\n\t\tccb->ccb_h.status = CAM_REQ_INPROG | CAM_SIM_QUEUED;\n\t\tif (sc->transform(sc, csio->cdb_io.cdb_bytes, csio->cdb_len,\n\t\t\t\t  &cmd, &cmdlen)) {\n\t\t\tsc->transfer(sc, ccb->ccb_h.target_lun, cmd, cmdlen,\n\t\t\t\t     csio->data_ptr,\n\t\t\t\t     csio->dxfer_len, dir,\n\t\t\t\t     umass_cam_cb, (void *) ccb);\n\t\t} else {\n\t\t\tccb->ccb_h.status = CAM_REQ_INVALID;\n\t\t\txpt_done(ccb);\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase XPT_PATH_INQ:\n\t{\n\t\tstruct ccb_pathinq *cpi = &ccb->cpi;\n\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:XPT_PATH_INQ:.\\n\",\n\t\t\t(sc == NULL? DEVNAME_SIM:USBDEVNAME(sc->sc_dev)),\n\t\t\tUMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun));\n\n\t\t/* host specific information */\n\t\tcpi->version_num = 1;\n\t\tcpi->hba_inquiry = 0;\n\t\tcpi->target_sprt = 0;\n\t\tcpi->hba_misc = 0;\n\t\tcpi->hba_eng_cnt = 0;\n\t\tcpi->max_target = UMASS_SCSIID_MAX;\t/* one target */\n\t\tcpi->max_lun = 0;\t/* no LUN's supported */\n\t\tcpi->initiator_id = UMASS_SCSIID_HOST;\n\t\tstrncpy(cpi->sim_vid, \"FreeBSD\", SIM_IDLEN);\n\t\tstrncpy(cpi->hba_vid, \"USB SCSI\", HBA_IDLEN);\n\t\tstrncpy(cpi->dev_name, cam_sim_name(sim), DEV_IDLEN);\n\t\tcpi->unit_number = cam_sim_unit(sim);\n\t\tcpi->bus_id = UMASS_SCSI_BUS;\n\t\tif (sc) {\n\t\t\tcpi->base_transfer_speed = sc->transfer_speed;\n\t\t\tcpi->max_lun = sc->maxlun;\n\t\t}\n\n\t\tcpi->ccb_h.status = CAM_REQ_CMP;\n\t\txpt_done(ccb);\n\t\tbreak;\n\t}\n\tcase XPT_RESET_DEV:\n\t{\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:XPT_RESET_DEV:.\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun));\n\n\t\tccb->ccb_h.status = CAM_REQ_INPROG;\n\t\tumass_reset(sc, umass_cam_cb, (void *) ccb);\n\t\tbreak;\n\t} \n\tcase XPT_GET_TRAN_SETTINGS:\n\t{\n\t\tstruct ccb_trans_settings *cts = &ccb->cts;\n\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:XPT_GET_TRAN_SETTINGS:.\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun));\n\n\t\tcts->valid = 0;\n\t\tcts->flags = 0;\t\t/* no disconnection, tagging */\n\n\t\tccb->ccb_h.status = CAM_REQ_CMP;\n\t\txpt_done(ccb);\n\t\tbreak;\n\t}\n\tcase XPT_SET_TRAN_SETTINGS:\n\t{\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:XPT_SET_TRAN_SETTINGS:.\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun));\n\n\t\tccb->ccb_h.status = CAM_FUNC_NOTAVAIL;\n\t\txpt_done(ccb);\n\t\tbreak;\n\t}\n\tcase XPT_CALC_GEOMETRY:\n\t{\n\t\tstruct ccb_calc_geometry *ccg = &ccb->ccg;\n\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:XPT_CALC_GEOMETRY: \"\n\t\t\t\"Volume size = %d\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\tccg->volume_size));\n\n\t\t/* XXX We should probably ask the drive for the details\n\t\t *     instead of cluching them up ourselves\n\t\t */\n\t\tif (sc->drive == ZIP_100) {\n\t\t\tccg->heads = 64;\n\t\t\tccg->secs_per_track = 32;\n\t\t\tccg->cylinders = ccg->volume_size / ccg->heads\n\t\t\t\t\t  / ccg->secs_per_track;\n\t\t\tccb->ccb_h.status = CAM_REQ_CMP;\n\t\t\tbreak;\n\t\t} else if (sc->proto & PROTO_UFI) {\n\t\t\tccg->heads = 2;\n\t\t\tif (ccg->volume_size == 2880)\n\t\t\t\tccg->secs_per_track = 18;\n\t\t\telse\n\t\t\t\tccg->secs_per_track = 9;\n\t\t\tccg->cylinders = 80;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tccb->ccb_h.status = CAM_REQ_CMP_ERR;\n\t\t}\n\n\t\txpt_done(ccb);\n\t\tbreak;\n\t}\n\tcase XPT_NOOP:\n\t{\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:XPT_NOOP:.\\n\",\n\t\t\t(sc == NULL? DEVNAME_SIM:USBDEVNAME(sc->sc_dev)),\n\t\t\tUMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun));\n\n\t\tccb->ccb_h.status = CAM_REQ_CMP;\n\t\txpt_done(ccb);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d:func_code 0x%04x: \"\n\t\t\t\"Not implemented\\n\",\n\t\t\t(sc == NULL? DEVNAME_SIM:USBDEVNAME(sc->sc_dev)),\n\t\t\tUMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\tccb->ccb_h.func_code));\n\n\t\tccb->ccb_h.status = CAM_FUNC_NOTAVAIL;\n\t\txpt_done(ccb);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "umass_cam_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "2466-2483",
    "snippet": "Static int\numass_cam_detach(struct umass_softc *sc)\n{\n\tstruct cam_path *path;\n\n\t/* detach of sim not done until module unload */\n\tDPRINTF(UDMASS_SCSI, (\"%s: losing CAM device entry\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n\n\tif (xpt_create_path(&path, NULL, cam_sim_path(umass_sim),\n\t\t    device_get_unit(sc->sc_dev), CAM_LUN_WILDCARD)\n\t    != CAM_REQ_CMP)\n\t\treturn(ENOMEM);\n\txpt_async(AC_LOST_DEVICE, path, NULL);\n\txpt_free_path(path);\n\n\treturn(0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UDMASS_SCSI\t0x00020000\t/* scsi */"
    ],
    "globals_used": [
      "struct cam_sim *umass_sim;",
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xpt_free_path",
          "args": [
            "path"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_async",
          "args": [
            "AC_LOST_DEVICE",
            "path",
            "NULL"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_create_path",
          "args": [
            "&path",
            "NULL",
            "cam_sim_path(umass_sim)",
            "device_get_unit(sc->sc_dev)",
            "CAM_LUN_WILDCARD"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_get_unit",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cam_sim_path",
          "args": [
            "umass_sim"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s: losing CAM device entry\\n\",\n\t\tUSBDEVNAME(sc->sc_dev))"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_SCSI\t0x00020000\t/* scsi */\n\nstruct cam_sim *umass_sim;\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nint s;\n\nStatic int\numass_cam_detach(struct umass_softc *sc)\n{\n\tstruct cam_path *path;\n\n\t/* detach of sim not done until module unload */\n\tDPRINTF(UDMASS_SCSI, (\"%s: losing CAM device entry\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n\n\tif (xpt_create_path(&path, NULL, cam_sim_path(umass_sim),\n\t\t    device_get_unit(sc->sc_dev), CAM_LUN_WILDCARD)\n\t    != CAM_REQ_CMP)\n\t\treturn(ENOMEM);\n\txpt_async(AC_LOST_DEVICE, path, NULL);\n\txpt_free_path(path);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "umass_cam_detach_sim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "2440-2464",
    "snippet": "Static int\numass_cam_detach_sim()\n{\n\tif (umass_sim)\n\t\treturn(EBUSY);\t/* XXX CAM can't handle disappearing SIMs yet */\n\n\tif (umass_path) {\n\t\t/* XXX do we need to send an asynchroneous event for the SIM?\n\t\txpt_async(AC_LOST_DEVICE, umass_path, NULL);\n\t\t */\n\t\txpt_free_path(umass_path);\n\t\tumass_path = NULL;\n\t}\n\n\tif (umass_sim) {\n\t\tif (xpt_bus_deregister(cam_sim_path(umass_sim)))\n\t\t\tcam_sim_free(umass_sim, /*free_devq*/TRUE);\n\t\telse\n\t\t\treturn(EBUSY);\n\n\t\tumass_sim = NULL;\n\t}\n\n\treturn(0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cam_sim *umass_sim;",
      "struct cam_path *umass_path;",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cam_sim_free",
          "args": [
            "umass_sim",
            "/*free_devq*/TRUE"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_bus_deregister",
          "args": [
            "cam_sim_path(umass_sim)"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cam_sim_path",
          "args": [
            "umass_sim"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_free_path",
          "args": [
            "umass_path"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\nstruct cam_sim *umass_sim;\nstruct cam_path *umass_path;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\n\nStatic int\numass_cam_detach_sim()\n{\n\tif (umass_sim)\n\t\treturn(EBUSY);\t/* XXX CAM can't handle disappearing SIMs yet */\n\n\tif (umass_path) {\n\t\t/* XXX do we need to send an asynchroneous event for the SIM?\n\t\txpt_async(AC_LOST_DEVICE, umass_path, NULL);\n\t\t */\n\t\txpt_free_path(umass_path);\n\t\tumass_path = NULL;\n\t}\n\n\tif (umass_sim) {\n\t\tif (xpt_bus_deregister(cam_sim_path(umass_sim)))\n\t\t\tcam_sim_free(umass_sim, /*free_devq*/TRUE);\n\t\telse\n\t\t\treturn(EBUSY);\n\n\t\tumass_sim = NULL;\n\t}\n\n\treturn(0);\n}"
  },
  {
    "function_name": "umass_cam_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "2404-2434",
    "snippet": "Static int\numass_cam_attach(struct umass_softc *sc)\n{\n\t/* SIM already attached at module load. The device is a target on the\n\t * one SIM we registered: target device_get_unit(self).\n\t */\n\n\t/* The artificial limit UMASS_SCSIID_MAX is there because CAM expects\n\t * a limit to the number of targets that are present on a SIM.\n\t */\n\tif (device_get_unit(sc->sc_dev) > UMASS_SCSIID_MAX) {\n\t\tprintf(\"%s: Increase UMASS_SCSIID_MAX (currently %d) in %s \"\n\t\t\t\"and try again.\\n\", USBDEVNAME(sc->sc_dev),\n\t\t\tUMASS_SCSIID_MAX, __FILE__);\n\t\treturn(1);\n\t}\n\t\t\n#ifdef UMASS_DO_CAM_RESCAN\n\tif (!cold) {\n\t\t/* Notify CAM of the new device. Any failure is benign, as the\n\t\t * user can still do it by hand (camcontrol rescan <busno>).\n\t\t * Only do this if we are not booting, because CAM does a scan\n\t\t * after booting has completed, when interrupts have been\n\t\t * enabled.\n\t\t */\n\t\tumass_cam_rescan(sc);\n\t}\n#endif\n\n\treturn(0);\t/* always succesful */\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UMASS_SCSIID_MAX\t3\t/* maximum number of drives expected */",
      "#define UMASS_SCSIID_MAX\t32\t/* maximum number of drives expected */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "umass_cam_rescan",
          "args": [
            "sc"
          ],
          "line": 2429
        },
        "resolved": true,
        "details": {
          "function_name": "umass_cam_rescan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "2376-2401",
          "snippet": "Static void\numass_cam_rescan(struct umass_softc *sc)\n{\n\tstruct cam_path *path;\n\tunion ccb *ccb = malloc(sizeof(union ccb), M_USBDEV, M_WAITOK);\n\n\tmemset(ccb, 0, sizeof(union ccb));\n\n\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d: scanning bus for new device %d\\n\",\n\t\tUSBDEVNAME(sc->sc_dev),\t cam_sim_path(umass_sim),\n\t\tdevice_get_unit(sc->sc_dev), 0,\n\t\tdevice_get_unit(sc->sc_dev)));\n\n\tif (xpt_create_path(&path, xpt_periph, cam_sim_path(umass_sim),\n\t\t    device_get_unit(sc->sc_dev), 0)\n\t    != CAM_REQ_CMP)\n\t\treturn;\n\n\txpt_setup_ccb(&ccb->ccb_h, path, 5/*priority (low)*/);\n\tccb->ccb_h.func_code = XPT_SCAN_BUS;\n\tccb->ccb_h.cbfcnp = umass_cam_rescan_callback;\n\tccb->crcn.flags = CAM_FLAG_NONE;\n\txpt_action(ccb);\n\n\t/* The scan is in progress now. */\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UDMASS_SCSI\t0x00020000\t/* scsi */"
          ],
          "globals_used": [
            "struct cam_sim *umass_sim;",
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_SCSI\t0x00020000\t/* scsi */\n\nstruct cam_sim *umass_sim;\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nint s;\n\nStatic void\numass_cam_rescan(struct umass_softc *sc)\n{\n\tstruct cam_path *path;\n\tunion ccb *ccb = malloc(sizeof(union ccb), M_USBDEV, M_WAITOK);\n\n\tmemset(ccb, 0, sizeof(union ccb));\n\n\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d: scanning bus for new device %d\\n\",\n\t\tUSBDEVNAME(sc->sc_dev),\t cam_sim_path(umass_sim),\n\t\tdevice_get_unit(sc->sc_dev), 0,\n\t\tdevice_get_unit(sc->sc_dev)));\n\n\tif (xpt_create_path(&path, xpt_periph, cam_sim_path(umass_sim),\n\t\t    device_get_unit(sc->sc_dev), 0)\n\t    != CAM_REQ_CMP)\n\t\treturn;\n\n\txpt_setup_ccb(&ccb->ccb_h, path, 5/*priority (low)*/);\n\tccb->ccb_h.func_code = XPT_SCAN_BUS;\n\tccb->ccb_h.cbfcnp = umass_cam_rescan_callback;\n\tccb->crcn.flags = CAM_FLAG_NONE;\n\txpt_action(ccb);\n\n\t/* The scan is in progress now. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: Increase UMASS_SCSIID_MAX (currently %d) in %s \"\n\t\t\t\"and try again.\\n\"",
            "USBDEVNAME(sc->sc_dev)",
            "UMASS_SCSIID_MAX",
            "__FILE__"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_get_unit",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UMASS_SCSIID_MAX\t3\t/* maximum number of drives expected */\n#define UMASS_SCSIID_MAX\t32\t/* maximum number of drives expected */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nint s;\n\nStatic int\numass_cam_attach(struct umass_softc *sc)\n{\n\t/* SIM already attached at module load. The device is a target on the\n\t * one SIM we registered: target device_get_unit(self).\n\t */\n\n\t/* The artificial limit UMASS_SCSIID_MAX is there because CAM expects\n\t * a limit to the number of targets that are present on a SIM.\n\t */\n\tif (device_get_unit(sc->sc_dev) > UMASS_SCSIID_MAX) {\n\t\tprintf(\"%s: Increase UMASS_SCSIID_MAX (currently %d) in %s \"\n\t\t\t\"and try again.\\n\", USBDEVNAME(sc->sc_dev),\n\t\t\tUMASS_SCSIID_MAX, __FILE__);\n\t\treturn(1);\n\t}\n\t\t\n#ifdef UMASS_DO_CAM_RESCAN\n\tif (!cold) {\n\t\t/* Notify CAM of the new device. Any failure is benign, as the\n\t\t * user can still do it by hand (camcontrol rescan <busno>).\n\t\t * Only do this if we are not booting, because CAM does a scan\n\t\t * after booting has completed, when interrupts have been\n\t\t * enabled.\n\t\t */\n\t\tumass_cam_rescan(sc);\n\t}\n#endif\n\n\treturn(0);\t/* always succesful */\n}"
  },
  {
    "function_name": "umass_cam_rescan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "2376-2401",
    "snippet": "Static void\numass_cam_rescan(struct umass_softc *sc)\n{\n\tstruct cam_path *path;\n\tunion ccb *ccb = malloc(sizeof(union ccb), M_USBDEV, M_WAITOK);\n\n\tmemset(ccb, 0, sizeof(union ccb));\n\n\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d: scanning bus for new device %d\\n\",\n\t\tUSBDEVNAME(sc->sc_dev),\t cam_sim_path(umass_sim),\n\t\tdevice_get_unit(sc->sc_dev), 0,\n\t\tdevice_get_unit(sc->sc_dev)));\n\n\tif (xpt_create_path(&path, xpt_periph, cam_sim_path(umass_sim),\n\t\t    device_get_unit(sc->sc_dev), 0)\n\t    != CAM_REQ_CMP)\n\t\treturn;\n\n\txpt_setup_ccb(&ccb->ccb_h, path, 5/*priority (low)*/);\n\tccb->ccb_h.func_code = XPT_SCAN_BUS;\n\tccb->ccb_h.cbfcnp = umass_cam_rescan_callback;\n\tccb->crcn.flags = CAM_FLAG_NONE;\n\txpt_action(ccb);\n\n\t/* The scan is in progress now. */\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UDMASS_SCSI\t0x00020000\t/* scsi */"
    ],
    "globals_used": [
      "struct cam_sim *umass_sim;",
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xpt_action",
          "args": [
            "ccb"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_setup_ccb",
          "args": [
            "&ccb->ccb_h",
            "path",
            "5/*priority (low)*/"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_create_path",
          "args": [
            "&path",
            "xpt_periph",
            "cam_sim_path(umass_sim)",
            "device_get_unit(sc->sc_dev)",
            "0"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_get_unit",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cam_sim_path",
          "args": [
            "umass_sim"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s:%d:%d:%d: scanning bus for new device %d\\n\",\n\t\tUSBDEVNAME(sc->sc_dev),\t cam_sim_path(umass_sim),\n\t\tdevice_get_unit(sc->sc_dev), 0,\n\t\tdevice_get_unit(sc->sc_dev))"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_get_unit",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_get_unit",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cam_sim_path",
          "args": [
            "umass_sim"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ccb",
            "0",
            "sizeof(union ccb)"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(union ccb)",
            "M_USBDEV",
            "M_WAITOK"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_SCSI\t0x00020000\t/* scsi */\n\nstruct cam_sim *umass_sim;\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nint s;\n\nStatic void\numass_cam_rescan(struct umass_softc *sc)\n{\n\tstruct cam_path *path;\n\tunion ccb *ccb = malloc(sizeof(union ccb), M_USBDEV, M_WAITOK);\n\n\tmemset(ccb, 0, sizeof(union ccb));\n\n\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d: scanning bus for new device %d\\n\",\n\t\tUSBDEVNAME(sc->sc_dev),\t cam_sim_path(umass_sim),\n\t\tdevice_get_unit(sc->sc_dev), 0,\n\t\tdevice_get_unit(sc->sc_dev)));\n\n\tif (xpt_create_path(&path, xpt_periph, cam_sim_path(umass_sim),\n\t\t    device_get_unit(sc->sc_dev), 0)\n\t    != CAM_REQ_CMP)\n\t\treturn;\n\n\txpt_setup_ccb(&ccb->ccb_h, path, 5/*priority (low)*/);\n\tccb->ccb_h.func_code = XPT_SCAN_BUS;\n\tccb->ccb_h.cbfcnp = umass_cam_rescan_callback;\n\tccb->crcn.flags = CAM_FLAG_NONE;\n\txpt_action(ccb);\n\n\t/* The scan is in progress now. */\n}"
  },
  {
    "function_name": "umass_cam_rescan_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "2353-2374",
    "snippet": "Static void\numass_cam_rescan_callback(struct cam_periph *periph, union ccb *ccb)\n{\n#ifdef UMASS_DEBUG\n\tstruct umass_softc *sc = devclass_get_softc(umass_devclass,\n\t\t\t\t\t       ccb->ccb_h.target_id);\n\n\tif (ccb->ccb_h.status != CAM_REQ_CMP) {\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d: Rescan failed, 0x%04x\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\tccb->ccb_h.status));\n\t} else {\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d: Rescan succeeded, freeing resources.\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun));\n\t}\n#endif\n\n\txpt_free_path(ccb->ccb_h.path);\n\tfree(ccb, M_USBDEV);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UMASS_SCSI_BUS\t\t0",
      "#define UDMASS_SCSI\t0x00020000\t/* scsi */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "umass_bbb_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "umass_cbi_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "Static void",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ccb",
            "M_USBDEV"
          ],
          "line": 2373
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xpt_free_path",
          "args": [
            "ccb->ccb_h.path"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s:%d:%d:%d: Rescan succeeded, freeing resources.\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun)"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_SCSI",
            "(\"%s:%d:%d:%d: Rescan failed, 0x%04x\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\tccb->ccb_h.status)"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devclass_get_softc",
          "args": [
            "umass_devclass",
            "ccb->ccb_h.target_id"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UMASS_SCSI_BUS\t\t0\n#define UDMASS_SCSI\t0x00020000\t/* scsi */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\numass_bbb_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\numass_cbi_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nint s;\n\nStatic void\numass_cam_rescan_callback(struct cam_periph *periph, union ccb *ccb)\n{\n#ifdef UMASS_DEBUG\n\tstruct umass_softc *sc = devclass_get_softc(umass_devclass,\n\t\t\t\t\t       ccb->ccb_h.target_id);\n\n\tif (ccb->ccb_h.status != CAM_REQ_CMP) {\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d: Rescan failed, 0x%04x\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun,\n\t\t\tccb->ccb_h.status));\n\t} else {\n\t\tDPRINTF(UDMASS_SCSI, (\"%s:%d:%d:%d: Rescan succeeded, freeing resources.\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,\n\t\t\tccb->ccb_h.target_id, ccb->ccb_h.target_lun));\n\t}\n#endif\n\n\txpt_free_path(ccb->ccb_h.path);\n\tfree(ccb, M_USBDEV);\n}"
  },
  {
    "function_name": "umass_cam_attach_sim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "2309-2345",
    "snippet": "Static int\numass_cam_attach_sim()\n{\n\tstruct cam_devq *devq;\t\t/* Per device Queue */\n\n\t/* A HBA is attached to the CAM layer.\n\t *\n\t * The CAM layer will then after a while start probing for\n\t * devices on the bus. The number of devices is limitted to one.\n\t */\n\n\t/* SCSI transparent command set */\n\n\tdevq = cam_simq_alloc(1 /*maximum openings*/);\n\tif (devq == NULL)\n\t\treturn(ENOMEM);\n\n\tumass_sim = cam_sim_alloc(umass_cam_action, umass_cam_poll, DEVNAME,\n\t\t\t\tNULL /*priv*/, 0 /*unit number*/,\n\t\t\t\t1 /*maximum device openings*/,\n\t\t\t\t0 /*maximum tagged device openings*/,\n\t\t\t\tdevq);\n\tif (umass_sim == NULL) {\n\t\tcam_simq_free(devq);\n\t\treturn(ENOMEM);\n\t}\n\n\tif(xpt_bus_register(umass_sim, 0) != CAM_SUCCESS)\n\t\treturn(ENOMEM);\n\n\tif (xpt_create_path(&umass_path, NULL, cam_sim_path(umass_sim),\n\t\t\t    UMASS_SCSIID_HOST, 0)\n\t    != CAM_REQ_CMP)\n\t\treturn(ENOMEM);\n\n\treturn(0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UMASS_SCSIID_HOST\t0x00",
      "#define UMASS_SCSIID_HOST\tUMASS_SCSIID_MAX",
      "#define DEVNAME\t\t\"umass\""
    ],
    "globals_used": [
      "struct cam_sim *umass_sim;",
      "struct cam_path *umass_path;",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "umass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "umass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
      "Static void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xpt_create_path",
          "args": [
            "&umass_path",
            "NULL",
            "cam_sim_path(umass_sim)",
            "UMASS_SCSIID_HOST",
            "0"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cam_sim_path",
          "args": [
            "umass_sim"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpt_bus_register",
          "args": [
            "umass_sim",
            "0"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cam_simq_free",
          "args": [
            "devq"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cam_sim_alloc",
          "args": [
            "umass_cam_action",
            "umass_cam_poll",
            "DEVNAME",
            "NULL/*priv*/",
            "0/*unit number*/",
            "1/*maximum device openings*/",
            "0/*maximum tagged device openings*/",
            "devq"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cam_simq_alloc",
          "args": [
            "1/*maximum openings*/"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UMASS_SCSIID_HOST\t0x00\n#define UMASS_SCSIID_HOST\tUMASS_SCSIID_MAX\n#define DEVNAME\t\t\"umass\"\n\nstruct cam_sim *umass_sim;\nstruct cam_path *umass_path;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\numass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\numass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\n\nStatic int\numass_cam_attach_sim()\n{\n\tstruct cam_devq *devq;\t\t/* Per device Queue */\n\n\t/* A HBA is attached to the CAM layer.\n\t *\n\t * The CAM layer will then after a while start probing for\n\t * devices on the bus. The number of devices is limitted to one.\n\t */\n\n\t/* SCSI transparent command set */\n\n\tdevq = cam_simq_alloc(1 /*maximum openings*/);\n\tif (devq == NULL)\n\t\treturn(ENOMEM);\n\n\tumass_sim = cam_sim_alloc(umass_cam_action, umass_cam_poll, DEVNAME,\n\t\t\t\tNULL /*priv*/, 0 /*unit number*/,\n\t\t\t\t1 /*maximum device openings*/,\n\t\t\t\t0 /*maximum tagged device openings*/,\n\t\t\t\tdevq);\n\tif (umass_sim == NULL) {\n\t\tcam_simq_free(devq);\n\t\treturn(ENOMEM);\n\t}\n\n\tif(xpt_bus_register(umass_sim, 0) != CAM_SUCCESS)\n\t\treturn(ENOMEM);\n\n\tif (xpt_create_path(&umass_path, NULL, cam_sim_path(umass_sim),\n\t\t\t    UMASS_SCSIID_HOST, 0)\n\t    != CAM_REQ_CMP)\n\t\treturn(ENOMEM);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "umass_bbb_get_max_lun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "2245-2300",
    "snippet": "usbd_status\numass_bbb_get_max_lun(struct umass_softc *sc, u_int8_t *maxlun)\n{\n\tusbd_device_handle dev;\n\tusb_device_request_t req;\n\tusbd_status err;\n\tusb_interface_descriptor_t *id;\n\n\t*maxlun = 0;\t\t/* Default to 0. */\n\n\tDPRINTF(UDMASS_BBB, (\"%s: Get Max Lun\\n\", USBDEVNAME(sc->sc_dev)));\n\n\tusbd_interface2device_handle(sc->iface, &dev);\n\tid = usbd_get_interface_descriptor(sc->iface);\n\n\t/* The Get Max Lun command is a class-specific request. */\n\treq.bmRequestType = UT_READ_CLASS_INTERFACE;\n\treq.bRequest = UR_BBB_GET_MAX_LUN;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, id->bInterfaceNumber);\n\tUSETW(req.wLength, 1);\n\n\terr = usbd_do_request(dev, &req, maxlun);\n\tswitch (err) {\n\tcase USBD_NORMAL_COMPLETION:\n\t\tDPRINTF(UDMASS_BBB, (\"%s: Max Lun %d\\n\",\n\t\t    USBDEVNAME(sc->sc_dev), *maxlun));\n\t\tbreak;\n\n\tcase USBD_STALLED:\n\t\t/*\n\t\t * Device doesn't support Get Max Lun request.\n\t\t */\n\t\terr = USBD_NORMAL_COMPLETION;\n\t\tDPRINTF(UDMASS_BBB, (\"%s: Get Max Lun not supported\\n\",\n\t\t    USBDEVNAME(sc->sc_dev)));\n\t\tbreak;\n\n\tcase USBD_SHORT_XFER:\n\t\t/*\n\t\t * XXX This must mean Get Max Lun is not supported, too!\n\t\t */\n\t\terr = USBD_NORMAL_COMPLETION;\n\t\tDPRINTF(UDMASS_BBB, (\"%s: Get Max Lun SHORT_XFER\\n\",\n\t\t    USBDEVNAME(sc->sc_dev)));\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: Get Max Lun failed: %s\\n\",\n\t\t    USBDEVNAME(sc->sc_dev), usbd_errstr(err));\n\t\t/* XXX Should we port_reset the device? */\n\t\tbreak;\n\t}\n\n\treturn (err);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define\tUR_BBB_GET_MAX_LUN\t0xfe",
      "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
    ],
    "globals_used": [
      "__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "umass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static usbd_status",
      "Static usbd_status",
      "umass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));",
      "usbd_status umass_bbb_get_max_lun",
      "umass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: Get Max Lun failed: %s\\n\"",
            "USBDEVNAME(sc->sc_dev)",
            "usbd_errstr(err)"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_BBB",
            "(\"%s: Get Max Lun SHORT_XFER\\n\",\n\t\t    USBDEVNAME(sc->sc_dev))"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_BBB",
            "(\"%s: Get Max Lun not supported\\n\",\n\t\t    USBDEVNAME(sc->sc_dev))"
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_BBB",
            "(\"%s: Max Lun %d\\n\",\n\t\t    USBDEVNAME(sc->sc_dev), *maxlun)"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_do_request",
          "args": [
            "dev",
            "&req",
            "maxlun"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_do_request_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1059-1079",
          "snippet": "usbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "1"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "id->bInterfaceNumber"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "0"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_interface_descriptor",
          "args": [
            "sc->iface"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_interface2device_handle",
          "args": [
            "sc->iface",
            "&dev"
          ],
          "line": 2257
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_interface2device_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "658-665",
          "snippet": "usbd_status \nusbd_interface2device_handle(iface, dev)\n\tusbd_interface_handle iface;\n\tusbd_device_handle *dev;\n{\n\t*dev = iface->device;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nusbd_status \nusbd_interface2device_handle(iface, dev)\n\tusbd_interface_handle iface;\n\tusbd_device_handle *dev;\n{\n\t*dev = iface->device;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_BBB",
            "(\"%s: Get Max Lun\\n\", USBDEVNAME(sc->sc_dev))"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define\tUR_BBB_GET_MAX_LUN\t0xfe\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\n__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\numass_disco\t\t__P((struct umass_softc *sc));\numass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic usbd_status;\nStatic usbd_status;\numass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));\nusbd_status umass_bbb_get_max_lun;\numass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nint s;\n\nusbd_status\numass_bbb_get_max_lun(struct umass_softc *sc, u_int8_t *maxlun)\n{\n\tusbd_device_handle dev;\n\tusb_device_request_t req;\n\tusbd_status err;\n\tusb_interface_descriptor_t *id;\n\n\t*maxlun = 0;\t\t/* Default to 0. */\n\n\tDPRINTF(UDMASS_BBB, (\"%s: Get Max Lun\\n\", USBDEVNAME(sc->sc_dev)));\n\n\tusbd_interface2device_handle(sc->iface, &dev);\n\tid = usbd_get_interface_descriptor(sc->iface);\n\n\t/* The Get Max Lun command is a class-specific request. */\n\treq.bmRequestType = UT_READ_CLASS_INTERFACE;\n\treq.bRequest = UR_BBB_GET_MAX_LUN;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, id->bInterfaceNumber);\n\tUSETW(req.wLength, 1);\n\n\terr = usbd_do_request(dev, &req, maxlun);\n\tswitch (err) {\n\tcase USBD_NORMAL_COMPLETION:\n\t\tDPRINTF(UDMASS_BBB, (\"%s: Max Lun %d\\n\",\n\t\t    USBDEVNAME(sc->sc_dev), *maxlun));\n\t\tbreak;\n\n\tcase USBD_STALLED:\n\t\t/*\n\t\t * Device doesn't support Get Max Lun request.\n\t\t */\n\t\terr = USBD_NORMAL_COMPLETION;\n\t\tDPRINTF(UDMASS_BBB, (\"%s: Get Max Lun not supported\\n\",\n\t\t    USBDEVNAME(sc->sc_dev)));\n\t\tbreak;\n\n\tcase USBD_SHORT_XFER:\n\t\t/*\n\t\t * XXX This must mean Get Max Lun is not supported, too!\n\t\t */\n\t\terr = USBD_NORMAL_COMPLETION;\n\t\tDPRINTF(UDMASS_BBB, (\"%s: Get Max Lun SHORT_XFER\\n\",\n\t\t    USBDEVNAME(sc->sc_dev)));\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: Get Max Lun failed: %s\\n\",\n\t\t    USBDEVNAME(sc->sc_dev), usbd_errstr(err));\n\t\t/* XXX Should we port_reset the device? */\n\t\tbreak;\n\t}\n\n\treturn (err);\n}"
  },
  {
    "function_name": "umass_cbi_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "1969-2243",
    "snippet": "Static void\numass_cbi_state(usbd_xfer_handle xfer, usbd_private_handle priv,\n\t\tusbd_status err)\n{\n\tstruct umass_softc *sc = (struct umass_softc *) priv;\n\n\tKASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),\n\t\t(\"sc->proto == 0x%02x wrong for umass_cbi_state\\n\", sc->proto));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\t/*\n\t * State handling for CBI transfers.\n\t */\n\n\tDPRINTF(UDMASS_CBI, (\"%s: Handling CBI state %d (%s), xfer=%p, %s\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), sc->transfer_state,\n\t\tstates[sc->transfer_state], xfer, usbd_errstr(err)));\n\n\tswitch (sc->transfer_state) {\n\n\t/***** CBI Transfer *****/\n\tcase TSTATE_CBI_COMMAND:\n\t\tif (err == USBD_STALLED) {\n\t\t\tDPRINTF(UDMASS_CBI, (\"%s: Command Transport failed\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev)));\n\t\t\t/* Status transport by control pipe (section 2.3.2.1).\n\t\t\t * The command contained in the command block failed.\n\t\t\t *\n                         * The control pipe has already been unstalled by the\n                         * USB stack.\n                         * Section 2.4.3.1.1 states that the bulk in endpoints\n                         * should not stalled at this point.\n\t\t\t */\n\n\t\t\tsc->transfer_state = TSTATE_IDLE;\n\t\t\tsc->transfer_cb(sc, sc->transfer_priv,\n\t\t\t\t\tsc->transfer_datalen,\n\t\t\t\t\tSTATUS_CMD_FAILED);\n\n\t\t\treturn;\n\t\t} else if (err) {\n\t\t\tDPRINTF(UDMASS_CBI, (\"%s: failed to send ADSC\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev)));\n\t\t\tumass_cbi_reset(sc, STATUS_WIRE_FAILED);\n\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tsc->transfer_state = TSTATE_CBI_DATA;\n\t\tif (sc->transfer_dir == DIR_IN) {\n\t\t\tif (umass_setup_transfer(sc, sc->bulkin_pipe,\n\t\t\t\t\tsc->transfer_data, sc->transfer_datalen,\n\t\t\t\t\tUSBD_SHORT_XFER_OK | USBD_NO_COPY,\n\t\t\t\t\tsc->transfer_xfer[XFER_CBI_DATA]))\n\t\t\t\tumass_cbi_reset(sc, STATUS_WIRE_FAILED);\n\n\t\t} else if (sc->transfer_dir == DIR_OUT) {\n\t\t\tmemcpy(sc->data_buffer, sc->transfer_data, \n\t\t\t       sc->transfer_datalen);\n\t\t\tif (umass_setup_transfer(sc, sc->bulkout_pipe,\n\t\t\t\t\tsc->transfer_data, sc->transfer_datalen,\n\t\t\t\t\tUSBD_NO_COPY,/* fixed length transfer */\n\t\t\t\t\tsc->transfer_xfer[XFER_CBI_DATA]))\n\t\t\t\tumass_cbi_reset(sc, STATUS_WIRE_FAILED);\n\n\t\t} else if (sc->proto & PROTO_CBI_I) {\n\t\t\tDPRINTF(UDMASS_CBI, (\"%s: no data phase\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev)));\n\t\t\tsc->transfer_state = TSTATE_CBI_STATUS;\n\t\t\tif (umass_setup_transfer(sc, sc->intrin_pipe,\n\t\t\t\t\t&sc->sbl, sizeof(sc->sbl),\n\t\t\t\t\t0,\t/* fixed length transfer */\n\t\t\t\t\tsc->transfer_xfer[XFER_CBI_STATUS])){\n\t\t\t\tumass_cbi_reset(sc, STATUS_WIRE_FAILED);\n\t\t\t}\n\t\t} else {\n\t\t\tDPRINTF(UDMASS_CBI, (\"%s: no data phase\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev)));\n\t\t\t/* No command completion interrupt. Request\n\t\t\t * sense data.\n\t\t\t */\n\t\t\tsc->transfer_state = TSTATE_IDLE;\n\t\t\tsc->transfer_cb(sc, sc->transfer_priv,\n\t\t\t       0, STATUS_CMD_UNKNOWN);\n\t\t}\n\n\t\treturn;\n\n\tcase TSTATE_CBI_DATA:\n\t\t/* retrieve the length of the transfer that was done */\n\t\tusbd_get_xfer_status(xfer,NULL,NULL,&sc->transfer_actlen,NULL);\n\t\tDPRINTF(UDMASS_CBI, (\"%s: CBI_DATA actlen=%d\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), sc->transfer_actlen));\n\n\t\tif (err) {\n\t\t\tDPRINTF(UDMASS_CBI, (\"%s: Data-%s %db failed, \"\n\t\t\t\t\"%s\\n\", USBDEVNAME(sc->sc_dev),\n\t\t\t\t(sc->transfer_dir == DIR_IN?\"in\":\"out\"),\n\t\t\t\tsc->transfer_datalen,usbd_errstr(err)));\n\n\t\t\tif (err == USBD_STALLED) {\n\t\t\t\tumass_clear_endpoint_stall(sc,\n\t\t\t\t\tsc->bulkin, sc->bulkin_pipe,\n\t\t\t\t\tTSTATE_CBI_DCLEAR,\n\t\t\t\t\tsc->transfer_xfer[XFER_CBI_DCLEAR]);\n\t\t\t} else {\n\t\t\t\tumass_cbi_reset(sc, STATUS_WIRE_FAILED);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (sc->transfer_dir == DIR_IN)\n\t\t\tmemcpy(sc->transfer_data, sc->data_buffer,\n\t\t\t       sc->transfer_actlen);\n\n\t\tDIF(UDMASS_CBI, if (sc->transfer_dir == DIR_IN)\n\t\t\t\t\tumass_dump_buffer(sc, sc->transfer_data,\n\t\t\t\t\t\tsc->transfer_actlen, 48));\n\n\t\tif (sc->proto & PROTO_CBI_I) {\n\t\t\tsc->transfer_state = TSTATE_CBI_STATUS;\n\t\t\tmemset(&sc->sbl, 0, sizeof(sc->sbl));\n\t\t\tif (umass_setup_transfer(sc, sc->intrin_pipe,\n\t\t\t\t    &sc->sbl, sizeof(sc->sbl),\n\t\t\t\t    0,\t/* fixed length transfer */\n\t\t\t\t    sc->transfer_xfer[XFER_CBI_STATUS])){\n\t\t\t\tumass_cbi_reset(sc, STATUS_WIRE_FAILED);\n\t\t\t}\n\t\t} else {\n\t\t\t/* No command completion interrupt. Request\n\t\t\t * sense to get status of command.\n\t\t\t */\n\t\t\tsc->transfer_state = TSTATE_IDLE;\n\t\t\tsc->transfer_cb(sc, sc->transfer_priv,\n\t\t\t\tsc->transfer_datalen - sc->transfer_actlen,\n\t\t\t\tSTATUS_CMD_UNKNOWN);\n\t\t}\n\t\treturn;\n\n\tcase TSTATE_CBI_STATUS:\n\t\tif (err) {\n\t\t\tDPRINTF(UDMASS_CBI, (\"%s: Status Transport failed\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev)));\n\t\t\t/* Status transport by interrupt pipe (section 2.3.2.2).\n\t\t\t */\n\n\t\t\tif (err == USBD_STALLED) {\n\t\t\t\tumass_clear_endpoint_stall(sc,\n\t\t\t\t\tsc->intrin, sc->intrin_pipe,\n\t\t\t\t\tTSTATE_CBI_SCLEAR,\n\t\t\t\t\tsc->transfer_xfer[XFER_CBI_SCLEAR]);\n\t\t\t} else {\n\t\t\t\tumass_cbi_reset(sc, STATUS_WIRE_FAILED);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t/* Dissect the information in the buffer */\n\n\t\tif (sc->proto & PROTO_UFI) {\n\t\t\tint status;\n\t\t\t\n\t\t\t/* Section 3.4.3.1.3 specifies that the UFI command\n\t\t\t * protocol returns an ASC and ASCQ in the interrupt\n\t\t\t * data block.\n\t\t\t */\n\n\t\t\tDPRINTF(UDMASS_CBI, (\"%s: UFI CCI, ASC = 0x%02x, \"\n\t\t\t\t\"ASCQ = 0x%02x\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tsc->sbl.ufi.asc, sc->sbl.ufi.ascq));\n\n\t\t\tif (sc->sbl.ufi.asc == 0 && sc->sbl.ufi.ascq == 0)\n\t\t\t\tstatus = STATUS_CMD_OK;\n\t\t\telse\n\t\t\t\tstatus = STATUS_CMD_FAILED;\n\n\t\t\t/* No sense, command successfull */\n\t\t} else {\n\t\t\t/* Command Interrupt Data Block */\n\t\t\tDPRINTF(UDMASS_CBI, (\"%s: type=0x%02x, value=0x%02x\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tsc->sbl.common.type, sc->sbl.common.value));\n\n\t\t\tif (sc->sbl.common.type == IDB_TYPE_CCI) {\n\t\t\t\tint err;\n\n\t\t\t\tif ((sc->sbl.common.value&IDB_VALUE_STATUS_MASK)\n\t\t\t\t\t\t\t== IDB_VALUE_PASS) {\n\t\t\t\t\terr = STATUS_CMD_OK;\n\t\t\t\t} else if ((sc->sbl.common.value & IDB_VALUE_STATUS_MASK)\n\t\t\t\t\t\t\t== IDB_VALUE_FAIL ||\n\t\t\t\t\t   (sc->sbl.common.value & IDB_VALUE_STATUS_MASK)\n\t\t\t\t\t\t== IDB_VALUE_PERSISTENT) {\n\t\t\t\t\terr = STATUS_CMD_FAILED;\n\t\t\t\t} else {\n\t\t\t\t\terr = STATUS_WIRE_FAILED;\n\t\t\t\t}\n\n\t\t\t\tsc->transfer_state = TSTATE_IDLE;\n\t\t\t\tsc->transfer_cb(sc, sc->transfer_priv,\n\t\t\t\t\t\tsc->transfer_datalen,\n\t\t\t\t\t\terr);\n\t\t\t}\n\t\t}\n\t\treturn;\n\n\tcase TSTATE_CBI_DCLEAR:\n\t\tif (err) {\t/* should not occur */\n\t\t\tprintf(\"%s: CBI bulk-in/out stall clear failed, %s\\n\",\n\t\t\t       USBDEVNAME(sc->sc_dev), usbd_errstr(err));\n\t\t\tumass_cbi_reset(sc, STATUS_WIRE_FAILED);\n\t\t}\n\n\t\tsc->transfer_state = TSTATE_IDLE;\n\t\tsc->transfer_cb(sc, sc->transfer_priv,\n\t\t\t\tsc->transfer_datalen,\n\t\t\t\tSTATUS_CMD_FAILED);\n\t\treturn;\n\n\tcase TSTATE_CBI_SCLEAR:\n\t\tif (err)\t/* should not occur */\n\t\t\tprintf(\"%s: CBI intr-in stall clear failed, %s\\n\",\n\t\t\t       USBDEVNAME(sc->sc_dev), usbd_errstr(err));\n\n\t\t/* Something really bad is going on. Reset the device */\n\t\tumass_cbi_reset(sc, STATUS_CMD_FAILED);\n\t\treturn;\n\n\t/***** CBI Reset *****/\n\tcase TSTATE_CBI_RESET1:\n\t\tif (err)\n\t\t\tprintf(\"%s: CBI reset failed, %s\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev), usbd_errstr(err));\n\n\t\tumass_clear_endpoint_stall(sc,\n\t\t\tsc->bulkin, sc->bulkin_pipe, TSTATE_CBI_RESET2,\n\t\t\tsc->transfer_xfer[XFER_CBI_RESET2]);\n\n\t\treturn;\n\tcase TSTATE_CBI_RESET2:\n\t\tif (err)\t/* should not occur */\n\t\t\tprintf(\"%s: CBI bulk-in stall clear failed, %s\\n\",\n\t\t\t       USBDEVNAME(sc->sc_dev), usbd_errstr(err));\n\t\t\t/* no error recovery, otherwise we end up in a loop */\n\n\t\tumass_clear_endpoint_stall(sc,\n\t\t\tsc->bulkout, sc->bulkout_pipe, TSTATE_CBI_RESET3,\n\t\t\tsc->transfer_xfer[XFER_CBI_RESET3]);\n\n\t\treturn;\n\tcase TSTATE_CBI_RESET3:\n\t\tif (err)\t/* should not occur */\n\t\t\tprintf(\"%s: CBI bulk-out stall clear failed, %s\\n\",\n\t\t\t       USBDEVNAME(sc->sc_dev), usbd_errstr(err));\n\t\t\t/* no error recovery, otherwise we end up in a loop */\n\n\t\tsc->transfer_state = TSTATE_IDLE;\n\t\tif (sc->transfer_priv) {\n\t\t\tsc->transfer_cb(sc, sc->transfer_priv,\n\t\t\t\t\tsc->transfer_datalen,\n\t\t\t\t\tsc->transfer_status);\n\t\t}\n\n\t\treturn;\n\n\n\t/***** Default *****/\n\tdefault:\n\t\tpanic(\"%s: Unknown state %d\\n\",\n\t\t      USBDEVNAME(sc->sc_dev), sc->transfer_state);\n\t}\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define STATUS_WIRE_FAILED\t3\t/* couldn't even get command across */",
      "#define STATUS_CMD_FAILED\t2\t/* transfer was ok, command failed */",
      "#define STATUS_CMD_UNKNOWN\t1\t/* will have to fetch sense */",
      "#define STATUS_CMD_OK\t\t0\t/* everything ok */",
      "#define IDB_VALUE_STATUS_MASK\t0x03",
      "#define IDB_VALUE_PERSISTENT\t0x03",
      "#define IDB_VALUE_FAIL\t\t0x01",
      "#define IDB_VALUE_PASS\t\t0x00",
      "#define IDB_TYPE_CCI\t\t0x00",
      "#define DIR_OUT\t\t2",
      "#define DIR_IN\t\t1",
      "#define UDMASS_CBI\t0x00400000\t/* CBI transfers */"
    ],
    "globals_used": [
      "__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static usbd_status",
      "umass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));",
      "Static usbd_status",
      "umass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));",
      "Static void",
      "umass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));",
      "Static void",
      "umass_bbb_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "umass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
      "Static void",
      "umass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));",
      "Static int",
      "umass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));",
      "Static void",
      "umass_cbi_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "umass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
      "Static void",
      "umass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: Unknown state %d\\n\"",
            "USBDEVNAME(sc->sc_dev)",
            "sc->transfer_state"
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->transfer_cb",
          "args": [
            "sc",
            "sc->transfer_priv",
            "sc->transfer_datalen",
            "sc->transfer_status"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: CBI bulk-out stall clear failed, %s\\n\"",
            "USBDEVNAME(sc->sc_dev)",
            "usbd_errstr(err)"
          ],
          "line": 2224
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umass_clear_endpoint_stall",
          "args": [
            "sc",
            "sc->bulkout",
            "sc->bulkout_pipe",
            "TSTATE_CBI_RESET3",
            "sc->transfer_xfer[XFER_CBI_RESET3]"
          ],
          "line": 2217
        },
        "resolved": true,
        "details": {
          "function_name": "umass_clear_endpoint_stall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "1337-1362",
          "snippet": "Static void\numass_clear_endpoint_stall(struct umass_softc *sc,\n\tu_int8_t endpt, usbd_pipe_handle pipe,\n\tint state, usbd_xfer_handle xfer)\n{\n\tusbd_device_handle dev;\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\tDPRINTF(UDMASS_BBB, (\"%s: Clear endpoint 0x%02x stall\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), endpt));\n\n\tusbd_interface2device_handle(sc->iface, &dev);\n\n\tsc->transfer_state = state;\n\n\tusbd_clear_endpoint_toggle(pipe);\n\n\tsc->request.bmRequestType = UT_WRITE_ENDPOINT;\n\tsc->request.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(sc->request.wValue, UF_ENDPOINT_HALT);\n\tUSETW(sc->request.wIndex, endpt);\n\tUSETW(sc->request.wLength, 0);\n\tumass_setup_ctrl_transfer(sc, dev, &sc->request, NULL, 0, 0, xfer);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
          ],
          "globals_used": [
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "umass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "umass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));",
            "umass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));",
            "Static void",
            "umass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "umass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\numass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\numass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));\numass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\numass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic int;\numass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nint s;\n\nStatic void\numass_clear_endpoint_stall(struct umass_softc *sc,\n\tu_int8_t endpt, usbd_pipe_handle pipe,\n\tint state, usbd_xfer_handle xfer)\n{\n\tusbd_device_handle dev;\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\tDPRINTF(UDMASS_BBB, (\"%s: Clear endpoint 0x%02x stall\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), endpt));\n\n\tusbd_interface2device_handle(sc->iface, &dev);\n\n\tsc->transfer_state = state;\n\n\tusbd_clear_endpoint_toggle(pipe);\n\n\tsc->request.bmRequestType = UT_WRITE_ENDPOINT;\n\tsc->request.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(sc->request.wValue, UF_ENDPOINT_HALT);\n\tUSETW(sc->request.wIndex, endpt);\n\tUSETW(sc->request.wLength, 0);\n\tumass_setup_ctrl_transfer(sc, dev, &sc->request, NULL, 0, 0, xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umass_cbi_reset",
          "args": [
            "sc",
            "STATUS_CMD_FAILED"
          ],
          "line": 2197
        },
        "resolved": true,
        "details": {
          "function_name": "umass_cbi_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "1862-1911",
          "snippet": "Static void\numass_cbi_reset(struct umass_softc *sc, int status)\n{\n\tint i;\n#\tdefine SEND_DIAGNOSTIC_CMDLEN\t12\n\n\tKASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),\n\t\t(\"sc->proto == 0x%02x wrong for umass_cbi_reset\\n\",sc->proto));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\t/*\n\t * Command Block Reset Protocol\n\t * \n\t * First send a reset request to the device. Then clear\n\t * any possibly stalled bulk endpoints.\n\n\t * This is done in 3 steps, states:\n\t * TSTATE_CBI_RESET1\n\t * TSTATE_CBI_RESET2\n\t * TSTATE_CBI_RESET3\n\t *\n\t * If the reset doesn't succeed, the device should be port reset.\n\t */\n\n\tDPRINTF(UDMASS_CBI, (\"%s: CBI Reset\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n\t\n\tKASSERT(sizeof(sc->cbl) >= SEND_DIAGNOSTIC_CMDLEN,\n\t\t(\"%s: CBL struct is too small (%d < %d)\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\tsizeof(sc->cbl), SEND_DIAGNOSTIC_CMDLEN));\n\n\tsc->transfer_state = TSTATE_CBI_RESET1;\n\tsc->transfer_status = status;\n\n\t/* The 0x1d code is the SEND DIAGNOSTIC command. To distingiush between\n\t * the two the last 10 bytes of the cbl is filled with 0xff (section\n\t * 2.2 of the CBI spec).\n\t */\n\tsc->cbl[0] = 0x1d;\t/* Command Block Reset */\n\tsc->cbl[1] = 0x04;\n\tfor (i = 2; i < SEND_DIAGNOSTIC_CMDLEN; i++)\n\t\tsc->cbl[i] = 0xff;\n\n\tumass_cbi_adsc(sc, sc->cbl, SEND_DIAGNOSTIC_CMDLEN,\n\t\t       sc->transfer_xfer[XFER_CBI_RESET1]);\n\t/* XXX if the command fails we should reset the port on the bub */\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UDMASS_CBI\t0x00400000\t/* CBI transfers */"
          ],
          "globals_used": [
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "Static void",
            "Static void",
            "umass_bbb_reset\t__P((struct umass_softc *sc, int status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "umass_cbi_reset\t__P((struct umass_softc *sc, int status));",
            "Static void",
            "Static void",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_CBI\t0x00400000\t/* CBI transfers */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\numass_bbb_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\numass_cbi_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nint s;\n\nStatic void\numass_cbi_reset(struct umass_softc *sc, int status)\n{\n\tint i;\n#\tdefine SEND_DIAGNOSTIC_CMDLEN\t12\n\n\tKASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),\n\t\t(\"sc->proto == 0x%02x wrong for umass_cbi_reset\\n\",sc->proto));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\t/*\n\t * Command Block Reset Protocol\n\t * \n\t * First send a reset request to the device. Then clear\n\t * any possibly stalled bulk endpoints.\n\n\t * This is done in 3 steps, states:\n\t * TSTATE_CBI_RESET1\n\t * TSTATE_CBI_RESET2\n\t * TSTATE_CBI_RESET3\n\t *\n\t * If the reset doesn't succeed, the device should be port reset.\n\t */\n\n\tDPRINTF(UDMASS_CBI, (\"%s: CBI Reset\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n\t\n\tKASSERT(sizeof(sc->cbl) >= SEND_DIAGNOSTIC_CMDLEN,\n\t\t(\"%s: CBL struct is too small (%d < %d)\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\tsizeof(sc->cbl), SEND_DIAGNOSTIC_CMDLEN));\n\n\tsc->transfer_state = TSTATE_CBI_RESET1;\n\tsc->transfer_status = status;\n\n\t/* The 0x1d code is the SEND DIAGNOSTIC command. To distingiush between\n\t * the two the last 10 bytes of the cbl is filled with 0xff (section\n\t * 2.2 of the CBI spec).\n\t */\n\tsc->cbl[0] = 0x1d;\t/* Command Block Reset */\n\tsc->cbl[1] = 0x04;\n\tfor (i = 2; i < SEND_DIAGNOSTIC_CMDLEN; i++)\n\t\tsc->cbl[i] = 0xff;\n\n\tumass_cbi_adsc(sc, sc->cbl, SEND_DIAGNOSTIC_CMDLEN,\n\t\t       sc->transfer_xfer[XFER_CBI_RESET1]);\n\t/* XXX if the command fails we should reset the port on the bub */\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->transfer_cb",
          "args": [
            "sc",
            "sc->transfer_priv",
            "sc->transfer_datalen",
            "STATUS_CMD_FAILED"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->transfer_cb",
          "args": [
            "sc",
            "sc->transfer_priv",
            "sc->transfer_datalen",
            "err"
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_CBI",
            "(\"%s: type=0x%02x, value=0x%02x\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tsc->sbl.common.type, sc->sbl.common.value)"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_CBI",
            "(\"%s: UFI CCI, ASC = 0x%02x, \"\n\t\t\t\t\"ASCQ = 0x%02x\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tsc->sbl.ufi.asc, sc->sbl.ufi.ascq)"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_CBI",
            "(\"%s: Status Transport failed\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev))"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->transfer_cb",
          "args": [
            "sc",
            "sc->transfer_priv",
            "sc->transfer_datalen - sc->transfer_actlen",
            "STATUS_CMD_UNKNOWN"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umass_setup_transfer",
          "args": [
            "sc",
            "sc->intrin_pipe",
            "&sc->sbl",
            "sizeof(sc->sbl)",
            "0",
            "/* fixed length transfer */sc->transfer_xfer[XFER_CBI_STATUS]"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "umass_setup_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "1279-1305",
          "snippet": "Static usbd_status\numass_setup_transfer(struct umass_softc *sc, usbd_pipe_handle pipe,\n\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\tusbd_xfer_handle xfer)\n{\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\t/* Initialiase a USB transfer and then schedule it */\n\n\tusbd_setup_xfer(xfer, pipe, (void *)sc, buffer, buflen,\n\t    flags | sc->sc_xfer_flags, sc->timeout, sc->state);\n\n\terr = usbd_transfer(xfer);\n\tDPRINTF(UDMASS_XFER,(\"%s: start xfer buffer=%p buflen=%d flags=0x%x \"\n\t    \"timeout=%d\\n\", USBDEVNAME(sc->sc_dev),\n\t    buffer, buflen, flags | sc->sc_xfer_flags, sc->timeout));\n\tif (err && err != USBD_IN_PROGRESS) {\n\t\tDPRINTF(UDMASS_BBB, (\"%s: failed to setup transfer, %s\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), usbd_errstr(err)));\n\t\treturn (err);\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UDMASS_XFER\t0x40000000\t/* all transfers */",
            "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
          ],
          "globals_used": [
            "__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "Static usbd_status",
            "umass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));",
            "Static usbd_status",
            "umass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));",
            "Static void",
            "umass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "umass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));",
            "Static int",
            "umass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "umass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_XFER\t0x40000000\t/* all transfers */\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\n__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic usbd_status;\numass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic usbd_status;\numass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\numass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\numass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));\nStatic int;\numass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\numass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nint s;\n\nStatic usbd_status\numass_setup_transfer(struct umass_softc *sc, usbd_pipe_handle pipe,\n\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\tusbd_xfer_handle xfer)\n{\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\t/* Initialiase a USB transfer and then schedule it */\n\n\tusbd_setup_xfer(xfer, pipe, (void *)sc, buffer, buflen,\n\t    flags | sc->sc_xfer_flags, sc->timeout, sc->state);\n\n\terr = usbd_transfer(xfer);\n\tDPRINTF(UDMASS_XFER,(\"%s: start xfer buffer=%p buflen=%d flags=0x%x \"\n\t    \"timeout=%d\\n\", USBDEVNAME(sc->sc_dev),\n\t    buffer, buflen, flags | sc->sc_xfer_flags, sc->timeout));\n\tif (err && err != USBD_IN_PROGRESS) {\n\t\tDPRINTF(UDMASS_BBB, (\"%s: failed to setup transfer, %s\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), usbd_errstr(err)));\n\t\treturn (err);\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sc->sbl",
            "0",
            "sizeof(sc->sbl)"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIF",
          "args": [
            "UDMASS_CBI",
            "if (sc->transfer_dir == DIR_IN)umass_dump_buffer(sc, sc->transfer_data,\n\t\t\t\t\t\tsc->transfer_actlen, 48)"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umass_dump_buffer",
          "args": [
            "sc",
            "sc->transfer_data",
            "sc->transfer_actlen",
            "48"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "umass_dump_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "3041-3067",
          "snippet": "Static void\numass_dump_buffer(struct umass_softc *sc, u_int8_t *buffer, int buflen,\n\t\t  int printlen)\n{\n\tint i, j;\n\tchar s1[40];\n\tchar s2[40];\n\tchar s3[5];\n\n\ts1[0] = '\\0';\n\ts3[0] = '\\0';\n\n\tsprintf(s2, \" buffer=%p, buflen=%d\", buffer, buflen);\n\tfor (i = 0; i < buflen && i < printlen; i++) {\n\t\tj = i % 16;\n\t\tif (j == 0 && i != 0) {\n\t\t\tDPRINTF(UDMASS_GEN, (\"%s: 0x %s%s\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev), s1, s2));\n\t\t\ts2[0] = '\\0';\n\t\t}\n\t\tsprintf(&s1[j*2], \"%02x\", buffer[i] & 0xff);\n\t}\n\tif (buflen > printlen)\n\t\tsprintf(s3, \" ...\");\n\tDPRINTF(UDMASS_GEN, (\"%s: 0x %s%s%s\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), s1, s2, s3));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UDMASS_GEN\t0x00010000\t/* general */"
          ],
          "globals_used": [
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_GEN\t0x00010000\t/* general */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nint s;\n\nStatic void\numass_dump_buffer(struct umass_softc *sc, u_int8_t *buffer, int buflen,\n\t\t  int printlen)\n{\n\tint i, j;\n\tchar s1[40];\n\tchar s2[40];\n\tchar s3[5];\n\n\ts1[0] = '\\0';\n\ts3[0] = '\\0';\n\n\tsprintf(s2, \" buffer=%p, buflen=%d\", buffer, buflen);\n\tfor (i = 0; i < buflen && i < printlen; i++) {\n\t\tj = i % 16;\n\t\tif (j == 0 && i != 0) {\n\t\t\tDPRINTF(UDMASS_GEN, (\"%s: 0x %s%s\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev), s1, s2));\n\t\t\ts2[0] = '\\0';\n\t\t}\n\t\tsprintf(&s1[j*2], \"%02x\", buffer[i] & 0xff);\n\t}\n\tif (buflen > printlen)\n\t\tsprintf(s3, \" ...\");\n\tDPRINTF(UDMASS_GEN, (\"%s: 0x %s%s%s\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), s1, s2, s3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "if",
          "args": [
            "sc->transfer_dir == DIR_IN"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "aue_ifmedia_sts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "1666-1679",
          "snippet": "Static void\naue_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\tstruct mii_data\t\t*mii = GET_MII(sc);\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tmii_pollstat(mii);\n\tifmr->ifm_active = mii->mii_media_active;\n\tifmr->ifm_status = mii->mii_media_status;\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "aue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "aue_watchdog\t__P((struct ifnet *));",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "aue_ifmedia_upd\t__P((struct ifnet *));",
            "Static void",
            "aue_ifmedia_sts\t__P((struct ifnet *, struct ifmediareq *));",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\naue_ifmedia_sts\t__P((struct ifnet *, struct ifmediareq *));\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\tstruct mii_data\t\t*mii = GET_MII(sc);\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tmii_pollstat(mii);\n\tifmr->ifm_active = mii->mii_media_active;\n\tifmr->ifm_status = mii->mii_media_status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sc->transfer_data",
            "sc->data_buffer",
            "sc->transfer_actlen"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_CBI",
            "(\"%s: Data-%s %db failed, \"\n\t\t\t\t\"%s\\n\", USBDEVNAME(sc->sc_dev),\n\t\t\t\t(sc->transfer_dir == DIR_IN?\"in\":\"out\"),\n\t\t\t\tsc->transfer_datalen,usbd_errstr(err))"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_CBI",
            "(\"%s: CBI_DATA actlen=%d\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), sc->transfer_actlen)"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_xfer_status",
          "args": [
            "xfer",
            "NULL",
            "NULL",
            "&sc->transfer_actlen",
            "NULL"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_xfer_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "499-515",
          "snippet": "void\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nvoid\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->transfer_cb",
          "args": [
            "sc",
            "sc->transfer_priv",
            "0",
            "STATUS_CMD_UNKNOWN"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_CBI",
            "(\"%s: no data phase\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev))"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_CBI",
            "(\"%s: no data phase\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev))"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sc->data_buffer",
            "sc->transfer_data",
            "sc->transfer_datalen"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_CBI",
            "(\"%s: failed to send ADSC\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev))"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->transfer_cb",
          "args": [
            "sc",
            "sc->transfer_priv",
            "sc->transfer_datalen",
            "STATUS_CMD_FAILED"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_CBI",
            "(\"%s: Command Transport failed\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev))"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_CBI",
            "(\"%s: Handling CBI state %d (%s), xfer=%p, %s\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), sc->transfer_state,\n\t\tstates[sc->transfer_state], xfer, usbd_errstr(err))"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "sc->proto & (PROTO_CBI|PROTO_CBI_I)",
            "(\"sc->proto == 0x%02x wrong for umass_cbi_state\\n\", sc->proto)"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define STATUS_WIRE_FAILED\t3\t/* couldn't even get command across */\n#define STATUS_CMD_FAILED\t2\t/* transfer was ok, command failed */\n#define STATUS_CMD_UNKNOWN\t1\t/* will have to fetch sense */\n#define STATUS_CMD_OK\t\t0\t/* everything ok */\n#define IDB_VALUE_STATUS_MASK\t0x03\n#define IDB_VALUE_PERSISTENT\t0x03\n#define IDB_VALUE_FAIL\t\t0x01\n#define IDB_VALUE_PASS\t\t0x00\n#define IDB_TYPE_CCI\t\t0x00\n#define DIR_OUT\t\t2\n#define DIR_IN\t\t1\n#define UDMASS_CBI\t0x00400000\t/* CBI transfers */\n\n__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic usbd_status;\numass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic usbd_status;\numass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\numass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));\nStatic void;\numass_bbb_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\numass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\numass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));\nStatic int;\numass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\numass_cbi_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\numass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\numass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nint s;\n\nStatic void\numass_cbi_state(usbd_xfer_handle xfer, usbd_private_handle priv,\n\t\tusbd_status err)\n{\n\tstruct umass_softc *sc = (struct umass_softc *) priv;\n\n\tKASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),\n\t\t(\"sc->proto == 0x%02x wrong for umass_cbi_state\\n\", sc->proto));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\t/*\n\t * State handling for CBI transfers.\n\t */\n\n\tDPRINTF(UDMASS_CBI, (\"%s: Handling CBI state %d (%s), xfer=%p, %s\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), sc->transfer_state,\n\t\tstates[sc->transfer_state], xfer, usbd_errstr(err)));\n\n\tswitch (sc->transfer_state) {\n\n\t/***** CBI Transfer *****/\n\tcase TSTATE_CBI_COMMAND:\n\t\tif (err == USBD_STALLED) {\n\t\t\tDPRINTF(UDMASS_CBI, (\"%s: Command Transport failed\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev)));\n\t\t\t/* Status transport by control pipe (section 2.3.2.1).\n\t\t\t * The command contained in the command block failed.\n\t\t\t *\n                         * The control pipe has already been unstalled by the\n                         * USB stack.\n                         * Section 2.4.3.1.1 states that the bulk in endpoints\n                         * should not stalled at this point.\n\t\t\t */\n\n\t\t\tsc->transfer_state = TSTATE_IDLE;\n\t\t\tsc->transfer_cb(sc, sc->transfer_priv,\n\t\t\t\t\tsc->transfer_datalen,\n\t\t\t\t\tSTATUS_CMD_FAILED);\n\n\t\t\treturn;\n\t\t} else if (err) {\n\t\t\tDPRINTF(UDMASS_CBI, (\"%s: failed to send ADSC\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev)));\n\t\t\tumass_cbi_reset(sc, STATUS_WIRE_FAILED);\n\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tsc->transfer_state = TSTATE_CBI_DATA;\n\t\tif (sc->transfer_dir == DIR_IN) {\n\t\t\tif (umass_setup_transfer(sc, sc->bulkin_pipe,\n\t\t\t\t\tsc->transfer_data, sc->transfer_datalen,\n\t\t\t\t\tUSBD_SHORT_XFER_OK | USBD_NO_COPY,\n\t\t\t\t\tsc->transfer_xfer[XFER_CBI_DATA]))\n\t\t\t\tumass_cbi_reset(sc, STATUS_WIRE_FAILED);\n\n\t\t} else if (sc->transfer_dir == DIR_OUT) {\n\t\t\tmemcpy(sc->data_buffer, sc->transfer_data, \n\t\t\t       sc->transfer_datalen);\n\t\t\tif (umass_setup_transfer(sc, sc->bulkout_pipe,\n\t\t\t\t\tsc->transfer_data, sc->transfer_datalen,\n\t\t\t\t\tUSBD_NO_COPY,/* fixed length transfer */\n\t\t\t\t\tsc->transfer_xfer[XFER_CBI_DATA]))\n\t\t\t\tumass_cbi_reset(sc, STATUS_WIRE_FAILED);\n\n\t\t} else if (sc->proto & PROTO_CBI_I) {\n\t\t\tDPRINTF(UDMASS_CBI, (\"%s: no data phase\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev)));\n\t\t\tsc->transfer_state = TSTATE_CBI_STATUS;\n\t\t\tif (umass_setup_transfer(sc, sc->intrin_pipe,\n\t\t\t\t\t&sc->sbl, sizeof(sc->sbl),\n\t\t\t\t\t0,\t/* fixed length transfer */\n\t\t\t\t\tsc->transfer_xfer[XFER_CBI_STATUS])){\n\t\t\t\tumass_cbi_reset(sc, STATUS_WIRE_FAILED);\n\t\t\t}\n\t\t} else {\n\t\t\tDPRINTF(UDMASS_CBI, (\"%s: no data phase\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev)));\n\t\t\t/* No command completion interrupt. Request\n\t\t\t * sense data.\n\t\t\t */\n\t\t\tsc->transfer_state = TSTATE_IDLE;\n\t\t\tsc->transfer_cb(sc, sc->transfer_priv,\n\t\t\t       0, STATUS_CMD_UNKNOWN);\n\t\t}\n\n\t\treturn;\n\n\tcase TSTATE_CBI_DATA:\n\t\t/* retrieve the length of the transfer that was done */\n\t\tusbd_get_xfer_status(xfer,NULL,NULL,&sc->transfer_actlen,NULL);\n\t\tDPRINTF(UDMASS_CBI, (\"%s: CBI_DATA actlen=%d\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), sc->transfer_actlen));\n\n\t\tif (err) {\n\t\t\tDPRINTF(UDMASS_CBI, (\"%s: Data-%s %db failed, \"\n\t\t\t\t\"%s\\n\", USBDEVNAME(sc->sc_dev),\n\t\t\t\t(sc->transfer_dir == DIR_IN?\"in\":\"out\"),\n\t\t\t\tsc->transfer_datalen,usbd_errstr(err)));\n\n\t\t\tif (err == USBD_STALLED) {\n\t\t\t\tumass_clear_endpoint_stall(sc,\n\t\t\t\t\tsc->bulkin, sc->bulkin_pipe,\n\t\t\t\t\tTSTATE_CBI_DCLEAR,\n\t\t\t\t\tsc->transfer_xfer[XFER_CBI_DCLEAR]);\n\t\t\t} else {\n\t\t\t\tumass_cbi_reset(sc, STATUS_WIRE_FAILED);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (sc->transfer_dir == DIR_IN)\n\t\t\tmemcpy(sc->transfer_data, sc->data_buffer,\n\t\t\t       sc->transfer_actlen);\n\n\t\tDIF(UDMASS_CBI, if (sc->transfer_dir == DIR_IN)\n\t\t\t\t\tumass_dump_buffer(sc, sc->transfer_data,\n\t\t\t\t\t\tsc->transfer_actlen, 48));\n\n\t\tif (sc->proto & PROTO_CBI_I) {\n\t\t\tsc->transfer_state = TSTATE_CBI_STATUS;\n\t\t\tmemset(&sc->sbl, 0, sizeof(sc->sbl));\n\t\t\tif (umass_setup_transfer(sc, sc->intrin_pipe,\n\t\t\t\t    &sc->sbl, sizeof(sc->sbl),\n\t\t\t\t    0,\t/* fixed length transfer */\n\t\t\t\t    sc->transfer_xfer[XFER_CBI_STATUS])){\n\t\t\t\tumass_cbi_reset(sc, STATUS_WIRE_FAILED);\n\t\t\t}\n\t\t} else {\n\t\t\t/* No command completion interrupt. Request\n\t\t\t * sense to get status of command.\n\t\t\t */\n\t\t\tsc->transfer_state = TSTATE_IDLE;\n\t\t\tsc->transfer_cb(sc, sc->transfer_priv,\n\t\t\t\tsc->transfer_datalen - sc->transfer_actlen,\n\t\t\t\tSTATUS_CMD_UNKNOWN);\n\t\t}\n\t\treturn;\n\n\tcase TSTATE_CBI_STATUS:\n\t\tif (err) {\n\t\t\tDPRINTF(UDMASS_CBI, (\"%s: Status Transport failed\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev)));\n\t\t\t/* Status transport by interrupt pipe (section 2.3.2.2).\n\t\t\t */\n\n\t\t\tif (err == USBD_STALLED) {\n\t\t\t\tumass_clear_endpoint_stall(sc,\n\t\t\t\t\tsc->intrin, sc->intrin_pipe,\n\t\t\t\t\tTSTATE_CBI_SCLEAR,\n\t\t\t\t\tsc->transfer_xfer[XFER_CBI_SCLEAR]);\n\t\t\t} else {\n\t\t\t\tumass_cbi_reset(sc, STATUS_WIRE_FAILED);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t/* Dissect the information in the buffer */\n\n\t\tif (sc->proto & PROTO_UFI) {\n\t\t\tint status;\n\t\t\t\n\t\t\t/* Section 3.4.3.1.3 specifies that the UFI command\n\t\t\t * protocol returns an ASC and ASCQ in the interrupt\n\t\t\t * data block.\n\t\t\t */\n\n\t\t\tDPRINTF(UDMASS_CBI, (\"%s: UFI CCI, ASC = 0x%02x, \"\n\t\t\t\t\"ASCQ = 0x%02x\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tsc->sbl.ufi.asc, sc->sbl.ufi.ascq));\n\n\t\t\tif (sc->sbl.ufi.asc == 0 && sc->sbl.ufi.ascq == 0)\n\t\t\t\tstatus = STATUS_CMD_OK;\n\t\t\telse\n\t\t\t\tstatus = STATUS_CMD_FAILED;\n\n\t\t\t/* No sense, command successfull */\n\t\t} else {\n\t\t\t/* Command Interrupt Data Block */\n\t\t\tDPRINTF(UDMASS_CBI, (\"%s: type=0x%02x, value=0x%02x\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tsc->sbl.common.type, sc->sbl.common.value));\n\n\t\t\tif (sc->sbl.common.type == IDB_TYPE_CCI) {\n\t\t\t\tint err;\n\n\t\t\t\tif ((sc->sbl.common.value&IDB_VALUE_STATUS_MASK)\n\t\t\t\t\t\t\t== IDB_VALUE_PASS) {\n\t\t\t\t\terr = STATUS_CMD_OK;\n\t\t\t\t} else if ((sc->sbl.common.value & IDB_VALUE_STATUS_MASK)\n\t\t\t\t\t\t\t== IDB_VALUE_FAIL ||\n\t\t\t\t\t   (sc->sbl.common.value & IDB_VALUE_STATUS_MASK)\n\t\t\t\t\t\t== IDB_VALUE_PERSISTENT) {\n\t\t\t\t\terr = STATUS_CMD_FAILED;\n\t\t\t\t} else {\n\t\t\t\t\terr = STATUS_WIRE_FAILED;\n\t\t\t\t}\n\n\t\t\t\tsc->transfer_state = TSTATE_IDLE;\n\t\t\t\tsc->transfer_cb(sc, sc->transfer_priv,\n\t\t\t\t\t\tsc->transfer_datalen,\n\t\t\t\t\t\terr);\n\t\t\t}\n\t\t}\n\t\treturn;\n\n\tcase TSTATE_CBI_DCLEAR:\n\t\tif (err) {\t/* should not occur */\n\t\t\tprintf(\"%s: CBI bulk-in/out stall clear failed, %s\\n\",\n\t\t\t       USBDEVNAME(sc->sc_dev), usbd_errstr(err));\n\t\t\tumass_cbi_reset(sc, STATUS_WIRE_FAILED);\n\t\t}\n\n\t\tsc->transfer_state = TSTATE_IDLE;\n\t\tsc->transfer_cb(sc, sc->transfer_priv,\n\t\t\t\tsc->transfer_datalen,\n\t\t\t\tSTATUS_CMD_FAILED);\n\t\treturn;\n\n\tcase TSTATE_CBI_SCLEAR:\n\t\tif (err)\t/* should not occur */\n\t\t\tprintf(\"%s: CBI intr-in stall clear failed, %s\\n\",\n\t\t\t       USBDEVNAME(sc->sc_dev), usbd_errstr(err));\n\n\t\t/* Something really bad is going on. Reset the device */\n\t\tumass_cbi_reset(sc, STATUS_CMD_FAILED);\n\t\treturn;\n\n\t/***** CBI Reset *****/\n\tcase TSTATE_CBI_RESET1:\n\t\tif (err)\n\t\t\tprintf(\"%s: CBI reset failed, %s\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev), usbd_errstr(err));\n\n\t\tumass_clear_endpoint_stall(sc,\n\t\t\tsc->bulkin, sc->bulkin_pipe, TSTATE_CBI_RESET2,\n\t\t\tsc->transfer_xfer[XFER_CBI_RESET2]);\n\n\t\treturn;\n\tcase TSTATE_CBI_RESET2:\n\t\tif (err)\t/* should not occur */\n\t\t\tprintf(\"%s: CBI bulk-in stall clear failed, %s\\n\",\n\t\t\t       USBDEVNAME(sc->sc_dev), usbd_errstr(err));\n\t\t\t/* no error recovery, otherwise we end up in a loop */\n\n\t\tumass_clear_endpoint_stall(sc,\n\t\t\tsc->bulkout, sc->bulkout_pipe, TSTATE_CBI_RESET3,\n\t\t\tsc->transfer_xfer[XFER_CBI_RESET3]);\n\n\t\treturn;\n\tcase TSTATE_CBI_RESET3:\n\t\tif (err)\t/* should not occur */\n\t\t\tprintf(\"%s: CBI bulk-out stall clear failed, %s\\n\",\n\t\t\t       USBDEVNAME(sc->sc_dev), usbd_errstr(err));\n\t\t\t/* no error recovery, otherwise we end up in a loop */\n\n\t\tsc->transfer_state = TSTATE_IDLE;\n\t\tif (sc->transfer_priv) {\n\t\t\tsc->transfer_cb(sc, sc->transfer_priv,\n\t\t\t\t\tsc->transfer_datalen,\n\t\t\t\t\tsc->transfer_status);\n\t\t}\n\n\t\treturn;\n\n\n\t/***** Default *****/\n\tdefault:\n\t\tpanic(\"%s: Unknown state %d\\n\",\n\t\t      USBDEVNAME(sc->sc_dev), sc->transfer_state);\n\t}\n}"
  },
  {
    "function_name": "umass_cbi_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "1913-1967",
    "snippet": "Static void\numass_cbi_transfer(struct umass_softc *sc, int lun,\n\t\tvoid *cmd, int cmdlen, void *data, int datalen, int dir,\n\t\ttransfer_cb_f cb, void *priv)\n{\n\tDPRINTF(UDMASS_CBI,(\"%s: umass_cbi_transfer cmd=0x%02x, len=%d\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), *(u_char*)cmd, datalen));\n\n\tKASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),\n\t\t(\"sc->proto == 0x%02x wrong for umass_cbi_transfer\\n\",\n\t\tsc->proto));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\t/*\n\t * Do a CBI transfer with cmdlen bytes from cmd, possibly\n\t * a data phase of datalen bytes from/to the device and finally a\n\t * csw read phase.\n\t * If the data direction was inbound a maximum of datalen bytes\n\t * is stored in the buffer pointed to by data.\n\t *\n\t * umass_cbi_transfer initialises the transfer and lets the state\n\t * machine in umass_cbi_state handle the completion. It uses the \n\t * following states:\n\t * TSTATE_CBI_COMMAND\n\t *   -> XXX fill in\n\t *\n\t * An error in any of those states will invoke\n\t * umass_cbi_reset.\n\t */\n\n\t/* check the given arguments */\n\tKASSERT(datalen == 0 || data != NULL,\n\t\t(\"%s: datalen > 0, but no buffer\",USBDEVNAME(sc->sc_dev)));\n\tKASSERT(datalen == 0 || dir != DIR_NONE,\n\t\t(\"%s: direction is NONE while datalen is not zero\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev)));\n\n\t/* store the details for the data transfer phase */\n\tsc->transfer_dir = dir;\n\tsc->transfer_data = data;\n\tsc->transfer_datalen = datalen;\n\tsc->transfer_actlen = 0;\n\tsc->transfer_cb = cb;\n\tsc->transfer_priv = priv;\n\tsc->transfer_status = STATUS_CMD_OK;\n\n\t/* move from idle to the command state */\n\tsc->transfer_state = TSTATE_CBI_COMMAND;\n\n\t/* Send the Command Block from host to device via control endpoint. */\n\tif (umass_cbi_adsc(sc, cmd, cmdlen, sc->transfer_xfer[XFER_CBI_CB]))\n\t\tumass_cbi_reset(sc, STATUS_WIRE_FAILED);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define STATUS_WIRE_FAILED\t3\t/* couldn't even get command across */",
      "#define STATUS_CMD_OK\t\t0\t/* everything ok */",
      "#define DIR_NONE\t0",
      "#define UDMASS_CBI\t0x00400000\t/* CBI transfers */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "Static void",
      "umass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "umass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
      "Static void",
      "int cmdlen;",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "umass_cbi_reset",
          "args": [
            "sc",
            "STATUS_WIRE_FAILED"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "umass_cbi_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "1862-1911",
          "snippet": "Static void\numass_cbi_reset(struct umass_softc *sc, int status)\n{\n\tint i;\n#\tdefine SEND_DIAGNOSTIC_CMDLEN\t12\n\n\tKASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),\n\t\t(\"sc->proto == 0x%02x wrong for umass_cbi_reset\\n\",sc->proto));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\t/*\n\t * Command Block Reset Protocol\n\t * \n\t * First send a reset request to the device. Then clear\n\t * any possibly stalled bulk endpoints.\n\n\t * This is done in 3 steps, states:\n\t * TSTATE_CBI_RESET1\n\t * TSTATE_CBI_RESET2\n\t * TSTATE_CBI_RESET3\n\t *\n\t * If the reset doesn't succeed, the device should be port reset.\n\t */\n\n\tDPRINTF(UDMASS_CBI, (\"%s: CBI Reset\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n\t\n\tKASSERT(sizeof(sc->cbl) >= SEND_DIAGNOSTIC_CMDLEN,\n\t\t(\"%s: CBL struct is too small (%d < %d)\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\tsizeof(sc->cbl), SEND_DIAGNOSTIC_CMDLEN));\n\n\tsc->transfer_state = TSTATE_CBI_RESET1;\n\tsc->transfer_status = status;\n\n\t/* The 0x1d code is the SEND DIAGNOSTIC command. To distingiush between\n\t * the two the last 10 bytes of the cbl is filled with 0xff (section\n\t * 2.2 of the CBI spec).\n\t */\n\tsc->cbl[0] = 0x1d;\t/* Command Block Reset */\n\tsc->cbl[1] = 0x04;\n\tfor (i = 2; i < SEND_DIAGNOSTIC_CMDLEN; i++)\n\t\tsc->cbl[i] = 0xff;\n\n\tumass_cbi_adsc(sc, sc->cbl, SEND_DIAGNOSTIC_CMDLEN,\n\t\t       sc->transfer_xfer[XFER_CBI_RESET1]);\n\t/* XXX if the command fails we should reset the port on the bub */\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UDMASS_CBI\t0x00400000\t/* CBI transfers */"
          ],
          "globals_used": [
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "Static void",
            "Static void",
            "umass_bbb_reset\t__P((struct umass_softc *sc, int status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "umass_cbi_reset\t__P((struct umass_softc *sc, int status));",
            "Static void",
            "Static void",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_CBI\t0x00400000\t/* CBI transfers */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\numass_bbb_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\numass_cbi_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nint s;\n\nStatic void\numass_cbi_reset(struct umass_softc *sc, int status)\n{\n\tint i;\n#\tdefine SEND_DIAGNOSTIC_CMDLEN\t12\n\n\tKASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),\n\t\t(\"sc->proto == 0x%02x wrong for umass_cbi_reset\\n\",sc->proto));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\t/*\n\t * Command Block Reset Protocol\n\t * \n\t * First send a reset request to the device. Then clear\n\t * any possibly stalled bulk endpoints.\n\n\t * This is done in 3 steps, states:\n\t * TSTATE_CBI_RESET1\n\t * TSTATE_CBI_RESET2\n\t * TSTATE_CBI_RESET3\n\t *\n\t * If the reset doesn't succeed, the device should be port reset.\n\t */\n\n\tDPRINTF(UDMASS_CBI, (\"%s: CBI Reset\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n\t\n\tKASSERT(sizeof(sc->cbl) >= SEND_DIAGNOSTIC_CMDLEN,\n\t\t(\"%s: CBL struct is too small (%d < %d)\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\tsizeof(sc->cbl), SEND_DIAGNOSTIC_CMDLEN));\n\n\tsc->transfer_state = TSTATE_CBI_RESET1;\n\tsc->transfer_status = status;\n\n\t/* The 0x1d code is the SEND DIAGNOSTIC command. To distingiush between\n\t * the two the last 10 bytes of the cbl is filled with 0xff (section\n\t * 2.2 of the CBI spec).\n\t */\n\tsc->cbl[0] = 0x1d;\t/* Command Block Reset */\n\tsc->cbl[1] = 0x04;\n\tfor (i = 2; i < SEND_DIAGNOSTIC_CMDLEN; i++)\n\t\tsc->cbl[i] = 0xff;\n\n\tumass_cbi_adsc(sc, sc->cbl, SEND_DIAGNOSTIC_CMDLEN,\n\t\t       sc->transfer_xfer[XFER_CBI_RESET1]);\n\t/* XXX if the command fails we should reset the port on the bub */\n}"
        }
      },
      {
        "call_info": {
          "callee": "umass_cbi_adsc",
          "args": [
            "sc",
            "cmd",
            "cmdlen",
            "sc->transfer_xfer[XFER_CBI_CB]"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "umass_cbi_adsc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "1838-1859",
          "snippet": "Static int\numass_cbi_adsc(struct umass_softc *sc, char *buffer, int buflen,\n\t       usbd_xfer_handle xfer)\n{\n\tusbd_device_handle dev;\n\n\tDPRINTF(UDMASS_CBI,(\"%s: umass_cbi_adsc\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n\n\tKASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),\n\t\t(\"sc->proto == 0x%02x wrong for umass_cbi_adsc\\n\",sc->proto));\n\n\tusbd_interface2device_handle(sc->iface, &dev);\n\n\tsc->request.bmRequestType = UT_WRITE_CLASS_INTERFACE;\n\tsc->request.bRequest = UR_CBI_ADSC;\n\tUSETW(sc->request.wValue, 0);\n\tUSETW(sc->request.wIndex, sc->ifaceno);\n\tUSETW(sc->request.wLength, buflen);\n\treturn umass_setup_ctrl_transfer(sc, dev, &sc->request, buffer,\n\t\t\t\t\t buflen, 0, xfer);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UR_CBI_ADSC\t0x00",
            "#define UDMASS_CBI\t0x00400000\t/* CBI transfers */"
          ],
          "globals_used": [
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "umass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "umass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));",
            "umass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));",
            "Static void",
            "umass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "umass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UR_CBI_ADSC\t0x00\n#define UDMASS_CBI\t0x00400000\t/* CBI transfers */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\numass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\numass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));\numass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\numass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic int;\numass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nint s;\n\nStatic int\numass_cbi_adsc(struct umass_softc *sc, char *buffer, int buflen,\n\t       usbd_xfer_handle xfer)\n{\n\tusbd_device_handle dev;\n\n\tDPRINTF(UDMASS_CBI,(\"%s: umass_cbi_adsc\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n\n\tKASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),\n\t\t(\"sc->proto == 0x%02x wrong for umass_cbi_adsc\\n\",sc->proto));\n\n\tusbd_interface2device_handle(sc->iface, &dev);\n\n\tsc->request.bmRequestType = UT_WRITE_CLASS_INTERFACE;\n\tsc->request.bRequest = UR_CBI_ADSC;\n\tUSETW(sc->request.wValue, 0);\n\tUSETW(sc->request.wIndex, sc->ifaceno);\n\tUSETW(sc->request.wLength, buflen);\n\treturn umass_setup_ctrl_transfer(sc, dev, &sc->request, buffer,\n\t\t\t\t\t buflen, 0, xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "datalen == 0 || dir != DIR_NONE",
            "(\"%s: direction is NONE while datalen is not zero\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev))"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "datalen == 0 || data != NULL",
            "(\"%s: datalen > 0, but no buffer\",USBDEVNAME(sc->sc_dev))"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "sc->proto & (PROTO_CBI|PROTO_CBI_I)",
            "(\"sc->proto == 0x%02x wrong for umass_cbi_transfer\\n\",\n\t\tsc->proto)"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_CBI",
            "(\"%s: umass_cbi_transfer cmd=0x%02x, len=%d\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), *(u_char*)cmd, datalen)"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define STATUS_WIRE_FAILED\t3\t/* couldn't even get command across */\n#define STATUS_CMD_OK\t\t0\t/* everything ok */\n#define DIR_NONE\t0\n#define UDMASS_CBI\t0x00400000\t/* CBI transfers */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\numass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\numass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\nint cmdlen;\nint s;\n\nStatic void\numass_cbi_transfer(struct umass_softc *sc, int lun,\n\t\tvoid *cmd, int cmdlen, void *data, int datalen, int dir,\n\t\ttransfer_cb_f cb, void *priv)\n{\n\tDPRINTF(UDMASS_CBI,(\"%s: umass_cbi_transfer cmd=0x%02x, len=%d\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), *(u_char*)cmd, datalen));\n\n\tKASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),\n\t\t(\"sc->proto == 0x%02x wrong for umass_cbi_transfer\\n\",\n\t\tsc->proto));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\t/*\n\t * Do a CBI transfer with cmdlen bytes from cmd, possibly\n\t * a data phase of datalen bytes from/to the device and finally a\n\t * csw read phase.\n\t * If the data direction was inbound a maximum of datalen bytes\n\t * is stored in the buffer pointed to by data.\n\t *\n\t * umass_cbi_transfer initialises the transfer and lets the state\n\t * machine in umass_cbi_state handle the completion. It uses the \n\t * following states:\n\t * TSTATE_CBI_COMMAND\n\t *   -> XXX fill in\n\t *\n\t * An error in any of those states will invoke\n\t * umass_cbi_reset.\n\t */\n\n\t/* check the given arguments */\n\tKASSERT(datalen == 0 || data != NULL,\n\t\t(\"%s: datalen > 0, but no buffer\",USBDEVNAME(sc->sc_dev)));\n\tKASSERT(datalen == 0 || dir != DIR_NONE,\n\t\t(\"%s: direction is NONE while datalen is not zero\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev)));\n\n\t/* store the details for the data transfer phase */\n\tsc->transfer_dir = dir;\n\tsc->transfer_data = data;\n\tsc->transfer_datalen = datalen;\n\tsc->transfer_actlen = 0;\n\tsc->transfer_cb = cb;\n\tsc->transfer_priv = priv;\n\tsc->transfer_status = STATUS_CMD_OK;\n\n\t/* move from idle to the command state */\n\tsc->transfer_state = TSTATE_CBI_COMMAND;\n\n\t/* Send the Command Block from host to device via control endpoint. */\n\tif (umass_cbi_adsc(sc, cmd, cmdlen, sc->transfer_xfer[XFER_CBI_CB]))\n\t\tumass_cbi_reset(sc, STATUS_WIRE_FAILED);\n}"
  },
  {
    "function_name": "umass_cbi_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "1862-1911",
    "snippet": "Static void\numass_cbi_reset(struct umass_softc *sc, int status)\n{\n\tint i;\n#\tdefine SEND_DIAGNOSTIC_CMDLEN\t12\n\n\tKASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),\n\t\t(\"sc->proto == 0x%02x wrong for umass_cbi_reset\\n\",sc->proto));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\t/*\n\t * Command Block Reset Protocol\n\t * \n\t * First send a reset request to the device. Then clear\n\t * any possibly stalled bulk endpoints.\n\n\t * This is done in 3 steps, states:\n\t * TSTATE_CBI_RESET1\n\t * TSTATE_CBI_RESET2\n\t * TSTATE_CBI_RESET3\n\t *\n\t * If the reset doesn't succeed, the device should be port reset.\n\t */\n\n\tDPRINTF(UDMASS_CBI, (\"%s: CBI Reset\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n\t\n\tKASSERT(sizeof(sc->cbl) >= SEND_DIAGNOSTIC_CMDLEN,\n\t\t(\"%s: CBL struct is too small (%d < %d)\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\tsizeof(sc->cbl), SEND_DIAGNOSTIC_CMDLEN));\n\n\tsc->transfer_state = TSTATE_CBI_RESET1;\n\tsc->transfer_status = status;\n\n\t/* The 0x1d code is the SEND DIAGNOSTIC command. To distingiush between\n\t * the two the last 10 bytes of the cbl is filled with 0xff (section\n\t * 2.2 of the CBI spec).\n\t */\n\tsc->cbl[0] = 0x1d;\t/* Command Block Reset */\n\tsc->cbl[1] = 0x04;\n\tfor (i = 2; i < SEND_DIAGNOSTIC_CMDLEN; i++)\n\t\tsc->cbl[i] = 0xff;\n\n\tumass_cbi_adsc(sc, sc->cbl, SEND_DIAGNOSTIC_CMDLEN,\n\t\t       sc->transfer_xfer[XFER_CBI_RESET1]);\n\t/* XXX if the command fails we should reset the port on the bub */\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UDMASS_CBI\t0x00400000\t/* CBI transfers */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "umass_bbb_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "umass_cbi_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "Static void",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "umass_cbi_adsc",
          "args": [
            "sc",
            "sc->cbl",
            "SEND_DIAGNOSTIC_CMDLEN",
            "sc->transfer_xfer[XFER_CBI_RESET1]"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "umass_cbi_adsc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "1838-1859",
          "snippet": "Static int\numass_cbi_adsc(struct umass_softc *sc, char *buffer, int buflen,\n\t       usbd_xfer_handle xfer)\n{\n\tusbd_device_handle dev;\n\n\tDPRINTF(UDMASS_CBI,(\"%s: umass_cbi_adsc\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n\n\tKASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),\n\t\t(\"sc->proto == 0x%02x wrong for umass_cbi_adsc\\n\",sc->proto));\n\n\tusbd_interface2device_handle(sc->iface, &dev);\n\n\tsc->request.bmRequestType = UT_WRITE_CLASS_INTERFACE;\n\tsc->request.bRequest = UR_CBI_ADSC;\n\tUSETW(sc->request.wValue, 0);\n\tUSETW(sc->request.wIndex, sc->ifaceno);\n\tUSETW(sc->request.wLength, buflen);\n\treturn umass_setup_ctrl_transfer(sc, dev, &sc->request, buffer,\n\t\t\t\t\t buflen, 0, xfer);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UR_CBI_ADSC\t0x00",
            "#define UDMASS_CBI\t0x00400000\t/* CBI transfers */"
          ],
          "globals_used": [
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "umass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "umass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));",
            "umass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));",
            "Static void",
            "umass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "umass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UR_CBI_ADSC\t0x00\n#define UDMASS_CBI\t0x00400000\t/* CBI transfers */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\numass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\numass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));\numass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\numass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic int;\numass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nint s;\n\nStatic int\numass_cbi_adsc(struct umass_softc *sc, char *buffer, int buflen,\n\t       usbd_xfer_handle xfer)\n{\n\tusbd_device_handle dev;\n\n\tDPRINTF(UDMASS_CBI,(\"%s: umass_cbi_adsc\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n\n\tKASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),\n\t\t(\"sc->proto == 0x%02x wrong for umass_cbi_adsc\\n\",sc->proto));\n\n\tusbd_interface2device_handle(sc->iface, &dev);\n\n\tsc->request.bmRequestType = UT_WRITE_CLASS_INTERFACE;\n\tsc->request.bRequest = UR_CBI_ADSC;\n\tUSETW(sc->request.wValue, 0);\n\tUSETW(sc->request.wIndex, sc->ifaceno);\n\tUSETW(sc->request.wLength, buflen);\n\treturn umass_setup_ctrl_transfer(sc, dev, &sc->request, buffer,\n\t\t\t\t\t buflen, 0, xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "sizeof(sc->cbl) >= SEND_DIAGNOSTIC_CMDLEN",
            "(\"%s: CBL struct is too small (%d < %d)\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\tsizeof(sc->cbl), SEND_DIAGNOSTIC_CMDLEN)"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_CBI",
            "(\"%s: CBI Reset\\n\",\n\t\tUSBDEVNAME(sc->sc_dev))"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "sc->proto & (PROTO_CBI|PROTO_CBI_I)",
            "(\"sc->proto == 0x%02x wrong for umass_cbi_reset\\n\",sc->proto)"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_CBI\t0x00400000\t/* CBI transfers */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\numass_bbb_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\numass_cbi_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nint s;\n\nStatic void\numass_cbi_reset(struct umass_softc *sc, int status)\n{\n\tint i;\n#\tdefine SEND_DIAGNOSTIC_CMDLEN\t12\n\n\tKASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),\n\t\t(\"sc->proto == 0x%02x wrong for umass_cbi_reset\\n\",sc->proto));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\t/*\n\t * Command Block Reset Protocol\n\t * \n\t * First send a reset request to the device. Then clear\n\t * any possibly stalled bulk endpoints.\n\n\t * This is done in 3 steps, states:\n\t * TSTATE_CBI_RESET1\n\t * TSTATE_CBI_RESET2\n\t * TSTATE_CBI_RESET3\n\t *\n\t * If the reset doesn't succeed, the device should be port reset.\n\t */\n\n\tDPRINTF(UDMASS_CBI, (\"%s: CBI Reset\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n\t\n\tKASSERT(sizeof(sc->cbl) >= SEND_DIAGNOSTIC_CMDLEN,\n\t\t(\"%s: CBL struct is too small (%d < %d)\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\tsizeof(sc->cbl), SEND_DIAGNOSTIC_CMDLEN));\n\n\tsc->transfer_state = TSTATE_CBI_RESET1;\n\tsc->transfer_status = status;\n\n\t/* The 0x1d code is the SEND DIAGNOSTIC command. To distingiush between\n\t * the two the last 10 bytes of the cbl is filled with 0xff (section\n\t * 2.2 of the CBI spec).\n\t */\n\tsc->cbl[0] = 0x1d;\t/* Command Block Reset */\n\tsc->cbl[1] = 0x04;\n\tfor (i = 2; i < SEND_DIAGNOSTIC_CMDLEN; i++)\n\t\tsc->cbl[i] = 0xff;\n\n\tumass_cbi_adsc(sc, sc->cbl, SEND_DIAGNOSTIC_CMDLEN,\n\t\t       sc->transfer_xfer[XFER_CBI_RESET1]);\n\t/* XXX if the command fails we should reset the port on the bub */\n}"
  },
  {
    "function_name": "umass_cbi_adsc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "1838-1859",
    "snippet": "Static int\numass_cbi_adsc(struct umass_softc *sc, char *buffer, int buflen,\n\t       usbd_xfer_handle xfer)\n{\n\tusbd_device_handle dev;\n\n\tDPRINTF(UDMASS_CBI,(\"%s: umass_cbi_adsc\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n\n\tKASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),\n\t\t(\"sc->proto == 0x%02x wrong for umass_cbi_adsc\\n\",sc->proto));\n\n\tusbd_interface2device_handle(sc->iface, &dev);\n\n\tsc->request.bmRequestType = UT_WRITE_CLASS_INTERFACE;\n\tsc->request.bRequest = UR_CBI_ADSC;\n\tUSETW(sc->request.wValue, 0);\n\tUSETW(sc->request.wIndex, sc->ifaceno);\n\tUSETW(sc->request.wLength, buflen);\n\treturn umass_setup_ctrl_transfer(sc, dev, &sc->request, buffer,\n\t\t\t\t\t buflen, 0, xfer);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UR_CBI_ADSC\t0x00",
      "#define UDMASS_CBI\t0x00400000\t/* CBI transfers */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "umass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "umass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));",
      "umass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));",
      "Static void",
      "umass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "umass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "umass_setup_ctrl_transfer",
          "args": [
            "sc",
            "dev",
            "&sc->request",
            "buffer",
            "buflen",
            "0",
            "xfer"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "umass_setup_ctrl_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "1308-1335",
          "snippet": "Static usbd_status\numass_setup_ctrl_transfer(struct umass_softc *sc, usbd_device_handle dev,\n\t usb_device_request_t *req,\n\t void *buffer, int buflen, int flags,\n\t usbd_xfer_handle xfer)\n{\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\t/* Initialiase a USB control transfer and then schedule it */\n\n\tusbd_setup_default_xfer(xfer, dev, (void *) sc,\n\t    sc->timeout, req, buffer, buflen, \n\t    flags | sc->sc_xfer_flags, sc->state);\n\n\terr = usbd_transfer(xfer);\n\tif (err && err != USBD_IN_PROGRESS) {\n\t\tDPRINTF(UDMASS_BBB, (\"%s: failed to setup ctrl transfer, %s\\n\",\n\t\t\t USBDEVNAME(sc->sc_dev), usbd_errstr(err)));\n\n\t\t/* do not reset, as this would make us loop */\n\t\treturn (err);\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
          ],
          "globals_used": [
            "__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "umass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "Static usbd_status",
            "umass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));",
            "Static usbd_status",
            "umass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));",
            "Static void",
            "umass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "umass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));",
            "Static int",
            "umass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "umass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\n__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\numass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic usbd_status;\numass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic usbd_status;\numass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\numass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\numass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));\nStatic int;\numass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\numass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nint s;\n\nStatic usbd_status\numass_setup_ctrl_transfer(struct umass_softc *sc, usbd_device_handle dev,\n\t usb_device_request_t *req,\n\t void *buffer, int buflen, int flags,\n\t usbd_xfer_handle xfer)\n{\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\t/* Initialiase a USB control transfer and then schedule it */\n\n\tusbd_setup_default_xfer(xfer, dev, (void *) sc,\n\t    sc->timeout, req, buffer, buflen, \n\t    flags | sc->sc_xfer_flags, sc->state);\n\n\terr = usbd_transfer(xfer);\n\tif (err && err != USBD_IN_PROGRESS) {\n\t\tDPRINTF(UDMASS_BBB, (\"%s: failed to setup ctrl transfer, %s\\n\",\n\t\t\t USBDEVNAME(sc->sc_dev), usbd_errstr(err)));\n\n\t\t/* do not reset, as this would make us loop */\n\t\treturn (err);\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "sc->request.wLength",
            "buflen"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "sc->request.wIndex",
            "sc->ifaceno"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "sc->request.wValue",
            "0"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_interface2device_handle",
          "args": [
            "sc->iface",
            "&dev"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_interface2device_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "658-665",
          "snippet": "usbd_status \nusbd_interface2device_handle(iface, dev)\n\tusbd_interface_handle iface;\n\tusbd_device_handle *dev;\n{\n\t*dev = iface->device;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nusbd_status \nusbd_interface2device_handle(iface, dev)\n\tusbd_interface_handle iface;\n\tusbd_device_handle *dev;\n{\n\t*dev = iface->device;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "sc->proto & (PROTO_CBI|PROTO_CBI_I)",
            "(\"sc->proto == 0x%02x wrong for umass_cbi_adsc\\n\",sc->proto)"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_CBI",
            "(\"%s: umass_cbi_adsc\\n\",\n\t\tUSBDEVNAME(sc->sc_dev))"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UR_CBI_ADSC\t0x00\n#define UDMASS_CBI\t0x00400000\t/* CBI transfers */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\numass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\numass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));\numass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\numass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic int;\numass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nint s;\n\nStatic int\numass_cbi_adsc(struct umass_softc *sc, char *buffer, int buflen,\n\t       usbd_xfer_handle xfer)\n{\n\tusbd_device_handle dev;\n\n\tDPRINTF(UDMASS_CBI,(\"%s: umass_cbi_adsc\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n\n\tKASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),\n\t\t(\"sc->proto == 0x%02x wrong for umass_cbi_adsc\\n\",sc->proto));\n\n\tusbd_interface2device_handle(sc->iface, &dev);\n\n\tsc->request.bmRequestType = UT_WRITE_CLASS_INTERFACE;\n\tsc->request.bRequest = UR_CBI_ADSC;\n\tUSETW(sc->request.wValue, 0);\n\tUSETW(sc->request.wIndex, sc->ifaceno);\n\tUSETW(sc->request.wLength, buflen);\n\treturn umass_setup_ctrl_transfer(sc, dev, &sc->request, buffer,\n\t\t\t\t\t buflen, 0, xfer);\n}"
  },
  {
    "function_name": "umass_bbb_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "1534-1832",
    "snippet": "Static void\numass_bbb_state(usbd_xfer_handle xfer, usbd_private_handle priv,\n\t\tusbd_status err)\n{\n\tstruct umass_softc *sc = (struct umass_softc *) priv;\n\tusbd_xfer_handle next_xfer;\n\n\tKASSERT(sc->proto & PROTO_BBB,\n\t\t(\"sc->proto == 0x%02x wrong for umass_bbb_state\\n\",sc->proto));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\t/*\n\t * State handling for BBB transfers.\n\t *\n\t * The subroutine is rather long. It steps through the states given in\n\t * Annex A of the Bulk-Only specification.\n\t * Each state first does the error handling of the previous transfer\n\t * and then prepares the next transfer.\n\t * Each transfer is done asynchroneously so after the request/transfer\n\t * has been submitted you will find a 'return;'.\n\t */\n\n\tDPRINTF(UDMASS_BBB, (\"%s: Handling BBB state %d (%s), xfer=%p, %s\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), sc->transfer_state,\n\t\tstates[sc->transfer_state], xfer, usbd_errstr(err)));\n\n\tswitch (sc->transfer_state) {\n\n\t/***** Bulk Transfer *****/\n\tcase TSTATE_BBB_COMMAND:\n\t\t/* Command transport phase, error handling */\n\t\tif (err) {\n\t\t\tDPRINTF(UDMASS_BBB, (\"%s: failed to send CBW\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev)));\n\t\t\t/* If the device detects that the CBW is invalid, then\n\t\t\t * the device may STALL both bulk endpoints and require\n\t\t\t * a Bulk-Reset\n\t\t\t */\n\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Data transport phase, setup transfer */\n\t\tsc->transfer_state = TSTATE_BBB_DATA;\n\t\tif (sc->transfer_dir == DIR_IN) {\n\t\t\tif (umass_setup_transfer(sc, sc->bulkin_pipe,\n\t\t\t\t\tsc->data_buffer, sc->transfer_datalen,\n\t\t\t\t\tUSBD_SHORT_XFER_OK | USBD_NO_COPY,\n\t\t\t\t\tsc->transfer_xfer[XFER_BBB_DATA]))\n\t\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\n\t\t\treturn;\n\t\t} else if (sc->transfer_dir == DIR_OUT) {\n\t\t\tmemcpy(sc->data_buffer, sc->transfer_data, \n\t\t\t       sc->transfer_datalen);\n\t\t\tif (umass_setup_transfer(sc, sc->bulkout_pipe,\n\t\t\t\t\tsc->data_buffer, sc->transfer_datalen,\n\t\t\t\t\tUSBD_NO_COPY,/* fixed length transfer */\n\t\t\t\t\tsc->transfer_xfer[XFER_BBB_DATA]))\n\t\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\n\t\t\treturn;\n\t\t} else {\n\t\t\tDPRINTF(UDMASS_BBB, (\"%s: no data phase\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev)));\n\t\t}\n\n\t\t/* FALLTHROUGH if no data phase, err == 0 */\n\tcase TSTATE_BBB_DATA:\n\t\t/* Command transport phase, error handling (ignored if no data\n\t\t * phase (fallthrough from previous state)) */\n\t\tif (sc->transfer_dir != DIR_NONE) {\n\t\t\t/* retrieve the length of the transfer that was done */\n\t\t\tusbd_get_xfer_status(xfer, NULL, NULL,\n\t\t\t\t\t     &sc->transfer_actlen, NULL);\n\n\t\t\tif (err) {\n\t\t\t\tDPRINTF(UDMASS_BBB, (\"%s: Data-%s %db failed, \"\n\t\t\t\t\t\"%s\\n\", USBDEVNAME(sc->sc_dev),\n\t\t\t\t\t(sc->transfer_dir == DIR_IN?\"in\":\"out\"),\n\t\t\t\t\tsc->transfer_datalen,usbd_errstr(err)));\n\n\t\t\t\tif (err == USBD_STALLED) {\n\t\t\t\t\tumass_clear_endpoint_stall(sc,\n\t\t\t\t\t  (sc->transfer_dir == DIR_IN?\n\t\t\t\t\t    sc->bulkin:sc->bulkout),\n\t\t\t\t\t  (sc->transfer_dir == DIR_IN?\n\t\t\t\t\t    sc->bulkin_pipe:sc->bulkout_pipe),\n\t\t\t\t\t  TSTATE_BBB_DCLEAR,\n\t\t\t\t\t  sc->transfer_xfer[XFER_BBB_DCLEAR]);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\t/* Unless the error is a pipe stall the\n\t\t\t\t\t * error is fatal.\n\t\t\t\t\t */\n\t\t\t\t\tumass_bbb_reset(sc,STATUS_WIRE_FAILED);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (sc->transfer_dir == DIR_IN)\n\t\t\tmemcpy(sc->transfer_data, sc->data_buffer,\n\t\t\t       sc->transfer_actlen);\n\n\t\tDIF(UDMASS_BBB, if (sc->transfer_dir == DIR_IN)\n\t\t\t\t\tumass_dump_buffer(sc, sc->transfer_data,\n\t\t\t\t\t\tsc->transfer_datalen, 48));\n\n\t\t/* FALLTHROUGH, err == 0 (no data phase or successfull) */\n\tcase TSTATE_BBB_DCLEAR: /* stall clear after data phase */\n\tcase TSTATE_BBB_SCLEAR: /* stall clear after status phase */\n\t\t/* Reading of CSW after bulk stall condition in data phase\n\t\t * (TSTATE_BBB_DATA2) or bulk-in stall condition after\n\t\t * reading CSW (TSTATE_BBB_SCLEAR).\n\t\t * In the case of no data phase or successfull data phase,\n\t\t * err == 0 and the following if block is passed.\n\t\t */\n\t\tif (err) {\t/* should not occur */\n\t\t\t/* try the transfer below, even if clear stall failed */\n\t\t\tDPRINTF(UDMASS_BBB, (\"%s: bulk-%s stall clear failed\"\n\t\t\t\t\", %s\\n\", USBDEVNAME(sc->sc_dev),\n\t\t\t\t(sc->transfer_dir == DIR_IN? \"in\":\"out\"),\n\t\t\t\tusbd_errstr(err)));\n\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\t\t\treturn;\n\t\t}\n\t\n\t\t/* Status transport phase, setup transfer */\n\t\tif (sc->transfer_state == TSTATE_BBB_COMMAND ||\n\t\t    sc->transfer_state == TSTATE_BBB_DATA ||\n\t\t    sc->transfer_state == TSTATE_BBB_DCLEAR) {\n\t\t\t/* After no data phase, successfull data phase and\n\t\t\t * after clearing bulk-in/-out stall condition\n\t\t\t */\n\t\t\tsc->transfer_state = TSTATE_BBB_STATUS1;\n\t\t\tnext_xfer = sc->transfer_xfer[XFER_BBB_CSW1];\n\t\t} else {\n\t\t\t/* After first attempt of fetching CSW */\n\t\t\tsc->transfer_state = TSTATE_BBB_STATUS2;\n\t\t\tnext_xfer = sc->transfer_xfer[XFER_BBB_CSW2];\n\t\t}\n\n\t\t/* Read the Command Status Wrapper via bulk-in endpoint. */\n\t\tif (umass_setup_transfer(sc, sc->bulkin_pipe,\n\t\t\t\t&sc->csw, UMASS_BBB_CSW_SIZE, 0,\n\t\t\t\tnext_xfer)) {\n\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\t\t\treturn;\n\t\t}\n\n\t\treturn;\n\tcase TSTATE_BBB_STATUS1:\t/* first attempt */\n\tcase TSTATE_BBB_STATUS2:\t/* second attempt */\n\t\t/* Status transfer, error handling */\n\t\tif (err) {\n\t\t\tDPRINTF(UDMASS_BBB, (\"%s: Failed to read CSW, %s%s\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev), usbd_errstr(err),\n\t\t\t\t(sc->transfer_state == TSTATE_BBB_STATUS1?\n\t\t\t\t\t\", retrying\":\"\")));\n\n\t\t\t/* If this was the first attempt at fetching the CSW\n\t\t\t * retry it, otherwise fail.\n\t\t\t */\n\t\t\tif (sc->transfer_state == TSTATE_BBB_STATUS1) {\n\t\t\t\tumass_clear_endpoint_stall(sc,\n\t\t\t\t\t\tsc->bulkin, sc->bulkin_pipe,\n\t\t\t\t\t\tTSTATE_BBB_SCLEAR,\n\t\t\t\t\t\tsc->transfer_xfer[XFER_BBB_SCLEAR]);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tDIF(UDMASS_BBB, umass_bbb_dump_csw(sc, &sc->csw));\n\n\t\t/* Check CSW and handle any error */\n\t\tif (UGETDW(sc->csw.dCSWSignature) != CSWSIGNATURE) {\n\t\t\t/* Invalid CSW: Wrong signature or wrong tag might\n\t\t\t * indicate that the device is confused -> reset it.\n\t\t\t */\n\t\t\tprintf(\"%s: Invalid CSW: sig 0x%08x should be 0x%08x\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tUGETDW(sc->csw.dCSWSignature),\n\t\t\t\tCSWSIGNATURE);\n\n\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\t\t\treturn;\n\t\t} else if (UGETDW(sc->csw.dCSWTag)\n\t\t\t\t!= UGETDW(sc->cbw.dCBWTag)) {\n\t\t\tprintf(\"%s: Invalid CSW: tag %d should be %d\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tUGETDW(sc->csw.dCSWTag),\n\t\t\t\tUGETDW(sc->cbw.dCBWTag));\n\n\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\t\t\treturn;\n\n\t\t/* CSW is valid here */\n\t\t} else if (sc->csw.bCSWStatus > CSWSTATUS_PHASE) {\n\t\t\tprintf(\"%s: Invalid CSW: status %d > %d\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tsc->csw.bCSWStatus,\n\t\t\t\tCSWSTATUS_PHASE);\n\n\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\t\t\treturn;\n\t\t} else if (sc->csw.bCSWStatus == CSWSTATUS_PHASE) {\n\t\t\tprintf(\"%s: Phase Error, residue = %d\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tUGETDW(sc->csw.dCSWDataResidue));\n\t\t\t\t\n\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\t\t\treturn;\n\n\t\t} else if (sc->transfer_actlen > sc->transfer_datalen) {\n\t\t\t/* Buffer overrun! Don't let this go by unnoticed */\n\t\t\tpanic(\"%s: transferred %d bytes instead of %d bytes\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tsc->transfer_actlen, sc->transfer_datalen);\n\t\t} else if (sc->transfer_datalen - sc->transfer_actlen\n\t\t\t   != UGETDW(sc->csw.dCSWDataResidue)) {\n\t\t\tDPRINTF(UDMASS_BBB, (\"%s: actlen=%d != residue=%d\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tsc->transfer_datalen - sc->transfer_actlen,\n\t\t\t\tUGETDW(sc->csw.dCSWDataResidue)));\n\n\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\t\t\treturn;\n\n\t\t} else if (sc->csw.bCSWStatus == CSWSTATUS_FAILED) {\n\t\t\tDPRINTF(UDMASS_BBB, (\"%s: Command Failed, res = %d\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tUGETDW(sc->csw.dCSWDataResidue)));\n\n\t\t\t/* SCSI command failed but transfer was succesful */\n\t\t\tsc->transfer_state = TSTATE_IDLE;\n\t\t\tsc->transfer_cb(sc, sc->transfer_priv,\n\t\t\t\t\tUGETDW(sc->csw.dCSWDataResidue),\n\t\t\t\t\tSTATUS_CMD_FAILED);\n\n\t\t\treturn;\n\n\t\t} else {\t/* success */\n\t\t\tsc->transfer_state = TSTATE_IDLE;\n\t\t\tsc->transfer_cb(sc, sc->transfer_priv,\n\t\t\t\t\tUGETDW(sc->csw.dCSWDataResidue),\n\t\t\t\t\tSTATUS_CMD_OK);\n\n\t\t\treturn;\n\t\t}\n\n\t/***** Bulk Reset *****/\n\tcase TSTATE_BBB_RESET1:\n\t\tif (err)\n\t\t\tprintf(\"%s: BBB reset failed, %s\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev), usbd_errstr(err));\n\n\t\tumass_clear_endpoint_stall(sc,\n\t\t\tsc->bulkin, sc->bulkin_pipe, TSTATE_BBB_RESET2,\n\t\t\tsc->transfer_xfer[XFER_BBB_RESET2]);\n\n\t\treturn;\n\tcase TSTATE_BBB_RESET2:\n\t\tif (err)\t/* should not occur */\n\t\t\tprintf(\"%s: BBB bulk-in clear stall failed, %s\\n\",\n\t\t\t       USBDEVNAME(sc->sc_dev), usbd_errstr(err));\n\t\t\t/* no error recovery, otherwise we end up in a loop */\n\n\t\tumass_clear_endpoint_stall(sc,\n\t\t\tsc->bulkout, sc->bulkout_pipe, TSTATE_BBB_RESET3,\n\t\t\tsc->transfer_xfer[XFER_BBB_RESET3]);\n\n\t\treturn;\n\tcase TSTATE_BBB_RESET3:\n\t\tif (err)\t/* should not occur */\n\t\t\tprintf(\"%s: BBB bulk-out clear stall failed, %s\\n\",\n\t\t\t       USBDEVNAME(sc->sc_dev), usbd_errstr(err));\n\t\t\t/* no error recovery, otherwise we end up in a loop */\n\n\t\tsc->transfer_state = TSTATE_IDLE;\n\t\tif (sc->transfer_priv) {\n\t\t\tsc->transfer_cb(sc, sc->transfer_priv,\n\t\t\t\t\tsc->transfer_datalen,\n\t\t\t\t\tsc->transfer_status);\n\t\t}\n\n\t\treturn;\n\n\t/***** Default *****/\n\tdefault:\n\t\tpanic(\"%s: Unknown state %d\\n\",\n\t\t      USBDEVNAME(sc->sc_dev), sc->transfer_state);\n\t}\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define STATUS_WIRE_FAILED\t3\t/* couldn't even get command across */",
      "#define STATUS_CMD_FAILED\t2\t/* transfer was ok, command failed */",
      "#define STATUS_CMD_OK\t\t0\t/* everything ok */",
      "#define UMASS_BBB_CSW_SIZE\t13",
      "#define DIR_OUT\t\t2",
      "#define DIR_IN\t\t1",
      "#define DIR_NONE\t0",
      "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
    ],
    "globals_used": [
      "__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static usbd_status",
      "umass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));",
      "Static usbd_status",
      "umass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));",
      "Static void",
      "umass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));",
      "Static void",
      "umass_bbb_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "umass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
      "Static void",
      "umass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));",
      "Static int",
      "umass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));",
      "Static void",
      "umass_cbi_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "umass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
      "Static void",
      "umass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: Unknown state %d\\n\"",
            "USBDEVNAME(sc->sc_dev)",
            "sc->transfer_state"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->transfer_cb",
          "args": [
            "sc",
            "sc->transfer_priv",
            "sc->transfer_datalen",
            "sc->transfer_status"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: BBB bulk-out clear stall failed, %s\\n\"",
            "USBDEVNAME(sc->sc_dev)",
            "usbd_errstr(err)"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umass_clear_endpoint_stall",
          "args": [
            "sc",
            "sc->bulkout",
            "sc->bulkout_pipe",
            "TSTATE_BBB_RESET3",
            "sc->transfer_xfer[XFER_BBB_RESET3]"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "umass_clear_endpoint_stall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "1337-1362",
          "snippet": "Static void\numass_clear_endpoint_stall(struct umass_softc *sc,\n\tu_int8_t endpt, usbd_pipe_handle pipe,\n\tint state, usbd_xfer_handle xfer)\n{\n\tusbd_device_handle dev;\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\tDPRINTF(UDMASS_BBB, (\"%s: Clear endpoint 0x%02x stall\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), endpt));\n\n\tusbd_interface2device_handle(sc->iface, &dev);\n\n\tsc->transfer_state = state;\n\n\tusbd_clear_endpoint_toggle(pipe);\n\n\tsc->request.bmRequestType = UT_WRITE_ENDPOINT;\n\tsc->request.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(sc->request.wValue, UF_ENDPOINT_HALT);\n\tUSETW(sc->request.wIndex, endpt);\n\tUSETW(sc->request.wLength, 0);\n\tumass_setup_ctrl_transfer(sc, dev, &sc->request, NULL, 0, 0, xfer);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
          ],
          "globals_used": [
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "umass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "umass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));",
            "umass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));",
            "Static void",
            "umass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "umass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\numass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\numass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));\numass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\numass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic int;\numass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nint s;\n\nStatic void\numass_clear_endpoint_stall(struct umass_softc *sc,\n\tu_int8_t endpt, usbd_pipe_handle pipe,\n\tint state, usbd_xfer_handle xfer)\n{\n\tusbd_device_handle dev;\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\tDPRINTF(UDMASS_BBB, (\"%s: Clear endpoint 0x%02x stall\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), endpt));\n\n\tusbd_interface2device_handle(sc->iface, &dev);\n\n\tsc->transfer_state = state;\n\n\tusbd_clear_endpoint_toggle(pipe);\n\n\tsc->request.bmRequestType = UT_WRITE_ENDPOINT;\n\tsc->request.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(sc->request.wValue, UF_ENDPOINT_HALT);\n\tUSETW(sc->request.wIndex, endpt);\n\tUSETW(sc->request.wLength, 0);\n\tumass_setup_ctrl_transfer(sc, dev, &sc->request, NULL, 0, 0, xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->transfer_cb",
          "args": [
            "sc",
            "sc->transfer_priv",
            "UGETDW(sc->csw.dCSWDataResidue)",
            "STATUS_CMD_OK"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETDW",
          "args": [
            "sc->csw.dCSWDataResidue"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->transfer_cb",
          "args": [
            "sc",
            "sc->transfer_priv",
            "UGETDW(sc->csw.dCSWDataResidue)",
            "STATUS_CMD_FAILED"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETDW",
          "args": [
            "sc->csw.dCSWDataResidue"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_BBB",
            "(\"%s: Command Failed, res = %d\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tUGETDW(sc->csw.dCSWDataResidue))"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETDW",
          "args": [
            "sc->csw.dCSWDataResidue"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umass_bbb_reset",
          "args": [
            "sc",
            "STATUS_WIRE_FAILED"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "umass_bbb_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "1380-1423",
          "snippet": "Static void\numass_bbb_reset(struct umass_softc *sc, int status)\n{\n\tusbd_device_handle dev;\n\n\tKASSERT(sc->proto & PROTO_BBB,\n\t\t(\"sc->proto == 0x%02x wrong for umass_bbb_reset\\n\", sc->proto));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\t/*\n\t * Reset recovery (5.3.4 in Universal Serial Bus Mass Storage Class)\n\t *\n\t * For Reset Recovery the host shall issue in the following order:\n\t * a) a Bulk-Only Mass Storage Reset\n\t * b) a Clear Feature HALT to the Bulk-In endpoint\n\t * c) a Clear Feature HALT to the Bulk-Out endpoint\n\t *\n\t * This is done in 3 steps, states:\n\t * TSTATE_BBB_RESET1\n\t * TSTATE_BBB_RESET2\n\t * TSTATE_BBB_RESET3\n\t *\n\t * If the reset doesn't succeed, the device should be port reset.\n\t */\n\n\tDPRINTF(UDMASS_BBB, (\"%s: Bulk Reset\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n\t\n\tsc->transfer_state = TSTATE_BBB_RESET1;\n\tsc->transfer_status = status;\n\n\tusbd_interface2device_handle(sc->iface, &dev);\n\n\t/* reset is a class specific interface write */\n\tsc->request.bmRequestType = UT_WRITE_CLASS_INTERFACE;\n\tsc->request.bRequest = UR_BBB_RESET;\n\tUSETW(sc->request.wValue, 0);\n\tUSETW(sc->request.wIndex, sc->ifaceno);\n\tUSETW(sc->request.wLength, 0);\n\tumass_setup_ctrl_transfer(sc, dev, &sc->request, NULL, 0, 0,\n\t\t\t\t  sc->transfer_xfer[XFER_BBB_RESET1]);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UR_BBB_RESET\t0xff\t\t/* Bulk-Only reset */",
            "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
          ],
          "globals_used": [
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "umass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "Static void",
            "Static void",
            "umass_bbb_reset\t__P((struct umass_softc *sc, int status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "umass_cbi_reset\t__P((struct umass_softc *sc, int status));",
            "Static void",
            "Static void",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UR_BBB_RESET\t0xff\t\t/* Bulk-Only reset */\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\numass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\numass_bbb_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\numass_cbi_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nint s;\n\nStatic void\numass_bbb_reset(struct umass_softc *sc, int status)\n{\n\tusbd_device_handle dev;\n\n\tKASSERT(sc->proto & PROTO_BBB,\n\t\t(\"sc->proto == 0x%02x wrong for umass_bbb_reset\\n\", sc->proto));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\t/*\n\t * Reset recovery (5.3.4 in Universal Serial Bus Mass Storage Class)\n\t *\n\t * For Reset Recovery the host shall issue in the following order:\n\t * a) a Bulk-Only Mass Storage Reset\n\t * b) a Clear Feature HALT to the Bulk-In endpoint\n\t * c) a Clear Feature HALT to the Bulk-Out endpoint\n\t *\n\t * This is done in 3 steps, states:\n\t * TSTATE_BBB_RESET1\n\t * TSTATE_BBB_RESET2\n\t * TSTATE_BBB_RESET3\n\t *\n\t * If the reset doesn't succeed, the device should be port reset.\n\t */\n\n\tDPRINTF(UDMASS_BBB, (\"%s: Bulk Reset\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n\t\n\tsc->transfer_state = TSTATE_BBB_RESET1;\n\tsc->transfer_status = status;\n\n\tusbd_interface2device_handle(sc->iface, &dev);\n\n\t/* reset is a class specific interface write */\n\tsc->request.bmRequestType = UT_WRITE_CLASS_INTERFACE;\n\tsc->request.bRequest = UR_BBB_RESET;\n\tUSETW(sc->request.wValue, 0);\n\tUSETW(sc->request.wIndex, sc->ifaceno);\n\tUSETW(sc->request.wLength, 0);\n\tumass_setup_ctrl_transfer(sc, dev, &sc->request, NULL, 0, 0,\n\t\t\t\t  sc->transfer_xfer[XFER_BBB_RESET1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_BBB",
            "(\"%s: actlen=%d != residue=%d\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tsc->transfer_datalen - sc->transfer_actlen,\n\t\t\t\tUGETDW(sc->csw.dCSWDataResidue))"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETDW",
          "args": [
            "sc->csw.dCSWDataResidue"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETDW",
          "args": [
            "sc->csw.dCSWDataResidue"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: transferred %d bytes instead of %d bytes\\n\"",
            "USBDEVNAME(sc->sc_dev)",
            "sc->transfer_actlen",
            "sc->transfer_datalen"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETDW",
          "args": [
            "sc->csw.dCSWDataResidue"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETDW",
          "args": [
            "sc->cbw.dCBWTag"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETDW",
          "args": [
            "sc->csw.dCSWTag"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETDW",
          "args": [
            "sc->cbw.dCBWTag"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETDW",
          "args": [
            "sc->csw.dCSWTag"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETDW",
          "args": [
            "sc->csw.dCSWSignature"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETDW",
          "args": [
            "sc->csw.dCSWSignature"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIF",
          "args": [
            "UDMASS_BBB",
            "umass_bbb_dump_csw(sc, &sc->csw)"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umass_bbb_dump_csw",
          "args": [
            "sc",
            "&sc->csw"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "umass_bbb_dump_csw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "3024-3039",
          "snippet": "Static void\numass_bbb_dump_csw(struct umass_softc *sc, umass_bbb_csw_t *csw)\n{\n\tint sig = UGETDW(csw->dCSWSignature);\n\tint tag = UGETW(csw->dCSWTag);\n\tint res = UGETDW(csw->dCSWDataResidue);\n\tint status = csw->bCSWStatus;\n\n\tDPRINTF(UDMASS_BBB, (\"%s: CSW %d: sig = 0x%08x (%s), tag = %d, \"\n\t\t\"res = %d, status = 0x%02x (%s)\\n\", USBDEVNAME(sc->sc_dev),\n\t\ttag, sig, (sig == CSWSIGNATURE?\t \"valid\":\"invalid\"),\n\t\ttag, res,\n\t\tstatus, (status == CSWSTATUS_GOOD? \"good\":\n\t\t\t (status == CSWSTATUS_FAILED? \"failed\":\n\t\t\t  (status == CSWSTATUS_PHASE? \"phase\":\"<invalid>\")))));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
          ],
          "globals_used": [
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "Static void",
            "Static void",
            "umass_bbb_reset\t__P((struct umass_softc *sc, int status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "umass_cbi_reset\t__P((struct umass_softc *sc, int status));",
            "Static void",
            "Static void",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\numass_bbb_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\numass_cbi_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nint s;\n\nStatic void\numass_bbb_dump_csw(struct umass_softc *sc, umass_bbb_csw_t *csw)\n{\n\tint sig = UGETDW(csw->dCSWSignature);\n\tint tag = UGETW(csw->dCSWTag);\n\tint res = UGETDW(csw->dCSWDataResidue);\n\tint status = csw->bCSWStatus;\n\n\tDPRINTF(UDMASS_BBB, (\"%s: CSW %d: sig = 0x%08x (%s), tag = %d, \"\n\t\t\"res = %d, status = 0x%02x (%s)\\n\", USBDEVNAME(sc->sc_dev),\n\t\ttag, sig, (sig == CSWSIGNATURE?\t \"valid\":\"invalid\"),\n\t\ttag, res,\n\t\tstatus, (status == CSWSTATUS_GOOD? \"good\":\n\t\t\t (status == CSWSTATUS_FAILED? \"failed\":\n\t\t\t  (status == CSWSTATUS_PHASE? \"phase\":\"<invalid>\")))));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_BBB",
            "(\"%s: Failed to read CSW, %s%s\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev), usbd_errstr(err),\n\t\t\t\t(sc->transfer_state == TSTATE_BBB_STATUS1?\n\t\t\t\t\t\", retrying\":\"\"))"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umass_setup_transfer",
          "args": [
            "sc",
            "sc->bulkin_pipe",
            "&sc->csw",
            "UMASS_BBB_CSW_SIZE",
            "0",
            "next_xfer"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "umass_setup_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "1279-1305",
          "snippet": "Static usbd_status\numass_setup_transfer(struct umass_softc *sc, usbd_pipe_handle pipe,\n\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\tusbd_xfer_handle xfer)\n{\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\t/* Initialiase a USB transfer and then schedule it */\n\n\tusbd_setup_xfer(xfer, pipe, (void *)sc, buffer, buflen,\n\t    flags | sc->sc_xfer_flags, sc->timeout, sc->state);\n\n\terr = usbd_transfer(xfer);\n\tDPRINTF(UDMASS_XFER,(\"%s: start xfer buffer=%p buflen=%d flags=0x%x \"\n\t    \"timeout=%d\\n\", USBDEVNAME(sc->sc_dev),\n\t    buffer, buflen, flags | sc->sc_xfer_flags, sc->timeout));\n\tif (err && err != USBD_IN_PROGRESS) {\n\t\tDPRINTF(UDMASS_BBB, (\"%s: failed to setup transfer, %s\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), usbd_errstr(err)));\n\t\treturn (err);\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UDMASS_XFER\t0x40000000\t/* all transfers */",
            "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
          ],
          "globals_used": [
            "__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "Static usbd_status",
            "umass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));",
            "Static usbd_status",
            "umass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));",
            "Static void",
            "umass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "umass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));",
            "Static int",
            "umass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "umass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_XFER\t0x40000000\t/* all transfers */\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\n__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic usbd_status;\numass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic usbd_status;\numass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\numass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\numass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));\nStatic int;\numass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\numass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nint s;\n\nStatic usbd_status\numass_setup_transfer(struct umass_softc *sc, usbd_pipe_handle pipe,\n\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\tusbd_xfer_handle xfer)\n{\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\t/* Initialiase a USB transfer and then schedule it */\n\n\tusbd_setup_xfer(xfer, pipe, (void *)sc, buffer, buflen,\n\t    flags | sc->sc_xfer_flags, sc->timeout, sc->state);\n\n\terr = usbd_transfer(xfer);\n\tDPRINTF(UDMASS_XFER,(\"%s: start xfer buffer=%p buflen=%d flags=0x%x \"\n\t    \"timeout=%d\\n\", USBDEVNAME(sc->sc_dev),\n\t    buffer, buflen, flags | sc->sc_xfer_flags, sc->timeout));\n\tif (err && err != USBD_IN_PROGRESS) {\n\t\tDPRINTF(UDMASS_BBB, (\"%s: failed to setup transfer, %s\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), usbd_errstr(err)));\n\t\treturn (err);\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_BBB",
            "(\"%s: bulk-%s stall clear failed\"\n\t\t\t\t\", %s\\n\", USBDEVNAME(sc->sc_dev),\n\t\t\t\t(sc->transfer_dir == DIR_IN? \"in\":\"out\"),\n\t\t\t\tusbd_errstr(err))"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIF",
          "args": [
            "UDMASS_BBB",
            "if (sc->transfer_dir == DIR_IN)umass_dump_buffer(sc, sc->transfer_data,\n\t\t\t\t\t\tsc->transfer_datalen, 48)"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umass_dump_buffer",
          "args": [
            "sc",
            "sc->transfer_data",
            "sc->transfer_datalen",
            "48"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "umass_dump_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "3041-3067",
          "snippet": "Static void\numass_dump_buffer(struct umass_softc *sc, u_int8_t *buffer, int buflen,\n\t\t  int printlen)\n{\n\tint i, j;\n\tchar s1[40];\n\tchar s2[40];\n\tchar s3[5];\n\n\ts1[0] = '\\0';\n\ts3[0] = '\\0';\n\n\tsprintf(s2, \" buffer=%p, buflen=%d\", buffer, buflen);\n\tfor (i = 0; i < buflen && i < printlen; i++) {\n\t\tj = i % 16;\n\t\tif (j == 0 && i != 0) {\n\t\t\tDPRINTF(UDMASS_GEN, (\"%s: 0x %s%s\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev), s1, s2));\n\t\t\ts2[0] = '\\0';\n\t\t}\n\t\tsprintf(&s1[j*2], \"%02x\", buffer[i] & 0xff);\n\t}\n\tif (buflen > printlen)\n\t\tsprintf(s3, \" ...\");\n\tDPRINTF(UDMASS_GEN, (\"%s: 0x %s%s%s\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), s1, s2, s3));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UDMASS_GEN\t0x00010000\t/* general */"
          ],
          "globals_used": [
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_GEN\t0x00010000\t/* general */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nint s;\n\nStatic void\numass_dump_buffer(struct umass_softc *sc, u_int8_t *buffer, int buflen,\n\t\t  int printlen)\n{\n\tint i, j;\n\tchar s1[40];\n\tchar s2[40];\n\tchar s3[5];\n\n\ts1[0] = '\\0';\n\ts3[0] = '\\0';\n\n\tsprintf(s2, \" buffer=%p, buflen=%d\", buffer, buflen);\n\tfor (i = 0; i < buflen && i < printlen; i++) {\n\t\tj = i % 16;\n\t\tif (j == 0 && i != 0) {\n\t\t\tDPRINTF(UDMASS_GEN, (\"%s: 0x %s%s\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev), s1, s2));\n\t\t\ts2[0] = '\\0';\n\t\t}\n\t\tsprintf(&s1[j*2], \"%02x\", buffer[i] & 0xff);\n\t}\n\tif (buflen > printlen)\n\t\tsprintf(s3, \" ...\");\n\tDPRINTF(UDMASS_GEN, (\"%s: 0x %s%s%s\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), s1, s2, s3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "if",
          "args": [
            "sc->transfer_dir == DIR_IN"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "aue_ifmedia_sts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "1666-1679",
          "snippet": "Static void\naue_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\tstruct mii_data\t\t*mii = GET_MII(sc);\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tmii_pollstat(mii);\n\tifmr->ifm_active = mii->mii_media_active;\n\tifmr->ifm_status = mii->mii_media_status;\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "aue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "aue_watchdog\t__P((struct ifnet *));",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "aue_ifmedia_upd\t__P((struct ifnet *));",
            "Static void",
            "aue_ifmedia_sts\t__P((struct ifnet *, struct ifmediareq *));",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\naue_ifmedia_sts\t__P((struct ifnet *, struct ifmediareq *));\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\tstruct mii_data\t\t*mii = GET_MII(sc);\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tmii_pollstat(mii);\n\tifmr->ifm_active = mii->mii_media_active;\n\tifmr->ifm_status = mii->mii_media_status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sc->transfer_data",
            "sc->data_buffer",
            "sc->transfer_actlen"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_BBB",
            "(\"%s: Data-%s %db failed, \"\n\t\t\t\t\t\"%s\\n\", USBDEVNAME(sc->sc_dev),\n\t\t\t\t\t(sc->transfer_dir == DIR_IN?\"in\":\"out\"),\n\t\t\t\t\tsc->transfer_datalen,usbd_errstr(err))"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_xfer_status",
          "args": [
            "xfer",
            "NULL",
            "NULL",
            "&sc->transfer_actlen",
            "NULL"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_xfer_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "499-515",
          "snippet": "void\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nvoid\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_BBB",
            "(\"%s: no data phase\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev))"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sc->data_buffer",
            "sc->transfer_data",
            "sc->transfer_datalen"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_BBB",
            "(\"%s: failed to send CBW\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev))"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_BBB",
            "(\"%s: Handling BBB state %d (%s), xfer=%p, %s\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), sc->transfer_state,\n\t\tstates[sc->transfer_state], xfer, usbd_errstr(err))"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "sc->proto & PROTO_BBB",
            "(\"sc->proto == 0x%02x wrong for umass_bbb_state\\n\",sc->proto)"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define STATUS_WIRE_FAILED\t3\t/* couldn't even get command across */\n#define STATUS_CMD_FAILED\t2\t/* transfer was ok, command failed */\n#define STATUS_CMD_OK\t\t0\t/* everything ok */\n#define UMASS_BBB_CSW_SIZE\t13\n#define DIR_OUT\t\t2\n#define DIR_IN\t\t1\n#define DIR_NONE\t0\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\n__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic usbd_status;\numass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic usbd_status;\numass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\numass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));\nStatic void;\numass_bbb_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\numass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\numass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));\nStatic int;\numass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\numass_cbi_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\numass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\numass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nint s;\n\nStatic void\numass_bbb_state(usbd_xfer_handle xfer, usbd_private_handle priv,\n\t\tusbd_status err)\n{\n\tstruct umass_softc *sc = (struct umass_softc *) priv;\n\tusbd_xfer_handle next_xfer;\n\n\tKASSERT(sc->proto & PROTO_BBB,\n\t\t(\"sc->proto == 0x%02x wrong for umass_bbb_state\\n\",sc->proto));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\t/*\n\t * State handling for BBB transfers.\n\t *\n\t * The subroutine is rather long. It steps through the states given in\n\t * Annex A of the Bulk-Only specification.\n\t * Each state first does the error handling of the previous transfer\n\t * and then prepares the next transfer.\n\t * Each transfer is done asynchroneously so after the request/transfer\n\t * has been submitted you will find a 'return;'.\n\t */\n\n\tDPRINTF(UDMASS_BBB, (\"%s: Handling BBB state %d (%s), xfer=%p, %s\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), sc->transfer_state,\n\t\tstates[sc->transfer_state], xfer, usbd_errstr(err)));\n\n\tswitch (sc->transfer_state) {\n\n\t/***** Bulk Transfer *****/\n\tcase TSTATE_BBB_COMMAND:\n\t\t/* Command transport phase, error handling */\n\t\tif (err) {\n\t\t\tDPRINTF(UDMASS_BBB, (\"%s: failed to send CBW\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev)));\n\t\t\t/* If the device detects that the CBW is invalid, then\n\t\t\t * the device may STALL both bulk endpoints and require\n\t\t\t * a Bulk-Reset\n\t\t\t */\n\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Data transport phase, setup transfer */\n\t\tsc->transfer_state = TSTATE_BBB_DATA;\n\t\tif (sc->transfer_dir == DIR_IN) {\n\t\t\tif (umass_setup_transfer(sc, sc->bulkin_pipe,\n\t\t\t\t\tsc->data_buffer, sc->transfer_datalen,\n\t\t\t\t\tUSBD_SHORT_XFER_OK | USBD_NO_COPY,\n\t\t\t\t\tsc->transfer_xfer[XFER_BBB_DATA]))\n\t\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\n\t\t\treturn;\n\t\t} else if (sc->transfer_dir == DIR_OUT) {\n\t\t\tmemcpy(sc->data_buffer, sc->transfer_data, \n\t\t\t       sc->transfer_datalen);\n\t\t\tif (umass_setup_transfer(sc, sc->bulkout_pipe,\n\t\t\t\t\tsc->data_buffer, sc->transfer_datalen,\n\t\t\t\t\tUSBD_NO_COPY,/* fixed length transfer */\n\t\t\t\t\tsc->transfer_xfer[XFER_BBB_DATA]))\n\t\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\n\t\t\treturn;\n\t\t} else {\n\t\t\tDPRINTF(UDMASS_BBB, (\"%s: no data phase\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev)));\n\t\t}\n\n\t\t/* FALLTHROUGH if no data phase, err == 0 */\n\tcase TSTATE_BBB_DATA:\n\t\t/* Command transport phase, error handling (ignored if no data\n\t\t * phase (fallthrough from previous state)) */\n\t\tif (sc->transfer_dir != DIR_NONE) {\n\t\t\t/* retrieve the length of the transfer that was done */\n\t\t\tusbd_get_xfer_status(xfer, NULL, NULL,\n\t\t\t\t\t     &sc->transfer_actlen, NULL);\n\n\t\t\tif (err) {\n\t\t\t\tDPRINTF(UDMASS_BBB, (\"%s: Data-%s %db failed, \"\n\t\t\t\t\t\"%s\\n\", USBDEVNAME(sc->sc_dev),\n\t\t\t\t\t(sc->transfer_dir == DIR_IN?\"in\":\"out\"),\n\t\t\t\t\tsc->transfer_datalen,usbd_errstr(err)));\n\n\t\t\t\tif (err == USBD_STALLED) {\n\t\t\t\t\tumass_clear_endpoint_stall(sc,\n\t\t\t\t\t  (sc->transfer_dir == DIR_IN?\n\t\t\t\t\t    sc->bulkin:sc->bulkout),\n\t\t\t\t\t  (sc->transfer_dir == DIR_IN?\n\t\t\t\t\t    sc->bulkin_pipe:sc->bulkout_pipe),\n\t\t\t\t\t  TSTATE_BBB_DCLEAR,\n\t\t\t\t\t  sc->transfer_xfer[XFER_BBB_DCLEAR]);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\t/* Unless the error is a pipe stall the\n\t\t\t\t\t * error is fatal.\n\t\t\t\t\t */\n\t\t\t\t\tumass_bbb_reset(sc,STATUS_WIRE_FAILED);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (sc->transfer_dir == DIR_IN)\n\t\t\tmemcpy(sc->transfer_data, sc->data_buffer,\n\t\t\t       sc->transfer_actlen);\n\n\t\tDIF(UDMASS_BBB, if (sc->transfer_dir == DIR_IN)\n\t\t\t\t\tumass_dump_buffer(sc, sc->transfer_data,\n\t\t\t\t\t\tsc->transfer_datalen, 48));\n\n\t\t/* FALLTHROUGH, err == 0 (no data phase or successfull) */\n\tcase TSTATE_BBB_DCLEAR: /* stall clear after data phase */\n\tcase TSTATE_BBB_SCLEAR: /* stall clear after status phase */\n\t\t/* Reading of CSW after bulk stall condition in data phase\n\t\t * (TSTATE_BBB_DATA2) or bulk-in stall condition after\n\t\t * reading CSW (TSTATE_BBB_SCLEAR).\n\t\t * In the case of no data phase or successfull data phase,\n\t\t * err == 0 and the following if block is passed.\n\t\t */\n\t\tif (err) {\t/* should not occur */\n\t\t\t/* try the transfer below, even if clear stall failed */\n\t\t\tDPRINTF(UDMASS_BBB, (\"%s: bulk-%s stall clear failed\"\n\t\t\t\t\", %s\\n\", USBDEVNAME(sc->sc_dev),\n\t\t\t\t(sc->transfer_dir == DIR_IN? \"in\":\"out\"),\n\t\t\t\tusbd_errstr(err)));\n\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\t\t\treturn;\n\t\t}\n\t\n\t\t/* Status transport phase, setup transfer */\n\t\tif (sc->transfer_state == TSTATE_BBB_COMMAND ||\n\t\t    sc->transfer_state == TSTATE_BBB_DATA ||\n\t\t    sc->transfer_state == TSTATE_BBB_DCLEAR) {\n\t\t\t/* After no data phase, successfull data phase and\n\t\t\t * after clearing bulk-in/-out stall condition\n\t\t\t */\n\t\t\tsc->transfer_state = TSTATE_BBB_STATUS1;\n\t\t\tnext_xfer = sc->transfer_xfer[XFER_BBB_CSW1];\n\t\t} else {\n\t\t\t/* After first attempt of fetching CSW */\n\t\t\tsc->transfer_state = TSTATE_BBB_STATUS2;\n\t\t\tnext_xfer = sc->transfer_xfer[XFER_BBB_CSW2];\n\t\t}\n\n\t\t/* Read the Command Status Wrapper via bulk-in endpoint. */\n\t\tif (umass_setup_transfer(sc, sc->bulkin_pipe,\n\t\t\t\t&sc->csw, UMASS_BBB_CSW_SIZE, 0,\n\t\t\t\tnext_xfer)) {\n\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\t\t\treturn;\n\t\t}\n\n\t\treturn;\n\tcase TSTATE_BBB_STATUS1:\t/* first attempt */\n\tcase TSTATE_BBB_STATUS2:\t/* second attempt */\n\t\t/* Status transfer, error handling */\n\t\tif (err) {\n\t\t\tDPRINTF(UDMASS_BBB, (\"%s: Failed to read CSW, %s%s\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev), usbd_errstr(err),\n\t\t\t\t(sc->transfer_state == TSTATE_BBB_STATUS1?\n\t\t\t\t\t\", retrying\":\"\")));\n\n\t\t\t/* If this was the first attempt at fetching the CSW\n\t\t\t * retry it, otherwise fail.\n\t\t\t */\n\t\t\tif (sc->transfer_state == TSTATE_BBB_STATUS1) {\n\t\t\t\tumass_clear_endpoint_stall(sc,\n\t\t\t\t\t\tsc->bulkin, sc->bulkin_pipe,\n\t\t\t\t\t\tTSTATE_BBB_SCLEAR,\n\t\t\t\t\t\tsc->transfer_xfer[XFER_BBB_SCLEAR]);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tDIF(UDMASS_BBB, umass_bbb_dump_csw(sc, &sc->csw));\n\n\t\t/* Check CSW and handle any error */\n\t\tif (UGETDW(sc->csw.dCSWSignature) != CSWSIGNATURE) {\n\t\t\t/* Invalid CSW: Wrong signature or wrong tag might\n\t\t\t * indicate that the device is confused -> reset it.\n\t\t\t */\n\t\t\tprintf(\"%s: Invalid CSW: sig 0x%08x should be 0x%08x\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tUGETDW(sc->csw.dCSWSignature),\n\t\t\t\tCSWSIGNATURE);\n\n\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\t\t\treturn;\n\t\t} else if (UGETDW(sc->csw.dCSWTag)\n\t\t\t\t!= UGETDW(sc->cbw.dCBWTag)) {\n\t\t\tprintf(\"%s: Invalid CSW: tag %d should be %d\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tUGETDW(sc->csw.dCSWTag),\n\t\t\t\tUGETDW(sc->cbw.dCBWTag));\n\n\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\t\t\treturn;\n\n\t\t/* CSW is valid here */\n\t\t} else if (sc->csw.bCSWStatus > CSWSTATUS_PHASE) {\n\t\t\tprintf(\"%s: Invalid CSW: status %d > %d\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tsc->csw.bCSWStatus,\n\t\t\t\tCSWSTATUS_PHASE);\n\n\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\t\t\treturn;\n\t\t} else if (sc->csw.bCSWStatus == CSWSTATUS_PHASE) {\n\t\t\tprintf(\"%s: Phase Error, residue = %d\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tUGETDW(sc->csw.dCSWDataResidue));\n\t\t\t\t\n\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\t\t\treturn;\n\n\t\t} else if (sc->transfer_actlen > sc->transfer_datalen) {\n\t\t\t/* Buffer overrun! Don't let this go by unnoticed */\n\t\t\tpanic(\"%s: transferred %d bytes instead of %d bytes\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tsc->transfer_actlen, sc->transfer_datalen);\n\t\t} else if (sc->transfer_datalen - sc->transfer_actlen\n\t\t\t   != UGETDW(sc->csw.dCSWDataResidue)) {\n\t\t\tDPRINTF(UDMASS_BBB, (\"%s: actlen=%d != residue=%d\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tsc->transfer_datalen - sc->transfer_actlen,\n\t\t\t\tUGETDW(sc->csw.dCSWDataResidue)));\n\n\t\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\t\t\treturn;\n\n\t\t} else if (sc->csw.bCSWStatus == CSWSTATUS_FAILED) {\n\t\t\tDPRINTF(UDMASS_BBB, (\"%s: Command Failed, res = %d\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\t\tUGETDW(sc->csw.dCSWDataResidue)));\n\n\t\t\t/* SCSI command failed but transfer was succesful */\n\t\t\tsc->transfer_state = TSTATE_IDLE;\n\t\t\tsc->transfer_cb(sc, sc->transfer_priv,\n\t\t\t\t\tUGETDW(sc->csw.dCSWDataResidue),\n\t\t\t\t\tSTATUS_CMD_FAILED);\n\n\t\t\treturn;\n\n\t\t} else {\t/* success */\n\t\t\tsc->transfer_state = TSTATE_IDLE;\n\t\t\tsc->transfer_cb(sc, sc->transfer_priv,\n\t\t\t\t\tUGETDW(sc->csw.dCSWDataResidue),\n\t\t\t\t\tSTATUS_CMD_OK);\n\n\t\t\treturn;\n\t\t}\n\n\t/***** Bulk Reset *****/\n\tcase TSTATE_BBB_RESET1:\n\t\tif (err)\n\t\t\tprintf(\"%s: BBB reset failed, %s\\n\",\n\t\t\t\tUSBDEVNAME(sc->sc_dev), usbd_errstr(err));\n\n\t\tumass_clear_endpoint_stall(sc,\n\t\t\tsc->bulkin, sc->bulkin_pipe, TSTATE_BBB_RESET2,\n\t\t\tsc->transfer_xfer[XFER_BBB_RESET2]);\n\n\t\treturn;\n\tcase TSTATE_BBB_RESET2:\n\t\tif (err)\t/* should not occur */\n\t\t\tprintf(\"%s: BBB bulk-in clear stall failed, %s\\n\",\n\t\t\t       USBDEVNAME(sc->sc_dev), usbd_errstr(err));\n\t\t\t/* no error recovery, otherwise we end up in a loop */\n\n\t\tumass_clear_endpoint_stall(sc,\n\t\t\tsc->bulkout, sc->bulkout_pipe, TSTATE_BBB_RESET3,\n\t\t\tsc->transfer_xfer[XFER_BBB_RESET3]);\n\n\t\treturn;\n\tcase TSTATE_BBB_RESET3:\n\t\tif (err)\t/* should not occur */\n\t\t\tprintf(\"%s: BBB bulk-out clear stall failed, %s\\n\",\n\t\t\t       USBDEVNAME(sc->sc_dev), usbd_errstr(err));\n\t\t\t/* no error recovery, otherwise we end up in a loop */\n\n\t\tsc->transfer_state = TSTATE_IDLE;\n\t\tif (sc->transfer_priv) {\n\t\t\tsc->transfer_cb(sc, sc->transfer_priv,\n\t\t\t\t\tsc->transfer_datalen,\n\t\t\t\t\tsc->transfer_status);\n\t\t}\n\n\t\treturn;\n\n\t/***** Default *****/\n\tdefault:\n\t\tpanic(\"%s: Unknown state %d\\n\",\n\t\t      USBDEVNAME(sc->sc_dev), sc->transfer_state);\n\t}\n}"
  },
  {
    "function_name": "umass_bbb_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "1425-1531",
    "snippet": "Static void\numass_bbb_transfer(struct umass_softc *sc, int lun, void *cmd, int cmdlen,\n\t\t    void *data, int datalen, int dir,\n\t\t    transfer_cb_f cb, void *priv)\n{\n\tstatic int dCBWtag = 42;\t/* unique for CBW of transfer */\n\n\tDPRINTF(UDMASS_BBB,(\"%s: umass_bbb_transfer cmd=0x%02x\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), *(u_char*)cmd));\n\n\tKASSERT(sc->proto & PROTO_BBB,\n\t\t(\"sc->proto == 0x%02x wrong for umass_bbb_transfer\\n\",\n\t\tsc->proto));\n\n\t/*\n\t * Do a Bulk-Only transfer with cmdlen bytes from cmd, possibly\n\t * a data phase of datalen bytes from/to the device and finally a\n\t * csw read phase.\n\t * If the data direction was inbound a maximum of datalen bytes\n\t * is stored in the buffer pointed to by data.\n\t *\n\t * umass_bbb_transfer initialises the transfer and lets the state\n\t * machine in umass_bbb_state handle the completion. It uses the \n\t * following states:\n\t * TSTATE_BBB_COMMAND\n\t *   -> TSTATE_BBB_DATA\n\t *   -> TSTATE_BBB_STATUS\n\t *   -> TSTATE_BBB_STATUS2\n\t *   -> TSTATE_BBB_IDLE\n\t *\n\t * An error in any of those states will invoke\n\t * umass_bbb_reset.\n\t */\n\n\t/* check the given arguments */\n\tKASSERT(datalen == 0 || data != NULL,\n\t\t(\"%s: datalen > 0, but no buffer\",USBDEVNAME(sc->sc_dev)));\n\tKASSERT(cmdlen <= CBWCDBLENGTH,\n\t\t(\"%s: cmdlen exceeds CDB length in CBW (%d > %d)\",\n\t\t\tUSBDEVNAME(sc->sc_dev), cmdlen, CBWCDBLENGTH));\n\tKASSERT(dir == DIR_NONE || datalen > 0,\n\t\t(\"%s: datalen == 0 while direction is not NONE\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev)));\n\tKASSERT(datalen == 0 || dir != DIR_NONE,\n\t\t(\"%s: direction is NONE while datalen is not zero\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev)));\n\tKASSERT(sizeof(umass_bbb_cbw_t) == UMASS_BBB_CBW_SIZE,\n\t\t(\"%s: CBW struct does not have the right size (%d vs. %d)\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\tsizeof(umass_bbb_cbw_t), UMASS_BBB_CBW_SIZE));\n\tKASSERT(sizeof(umass_bbb_csw_t) == UMASS_BBB_CSW_SIZE,\n\t\t(\"%s: CSW struct does not have the right size (%d vs. %d)\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\tsizeof(umass_bbb_csw_t), UMASS_BBB_CSW_SIZE));\n\n\t/*\n\t * Determine the direction of the data transfer and the length.\n\t *\n\t * dCBWDataTransferLength (datalen) :\n\t *   This field indicates the number of bytes of data that the host\n\t *   intends to transfer on the IN or OUT Bulk endpoint(as indicated by\n\t *   the Direction bit) during the execution of this command. If this\n\t *   field is set to 0, the device will expect that no data will be\n\t *   transferred IN or OUT during this command, regardless of the value\n\t *   of the Direction bit defined in dCBWFlags.\n\t *\n\t * dCBWFlags (dir) :\n\t *   The bits of the Flags field are defined as follows:\n\t *     Bits 0-6\t reserved\n\t *     Bit  7\t Direction - this bit shall be ignored if the\n\t *\t\t\t     dCBWDataTransferLength field is zero.\n\t *\t\t 0 = data Out from host to device\n\t *\t\t 1 = data In from device to host\n\t */\n\n\t/* Fill in the Command Block Wrapper */\n\tUSETDW(sc->cbw.dCBWSignature, CBWSIGNATURE);\n\tUSETDW(sc->cbw.dCBWTag, dCBWtag);\n\tdCBWtag++;\t/* cannot be done in macro (it will be done 4 times) */\n\tUSETDW(sc->cbw.dCBWDataTransferLength, datalen);\n\t/* DIR_NONE is treated as DIR_OUT (0x00) */\n\tsc->cbw.bCBWFlags = (dir == DIR_IN? CBWFLAGS_IN:CBWFLAGS_OUT);\n\tsc->cbw.bCBWLUN = lun;\n\tsc->cbw.bCDBLength = cmdlen;\n\tbcopy(cmd, sc->cbw.CBWCDB, cmdlen);\n\n\tDIF(UDMASS_BBB, umass_bbb_dump_cbw(sc, &sc->cbw));\n\n\t/* store the details for the data transfer phase */\n\tsc->transfer_dir = dir;\n\tsc->transfer_data = data;\n\tsc->transfer_datalen = datalen;\n\tsc->transfer_actlen = 0;\n\tsc->transfer_cb = cb;\n\tsc->transfer_priv = priv;\n\tsc->transfer_status = STATUS_CMD_OK;\n\n\t/* move from idle to the command state */\n\tsc->transfer_state = TSTATE_BBB_COMMAND;\n\n\t/* Send the CBW from host to device via bulk-out endpoint. */\n\tif (umass_setup_transfer(sc, sc->bulkout_pipe,\n\t\t\t&sc->cbw, UMASS_BBB_CBW_SIZE, 0,\n\t\t\tsc->transfer_xfer[XFER_BBB_CBW])) {\n\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\t}\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define STATUS_WIRE_FAILED\t3\t/* couldn't even get command across */",
      "#define STATUS_CMD_OK\t\t0\t/* everything ok */",
      "#define UMASS_BBB_CSW_SIZE\t13",
      "#define UMASS_BBB_CBW_SIZE\t31",
      "#define DIR_OUT\t\t2",
      "#define DIR_IN\t\t1",
      "#define DIR_NONE\t0",
      "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "Static void",
      "umass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "umass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
      "Static void",
      "int cmdlen;",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "umass_bbb_reset",
          "args": [
            "sc",
            "STATUS_WIRE_FAILED"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "umass_bbb_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "1380-1423",
          "snippet": "Static void\numass_bbb_reset(struct umass_softc *sc, int status)\n{\n\tusbd_device_handle dev;\n\n\tKASSERT(sc->proto & PROTO_BBB,\n\t\t(\"sc->proto == 0x%02x wrong for umass_bbb_reset\\n\", sc->proto));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\t/*\n\t * Reset recovery (5.3.4 in Universal Serial Bus Mass Storage Class)\n\t *\n\t * For Reset Recovery the host shall issue in the following order:\n\t * a) a Bulk-Only Mass Storage Reset\n\t * b) a Clear Feature HALT to the Bulk-In endpoint\n\t * c) a Clear Feature HALT to the Bulk-Out endpoint\n\t *\n\t * This is done in 3 steps, states:\n\t * TSTATE_BBB_RESET1\n\t * TSTATE_BBB_RESET2\n\t * TSTATE_BBB_RESET3\n\t *\n\t * If the reset doesn't succeed, the device should be port reset.\n\t */\n\n\tDPRINTF(UDMASS_BBB, (\"%s: Bulk Reset\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n\t\n\tsc->transfer_state = TSTATE_BBB_RESET1;\n\tsc->transfer_status = status;\n\n\tusbd_interface2device_handle(sc->iface, &dev);\n\n\t/* reset is a class specific interface write */\n\tsc->request.bmRequestType = UT_WRITE_CLASS_INTERFACE;\n\tsc->request.bRequest = UR_BBB_RESET;\n\tUSETW(sc->request.wValue, 0);\n\tUSETW(sc->request.wIndex, sc->ifaceno);\n\tUSETW(sc->request.wLength, 0);\n\tumass_setup_ctrl_transfer(sc, dev, &sc->request, NULL, 0, 0,\n\t\t\t\t  sc->transfer_xfer[XFER_BBB_RESET1]);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UR_BBB_RESET\t0xff\t\t/* Bulk-Only reset */",
            "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
          ],
          "globals_used": [
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "umass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "Static void",
            "Static void",
            "umass_bbb_reset\t__P((struct umass_softc *sc, int status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "umass_cbi_reset\t__P((struct umass_softc *sc, int status));",
            "Static void",
            "Static void",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UR_BBB_RESET\t0xff\t\t/* Bulk-Only reset */\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\numass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\numass_bbb_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\numass_cbi_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nint s;\n\nStatic void\numass_bbb_reset(struct umass_softc *sc, int status)\n{\n\tusbd_device_handle dev;\n\n\tKASSERT(sc->proto & PROTO_BBB,\n\t\t(\"sc->proto == 0x%02x wrong for umass_bbb_reset\\n\", sc->proto));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\t/*\n\t * Reset recovery (5.3.4 in Universal Serial Bus Mass Storage Class)\n\t *\n\t * For Reset Recovery the host shall issue in the following order:\n\t * a) a Bulk-Only Mass Storage Reset\n\t * b) a Clear Feature HALT to the Bulk-In endpoint\n\t * c) a Clear Feature HALT to the Bulk-Out endpoint\n\t *\n\t * This is done in 3 steps, states:\n\t * TSTATE_BBB_RESET1\n\t * TSTATE_BBB_RESET2\n\t * TSTATE_BBB_RESET3\n\t *\n\t * If the reset doesn't succeed, the device should be port reset.\n\t */\n\n\tDPRINTF(UDMASS_BBB, (\"%s: Bulk Reset\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n\t\n\tsc->transfer_state = TSTATE_BBB_RESET1;\n\tsc->transfer_status = status;\n\n\tusbd_interface2device_handle(sc->iface, &dev);\n\n\t/* reset is a class specific interface write */\n\tsc->request.bmRequestType = UT_WRITE_CLASS_INTERFACE;\n\tsc->request.bRequest = UR_BBB_RESET;\n\tUSETW(sc->request.wValue, 0);\n\tUSETW(sc->request.wIndex, sc->ifaceno);\n\tUSETW(sc->request.wLength, 0);\n\tumass_setup_ctrl_transfer(sc, dev, &sc->request, NULL, 0, 0,\n\t\t\t\t  sc->transfer_xfer[XFER_BBB_RESET1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "umass_setup_transfer",
          "args": [
            "sc",
            "sc->bulkout_pipe",
            "&sc->cbw",
            "UMASS_BBB_CBW_SIZE",
            "0",
            "sc->transfer_xfer[XFER_BBB_CBW]"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "umass_setup_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "1279-1305",
          "snippet": "Static usbd_status\numass_setup_transfer(struct umass_softc *sc, usbd_pipe_handle pipe,\n\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\tusbd_xfer_handle xfer)\n{\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\t/* Initialiase a USB transfer and then schedule it */\n\n\tusbd_setup_xfer(xfer, pipe, (void *)sc, buffer, buflen,\n\t    flags | sc->sc_xfer_flags, sc->timeout, sc->state);\n\n\terr = usbd_transfer(xfer);\n\tDPRINTF(UDMASS_XFER,(\"%s: start xfer buffer=%p buflen=%d flags=0x%x \"\n\t    \"timeout=%d\\n\", USBDEVNAME(sc->sc_dev),\n\t    buffer, buflen, flags | sc->sc_xfer_flags, sc->timeout));\n\tif (err && err != USBD_IN_PROGRESS) {\n\t\tDPRINTF(UDMASS_BBB, (\"%s: failed to setup transfer, %s\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), usbd_errstr(err)));\n\t\treturn (err);\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UDMASS_XFER\t0x40000000\t/* all transfers */",
            "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
          ],
          "globals_used": [
            "__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "Static usbd_status",
            "umass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));",
            "Static usbd_status",
            "umass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));",
            "Static void",
            "umass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "umass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));",
            "Static int",
            "umass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "umass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_XFER\t0x40000000\t/* all transfers */\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\n__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic usbd_status;\numass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic usbd_status;\numass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\numass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\numass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));\nStatic int;\numass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\numass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nint s;\n\nStatic usbd_status\numass_setup_transfer(struct umass_softc *sc, usbd_pipe_handle pipe,\n\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\tusbd_xfer_handle xfer)\n{\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\t/* Initialiase a USB transfer and then schedule it */\n\n\tusbd_setup_xfer(xfer, pipe, (void *)sc, buffer, buflen,\n\t    flags | sc->sc_xfer_flags, sc->timeout, sc->state);\n\n\terr = usbd_transfer(xfer);\n\tDPRINTF(UDMASS_XFER,(\"%s: start xfer buffer=%p buflen=%d flags=0x%x \"\n\t    \"timeout=%d\\n\", USBDEVNAME(sc->sc_dev),\n\t    buffer, buflen, flags | sc->sc_xfer_flags, sc->timeout));\n\tif (err && err != USBD_IN_PROGRESS) {\n\t\tDPRINTF(UDMASS_BBB, (\"%s: failed to setup transfer, %s\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), usbd_errstr(err)));\n\t\treturn (err);\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIF",
          "args": [
            "UDMASS_BBB",
            "umass_bbb_dump_cbw(sc, &sc->cbw)"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umass_bbb_dump_cbw",
          "args": [
            "sc",
            "&sc->cbw"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "umass_bbb_dump_cbw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "3006-3022",
          "snippet": "Static void\numass_bbb_dump_cbw(struct umass_softc *sc, umass_bbb_cbw_t *cbw)\n{\n\tint clen = cbw->bCDBLength;\n\tint dlen = UGETDW(cbw->dCBWDataTransferLength);\n\tu_int8_t *c = cbw->CBWCDB;\n\tint tag = UGETDW(cbw->dCBWTag);\n\tint flags = cbw->bCBWFlags;\n\n\tDPRINTF(UDMASS_BBB, (\"%s: CBW %d: cmd = %db \"\n\t\t\"(0x%02x%02x%02x%02x%02x%02x%s), \"\n\t\t\"data = %d bytes, dir = %s\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), tag, clen,\n\t\tc[0], c[1], c[2], c[3], c[4], c[5], (clen > 6? \"...\":\"\"),\n\t\tdlen, (flags == CBWFLAGS_IN? \"in\":\n\t\t       (flags == CBWFLAGS_OUT? \"out\":\"<invalid>\"))));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
          ],
          "globals_used": [
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nint s;\n\nStatic void\numass_bbb_dump_cbw(struct umass_softc *sc, umass_bbb_cbw_t *cbw)\n{\n\tint clen = cbw->bCDBLength;\n\tint dlen = UGETDW(cbw->dCBWDataTransferLength);\n\tu_int8_t *c = cbw->CBWCDB;\n\tint tag = UGETDW(cbw->dCBWTag);\n\tint flags = cbw->bCBWFlags;\n\n\tDPRINTF(UDMASS_BBB, (\"%s: CBW %d: cmd = %db \"\n\t\t\"(0x%02x%02x%02x%02x%02x%02x%s), \"\n\t\t\"data = %d bytes, dir = %s\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), tag, clen,\n\t\tc[0], c[1], c[2], c[3], c[4], c[5], (clen > 6? \"...\":\"\"),\n\t\tdlen, (flags == CBWFLAGS_IN? \"in\":\n\t\t       (flags == CBWFLAGS_OUT? \"out\":\"<invalid>\"))));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "cmd",
            "sc->cbw.CBWCDB",
            "cmdlen"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETDW",
          "args": [
            "sc->cbw.dCBWDataTransferLength",
            "datalen"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETDW",
          "args": [
            "sc->cbw.dCBWTag",
            "dCBWtag"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETDW",
          "args": [
            "sc->cbw.dCBWSignature",
            "CBWSIGNATURE"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "sizeof(umass_bbb_csw_t) == UMASS_BBB_CSW_SIZE",
            "(\"%s: CSW struct does not have the right size (%d vs. %d)\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\tsizeof(umass_bbb_csw_t), UMASS_BBB_CSW_SIZE)"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "sizeof(umass_bbb_cbw_t) == UMASS_BBB_CBW_SIZE",
            "(\"%s: CBW struct does not have the right size (%d vs. %d)\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\tsizeof(umass_bbb_cbw_t), UMASS_BBB_CBW_SIZE)"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "datalen == 0 || dir != DIR_NONE",
            "(\"%s: direction is NONE while datalen is not zero\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev))"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "dir == DIR_NONE || datalen > 0",
            "(\"%s: datalen == 0 while direction is not NONE\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev))"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "cmdlen <= CBWCDBLENGTH",
            "(\"%s: cmdlen exceeds CDB length in CBW (%d > %d)\",\n\t\t\tUSBDEVNAME(sc->sc_dev), cmdlen, CBWCDBLENGTH)"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "datalen == 0 || data != NULL",
            "(\"%s: datalen > 0, but no buffer\",USBDEVNAME(sc->sc_dev))"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "sc->proto & PROTO_BBB",
            "(\"sc->proto == 0x%02x wrong for umass_bbb_transfer\\n\",\n\t\tsc->proto)"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_BBB",
            "(\"%s: umass_bbb_transfer cmd=0x%02x\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), *(u_char*)cmd)"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define STATUS_WIRE_FAILED\t3\t/* couldn't even get command across */\n#define STATUS_CMD_OK\t\t0\t/* everything ok */\n#define UMASS_BBB_CSW_SIZE\t13\n#define UMASS_BBB_CBW_SIZE\t31\n#define DIR_OUT\t\t2\n#define DIR_IN\t\t1\n#define DIR_NONE\t0\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\numass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\numass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\nint cmdlen;\nint s;\n\nStatic void\numass_bbb_transfer(struct umass_softc *sc, int lun, void *cmd, int cmdlen,\n\t\t    void *data, int datalen, int dir,\n\t\t    transfer_cb_f cb, void *priv)\n{\n\tstatic int dCBWtag = 42;\t/* unique for CBW of transfer */\n\n\tDPRINTF(UDMASS_BBB,(\"%s: umass_bbb_transfer cmd=0x%02x\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), *(u_char*)cmd));\n\n\tKASSERT(sc->proto & PROTO_BBB,\n\t\t(\"sc->proto == 0x%02x wrong for umass_bbb_transfer\\n\",\n\t\tsc->proto));\n\n\t/*\n\t * Do a Bulk-Only transfer with cmdlen bytes from cmd, possibly\n\t * a data phase of datalen bytes from/to the device and finally a\n\t * csw read phase.\n\t * If the data direction was inbound a maximum of datalen bytes\n\t * is stored in the buffer pointed to by data.\n\t *\n\t * umass_bbb_transfer initialises the transfer and lets the state\n\t * machine in umass_bbb_state handle the completion. It uses the \n\t * following states:\n\t * TSTATE_BBB_COMMAND\n\t *   -> TSTATE_BBB_DATA\n\t *   -> TSTATE_BBB_STATUS\n\t *   -> TSTATE_BBB_STATUS2\n\t *   -> TSTATE_BBB_IDLE\n\t *\n\t * An error in any of those states will invoke\n\t * umass_bbb_reset.\n\t */\n\n\t/* check the given arguments */\n\tKASSERT(datalen == 0 || data != NULL,\n\t\t(\"%s: datalen > 0, but no buffer\",USBDEVNAME(sc->sc_dev)));\n\tKASSERT(cmdlen <= CBWCDBLENGTH,\n\t\t(\"%s: cmdlen exceeds CDB length in CBW (%d > %d)\",\n\t\t\tUSBDEVNAME(sc->sc_dev), cmdlen, CBWCDBLENGTH));\n\tKASSERT(dir == DIR_NONE || datalen > 0,\n\t\t(\"%s: datalen == 0 while direction is not NONE\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev)));\n\tKASSERT(datalen == 0 || dir != DIR_NONE,\n\t\t(\"%s: direction is NONE while datalen is not zero\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev)));\n\tKASSERT(sizeof(umass_bbb_cbw_t) == UMASS_BBB_CBW_SIZE,\n\t\t(\"%s: CBW struct does not have the right size (%d vs. %d)\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\tsizeof(umass_bbb_cbw_t), UMASS_BBB_CBW_SIZE));\n\tKASSERT(sizeof(umass_bbb_csw_t) == UMASS_BBB_CSW_SIZE,\n\t\t(\"%s: CSW struct does not have the right size (%d vs. %d)\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev),\n\t\t\tsizeof(umass_bbb_csw_t), UMASS_BBB_CSW_SIZE));\n\n\t/*\n\t * Determine the direction of the data transfer and the length.\n\t *\n\t * dCBWDataTransferLength (datalen) :\n\t *   This field indicates the number of bytes of data that the host\n\t *   intends to transfer on the IN or OUT Bulk endpoint(as indicated by\n\t *   the Direction bit) during the execution of this command. If this\n\t *   field is set to 0, the device will expect that no data will be\n\t *   transferred IN or OUT during this command, regardless of the value\n\t *   of the Direction bit defined in dCBWFlags.\n\t *\n\t * dCBWFlags (dir) :\n\t *   The bits of the Flags field are defined as follows:\n\t *     Bits 0-6\t reserved\n\t *     Bit  7\t Direction - this bit shall be ignored if the\n\t *\t\t\t     dCBWDataTransferLength field is zero.\n\t *\t\t 0 = data Out from host to device\n\t *\t\t 1 = data In from device to host\n\t */\n\n\t/* Fill in the Command Block Wrapper */\n\tUSETDW(sc->cbw.dCBWSignature, CBWSIGNATURE);\n\tUSETDW(sc->cbw.dCBWTag, dCBWtag);\n\tdCBWtag++;\t/* cannot be done in macro (it will be done 4 times) */\n\tUSETDW(sc->cbw.dCBWDataTransferLength, datalen);\n\t/* DIR_NONE is treated as DIR_OUT (0x00) */\n\tsc->cbw.bCBWFlags = (dir == DIR_IN? CBWFLAGS_IN:CBWFLAGS_OUT);\n\tsc->cbw.bCBWLUN = lun;\n\tsc->cbw.bCDBLength = cmdlen;\n\tbcopy(cmd, sc->cbw.CBWCDB, cmdlen);\n\n\tDIF(UDMASS_BBB, umass_bbb_dump_cbw(sc, &sc->cbw));\n\n\t/* store the details for the data transfer phase */\n\tsc->transfer_dir = dir;\n\tsc->transfer_data = data;\n\tsc->transfer_datalen = datalen;\n\tsc->transfer_actlen = 0;\n\tsc->transfer_cb = cb;\n\tsc->transfer_priv = priv;\n\tsc->transfer_status = STATUS_CMD_OK;\n\n\t/* move from idle to the command state */\n\tsc->transfer_state = TSTATE_BBB_COMMAND;\n\n\t/* Send the CBW from host to device via bulk-out endpoint. */\n\tif (umass_setup_transfer(sc, sc->bulkout_pipe,\n\t\t\t&sc->cbw, UMASS_BBB_CBW_SIZE, 0,\n\t\t\tsc->transfer_xfer[XFER_BBB_CBW])) {\n\t\tumass_bbb_reset(sc, STATUS_WIRE_FAILED);\n\t}\n}"
  },
  {
    "function_name": "umass_bbb_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "1380-1423",
    "snippet": "Static void\numass_bbb_reset(struct umass_softc *sc, int status)\n{\n\tusbd_device_handle dev;\n\n\tKASSERT(sc->proto & PROTO_BBB,\n\t\t(\"sc->proto == 0x%02x wrong for umass_bbb_reset\\n\", sc->proto));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\t/*\n\t * Reset recovery (5.3.4 in Universal Serial Bus Mass Storage Class)\n\t *\n\t * For Reset Recovery the host shall issue in the following order:\n\t * a) a Bulk-Only Mass Storage Reset\n\t * b) a Clear Feature HALT to the Bulk-In endpoint\n\t * c) a Clear Feature HALT to the Bulk-Out endpoint\n\t *\n\t * This is done in 3 steps, states:\n\t * TSTATE_BBB_RESET1\n\t * TSTATE_BBB_RESET2\n\t * TSTATE_BBB_RESET3\n\t *\n\t * If the reset doesn't succeed, the device should be port reset.\n\t */\n\n\tDPRINTF(UDMASS_BBB, (\"%s: Bulk Reset\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n\t\n\tsc->transfer_state = TSTATE_BBB_RESET1;\n\tsc->transfer_status = status;\n\n\tusbd_interface2device_handle(sc->iface, &dev);\n\n\t/* reset is a class specific interface write */\n\tsc->request.bmRequestType = UT_WRITE_CLASS_INTERFACE;\n\tsc->request.bRequest = UR_BBB_RESET;\n\tUSETW(sc->request.wValue, 0);\n\tUSETW(sc->request.wIndex, sc->ifaceno);\n\tUSETW(sc->request.wLength, 0);\n\tumass_setup_ctrl_transfer(sc, dev, &sc->request, NULL, 0, 0,\n\t\t\t\t  sc->transfer_xfer[XFER_BBB_RESET1]);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UR_BBB_RESET\t0xff\t\t/* Bulk-Only reset */",
      "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "umass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "umass_bbb_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "umass_cbi_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "Static void",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "umass_setup_ctrl_transfer",
          "args": [
            "sc",
            "dev",
            "&sc->request",
            "NULL",
            "0",
            "0",
            "sc->transfer_xfer[XFER_BBB_RESET1]"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "umass_setup_ctrl_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "1308-1335",
          "snippet": "Static usbd_status\numass_setup_ctrl_transfer(struct umass_softc *sc, usbd_device_handle dev,\n\t usb_device_request_t *req,\n\t void *buffer, int buflen, int flags,\n\t usbd_xfer_handle xfer)\n{\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\t/* Initialiase a USB control transfer and then schedule it */\n\n\tusbd_setup_default_xfer(xfer, dev, (void *) sc,\n\t    sc->timeout, req, buffer, buflen, \n\t    flags | sc->sc_xfer_flags, sc->state);\n\n\terr = usbd_transfer(xfer);\n\tif (err && err != USBD_IN_PROGRESS) {\n\t\tDPRINTF(UDMASS_BBB, (\"%s: failed to setup ctrl transfer, %s\\n\",\n\t\t\t USBDEVNAME(sc->sc_dev), usbd_errstr(err)));\n\n\t\t/* do not reset, as this would make us loop */\n\t\treturn (err);\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
          ],
          "globals_used": [
            "__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "umass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "Static usbd_status",
            "umass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));",
            "Static usbd_status",
            "umass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));",
            "Static void",
            "umass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "umass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));",
            "Static int",
            "umass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "umass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\n__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\numass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic usbd_status;\numass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic usbd_status;\numass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\numass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\numass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));\nStatic int;\numass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\numass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nint s;\n\nStatic usbd_status\numass_setup_ctrl_transfer(struct umass_softc *sc, usbd_device_handle dev,\n\t usb_device_request_t *req,\n\t void *buffer, int buflen, int flags,\n\t usbd_xfer_handle xfer)\n{\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\t/* Initialiase a USB control transfer and then schedule it */\n\n\tusbd_setup_default_xfer(xfer, dev, (void *) sc,\n\t    sc->timeout, req, buffer, buflen, \n\t    flags | sc->sc_xfer_flags, sc->state);\n\n\terr = usbd_transfer(xfer);\n\tif (err && err != USBD_IN_PROGRESS) {\n\t\tDPRINTF(UDMASS_BBB, (\"%s: failed to setup ctrl transfer, %s\\n\",\n\t\t\t USBDEVNAME(sc->sc_dev), usbd_errstr(err)));\n\n\t\t/* do not reset, as this would make us loop */\n\t\treturn (err);\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "sc->request.wLength",
            "0"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "sc->request.wIndex",
            "sc->ifaceno"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "sc->request.wValue",
            "0"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_interface2device_handle",
          "args": [
            "sc->iface",
            "&dev"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_interface2device_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "658-665",
          "snippet": "usbd_status \nusbd_interface2device_handle(iface, dev)\n\tusbd_interface_handle iface;\n\tusbd_device_handle *dev;\n{\n\t*dev = iface->device;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nusbd_status \nusbd_interface2device_handle(iface, dev)\n\tusbd_interface_handle iface;\n\tusbd_device_handle *dev;\n{\n\t*dev = iface->device;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_BBB",
            "(\"%s: Bulk Reset\\n\",\n\t\tUSBDEVNAME(sc->sc_dev))"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "sc->proto & PROTO_BBB",
            "(\"sc->proto == 0x%02x wrong for umass_bbb_reset\\n\", sc->proto)"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UR_BBB_RESET\t0xff\t\t/* Bulk-Only reset */\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\numass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\numass_bbb_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\numass_cbi_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nint s;\n\nStatic void\numass_bbb_reset(struct umass_softc *sc, int status)\n{\n\tusbd_device_handle dev;\n\n\tKASSERT(sc->proto & PROTO_BBB,\n\t\t(\"sc->proto == 0x%02x wrong for umass_bbb_reset\\n\", sc->proto));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\t/*\n\t * Reset recovery (5.3.4 in Universal Serial Bus Mass Storage Class)\n\t *\n\t * For Reset Recovery the host shall issue in the following order:\n\t * a) a Bulk-Only Mass Storage Reset\n\t * b) a Clear Feature HALT to the Bulk-In endpoint\n\t * c) a Clear Feature HALT to the Bulk-Out endpoint\n\t *\n\t * This is done in 3 steps, states:\n\t * TSTATE_BBB_RESET1\n\t * TSTATE_BBB_RESET2\n\t * TSTATE_BBB_RESET3\n\t *\n\t * If the reset doesn't succeed, the device should be port reset.\n\t */\n\n\tDPRINTF(UDMASS_BBB, (\"%s: Bulk Reset\\n\",\n\t\tUSBDEVNAME(sc->sc_dev)));\n\t\n\tsc->transfer_state = TSTATE_BBB_RESET1;\n\tsc->transfer_status = status;\n\n\tusbd_interface2device_handle(sc->iface, &dev);\n\n\t/* reset is a class specific interface write */\n\tsc->request.bmRequestType = UT_WRITE_CLASS_INTERFACE;\n\tsc->request.bRequest = UR_BBB_RESET;\n\tUSETW(sc->request.wValue, 0);\n\tUSETW(sc->request.wIndex, sc->ifaceno);\n\tUSETW(sc->request.wLength, 0);\n\tumass_setup_ctrl_transfer(sc, dev, &sc->request, NULL, 0, 0,\n\t\t\t\t  sc->transfer_xfer[XFER_BBB_RESET1]);\n}"
  },
  {
    "function_name": "umass_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "1365-1373",
    "snippet": "Static void\numass_reset(struct umass_softc *sc, transfer_cb_f cb, void *priv)\n{\n\tsc->transfer_cb = cb;\n\tsc->transfer_priv = priv;\n\n\t/* The reset is a forced reset, so no error (yet) */\n\tsc->reset(sc, STATUS_CMD_OK);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define STATUS_CMD_OK\t\t0\t/* everything ok */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "Static void",
      "umass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "umass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));",
      "Static void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->reset",
          "args": [
            "sc",
            "STATUS_CMD_OK"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define STATUS_CMD_OK\t\t0\t/* everything ok */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\numass_bbb_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\numass_cbi_transfer\t__P((struct umass_softc *sc, int lun,\n\t\t\t\tvoid *cmd, int cmdlen,\n\t\t\t\tvoid *data, int datalen, int dir,\n\t\t\t\ttransfer_cb_f cb, void *priv));\nStatic void;\n\nStatic void\numass_reset(struct umass_softc *sc, transfer_cb_f cb, void *priv)\n{\n\tsc->transfer_cb = cb;\n\tsc->transfer_priv = priv;\n\n\t/* The reset is a forced reset, so no error (yet) */\n\tsc->reset(sc, STATUS_CMD_OK);\n}"
  },
  {
    "function_name": "umass_clear_endpoint_stall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "1337-1362",
    "snippet": "Static void\numass_clear_endpoint_stall(struct umass_softc *sc,\n\tu_int8_t endpt, usbd_pipe_handle pipe,\n\tint state, usbd_xfer_handle xfer)\n{\n\tusbd_device_handle dev;\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\tDPRINTF(UDMASS_BBB, (\"%s: Clear endpoint 0x%02x stall\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), endpt));\n\n\tusbd_interface2device_handle(sc->iface, &dev);\n\n\tsc->transfer_state = state;\n\n\tusbd_clear_endpoint_toggle(pipe);\n\n\tsc->request.bmRequestType = UT_WRITE_ENDPOINT;\n\tsc->request.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(sc->request.wValue, UF_ENDPOINT_HALT);\n\tUSETW(sc->request.wIndex, endpt);\n\tUSETW(sc->request.wLength, 0);\n\tumass_setup_ctrl_transfer(sc, dev, &sc->request, NULL, 0, 0, xfer);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "umass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "umass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));",
      "umass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));",
      "Static void",
      "umass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "umass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "umass_setup_ctrl_transfer",
          "args": [
            "sc",
            "dev",
            "&sc->request",
            "NULL",
            "0",
            "0",
            "xfer"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "umass_setup_ctrl_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "1308-1335",
          "snippet": "Static usbd_status\numass_setup_ctrl_transfer(struct umass_softc *sc, usbd_device_handle dev,\n\t usb_device_request_t *req,\n\t void *buffer, int buflen, int flags,\n\t usbd_xfer_handle xfer)\n{\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\t/* Initialiase a USB control transfer and then schedule it */\n\n\tusbd_setup_default_xfer(xfer, dev, (void *) sc,\n\t    sc->timeout, req, buffer, buflen, \n\t    flags | sc->sc_xfer_flags, sc->state);\n\n\terr = usbd_transfer(xfer);\n\tif (err && err != USBD_IN_PROGRESS) {\n\t\tDPRINTF(UDMASS_BBB, (\"%s: failed to setup ctrl transfer, %s\\n\",\n\t\t\t USBDEVNAME(sc->sc_dev), usbd_errstr(err)));\n\n\t\t/* do not reset, as this would make us loop */\n\t\treturn (err);\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
          ],
          "globals_used": [
            "__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
            "Static void",
            "umass_disco\t\t__P((struct umass_softc *sc));",
            "Static int",
            "umass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));",
            "Static void",
            "umass_init_shuttle\t__P((struct umass_softc *sc));",
            "Static usbd_status",
            "umass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));",
            "Static usbd_status",
            "umass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));",
            "Static void",
            "umass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "umass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));",
            "Static int",
            "umass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "umass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\n__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\numass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic usbd_status;\numass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic usbd_status;\numass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\numass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\numass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));\nStatic int;\numass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\numass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nint s;\n\nStatic usbd_status\numass_setup_ctrl_transfer(struct umass_softc *sc, usbd_device_handle dev,\n\t usb_device_request_t *req,\n\t void *buffer, int buflen, int flags,\n\t usbd_xfer_handle xfer)\n{\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\t/* Initialiase a USB control transfer and then schedule it */\n\n\tusbd_setup_default_xfer(xfer, dev, (void *) sc,\n\t    sc->timeout, req, buffer, buflen, \n\t    flags | sc->sc_xfer_flags, sc->state);\n\n\terr = usbd_transfer(xfer);\n\tif (err && err != USBD_IN_PROGRESS) {\n\t\tDPRINTF(UDMASS_BBB, (\"%s: failed to setup ctrl transfer, %s\\n\",\n\t\t\t USBDEVNAME(sc->sc_dev), usbd_errstr(err)));\n\n\t\t/* do not reset, as this would make us loop */\n\t\treturn (err);\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "sc->request.wLength",
            "0"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "sc->request.wIndex",
            "endpt"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "sc->request.wValue",
            "UF_ENDPOINT_HALT"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_clear_endpoint_toggle",
          "args": [
            "pipe"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_clear_endpoint_toggle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "631-636",
          "snippet": "void\nusbd_clear_endpoint_toggle(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tpipe->methods->cleartoggle(pipe);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_clear_endpoint_toggle(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tpipe->methods->cleartoggle(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_interface2device_handle",
          "args": [
            "sc->iface",
            "&dev"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_interface2device_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "658-665",
          "snippet": "usbd_status \nusbd_interface2device_handle(iface, dev)\n\tusbd_interface_handle iface;\n\tusbd_device_handle *dev;\n{\n\t*dev = iface->device;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nusbd_status \nusbd_interface2device_handle(iface, dev)\n\tusbd_interface_handle iface;\n\tusbd_device_handle *dev;\n{\n\t*dev = iface->device;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_BBB",
            "(\"%s: Clear endpoint 0x%02x stall\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), endpt)"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\numass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\numass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));\numass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\numass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic int;\numass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nint s;\n\nStatic void\numass_clear_endpoint_stall(struct umass_softc *sc,\n\tu_int8_t endpt, usbd_pipe_handle pipe,\n\tint state, usbd_xfer_handle xfer)\n{\n\tusbd_device_handle dev;\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\tDPRINTF(UDMASS_BBB, (\"%s: Clear endpoint 0x%02x stall\\n\",\n\t\tUSBDEVNAME(sc->sc_dev), endpt));\n\n\tusbd_interface2device_handle(sc->iface, &dev);\n\n\tsc->transfer_state = state;\n\n\tusbd_clear_endpoint_toggle(pipe);\n\n\tsc->request.bmRequestType = UT_WRITE_ENDPOINT;\n\tsc->request.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(sc->request.wValue, UF_ENDPOINT_HALT);\n\tUSETW(sc->request.wIndex, endpt);\n\tUSETW(sc->request.wLength, 0);\n\tumass_setup_ctrl_transfer(sc, dev, &sc->request, NULL, 0, 0, xfer);\n}"
  },
  {
    "function_name": "umass_setup_ctrl_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "1308-1335",
    "snippet": "Static usbd_status\numass_setup_ctrl_transfer(struct umass_softc *sc, usbd_device_handle dev,\n\t usb_device_request_t *req,\n\t void *buffer, int buflen, int flags,\n\t usbd_xfer_handle xfer)\n{\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\t/* Initialiase a USB control transfer and then schedule it */\n\n\tusbd_setup_default_xfer(xfer, dev, (void *) sc,\n\t    sc->timeout, req, buffer, buflen, \n\t    flags | sc->sc_xfer_flags, sc->state);\n\n\terr = usbd_transfer(xfer);\n\tif (err && err != USBD_IN_PROGRESS) {\n\t\tDPRINTF(UDMASS_BBB, (\"%s: failed to setup ctrl transfer, %s\\n\",\n\t\t\t USBDEVNAME(sc->sc_dev), usbd_errstr(err)));\n\n\t\t/* do not reset, as this would make us loop */\n\t\treturn (err);\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
    ],
    "globals_used": [
      "__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "umass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static usbd_status",
      "umass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));",
      "Static usbd_status",
      "umass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));",
      "Static void",
      "umass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "umass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));",
      "Static int",
      "umass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "umass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_BBB",
            "(\"%s: failed to setup ctrl transfer, %s\\n\",\n\t\t\t USBDEVNAME(sc->sc_dev), usbd_errstr(err))"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "xfer"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_default_xfer",
          "args": [
            "xfer",
            "dev",
            "(void *) sc",
            "sc->timeout",
            "req",
            "buffer",
            "buflen",
            "flags | sc->sc_xfer_flags",
            "sc->state"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_default_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "446-473",
          "snippet": "void\nusbd_setup_default_xfer(xfer, dev, priv, timeout, req, buffer, \n\t\t\t   length, flags, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_device_handle dev;\n\tusbd_private_handle priv;\n\tu_int32_t timeout;\n\tusb_device_request_t *req;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = dev->default_pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->request = *req;\n\txfer->rqflags |= URQ_REQUEST;\n\txfer->nframes = 0;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nvoid\nusbd_setup_default_xfer(xfer, dev, priv, timeout, req, buffer, \n\t\t\t   length, flags, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_device_handle dev;\n\tusbd_private_handle priv;\n\tu_int32_t timeout;\n\tusb_device_request_t *req;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = dev->default_pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->request = *req;\n\txfer->rqflags |= URQ_REQUEST;\n\txfer->nframes = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\n__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\numass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic usbd_status;\numass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic usbd_status;\numass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\numass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\numass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));\nStatic int;\numass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\numass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nint s;\n\nStatic usbd_status\numass_setup_ctrl_transfer(struct umass_softc *sc, usbd_device_handle dev,\n\t usb_device_request_t *req,\n\t void *buffer, int buflen, int flags,\n\t usbd_xfer_handle xfer)\n{\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\t/* Initialiase a USB control transfer and then schedule it */\n\n\tusbd_setup_default_xfer(xfer, dev, (void *) sc,\n\t    sc->timeout, req, buffer, buflen, \n\t    flags | sc->sc_xfer_flags, sc->state);\n\n\terr = usbd_transfer(xfer);\n\tif (err && err != USBD_IN_PROGRESS) {\n\t\tDPRINTF(UDMASS_BBB, (\"%s: failed to setup ctrl transfer, %s\\n\",\n\t\t\t USBDEVNAME(sc->sc_dev), usbd_errstr(err)));\n\n\t\t/* do not reset, as this would make us loop */\n\t\treturn (err);\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "umass_setup_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "1279-1305",
    "snippet": "Static usbd_status\numass_setup_transfer(struct umass_softc *sc, usbd_pipe_handle pipe,\n\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\tusbd_xfer_handle xfer)\n{\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\t/* Initialiase a USB transfer and then schedule it */\n\n\tusbd_setup_xfer(xfer, pipe, (void *)sc, buffer, buflen,\n\t    flags | sc->sc_xfer_flags, sc->timeout, sc->state);\n\n\terr = usbd_transfer(xfer);\n\tDPRINTF(UDMASS_XFER,(\"%s: start xfer buffer=%p buflen=%d flags=0x%x \"\n\t    \"timeout=%d\\n\", USBDEVNAME(sc->sc_dev),\n\t    buffer, buflen, flags | sc->sc_xfer_flags, sc->timeout));\n\tif (err && err != USBD_IN_PROGRESS) {\n\t\tDPRINTF(UDMASS_BBB, (\"%s: failed to setup transfer, %s\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), usbd_errstr(err)));\n\t\treturn (err);\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UDMASS_XFER\t0x40000000\t/* all transfers */",
      "#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */"
    ],
    "globals_used": [
      "__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static usbd_status",
      "umass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));",
      "Static usbd_status",
      "umass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));",
      "Static void",
      "umass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "umass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));",
      "Static int",
      "umass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "umass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_BBB",
            "(\"%s: failed to setup transfer, %s\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), usbd_errstr(err))"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_XFER",
            "(\"%s: start xfer buffer=%p buflen=%d flags=0x%x \"\n\t    \"timeout=%d\\n\", USBDEVNAME(sc->sc_dev),\n\t    buffer, buflen, flags | sc->sc_xfer_flags, sc->timeout)"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "xfer"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_xfer",
          "args": [
            "xfer",
            "pipe",
            "(void *)sc",
            "buffer",
            "buflen",
            "flags | sc->sc_xfer_flags",
            "sc->timeout",
            "sc->state"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "420-444",
          "snippet": "void\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_XFER\t0x40000000\t/* all transfers */\n#define UDMASS_BBB\t0x00200000\t/* Bulk-Only transfers */\n\n__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic usbd_status;\numass_setup_transfer __P((struct umass_softc *sc,\n\t\t\t\tusbd_pipe_handle pipe,\n\t\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic usbd_status;\numass_setup_ctrl_transfer\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_device_handle dev,\n\t\t\t\tusb_device_request_t *req,\n\t\t\t\tvoid *buffer, int buflen, int flags, \n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\numass_clear_endpoint_stall\t__P((struct umass_softc *sc,\n\t\t\t\tu_int8_t endpt, usbd_pipe_handle pipe,\n\t\t\t\tint state, usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\numass_bbb_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv,\n\t\t\t\tusbd_status err));\nStatic int;\numass_cbi_adsc\t__P((struct umass_softc *sc, char *buffer,int buflen,\n\t\t\t\tusbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\numass_cbi_state\t__P((usbd_xfer_handle xfer,\n\t\t\t\tusbd_private_handle priv, usbd_status err));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nint s;\n\nStatic usbd_status\numass_setup_transfer(struct umass_softc *sc, usbd_pipe_handle pipe,\n\t\t\tvoid *buffer, int buflen, int flags,\n\t\t\tusbd_xfer_handle xfer)\n{\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\t/* Initialiase a USB transfer and then schedule it */\n\n\tusbd_setup_xfer(xfer, pipe, (void *)sc, buffer, buflen,\n\t    flags | sc->sc_xfer_flags, sc->timeout, sc->state);\n\n\terr = usbd_transfer(xfer);\n\tDPRINTF(UDMASS_XFER,(\"%s: start xfer buffer=%p buflen=%d flags=0x%x \"\n\t    \"timeout=%d\\n\", USBDEVNAME(sc->sc_dev),\n\t    buffer, buflen, flags | sc->sc_xfer_flags, sc->timeout));\n\tif (err && err != USBD_IN_PROGRESS) {\n\t\tDPRINTF(UDMASS_BBB, (\"%s: failed to setup transfer, %s\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), usbd_errstr(err)));\n\t\treturn (err);\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "umass_init_shuttle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "1260-1273",
    "snippet": "Static void\numass_init_shuttle(struct umass_softc *sc)\n{\n\tusb_device_request_t req;\n\tu_char status[2];\n\n\t/* The Linux driver does this */\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = 1;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, sc->ifaceno);\n\tUSETW(req.wLength, sizeof status);\n\t(void)usbd_do_request(sc->sc_udev, &req, &status);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "umass_bbb_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "umass_cbi_reset\t__P((struct umass_softc *sc, int status));",
      "Static void",
      "Static void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_do_request",
          "args": [
            "sc->sc_udev",
            "&req",
            "&status"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_do_request_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1059-1079",
          "snippet": "usbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "sizeof status"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "sc->ifaceno"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "0"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\numass_bbb_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\numass_cbi_reset\t__P((struct umass_softc *sc, int status));\nStatic void;\nStatic void;\n\nStatic void\numass_init_shuttle(struct umass_softc *sc)\n{\n\tusb_device_request_t req;\n\tu_char status[2];\n\n\t/* The Linux driver does this */\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = 1;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, sc->ifaceno);\n\tUSETW(req.wLength, sizeof status);\n\t(void)usbd_do_request(sc->sc_udev, &req, &status);\n}"
  },
  {
    "function_name": "umass_disco",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "1236-1258",
    "snippet": "Static void\numass_disco(sc)\n\tstruct umass_softc *sc;\n{ \n\tint i;\n\n\tDPRINTF(UDMASS_GEN, (\"umass_disco\\n\"));\n\n\t/* Free the xfers. */\n\tfor (i = 0; i < XFER_NR; i++)\n\t\tif (sc->transfer_xfer[i] != NULL) {\n\t\t\tusbd_free_xfer(sc->transfer_xfer[i]);\n\t\t\tsc->transfer_xfer[i] = NULL;\n\t\t}\n\n\t/* Remove all the pipes. */\n\tif (sc->bulkout_pipe != NULL)\n\t\tusbd_close_pipe(sc->bulkout_pipe);\n\tif (sc->bulkin_pipe != NULL)\n\t\tusbd_close_pipe(sc->bulkin_pipe);\n\tif (sc->intrin_pipe != NULL)\n\t\tusbd_close_pipe(sc->intrin_pipe);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UDMASS_GEN\t0x00010000\t/* general */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_close_pipe",
          "args": [
            "sc->intrin_pipe"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_close_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "224-252",
          "snippet": "usbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_free_xfer",
          "args": [
            "sc->transfer_xfer[i]"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "403-418",
          "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_GEN",
            "(\"umass_disco\\n\")"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_GEN\t0x00010000\t/* general */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\n\nStatic void\numass_disco(sc)\n\tstruct umass_softc *sc;\n{ \n\tint i;\n\n\tDPRINTF(UDMASS_GEN, (\"umass_disco\\n\"));\n\n\t/* Free the xfers. */\n\tfor (i = 0; i < XFER_NR; i++)\n\t\tif (sc->transfer_xfer[i] != NULL) {\n\t\t\tusbd_free_xfer(sc->transfer_xfer[i]);\n\t\t\tsc->transfer_xfer[i] = NULL;\n\t\t}\n\n\t/* Remove all the pipes. */\n\tif (sc->bulkout_pipe != NULL)\n\t\tusbd_close_pipe(sc->bulkout_pipe);\n\tif (sc->bulkin_pipe != NULL)\n\t\tusbd_close_pipe(sc->bulkin_pipe);\n\tif (sc->intrin_pipe != NULL)\n\t\tusbd_close_pipe(sc->intrin_pipe);\n}"
  },
  {
    "function_name": "umass_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "1206-1233",
    "snippet": "int\numass_activate(self, act)\n\tstruct device *self;\n\tenum devact act;\n{\n\tstruct umass_softc *sc = (struct umass_softc *) self;\n\tint rv = 0;\n\n\tDPRINTF(UDMASS_USB, (\"%s: umass_activate: %d\\n\",\n\t    USBDEVNAME(sc->sc_dev), act));\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\trv = EOPNOTSUPP;\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tif (sc->sc_child != NULL)\n\t\t\tbreak;\n\t\trv = config_deactivate(sc->sc_child);\n\t\tDPRINTF(UDMASS_USB, (\"%s: umass_activate: child \"\n\t\t    \"returned %d\\n\", USBDEVNAME(sc->sc_dev), rv));\n\t\tif (rv == 0)\n\t\t\tsc->sc_dying = 1;\n\t\tbreak;\n\t}\n\treturn (rv);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UDMASS_USB\t0x00100000\t/* USB general */"
    ],
    "globals_used": [
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_USB",
            "(\"%s: umass_activate: child \"\n\t\t    \"returned %d\\n\", USBDEVNAME(sc->sc_dev), rv)"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_deactivate",
          "args": [
            "sc->sc_child"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_USB",
            "(\"%s: umass_activate: %d\\n\",\n\t    USBDEVNAME(sc->sc_dev), act)"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UDMASS_USB\t0x00100000\t/* USB general */\n\numass_disco\t\t__P((struct umass_softc *sc));\numass_init_shuttle\t__P((struct umass_softc *sc));\nint s;\n\nint\numass_activate(self, act)\n\tstruct device *self;\n\tenum devact act;\n{\n\tstruct umass_softc *sc = (struct umass_softc *) self;\n\tint rv = 0;\n\n\tDPRINTF(UDMASS_USB, (\"%s: umass_activate: %d\\n\",\n\t    USBDEVNAME(sc->sc_dev), act));\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\trv = EOPNOTSUPP;\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tif (sc->sc_child != NULL)\n\t\t\tbreak;\n\t\trv = config_deactivate(sc->sc_child);\n\t\tDPRINTF(UDMASS_USB, (\"%s: umass_activate: child \"\n\t\t    \"returned %d\\n\", USBDEVNAME(sc->sc_dev), rv));\n\t\tif (rv == 0)\n\t\t\tsc->sc_dying = 1;\n\t\tbreak;\n\t}\n\treturn (rv);\n}"
  },
  {
    "function_name": "scsipiprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "1141-1157",
    "snippet": "Static int\nscsipiprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n#if !defined(__OpenBSD__)\n\textern int atapi_print __P((void *aux, const char *pnp));\n\tstruct scsipi_link *l = aux;\n\n\tif (l->type == BUS_SCSI)\n\t\treturn (scsiprint(aux, pnp));\n\telse\n\t\treturn (atapi_print(aux, pnp));\n#else\n\treturn (scsiprint(aux, pnp));\n#endif\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scsiprint",
          "args": [
            "aux",
            "pnp"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atapi_print",
          "args": [
            "aux",
            "pnp"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "atapi_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "295-305",
          "snippet": "int\natapi_print(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\tstruct ata_atapi_attach *aa_link = aux;\n\tif (pnp)\n\t\tprintf(\"atapibus at %s\", pnp);\n\tprintf(\" channel %d\", aa_link->aa_channel);\n\treturn (UNCONF);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\natapi_print(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\tstruct ata_atapi_attach *aa_link = aux;\n\tif (pnp)\n\t\tprintf(\"atapibus at %s\", pnp);\n\tprintf(\" channel %d\", aa_link->aa_channel);\n\treturn (UNCONF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scsiprint",
          "args": [
            "aux",
            "pnp"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__P",
          "args": [
            "(void *aux, const char *pnp)"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\n\nStatic int\nscsipiprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n#if !defined(__OpenBSD__)\n\textern int atapi_print __P((void *aux, const char *pnp));\n\tstruct scsipi_link *l = aux;\n\n\tif (l->type == BUS_SCSI)\n\t\treturn (scsiprint(aux, pnp));\n\telse\n\t\treturn (atapi_print(aux, pnp));\n#else\n\treturn (scsiprint(aux, pnp));\n#endif\n}"
  },
  {
    "function_name": "umass_match_proto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
    "lines": "657-767",
    "snippet": "Static int\numass_match_proto(sc, iface, dev)\n\tstruct umass_softc *sc;\n\tusbd_interface_handle iface;\n\tusbd_device_handle dev;\n{\n\tusb_device_descriptor_t *dd;\n\tusb_interface_descriptor_t *id;\n\n\t/*\n\t * Fill in sc->drive and sc->proto and return a match\n\t * value if both are determined and 0 otherwise.\n\t */\n\n\tsc->drive = DRIVE_GENERIC;\n\tsc->proto = PROTO_UNKNOWN;\n\tsc->transfer_speed = UMASS_DEFAULT_TRANSFER_SPEED;\n\n\tsc->sc_udev = dev;\n\tdd = usbd_get_device_descriptor(dev);\n\n\tif (UGETW(dd->idVendor) == USB_VENDOR_SHUTTLE\n\t    && UGETW(dd->idProduct) == USB_PRODUCT_SHUTTLE_EUSB) {\n\t\tsc->drive = SHUTTLE_EUSB;\n#if CBI_I\n\t\tsc->proto = PROTO_8070 | PROTO_CBI_I;\n#else\n\t\tsc->proto = PROTO_8070 | PROTO_CBI;\n#endif\n\t\tsc->quirks |= NO_TEST_UNIT_READY | NO_START_STOP;\n\t\treturn (UMATCH_VENDOR_PRODUCT);\n\t}\n\n\tif (UGETW(dd->idVendor) == USB_VENDOR_YEDATA\n\t    && UGETW(dd->idProduct) == USB_PRODUCT_YEDATA_FLASHBUSTERU) {\n\n\t\t/* Revisions < 1.28 do not handle the interrupt endpoint\n\t\t * very well.\n\t\t */\n\t\tif (UGETW(dd->bcdDevice) < 0x128)\n\t\t\tsc->proto = PROTO_UFI | PROTO_CBI;\n\t\telse\n#if CBI_I\n\t\t\tsc->proto = PROTO_UFI | PROTO_CBI_I;\n#else\n\t\t\tsc->proto = PROTO_UFI | PROTO_CBI;\n#endif\n\t\t/*\n\t\t * Revisions < 1.28 do not have the TEST UNIT READY command\n\t\t * Revisions == 1.28 have a broken TEST UNIT READY\n\t\t */\n\t\tif (UGETW(dd->bcdDevice) <= 0x128)\n\t\t\tsc->quirks |= NO_TEST_UNIT_READY;\n\n\t\tsc->quirks |= RS_NO_CLEAR_UA;\n\t\tsc->transfer_speed = UMASS_FLOPPY_TRANSFER_SPEED;\n\t\treturn (UMATCH_VENDOR_PRODUCT_REV);\n\t}\n\n\n\tid = usbd_get_interface_descriptor(iface);\n\tif (id == NULL || id->bInterfaceClass != UICLASS_MASS)\n\t\treturn (UMATCH_NONE);\n\n\tswitch (id->bInterfaceSubClass) {\n\tcase UISUBCLASS_SCSI:\n\t\tsc->proto |= PROTO_SCSI;\n\t\tbreak;\n\tcase UISUBCLASS_UFI:\n\t\tsc->transfer_speed = UMASS_FLOPPY_TRANSFER_SPEED;\n\t\tsc->proto |= PROTO_UFI;\n\t\tbreak;\n\tcase UISUBCLASS_SFF8020I:\n\tcase UISUBCLASS_SFF8070I:\n\tcase UISUBCLASS_QIC157:\n\t\tsc->proto |= PROTO_8070;\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF(UDMASS_GEN, (\"%s: Unsupported command protocol %d\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), id->bInterfaceSubClass));\n\t\treturn (UMATCH_NONE);\n\t}\n\n\tswitch (id->bInterfaceProtocol) {\n\tcase UIPROTO_MASS_CBI:\n\t\tsc->proto |= PROTO_CBI;\n\t\tbreak;\n\tcase UIPROTO_MASS_CBI_I:\n#if CBI_I\n\t\tsc->proto |= PROTO_CBI_I;\n#else\n\t\tsc->proto |= PROTO_CBI;\n#endif\n\t\tbreak;\n\tcase UIPROTO_MASS_BBB:\n\t\tsc->proto |= PROTO_BBB;\n\t\tbreak;\n\tcase UIPROTO_MASS_BBB_P:\n\t\tsc->drive = ZIP_100;\n\t\tsc->proto |= PROTO_BBB;\n\t\tsc->transfer_speed = UMASS_ZIP100_TRANSFER_SPEED;\n\t\tsc->quirks |= NO_TEST_UNIT_READY;\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF(UDMASS_GEN, (\"%s: Unsupported wire protocol %d\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), id->bInterfaceProtocol));\n\t\treturn (UMATCH_NONE);\n\t}\n\n\treturn (UMATCH_DEVCLASS_DEVSUBCLASS_DEVPROTO);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/ata/atavar.h>\t/* XXX */",
      "#include <dev/scsipi/scsi_changer.h>",
      "#include <dev/scsipi/scsi_disk.h>",
      "#include <dev/scsipi/scsipi_disk.h>",
      "#include <dev/scsipi/atapiconf.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <sys/scsiio.h>",
      "#include <cam/cam_periph.h>",
      "#include <sys/devicestat.h>",
      "#include <cam/scsi/scsi_da.h>",
      "#include <cam/scsi/scsi_all.h>",
      "#include <cam/cam_xpt_sim.h>",
      "#include <cam/cam_sim.h>",
      "#include <cam/cam_ccb.h>",
      "#include <cam/cam.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/clock.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"atapibus.h\""
    ],
    "macros_used": [
      "#define UMASS_ZIP100_TRANSFER_SPEED\t650",
      "#define UMASS_FLOPPY_TRANSFER_SPEED\t20",
      "#define UMASS_DEFAULT_TRANSFER_SPEED\t150\t/* in kb/s, conservative est. */",
      "#define UDMASS_GEN\t0x00010000\t/* general */"
    ],
    "globals_used": [
      "Static void",
      "umass_disco\t\t__P((struct umass_softc *sc));",
      "Static int",
      "umass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));",
      "Static void",
      "umass_init_shuttle\t__P((struct umass_softc *sc));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_GEN",
            "(\"%s: Unsupported wire protocol %d\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), id->bInterfaceProtocol)"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "UDMASS_GEN",
            "(\"%s: Unsupported command protocol %d\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), id->bInterfaceSubClass)"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_interface_descriptor",
          "args": [
            "iface"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "dd->bcdDevice"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "dd->bcdDevice"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "dd->idProduct"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "dd->idVendor"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "dd->idProduct"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "dd->idVendor"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_device_descriptor",
          "args": [
            "dev"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UMASS_ZIP100_TRANSFER_SPEED\t650\n#define UMASS_FLOPPY_TRANSFER_SPEED\t20\n#define UMASS_DEFAULT_TRANSFER_SPEED\t150\t/* in kb/s, conservative est. */\n#define UDMASS_GEN\t0x00010000\t/* general */\n\nStatic void;\numass_disco\t\t__P((struct umass_softc *sc));\nStatic int;\numass_match_proto\t__P((struct umass_softc *sc,\n\t\t\t\tusbd_interface_handle iface,\n\t\t\t\tusbd_device_handle dev));\nStatic void;\numass_init_shuttle\t__P((struct umass_softc *sc));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nint s;\n\nStatic int\numass_match_proto(sc, iface, dev)\n\tstruct umass_softc *sc;\n\tusbd_interface_handle iface;\n\tusbd_device_handle dev;\n{\n\tusb_device_descriptor_t *dd;\n\tusb_interface_descriptor_t *id;\n\n\t/*\n\t * Fill in sc->drive and sc->proto and return a match\n\t * value if both are determined and 0 otherwise.\n\t */\n\n\tsc->drive = DRIVE_GENERIC;\n\tsc->proto = PROTO_UNKNOWN;\n\tsc->transfer_speed = UMASS_DEFAULT_TRANSFER_SPEED;\n\n\tsc->sc_udev = dev;\n\tdd = usbd_get_device_descriptor(dev);\n\n\tif (UGETW(dd->idVendor) == USB_VENDOR_SHUTTLE\n\t    && UGETW(dd->idProduct) == USB_PRODUCT_SHUTTLE_EUSB) {\n\t\tsc->drive = SHUTTLE_EUSB;\n#if CBI_I\n\t\tsc->proto = PROTO_8070 | PROTO_CBI_I;\n#else\n\t\tsc->proto = PROTO_8070 | PROTO_CBI;\n#endif\n\t\tsc->quirks |= NO_TEST_UNIT_READY | NO_START_STOP;\n\t\treturn (UMATCH_VENDOR_PRODUCT);\n\t}\n\n\tif (UGETW(dd->idVendor) == USB_VENDOR_YEDATA\n\t    && UGETW(dd->idProduct) == USB_PRODUCT_YEDATA_FLASHBUSTERU) {\n\n\t\t/* Revisions < 1.28 do not handle the interrupt endpoint\n\t\t * very well.\n\t\t */\n\t\tif (UGETW(dd->bcdDevice) < 0x128)\n\t\t\tsc->proto = PROTO_UFI | PROTO_CBI;\n\t\telse\n#if CBI_I\n\t\t\tsc->proto = PROTO_UFI | PROTO_CBI_I;\n#else\n\t\t\tsc->proto = PROTO_UFI | PROTO_CBI;\n#endif\n\t\t/*\n\t\t * Revisions < 1.28 do not have the TEST UNIT READY command\n\t\t * Revisions == 1.28 have a broken TEST UNIT READY\n\t\t */\n\t\tif (UGETW(dd->bcdDevice) <= 0x128)\n\t\t\tsc->quirks |= NO_TEST_UNIT_READY;\n\n\t\tsc->quirks |= RS_NO_CLEAR_UA;\n\t\tsc->transfer_speed = UMASS_FLOPPY_TRANSFER_SPEED;\n\t\treturn (UMATCH_VENDOR_PRODUCT_REV);\n\t}\n\n\n\tid = usbd_get_interface_descriptor(iface);\n\tif (id == NULL || id->bInterfaceClass != UICLASS_MASS)\n\t\treturn (UMATCH_NONE);\n\n\tswitch (id->bInterfaceSubClass) {\n\tcase UISUBCLASS_SCSI:\n\t\tsc->proto |= PROTO_SCSI;\n\t\tbreak;\n\tcase UISUBCLASS_UFI:\n\t\tsc->transfer_speed = UMASS_FLOPPY_TRANSFER_SPEED;\n\t\tsc->proto |= PROTO_UFI;\n\t\tbreak;\n\tcase UISUBCLASS_SFF8020I:\n\tcase UISUBCLASS_SFF8070I:\n\tcase UISUBCLASS_QIC157:\n\t\tsc->proto |= PROTO_8070;\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF(UDMASS_GEN, (\"%s: Unsupported command protocol %d\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), id->bInterfaceSubClass));\n\t\treturn (UMATCH_NONE);\n\t}\n\n\tswitch (id->bInterfaceProtocol) {\n\tcase UIPROTO_MASS_CBI:\n\t\tsc->proto |= PROTO_CBI;\n\t\tbreak;\n\tcase UIPROTO_MASS_CBI_I:\n#if CBI_I\n\t\tsc->proto |= PROTO_CBI_I;\n#else\n\t\tsc->proto |= PROTO_CBI;\n#endif\n\t\tbreak;\n\tcase UIPROTO_MASS_BBB:\n\t\tsc->proto |= PROTO_BBB;\n\t\tbreak;\n\tcase UIPROTO_MASS_BBB_P:\n\t\tsc->drive = ZIP_100;\n\t\tsc->proto |= PROTO_BBB;\n\t\tsc->transfer_speed = UMASS_ZIP100_TRANSFER_SPEED;\n\t\tsc->quirks |= NO_TEST_UNIT_READY;\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF(UDMASS_GEN, (\"%s: Unsupported wire protocol %d\\n\",\n\t\t\tUSBDEVNAME(sc->sc_dev), id->bInterfaceProtocol));\n\t\treturn (UMATCH_NONE);\n\t}\n\n\treturn (UMATCH_DEVCLASS_DEVSUBCLASS_DEVPROTO);\n}"
  }
]