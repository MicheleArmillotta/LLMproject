[
  {
    "function_name": "tcic_isa_chip_intr_disestablish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/tcic2_isa.c",
    "lines": "357-375",
    "snippet": "void \ntcic_isa_chip_intr_disestablish(pch, ih)\n\tpcmcia_chipset_handle_t pch;\n\tvoid *ih;\n{\n\tstruct tcic_handle *h = (struct tcic_handle *) pch;\n\tint val, reg;\n\n\tDPRINTF((\"%s: tcic_isa_chip_intr_disestablish\\n\", h->sc->dev.dv_xname));\n\n\th->ih_irq = 0;\n\n\treg = TCIC_IR_SCF1_N(h->sock);\n\tval = tcic_read_ind_2(h, reg);\n\tval &= ~TCIC_SCF1_IRQ_MASK;\n\ttcic_write_ind_2(h, reg, val);\n\n\tisa_intr_disestablish(h->sc->intr_est, ih);\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isa_intr_disestablish",
          "args": [
            "h->sc->intr_est",
            "ih"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_write_ind_2",
          "args": [
            "h",
            "reg",
            "val"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_write_ind_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "262-273",
          "snippet": "static __inline__ void\ntcic_write_ind_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tint r_addr;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA, (data));\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_write_ind_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tint r_addr;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA, (data));\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_read_ind_2",
          "args": [
            "h",
            "reg"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_read_ind_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "248-259",
          "snippet": "static __inline__ int\ntcic_read_ind_2(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\tint r_addr, val;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tval = bus_space_read_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA);\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n\treturn val;\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ int\ntcic_read_ind_2(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\tint r_addr, val;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tval = bus_space_read_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA);\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_IR_SCF1_N",
          "args": [
            "h->sock"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: tcic_isa_chip_intr_disestablish\\n\", h->sc->dev.dv_xname)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid \ntcic_isa_chip_intr_disestablish(pch, ih)\n\tpcmcia_chipset_handle_t pch;\n\tvoid *ih;\n{\n\tstruct tcic_handle *h = (struct tcic_handle *) pch;\n\tint val, reg;\n\n\tDPRINTF((\"%s: tcic_isa_chip_intr_disestablish\\n\", h->sc->dev.dv_xname));\n\n\th->ih_irq = 0;\n\n\treg = TCIC_IR_SCF1_N(h->sock);\n\tval = tcic_read_ind_2(h, reg);\n\tval &= ~TCIC_SCF1_IRQ_MASK;\n\ttcic_write_ind_2(h, reg, val);\n\n\tisa_intr_disestablish(h->sc->intr_est, ih);\n}"
  },
  {
    "function_name": "tcic_isa_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/tcic2_isa.c",
    "lines": "193-308",
    "snippet": "void\ntcic_isa_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct tcic_softc *sc = (void *) self;\n\tstruct isa_attach_args *ia = aux;\n\tisa_chipset_tag_t ic = ia->ia_ic;\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_tag_t memt = ia->ia_memt;\n\tbus_space_handle_t ioh;\n\tbus_space_handle_t memh;\n\n\t/* Map i/o space. */\n\tif (bus_space_map(iot, ia->ia_iobase, ia->ia_iosize, 0, &ioh)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\n\t/* Map mem space. */\n\tif (bus_space_map(memt, ia->ia_maddr, ia->ia_msize, 0, &memh)) {\n\t\tprintf(\": can't map mem space\\n\");\n\t\treturn;\n\t}\n\n\tsc->membase = ia->ia_maddr;\n\tsc->subregionmask = (1 << (ia->ia_msize / TCIC_MEM_PAGESIZE)) - 1;\n\tsc->memsize2 = tcic_log2((u_int)ia->ia_msize);\n\n\tsc->intr_est = ic;\n\tsc->pct = (pcmcia_chipset_tag_t) & tcic_isa_functions;\n\n\tsc->iot = iot;\n\tsc->ioh = ioh;\n\tsc->memt = memt;\n\tsc->memh = memh;\n\n\t/*\n\t * determine chip type and initialise some chip type dependend\n\t * parameters in softc.\n\t */\n\tsc->chipid = tcic_chipid(iot, ioh);\n\tsc->validirqs = tcic_validirqs(sc->chipid);\n\n\t/*\n\t * allocate an irq.  interrupts are relatively\n\t * scarce but for TCIC controllers very infrequent.\n\t */\n\n\tif ((sc->irq = ia->ia_irq) == IRQUNK) {\n\t\tif (isa_intr_alloc(ic,\n\t\t    sc->validirqs & (tcic_isa_intr_alloc_mask & 0xff00),\n\t\t    IST_EDGE, &sc->irq)) {\n\t\t\tprintf(\"\\n%s: can't allocate interrupt\\n\",\n\t\t\t    sc->dev.dv_xname);\n\t\t\treturn;\n\t\t}\n\t\tprintf(\": using irq %d\", sc->irq);\n\t}\n\tprintf(\"\\n\");\n\n\ttcic_attach(sc);\n\n\n\t/*\n\t * XXX mycroft recommends I/O space range 0x400-0xfff.\n\t */\n\n\t/*\n\t * XXX some hardware doesn't seem to grok addresses in 0x400 range--\n\t * apparently missing a bit or more of address lines. (e.g.\n\t * CIRRUS_PD672X with Linksys EthernetCard ne2000 clone in TI\n\t * TravelMate 5000--not clear which is at fault)\n\t * \n\t * Add a kludge to detect 10 bit wide buses and deal with them,\n\t * and also a config file option to override the probe.\n\t */\n\n#if 0\n\t/*\n\t * This is what we'd like to use, but...\n\t */\n\tsc->iobase = 0x400;\n\tsc->iosize = 0xbff;\n#else\n\t/*\n\t * ...the above bus width probe doesn't always work.\n\t * So, experimentation has shown the following range\n\t * to not lose on systems that 0x300-0x3ff loses on\n\t * (e.g. the NEC Versa 6030X).\n\t */\n\tsc->iobase = 0x330;\n\tsc->iosize = 0x0cf;\n#endif\n\n\tDPRINTF((\"%s: bus_space_alloc range 0x%04lx-0x%04lx)\\n\",\n\t    sc->dev.dv_xname, (long) sc->iobase,\n\t    (long) sc->iobase + sc->iosize));\n\n\tif (tcic_isa_alloc_iobase && tcic_isa_alloc_iosize) {\n\t\tsc->iobase = tcic_isa_alloc_iobase;\n\t\tsc->iosize = tcic_isa_alloc_iosize;\n\n\t\tDPRINTF((\"%s: bus_space_alloc range 0x%04lx-0x%04lx \"\n\t\t    \"(config override)\\n\", sc->dev.dv_xname, (long) sc->iobase,\n\t\t    (long) sc->iobase + sc->iosize));\n\t}\n\tsc->ih = isa_intr_establish(ic, sc->irq, IST_EDGE, IPL_TTY,\n\t    tcic_intr, sc, sc->dev.dv_xname);\n\tif (sc->ih == NULL) {\n\t\tprintf(\"%s: can't establish interrupt\\n\", sc->dev.dv_xname);\n\t\treturn;\n\t}\n\n\ttcic_attach_sockets(sc);\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ttcic_isa_alloc_iobase = TCIC_ISA_ALLOC_IOBASE;",
      "int\ttcic_isa_alloc_iosize = TCIC_ISA_ALLOC_IOSIZE;",
      "int\ttcic_isa_intr_alloc_mask = TCIC_ISA_INTR_ALLOC_MASK;",
      "void\ttcic_isa_attach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tcic_attach_sockets",
          "args": [
            "sc"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_attach_sockets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "401-410",
          "snippet": "void\ntcic_attach_sockets(sc)\n\tstruct tcic_softc *sc;\n{\n\tint i;\n\n\tfor (i = 0; i < TCIC_NSLOTS; i++)\n\t\tif (sc->handle[i].flags & TCIC_FLAG_SOCKETP)\n\t\t\ttcic_attach_socket(&sc->handle[i]);\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttcic_attach_socket"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_attach_socket;\n\nvoid\ntcic_attach_sockets(sc)\n\tstruct tcic_softc *sc;\n{\n\tint i;\n\n\tfor (i = 0; i < TCIC_NSLOTS; i++)\n\t\tif (sc->handle[i].flags & TCIC_FLAG_SOCKETP)\n\t\t\ttcic_attach_socket(&sc->handle[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: can't establish interrupt\\n\"",
            "sc->dev.dv_xname"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ic",
            "sc->irq",
            "IST_EDGE",
            "IPL_TTY",
            "tcic_intr",
            "sc",
            "sc->dev.dv_xname"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: bus_space_alloc range 0x%04lx-0x%04lx \"\n\t\t    \"(config override)\\n\", sc->dev.dv_xname, (long) sc->iobase,\n\t\t    (long) sc->iobase + sc->iosize)"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: bus_space_alloc range 0x%04lx-0x%04lx)\\n\",\n\t    sc->dev.dv_xname, (long) sc->iobase,\n\t    (long) sc->iobase + sc->iosize)"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_attach",
          "args": [
            "sc"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_attach_card",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "720-734",
          "snippet": "void\ntcic_attach_card(h)\n\tstruct tcic_handle *h;\n{\n\tDPRINTF((\"tcic_attach_card\\n\"));\n\n\tif (h->flags & TCIC_FLAG_CARDP)\n\t\tpanic(\"tcic_attach_card: already attached\");\n\n\t/* call the MI attach function */\n\n\tpcmcia_card_attach(h->pcmcia);\n\n\th->flags |= TCIC_FLAG_CARDP;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttcic_attach_card"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_attach_card;\n\nvoid\ntcic_attach_card(h)\n\tstruct tcic_handle *h;\n{\n\tDPRINTF((\"tcic_attach_card\\n\"));\n\n\tif (h->flags & TCIC_FLAG_CARDP)\n\t\tpanic(\"tcic_attach_card: already attached\");\n\n\t/* call the MI attach function */\n\n\tpcmcia_card_attach(h->pcmcia);\n\n\th->flags |= TCIC_FLAG_CARDP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_intr_alloc",
          "args": [
            "ic",
            "sc->validirqs & (tcic_isa_intr_alloc_mask & 0xff00)",
            "IST_EDGE",
            "&sc->irq"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_validirqs",
          "args": [
            "sc->chipid"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_validirqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "300-317",
          "snippet": "int\ntcic_validirqs(chipid)\n\tint chipid;\n{\n\tswitch (chipid) {\n\tcase TCIC_CHIPID_DB86082_1:\n\tcase TCIC_CHIPID_DB86082A:\n\tcase TCIC_CHIPID_DB86082B_ES:\n\tcase TCIC_CHIPID_DB86082B:\n\tcase TCIC_CHIPID_DB86084_1:\n\tcase TCIC_CHIPID_DB86084A:\n\tcase TCIC_CHIPID_DB86184_1:\n\tcase TCIC_CHIPID_DB86072_1_ES:\n\tcase TCIC_CHIPID_DB86072_1:\n\t\treturn tcic_valid_irqs;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_validirqs(chipid)\n\tint chipid;\n{\n\tswitch (chipid) {\n\tcase TCIC_CHIPID_DB86082_1:\n\tcase TCIC_CHIPID_DB86082A:\n\tcase TCIC_CHIPID_DB86082B_ES:\n\tcase TCIC_CHIPID_DB86082B:\n\tcase TCIC_CHIPID_DB86084_1:\n\tcase TCIC_CHIPID_DB86084A:\n\tcase TCIC_CHIPID_DB86184_1:\n\tcase TCIC_CHIPID_DB86072_1_ES:\n\tcase TCIC_CHIPID_DB86072_1:\n\t\treturn tcic_valid_irqs;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_chipid",
          "args": [
            "iot",
            "ioh"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_chipid_known",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "248-267",
          "snippet": "int\ntcic_chipid_known(id)\n\tint id;\n{\n\t/* XXX only know how to handle DB86082 -chb */\n\tswitch (id) {\n\tcase TCIC_CHIPID_DB86082_1:\n\tcase TCIC_CHIPID_DB86082A:\n\tcase TCIC_CHIPID_DB86082B_ES:\n\tcase TCIC_CHIPID_DB86082B:\n\tcase TCIC_CHIPID_DB86084_1:\n\tcase TCIC_CHIPID_DB86084A:\n\tcase TCIC_CHIPID_DB86184_1:\n\tcase TCIC_CHIPID_DB86072_1_ES:\n\tcase TCIC_CHIPID_DB86072_1:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *\ntcic_chipid_to_string(id)\n\tint id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nchar *\ntcic_chipid_to_string(id)\n\tint id;\n\nint\ntcic_chipid_known(id)\n\tint id;\n{\n\t/* XXX only know how to handle DB86082 -chb */\n\tswitch (id) {\n\tcase TCIC_CHIPID_DB86082_1:\n\tcase TCIC_CHIPID_DB86082A:\n\tcase TCIC_CHIPID_DB86082B_ES:\n\tcase TCIC_CHIPID_DB86082B:\n\tcase TCIC_CHIPID_DB86084_1:\n\tcase TCIC_CHIPID_DB86084A:\n\tcase TCIC_CHIPID_DB86184_1:\n\tcase TCIC_CHIPID_DB86072_1_ES:\n\tcase TCIC_CHIPID_DB86072_1:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_log2",
          "args": [
            "(u_int)ia->ia_msize"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "memt",
            "ia->ia_maddr",
            "ia->ia_msize",
            "0",
            "&memh"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "ia->ia_iobase",
            "ia->ia_iosize",
            "0",
            "&ioh"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ttcic_isa_alloc_iobase = TCIC_ISA_ALLOC_IOBASE;\nint\ttcic_isa_alloc_iosize = TCIC_ISA_ALLOC_IOSIZE;\nint\ttcic_isa_intr_alloc_mask = TCIC_ISA_INTR_ALLOC_MASK;\nvoid\ttcic_isa_attach;\n\nvoid\ntcic_isa_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct tcic_softc *sc = (void *) self;\n\tstruct isa_attach_args *ia = aux;\n\tisa_chipset_tag_t ic = ia->ia_ic;\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_tag_t memt = ia->ia_memt;\n\tbus_space_handle_t ioh;\n\tbus_space_handle_t memh;\n\n\t/* Map i/o space. */\n\tif (bus_space_map(iot, ia->ia_iobase, ia->ia_iosize, 0, &ioh)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\n\t/* Map mem space. */\n\tif (bus_space_map(memt, ia->ia_maddr, ia->ia_msize, 0, &memh)) {\n\t\tprintf(\": can't map mem space\\n\");\n\t\treturn;\n\t}\n\n\tsc->membase = ia->ia_maddr;\n\tsc->subregionmask = (1 << (ia->ia_msize / TCIC_MEM_PAGESIZE)) - 1;\n\tsc->memsize2 = tcic_log2((u_int)ia->ia_msize);\n\n\tsc->intr_est = ic;\n\tsc->pct = (pcmcia_chipset_tag_t) & tcic_isa_functions;\n\n\tsc->iot = iot;\n\tsc->ioh = ioh;\n\tsc->memt = memt;\n\tsc->memh = memh;\n\n\t/*\n\t * determine chip type and initialise some chip type dependend\n\t * parameters in softc.\n\t */\n\tsc->chipid = tcic_chipid(iot, ioh);\n\tsc->validirqs = tcic_validirqs(sc->chipid);\n\n\t/*\n\t * allocate an irq.  interrupts are relatively\n\t * scarce but for TCIC controllers very infrequent.\n\t */\n\n\tif ((sc->irq = ia->ia_irq) == IRQUNK) {\n\t\tif (isa_intr_alloc(ic,\n\t\t    sc->validirqs & (tcic_isa_intr_alloc_mask & 0xff00),\n\t\t    IST_EDGE, &sc->irq)) {\n\t\t\tprintf(\"\\n%s: can't allocate interrupt\\n\",\n\t\t\t    sc->dev.dv_xname);\n\t\t\treturn;\n\t\t}\n\t\tprintf(\": using irq %d\", sc->irq);\n\t}\n\tprintf(\"\\n\");\n\n\ttcic_attach(sc);\n\n\n\t/*\n\t * XXX mycroft recommends I/O space range 0x400-0xfff.\n\t */\n\n\t/*\n\t * XXX some hardware doesn't seem to grok addresses in 0x400 range--\n\t * apparently missing a bit or more of address lines. (e.g.\n\t * CIRRUS_PD672X with Linksys EthernetCard ne2000 clone in TI\n\t * TravelMate 5000--not clear which is at fault)\n\t * \n\t * Add a kludge to detect 10 bit wide buses and deal with them,\n\t * and also a config file option to override the probe.\n\t */\n\n#if 0\n\t/*\n\t * This is what we'd like to use, but...\n\t */\n\tsc->iobase = 0x400;\n\tsc->iosize = 0xbff;\n#else\n\t/*\n\t * ...the above bus width probe doesn't always work.\n\t * So, experimentation has shown the following range\n\t * to not lose on systems that 0x300-0x3ff loses on\n\t * (e.g. the NEC Versa 6030X).\n\t */\n\tsc->iobase = 0x330;\n\tsc->iosize = 0x0cf;\n#endif\n\n\tDPRINTF((\"%s: bus_space_alloc range 0x%04lx-0x%04lx)\\n\",\n\t    sc->dev.dv_xname, (long) sc->iobase,\n\t    (long) sc->iobase + sc->iosize));\n\n\tif (tcic_isa_alloc_iobase && tcic_isa_alloc_iosize) {\n\t\tsc->iobase = tcic_isa_alloc_iobase;\n\t\tsc->iosize = tcic_isa_alloc_iosize;\n\n\t\tDPRINTF((\"%s: bus_space_alloc range 0x%04lx-0x%04lx \"\n\t\t    \"(config override)\\n\", sc->dev.dv_xname, (long) sc->iobase,\n\t\t    (long) sc->iobase + sc->iosize));\n\t}\n\tsc->ih = isa_intr_establish(ic, sc->irq, IST_EDGE, IPL_TTY,\n\t    tcic_intr, sc, sc->dev.dv_xname);\n\tif (sc->ih == NULL) {\n\t\tprintf(\"%s: can't establish interrupt\\n\", sc->dev.dv_xname);\n\t\treturn;\n\t}\n\n\ttcic_attach_sockets(sc);\n}"
  },
  {
    "function_name": "tcic_isa_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/tcic2_isa.c",
    "lines": "140-191",
    "snippet": "int\ntcic_isa_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh, memh;\n\tint val, found;\n\n\t/* Disallow wildcarded i/o address. */\n\tif (ia->ia_iobase == -1 /* ISACF_PORT_DEFAULT */)\n\t\treturn (0);\n\n\tif (bus_space_map(iot, ia->ia_iobase, TCIC_IOSIZE, 0, &ioh))\n\t\treturn (0);\n\n\tif (ia->ia_msize == 0)\n\t\tia->ia_msize = TCIC_MEMSIZE;\n\n\tif (bus_space_map(ia->ia_memt, ia->ia_maddr, ia->ia_msize, 0, &memh))\n\t\treturn (0);\n\n\tDPRINTF((\"tcic probing 0x%03x\\n\", ia->ia_iobase));\n\tfound = 0;\n\n\t/*\n\t * First, check for the reserved bits to be zero.\n\t */\n\tif (tcic_check_reserved_bits(iot, ioh)) {\n\t\tDPRINTF((\"tcic: reserved bits checked OK\\n\"));\n\t\t/* Second, check whether the we know how to handle the chip. */\n\t\tif ((val = tcic_chipid(iot, ioh))) {\n\t\t\tDPRINTF((\"tcic id: 0x%02x\\n\", val));\n\t\t\tif (tcic_chipid_known(val))\n\t\t\t\tfound++;\n\t\t}\n\t}\n\telse\n\t\tDPRINTF((\"tcic: reserved bits didn't check OK\\n\"));\n\n\tbus_space_unmap(iot, ioh, TCIC_IOSIZE);\n\tbus_space_unmap(ia->ia_memt, memh, ia->ia_msize);\n\n\tif (!found)\n\t\treturn (0);\n\n\tia->ia_iosize = TCIC_IOSIZE;\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ttcic_isa_probe"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "ia->ia_memt",
            "memh",
            "ia->ia_msize"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh",
            "TCIC_IOSIZE"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic: reserved bits didn't check OK\\n\")"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_chipid_known",
          "args": [
            "val"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_chipid_known",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "248-267",
          "snippet": "int\ntcic_chipid_known(id)\n\tint id;\n{\n\t/* XXX only know how to handle DB86082 -chb */\n\tswitch (id) {\n\tcase TCIC_CHIPID_DB86082_1:\n\tcase TCIC_CHIPID_DB86082A:\n\tcase TCIC_CHIPID_DB86082B_ES:\n\tcase TCIC_CHIPID_DB86082B:\n\tcase TCIC_CHIPID_DB86084_1:\n\tcase TCIC_CHIPID_DB86084A:\n\tcase TCIC_CHIPID_DB86184_1:\n\tcase TCIC_CHIPID_DB86072_1_ES:\n\tcase TCIC_CHIPID_DB86072_1:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *\ntcic_chipid_to_string(id)\n\tint id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nchar *\ntcic_chipid_to_string(id)\n\tint id;\n\nint\ntcic_chipid_known(id)\n\tint id;\n{\n\t/* XXX only know how to handle DB86082 -chb */\n\tswitch (id) {\n\tcase TCIC_CHIPID_DB86082_1:\n\tcase TCIC_CHIPID_DB86082A:\n\tcase TCIC_CHIPID_DB86082B_ES:\n\tcase TCIC_CHIPID_DB86082B:\n\tcase TCIC_CHIPID_DB86084_1:\n\tcase TCIC_CHIPID_DB86084A:\n\tcase TCIC_CHIPID_DB86184_1:\n\tcase TCIC_CHIPID_DB86072_1_ES:\n\tcase TCIC_CHIPID_DB86072_1:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic id: 0x%02x\\n\", val)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic: reserved bits checked OK\\n\")"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_check_reserved_bits",
          "args": [
            "iot",
            "ioh"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_check_reserved_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "109-220",
          "snippet": "int\ntcic_check_reserved_bits(iot, ioh)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n{\n\tint val, auxreg;\n\n\tDPRINTF((\"tcic: chkrsvd 1\\n\"));\n\t/* R_ADDR bit 30:28 have a restricted range. */\n\tval = (bus_space_read_2(iot, ioh, TCIC_R_ADDR2) & TCIC_SS_MASK)\n\t    >> TCIC_SS_SHIFT;\n\tif (val > 1)\n\t\treturn 0;\n\n\tDPRINTF((\"tcic: chkrsvd 2\\n\"));\n\t/* R_SCTRL bits 6,2,1 are reserved. */\n\tval = bus_space_read_1(iot, ioh, TCIC_R_SCTRL);\n\tif (val & TCIC_SCTRL_RSVD)\n\t\treturn 0;\n\n\tDPRINTF((\"tcic: chkrsvd 3\\n\"));\n\t/* R_ICSR bit 2 must be same as bit 3. */\n\tval = bus_space_read_1(iot, ioh, TCIC_R_ICSR);\n\tif (((val >> 1) & 1) != ((val >> 2) & 1))\n\t\treturn 0;\n\n\tDPRINTF((\"tcic: chkrsvd 4\\n\"));\n\t/* R_IENA bits 7,2 are reserverd. */\n\tval = bus_space_read_1(iot, ioh, TCIC_R_IENA);\n\tif (val & TCIC_IENA_RSVD)\n\t\treturn 0;\n\n\tDPRINTF((\"tcic: chkrsvd 5\\n\"));\n\t/* Some aux registers have reserved bits. */\n\t/* Which are we looking at? */\n\tauxreg = bus_space_read_1(iot, ioh, TCIC_R_MODE)\n\t    & TCIC_AR_MASK;\n\tval = bus_space_read_2(iot, ioh, TCIC_R_AUX);\n\tDPRINTF((\"tcic: auxreg 0x%02x val 0x%04x\\n\", auxreg, val));\n\tswitch (auxreg) {\n\tcase TCIC_AR_SYSCFG:\n\t\tif (INVALID_AR_SYSCFG(val))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase TCIC_AR_ILOCK:\n\t\tif (INVALID_AR_ILOCK(val))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase TCIC_AR_TEST:\n\t\tif (INVALID_AR_TEST(val))\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\tDPRINTF((\"tcic: chkrsvd 6\\n\"));\n\t/* XXX fails if pcmcia bios is enabled. */\n\t/* Various bits set or not depending if in RESET mode. */\n\tval = bus_space_read_1(iot, ioh, TCIC_R_SCTRL);\n\tif (val & TCIC_SCTRL_RESET) {\n\t\tDPRINTF((\"tcic: chkrsvd 7\\n\"));\n\t\t/* Address bits must be 0 */\n\t\tval = bus_space_read_2(iot, ioh, TCIC_R_ADDR);\n\t\tif (val != 0)\n\t\t\treturn 0;\n\t\tval = bus_space_read_2(iot, ioh, TCIC_R_ADDR2);\n\t\tif (val != 0)\n\t\t\treturn 0;\n\t\tDPRINTF((\"tcic: chkrsvd 8\\n\"));\n\t\t/* EDC bits must be 0 */\n\t\tval = bus_space_read_2(iot, ioh, TCIC_R_EDC);\n\t\tif (val != 0)\n\t\t\treturn 0;\n\t\t/* We're OK, so take it out of reset. XXX -chb */\n\t\tbus_space_write_1(iot, ioh, TCIC_R_SCTRL, 0);\n\t}\n\telse {\t/* not in RESET mode */\n\t\tint omode;\n\t\tint val1, val2;\n\t\tDPRINTF((\"tcic: chkrsvd 9\\n\"));\n\t\t/* Programming timers must have expired. */\n\t\tval = bus_space_read_1(iot, ioh, TCIC_R_SSTAT);\n\t\tif ((val & (TCIC_SSTAT_6US|TCIC_SSTAT_10US|TCIC_SSTAT_PROGTIME))\n\t\t    != (TCIC_SSTAT_6US|TCIC_SSTAT_10US|TCIC_SSTAT_PROGTIME))\n\t\t\treturn 0;\n\t\tDPRINTF((\"tcic: chkrsvd 10\\n\"));\n\t\t/*\n\t\t * EDC bits should change on read from data space\n\t\t * as long as either EDC or the data are nonzero.\n\t\t */\n\t\t if ((bus_space_read_2(iot, ioh, TCIC_R_ADDR2)\n\t\t     & TCIC_ADDR2_INDREG) != 0) {\n\t\t\tval1 = bus_space_read_2(iot, ioh, TCIC_R_EDC);\n\t\t\tval2 = bus_space_read_2(iot, ioh, TCIC_R_DATA);\n\t\t\tif (val1 | val2) {\n\t\t\t\tval1 = bus_space_read_2(iot, ioh, TCIC_R_EDC);\n\t\t\t\tif (val1 == val2)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tDPRINTF((\"tcic: chkrsvd 11\\n\"));\n\t\t/* XXX what does this check? -chb */\n\t\tomode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\t\tval1 = omode ^ TCIC_AR_MASK;\n\t\tbus_space_write_1(iot, ioh, TCIC_R_MODE, val1);\n\t\tval2 = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\t\tbus_space_write_1(iot, ioh, TCIC_R_MODE, omode);\n\t\tif ( val1 != val2)\n\t\t\treturn 0;\n\t}\n\t/* All tests passed */\n\treturn 1;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_check_reserved_bits(iot, ioh)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n{\n\tint val, auxreg;\n\n\tDPRINTF((\"tcic: chkrsvd 1\\n\"));\n\t/* R_ADDR bit 30:28 have a restricted range. */\n\tval = (bus_space_read_2(iot, ioh, TCIC_R_ADDR2) & TCIC_SS_MASK)\n\t    >> TCIC_SS_SHIFT;\n\tif (val > 1)\n\t\treturn 0;\n\n\tDPRINTF((\"tcic: chkrsvd 2\\n\"));\n\t/* R_SCTRL bits 6,2,1 are reserved. */\n\tval = bus_space_read_1(iot, ioh, TCIC_R_SCTRL);\n\tif (val & TCIC_SCTRL_RSVD)\n\t\treturn 0;\n\n\tDPRINTF((\"tcic: chkrsvd 3\\n\"));\n\t/* R_ICSR bit 2 must be same as bit 3. */\n\tval = bus_space_read_1(iot, ioh, TCIC_R_ICSR);\n\tif (((val >> 1) & 1) != ((val >> 2) & 1))\n\t\treturn 0;\n\n\tDPRINTF((\"tcic: chkrsvd 4\\n\"));\n\t/* R_IENA bits 7,2 are reserverd. */\n\tval = bus_space_read_1(iot, ioh, TCIC_R_IENA);\n\tif (val & TCIC_IENA_RSVD)\n\t\treturn 0;\n\n\tDPRINTF((\"tcic: chkrsvd 5\\n\"));\n\t/* Some aux registers have reserved bits. */\n\t/* Which are we looking at? */\n\tauxreg = bus_space_read_1(iot, ioh, TCIC_R_MODE)\n\t    & TCIC_AR_MASK;\n\tval = bus_space_read_2(iot, ioh, TCIC_R_AUX);\n\tDPRINTF((\"tcic: auxreg 0x%02x val 0x%04x\\n\", auxreg, val));\n\tswitch (auxreg) {\n\tcase TCIC_AR_SYSCFG:\n\t\tif (INVALID_AR_SYSCFG(val))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase TCIC_AR_ILOCK:\n\t\tif (INVALID_AR_ILOCK(val))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase TCIC_AR_TEST:\n\t\tif (INVALID_AR_TEST(val))\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\tDPRINTF((\"tcic: chkrsvd 6\\n\"));\n\t/* XXX fails if pcmcia bios is enabled. */\n\t/* Various bits set or not depending if in RESET mode. */\n\tval = bus_space_read_1(iot, ioh, TCIC_R_SCTRL);\n\tif (val & TCIC_SCTRL_RESET) {\n\t\tDPRINTF((\"tcic: chkrsvd 7\\n\"));\n\t\t/* Address bits must be 0 */\n\t\tval = bus_space_read_2(iot, ioh, TCIC_R_ADDR);\n\t\tif (val != 0)\n\t\t\treturn 0;\n\t\tval = bus_space_read_2(iot, ioh, TCIC_R_ADDR2);\n\t\tif (val != 0)\n\t\t\treturn 0;\n\t\tDPRINTF((\"tcic: chkrsvd 8\\n\"));\n\t\t/* EDC bits must be 0 */\n\t\tval = bus_space_read_2(iot, ioh, TCIC_R_EDC);\n\t\tif (val != 0)\n\t\t\treturn 0;\n\t\t/* We're OK, so take it out of reset. XXX -chb */\n\t\tbus_space_write_1(iot, ioh, TCIC_R_SCTRL, 0);\n\t}\n\telse {\t/* not in RESET mode */\n\t\tint omode;\n\t\tint val1, val2;\n\t\tDPRINTF((\"tcic: chkrsvd 9\\n\"));\n\t\t/* Programming timers must have expired. */\n\t\tval = bus_space_read_1(iot, ioh, TCIC_R_SSTAT);\n\t\tif ((val & (TCIC_SSTAT_6US|TCIC_SSTAT_10US|TCIC_SSTAT_PROGTIME))\n\t\t    != (TCIC_SSTAT_6US|TCIC_SSTAT_10US|TCIC_SSTAT_PROGTIME))\n\t\t\treturn 0;\n\t\tDPRINTF((\"tcic: chkrsvd 10\\n\"));\n\t\t/*\n\t\t * EDC bits should change on read from data space\n\t\t * as long as either EDC or the data are nonzero.\n\t\t */\n\t\t if ((bus_space_read_2(iot, ioh, TCIC_R_ADDR2)\n\t\t     & TCIC_ADDR2_INDREG) != 0) {\n\t\t\tval1 = bus_space_read_2(iot, ioh, TCIC_R_EDC);\n\t\t\tval2 = bus_space_read_2(iot, ioh, TCIC_R_DATA);\n\t\t\tif (val1 | val2) {\n\t\t\t\tval1 = bus_space_read_2(iot, ioh, TCIC_R_EDC);\n\t\t\t\tif (val1 == val2)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tDPRINTF((\"tcic: chkrsvd 11\\n\"));\n\t\t/* XXX what does this check? -chb */\n\t\tomode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\t\tval1 = omode ^ TCIC_AR_MASK;\n\t\tbus_space_write_1(iot, ioh, TCIC_R_MODE, val1);\n\t\tval2 = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\t\tbus_space_write_1(iot, ioh, TCIC_R_MODE, omode);\n\t\tif ( val1 != val2)\n\t\t\treturn 0;\n\t}\n\t/* All tests passed */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic probing 0x%03x\\n\", ia->ia_iobase)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "ia->ia_memt",
            "ia->ia_maddr",
            "ia->ia_msize",
            "0",
            "&memh"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "ia->ia_iobase",
            "TCIC_IOSIZE",
            "0",
            "&ioh"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ttcic_isa_probe;\n\nint\ntcic_isa_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh, memh;\n\tint val, found;\n\n\t/* Disallow wildcarded i/o address. */\n\tif (ia->ia_iobase == -1 /* ISACF_PORT_DEFAULT */)\n\t\treturn (0);\n\n\tif (bus_space_map(iot, ia->ia_iobase, TCIC_IOSIZE, 0, &ioh))\n\t\treturn (0);\n\n\tif (ia->ia_msize == 0)\n\t\tia->ia_msize = TCIC_MEMSIZE;\n\n\tif (bus_space_map(ia->ia_memt, ia->ia_maddr, ia->ia_msize, 0, &memh))\n\t\treturn (0);\n\n\tDPRINTF((\"tcic probing 0x%03x\\n\", ia->ia_iobase));\n\tfound = 0;\n\n\t/*\n\t * First, check for the reserved bits to be zero.\n\t */\n\tif (tcic_check_reserved_bits(iot, ioh)) {\n\t\tDPRINTF((\"tcic: reserved bits checked OK\\n\"));\n\t\t/* Second, check whether the we know how to handle the chip. */\n\t\tif ((val = tcic_chipid(iot, ioh))) {\n\t\t\tDPRINTF((\"tcic id: 0x%02x\\n\", val));\n\t\t\tif (tcic_chipid_known(val))\n\t\t\t\tfound++;\n\t\t}\n\t}\n\telse\n\t\tDPRINTF((\"tcic: reserved bits didn't check OK\\n\"));\n\n\tbus_space_unmap(iot, ioh, TCIC_IOSIZE);\n\tbus_space_unmap(ia->ia_memt, memh, ia->ia_msize);\n\n\tif (!found)\n\t\treturn (0);\n\n\tia->ia_iosize = TCIC_IOSIZE;\n\n\treturn (1);\n}"
  }
]