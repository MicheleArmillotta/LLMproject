[
  {
    "function_name": "print_rbd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "2266-2275",
    "snippet": "void\nprint_rbd(rbd)\n\tvolatile struct ie_recv_buf_desc *rbd;\n{\n\n\tprintf(\"RBD at %08lx:\\nactual %04x, next %04x, buffer %08x\\n\"\n\t    \"length %04x, mbz %04x\\n\", (u_long)rbd, rbd->ie_rbd_actual,\n\t    rbd->ie_rbd_next, rbd->ie_rbd_buffer, rbd->ie_rbd_length,\n\t    rbd->mbz);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"RBD at %08lx:\\nactual %04x, next %04x, buffer %08x\\n\"\n\t    \"length %04x, mbz %04x\\n\"",
            "(u_long)rbd",
            "rbd->ie_rbd_actual",
            "rbd->ie_rbd_next",
            "rbd->ie_rbd_buffer",
            "rbd->ie_rbd_length",
            "rbd->mbz"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\nprint_rbd(rbd)\n\tvolatile struct ie_recv_buf_desc *rbd;\n{\n\n\tprintf(\"RBD at %08lx:\\nactual %04x, next %04x, buffer %08x\\n\"\n\t    \"length %04x, mbz %04x\\n\", (u_long)rbd, rbd->ie_rbd_actual,\n\t    rbd->ie_rbd_next, rbd->ie_rbd_buffer, rbd->ie_rbd_length,\n\t    rbd->mbz);\n}"
  },
  {
    "function_name": "mc_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "2237-2263",
    "snippet": "static void\nmc_reset(sc)\n\tstruct ie_softc *sc;\n{\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Step through the list of addresses.\n\t */\n\tsc->mcast_count = 0;\n\tETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);\n\twhile (enm) {\n\t\tif (sc->mcast_count >= MAXMCAST ||\n\t\t    bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) != 0) {\n\t\t\tsc->sc_arpcom.ac_if.if_flags |= IFF_ALLMULTI;\n\t\t\tieioctl(&sc->sc_arpcom.ac_if, SIOCSIFFLAGS, (void *)0);\n\t\t\tgoto setflag;\n\t\t}\n\n\t\tbcopy(enm->enm_addrlo, &sc->mcast_addrs[sc->mcast_count], 6);\n\t\tsc->mcast_count++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\nsetflag:\n\tsc->want_mcsetup = 1;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ieioctl",
      "static void mc_reset",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "enm->enm_addrlo",
            "&sc->mcast_addrs[sc->mcast_count]",
            "6"
          ],
          "line": 2257
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ieioctl",
          "args": [
            "&sc->sc_arpcom.ac_if",
            "SIOCSIFFLAGS",
            "(void *)0"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "ieioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "2145-2235",
          "snippet": "int\nieioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ie_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tieinit(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tieinit(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tsc->promisc = ifp->if_flags & (IFF_PROMISC | IFF_ALLMULTI);\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tiestop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tieinit(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\tiestop(sc);\n\t\t\tieinit(sc);\n\t\t}\n#ifdef IEDEBUG\n\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\tsc->sc_debug = IED_ALL;\n\t\telse\n\t\t\tsc->sc_debug = 0;\n#endif\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom):\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tmc_reset(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\tsplx(s);\n\treturn error;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tIED_ALL\t\t0x7f"
          ],
          "globals_used": [
            "void iestop",
            "int ieinit",
            "int ieioctl",
            "static void mc_reset",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tIED_ALL\t\t0x7f\n\nvoid iestop;\nint ieinit;\nint ieioctl;\nstatic void mc_reset;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nieioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ie_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tieinit(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tieinit(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tsc->promisc = ifp->if_flags & (IFF_PROMISC | IFF_ALLMULTI);\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tiestop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tieinit(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\tiestop(sc);\n\t\t\tieinit(sc);\n\t\t}\n#ifdef IEDEBUG\n\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\tsc->sc_debug = IED_ALL;\n\t\telse\n\t\t\tsc->sc_debug = 0;\n#endif\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom):\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tmc_reset(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\tsplx(s);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "enm->enm_addrlo",
            "enm->enm_addrhi",
            "6"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "&sc->sc_arpcom",
            "enm"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ieioctl;\nstatic void mc_reset;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic void\nmc_reset(sc)\n\tstruct ie_softc *sc;\n{\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Step through the list of addresses.\n\t */\n\tsc->mcast_count = 0;\n\tETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);\n\twhile (enm) {\n\t\tif (sc->mcast_count >= MAXMCAST ||\n\t\t    bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) != 0) {\n\t\t\tsc->sc_arpcom.ac_if.if_flags |= IFF_ALLMULTI;\n\t\t\tieioctl(&sc->sc_arpcom.ac_if, SIOCSIFFLAGS, (void *)0);\n\t\t\tgoto setflag;\n\t\t}\n\n\t\tbcopy(enm->enm_addrlo, &sc->mcast_addrs[sc->mcast_count], 6);\n\t\tsc->mcast_count++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\nsetflag:\n\tsc->want_mcsetup = 1;\n}"
  },
  {
    "function_name": "ieioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "2145-2235",
    "snippet": "int\nieioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ie_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tieinit(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tieinit(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tsc->promisc = ifp->if_flags & (IFF_PROMISC | IFF_ALLMULTI);\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tiestop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tieinit(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\tiestop(sc);\n\t\t\tieinit(sc);\n\t\t}\n#ifdef IEDEBUG\n\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\tsc->sc_debug = IED_ALL;\n\t\telse\n\t\t\tsc->sc_debug = 0;\n#endif\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom):\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tmc_reset(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\tsplx(s);\n\treturn error;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tIED_ALL\t\t0x7f"
    ],
    "globals_used": [
      "void iestop",
      "int ieinit",
      "int ieioctl",
      "static void mc_reset",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mc_reset",
          "args": [
            "sc"
          ],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "mc_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "2237-2263",
          "snippet": "static void\nmc_reset(sc)\n\tstruct ie_softc *sc;\n{\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Step through the list of addresses.\n\t */\n\tsc->mcast_count = 0;\n\tETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);\n\twhile (enm) {\n\t\tif (sc->mcast_count >= MAXMCAST ||\n\t\t    bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) != 0) {\n\t\t\tsc->sc_arpcom.ac_if.if_flags |= IFF_ALLMULTI;\n\t\t\tieioctl(&sc->sc_arpcom.ac_if, SIOCSIFFLAGS, (void *)0);\n\t\t\tgoto setflag;\n\t\t}\n\n\t\tbcopy(enm->enm_addrlo, &sc->mcast_addrs[sc->mcast_count], 6);\n\t\tsc->mcast_count++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\nsetflag:\n\tsc->want_mcsetup = 1;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int ieioctl",
            "static void mc_reset",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint ieioctl;\nstatic void mc_reset;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic void\nmc_reset(sc)\n\tstruct ie_softc *sc;\n{\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Step through the list of addresses.\n\t */\n\tsc->mcast_count = 0;\n\tETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);\n\twhile (enm) {\n\t\tif (sc->mcast_count >= MAXMCAST ||\n\t\t    bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) != 0) {\n\t\t\tsc->sc_arpcom.ac_if.if_flags |= IFF_ALLMULTI;\n\t\t\tieioctl(&sc->sc_arpcom.ac_if, SIOCSIFFLAGS, (void *)0);\n\t\t\tgoto setflag;\n\t\t}\n\n\t\tbcopy(enm->enm_addrlo, &sc->mcast_addrs[sc->mcast_count], 6);\n\t\tsc->mcast_count++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\nsetflag:\n\tsc->want_mcsetup = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ieinit",
          "args": [
            "sc"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "ieinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "2045-2135",
          "snippet": "int\nieinit(sc)\n\tstruct ie_softc *sc;\n{\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvoid *ptr;\n\n\tptr = (void *)ALIGN(scb + 1);\n\n\t/*\n\t * Send the configure command first.\n\t */\n\t{\n\t\tvolatile struct ie_config_cmd *cmd = ptr;\n\n\t\tscb->ie_command_list = MK_16(MEM, cmd);\n\t\tcmd->com.ie_cmd_status = 0;\n\t\tcmd->com.ie_cmd_cmd = IE_CMD_CONFIG | IE_CMD_LAST;\n\t\tcmd->com.ie_cmd_link = 0xffff;\n\n\t\tie_setup_config(cmd, sc->promisc != 0,\n\t\t    sc->hard_type == IE_STARLAN10);\n\n\t\tif (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||\n\t\t    !(cmd->com.ie_cmd_status & IE_STAT_OK)) {\n\t\t\tprintf(\"%s: configure command failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Now send the Individual Address Setup command.\n\t */\n\t{\n\t\tvolatile struct ie_iasetup_cmd *cmd = ptr;\n\n\t\tscb->ie_command_list = MK_16(MEM, cmd);\n\t\tcmd->com.ie_cmd_status = 0;\n\t\tcmd->com.ie_cmd_cmd = IE_CMD_IASETUP | IE_CMD_LAST;\n\t\tcmd->com.ie_cmd_link = 0xffff;\n\n\t\tbcopy(sc->sc_arpcom.ac_enaddr, (caddr_t)&cmd->ie_address,\n\t\t    sizeof cmd->ie_address);\n\n\t\tif (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||\n\t\t    !(cmd->com.ie_cmd_status & IE_STAT_OK)) {\n\t\t\tprintf(\"%s: individual address setup command failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Now run the time-domain reflectometer.\n\t */\n\trun_tdr(sc, ptr);\n\n\t/*\n\t * Acknowledge any interrupts we have generated thus far.\n\t */\n\tie_ack(sc, IE_ST_WHENCE);\n\n\t/*\n\t * Set up the RFA.\n\t */\n\tiememinit(ptr, sc);\n\n\tsc->sc_arpcom.ac_if.if_flags |= IFF_RUNNING;\n\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\n\tsc->scb->ie_recv_list = MK_16(MEM, sc->rframes[0]);\n\tcommand_and_wait(sc, IE_RU_START, 0, 0);\n\n\tie_ack(sc, IE_ST_WHENCE);\n\n\t/* take the ee16 out of loopback */\n\t{\n\tu_char\tbart_config;\n\n\tif(sc->hard_type == IE_EE16) {\n\t\tbart_config = inb(PORT + IEE16_CONFIG);\n\t\tbart_config &= ~IEE16_BART_LOOPBACK;\n\t\tbart_config |= IEE16_BART_MCS16_TEST; /* inb doesn't get bit! */\n\t\toutb(PORT + IEE16_CONFIG, bart_config);\n\t\tee16_interrupt_enable(sc); \n\t\tee16_chan_attn(sc);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define MEM \tsc->sc_maddr",
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "int ieinit",
            "static void ee16_chan_attn",
            "static void ee16_interrupt_enable",
            "static int command_and_wait",
            "void iememinit",
            "static __inline void ie_setup_config",
            "static __inline void ie_ack",
            "static void run_tdr",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define MEM \tsc->sc_maddr\n#define PORT\tsc->sc_iobase\n\nint ieinit;\nstatic void ee16_chan_attn;\nstatic void ee16_interrupt_enable;\nstatic int command_and_wait;\nvoid iememinit;\nstatic __inline void ie_setup_config;\nstatic __inline void ie_ack;\nstatic void run_tdr;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nieinit(sc)\n\tstruct ie_softc *sc;\n{\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvoid *ptr;\n\n\tptr = (void *)ALIGN(scb + 1);\n\n\t/*\n\t * Send the configure command first.\n\t */\n\t{\n\t\tvolatile struct ie_config_cmd *cmd = ptr;\n\n\t\tscb->ie_command_list = MK_16(MEM, cmd);\n\t\tcmd->com.ie_cmd_status = 0;\n\t\tcmd->com.ie_cmd_cmd = IE_CMD_CONFIG | IE_CMD_LAST;\n\t\tcmd->com.ie_cmd_link = 0xffff;\n\n\t\tie_setup_config(cmd, sc->promisc != 0,\n\t\t    sc->hard_type == IE_STARLAN10);\n\n\t\tif (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||\n\t\t    !(cmd->com.ie_cmd_status & IE_STAT_OK)) {\n\t\t\tprintf(\"%s: configure command failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Now send the Individual Address Setup command.\n\t */\n\t{\n\t\tvolatile struct ie_iasetup_cmd *cmd = ptr;\n\n\t\tscb->ie_command_list = MK_16(MEM, cmd);\n\t\tcmd->com.ie_cmd_status = 0;\n\t\tcmd->com.ie_cmd_cmd = IE_CMD_IASETUP | IE_CMD_LAST;\n\t\tcmd->com.ie_cmd_link = 0xffff;\n\n\t\tbcopy(sc->sc_arpcom.ac_enaddr, (caddr_t)&cmd->ie_address,\n\t\t    sizeof cmd->ie_address);\n\n\t\tif (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||\n\t\t    !(cmd->com.ie_cmd_status & IE_STAT_OK)) {\n\t\t\tprintf(\"%s: individual address setup command failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Now run the time-domain reflectometer.\n\t */\n\trun_tdr(sc, ptr);\n\n\t/*\n\t * Acknowledge any interrupts we have generated thus far.\n\t */\n\tie_ack(sc, IE_ST_WHENCE);\n\n\t/*\n\t * Set up the RFA.\n\t */\n\tiememinit(ptr, sc);\n\n\tsc->sc_arpcom.ac_if.if_flags |= IFF_RUNNING;\n\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\n\tsc->scb->ie_recv_list = MK_16(MEM, sc->rframes[0]);\n\tcommand_and_wait(sc, IE_RU_START, 0, 0);\n\n\tie_ack(sc, IE_ST_WHENCE);\n\n\t/* take the ee16 out of loopback */\n\t{\n\tu_char\tbart_config;\n\n\tif(sc->hard_type == IE_EE16) {\n\t\tbart_config = inb(PORT + IEE16_CONFIG);\n\t\tbart_config &= ~IEE16_BART_LOOPBACK;\n\t\tbart_config |= IEE16_BART_MCS16_TEST; /* inb doesn't get bit! */\n\t\toutb(PORT + IEE16_CONFIG, bart_config);\n\t\tee16_interrupt_enable(sc); \n\t\tee16_chan_attn(sc);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iestop",
          "args": [
            "sc"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "iestop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "2137-2143",
          "snippet": "void\niestop(sc)\n\tstruct ie_softc *sc;\n{\n\n\tcommand_and_wait(sc, IE_RU_DISABLE, 0, 0);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void iestop",
            "static int command_and_wait",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iestop;\nstatic int command_and_wait;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\niestop(sc)\n\tstruct ie_softc *sc;\n{\n\n\tcommand_and_wait(sc, IE_RU_DISABLE, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->sc_arpcom",
            "ifa"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "&sc->sc_arpcom",
            "cmd",
            "data"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "wx_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "303-356",
          "snippet": "static int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_init",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_init;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tIED_ALL\t\t0x7f\n\nvoid iestop;\nint ieinit;\nint ieioctl;\nstatic void mc_reset;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nieioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ie_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tieinit(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tieinit(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tsc->promisc = ifp->if_flags & (IFF_PROMISC | IFF_ALLMULTI);\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tiestop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tieinit(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\tiestop(sc);\n\t\t\tieinit(sc);\n\t\t}\n#ifdef IEDEBUG\n\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\tsc->sc_debug = IED_ALL;\n\t\telse\n\t\t\tsc->sc_debug = 0;\n#endif\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom):\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tmc_reset(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\tsplx(s);\n\treturn error;\n}"
  },
  {
    "function_name": "iestop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "2137-2143",
    "snippet": "void\niestop(sc)\n\tstruct ie_softc *sc;\n{\n\n\tcommand_and_wait(sc, IE_RU_DISABLE, 0, 0);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void iestop",
      "static int command_and_wait",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "command_and_wait",
          "args": [
            "sc",
            "IE_RU_DISABLE",
            "0",
            "0"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "command_and_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1838-1886",
          "snippet": "static int\ncommand_and_wait(sc, cmd, pcmd, mask)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tvolatile void *pcmd;\n\tint mask;\n{\n\tvolatile struct ie_cmd_common *cc = pcmd;\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvolatile int timedout = 0;\n\textern int hz;\n\n\tscb->ie_command = (u_short)cmd;\n\n\tif (IE_ACTION_COMMAND(cmd) && pcmd) {\n\t\t(sc->chan_attn)(sc);\n\n\t\t/*\n\t\t * According to the packet driver, the minimum timeout should\n\t\t * be .369 seconds, which we round up to .4.\n\t\t */\n\t\ttimeout(chan_attn_timeout, (caddr_t)&timedout, 2 * hz / 5);\n\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, but I haven't figured out how, or indeed if, we\n\t\t * can put the process waiting for action to sleep.  (We may\n\t\t * be getting called through some other timeout running in the\n\t\t * kernel.)\n\t\t */\n\t\tfor (;;)\n\t\t\tif ((cc->ie_cmd_status & mask) || timedout)\n\t\t\t\tbreak;\n\n\t\tuntimeout(chan_attn_timeout, (caddr_t)&timedout);\n\n\t\treturn timedout;\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\t(sc->chan_attn)(sc);\n\n\t\twhile (scb->ie_command)\n\t\t\t;\t\t\t\t/* spin lock */\n\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int command_and_wait",
            "static void chan_attn_timeout",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int command_and_wait;\nstatic void chan_attn_timeout;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic int\ncommand_and_wait(sc, cmd, pcmd, mask)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tvolatile void *pcmd;\n\tint mask;\n{\n\tvolatile struct ie_cmd_common *cc = pcmd;\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvolatile int timedout = 0;\n\textern int hz;\n\n\tscb->ie_command = (u_short)cmd;\n\n\tif (IE_ACTION_COMMAND(cmd) && pcmd) {\n\t\t(sc->chan_attn)(sc);\n\n\t\t/*\n\t\t * According to the packet driver, the minimum timeout should\n\t\t * be .369 seconds, which we round up to .4.\n\t\t */\n\t\ttimeout(chan_attn_timeout, (caddr_t)&timedout, 2 * hz / 5);\n\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, but I haven't figured out how, or indeed if, we\n\t\t * can put the process waiting for action to sleep.  (We may\n\t\t * be getting called through some other timeout running in the\n\t\t * kernel.)\n\t\t */\n\t\tfor (;;)\n\t\t\tif ((cc->ie_cmd_status & mask) || timedout)\n\t\t\t\tbreak;\n\n\t\tuntimeout(chan_attn_timeout, (caddr_t)&timedout);\n\n\t\treturn timedout;\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\t(sc->chan_attn)(sc);\n\n\t\twhile (scb->ie_command)\n\t\t\t;\t\t\t\t/* spin lock */\n\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iestop;\nstatic int command_and_wait;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\niestop(sc)\n\tstruct ie_softc *sc;\n{\n\n\tcommand_and_wait(sc, IE_RU_DISABLE, 0, 0);\n}"
  },
  {
    "function_name": "ieinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "2045-2135",
    "snippet": "int\nieinit(sc)\n\tstruct ie_softc *sc;\n{\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvoid *ptr;\n\n\tptr = (void *)ALIGN(scb + 1);\n\n\t/*\n\t * Send the configure command first.\n\t */\n\t{\n\t\tvolatile struct ie_config_cmd *cmd = ptr;\n\n\t\tscb->ie_command_list = MK_16(MEM, cmd);\n\t\tcmd->com.ie_cmd_status = 0;\n\t\tcmd->com.ie_cmd_cmd = IE_CMD_CONFIG | IE_CMD_LAST;\n\t\tcmd->com.ie_cmd_link = 0xffff;\n\n\t\tie_setup_config(cmd, sc->promisc != 0,\n\t\t    sc->hard_type == IE_STARLAN10);\n\n\t\tif (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||\n\t\t    !(cmd->com.ie_cmd_status & IE_STAT_OK)) {\n\t\t\tprintf(\"%s: configure command failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Now send the Individual Address Setup command.\n\t */\n\t{\n\t\tvolatile struct ie_iasetup_cmd *cmd = ptr;\n\n\t\tscb->ie_command_list = MK_16(MEM, cmd);\n\t\tcmd->com.ie_cmd_status = 0;\n\t\tcmd->com.ie_cmd_cmd = IE_CMD_IASETUP | IE_CMD_LAST;\n\t\tcmd->com.ie_cmd_link = 0xffff;\n\n\t\tbcopy(sc->sc_arpcom.ac_enaddr, (caddr_t)&cmd->ie_address,\n\t\t    sizeof cmd->ie_address);\n\n\t\tif (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||\n\t\t    !(cmd->com.ie_cmd_status & IE_STAT_OK)) {\n\t\t\tprintf(\"%s: individual address setup command failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Now run the time-domain reflectometer.\n\t */\n\trun_tdr(sc, ptr);\n\n\t/*\n\t * Acknowledge any interrupts we have generated thus far.\n\t */\n\tie_ack(sc, IE_ST_WHENCE);\n\n\t/*\n\t * Set up the RFA.\n\t */\n\tiememinit(ptr, sc);\n\n\tsc->sc_arpcom.ac_if.if_flags |= IFF_RUNNING;\n\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\n\tsc->scb->ie_recv_list = MK_16(MEM, sc->rframes[0]);\n\tcommand_and_wait(sc, IE_RU_START, 0, 0);\n\n\tie_ack(sc, IE_ST_WHENCE);\n\n\t/* take the ee16 out of loopback */\n\t{\n\tu_char\tbart_config;\n\n\tif(sc->hard_type == IE_EE16) {\n\t\tbart_config = inb(PORT + IEE16_CONFIG);\n\t\tbart_config &= ~IEE16_BART_LOOPBACK;\n\t\tbart_config |= IEE16_BART_MCS16_TEST; /* inb doesn't get bit! */\n\t\toutb(PORT + IEE16_CONFIG, bart_config);\n\t\tee16_interrupt_enable(sc); \n\t\tee16_chan_attn(sc);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define MEM \tsc->sc_maddr",
      "#define PORT\tsc->sc_iobase"
    ],
    "globals_used": [
      "int ieinit",
      "static void ee16_chan_attn",
      "static void ee16_interrupt_enable",
      "static int command_and_wait",
      "void iememinit",
      "static __inline void ie_setup_config",
      "static __inline void ie_ack",
      "static void run_tdr",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ee16_chan_attn",
          "args": [
            "sc"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_chan_attn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1688-1693",
          "snippet": "void\nee16_chan_attn(sc)\n\tstruct ie_softc *sc;\n{\n\toutb(PORT + IEE16_ATTN, 0);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "static void ee16_chan_attn",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nstatic void ee16_chan_attn;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_chan_attn(sc)\n\tstruct ie_softc *sc;\n{\n\toutb(PORT + IEE16_ATTN, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee16_interrupt_enable",
          "args": [
            "sc"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_interrupt_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1778-1785",
          "snippet": "static inline void\nee16_interrupt_enable(sc)\n\tstruct ie_softc *sc;\n{\n\tdelay(100);\n\toutb(PORT + IEE16_IRQ, sc->irq_encoded | IEE16_IRQ_ENABLE);\n\tdelay(100);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "static void ee16_interrupt_enable",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nstatic void ee16_interrupt_enable;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic inline void\nee16_interrupt_enable(sc)\n\tstruct ie_softc *sc;\n{\n\tdelay(100);\n\toutb(PORT + IEE16_IRQ, sc->irq_encoded | IEE16_IRQ_ENABLE);\n\tdelay(100);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "PORT + IEE16_CONFIG",
            "bart_config"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "PORT + IEE16_CONFIG"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ie_ack",
          "args": [
            "sc",
            "IE_ST_WHENCE"
          ],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "ie_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "364-376",
          "snippet": "static __inline void\nie_ack(sc, mask)\n\tstruct ie_softc *sc;\n\tu_int mask;\n{\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\n\tscb->ie_command = scb->ie_status & mask;\n\t(sc->chan_attn)(sc);\n\n\twhile (scb->ie_command)\n\t\t;\t\t/* Spin Lock */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void ie_ack",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline void ie_ack;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic __inline void\nie_ack(sc, mask)\n\tstruct ie_softc *sc;\n\tu_int mask;\n{\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\n\tscb->ie_command = scb->ie_status & mask;\n\t(sc->chan_attn)(sc);\n\n\twhile (scb->ie_command)\n\t\t;\t\t/* Spin Lock */\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_and_wait",
          "args": [
            "sc",
            "IE_RU_START",
            "0",
            "0"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "command_and_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1838-1886",
          "snippet": "static int\ncommand_and_wait(sc, cmd, pcmd, mask)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tvolatile void *pcmd;\n\tint mask;\n{\n\tvolatile struct ie_cmd_common *cc = pcmd;\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvolatile int timedout = 0;\n\textern int hz;\n\n\tscb->ie_command = (u_short)cmd;\n\n\tif (IE_ACTION_COMMAND(cmd) && pcmd) {\n\t\t(sc->chan_attn)(sc);\n\n\t\t/*\n\t\t * According to the packet driver, the minimum timeout should\n\t\t * be .369 seconds, which we round up to .4.\n\t\t */\n\t\ttimeout(chan_attn_timeout, (caddr_t)&timedout, 2 * hz / 5);\n\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, but I haven't figured out how, or indeed if, we\n\t\t * can put the process waiting for action to sleep.  (We may\n\t\t * be getting called through some other timeout running in the\n\t\t * kernel.)\n\t\t */\n\t\tfor (;;)\n\t\t\tif ((cc->ie_cmd_status & mask) || timedout)\n\t\t\t\tbreak;\n\n\t\tuntimeout(chan_attn_timeout, (caddr_t)&timedout);\n\n\t\treturn timedout;\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\t(sc->chan_attn)(sc);\n\n\t\twhile (scb->ie_command)\n\t\t\t;\t\t\t\t/* spin lock */\n\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int command_and_wait",
            "static void chan_attn_timeout",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int command_and_wait;\nstatic void chan_attn_timeout;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic int\ncommand_and_wait(sc, cmd, pcmd, mask)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tvolatile void *pcmd;\n\tint mask;\n{\n\tvolatile struct ie_cmd_common *cc = pcmd;\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvolatile int timedout = 0;\n\textern int hz;\n\n\tscb->ie_command = (u_short)cmd;\n\n\tif (IE_ACTION_COMMAND(cmd) && pcmd) {\n\t\t(sc->chan_attn)(sc);\n\n\t\t/*\n\t\t * According to the packet driver, the minimum timeout should\n\t\t * be .369 seconds, which we round up to .4.\n\t\t */\n\t\ttimeout(chan_attn_timeout, (caddr_t)&timedout, 2 * hz / 5);\n\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, but I haven't figured out how, or indeed if, we\n\t\t * can put the process waiting for action to sleep.  (We may\n\t\t * be getting called through some other timeout running in the\n\t\t * kernel.)\n\t\t */\n\t\tfor (;;)\n\t\t\tif ((cc->ie_cmd_status & mask) || timedout)\n\t\t\t\tbreak;\n\n\t\tuntimeout(chan_attn_timeout, (caddr_t)&timedout);\n\n\t\treturn timedout;\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\t(sc->chan_attn)(sc);\n\n\t\twhile (scb->ie_command)\n\t\t\t;\t\t\t\t/* spin lock */\n\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MK_16",
          "args": [
            "MEM",
            "sc->rframes[0]"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iememinit",
          "args": [
            "ptr",
            "sc"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "iememinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1937-2005",
          "snippet": "void\niememinit(ptr, sc)\n\tvoid *ptr;\n\tstruct ie_softc *sc;\n{\n\tint i;\n\n\t/* First lay them out. */\n\tfor (i = 0; i < NFRAMES; i++)\n\t\tsc->rframes[i] = ALLOC(ptr, sizeof(*sc->rframes[i]));\n\n\t/* Now link them together. */\n\tfor (i = 0; i < NFRAMES; i++)\n\t\tsc->rframes[i]->ie_fd_next =\n\t\t    MK_16(MEM, sc->rframes[(i + 1) % NFRAMES]);\n\n\t/* Finally, set the EOL bit on the last one. */\n\tsc->rframes[NFRAMES - 1]->ie_fd_last |= IE_FD_LAST;\n\n\t/*\n\t * Now lay out some buffers for the incoming frames.  Note that we set\n\t * aside a bit of slop in each buffer, to make sure that we have enough\n\t * space to hold a single frame in every buffer.\n\t */\n\tfor (i = 0; i < NRXBUF; i++) {\n\t\tsc->rbuffs[i] = ALLOC(ptr, sizeof(*sc->rbuffs[i]));\n\t\tsc->rbuffs[i]->ie_rbd_length = IE_RBUF_SIZE;\n\t\tsc->rbuffs[i]->ie_rbd_buffer = MK_24(MEM, ptr);\n\t\tsc->cbuffs[i] = ALLOC(ptr, IE_RBUF_SIZE);\n\t}\n\n\t/* Now link them together. */\n\tfor (i = 0; i < NRXBUF; i++)\n\t\tsc->rbuffs[i]->ie_rbd_next =\n\t\t    MK_16(MEM, sc->rbuffs[(i + 1) % NRXBUF]);\n\n\t/* Tag EOF on the last one. */\n\tsc->rbuffs[NRXBUF - 1]->ie_rbd_length |= IE_RBD_LAST;\n\n\t/*\n\t * We use the head and tail pointers on receive to keep track of the\n\t * order in which RFDs and RBDs are used.\n\t */\n\tsc->rfhead = 0;\n\tsc->rftail = NFRAMES - 1;\n\tsc->rbhead = 0;\n\tsc->rbtail = NRXBUF - 1;\n\n\tsc->scb->ie_recv_list = MK_16(MEM, sc->rframes[0]);\n\tsc->rframes[0]->ie_fd_buf_desc = MK_16(MEM, sc->rbuffs[0]);\n\n\t/*\n\t * Finally, the transmit command and buffer are the last little bit of\n\t * work.\n\t */\n\tfor (i = 0; i < NTXBUF; i++) {\n\t\tsc->xmit_cmds[i] = ALLOC(ptr, sizeof(*sc->xmit_cmds[i]));\n\t\tsc->xmit_buffs[i] = ALLOC(ptr, sizeof(*sc->xmit_buffs[i]));\n\t}\n\n\tfor (i = 0; i < NTXBUF; i++)\n\t\tsc->xmit_cbuffs[i] = ALLOC(ptr, IE_TBUF_SIZE);\n\n\t/* Pointers to last packet sent and next available transmit buffer. */\n\tsc->xchead = sc->xctail = 0;\n\n\t/* Clear transmit-busy flag and set number of free transmit buffers. */\n\tsc->xmit_busy = 0;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define MEM \tsc->sc_maddr",
            "#define\tIE_TBUF_SIZE\tETHER_MAX_LEN\t/* length of transmit buffer */",
            "#define\tNTXBUF\t\t2\t\t/* number of transmit commands */",
            "#define\tIE_RBUF_SIZE\t256\t\t/* size of each receive buffer;\n\t\t\t\t\t\tMUST BE POWER OF TWO */",
            "#define\tNRXBUF\t\t48\t\t/* number of buffers to allocate */",
            "#define\tNFRAMES\t\t16\t\t/* number of receive frames */"
          ],
          "globals_used": [
            "void iememinit",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define MEM \tsc->sc_maddr\n#define\tIE_TBUF_SIZE\tETHER_MAX_LEN\t/* length of transmit buffer */\n#define\tNTXBUF\t\t2\t\t/* number of transmit commands */\n#define\tIE_RBUF_SIZE\t256\t\t/* size of each receive buffer;\n\t\t\t\t\t\tMUST BE POWER OF TWO */\n#define\tNRXBUF\t\t48\t\t/* number of buffers to allocate */\n#define\tNFRAMES\t\t16\t\t/* number of receive frames */\n\nvoid iememinit;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\niememinit(ptr, sc)\n\tvoid *ptr;\n\tstruct ie_softc *sc;\n{\n\tint i;\n\n\t/* First lay them out. */\n\tfor (i = 0; i < NFRAMES; i++)\n\t\tsc->rframes[i] = ALLOC(ptr, sizeof(*sc->rframes[i]));\n\n\t/* Now link them together. */\n\tfor (i = 0; i < NFRAMES; i++)\n\t\tsc->rframes[i]->ie_fd_next =\n\t\t    MK_16(MEM, sc->rframes[(i + 1) % NFRAMES]);\n\n\t/* Finally, set the EOL bit on the last one. */\n\tsc->rframes[NFRAMES - 1]->ie_fd_last |= IE_FD_LAST;\n\n\t/*\n\t * Now lay out some buffers for the incoming frames.  Note that we set\n\t * aside a bit of slop in each buffer, to make sure that we have enough\n\t * space to hold a single frame in every buffer.\n\t */\n\tfor (i = 0; i < NRXBUF; i++) {\n\t\tsc->rbuffs[i] = ALLOC(ptr, sizeof(*sc->rbuffs[i]));\n\t\tsc->rbuffs[i]->ie_rbd_length = IE_RBUF_SIZE;\n\t\tsc->rbuffs[i]->ie_rbd_buffer = MK_24(MEM, ptr);\n\t\tsc->cbuffs[i] = ALLOC(ptr, IE_RBUF_SIZE);\n\t}\n\n\t/* Now link them together. */\n\tfor (i = 0; i < NRXBUF; i++)\n\t\tsc->rbuffs[i]->ie_rbd_next =\n\t\t    MK_16(MEM, sc->rbuffs[(i + 1) % NRXBUF]);\n\n\t/* Tag EOF on the last one. */\n\tsc->rbuffs[NRXBUF - 1]->ie_rbd_length |= IE_RBD_LAST;\n\n\t/*\n\t * We use the head and tail pointers on receive to keep track of the\n\t * order in which RFDs and RBDs are used.\n\t */\n\tsc->rfhead = 0;\n\tsc->rftail = NFRAMES - 1;\n\tsc->rbhead = 0;\n\tsc->rbtail = NRXBUF - 1;\n\n\tsc->scb->ie_recv_list = MK_16(MEM, sc->rframes[0]);\n\tsc->rframes[0]->ie_fd_buf_desc = MK_16(MEM, sc->rbuffs[0]);\n\n\t/*\n\t * Finally, the transmit command and buffer are the last little bit of\n\t * work.\n\t */\n\tfor (i = 0; i < NTXBUF; i++) {\n\t\tsc->xmit_cmds[i] = ALLOC(ptr, sizeof(*sc->xmit_cmds[i]));\n\t\tsc->xmit_buffs[i] = ALLOC(ptr, sizeof(*sc->xmit_buffs[i]));\n\t}\n\n\tfor (i = 0; i < NTXBUF; i++)\n\t\tsc->xmit_cbuffs[i] = ALLOC(ptr, IE_TBUF_SIZE);\n\n\t/* Pointers to last packet sent and next available transmit buffer. */\n\tsc->xchead = sc->xctail = 0;\n\n\t/* Clear transmit-busy flag and set number of free transmit buffers. */\n\tsc->xmit_busy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "run_tdr",
          "args": [
            "sc",
            "ptr"
          ],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "run_tdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1891-1929",
          "snippet": "static void\nrun_tdr(sc, cmd)\n\tstruct ie_softc *sc;\n\tstruct ie_tdr_cmd *cmd;\n{\n\tint result;\n\n\tcmd->com.ie_cmd_status = 0;\n\tcmd->com.ie_cmd_cmd = IE_CMD_TDR | IE_CMD_LAST;\n\tcmd->com.ie_cmd_link = 0xffff;\n\n\tsc->scb->ie_command_list = MK_16(MEM, cmd);\n\tcmd->ie_tdr_time = 0;\n\n\tif (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||\n\t    !(cmd->com.ie_cmd_status & IE_STAT_OK))\n\t\tresult = 0x10000;\n\telse\n\t\tresult = cmd->ie_tdr_time;\n\n\tie_ack(sc, IE_ST_WHENCE);\n\n\tif (result & IE_TDR_SUCCESS)\n\t\treturn;\n\n\tif (result & 0x10000)\n\t\tprintf(\"%s: TDR command failed\\n\", sc->sc_dev.dv_xname);\n\telse if (result & IE_TDR_XCVR)\n\t\tprintf(\"%s: transceiver problem\\n\", sc->sc_dev.dv_xname);\n\telse if (result & IE_TDR_OPEN)\n\t\tprintf(\"%s: TDR detected an open %d clocks away\\n\",\n\t\t    sc->sc_dev.dv_xname, result & IE_TDR_TIME);\n\telse if (result & IE_TDR_SHORT)\n\t\tprintf(\"%s: TDR detected a short %d clocks away\\n\",\n\t\t    sc->sc_dev.dv_xname, result & IE_TDR_TIME);\n\telse\n\t\tprintf(\"%s: TDR returned unknown status %x\\n\",\n\t\t    sc->sc_dev.dv_xname, result);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define MEM \tsc->sc_maddr"
          ],
          "globals_used": [
            "static int command_and_wait",
            "static __inline void ie_ack",
            "static void run_tdr",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define MEM \tsc->sc_maddr\n\nstatic int command_and_wait;\nstatic __inline void ie_ack;\nstatic void run_tdr;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic void\nrun_tdr(sc, cmd)\n\tstruct ie_softc *sc;\n\tstruct ie_tdr_cmd *cmd;\n{\n\tint result;\n\n\tcmd->com.ie_cmd_status = 0;\n\tcmd->com.ie_cmd_cmd = IE_CMD_TDR | IE_CMD_LAST;\n\tcmd->com.ie_cmd_link = 0xffff;\n\n\tsc->scb->ie_command_list = MK_16(MEM, cmd);\n\tcmd->ie_tdr_time = 0;\n\n\tif (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||\n\t    !(cmd->com.ie_cmd_status & IE_STAT_OK))\n\t\tresult = 0x10000;\n\telse\n\t\tresult = cmd->ie_tdr_time;\n\n\tie_ack(sc, IE_ST_WHENCE);\n\n\tif (result & IE_TDR_SUCCESS)\n\t\treturn;\n\n\tif (result & 0x10000)\n\t\tprintf(\"%s: TDR command failed\\n\", sc->sc_dev.dv_xname);\n\telse if (result & IE_TDR_XCVR)\n\t\tprintf(\"%s: transceiver problem\\n\", sc->sc_dev.dv_xname);\n\telse if (result & IE_TDR_OPEN)\n\t\tprintf(\"%s: TDR detected an open %d clocks away\\n\",\n\t\t    sc->sc_dev.dv_xname, result & IE_TDR_TIME);\n\telse if (result & IE_TDR_SHORT)\n\t\tprintf(\"%s: TDR detected a short %d clocks away\\n\",\n\t\t    sc->sc_dev.dv_xname, result & IE_TDR_TIME);\n\telse\n\t\tprintf(\"%s: TDR returned unknown status %x\\n\",\n\t\t    sc->sc_dev.dv_xname, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: individual address setup command failed\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_arpcom.ac_enaddr",
            "(caddr_t)&cmd->ie_address",
            "sizeof cmd->ie_address"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "MK_16",
          "args": [
            "MEM",
            "cmd"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ie_setup_config",
          "args": [
            "cmd",
            "sc->promisc != 0",
            "sc->hard_type == IE_STARLAN10"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "ie_setup_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "344-362",
          "snippet": "static __inline void\nie_setup_config(cmd, promiscuous, manchester)\n\tvolatile struct ie_config_cmd *cmd;\n\tint promiscuous, manchester;\n{\n\n\tcmd->ie_config_count = 0x0c;\n\tcmd->ie_fifo = 8;\n\tcmd->ie_save_bad = 0x40;\n\tcmd->ie_addr_len = 0x2e;\n\tcmd->ie_priority = 0;\n\tcmd->ie_ifs = 0x60;\n\tcmd->ie_slot_low = 0;\n\tcmd->ie_slot_high = 0xf2;\n\tcmd->ie_promisc = promiscuous | manchester << 2;\n\tcmd->ie_crs_cdt = 0;\n\tcmd->ie_min_len = 64;\n\tcmd->ie_junk = 0xff;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void ie_setup_config"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline void ie_setup_config;\n\nstatic __inline void\nie_setup_config(cmd, promiscuous, manchester)\n\tvolatile struct ie_config_cmd *cmd;\n\tint promiscuous, manchester;\n{\n\n\tcmd->ie_config_count = 0x0c;\n\tcmd->ie_fifo = 8;\n\tcmd->ie_save_bad = 0x40;\n\tcmd->ie_addr_len = 0x2e;\n\tcmd->ie_priority = 0;\n\tcmd->ie_ifs = 0x60;\n\tcmd->ie_slot_low = 0;\n\tcmd->ie_slot_high = 0xf2;\n\tcmd->ie_promisc = promiscuous | manchester << 2;\n\tcmd->ie_crs_cdt = 0;\n\tcmd->ie_min_len = 64;\n\tcmd->ie_junk = 0xff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MK_16",
          "args": [
            "MEM",
            "cmd"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "scb + 1"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define MEM \tsc->sc_maddr\n#define PORT\tsc->sc_iobase\n\nint ieinit;\nstatic void ee16_chan_attn;\nstatic void ee16_interrupt_enable;\nstatic int command_and_wait;\nvoid iememinit;\nstatic __inline void ie_setup_config;\nstatic __inline void ie_ack;\nstatic void run_tdr;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nieinit(sc)\n\tstruct ie_softc *sc;\n{\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvoid *ptr;\n\n\tptr = (void *)ALIGN(scb + 1);\n\n\t/*\n\t * Send the configure command first.\n\t */\n\t{\n\t\tvolatile struct ie_config_cmd *cmd = ptr;\n\n\t\tscb->ie_command_list = MK_16(MEM, cmd);\n\t\tcmd->com.ie_cmd_status = 0;\n\t\tcmd->com.ie_cmd_cmd = IE_CMD_CONFIG | IE_CMD_LAST;\n\t\tcmd->com.ie_cmd_link = 0xffff;\n\n\t\tie_setup_config(cmd, sc->promisc != 0,\n\t\t    sc->hard_type == IE_STARLAN10);\n\n\t\tif (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||\n\t\t    !(cmd->com.ie_cmd_status & IE_STAT_OK)) {\n\t\t\tprintf(\"%s: configure command failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Now send the Individual Address Setup command.\n\t */\n\t{\n\t\tvolatile struct ie_iasetup_cmd *cmd = ptr;\n\n\t\tscb->ie_command_list = MK_16(MEM, cmd);\n\t\tcmd->com.ie_cmd_status = 0;\n\t\tcmd->com.ie_cmd_cmd = IE_CMD_IASETUP | IE_CMD_LAST;\n\t\tcmd->com.ie_cmd_link = 0xffff;\n\n\t\tbcopy(sc->sc_arpcom.ac_enaddr, (caddr_t)&cmd->ie_address,\n\t\t    sizeof cmd->ie_address);\n\n\t\tif (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||\n\t\t    !(cmd->com.ie_cmd_status & IE_STAT_OK)) {\n\t\t\tprintf(\"%s: individual address setup command failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Now run the time-domain reflectometer.\n\t */\n\trun_tdr(sc, ptr);\n\n\t/*\n\t * Acknowledge any interrupts we have generated thus far.\n\t */\n\tie_ack(sc, IE_ST_WHENCE);\n\n\t/*\n\t * Set up the RFA.\n\t */\n\tiememinit(ptr, sc);\n\n\tsc->sc_arpcom.ac_if.if_flags |= IFF_RUNNING;\n\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\n\tsc->scb->ie_recv_list = MK_16(MEM, sc->rframes[0]);\n\tcommand_and_wait(sc, IE_RU_START, 0, 0);\n\n\tie_ack(sc, IE_ST_WHENCE);\n\n\t/* take the ee16 out of loopback */\n\t{\n\tu_char\tbart_config;\n\n\tif(sc->hard_type == IE_EE16) {\n\t\tbart_config = inb(PORT + IEE16_CONFIG);\n\t\tbart_config &= ~IEE16_BART_LOOPBACK;\n\t\tbart_config |= IEE16_BART_MCS16_TEST; /* inb doesn't get bit! */\n\t\toutb(PORT + IEE16_CONFIG, bart_config);\n\t\tee16_interrupt_enable(sc); \n\t\tee16_chan_attn(sc);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "mc_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "2011-2035",
    "snippet": "static int\nmc_setup(sc, ptr)\n\tstruct ie_softc *sc;\n\tvoid *ptr;\n{\n\tvolatile struct ie_mcast_cmd *cmd = ptr;\n\n\tcmd->com.ie_cmd_status = 0;\n\tcmd->com.ie_cmd_cmd = IE_CMD_MCAST | IE_CMD_LAST;\n\tcmd->com.ie_cmd_link = 0xffff;\n\n\tbcopy((caddr_t)sc->mcast_addrs, (caddr_t)cmd->ie_mcast_addrs,\n\t    sc->mcast_count * sizeof *sc->mcast_addrs);\n\n\tcmd->ie_mcast_bytes = sc->mcast_count * ETHER_ADDR_LEN; /* grrr... */\n\n\tsc->scb->ie_command_list = MK_16(MEM, cmd);\n\tif (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||\n\t    !(cmd->com.ie_cmd_status & IE_STAT_OK)) {\n\t\tprintf(\"%s: multicast address setup command failed\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define MEM \tsc->sc_maddr",
      "#define\tETHER_ADDR_LEN\t6"
    ],
    "globals_used": [
      "static int command_and_wait",
      "static int mc_setup",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: multicast address setup command failed\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 2030
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_and_wait",
          "args": [
            "sc",
            "IE_CU_START",
            "cmd",
            "IE_STAT_COMPL"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "command_and_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1838-1886",
          "snippet": "static int\ncommand_and_wait(sc, cmd, pcmd, mask)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tvolatile void *pcmd;\n\tint mask;\n{\n\tvolatile struct ie_cmd_common *cc = pcmd;\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvolatile int timedout = 0;\n\textern int hz;\n\n\tscb->ie_command = (u_short)cmd;\n\n\tif (IE_ACTION_COMMAND(cmd) && pcmd) {\n\t\t(sc->chan_attn)(sc);\n\n\t\t/*\n\t\t * According to the packet driver, the minimum timeout should\n\t\t * be .369 seconds, which we round up to .4.\n\t\t */\n\t\ttimeout(chan_attn_timeout, (caddr_t)&timedout, 2 * hz / 5);\n\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, but I haven't figured out how, or indeed if, we\n\t\t * can put the process waiting for action to sleep.  (We may\n\t\t * be getting called through some other timeout running in the\n\t\t * kernel.)\n\t\t */\n\t\tfor (;;)\n\t\t\tif ((cc->ie_cmd_status & mask) || timedout)\n\t\t\t\tbreak;\n\n\t\tuntimeout(chan_attn_timeout, (caddr_t)&timedout);\n\n\t\treturn timedout;\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\t(sc->chan_attn)(sc);\n\n\t\twhile (scb->ie_command)\n\t\t\t;\t\t\t\t/* spin lock */\n\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int command_and_wait",
            "static void chan_attn_timeout",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int command_and_wait;\nstatic void chan_attn_timeout;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic int\ncommand_and_wait(sc, cmd, pcmd, mask)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tvolatile void *pcmd;\n\tint mask;\n{\n\tvolatile struct ie_cmd_common *cc = pcmd;\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvolatile int timedout = 0;\n\textern int hz;\n\n\tscb->ie_command = (u_short)cmd;\n\n\tif (IE_ACTION_COMMAND(cmd) && pcmd) {\n\t\t(sc->chan_attn)(sc);\n\n\t\t/*\n\t\t * According to the packet driver, the minimum timeout should\n\t\t * be .369 seconds, which we round up to .4.\n\t\t */\n\t\ttimeout(chan_attn_timeout, (caddr_t)&timedout, 2 * hz / 5);\n\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, but I haven't figured out how, or indeed if, we\n\t\t * can put the process waiting for action to sleep.  (We may\n\t\t * be getting called through some other timeout running in the\n\t\t * kernel.)\n\t\t */\n\t\tfor (;;)\n\t\t\tif ((cc->ie_cmd_status & mask) || timedout)\n\t\t\t\tbreak;\n\n\t\tuntimeout(chan_attn_timeout, (caddr_t)&timedout);\n\n\t\treturn timedout;\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\t(sc->chan_attn)(sc);\n\n\t\twhile (scb->ie_command)\n\t\t\t;\t\t\t\t/* spin lock */\n\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MK_16",
          "args": [
            "MEM",
            "cmd"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(caddr_t)sc->mcast_addrs",
            "(caddr_t)cmd->ie_mcast_addrs",
            "sc->mcast_count * sizeof *sc->mcast_addrs"
          ],
          "line": 2022
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define MEM \tsc->sc_maddr\n#define\tETHER_ADDR_LEN\t6\n\nstatic int command_and_wait;\nstatic int mc_setup;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic int\nmc_setup(sc, ptr)\n\tstruct ie_softc *sc;\n\tvoid *ptr;\n{\n\tvolatile struct ie_mcast_cmd *cmd = ptr;\n\n\tcmd->com.ie_cmd_status = 0;\n\tcmd->com.ie_cmd_cmd = IE_CMD_MCAST | IE_CMD_LAST;\n\tcmd->com.ie_cmd_link = 0xffff;\n\n\tbcopy((caddr_t)sc->mcast_addrs, (caddr_t)cmd->ie_mcast_addrs,\n\t    sc->mcast_count * sizeof *sc->mcast_addrs);\n\n\tcmd->ie_mcast_bytes = sc->mcast_count * ETHER_ADDR_LEN; /* grrr... */\n\n\tsc->scb->ie_command_list = MK_16(MEM, cmd);\n\tif (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||\n\t    !(cmd->com.ie_cmd_status & IE_STAT_OK)) {\n\t\tprintf(\"%s: multicast address setup command failed\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "iememinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1937-2005",
    "snippet": "void\niememinit(ptr, sc)\n\tvoid *ptr;\n\tstruct ie_softc *sc;\n{\n\tint i;\n\n\t/* First lay them out. */\n\tfor (i = 0; i < NFRAMES; i++)\n\t\tsc->rframes[i] = ALLOC(ptr, sizeof(*sc->rframes[i]));\n\n\t/* Now link them together. */\n\tfor (i = 0; i < NFRAMES; i++)\n\t\tsc->rframes[i]->ie_fd_next =\n\t\t    MK_16(MEM, sc->rframes[(i + 1) % NFRAMES]);\n\n\t/* Finally, set the EOL bit on the last one. */\n\tsc->rframes[NFRAMES - 1]->ie_fd_last |= IE_FD_LAST;\n\n\t/*\n\t * Now lay out some buffers for the incoming frames.  Note that we set\n\t * aside a bit of slop in each buffer, to make sure that we have enough\n\t * space to hold a single frame in every buffer.\n\t */\n\tfor (i = 0; i < NRXBUF; i++) {\n\t\tsc->rbuffs[i] = ALLOC(ptr, sizeof(*sc->rbuffs[i]));\n\t\tsc->rbuffs[i]->ie_rbd_length = IE_RBUF_SIZE;\n\t\tsc->rbuffs[i]->ie_rbd_buffer = MK_24(MEM, ptr);\n\t\tsc->cbuffs[i] = ALLOC(ptr, IE_RBUF_SIZE);\n\t}\n\n\t/* Now link them together. */\n\tfor (i = 0; i < NRXBUF; i++)\n\t\tsc->rbuffs[i]->ie_rbd_next =\n\t\t    MK_16(MEM, sc->rbuffs[(i + 1) % NRXBUF]);\n\n\t/* Tag EOF on the last one. */\n\tsc->rbuffs[NRXBUF - 1]->ie_rbd_length |= IE_RBD_LAST;\n\n\t/*\n\t * We use the head and tail pointers on receive to keep track of the\n\t * order in which RFDs and RBDs are used.\n\t */\n\tsc->rfhead = 0;\n\tsc->rftail = NFRAMES - 1;\n\tsc->rbhead = 0;\n\tsc->rbtail = NRXBUF - 1;\n\n\tsc->scb->ie_recv_list = MK_16(MEM, sc->rframes[0]);\n\tsc->rframes[0]->ie_fd_buf_desc = MK_16(MEM, sc->rbuffs[0]);\n\n\t/*\n\t * Finally, the transmit command and buffer are the last little bit of\n\t * work.\n\t */\n\tfor (i = 0; i < NTXBUF; i++) {\n\t\tsc->xmit_cmds[i] = ALLOC(ptr, sizeof(*sc->xmit_cmds[i]));\n\t\tsc->xmit_buffs[i] = ALLOC(ptr, sizeof(*sc->xmit_buffs[i]));\n\t}\n\n\tfor (i = 0; i < NTXBUF; i++)\n\t\tsc->xmit_cbuffs[i] = ALLOC(ptr, IE_TBUF_SIZE);\n\n\t/* Pointers to last packet sent and next available transmit buffer. */\n\tsc->xchead = sc->xctail = 0;\n\n\t/* Clear transmit-busy flag and set number of free transmit buffers. */\n\tsc->xmit_busy = 0;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define MEM \tsc->sc_maddr",
      "#define\tIE_TBUF_SIZE\tETHER_MAX_LEN\t/* length of transmit buffer */",
      "#define\tNTXBUF\t\t2\t\t/* number of transmit commands */",
      "#define\tIE_RBUF_SIZE\t256\t\t/* size of each receive buffer;\n\t\t\t\t\t\tMUST BE POWER OF TWO */",
      "#define\tNRXBUF\t\t48\t\t/* number of buffers to allocate */",
      "#define\tNFRAMES\t\t16\t\t/* number of receive frames */"
    ],
    "globals_used": [
      "void iememinit",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ALLOC",
          "args": [
            "ptr",
            "IE_TBUF_SIZE"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALLOC",
          "args": [
            "ptr",
            "sizeof(*sc->xmit_buffs[i])"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALLOC",
          "args": [
            "ptr",
            "sizeof(*sc->xmit_cmds[i])"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MK_16",
          "args": [
            "MEM",
            "sc->rbuffs[0]"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MK_16",
          "args": [
            "MEM",
            "sc->rframes[0]"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MK_16",
          "args": [
            "MEM",
            "sc->rbuffs[(i + 1) % NRXBUF]"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALLOC",
          "args": [
            "ptr",
            "IE_RBUF_SIZE"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MK_24",
          "args": [
            "MEM",
            "ptr"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALLOC",
          "args": [
            "ptr",
            "sizeof(*sc->rbuffs[i])"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MK_16",
          "args": [
            "MEM",
            "sc->rframes[(i + 1) % NFRAMES]"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALLOC",
          "args": [
            "ptr",
            "sizeof(*sc->rframes[i])"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define MEM \tsc->sc_maddr\n#define\tIE_TBUF_SIZE\tETHER_MAX_LEN\t/* length of transmit buffer */\n#define\tNTXBUF\t\t2\t\t/* number of transmit commands */\n#define\tIE_RBUF_SIZE\t256\t\t/* size of each receive buffer;\n\t\t\t\t\t\tMUST BE POWER OF TWO */\n#define\tNRXBUF\t\t48\t\t/* number of buffers to allocate */\n#define\tNFRAMES\t\t16\t\t/* number of receive frames */\n\nvoid iememinit;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\niememinit(ptr, sc)\n\tvoid *ptr;\n\tstruct ie_softc *sc;\n{\n\tint i;\n\n\t/* First lay them out. */\n\tfor (i = 0; i < NFRAMES; i++)\n\t\tsc->rframes[i] = ALLOC(ptr, sizeof(*sc->rframes[i]));\n\n\t/* Now link them together. */\n\tfor (i = 0; i < NFRAMES; i++)\n\t\tsc->rframes[i]->ie_fd_next =\n\t\t    MK_16(MEM, sc->rframes[(i + 1) % NFRAMES]);\n\n\t/* Finally, set the EOL bit on the last one. */\n\tsc->rframes[NFRAMES - 1]->ie_fd_last |= IE_FD_LAST;\n\n\t/*\n\t * Now lay out some buffers for the incoming frames.  Note that we set\n\t * aside a bit of slop in each buffer, to make sure that we have enough\n\t * space to hold a single frame in every buffer.\n\t */\n\tfor (i = 0; i < NRXBUF; i++) {\n\t\tsc->rbuffs[i] = ALLOC(ptr, sizeof(*sc->rbuffs[i]));\n\t\tsc->rbuffs[i]->ie_rbd_length = IE_RBUF_SIZE;\n\t\tsc->rbuffs[i]->ie_rbd_buffer = MK_24(MEM, ptr);\n\t\tsc->cbuffs[i] = ALLOC(ptr, IE_RBUF_SIZE);\n\t}\n\n\t/* Now link them together. */\n\tfor (i = 0; i < NRXBUF; i++)\n\t\tsc->rbuffs[i]->ie_rbd_next =\n\t\t    MK_16(MEM, sc->rbuffs[(i + 1) % NRXBUF]);\n\n\t/* Tag EOF on the last one. */\n\tsc->rbuffs[NRXBUF - 1]->ie_rbd_length |= IE_RBD_LAST;\n\n\t/*\n\t * We use the head and tail pointers on receive to keep track of the\n\t * order in which RFDs and RBDs are used.\n\t */\n\tsc->rfhead = 0;\n\tsc->rftail = NFRAMES - 1;\n\tsc->rbhead = 0;\n\tsc->rbtail = NRXBUF - 1;\n\n\tsc->scb->ie_recv_list = MK_16(MEM, sc->rframes[0]);\n\tsc->rframes[0]->ie_fd_buf_desc = MK_16(MEM, sc->rbuffs[0]);\n\n\t/*\n\t * Finally, the transmit command and buffer are the last little bit of\n\t * work.\n\t */\n\tfor (i = 0; i < NTXBUF; i++) {\n\t\tsc->xmit_cmds[i] = ALLOC(ptr, sizeof(*sc->xmit_cmds[i]));\n\t\tsc->xmit_buffs[i] = ALLOC(ptr, sizeof(*sc->xmit_buffs[i]));\n\t}\n\n\tfor (i = 0; i < NTXBUF; i++)\n\t\tsc->xmit_cbuffs[i] = ALLOC(ptr, IE_TBUF_SIZE);\n\n\t/* Pointers to last packet sent and next available transmit buffer. */\n\tsc->xchead = sc->xctail = 0;\n\n\t/* Clear transmit-busy flag and set number of free transmit buffers. */\n\tsc->xmit_busy = 0;\n}"
  },
  {
    "function_name": "run_tdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1891-1929",
    "snippet": "static void\nrun_tdr(sc, cmd)\n\tstruct ie_softc *sc;\n\tstruct ie_tdr_cmd *cmd;\n{\n\tint result;\n\n\tcmd->com.ie_cmd_status = 0;\n\tcmd->com.ie_cmd_cmd = IE_CMD_TDR | IE_CMD_LAST;\n\tcmd->com.ie_cmd_link = 0xffff;\n\n\tsc->scb->ie_command_list = MK_16(MEM, cmd);\n\tcmd->ie_tdr_time = 0;\n\n\tif (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||\n\t    !(cmd->com.ie_cmd_status & IE_STAT_OK))\n\t\tresult = 0x10000;\n\telse\n\t\tresult = cmd->ie_tdr_time;\n\n\tie_ack(sc, IE_ST_WHENCE);\n\n\tif (result & IE_TDR_SUCCESS)\n\t\treturn;\n\n\tif (result & 0x10000)\n\t\tprintf(\"%s: TDR command failed\\n\", sc->sc_dev.dv_xname);\n\telse if (result & IE_TDR_XCVR)\n\t\tprintf(\"%s: transceiver problem\\n\", sc->sc_dev.dv_xname);\n\telse if (result & IE_TDR_OPEN)\n\t\tprintf(\"%s: TDR detected an open %d clocks away\\n\",\n\t\t    sc->sc_dev.dv_xname, result & IE_TDR_TIME);\n\telse if (result & IE_TDR_SHORT)\n\t\tprintf(\"%s: TDR detected a short %d clocks away\\n\",\n\t\t    sc->sc_dev.dv_xname, result & IE_TDR_TIME);\n\telse\n\t\tprintf(\"%s: TDR returned unknown status %x\\n\",\n\t\t    sc->sc_dev.dv_xname, result);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define MEM \tsc->sc_maddr"
    ],
    "globals_used": [
      "static int command_and_wait",
      "static __inline void ie_ack",
      "static void run_tdr",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: TDR returned unknown status %x\\n\"",
            "sc->sc_dev.dv_xname",
            "result"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ie_ack",
          "args": [
            "sc",
            "IE_ST_WHENCE"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "ie_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "364-376",
          "snippet": "static __inline void\nie_ack(sc, mask)\n\tstruct ie_softc *sc;\n\tu_int mask;\n{\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\n\tscb->ie_command = scb->ie_status & mask;\n\t(sc->chan_attn)(sc);\n\n\twhile (scb->ie_command)\n\t\t;\t\t/* Spin Lock */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void ie_ack",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline void ie_ack;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic __inline void\nie_ack(sc, mask)\n\tstruct ie_softc *sc;\n\tu_int mask;\n{\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\n\tscb->ie_command = scb->ie_status & mask;\n\t(sc->chan_attn)(sc);\n\n\twhile (scb->ie_command)\n\t\t;\t\t/* Spin Lock */\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_and_wait",
          "args": [
            "sc",
            "IE_CU_START",
            "cmd",
            "IE_STAT_COMPL"
          ],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "command_and_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1838-1886",
          "snippet": "static int\ncommand_and_wait(sc, cmd, pcmd, mask)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tvolatile void *pcmd;\n\tint mask;\n{\n\tvolatile struct ie_cmd_common *cc = pcmd;\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvolatile int timedout = 0;\n\textern int hz;\n\n\tscb->ie_command = (u_short)cmd;\n\n\tif (IE_ACTION_COMMAND(cmd) && pcmd) {\n\t\t(sc->chan_attn)(sc);\n\n\t\t/*\n\t\t * According to the packet driver, the minimum timeout should\n\t\t * be .369 seconds, which we round up to .4.\n\t\t */\n\t\ttimeout(chan_attn_timeout, (caddr_t)&timedout, 2 * hz / 5);\n\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, but I haven't figured out how, or indeed if, we\n\t\t * can put the process waiting for action to sleep.  (We may\n\t\t * be getting called through some other timeout running in the\n\t\t * kernel.)\n\t\t */\n\t\tfor (;;)\n\t\t\tif ((cc->ie_cmd_status & mask) || timedout)\n\t\t\t\tbreak;\n\n\t\tuntimeout(chan_attn_timeout, (caddr_t)&timedout);\n\n\t\treturn timedout;\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\t(sc->chan_attn)(sc);\n\n\t\twhile (scb->ie_command)\n\t\t\t;\t\t\t\t/* spin lock */\n\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int command_and_wait",
            "static void chan_attn_timeout",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int command_and_wait;\nstatic void chan_attn_timeout;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic int\ncommand_and_wait(sc, cmd, pcmd, mask)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tvolatile void *pcmd;\n\tint mask;\n{\n\tvolatile struct ie_cmd_common *cc = pcmd;\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvolatile int timedout = 0;\n\textern int hz;\n\n\tscb->ie_command = (u_short)cmd;\n\n\tif (IE_ACTION_COMMAND(cmd) && pcmd) {\n\t\t(sc->chan_attn)(sc);\n\n\t\t/*\n\t\t * According to the packet driver, the minimum timeout should\n\t\t * be .369 seconds, which we round up to .4.\n\t\t */\n\t\ttimeout(chan_attn_timeout, (caddr_t)&timedout, 2 * hz / 5);\n\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, but I haven't figured out how, or indeed if, we\n\t\t * can put the process waiting for action to sleep.  (We may\n\t\t * be getting called through some other timeout running in the\n\t\t * kernel.)\n\t\t */\n\t\tfor (;;)\n\t\t\tif ((cc->ie_cmd_status & mask) || timedout)\n\t\t\t\tbreak;\n\n\t\tuntimeout(chan_attn_timeout, (caddr_t)&timedout);\n\n\t\treturn timedout;\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\t(sc->chan_attn)(sc);\n\n\t\twhile (scb->ie_command)\n\t\t\t;\t\t\t\t/* spin lock */\n\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MK_16",
          "args": [
            "MEM",
            "cmd"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define MEM \tsc->sc_maddr\n\nstatic int command_and_wait;\nstatic __inline void ie_ack;\nstatic void run_tdr;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic void\nrun_tdr(sc, cmd)\n\tstruct ie_softc *sc;\n\tstruct ie_tdr_cmd *cmd;\n{\n\tint result;\n\n\tcmd->com.ie_cmd_status = 0;\n\tcmd->com.ie_cmd_cmd = IE_CMD_TDR | IE_CMD_LAST;\n\tcmd->com.ie_cmd_link = 0xffff;\n\n\tsc->scb->ie_command_list = MK_16(MEM, cmd);\n\tcmd->ie_tdr_time = 0;\n\n\tif (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||\n\t    !(cmd->com.ie_cmd_status & IE_STAT_OK))\n\t\tresult = 0x10000;\n\telse\n\t\tresult = cmd->ie_tdr_time;\n\n\tie_ack(sc, IE_ST_WHENCE);\n\n\tif (result & IE_TDR_SUCCESS)\n\t\treturn;\n\n\tif (result & 0x10000)\n\t\tprintf(\"%s: TDR command failed\\n\", sc->sc_dev.dv_xname);\n\telse if (result & IE_TDR_XCVR)\n\t\tprintf(\"%s: transceiver problem\\n\", sc->sc_dev.dv_xname);\n\telse if (result & IE_TDR_OPEN)\n\t\tprintf(\"%s: TDR detected an open %d clocks away\\n\",\n\t\t    sc->sc_dev.dv_xname, result & IE_TDR_TIME);\n\telse if (result & IE_TDR_SHORT)\n\t\tprintf(\"%s: TDR detected a short %d clocks away\\n\",\n\t\t    sc->sc_dev.dv_xname, result & IE_TDR_TIME);\n\telse\n\t\tprintf(\"%s: TDR returned unknown status %x\\n\",\n\t\t    sc->sc_dev.dv_xname, result);\n}"
  },
  {
    "function_name": "command_and_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1838-1886",
    "snippet": "static int\ncommand_and_wait(sc, cmd, pcmd, mask)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tvolatile void *pcmd;\n\tint mask;\n{\n\tvolatile struct ie_cmd_common *cc = pcmd;\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvolatile int timedout = 0;\n\textern int hz;\n\n\tscb->ie_command = (u_short)cmd;\n\n\tif (IE_ACTION_COMMAND(cmd) && pcmd) {\n\t\t(sc->chan_attn)(sc);\n\n\t\t/*\n\t\t * According to the packet driver, the minimum timeout should\n\t\t * be .369 seconds, which we round up to .4.\n\t\t */\n\t\ttimeout(chan_attn_timeout, (caddr_t)&timedout, 2 * hz / 5);\n\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, but I haven't figured out how, or indeed if, we\n\t\t * can put the process waiting for action to sleep.  (We may\n\t\t * be getting called through some other timeout running in the\n\t\t * kernel.)\n\t\t */\n\t\tfor (;;)\n\t\t\tif ((cc->ie_cmd_status & mask) || timedout)\n\t\t\t\tbreak;\n\n\t\tuntimeout(chan_attn_timeout, (caddr_t)&timedout);\n\n\t\treturn timedout;\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\t(sc->chan_attn)(sc);\n\n\t\twhile (scb->ie_command)\n\t\t\t;\t\t\t\t/* spin lock */\n\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int command_and_wait",
      "static void chan_attn_timeout",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "chan_attn_timeout",
            "(caddr_t)&timedout"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "chan_attn_timeout",
            "(caddr_t)&timedout",
            "2 * hz / 5"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "chan_attn_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1822-1828",
          "snippet": "static void\nchan_attn_timeout(rock)\n\tvoid *rock;\n{\n\n\t*(int *)rock = 1;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void chan_attn_timeout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic void chan_attn_timeout;\n\nstatic void\nchan_attn_timeout(rock)\n\tvoid *rock;\n{\n\n\t*(int *)rock = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_ACTION_COMMAND",
          "args": [
            "cmd"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int command_and_wait;\nstatic void chan_attn_timeout;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic int\ncommand_and_wait(sc, cmd, pcmd, mask)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tvolatile void *pcmd;\n\tint mask;\n{\n\tvolatile struct ie_cmd_common *cc = pcmd;\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvolatile int timedout = 0;\n\textern int hz;\n\n\tscb->ie_command = (u_short)cmd;\n\n\tif (IE_ACTION_COMMAND(cmd) && pcmd) {\n\t\t(sc->chan_attn)(sc);\n\n\t\t/*\n\t\t * According to the packet driver, the minimum timeout should\n\t\t * be .369 seconds, which we round up to .4.\n\t\t */\n\t\ttimeout(chan_attn_timeout, (caddr_t)&timedout, 2 * hz / 5);\n\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, but I haven't figured out how, or indeed if, we\n\t\t * can put the process waiting for action to sleep.  (We may\n\t\t * be getting called through some other timeout running in the\n\t\t * kernel.)\n\t\t */\n\t\tfor (;;)\n\t\t\tif ((cc->ie_cmd_status & mask) || timedout)\n\t\t\t\tbreak;\n\n\t\tuntimeout(chan_attn_timeout, (caddr_t)&timedout);\n\n\t\treturn timedout;\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\t(sc->chan_attn)(sc);\n\n\t\twhile (scb->ie_command)\n\t\t\t;\t\t\t\t/* spin lock */\n\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "chan_attn_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1822-1828",
    "snippet": "static void\nchan_attn_timeout(rock)\n\tvoid *rock;\n{\n\n\t*(int *)rock = 1;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void chan_attn_timeout"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic void chan_attn_timeout;\n\nstatic void\nchan_attn_timeout(rock)\n\tvoid *rock;\n{\n\n\t*(int *)rock = 1;\n}"
  },
  {
    "function_name": "iereset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1797-1817",
    "snippet": "void\niereset(sc)\n\tstruct ie_softc *sc;\n{\n\tint s = splnet();\n\n\tiestop(sc);\n\n\t/*\n\t * Stop i82586 dead in its tracks.\n\t */\n\tif (command_and_wait(sc, IE_RU_ABORT | IE_CU_ABORT, 0, 0))\n\t\tprintf(\"%s: abort commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\tif (command_and_wait(sc, IE_RU_DISABLE | IE_CU_STOP, 0, 0))\n\t\tprintf(\"%s: disable commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\tieinit(sc);\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void iestop",
      "int ieinit",
      "void iereset",
      "static int command_and_wait",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ieinit",
          "args": [
            "sc"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "ieinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "2045-2135",
          "snippet": "int\nieinit(sc)\n\tstruct ie_softc *sc;\n{\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvoid *ptr;\n\n\tptr = (void *)ALIGN(scb + 1);\n\n\t/*\n\t * Send the configure command first.\n\t */\n\t{\n\t\tvolatile struct ie_config_cmd *cmd = ptr;\n\n\t\tscb->ie_command_list = MK_16(MEM, cmd);\n\t\tcmd->com.ie_cmd_status = 0;\n\t\tcmd->com.ie_cmd_cmd = IE_CMD_CONFIG | IE_CMD_LAST;\n\t\tcmd->com.ie_cmd_link = 0xffff;\n\n\t\tie_setup_config(cmd, sc->promisc != 0,\n\t\t    sc->hard_type == IE_STARLAN10);\n\n\t\tif (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||\n\t\t    !(cmd->com.ie_cmd_status & IE_STAT_OK)) {\n\t\t\tprintf(\"%s: configure command failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Now send the Individual Address Setup command.\n\t */\n\t{\n\t\tvolatile struct ie_iasetup_cmd *cmd = ptr;\n\n\t\tscb->ie_command_list = MK_16(MEM, cmd);\n\t\tcmd->com.ie_cmd_status = 0;\n\t\tcmd->com.ie_cmd_cmd = IE_CMD_IASETUP | IE_CMD_LAST;\n\t\tcmd->com.ie_cmd_link = 0xffff;\n\n\t\tbcopy(sc->sc_arpcom.ac_enaddr, (caddr_t)&cmd->ie_address,\n\t\t    sizeof cmd->ie_address);\n\n\t\tif (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||\n\t\t    !(cmd->com.ie_cmd_status & IE_STAT_OK)) {\n\t\t\tprintf(\"%s: individual address setup command failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Now run the time-domain reflectometer.\n\t */\n\trun_tdr(sc, ptr);\n\n\t/*\n\t * Acknowledge any interrupts we have generated thus far.\n\t */\n\tie_ack(sc, IE_ST_WHENCE);\n\n\t/*\n\t * Set up the RFA.\n\t */\n\tiememinit(ptr, sc);\n\n\tsc->sc_arpcom.ac_if.if_flags |= IFF_RUNNING;\n\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\n\tsc->scb->ie_recv_list = MK_16(MEM, sc->rframes[0]);\n\tcommand_and_wait(sc, IE_RU_START, 0, 0);\n\n\tie_ack(sc, IE_ST_WHENCE);\n\n\t/* take the ee16 out of loopback */\n\t{\n\tu_char\tbart_config;\n\n\tif(sc->hard_type == IE_EE16) {\n\t\tbart_config = inb(PORT + IEE16_CONFIG);\n\t\tbart_config &= ~IEE16_BART_LOOPBACK;\n\t\tbart_config |= IEE16_BART_MCS16_TEST; /* inb doesn't get bit! */\n\t\toutb(PORT + IEE16_CONFIG, bart_config);\n\t\tee16_interrupt_enable(sc); \n\t\tee16_chan_attn(sc);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define MEM \tsc->sc_maddr",
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "int ieinit",
            "static void ee16_chan_attn",
            "static void ee16_interrupt_enable",
            "static int command_and_wait",
            "void iememinit",
            "static __inline void ie_setup_config",
            "static __inline void ie_ack",
            "static void run_tdr",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define MEM \tsc->sc_maddr\n#define PORT\tsc->sc_iobase\n\nint ieinit;\nstatic void ee16_chan_attn;\nstatic void ee16_interrupt_enable;\nstatic int command_and_wait;\nvoid iememinit;\nstatic __inline void ie_setup_config;\nstatic __inline void ie_ack;\nstatic void run_tdr;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nieinit(sc)\n\tstruct ie_softc *sc;\n{\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvoid *ptr;\n\n\tptr = (void *)ALIGN(scb + 1);\n\n\t/*\n\t * Send the configure command first.\n\t */\n\t{\n\t\tvolatile struct ie_config_cmd *cmd = ptr;\n\n\t\tscb->ie_command_list = MK_16(MEM, cmd);\n\t\tcmd->com.ie_cmd_status = 0;\n\t\tcmd->com.ie_cmd_cmd = IE_CMD_CONFIG | IE_CMD_LAST;\n\t\tcmd->com.ie_cmd_link = 0xffff;\n\n\t\tie_setup_config(cmd, sc->promisc != 0,\n\t\t    sc->hard_type == IE_STARLAN10);\n\n\t\tif (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||\n\t\t    !(cmd->com.ie_cmd_status & IE_STAT_OK)) {\n\t\t\tprintf(\"%s: configure command failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Now send the Individual Address Setup command.\n\t */\n\t{\n\t\tvolatile struct ie_iasetup_cmd *cmd = ptr;\n\n\t\tscb->ie_command_list = MK_16(MEM, cmd);\n\t\tcmd->com.ie_cmd_status = 0;\n\t\tcmd->com.ie_cmd_cmd = IE_CMD_IASETUP | IE_CMD_LAST;\n\t\tcmd->com.ie_cmd_link = 0xffff;\n\n\t\tbcopy(sc->sc_arpcom.ac_enaddr, (caddr_t)&cmd->ie_address,\n\t\t    sizeof cmd->ie_address);\n\n\t\tif (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||\n\t\t    !(cmd->com.ie_cmd_status & IE_STAT_OK)) {\n\t\t\tprintf(\"%s: individual address setup command failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Now run the time-domain reflectometer.\n\t */\n\trun_tdr(sc, ptr);\n\n\t/*\n\t * Acknowledge any interrupts we have generated thus far.\n\t */\n\tie_ack(sc, IE_ST_WHENCE);\n\n\t/*\n\t * Set up the RFA.\n\t */\n\tiememinit(ptr, sc);\n\n\tsc->sc_arpcom.ac_if.if_flags |= IFF_RUNNING;\n\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\n\tsc->scb->ie_recv_list = MK_16(MEM, sc->rframes[0]);\n\tcommand_and_wait(sc, IE_RU_START, 0, 0);\n\n\tie_ack(sc, IE_ST_WHENCE);\n\n\t/* take the ee16 out of loopback */\n\t{\n\tu_char\tbart_config;\n\n\tif(sc->hard_type == IE_EE16) {\n\t\tbart_config = inb(PORT + IEE16_CONFIG);\n\t\tbart_config &= ~IEE16_BART_LOOPBACK;\n\t\tbart_config |= IEE16_BART_MCS16_TEST; /* inb doesn't get bit! */\n\t\toutb(PORT + IEE16_CONFIG, bart_config);\n\t\tee16_interrupt_enable(sc); \n\t\tee16_chan_attn(sc);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: disable commands timed out\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_and_wait",
          "args": [
            "sc",
            "IE_RU_DISABLE | IE_CU_STOP",
            "0",
            "0"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "command_and_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1838-1886",
          "snippet": "static int\ncommand_and_wait(sc, cmd, pcmd, mask)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tvolatile void *pcmd;\n\tint mask;\n{\n\tvolatile struct ie_cmd_common *cc = pcmd;\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvolatile int timedout = 0;\n\textern int hz;\n\n\tscb->ie_command = (u_short)cmd;\n\n\tif (IE_ACTION_COMMAND(cmd) && pcmd) {\n\t\t(sc->chan_attn)(sc);\n\n\t\t/*\n\t\t * According to the packet driver, the minimum timeout should\n\t\t * be .369 seconds, which we round up to .4.\n\t\t */\n\t\ttimeout(chan_attn_timeout, (caddr_t)&timedout, 2 * hz / 5);\n\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, but I haven't figured out how, or indeed if, we\n\t\t * can put the process waiting for action to sleep.  (We may\n\t\t * be getting called through some other timeout running in the\n\t\t * kernel.)\n\t\t */\n\t\tfor (;;)\n\t\t\tif ((cc->ie_cmd_status & mask) || timedout)\n\t\t\t\tbreak;\n\n\t\tuntimeout(chan_attn_timeout, (caddr_t)&timedout);\n\n\t\treturn timedout;\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\t(sc->chan_attn)(sc);\n\n\t\twhile (scb->ie_command)\n\t\t\t;\t\t\t\t/* spin lock */\n\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int command_and_wait",
            "static void chan_attn_timeout",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int command_and_wait;\nstatic void chan_attn_timeout;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic int\ncommand_and_wait(sc, cmd, pcmd, mask)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tvolatile void *pcmd;\n\tint mask;\n{\n\tvolatile struct ie_cmd_common *cc = pcmd;\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvolatile int timedout = 0;\n\textern int hz;\n\n\tscb->ie_command = (u_short)cmd;\n\n\tif (IE_ACTION_COMMAND(cmd) && pcmd) {\n\t\t(sc->chan_attn)(sc);\n\n\t\t/*\n\t\t * According to the packet driver, the minimum timeout should\n\t\t * be .369 seconds, which we round up to .4.\n\t\t */\n\t\ttimeout(chan_attn_timeout, (caddr_t)&timedout, 2 * hz / 5);\n\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, but I haven't figured out how, or indeed if, we\n\t\t * can put the process waiting for action to sleep.  (We may\n\t\t * be getting called through some other timeout running in the\n\t\t * kernel.)\n\t\t */\n\t\tfor (;;)\n\t\t\tif ((cc->ie_cmd_status & mask) || timedout)\n\t\t\t\tbreak;\n\n\t\tuntimeout(chan_attn_timeout, (caddr_t)&timedout);\n\n\t\treturn timedout;\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\t(sc->chan_attn)(sc);\n\n\t\twhile (scb->ie_command)\n\t\t\t;\t\t\t\t/* spin lock */\n\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iestop",
          "args": [
            "sc"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "iestop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "2137-2143",
          "snippet": "void\niestop(sc)\n\tstruct ie_softc *sc;\n{\n\n\tcommand_and_wait(sc, IE_RU_DISABLE, 0, 0);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void iestop",
            "static int command_and_wait",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iestop;\nstatic int command_and_wait;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\niestop(sc)\n\tstruct ie_softc *sc;\n{\n\n\tcommand_and_wait(sc, IE_RU_DISABLE, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iestop;\nint ieinit;\nvoid iereset;\nstatic int command_and_wait;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\niereset(sc)\n\tstruct ie_softc *sc;\n{\n\tint s = splnet();\n\n\tiestop(sc);\n\n\t/*\n\t * Stop i82586 dead in its tracks.\n\t */\n\tif (command_and_wait(sc, IE_RU_ABORT | IE_CU_ABORT, 0, 0))\n\t\tprintf(\"%s: abort commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\tif (command_and_wait(sc, IE_RU_DISABLE | IE_CU_STOP, 0, 0))\n\t\tprintf(\"%s: disable commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\tieinit(sc);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "slel_get_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1786-1795",
    "snippet": "void\nslel_get_address(sc)\n\tstruct ie_softc *sc;\n{\n\tu_char *addr = sc->sc_arpcom.ac_enaddr;\n\tint i;\n\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\taddr[i] = inb(PORT + i);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define PORT\tsc->sc_iobase",
      "#define\tETHER_ADDR_LEN\t6"
    ],
    "globals_used": [
      "static void slel_get_address",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "PORT + i"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n#define\tETHER_ADDR_LEN\t6\n\nstatic void slel_get_address;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nslel_get_address(sc)\n\tstruct ie_softc *sc;\n{\n\tu_char *addr = sc->sc_arpcom.ac_enaddr;\n\tint i;\n\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\taddr[i] = inb(PORT + i);\n}"
  },
  {
    "function_name": "ee16_interrupt_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1778-1785",
    "snippet": "static inline void\nee16_interrupt_enable(sc)\n\tstruct ie_softc *sc;\n{\n\tdelay(100);\n\toutb(PORT + IEE16_IRQ, sc->irq_encoded | IEE16_IRQ_ENABLE);\n\tdelay(100);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define PORT\tsc->sc_iobase"
    ],
    "globals_used": [
      "static void ee16_interrupt_enable",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "PORT + IEE16_IRQ",
            "sc->irq_encoded | IEE16_IRQ_ENABLE"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nstatic void ee16_interrupt_enable;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic inline void\nee16_interrupt_enable(sc)\n\tstruct ie_softc *sc;\n{\n\tdelay(100);\n\toutb(PORT + IEE16_IRQ, sc->irq_encoded | IEE16_IRQ_ENABLE);\n\tdelay(100);\n}"
  },
  {
    "function_name": "ee16_eeprom_clock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1762-1776",
    "snippet": "void\nee16_eeprom_clock(sc, state)\n\tstruct ie_softc *sc;\n\tint state;\n{\n\tint ectrl;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~(IEE16_RESET_ASIC | IEE16_ECTRL_EESK);\n\tif (state) {\n\t\tectrl |= IEE16_ECTRL_EESK;\n\t}\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(9);\t\t/* EESK must be stable for 8.38 uSec */\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define PORT\tsc->sc_iobase"
    ],
    "globals_used": [
      "void ee16_eeprom_clock",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "9"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "PORT + IEE16_ECTRL",
            "ectrl"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "PORT + IEE16_ECTRL"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_clock(sc, state)\n\tstruct ie_softc *sc;\n\tint state;\n{\n\tint ectrl;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~(IEE16_RESET_ASIC | IEE16_ECTRL_EESK);\n\tif (state) {\n\t\tectrl |= IEE16_ECTRL_EESK;\n\t}\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(9);\t\t/* EESK must be stable for 8.38 uSec */\n}"
  },
  {
    "function_name": "ee16_eeprom_inbits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1742-1760",
    "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define PORT\tsc->sc_iobase"
    ],
    "globals_used": [
      "void ee16_eeprom_clock",
      "int ee16_eeprom_inbits",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ee16_eeprom_clock",
          "args": [
            "sc",
            "0"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1762-1776",
          "snippet": "void\nee16_eeprom_clock(sc, state)\n\tstruct ie_softc *sc;\n\tint state;\n{\n\tint ectrl;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~(IEE16_RESET_ASIC | IEE16_ECTRL_EESK);\n\tif (state) {\n\t\tectrl |= IEE16_ECTRL_EESK;\n\t}\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(9);\t\t/* EESK must be stable for 8.38 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_clock(sc, state)\n\tstruct ie_softc *sc;\n\tint state;\n{\n\tint ectrl;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~(IEE16_RESET_ASIC | IEE16_ECTRL_EESK);\n\tif (state) {\n\t\tectrl |= IEE16_ECTRL_EESK;\n\t}\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(9);\t\t/* EESK must be stable for 8.38 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "PORT + IEE16_ECTRL"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
  },
  {
    "function_name": "ee16_eeprom_outbits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1718-1740",
    "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define PORT\tsc->sc_iobase"
    ],
    "globals_used": [
      "void ee16_eeprom_outbits",
      "void ee16_eeprom_clock",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "PORT + IEE16_ECTRL",
            "ectrl"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ee16_eeprom_clock",
          "args": [
            "sc",
            "0"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1762-1776",
          "snippet": "void\nee16_eeprom_clock(sc, state)\n\tstruct ie_softc *sc;\n\tint state;\n{\n\tint ectrl;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~(IEE16_RESET_ASIC | IEE16_ECTRL_EESK);\n\tif (state) {\n\t\tectrl |= IEE16_ECTRL_EESK;\n\t}\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(9);\t\t/* EESK must be stable for 8.38 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_clock(sc, state)\n\tstruct ie_softc *sc;\n\tint state;\n{\n\tint ectrl;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~(IEE16_RESET_ASIC | IEE16_ECTRL_EESK);\n\tif (state) {\n\t\tectrl |= IEE16_ECTRL_EESK;\n\t}\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(9);\t\t/* EESK must be stable for 8.38 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "PORT + IEE16_ECTRL"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
  },
  {
    "function_name": "ee16_read_eeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1695-1716",
    "snippet": "u_short\nee16_read_eeprom(sc, location)\n\tstruct ie_softc *sc;\n\tint location;\n{\n\tint ectrl, edata;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= IEE16_ECTRL_MASK;\n\tectrl |= IEE16_ECTRL_EECS;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\n\tee16_eeprom_outbits(sc, IEE16_EEPROM_READ, IEE16_EEPROM_OPSIZE1);\n\tee16_eeprom_outbits(sc, location, IEE16_EEPROM_ADDR_SIZE);\n\tedata = ee16_eeprom_inbits(sc);\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~(IEE16_RESET_ASIC | IEE16_ECTRL_EEDI | IEE16_ECTRL_EECS);\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tee16_eeprom_clock(sc, 1);\n\tee16_eeprom_clock(sc, 0);\n\treturn edata;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define PORT\tsc->sc_iobase"
    ],
    "globals_used": [
      "void ee16_eeprom_outbits",
      "void ee16_eeprom_clock",
      "u_short ee16_read_eeprom",
      "int ee16_eeprom_inbits",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ee16_eeprom_clock",
          "args": [
            "sc",
            "0"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1762-1776",
          "snippet": "void\nee16_eeprom_clock(sc, state)\n\tstruct ie_softc *sc;\n\tint state;\n{\n\tint ectrl;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~(IEE16_RESET_ASIC | IEE16_ECTRL_EESK);\n\tif (state) {\n\t\tectrl |= IEE16_ECTRL_EESK;\n\t}\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(9);\t\t/* EESK must be stable for 8.38 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_clock(sc, state)\n\tstruct ie_softc *sc;\n\tint state;\n{\n\tint ectrl;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~(IEE16_RESET_ASIC | IEE16_ECTRL_EESK);\n\tif (state) {\n\t\tectrl |= IEE16_ECTRL_EESK;\n\t}\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(9);\t\t/* EESK must be stable for 8.38 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "PORT + IEE16_ECTRL",
            "ectrl"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "PORT + IEE16_ECTRL"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nu_short ee16_read_eeprom;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nu_short\nee16_read_eeprom(sc, location)\n\tstruct ie_softc *sc;\n\tint location;\n{\n\tint ectrl, edata;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= IEE16_ECTRL_MASK;\n\tectrl |= IEE16_ECTRL_EECS;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\n\tee16_eeprom_outbits(sc, IEE16_EEPROM_READ, IEE16_EEPROM_OPSIZE1);\n\tee16_eeprom_outbits(sc, location, IEE16_EEPROM_ADDR_SIZE);\n\tedata = ee16_eeprom_inbits(sc);\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~(IEE16_RESET_ASIC | IEE16_ECTRL_EEDI | IEE16_ECTRL_EECS);\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tee16_eeprom_clock(sc, 1);\n\tee16_eeprom_clock(sc, 0);\n\treturn edata;\n}"
  },
  {
    "function_name": "ee16_chan_attn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1688-1693",
    "snippet": "void\nee16_chan_attn(sc)\n\tstruct ie_softc *sc;\n{\n\toutb(PORT + IEE16_ATTN, 0);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define PORT\tsc->sc_iobase"
    ],
    "globals_used": [
      "static void ee16_chan_attn",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "PORT + IEE16_ATTN",
            "0"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nstatic void ee16_chan_attn;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_chan_attn(sc)\n\tstruct ie_softc *sc;\n{\n\toutb(PORT + IEE16_ATTN, 0);\n}"
  },
  {
    "function_name": "sl_chan_attn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1680-1686",
    "snippet": "void\nsl_chan_attn(sc)\n\tstruct ie_softc *sc;\n{\n\n\toutb(PORT + IEATT_ATTN, 0);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define PORT\tsc->sc_iobase"
    ],
    "globals_used": [
      "static void sl_chan_attn",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "PORT + IEATT_ATTN",
            "0"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nstatic void sl_chan_attn;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nsl_chan_attn(sc)\n\tstruct ie_softc *sc;\n{\n\n\toutb(PORT + IEATT_ATTN, 0);\n}"
  },
  {
    "function_name": "el_chan_attn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1672-1678",
    "snippet": "void\nel_chan_attn(sc)\n\tstruct ie_softc *sc;\n{\n\n\toutb(PORT + IE507_ATTN, 1);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define PORT\tsc->sc_iobase"
    ],
    "globals_used": [
      "static void el_chan_attn",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "PORT + IE507_ATTN",
            "1"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nstatic void el_chan_attn;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nel_chan_attn(sc)\n\tstruct ie_softc *sc;\n{\n\n\toutb(PORT + IE507_ATTN, 1);\n}"
  },
  {
    "function_name": "ee16_reset_586",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1661-1670",
    "snippet": "void\nee16_reset_586(sc)\n\tstruct ie_softc *sc;\n{\n\n\toutb(PORT + IEE16_ECTRL, IEE16_RESET_586);\n\tdelay(100);\n\toutb(PORT + IEE16_ECTRL, 0);\n\tdelay(100);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define PORT\tsc->sc_iobase"
    ],
    "globals_used": [
      "static void ee16_reset_586",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "PORT + IEE16_ECTRL",
            "0"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nstatic void ee16_reset_586;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_reset_586(sc)\n\tstruct ie_softc *sc;\n{\n\n\toutb(PORT + IEE16_ECTRL, IEE16_RESET_586);\n\tdelay(100);\n\toutb(PORT + IEE16_ECTRL, 0);\n\tdelay(100);\n}"
  },
  {
    "function_name": "sl_reset_586",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1653-1659",
    "snippet": "void\nsl_reset_586(sc)\n\tstruct ie_softc *sc;\n{\n\n\toutb(PORT + IEATT_RESET, 0);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define PORT\tsc->sc_iobase"
    ],
    "globals_used": [
      "static void sl_reset_586",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "PORT + IEATT_RESET",
            "0"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nstatic void sl_reset_586;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nsl_reset_586(sc)\n\tstruct ie_softc *sc;\n{\n\n\toutb(PORT + IEATT_RESET, 0);\n}"
  },
  {
    "function_name": "el_reset_586",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1642-1651",
    "snippet": "void\nel_reset_586(sc)\n\tstruct ie_softc *sc;\n{\n\n\toutb(PORT + IE507_CTRL, EL_CTRL_RESET);\n\tdelay(100);\n\toutb(PORT + IE507_CTRL, EL_CTRL_NORMAL);\n\tdelay(100);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define PORT\tsc->sc_iobase"
    ],
    "globals_used": [
      "static void el_reset_586",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "PORT + IE507_CTRL",
            "EL_CTRL_NORMAL"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nstatic void el_reset_586;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nel_reset_586(sc)\n\tstruct ie_softc *sc;\n{\n\n\toutb(PORT + IE507_CTRL, EL_CTRL_RESET);\n\tdelay(100);\n\toutb(PORT + IE507_CTRL, EL_CTRL_NORMAL);\n\tdelay(100);\n}"
  },
  {
    "function_name": "ie_find_mem_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1627-1640",
    "snippet": "void\nie_find_mem_size(sc)\n\tstruct ie_softc *sc;\n{\n\tu_int size;\n\n\tsc->sc_msize = 0;\n\n\tfor (size = 65536; size >= 16384; size -= 16384)\n\t\tif (check_ie_present(sc, sc->sc_maddr, size))\n\t\t\treturn;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ie_find_mem_size",
      "int\tcheck_ie_present",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_ie_present",
          "args": [
            "sc",
            "sc->sc_maddr",
            "size"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "check_ie_present",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1538-1621",
          "snippet": "int\ncheck_ie_present(sc, where, size)\n\tstruct ie_softc *sc;\n\tcaddr_t where;\n\tu_int size;\n{\n\tvolatile struct ie_sys_conf_ptr *scp;\n\tvolatile struct ie_int_sys_conf_ptr *iscp;\n\tvolatile struct ie_sys_ctl_block *scb;\n\tu_long realbase;\n\tint s;\n\n\ts = splnet();\n\n\trealbase = (u_long)where + size - (1 << 24);\n\n\tscp = (volatile struct ie_sys_conf_ptr *)(realbase + IE_SCP_ADDR);\n\tbzero((char *)scp, sizeof *scp);\n\n\t/*\n\t * First we put the ISCP at the bottom of memory; this tests to make\n\t * sure that our idea of the size of memory is the same as the\n\t * controller's.  This is NOT where the ISCP will be in normal\n\t * operation.\n\t */\n\tiscp = (volatile struct ie_int_sys_conf_ptr *)where;\n\tbzero((char *)iscp, sizeof *iscp);\n\n\tscb = (volatile struct ie_sys_ctl_block *)where;\n\tbzero((char *)scb, sizeof *scb);\n\n\tscp->ie_bus_use = 0;\t\t/* 16-bit */\n\tscp->ie_iscp_ptr = (caddr_t)((volatile caddr_t)iscp -\n\t    (volatile caddr_t)realbase);\n\n\tiscp->ie_busy = 1;\n\tiscp->ie_scb_offset = MK_16(realbase, scb) + 256;\n\n\t(sc->reset_586)(sc);\n\t(sc->chan_attn)(sc);\n\n\tdelay(100);\t\t\t/* wait a while... */\n\n\tif (iscp->ie_busy) {\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Now relocate the ISCP to its real home, and reset the controller\n\t * again.\n\t */\n\tiscp = (void *)ALIGN(realbase + IE_SCP_ADDR - sizeof(*iscp));\n\tbzero((char *)iscp, sizeof *iscp);\n\n\tscp->ie_iscp_ptr = (caddr_t)((caddr_t)iscp - (caddr_t)realbase);\n\n\tiscp->ie_busy = 1;\n\tiscp->ie_scb_offset = MK_16(realbase, scb);\n\n\t(sc->reset_586)(sc);\n\t(sc->chan_attn)(sc);\n\n\tdelay(100);\n\n\tif (iscp->ie_busy) {\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\n\tsc->sc_msize = size;\n\tsc->sc_maddr = (caddr_t)realbase;\n\n\tsc->iscp = iscp;\n\tsc->scb = scb;\n\n\t/*\n\t * Acknowledge any interrupts we may have caused...\n\t */\n\tie_ack(sc, IE_ST_WHENCE);\n\tsplx(s);\n\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tcheck_ie_present",
            "static __inline void ie_ack",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tcheck_ie_present;\nstatic __inline void ie_ack;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\ncheck_ie_present(sc, where, size)\n\tstruct ie_softc *sc;\n\tcaddr_t where;\n\tu_int size;\n{\n\tvolatile struct ie_sys_conf_ptr *scp;\n\tvolatile struct ie_int_sys_conf_ptr *iscp;\n\tvolatile struct ie_sys_ctl_block *scb;\n\tu_long realbase;\n\tint s;\n\n\ts = splnet();\n\n\trealbase = (u_long)where + size - (1 << 24);\n\n\tscp = (volatile struct ie_sys_conf_ptr *)(realbase + IE_SCP_ADDR);\n\tbzero((char *)scp, sizeof *scp);\n\n\t/*\n\t * First we put the ISCP at the bottom of memory; this tests to make\n\t * sure that our idea of the size of memory is the same as the\n\t * controller's.  This is NOT where the ISCP will be in normal\n\t * operation.\n\t */\n\tiscp = (volatile struct ie_int_sys_conf_ptr *)where;\n\tbzero((char *)iscp, sizeof *iscp);\n\n\tscb = (volatile struct ie_sys_ctl_block *)where;\n\tbzero((char *)scb, sizeof *scb);\n\n\tscp->ie_bus_use = 0;\t\t/* 16-bit */\n\tscp->ie_iscp_ptr = (caddr_t)((volatile caddr_t)iscp -\n\t    (volatile caddr_t)realbase);\n\n\tiscp->ie_busy = 1;\n\tiscp->ie_scb_offset = MK_16(realbase, scb) + 256;\n\n\t(sc->reset_586)(sc);\n\t(sc->chan_attn)(sc);\n\n\tdelay(100);\t\t\t/* wait a while... */\n\n\tif (iscp->ie_busy) {\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Now relocate the ISCP to its real home, and reset the controller\n\t * again.\n\t */\n\tiscp = (void *)ALIGN(realbase + IE_SCP_ADDR - sizeof(*iscp));\n\tbzero((char *)iscp, sizeof *iscp);\n\n\tscp->ie_iscp_ptr = (caddr_t)((caddr_t)iscp - (caddr_t)realbase);\n\n\tiscp->ie_busy = 1;\n\tiscp->ie_scb_offset = MK_16(realbase, scb);\n\n\t(sc->reset_586)(sc);\n\t(sc->chan_attn)(sc);\n\n\tdelay(100);\n\n\tif (iscp->ie_busy) {\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\n\tsc->sc_msize = size;\n\tsc->sc_maddr = (caddr_t)realbase;\n\n\tsc->iscp = iscp;\n\tsc->scb = scb;\n\n\t/*\n\t * Acknowledge any interrupts we may have caused...\n\t */\n\tie_ack(sc, IE_ST_WHENCE);\n\tsplx(s);\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ie_find_mem_size;\nint\tcheck_ie_present;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nie_find_mem_size(sc)\n\tstruct ie_softc *sc;\n{\n\tu_int size;\n\n\tsc->sc_msize = 0;\n\n\tfor (size = 65536; size >= 16384; size -= 16384)\n\t\tif (check_ie_present(sc, sc->sc_maddr, size))\n\t\t\treturn;\n\n\treturn;\n}"
  },
  {
    "function_name": "check_ie_present",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1538-1621",
    "snippet": "int\ncheck_ie_present(sc, where, size)\n\tstruct ie_softc *sc;\n\tcaddr_t where;\n\tu_int size;\n{\n\tvolatile struct ie_sys_conf_ptr *scp;\n\tvolatile struct ie_int_sys_conf_ptr *iscp;\n\tvolatile struct ie_sys_ctl_block *scb;\n\tu_long realbase;\n\tint s;\n\n\ts = splnet();\n\n\trealbase = (u_long)where + size - (1 << 24);\n\n\tscp = (volatile struct ie_sys_conf_ptr *)(realbase + IE_SCP_ADDR);\n\tbzero((char *)scp, sizeof *scp);\n\n\t/*\n\t * First we put the ISCP at the bottom of memory; this tests to make\n\t * sure that our idea of the size of memory is the same as the\n\t * controller's.  This is NOT where the ISCP will be in normal\n\t * operation.\n\t */\n\tiscp = (volatile struct ie_int_sys_conf_ptr *)where;\n\tbzero((char *)iscp, sizeof *iscp);\n\n\tscb = (volatile struct ie_sys_ctl_block *)where;\n\tbzero((char *)scb, sizeof *scb);\n\n\tscp->ie_bus_use = 0;\t\t/* 16-bit */\n\tscp->ie_iscp_ptr = (caddr_t)((volatile caddr_t)iscp -\n\t    (volatile caddr_t)realbase);\n\n\tiscp->ie_busy = 1;\n\tiscp->ie_scb_offset = MK_16(realbase, scb) + 256;\n\n\t(sc->reset_586)(sc);\n\t(sc->chan_attn)(sc);\n\n\tdelay(100);\t\t\t/* wait a while... */\n\n\tif (iscp->ie_busy) {\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Now relocate the ISCP to its real home, and reset the controller\n\t * again.\n\t */\n\tiscp = (void *)ALIGN(realbase + IE_SCP_ADDR - sizeof(*iscp));\n\tbzero((char *)iscp, sizeof *iscp);\n\n\tscp->ie_iscp_ptr = (caddr_t)((caddr_t)iscp - (caddr_t)realbase);\n\n\tiscp->ie_busy = 1;\n\tiscp->ie_scb_offset = MK_16(realbase, scb);\n\n\t(sc->reset_586)(sc);\n\t(sc->chan_attn)(sc);\n\n\tdelay(100);\n\n\tif (iscp->ie_busy) {\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\n\tsc->sc_msize = size;\n\tsc->sc_maddr = (caddr_t)realbase;\n\n\tsc->iscp = iscp;\n\tsc->scb = scb;\n\n\t/*\n\t * Acknowledge any interrupts we may have caused...\n\t */\n\tie_ack(sc, IE_ST_WHENCE);\n\tsplx(s);\n\n\treturn 1;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tcheck_ie_present",
      "static __inline void ie_ack",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ie_ack",
          "args": [
            "sc",
            "IE_ST_WHENCE"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "ie_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "364-376",
          "snippet": "static __inline void\nie_ack(sc, mask)\n\tstruct ie_softc *sc;\n\tu_int mask;\n{\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\n\tscb->ie_command = scb->ie_status & mask;\n\t(sc->chan_attn)(sc);\n\n\twhile (scb->ie_command)\n\t\t;\t\t/* Spin Lock */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void ie_ack",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline void ie_ack;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic __inline void\nie_ack(sc, mask)\n\tstruct ie_softc *sc;\n\tu_int mask;\n{\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\n\tscb->ie_command = scb->ie_status & mask;\n\t(sc->chan_attn)(sc);\n\n\twhile (scb->ie_command)\n\t\t;\t\t/* Spin Lock */\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MK_16",
          "args": [
            "realbase",
            "scb"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(caddr_t)iscp - (caddr_t)realbase"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)iscp",
            "sizeof *iscp"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "realbase + IE_SCP_ADDR - sizeof(*iscp)"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MK_16",
          "args": [
            "realbase",
            "scb"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(volatile caddr_t)iscp -\n\t    (volatile caddr_t)realbase"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)scb",
            "sizeof *scb"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)iscp",
            "sizeof *iscp"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)scp",
            "sizeof *scp"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tcheck_ie_present;\nstatic __inline void ie_ack;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\ncheck_ie_present(sc, where, size)\n\tstruct ie_softc *sc;\n\tcaddr_t where;\n\tu_int size;\n{\n\tvolatile struct ie_sys_conf_ptr *scp;\n\tvolatile struct ie_int_sys_conf_ptr *iscp;\n\tvolatile struct ie_sys_ctl_block *scb;\n\tu_long realbase;\n\tint s;\n\n\ts = splnet();\n\n\trealbase = (u_long)where + size - (1 << 24);\n\n\tscp = (volatile struct ie_sys_conf_ptr *)(realbase + IE_SCP_ADDR);\n\tbzero((char *)scp, sizeof *scp);\n\n\t/*\n\t * First we put the ISCP at the bottom of memory; this tests to make\n\t * sure that our idea of the size of memory is the same as the\n\t * controller's.  This is NOT where the ISCP will be in normal\n\t * operation.\n\t */\n\tiscp = (volatile struct ie_int_sys_conf_ptr *)where;\n\tbzero((char *)iscp, sizeof *iscp);\n\n\tscb = (volatile struct ie_sys_ctl_block *)where;\n\tbzero((char *)scb, sizeof *scb);\n\n\tscp->ie_bus_use = 0;\t\t/* 16-bit */\n\tscp->ie_iscp_ptr = (caddr_t)((volatile caddr_t)iscp -\n\t    (volatile caddr_t)realbase);\n\n\tiscp->ie_busy = 1;\n\tiscp->ie_scb_offset = MK_16(realbase, scb) + 256;\n\n\t(sc->reset_586)(sc);\n\t(sc->chan_attn)(sc);\n\n\tdelay(100);\t\t\t/* wait a while... */\n\n\tif (iscp->ie_busy) {\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Now relocate the ISCP to its real home, and reset the controller\n\t * again.\n\t */\n\tiscp = (void *)ALIGN(realbase + IE_SCP_ADDR - sizeof(*iscp));\n\tbzero((char *)iscp, sizeof *iscp);\n\n\tscp->ie_iscp_ptr = (caddr_t)((caddr_t)iscp - (caddr_t)realbase);\n\n\tiscp->ie_busy = 1;\n\tiscp->ie_scb_offset = MK_16(realbase, scb);\n\n\t(sc->reset_586)(sc);\n\t(sc->chan_attn)(sc);\n\n\tdelay(100);\n\n\tif (iscp->ie_busy) {\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\n\tsc->sc_msize = size;\n\tsc->sc_maddr = (caddr_t)realbase;\n\n\tsc->iscp = iscp;\n\tsc->scb = scb;\n\n\t/*\n\t * Acknowledge any interrupts we may have caused...\n\t */\n\tie_ack(sc, IE_ST_WHENCE);\n\tsplx(s);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "iestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1478-1533",
    "snippet": "void\niestart(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ie_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0, *m;\n\tu_char *buffer;\n\tu_short len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\tfor (;;) {\n\t\tif (sc->xmit_busy == NTXBUF) {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (m0 == 0)\n\t\t\tbreak;\n\n\t\t/* We need to use m->m_pkthdr.len, so require the header */\n\t\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\t\tpanic(\"iestart: no header mbuf\");\n\n#if NBPFILTER > 0\n\t\t/* Tap off here if there is a BPF listener. */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n#ifdef IEDEBUG\n\t\tif (sc->sc_debug & IED_ENQ)\n\t\t\tprintf(\"%s: fill buffer %d\\n\", sc->sc_dev.dv_xname,\n\t\t\t    sc->xchead);\n#endif\n\n\t\tbuffer = sc->xmit_cbuffs[sc->xchead];\n\t\tfor (m = m0; m != 0; m = m->m_next) {\n\t\t\tbcopy(mtod(m, caddr_t), buffer, m->m_len);\n\t\t\tbuffer += m->m_len;\n\t\t}\n\t\tlen = max(m0->m_pkthdr.len, ETHER_MIN_LEN);\n\n\t\tm_freem(m0);\n\t\tsc->xmit_buffs[sc->xchead]->ie_xmit_flags = len;\n\n\t\t/* Start the first packet transmitting. */\n\t\tif (sc->xmit_busy == 0)\n\t\t\tiexmit(sc);\n\n\t\tsc->xchead = (sc->xchead + 1) % NTXBUF;\n\t\tsc->xmit_busy++;\n\t}\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tNTXBUF\t\t2\t\t/* number of transmit commands */",
      "#define\tETHER_MIN_LEN\t64",
      "#define\tIED_ENQ\t\t0x20"
    ],
    "globals_used": [
      "void iestart",
      "void iexmit",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iexmit",
          "args": [
            "sc"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "iexmit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1191-1230",
          "snippet": "void\niexmit(sc)\n\tstruct ie_softc *sc;\n{\n\n#ifdef IEDEBUG\n\tif (sc->sc_debug & IED_XMIT)\n\t\tprintf(\"%s: xmit buffer %d\\n\", sc->sc_dev.dv_xname,\n\t\t    sc->xctail);\n#endif\n\n#if NBPFILTER > 0\n\t/*\n\t * If BPF is listening on this interface, let it see the packet before\n\t * we push it on the wire.\n\t */\n\tif (sc->sc_arpcom.ac_if.if_bpf)\n\t\tbpf_tap(sc->sc_arpcom.ac_if.if_bpf,\n\t\t    sc->xmit_cbuffs[sc->xctail],\n\t\t    sc->xmit_buffs[sc->xctail]->ie_xmit_flags);\n#endif\n\n\tsc->xmit_buffs[sc->xctail]->ie_xmit_flags |= IE_XMIT_LAST;\n\tsc->xmit_buffs[sc->xctail]->ie_xmit_next = 0xffff;\n\tsc->xmit_buffs[sc->xctail]->ie_xmit_buf =\n\t    MK_24(MEM, sc->xmit_cbuffs[sc->xctail]);\n\n\tsc->xmit_cmds[sc->xctail]->com.ie_cmd_link = 0xffff;\n\tsc->xmit_cmds[sc->xctail]->com.ie_cmd_cmd =\n\t    IE_CMD_XMIT | IE_CMD_INTR | IE_CMD_LAST;\n\n\tsc->xmit_cmds[sc->xctail]->ie_xmit_status = 0;\n\tsc->xmit_cmds[sc->xctail]->ie_xmit_desc =\n\t    MK_16(MEM, sc->xmit_buffs[sc->xctail]);\n\n\tsc->scb->ie_command_list = MK_16(MEM, sc->xmit_cmds[sc->xctail]);\n\tcommand_and_wait(sc, IE_CU_START, 0, 0);\n\n\tsc->sc_arpcom.ac_if.if_timer = 5;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define MEM \tsc->sc_maddr",
            "#define\tIED_XMIT\t0x40"
          ],
          "globals_used": [
            "static int command_and_wait",
            "void iexmit",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define MEM \tsc->sc_maddr\n#define\tIED_XMIT\t0x40\n\nstatic int command_and_wait;\nvoid iexmit;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\niexmit(sc)\n\tstruct ie_softc *sc;\n{\n\n#ifdef IEDEBUG\n\tif (sc->sc_debug & IED_XMIT)\n\t\tprintf(\"%s: xmit buffer %d\\n\", sc->sc_dev.dv_xname,\n\t\t    sc->xctail);\n#endif\n\n#if NBPFILTER > 0\n\t/*\n\t * If BPF is listening on this interface, let it see the packet before\n\t * we push it on the wire.\n\t */\n\tif (sc->sc_arpcom.ac_if.if_bpf)\n\t\tbpf_tap(sc->sc_arpcom.ac_if.if_bpf,\n\t\t    sc->xmit_cbuffs[sc->xctail],\n\t\t    sc->xmit_buffs[sc->xctail]->ie_xmit_flags);\n#endif\n\n\tsc->xmit_buffs[sc->xctail]->ie_xmit_flags |= IE_XMIT_LAST;\n\tsc->xmit_buffs[sc->xctail]->ie_xmit_next = 0xffff;\n\tsc->xmit_buffs[sc->xctail]->ie_xmit_buf =\n\t    MK_24(MEM, sc->xmit_cbuffs[sc->xctail]);\n\n\tsc->xmit_cmds[sc->xctail]->com.ie_cmd_link = 0xffff;\n\tsc->xmit_cmds[sc->xctail]->com.ie_cmd_cmd =\n\t    IE_CMD_XMIT | IE_CMD_INTR | IE_CMD_LAST;\n\n\tsc->xmit_cmds[sc->xctail]->ie_xmit_status = 0;\n\tsc->xmit_cmds[sc->xctail]->ie_xmit_desc =\n\t    MK_16(MEM, sc->xmit_buffs[sc->xctail]);\n\n\tsc->scb->ie_command_list = MK_16(MEM, sc->xmit_cmds[sc->xctail]);\n\tcommand_and_wait(sc, IE_CU_START, 0, 0);\n\n\tsc->sc_arpcom.ac_if.if_timer = 5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "m0->m_pkthdr.len",
            "ETHER_MIN_LEN"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "gusmax_mixer_query_devinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2892-3092",
          "snippet": "int\ngusmax_mixer_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tDPRINTF((\"gusmax_query_devinfo: index=%d\\n\", dip->index));\n\n\tswitch(dip->index) {\n#if 0\n    case GUSMAX_MIC_IN_LVL:\t/* Microphone */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_MIC_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n#endif\n\n    case GUSMAX_MONO_LVL:\t/* mono/microphone mixer */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_MONO_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_DAC_LVL:\t\t/*  dacout */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_DAC_MUTE;\n\tstrcpy(dip->label.name, AudioNdac);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_LINE_IN_LVL:\t/* line */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_LINE_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNline);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_CD_LVL:\t\t/* cd */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_CD_MUTE;\n\tstrcpy(dip->label.name, AudioNcd);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n\n    case GUSMAX_MONITOR_LVL:\t/* monitor level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->next = GUSMAX_MONITOR_MUTE;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNmonitor);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_OUT_LVL:\t\t/* cs4231 output volume: not useful? */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNoutput);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_SPEAKER_LVL:\t\t/* fake speaker volume */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_SPEAKER_MUTE;\n\tstrcpy(dip->label.name, AudioNmaster);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_LINE_IN_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_LINE_IN_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case GUSMAX_DAC_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_DAC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_CD_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_CD_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case GUSMAX_MONO_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_MONO_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_MONITOR_MUTE:\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_MONITOR_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_SPEAKER_MUTE:\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_SPEAKER_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n    mute:\n\tstrcpy(dip->label.name, AudioNmute);\n\tdip->un.e.num_mem = 2;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\tdip->un.e.member[0].ord = 0;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\tdip->un.e.member[1].ord = 1;\n\tbreak;\n\t\n    case GUSMAX_REC_LVL:\t/* record level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_RECORD_SOURCE;\n\tstrcpy(dip->label.name, AudioNrecord);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_RECORD_SOURCE:\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_REC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNsource);\n\tdip->un.e.num_mem = 4;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoutput);\n\tdip->un.e.member[0].ord = DAC_IN_PORT;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNmicrophone);\n\tdip->un.e.member[1].ord = MIC_IN_PORT;\n\tstrcpy(dip->un.e.member[2].label.name, AudioNdac);\n\tdip->un.e.member[2].ord = AUX1_IN_PORT;\n\tstrcpy(dip->un.e.member[3].label.name, AudioNline);\n\tdip->un.e.member[3].ord = LINE_IN_PORT;\n\tbreak;\n\n    case GUSMAX_INPUT_CLASS:\t\t\t/* input class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCinputs);\n\tbreak;\n\n    case GUSMAX_OUTPUT_CLASS:\t\t\t/* output class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCoutputs);\n\tbreak;\n\n    case GUSMAX_MONITOR_CLASS:\t\t\t/* monitor class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCmonitor);\n\tbreak;\n\t    \n    case GUSMAX_RECORD_CLASS:\t\t\t/* record source class */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCrecord);\n\tbreak;\n\n    default:\n\treturn ENXIO;\n\t/*NOTREACHED*/\n    }\n    DPRINTF((\"AUDIO_MIXER_DEVINFO: name=%s\\n\", dip->label.name));\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngusmax_mixer_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tDPRINTF((\"gusmax_query_devinfo: index=%d\\n\", dip->index));\n\n\tswitch(dip->index) {\n#if 0\n    case GUSMAX_MIC_IN_LVL:\t/* Microphone */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_MIC_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n#endif\n\n    case GUSMAX_MONO_LVL:\t/* mono/microphone mixer */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_MONO_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_DAC_LVL:\t\t/*  dacout */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_DAC_MUTE;\n\tstrcpy(dip->label.name, AudioNdac);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_LINE_IN_LVL:\t/* line */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_LINE_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNline);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_CD_LVL:\t\t/* cd */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_CD_MUTE;\n\tstrcpy(dip->label.name, AudioNcd);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n\n    case GUSMAX_MONITOR_LVL:\t/* monitor level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->next = GUSMAX_MONITOR_MUTE;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNmonitor);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_OUT_LVL:\t\t/* cs4231 output volume: not useful? */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNoutput);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_SPEAKER_LVL:\t\t/* fake speaker volume */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_SPEAKER_MUTE;\n\tstrcpy(dip->label.name, AudioNmaster);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_LINE_IN_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_LINE_IN_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case GUSMAX_DAC_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_DAC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_CD_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_CD_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case GUSMAX_MONO_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_MONO_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_MONITOR_MUTE:\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_MONITOR_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_SPEAKER_MUTE:\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_SPEAKER_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n    mute:\n\tstrcpy(dip->label.name, AudioNmute);\n\tdip->un.e.num_mem = 2;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\tdip->un.e.member[0].ord = 0;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\tdip->un.e.member[1].ord = 1;\n\tbreak;\n\t\n    case GUSMAX_REC_LVL:\t/* record level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_RECORD_SOURCE;\n\tstrcpy(dip->label.name, AudioNrecord);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_RECORD_SOURCE:\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_REC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNsource);\n\tdip->un.e.num_mem = 4;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoutput);\n\tdip->un.e.member[0].ord = DAC_IN_PORT;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNmicrophone);\n\tdip->un.e.member[1].ord = MIC_IN_PORT;\n\tstrcpy(dip->un.e.member[2].label.name, AudioNdac);\n\tdip->un.e.member[2].ord = AUX1_IN_PORT;\n\tstrcpy(dip->un.e.member[3].label.name, AudioNline);\n\tdip->un.e.member[3].ord = LINE_IN_PORT;\n\tbreak;\n\n    case GUSMAX_INPUT_CLASS:\t\t\t/* input class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCinputs);\n\tbreak;\n\n    case GUSMAX_OUTPUT_CLASS:\t\t\t/* output class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCoutputs);\n\tbreak;\n\n    case GUSMAX_MONITOR_CLASS:\t\t\t/* monitor class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCmonitor);\n\tbreak;\n\t    \n    case GUSMAX_RECORD_CLASS:\t\t\t/* record source class */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCrecord);\n\tbreak;\n\n    default:\n\treturn ENXIO;\n\t/*NOTREACHED*/\n    }\n    DPRINTF((\"AUDIO_MIXER_DEVINFO: name=%s\\n\", dip->label.name));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "mtod(m, caddr_t)",
            "buffer",
            "m->m_len"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: fill buffer %d\\n\"",
            "sc->sc_dev.dv_xname",
            "sc->xchead"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m0"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"iestart: no header mbuf\""
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tNTXBUF\t\t2\t\t/* number of transmit commands */\n#define\tETHER_MIN_LEN\t64\n#define\tIED_ENQ\t\t0x20\n\nvoid iestart;\nvoid iexmit;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\niestart(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ie_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0, *m;\n\tu_char *buffer;\n\tu_short len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\tfor (;;) {\n\t\tif (sc->xmit_busy == NTXBUF) {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (m0 == 0)\n\t\t\tbreak;\n\n\t\t/* We need to use m->m_pkthdr.len, so require the header */\n\t\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\t\tpanic(\"iestart: no header mbuf\");\n\n#if NBPFILTER > 0\n\t\t/* Tap off here if there is a BPF listener. */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n#ifdef IEDEBUG\n\t\tif (sc->sc_debug & IED_ENQ)\n\t\t\tprintf(\"%s: fill buffer %d\\n\", sc->sc_dev.dv_xname,\n\t\t\t    sc->xchead);\n#endif\n\n\t\tbuffer = sc->xmit_cbuffs[sc->xchead];\n\t\tfor (m = m0; m != 0; m = m->m_next) {\n\t\t\tbcopy(mtod(m, caddr_t), buffer, m->m_len);\n\t\t\tbuffer += m->m_len;\n\t\t}\n\t\tlen = max(m0->m_pkthdr.len, ETHER_MIN_LEN);\n\n\t\tm_freem(m0);\n\t\tsc->xmit_buffs[sc->xchead]->ie_xmit_flags = len;\n\n\t\t/* Start the first packet transmitting. */\n\t\tif (sc->xmit_busy == 0)\n\t\t\tiexmit(sc);\n\n\t\tsc->xchead = (sc->xchead + 1) % NTXBUF;\n\t\tsc->xmit_busy++;\n\t}\n}"
  },
  {
    "function_name": "ie_drop_packet_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1444-1473",
    "snippet": "void\nie_drop_packet_buffer(sc)\n\tstruct ie_softc *sc;\n{\n\tint i;\n\n\tdo {\n\t\t/*\n\t\t * This means we are somehow out of sync.  So, we reset the\n\t\t * adapter.\n\t\t */\n\t\tif (!(sc->rbuffs[sc->rbhead]->ie_rbd_actual & IE_RBD_USED)) {\n#ifdef IEDEBUG\n\t\t\tprint_rbd(sc->rbuffs[sc->rbhead]);\n#endif\n\t\t\tlog(LOG_ERR, \"%s: receive descriptors out of sync at %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sc->rbhead);\n\t\t\tiereset(sc);\n\t\t\treturn;\n\t\t}\n\n\t\ti = sc->rbuffs[sc->rbhead]->ie_rbd_actual & IE_RBD_LAST;\n\n\t\tsc->rbuffs[sc->rbhead]->ie_rbd_length |= IE_RBD_LAST;\n\t\tsc->rbuffs[sc->rbhead]->ie_rbd_actual = 0;\n\t\tsc->rbhead = (sc->rbhead + 1) % NRXBUF;\n\t\tsc->rbuffs[sc->rbtail]->ie_rbd_length &= ~IE_RBD_LAST;\n\t\tsc->rbtail = (sc->rbtail + 1) % NRXBUF;\n\t} while (!i);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tNRXBUF\t\t48\t\t/* number of buffers to allocate */"
    ],
    "globals_used": [
      "void iereset",
      "void ie_drop_packet_buffer",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iereset",
          "args": [
            "sc"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "iereset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1797-1817",
          "snippet": "void\niereset(sc)\n\tstruct ie_softc *sc;\n{\n\tint s = splnet();\n\n\tiestop(sc);\n\n\t/*\n\t * Stop i82586 dead in its tracks.\n\t */\n\tif (command_and_wait(sc, IE_RU_ABORT | IE_CU_ABORT, 0, 0))\n\t\tprintf(\"%s: abort commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\tif (command_and_wait(sc, IE_RU_DISABLE | IE_CU_STOP, 0, 0))\n\t\tprintf(\"%s: disable commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\tieinit(sc);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void iestop",
            "int ieinit",
            "void iereset",
            "static int command_and_wait",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iestop;\nint ieinit;\nvoid iereset;\nstatic int command_and_wait;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\niereset(sc)\n\tstruct ie_softc *sc;\n{\n\tint s = splnet();\n\n\tiestop(sc);\n\n\t/*\n\t * Stop i82586 dead in its tracks.\n\t */\n\tif (command_and_wait(sc, IE_RU_ABORT | IE_CU_ABORT, 0, 0))\n\t\tprintf(\"%s: abort commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\tif (command_and_wait(sc, IE_RU_DISABLE | IE_CU_STOP, 0, 0))\n\t\tprintf(\"%s: disable commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\tieinit(sc);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: receive descriptors out of sync at %d\\n\"",
            "sc->sc_dev.dv_xname",
            "sc->rbhead"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_rbd",
          "args": [
            "sc->rbuffs[sc->rbhead]"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "print_rbd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "2266-2275",
          "snippet": "void\nprint_rbd(rbd)\n\tvolatile struct ie_recv_buf_desc *rbd;\n{\n\n\tprintf(\"RBD at %08lx:\\nactual %04x, next %04x, buffer %08x\\n\"\n\t    \"length %04x, mbz %04x\\n\", (u_long)rbd, rbd->ie_rbd_actual,\n\t    rbd->ie_rbd_next, rbd->ie_rbd_buffer, rbd->ie_rbd_length,\n\t    rbd->mbz);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\nprint_rbd(rbd)\n\tvolatile struct ie_recv_buf_desc *rbd;\n{\n\n\tprintf(\"RBD at %08lx:\\nactual %04x, next %04x, buffer %08x\\n\"\n\t    \"length %04x, mbz %04x\\n\", (u_long)rbd, rbd->ie_rbd_actual,\n\t    rbd->ie_rbd_next, rbd->ie_rbd_buffer, rbd->ie_rbd_length,\n\t    rbd->mbz);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tNRXBUF\t\t48\t\t/* number of buffers to allocate */\n\nvoid iereset;\nvoid ie_drop_packet_buffer;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nie_drop_packet_buffer(sc)\n\tstruct ie_softc *sc;\n{\n\tint i;\n\n\tdo {\n\t\t/*\n\t\t * This means we are somehow out of sync.  So, we reset the\n\t\t * adapter.\n\t\t */\n\t\tif (!(sc->rbuffs[sc->rbhead]->ie_rbd_actual & IE_RBD_USED)) {\n#ifdef IEDEBUG\n\t\t\tprint_rbd(sc->rbuffs[sc->rbhead]);\n#endif\n\t\t\tlog(LOG_ERR, \"%s: receive descriptors out of sync at %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sc->rbhead);\n\t\t\tiereset(sc);\n\t\t\treturn;\n\t\t}\n\n\t\ti = sc->rbuffs[sc->rbhead]->ie_rbd_actual & IE_RBD_LAST;\n\n\t\tsc->rbuffs[sc->rbhead]->ie_rbd_length |= IE_RBD_LAST;\n\t\tsc->rbuffs[sc->rbhead]->ie_rbd_actual = 0;\n\t\tsc->rbhead = (sc->rbhead + 1) % NRXBUF;\n\t\tsc->rbuffs[sc->rbtail]->ie_rbd_length &= ~IE_RBD_LAST;\n\t\tsc->rbtail = (sc->rbtail + 1) % NRXBUF;\n\t} while (!i);\n}"
  },
  {
    "function_name": "ie_readframe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1358-1442",
    "snippet": "void\nie_readframe(sc, num)\n\tstruct ie_softc *sc;\n\tint num;\t\t\t/* frame number to read */\n{\n\tint status;\n\tstruct mbuf *m = 0;\n\tstruct ether_header eh;\n#if NBPFILTER > 0\n\tint bpf_gets_it = 0;\n#endif\n\n\tstatus = sc->rframes[num]->ie_fd_status;\n\n\t/* Advance the RFD list, since we're done with this descriptor. */\n\tsc->rframes[num]->ie_fd_status = 0;\n\tsc->rframes[num]->ie_fd_last |= IE_FD_LAST;\n\tsc->rframes[sc->rftail]->ie_fd_last &= ~IE_FD_LAST;\n\tsc->rftail = (sc->rftail + 1) % NFRAMES;\n\tsc->rfhead = (sc->rfhead + 1) % NFRAMES;\n\n\tif (status & IE_FD_OK) {\n#if NBPFILTER > 0\n\t\tm = ieget(sc, &eh, &bpf_gets_it);\n#else\n\t\tm = ieget(sc, &eh, 0);\n#endif\n\t\tie_drop_packet_buffer(sc);\n\t}\n\tif (m == 0) {\n\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\treturn;\n\t}\n\n#ifdef IEDEBUG\n\tif (sc->sc_debug & IED_READFRAME)\n\t\tprintf(\"%s: frame from ether %s type %x\\n\", sc->sc_dev.dv_xname,\n\t\t    ether_sprintf(eh.ether_shost), (u_int)eh.ether_type);\n#endif\n\n#if NBPFILTER > 0\n\t/*\n\t * Check for a BPF filter; if so, hand it up.\n\t * Note that we have to stick an extra mbuf up front, because bpf_mtap\n\t * expects to have the ether header at the front.\n\t * It doesn't matter that this results in an ill-formatted mbuf chain,\n\t * since BPF just looks at the data.  (It doesn't try to free the mbuf,\n\t * tho' it will make a copy for tcpdump.)\n\t */\n\tif (bpf_gets_it) {\n\t\tstruct mbuf m0;\n\t\tm0.m_len = sizeof eh;\n\t\tm0.m_data = (caddr_t)&eh;\n\t\tm0.m_next = m;\n\n\t\t/* Pass it up. */\n\t\tbpf_mtap(sc->sc_arpcom.ac_if.if_bpf, &m0);\n\n\t\t/*\n\t\t * A signal passed up from the filtering code indicating that\n\t\t * the packet is intended for BPF but not for the protocol\n\t\t * machinery.  We can save a few cycles by not handing it off\n\t\t * to them.\n\t\t */\n\t\tif (bpf_gets_it == 2) {\n\t\t\tm_freem(m);\n\t\t\treturn;\n\t\t}\n\t}\n#endif /* NBPFILTER > 0 */\n\n\t/*\n\t * In here there used to be code to check destination addresses upon\n\t * receipt of a packet.  We have deleted that code, and replaced it\n\t * with code to check the address much earlier in the cycle, before\n\t * copying the data in; this saves us valuable cycles when operating\n\t * as a multicast router or when using BPF.\n\t */\n\n\t/*\n\t * Finally pass this packet up to higher layers.\n\t */\n\tether_input(&sc->sc_arpcom.ac_if, &eh, m);\n\tsc->sc_arpcom.ac_if.if_ipackets++;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tNFRAMES\t\t16\t\t/* number of receive frames */",
      "#define\tIED_READFRAME\t0x10"
    ],
    "globals_used": [
      "void ie_readframe",
      "void ie_drop_packet_buffer",
      "struct mbuf *ieget",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "&sc->sc_arpcom.ac_if",
            "&eh",
            "m"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "sc->sc_arpcom.ac_if.if_bpf",
            "&m0"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: frame from ether %s type %x\\n\"",
            "sc->sc_dev.dv_xname",
            "ether_sprintf(eh.ether_shost)",
            "(u_int)eh.ether_type"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "eh.ether_shost"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ie_drop_packet_buffer",
          "args": [
            "sc"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "ie_drop_packet_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1444-1473",
          "snippet": "void\nie_drop_packet_buffer(sc)\n\tstruct ie_softc *sc;\n{\n\tint i;\n\n\tdo {\n\t\t/*\n\t\t * This means we are somehow out of sync.  So, we reset the\n\t\t * adapter.\n\t\t */\n\t\tif (!(sc->rbuffs[sc->rbhead]->ie_rbd_actual & IE_RBD_USED)) {\n#ifdef IEDEBUG\n\t\t\tprint_rbd(sc->rbuffs[sc->rbhead]);\n#endif\n\t\t\tlog(LOG_ERR, \"%s: receive descriptors out of sync at %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sc->rbhead);\n\t\t\tiereset(sc);\n\t\t\treturn;\n\t\t}\n\n\t\ti = sc->rbuffs[sc->rbhead]->ie_rbd_actual & IE_RBD_LAST;\n\n\t\tsc->rbuffs[sc->rbhead]->ie_rbd_length |= IE_RBD_LAST;\n\t\tsc->rbuffs[sc->rbhead]->ie_rbd_actual = 0;\n\t\tsc->rbhead = (sc->rbhead + 1) % NRXBUF;\n\t\tsc->rbuffs[sc->rbtail]->ie_rbd_length &= ~IE_RBD_LAST;\n\t\tsc->rbtail = (sc->rbtail + 1) % NRXBUF;\n\t} while (!i);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tNRXBUF\t\t48\t\t/* number of buffers to allocate */"
          ],
          "globals_used": [
            "void iereset",
            "void ie_drop_packet_buffer",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tNRXBUF\t\t48\t\t/* number of buffers to allocate */\n\nvoid iereset;\nvoid ie_drop_packet_buffer;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nie_drop_packet_buffer(sc)\n\tstruct ie_softc *sc;\n{\n\tint i;\n\n\tdo {\n\t\t/*\n\t\t * This means we are somehow out of sync.  So, we reset the\n\t\t * adapter.\n\t\t */\n\t\tif (!(sc->rbuffs[sc->rbhead]->ie_rbd_actual & IE_RBD_USED)) {\n#ifdef IEDEBUG\n\t\t\tprint_rbd(sc->rbuffs[sc->rbhead]);\n#endif\n\t\t\tlog(LOG_ERR, \"%s: receive descriptors out of sync at %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sc->rbhead);\n\t\t\tiereset(sc);\n\t\t\treturn;\n\t\t}\n\n\t\ti = sc->rbuffs[sc->rbhead]->ie_rbd_actual & IE_RBD_LAST;\n\n\t\tsc->rbuffs[sc->rbhead]->ie_rbd_length |= IE_RBD_LAST;\n\t\tsc->rbuffs[sc->rbhead]->ie_rbd_actual = 0;\n\t\tsc->rbhead = (sc->rbhead + 1) % NRXBUF;\n\t\tsc->rbuffs[sc->rbtail]->ie_rbd_length &= ~IE_RBD_LAST;\n\t\tsc->rbtail = (sc->rbtail + 1) % NRXBUF;\n\t} while (!i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ieget",
          "args": [
            "sc",
            "&eh",
            "0"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ieget",
          "args": [
            "sc",
            "&eh",
            "&bpf_gets_it"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tNFRAMES\t\t16\t\t/* number of receive frames */\n#define\tIED_READFRAME\t0x10\n\nvoid ie_readframe;\nvoid ie_drop_packet_buffer;\nstruct mbuf *ieget;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nie_readframe(sc, num)\n\tstruct ie_softc *sc;\n\tint num;\t\t\t/* frame number to read */\n{\n\tint status;\n\tstruct mbuf *m = 0;\n\tstruct ether_header eh;\n#if NBPFILTER > 0\n\tint bpf_gets_it = 0;\n#endif\n\n\tstatus = sc->rframes[num]->ie_fd_status;\n\n\t/* Advance the RFD list, since we're done with this descriptor. */\n\tsc->rframes[num]->ie_fd_status = 0;\n\tsc->rframes[num]->ie_fd_last |= IE_FD_LAST;\n\tsc->rframes[sc->rftail]->ie_fd_last &= ~IE_FD_LAST;\n\tsc->rftail = (sc->rftail + 1) % NFRAMES;\n\tsc->rfhead = (sc->rfhead + 1) % NFRAMES;\n\n\tif (status & IE_FD_OK) {\n#if NBPFILTER > 0\n\t\tm = ieget(sc, &eh, &bpf_gets_it);\n#else\n\t\tm = ieget(sc, &eh, 0);\n#endif\n\t\tie_drop_packet_buffer(sc);\n\t}\n\tif (m == 0) {\n\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\treturn;\n\t}\n\n#ifdef IEDEBUG\n\tif (sc->sc_debug & IED_READFRAME)\n\t\tprintf(\"%s: frame from ether %s type %x\\n\", sc->sc_dev.dv_xname,\n\t\t    ether_sprintf(eh.ether_shost), (u_int)eh.ether_type);\n#endif\n\n#if NBPFILTER > 0\n\t/*\n\t * Check for a BPF filter; if so, hand it up.\n\t * Note that we have to stick an extra mbuf up front, because bpf_mtap\n\t * expects to have the ether header at the front.\n\t * It doesn't matter that this results in an ill-formatted mbuf chain,\n\t * since BPF just looks at the data.  (It doesn't try to free the mbuf,\n\t * tho' it will make a copy for tcpdump.)\n\t */\n\tif (bpf_gets_it) {\n\t\tstruct mbuf m0;\n\t\tm0.m_len = sizeof eh;\n\t\tm0.m_data = (caddr_t)&eh;\n\t\tm0.m_next = m;\n\n\t\t/* Pass it up. */\n\t\tbpf_mtap(sc->sc_arpcom.ac_if.if_bpf, &m0);\n\n\t\t/*\n\t\t * A signal passed up from the filtering code indicating that\n\t\t * the packet is intended for BPF but not for the protocol\n\t\t * machinery.  We can save a few cycles by not handing it off\n\t\t * to them.\n\t\t */\n\t\tif (bpf_gets_it == 2) {\n\t\t\tm_freem(m);\n\t\t\treturn;\n\t\t}\n\t}\n#endif /* NBPFILTER > 0 */\n\n\t/*\n\t * In here there used to be code to check destination addresses upon\n\t * receipt of a packet.  We have deleted that code, and replaced it\n\t * with code to check the address much earlier in the cycle, before\n\t * copying the data in; this saves us valuable cycles when operating\n\t * as a multicast router or when using BPF.\n\t */\n\n\t/*\n\t * Finally pass this packet up to higher layers.\n\t */\n\tether_input(&sc->sc_arpcom.ac_if, &eh, m);\n\tsc->sc_arpcom.ac_if.if_ipackets++;\n}"
  },
  {
    "function_name": "iexmit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1191-1230",
    "snippet": "void\niexmit(sc)\n\tstruct ie_softc *sc;\n{\n\n#ifdef IEDEBUG\n\tif (sc->sc_debug & IED_XMIT)\n\t\tprintf(\"%s: xmit buffer %d\\n\", sc->sc_dev.dv_xname,\n\t\t    sc->xctail);\n#endif\n\n#if NBPFILTER > 0\n\t/*\n\t * If BPF is listening on this interface, let it see the packet before\n\t * we push it on the wire.\n\t */\n\tif (sc->sc_arpcom.ac_if.if_bpf)\n\t\tbpf_tap(sc->sc_arpcom.ac_if.if_bpf,\n\t\t    sc->xmit_cbuffs[sc->xctail],\n\t\t    sc->xmit_buffs[sc->xctail]->ie_xmit_flags);\n#endif\n\n\tsc->xmit_buffs[sc->xctail]->ie_xmit_flags |= IE_XMIT_LAST;\n\tsc->xmit_buffs[sc->xctail]->ie_xmit_next = 0xffff;\n\tsc->xmit_buffs[sc->xctail]->ie_xmit_buf =\n\t    MK_24(MEM, sc->xmit_cbuffs[sc->xctail]);\n\n\tsc->xmit_cmds[sc->xctail]->com.ie_cmd_link = 0xffff;\n\tsc->xmit_cmds[sc->xctail]->com.ie_cmd_cmd =\n\t    IE_CMD_XMIT | IE_CMD_INTR | IE_CMD_LAST;\n\n\tsc->xmit_cmds[sc->xctail]->ie_xmit_status = 0;\n\tsc->xmit_cmds[sc->xctail]->ie_xmit_desc =\n\t    MK_16(MEM, sc->xmit_buffs[sc->xctail]);\n\n\tsc->scb->ie_command_list = MK_16(MEM, sc->xmit_cmds[sc->xctail]);\n\tcommand_and_wait(sc, IE_CU_START, 0, 0);\n\n\tsc->sc_arpcom.ac_if.if_timer = 5;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define MEM \tsc->sc_maddr",
      "#define\tIED_XMIT\t0x40"
    ],
    "globals_used": [
      "static int command_and_wait",
      "void iexmit",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "command_and_wait",
          "args": [
            "sc",
            "IE_CU_START",
            "0",
            "0"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "command_and_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1838-1886",
          "snippet": "static int\ncommand_and_wait(sc, cmd, pcmd, mask)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tvolatile void *pcmd;\n\tint mask;\n{\n\tvolatile struct ie_cmd_common *cc = pcmd;\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvolatile int timedout = 0;\n\textern int hz;\n\n\tscb->ie_command = (u_short)cmd;\n\n\tif (IE_ACTION_COMMAND(cmd) && pcmd) {\n\t\t(sc->chan_attn)(sc);\n\n\t\t/*\n\t\t * According to the packet driver, the minimum timeout should\n\t\t * be .369 seconds, which we round up to .4.\n\t\t */\n\t\ttimeout(chan_attn_timeout, (caddr_t)&timedout, 2 * hz / 5);\n\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, but I haven't figured out how, or indeed if, we\n\t\t * can put the process waiting for action to sleep.  (We may\n\t\t * be getting called through some other timeout running in the\n\t\t * kernel.)\n\t\t */\n\t\tfor (;;)\n\t\t\tif ((cc->ie_cmd_status & mask) || timedout)\n\t\t\t\tbreak;\n\n\t\tuntimeout(chan_attn_timeout, (caddr_t)&timedout);\n\n\t\treturn timedout;\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\t(sc->chan_attn)(sc);\n\n\t\twhile (scb->ie_command)\n\t\t\t;\t\t\t\t/* spin lock */\n\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int command_and_wait",
            "static void chan_attn_timeout",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int command_and_wait;\nstatic void chan_attn_timeout;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic int\ncommand_and_wait(sc, cmd, pcmd, mask)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tvolatile void *pcmd;\n\tint mask;\n{\n\tvolatile struct ie_cmd_common *cc = pcmd;\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvolatile int timedout = 0;\n\textern int hz;\n\n\tscb->ie_command = (u_short)cmd;\n\n\tif (IE_ACTION_COMMAND(cmd) && pcmd) {\n\t\t(sc->chan_attn)(sc);\n\n\t\t/*\n\t\t * According to the packet driver, the minimum timeout should\n\t\t * be .369 seconds, which we round up to .4.\n\t\t */\n\t\ttimeout(chan_attn_timeout, (caddr_t)&timedout, 2 * hz / 5);\n\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, but I haven't figured out how, or indeed if, we\n\t\t * can put the process waiting for action to sleep.  (We may\n\t\t * be getting called through some other timeout running in the\n\t\t * kernel.)\n\t\t */\n\t\tfor (;;)\n\t\t\tif ((cc->ie_cmd_status & mask) || timedout)\n\t\t\t\tbreak;\n\n\t\tuntimeout(chan_attn_timeout, (caddr_t)&timedout);\n\n\t\treturn timedout;\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\t(sc->chan_attn)(sc);\n\n\t\twhile (scb->ie_command)\n\t\t\t;\t\t\t\t/* spin lock */\n\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MK_16",
          "args": [
            "MEM",
            "sc->xmit_cmds[sc->xctail]"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MK_16",
          "args": [
            "MEM",
            "sc->xmit_buffs[sc->xctail]"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MK_24",
          "args": [
            "MEM",
            "sc->xmit_cbuffs[sc->xctail]"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_tap",
          "args": [
            "sc->sc_arpcom.ac_if.if_bpf",
            "sc->xmit_cbuffs[sc->xctail]",
            "sc->xmit_buffs[sc->xctail]->ie_xmit_flags"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: xmit buffer %d\\n\"",
            "sc->sc_dev.dv_xname",
            "sc->xctail"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define MEM \tsc->sc_maddr\n#define\tIED_XMIT\t0x40\n\nstatic int command_and_wait;\nvoid iexmit;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\niexmit(sc)\n\tstruct ie_softc *sc;\n{\n\n#ifdef IEDEBUG\n\tif (sc->sc_debug & IED_XMIT)\n\t\tprintf(\"%s: xmit buffer %d\\n\", sc->sc_dev.dv_xname,\n\t\t    sc->xctail);\n#endif\n\n#if NBPFILTER > 0\n\t/*\n\t * If BPF is listening on this interface, let it see the packet before\n\t * we push it on the wire.\n\t */\n\tif (sc->sc_arpcom.ac_if.if_bpf)\n\t\tbpf_tap(sc->sc_arpcom.ac_if.if_bpf,\n\t\t    sc->xmit_cbuffs[sc->xctail],\n\t\t    sc->xmit_buffs[sc->xctail]->ie_xmit_flags);\n#endif\n\n\tsc->xmit_buffs[sc->xctail]->ie_xmit_flags |= IE_XMIT_LAST;\n\tsc->xmit_buffs[sc->xctail]->ie_xmit_next = 0xffff;\n\tsc->xmit_buffs[sc->xctail]->ie_xmit_buf =\n\t    MK_24(MEM, sc->xmit_cbuffs[sc->xctail]);\n\n\tsc->xmit_cmds[sc->xctail]->com.ie_cmd_link = 0xffff;\n\tsc->xmit_cmds[sc->xctail]->com.ie_cmd_cmd =\n\t    IE_CMD_XMIT | IE_CMD_INTR | IE_CMD_LAST;\n\n\tsc->xmit_cmds[sc->xctail]->ie_xmit_status = 0;\n\tsc->xmit_cmds[sc->xctail]->ie_xmit_desc =\n\t    MK_16(MEM, sc->xmit_buffs[sc->xctail]);\n\n\tsc->scb->ie_command_list = MK_16(MEM, sc->xmit_cmds[sc->xctail]);\n\tcommand_and_wait(sc, IE_CU_START, 0, 0);\n\n\tsc->sc_arpcom.ac_if.if_timer = 5;\n}"
  },
  {
    "function_name": "ie_packet_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1165-1184",
    "snippet": "static __inline int\nie_packet_len(sc)\n\tstruct ie_softc *sc;\n{\n\tint i;\n\tint head = sc->rbhead;\n\tint acc = 0;\n\n\tdo {\n\t\tif (!(sc->rbuffs[sc->rbhead]->ie_rbd_actual & IE_RBD_USED))\n\t\t\treturn -1;\n\n\t\ti = sc->rbuffs[head]->ie_rbd_actual & IE_RBD_LAST;\n\n\t\tacc += ie_buflen(sc, head);\n\t\thead = (head + 1) % NRXBUF;\n\t} while (!i);\n\n\treturn acc;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tNRXBUF\t\t48\t\t/* number of buffers to allocate */"
    ],
    "globals_used": [
      "static __inline int ie_buflen",
      "static __inline int ie_packet_len",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ie_buflen",
          "args": [
            "sc",
            "head"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "ie_buflen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1155-1163",
          "snippet": "static __inline int\nie_buflen(sc, head)\n\tstruct ie_softc *sc;\n\tint head;\n{\n\n\treturn (sc->rbuffs[head]->ie_rbd_actual\n\t    & (IE_RBUF_SIZE | (IE_RBUF_SIZE - 1)));\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tIE_RBUF_SIZE\t256\t\t/* size of each receive buffer;\n\t\t\t\t\t\tMUST BE POWER OF TWO */"
          ],
          "globals_used": [
            "static __inline int ie_buflen",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tIE_RBUF_SIZE\t256\t\t/* size of each receive buffer;\n\t\t\t\t\t\tMUST BE POWER OF TWO */\n\nstatic __inline int ie_buflen;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic __inline int\nie_buflen(sc, head)\n\tstruct ie_softc *sc;\n\tint head;\n{\n\n\treturn (sc->rbuffs[head]->ie_rbd_actual\n\t    & (IE_RBUF_SIZE | (IE_RBUF_SIZE - 1)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tNRXBUF\t\t48\t\t/* number of buffers to allocate */\n\nstatic __inline int ie_buflen;\nstatic __inline int ie_packet_len;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic __inline int\nie_packet_len(sc)\n\tstruct ie_softc *sc;\n{\n\tint i;\n\tint head = sc->rbhead;\n\tint acc = 0;\n\n\tdo {\n\t\tif (!(sc->rbuffs[sc->rbhead]->ie_rbd_actual & IE_RBD_USED))\n\t\t\treturn -1;\n\n\t\ti = sc->rbuffs[head]->ie_rbd_actual & IE_RBD_LAST;\n\n\t\tacc += ie_buflen(sc, head);\n\t\thead = (head + 1) % NRXBUF;\n\t} while (!i);\n\n\treturn acc;\n}"
  },
  {
    "function_name": "ie_buflen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1155-1163",
    "snippet": "static __inline int\nie_buflen(sc, head)\n\tstruct ie_softc *sc;\n\tint head;\n{\n\n\treturn (sc->rbuffs[head]->ie_rbd_actual\n\t    & (IE_RBUF_SIZE | (IE_RBUF_SIZE - 1)));\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tIE_RBUF_SIZE\t256\t\t/* size of each receive buffer;\n\t\t\t\t\t\tMUST BE POWER OF TWO */"
    ],
    "globals_used": [
      "static __inline int ie_buflen",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tIE_RBUF_SIZE\t256\t\t/* size of each receive buffer;\n\t\t\t\t\t\tMUST BE POWER OF TWO */\n\nstatic __inline int ie_buflen;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic __inline int\nie_buflen(sc, head)\n\tstruct ie_softc *sc;\n\tint head;\n{\n\n\treturn (sc->rbuffs[head]->ie_rbd_actual\n\t    & (IE_RBUF_SIZE | (IE_RBUF_SIZE - 1)));\n}"
  },
  {
    "function_name": "check_eh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1040-1148",
    "snippet": "static __inline int\ncheck_eh(sc, eh, to_bpf)\n\tstruct ie_softc *sc;\n\tstruct ether_header *eh;\n\tint *to_bpf;\n{\n\tint i;\n\n\tswitch (sc->promisc) {\n\tcase IFF_ALLMULTI:\n\t\t/*\n\t\t * Receiving all multicasts, but no unicasts except those\n\t\t * destined for us.\n\t\t */\n#if NBPFILTER > 0\n\t\t*to_bpf = (sc->sc_arpcom.ac_if.if_bpf != 0); /* BPF gets this packet if anybody cares */\n#endif\n\t\tif (eh->ether_dhost[0] & 1)\n\t\t\treturn 1;\n\t\tif (ether_equal(eh->ether_dhost, sc->sc_arpcom.ac_enaddr))\n\t\t\treturn 1;\n\t\treturn 0;\n\n\tcase IFF_PROMISC:\n\t\t/*\n\t\t * Receiving all packets.  These need to be passed on to BPF.\n\t\t */\n#if NBPFILTER > 0\n\t\t*to_bpf = (sc->sc_arpcom.ac_if.if_bpf != 0) ||\n\t\t    (sc->sc_arpcom.ac_if.if_bridge != NULL);\n#else\n\t\t*to_bpf = (sc->sc_arpcom.ac_if.if_bridge != NULL);\n#endif\n\t\t/* If for us, accept and hand up to BPF */\n\t\tif (ether_equal(eh->ether_dhost, sc->sc_arpcom.ac_enaddr))\n\t\t\treturn 1;\n\n#if NBPFILTER > 0\n\t\tif (*to_bpf && sc->sc_arpcom.ac_if.if_bridge == NULL)\n\t\t\t*to_bpf = 2; /* we don't need to see it */\n#endif\n\n\t\t/*\n\t\t * Not a multicast, so BPF wants to see it but we don't.\n\t\t */\n\t\tif (!(eh->ether_dhost[0] & 1))\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * If it's one of our multicast groups, accept it and pass it\n\t\t * up.\n\t\t */\n\t\tfor (i = 0; i < sc->mcast_count; i++) {\n\t\t\tif (ether_equal(eh->ether_dhost, (u_char *)&sc->mcast_addrs[i])) {\n#if NBPFILTER > 0\n\t\t\t\tif (*to_bpf)\n\t\t\t\t\t*to_bpf = 1;\n#endif\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\n\tcase IFF_ALLMULTI | IFF_PROMISC:\n\t\t/*\n\t\t * Acting as a multicast router, and BPF running at the same\n\t\t * time.  Whew!  (Hope this is a fast machine...)\n\t\t */\n#if NBPFILTER > 0\n\t\t*to_bpf = (sc->sc_arpcom.ac_if.if_bpf != 0) ||\n\t\t    (sc->sc_arpcom.ac_if.if_bridge != NULL);\n#else\n\t\t*to_bpf = (sc->sc_arpcom.ac_if.if_bridge != NULL);\n#endif\n\t\t/* We want to see multicasts. */\n\t\tif (eh->ether_dhost[0] & 1)\n\t\t\treturn 1;\n\n\t\t/* We want to see our own packets */\n\t\tif (ether_equal(eh->ether_dhost, sc->sc_arpcom.ac_enaddr))\n\t\t\treturn 1;\n\n\t\t/* Anything else goes to BPF but nothing else. */\n#if NBPFILTER > 0\n\t\tif (*to_bpf && sc->sc_arpcom.ac_if.if_bridge == NULL)\n\t\t\t*to_bpf = 2;\n#endif\n\t\treturn 1;\n\n\tcase 0:\n\t\t/*\n\t\t * Only accept unicast packets destined for us, or multicasts\n\t\t * for groups that we belong to.  For now, we assume that the\n\t\t * '586 will only return packets that we asked it for.  This\n\t\t * isn't strictly true (it uses hashing for the multicast\n\t\t * filter), but it will do in this case, and we want to get out\n\t\t * of here as quickly as possible.\n\t\t */\n#if NBPFILTER > 0\n\t\t*to_bpf = (sc->sc_arpcom.ac_if.if_bpf != 0);\n#endif\n\t\treturn 1;\n\t}\n\n#ifdef DIAGNOSTIC\n\tpanic(\"check_eh: impossible\");\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline int ether_equal",
      "static __inline int check_eh",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;",
      "int *to_bpf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"check_eh: impossible\""
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_equal",
          "args": [
            "eh->ether_dhost",
            "sc->sc_arpcom.ac_enaddr"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "ether_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1017-1026",
          "snippet": "static __inline int\nether_equal(one, two)\n\tu_char *one, *two;\n{\n\n\tif (one[0] != two[0] || one[1] != two[1] || one[2] != two[2] ||\n\t    one[3] != two[3] || one[4] != two[4] || one[5] != two[5])\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline int ether_equal"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline int ether_equal;\n\nstatic __inline int\nether_equal(one, two)\n\tu_char *one, *two;\n{\n\n\tif (one[0] != two[0] || one[1] != two[1] || one[2] != two[2] ||\n\t    one[3] != two[3] || one[4] != two[4] || one[5] != two[5])\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline int ether_equal;\nstatic __inline int check_eh;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\nint *to_bpf;\n\nstatic __inline int\ncheck_eh(sc, eh, to_bpf)\n\tstruct ie_softc *sc;\n\tstruct ether_header *eh;\n\tint *to_bpf;\n{\n\tint i;\n\n\tswitch (sc->promisc) {\n\tcase IFF_ALLMULTI:\n\t\t/*\n\t\t * Receiving all multicasts, but no unicasts except those\n\t\t * destined for us.\n\t\t */\n#if NBPFILTER > 0\n\t\t*to_bpf = (sc->sc_arpcom.ac_if.if_bpf != 0); /* BPF gets this packet if anybody cares */\n#endif\n\t\tif (eh->ether_dhost[0] & 1)\n\t\t\treturn 1;\n\t\tif (ether_equal(eh->ether_dhost, sc->sc_arpcom.ac_enaddr))\n\t\t\treturn 1;\n\t\treturn 0;\n\n\tcase IFF_PROMISC:\n\t\t/*\n\t\t * Receiving all packets.  These need to be passed on to BPF.\n\t\t */\n#if NBPFILTER > 0\n\t\t*to_bpf = (sc->sc_arpcom.ac_if.if_bpf != 0) ||\n\t\t    (sc->sc_arpcom.ac_if.if_bridge != NULL);\n#else\n\t\t*to_bpf = (sc->sc_arpcom.ac_if.if_bridge != NULL);\n#endif\n\t\t/* If for us, accept and hand up to BPF */\n\t\tif (ether_equal(eh->ether_dhost, sc->sc_arpcom.ac_enaddr))\n\t\t\treturn 1;\n\n#if NBPFILTER > 0\n\t\tif (*to_bpf && sc->sc_arpcom.ac_if.if_bridge == NULL)\n\t\t\t*to_bpf = 2; /* we don't need to see it */\n#endif\n\n\t\t/*\n\t\t * Not a multicast, so BPF wants to see it but we don't.\n\t\t */\n\t\tif (!(eh->ether_dhost[0] & 1))\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * If it's one of our multicast groups, accept it and pass it\n\t\t * up.\n\t\t */\n\t\tfor (i = 0; i < sc->mcast_count; i++) {\n\t\t\tif (ether_equal(eh->ether_dhost, (u_char *)&sc->mcast_addrs[i])) {\n#if NBPFILTER > 0\n\t\t\t\tif (*to_bpf)\n\t\t\t\t\t*to_bpf = 1;\n#endif\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\n\tcase IFF_ALLMULTI | IFF_PROMISC:\n\t\t/*\n\t\t * Acting as a multicast router, and BPF running at the same\n\t\t * time.  Whew!  (Hope this is a fast machine...)\n\t\t */\n#if NBPFILTER > 0\n\t\t*to_bpf = (sc->sc_arpcom.ac_if.if_bpf != 0) ||\n\t\t    (sc->sc_arpcom.ac_if.if_bridge != NULL);\n#else\n\t\t*to_bpf = (sc->sc_arpcom.ac_if.if_bridge != NULL);\n#endif\n\t\t/* We want to see multicasts. */\n\t\tif (eh->ether_dhost[0] & 1)\n\t\t\treturn 1;\n\n\t\t/* We want to see our own packets */\n\t\tif (ether_equal(eh->ether_dhost, sc->sc_arpcom.ac_enaddr))\n\t\t\treturn 1;\n\n\t\t/* Anything else goes to BPF but nothing else. */\n#if NBPFILTER > 0\n\t\tif (*to_bpf && sc->sc_arpcom.ac_if.if_bridge == NULL)\n\t\t\t*to_bpf = 2;\n#endif\n\t\treturn 1;\n\n\tcase 0:\n\t\t/*\n\t\t * Only accept unicast packets destined for us, or multicasts\n\t\t * for groups that we belong to.  For now, we assume that the\n\t\t * '586 will only return packets that we asked it for.  This\n\t\t * isn't strictly true (it uses hashing for the multicast\n\t\t * filter), but it will do in this case, and we want to get out\n\t\t * of here as quickly as possible.\n\t\t */\n#if NBPFILTER > 0\n\t\t*to_bpf = (sc->sc_arpcom.ac_if.if_bpf != 0);\n#endif\n\t\treturn 1;\n\t}\n\n#ifdef DIAGNOSTIC\n\tpanic(\"check_eh: impossible\");\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "ether_equal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "1017-1026",
    "snippet": "static __inline int\nether_equal(one, two)\n\tu_char *one, *two;\n{\n\n\tif (one[0] != two[0] || one[1] != two[1] || one[2] != two[2] ||\n\t    one[3] != two[3] || one[4] != two[4] || one[5] != two[5])\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline int ether_equal"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline int ether_equal;\n\nstatic __inline int\nether_equal(one, two)\n\tu_char *one, *two;\n{\n\n\tif (one[0] != two[0] || one[1] != two[1] || one[2] != two[2] ||\n\t    one[3] != two[3] || one[4] != two[4] || one[5] != two[5])\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "ietint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "951-1011",
    "snippet": "void\nietint(sc)\n\tstruct ie_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint status;\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tstatus = sc->xmit_cmds[sc->xctail]->ie_xmit_status;\n\n\tif (!(status & IE_STAT_COMPL) || (status & IE_STAT_BUSY))\n\t\tprintf(\"ietint: command still busy!\\n\");\n\n\tif (status & IE_STAT_OK) {\n\t\tifp->if_opackets++;\n\t\tifp->if_collisions += status & IE_XS_MAXCOLL;\n\t} else {\n\t\tifp->if_oerrors++;\n\t\t/*\n\t\t * XXX\n\t\t * Check SQE and DEFERRED?\n\t\t * What if more than one bit is set?\n\t\t */\n\t\tif (status & IE_STAT_ABORT)\n\t\t\tprintf(\"%s: send aborted\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_LATECOLL)\n\t\t\tprintf(\"%s: late collision\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_NOCARRIER)\n\t\t\tprintf(\"%s: no carrier\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_LOSTCTS)\n\t\t\tprintf(\"%s: lost CTS\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_UNDERRUN)\n\t\t\tprintf(\"%s: DMA underrun\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_EXCMAX) {\n\t\t\tprintf(\"%s: too many collisions\\n\", sc->sc_dev.dv_xname);\n\t\t\tifp->if_collisions += 16;\n\t\t}\n\t}\n\n\t/*\n\t * If multicast addresses were added or deleted while transmitting,\n\t * mc_reset() set the want_mcsetup flag indicating that we should do\n\t * it.\n\t */\n\tif (sc->want_mcsetup) {\n\t\tmc_setup(sc, (caddr_t)sc->xmit_cbuffs[sc->xctail]);\n\t\tsc->want_mcsetup = 0;\n\t}\n\n\t/* Done with the buffer. */\n\tsc->xmit_busy--;\n\tsc->xctail = (sc->xctail + 1) % NTXBUF;\n\n\t/* Start the next packet, if any, transmitting. */\n\tif (sc->xmit_busy > 0)\n\t\tiexmit(sc);\n\n\tiestart(ifp);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tNTXBUF\t\t2\t\t/* number of transmit commands */"
    ],
    "globals_used": [
      "void iestart",
      "void ietint",
      "void iexmit",
      "static int mc_setup",
      "static void mc_reset",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iestart",
          "args": [
            "ifp"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "iestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1478-1533",
          "snippet": "void\niestart(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ie_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0, *m;\n\tu_char *buffer;\n\tu_short len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\tfor (;;) {\n\t\tif (sc->xmit_busy == NTXBUF) {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (m0 == 0)\n\t\t\tbreak;\n\n\t\t/* We need to use m->m_pkthdr.len, so require the header */\n\t\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\t\tpanic(\"iestart: no header mbuf\");\n\n#if NBPFILTER > 0\n\t\t/* Tap off here if there is a BPF listener. */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n#ifdef IEDEBUG\n\t\tif (sc->sc_debug & IED_ENQ)\n\t\t\tprintf(\"%s: fill buffer %d\\n\", sc->sc_dev.dv_xname,\n\t\t\t    sc->xchead);\n#endif\n\n\t\tbuffer = sc->xmit_cbuffs[sc->xchead];\n\t\tfor (m = m0; m != 0; m = m->m_next) {\n\t\t\tbcopy(mtod(m, caddr_t), buffer, m->m_len);\n\t\t\tbuffer += m->m_len;\n\t\t}\n\t\tlen = max(m0->m_pkthdr.len, ETHER_MIN_LEN);\n\n\t\tm_freem(m0);\n\t\tsc->xmit_buffs[sc->xchead]->ie_xmit_flags = len;\n\n\t\t/* Start the first packet transmitting. */\n\t\tif (sc->xmit_busy == 0)\n\t\t\tiexmit(sc);\n\n\t\tsc->xchead = (sc->xchead + 1) % NTXBUF;\n\t\tsc->xmit_busy++;\n\t}\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tNTXBUF\t\t2\t\t/* number of transmit commands */",
            "#define\tETHER_MIN_LEN\t64",
            "#define\tIED_ENQ\t\t0x20"
          ],
          "globals_used": [
            "void iestart",
            "void iexmit",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tNTXBUF\t\t2\t\t/* number of transmit commands */\n#define\tETHER_MIN_LEN\t64\n#define\tIED_ENQ\t\t0x20\n\nvoid iestart;\nvoid iexmit;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\niestart(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ie_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0, *m;\n\tu_char *buffer;\n\tu_short len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\tfor (;;) {\n\t\tif (sc->xmit_busy == NTXBUF) {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (m0 == 0)\n\t\t\tbreak;\n\n\t\t/* We need to use m->m_pkthdr.len, so require the header */\n\t\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\t\tpanic(\"iestart: no header mbuf\");\n\n#if NBPFILTER > 0\n\t\t/* Tap off here if there is a BPF listener. */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n#ifdef IEDEBUG\n\t\tif (sc->sc_debug & IED_ENQ)\n\t\t\tprintf(\"%s: fill buffer %d\\n\", sc->sc_dev.dv_xname,\n\t\t\t    sc->xchead);\n#endif\n\n\t\tbuffer = sc->xmit_cbuffs[sc->xchead];\n\t\tfor (m = m0; m != 0; m = m->m_next) {\n\t\t\tbcopy(mtod(m, caddr_t), buffer, m->m_len);\n\t\t\tbuffer += m->m_len;\n\t\t}\n\t\tlen = max(m0->m_pkthdr.len, ETHER_MIN_LEN);\n\n\t\tm_freem(m0);\n\t\tsc->xmit_buffs[sc->xchead]->ie_xmit_flags = len;\n\n\t\t/* Start the first packet transmitting. */\n\t\tif (sc->xmit_busy == 0)\n\t\t\tiexmit(sc);\n\n\t\tsc->xchead = (sc->xchead + 1) % NTXBUF;\n\t\tsc->xmit_busy++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iexmit",
          "args": [
            "sc"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "iexmit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1191-1230",
          "snippet": "void\niexmit(sc)\n\tstruct ie_softc *sc;\n{\n\n#ifdef IEDEBUG\n\tif (sc->sc_debug & IED_XMIT)\n\t\tprintf(\"%s: xmit buffer %d\\n\", sc->sc_dev.dv_xname,\n\t\t    sc->xctail);\n#endif\n\n#if NBPFILTER > 0\n\t/*\n\t * If BPF is listening on this interface, let it see the packet before\n\t * we push it on the wire.\n\t */\n\tif (sc->sc_arpcom.ac_if.if_bpf)\n\t\tbpf_tap(sc->sc_arpcom.ac_if.if_bpf,\n\t\t    sc->xmit_cbuffs[sc->xctail],\n\t\t    sc->xmit_buffs[sc->xctail]->ie_xmit_flags);\n#endif\n\n\tsc->xmit_buffs[sc->xctail]->ie_xmit_flags |= IE_XMIT_LAST;\n\tsc->xmit_buffs[sc->xctail]->ie_xmit_next = 0xffff;\n\tsc->xmit_buffs[sc->xctail]->ie_xmit_buf =\n\t    MK_24(MEM, sc->xmit_cbuffs[sc->xctail]);\n\n\tsc->xmit_cmds[sc->xctail]->com.ie_cmd_link = 0xffff;\n\tsc->xmit_cmds[sc->xctail]->com.ie_cmd_cmd =\n\t    IE_CMD_XMIT | IE_CMD_INTR | IE_CMD_LAST;\n\n\tsc->xmit_cmds[sc->xctail]->ie_xmit_status = 0;\n\tsc->xmit_cmds[sc->xctail]->ie_xmit_desc =\n\t    MK_16(MEM, sc->xmit_buffs[sc->xctail]);\n\n\tsc->scb->ie_command_list = MK_16(MEM, sc->xmit_cmds[sc->xctail]);\n\tcommand_and_wait(sc, IE_CU_START, 0, 0);\n\n\tsc->sc_arpcom.ac_if.if_timer = 5;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define MEM \tsc->sc_maddr",
            "#define\tIED_XMIT\t0x40"
          ],
          "globals_used": [
            "static int command_and_wait",
            "void iexmit",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define MEM \tsc->sc_maddr\n#define\tIED_XMIT\t0x40\n\nstatic int command_and_wait;\nvoid iexmit;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\niexmit(sc)\n\tstruct ie_softc *sc;\n{\n\n#ifdef IEDEBUG\n\tif (sc->sc_debug & IED_XMIT)\n\t\tprintf(\"%s: xmit buffer %d\\n\", sc->sc_dev.dv_xname,\n\t\t    sc->xctail);\n#endif\n\n#if NBPFILTER > 0\n\t/*\n\t * If BPF is listening on this interface, let it see the packet before\n\t * we push it on the wire.\n\t */\n\tif (sc->sc_arpcom.ac_if.if_bpf)\n\t\tbpf_tap(sc->sc_arpcom.ac_if.if_bpf,\n\t\t    sc->xmit_cbuffs[sc->xctail],\n\t\t    sc->xmit_buffs[sc->xctail]->ie_xmit_flags);\n#endif\n\n\tsc->xmit_buffs[sc->xctail]->ie_xmit_flags |= IE_XMIT_LAST;\n\tsc->xmit_buffs[sc->xctail]->ie_xmit_next = 0xffff;\n\tsc->xmit_buffs[sc->xctail]->ie_xmit_buf =\n\t    MK_24(MEM, sc->xmit_cbuffs[sc->xctail]);\n\n\tsc->xmit_cmds[sc->xctail]->com.ie_cmd_link = 0xffff;\n\tsc->xmit_cmds[sc->xctail]->com.ie_cmd_cmd =\n\t    IE_CMD_XMIT | IE_CMD_INTR | IE_CMD_LAST;\n\n\tsc->xmit_cmds[sc->xctail]->ie_xmit_status = 0;\n\tsc->xmit_cmds[sc->xctail]->ie_xmit_desc =\n\t    MK_16(MEM, sc->xmit_buffs[sc->xctail]);\n\n\tsc->scb->ie_command_list = MK_16(MEM, sc->xmit_cmds[sc->xctail]);\n\tcommand_and_wait(sc, IE_CU_START, 0, 0);\n\n\tsc->sc_arpcom.ac_if.if_timer = 5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mc_setup",
          "args": [
            "sc",
            "(caddr_t)sc->xmit_cbuffs[sc->xctail]"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "mc_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "2011-2035",
          "snippet": "static int\nmc_setup(sc, ptr)\n\tstruct ie_softc *sc;\n\tvoid *ptr;\n{\n\tvolatile struct ie_mcast_cmd *cmd = ptr;\n\n\tcmd->com.ie_cmd_status = 0;\n\tcmd->com.ie_cmd_cmd = IE_CMD_MCAST | IE_CMD_LAST;\n\tcmd->com.ie_cmd_link = 0xffff;\n\n\tbcopy((caddr_t)sc->mcast_addrs, (caddr_t)cmd->ie_mcast_addrs,\n\t    sc->mcast_count * sizeof *sc->mcast_addrs);\n\n\tcmd->ie_mcast_bytes = sc->mcast_count * ETHER_ADDR_LEN; /* grrr... */\n\n\tsc->scb->ie_command_list = MK_16(MEM, cmd);\n\tif (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||\n\t    !(cmd->com.ie_cmd_status & IE_STAT_OK)) {\n\t\tprintf(\"%s: multicast address setup command failed\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define MEM \tsc->sc_maddr",
            "#define\tETHER_ADDR_LEN\t6"
          ],
          "globals_used": [
            "static int command_and_wait",
            "static int mc_setup",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define MEM \tsc->sc_maddr\n#define\tETHER_ADDR_LEN\t6\n\nstatic int command_and_wait;\nstatic int mc_setup;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic int\nmc_setup(sc, ptr)\n\tstruct ie_softc *sc;\n\tvoid *ptr;\n{\n\tvolatile struct ie_mcast_cmd *cmd = ptr;\n\n\tcmd->com.ie_cmd_status = 0;\n\tcmd->com.ie_cmd_cmd = IE_CMD_MCAST | IE_CMD_LAST;\n\tcmd->com.ie_cmd_link = 0xffff;\n\n\tbcopy((caddr_t)sc->mcast_addrs, (caddr_t)cmd->ie_mcast_addrs,\n\t    sc->mcast_count * sizeof *sc->mcast_addrs);\n\n\tcmd->ie_mcast_bytes = sc->mcast_count * ETHER_ADDR_LEN; /* grrr... */\n\n\tsc->scb->ie_command_list = MK_16(MEM, cmd);\n\tif (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||\n\t    !(cmd->com.ie_cmd_status & IE_STAT_OK)) {\n\t\tprintf(\"%s: multicast address setup command failed\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: too many collisions\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tNTXBUF\t\t2\t\t/* number of transmit commands */\n\nvoid iestart;\nvoid ietint;\nvoid iexmit;\nstatic int mc_setup;\nstatic void mc_reset;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nietint(sc)\n\tstruct ie_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint status;\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tstatus = sc->xmit_cmds[sc->xctail]->ie_xmit_status;\n\n\tif (!(status & IE_STAT_COMPL) || (status & IE_STAT_BUSY))\n\t\tprintf(\"ietint: command still busy!\\n\");\n\n\tif (status & IE_STAT_OK) {\n\t\tifp->if_opackets++;\n\t\tifp->if_collisions += status & IE_XS_MAXCOLL;\n\t} else {\n\t\tifp->if_oerrors++;\n\t\t/*\n\t\t * XXX\n\t\t * Check SQE and DEFERRED?\n\t\t * What if more than one bit is set?\n\t\t */\n\t\tif (status & IE_STAT_ABORT)\n\t\t\tprintf(\"%s: send aborted\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_LATECOLL)\n\t\t\tprintf(\"%s: late collision\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_NOCARRIER)\n\t\t\tprintf(\"%s: no carrier\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_LOSTCTS)\n\t\t\tprintf(\"%s: lost CTS\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_UNDERRUN)\n\t\t\tprintf(\"%s: DMA underrun\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_EXCMAX) {\n\t\t\tprintf(\"%s: too many collisions\\n\", sc->sc_dev.dv_xname);\n\t\t\tifp->if_collisions += 16;\n\t\t}\n\t}\n\n\t/*\n\t * If multicast addresses were added or deleted while transmitting,\n\t * mc_reset() set the want_mcsetup flag indicating that we should do\n\t * it.\n\t */\n\tif (sc->want_mcsetup) {\n\t\tmc_setup(sc, (caddr_t)sc->xmit_cbuffs[sc->xctail]);\n\t\tsc->want_mcsetup = 0;\n\t}\n\n\t/* Done with the buffer. */\n\tsc->xmit_busy--;\n\tsc->xctail = (sc->xctail + 1) % NTXBUF;\n\n\t/* Start the next packet, if any, transmitting. */\n\tif (sc->xmit_busy > 0)\n\t\tiexmit(sc);\n\n\tiestart(ifp);\n}"
  },
  {
    "function_name": "ierint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "909-944",
    "snippet": "void\nierint(sc)\n\tstruct ie_softc *sc;\n{\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tint i, status;\n\tstatic int timesthru = 1024;\n\n\ti = sc->rfhead;\n\tfor (;;) {\n\t\tstatus = sc->rframes[i]->ie_fd_status;\n\n\t\tif ((status & IE_FD_COMPLETE) && (status & IE_FD_OK)) {\n\t\t\tif (!--timesthru) {\n\t\t\t\tsc->sc_arpcom.ac_if.if_ierrors +=\n\t\t\t\t    scb->ie_err_crc + scb->ie_err_align +\n\t\t\t\t    scb->ie_err_resource + scb->ie_err_overrun;\n\t\t\t\tscb->ie_err_crc = scb->ie_err_align =\n\t\t\t\t    scb->ie_err_resource = scb->ie_err_overrun =\n\t\t\t\t    0;\n\t\t\t\ttimesthru = 1024;\n\t\t\t}\n\t\t\tie_readframe(sc, i);\n\t\t} else {\n\t\t\tif ((status & IE_FD_RNR) != 0 &&\n\t\t\t    (scb->ie_status & IE_RU_READY) == 0) {\n\t\t\t\tsc->rframes[0]->ie_fd_buf_desc =\n\t\t\t\t\t\tMK_16(MEM, sc->rbuffs[0]);\n\t\t\t\tscb->ie_recv_list = MK_16(MEM, sc->rframes[0]);\n\t\t\t\tcommand_and_wait(sc, IE_RU_START, 0, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\ti = (i + 1) % NFRAMES;\n\t}\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define MEM \tsc->sc_maddr",
      "#define\tNFRAMES\t\t16\t\t/* number of receive frames */"
    ],
    "globals_used": [
      "void ie_readframe",
      "static int command_and_wait",
      "void ierint",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "command_and_wait",
          "args": [
            "sc",
            "IE_RU_START",
            "0",
            "0"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "command_and_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1838-1886",
          "snippet": "static int\ncommand_and_wait(sc, cmd, pcmd, mask)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tvolatile void *pcmd;\n\tint mask;\n{\n\tvolatile struct ie_cmd_common *cc = pcmd;\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvolatile int timedout = 0;\n\textern int hz;\n\n\tscb->ie_command = (u_short)cmd;\n\n\tif (IE_ACTION_COMMAND(cmd) && pcmd) {\n\t\t(sc->chan_attn)(sc);\n\n\t\t/*\n\t\t * According to the packet driver, the minimum timeout should\n\t\t * be .369 seconds, which we round up to .4.\n\t\t */\n\t\ttimeout(chan_attn_timeout, (caddr_t)&timedout, 2 * hz / 5);\n\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, but I haven't figured out how, or indeed if, we\n\t\t * can put the process waiting for action to sleep.  (We may\n\t\t * be getting called through some other timeout running in the\n\t\t * kernel.)\n\t\t */\n\t\tfor (;;)\n\t\t\tif ((cc->ie_cmd_status & mask) || timedout)\n\t\t\t\tbreak;\n\n\t\tuntimeout(chan_attn_timeout, (caddr_t)&timedout);\n\n\t\treturn timedout;\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\t(sc->chan_attn)(sc);\n\n\t\twhile (scb->ie_command)\n\t\t\t;\t\t\t\t/* spin lock */\n\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int command_and_wait",
            "static void chan_attn_timeout",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int command_and_wait;\nstatic void chan_attn_timeout;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic int\ncommand_and_wait(sc, cmd, pcmd, mask)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tvolatile void *pcmd;\n\tint mask;\n{\n\tvolatile struct ie_cmd_common *cc = pcmd;\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tvolatile int timedout = 0;\n\textern int hz;\n\n\tscb->ie_command = (u_short)cmd;\n\n\tif (IE_ACTION_COMMAND(cmd) && pcmd) {\n\t\t(sc->chan_attn)(sc);\n\n\t\t/*\n\t\t * According to the packet driver, the minimum timeout should\n\t\t * be .369 seconds, which we round up to .4.\n\t\t */\n\t\ttimeout(chan_attn_timeout, (caddr_t)&timedout, 2 * hz / 5);\n\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, but I haven't figured out how, or indeed if, we\n\t\t * can put the process waiting for action to sleep.  (We may\n\t\t * be getting called through some other timeout running in the\n\t\t * kernel.)\n\t\t */\n\t\tfor (;;)\n\t\t\tif ((cc->ie_cmd_status & mask) || timedout)\n\t\t\t\tbreak;\n\n\t\tuntimeout(chan_attn_timeout, (caddr_t)&timedout);\n\n\t\treturn timedout;\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\t(sc->chan_attn)(sc);\n\n\t\twhile (scb->ie_command)\n\t\t\t;\t\t\t\t/* spin lock */\n\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MK_16",
          "args": [
            "MEM",
            "sc->rframes[0]"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MK_16",
          "args": [
            "MEM",
            "sc->rbuffs[0]"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ie_readframe",
          "args": [
            "sc",
            "i"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "ie_readframe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1358-1442",
          "snippet": "void\nie_readframe(sc, num)\n\tstruct ie_softc *sc;\n\tint num;\t\t\t/* frame number to read */\n{\n\tint status;\n\tstruct mbuf *m = 0;\n\tstruct ether_header eh;\n#if NBPFILTER > 0\n\tint bpf_gets_it = 0;\n#endif\n\n\tstatus = sc->rframes[num]->ie_fd_status;\n\n\t/* Advance the RFD list, since we're done with this descriptor. */\n\tsc->rframes[num]->ie_fd_status = 0;\n\tsc->rframes[num]->ie_fd_last |= IE_FD_LAST;\n\tsc->rframes[sc->rftail]->ie_fd_last &= ~IE_FD_LAST;\n\tsc->rftail = (sc->rftail + 1) % NFRAMES;\n\tsc->rfhead = (sc->rfhead + 1) % NFRAMES;\n\n\tif (status & IE_FD_OK) {\n#if NBPFILTER > 0\n\t\tm = ieget(sc, &eh, &bpf_gets_it);\n#else\n\t\tm = ieget(sc, &eh, 0);\n#endif\n\t\tie_drop_packet_buffer(sc);\n\t}\n\tif (m == 0) {\n\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\treturn;\n\t}\n\n#ifdef IEDEBUG\n\tif (sc->sc_debug & IED_READFRAME)\n\t\tprintf(\"%s: frame from ether %s type %x\\n\", sc->sc_dev.dv_xname,\n\t\t    ether_sprintf(eh.ether_shost), (u_int)eh.ether_type);\n#endif\n\n#if NBPFILTER > 0\n\t/*\n\t * Check for a BPF filter; if so, hand it up.\n\t * Note that we have to stick an extra mbuf up front, because bpf_mtap\n\t * expects to have the ether header at the front.\n\t * It doesn't matter that this results in an ill-formatted mbuf chain,\n\t * since BPF just looks at the data.  (It doesn't try to free the mbuf,\n\t * tho' it will make a copy for tcpdump.)\n\t */\n\tif (bpf_gets_it) {\n\t\tstruct mbuf m0;\n\t\tm0.m_len = sizeof eh;\n\t\tm0.m_data = (caddr_t)&eh;\n\t\tm0.m_next = m;\n\n\t\t/* Pass it up. */\n\t\tbpf_mtap(sc->sc_arpcom.ac_if.if_bpf, &m0);\n\n\t\t/*\n\t\t * A signal passed up from the filtering code indicating that\n\t\t * the packet is intended for BPF but not for the protocol\n\t\t * machinery.  We can save a few cycles by not handing it off\n\t\t * to them.\n\t\t */\n\t\tif (bpf_gets_it == 2) {\n\t\t\tm_freem(m);\n\t\t\treturn;\n\t\t}\n\t}\n#endif /* NBPFILTER > 0 */\n\n\t/*\n\t * In here there used to be code to check destination addresses upon\n\t * receipt of a packet.  We have deleted that code, and replaced it\n\t * with code to check the address much earlier in the cycle, before\n\t * copying the data in; this saves us valuable cycles when operating\n\t * as a multicast router or when using BPF.\n\t */\n\n\t/*\n\t * Finally pass this packet up to higher layers.\n\t */\n\tether_input(&sc->sc_arpcom.ac_if, &eh, m);\n\tsc->sc_arpcom.ac_if.if_ipackets++;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tNFRAMES\t\t16\t\t/* number of receive frames */",
            "#define\tIED_READFRAME\t0x10"
          ],
          "globals_used": [
            "void ie_readframe",
            "void ie_drop_packet_buffer",
            "struct mbuf *ieget",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tNFRAMES\t\t16\t\t/* number of receive frames */\n#define\tIED_READFRAME\t0x10\n\nvoid ie_readframe;\nvoid ie_drop_packet_buffer;\nstruct mbuf *ieget;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nie_readframe(sc, num)\n\tstruct ie_softc *sc;\n\tint num;\t\t\t/* frame number to read */\n{\n\tint status;\n\tstruct mbuf *m = 0;\n\tstruct ether_header eh;\n#if NBPFILTER > 0\n\tint bpf_gets_it = 0;\n#endif\n\n\tstatus = sc->rframes[num]->ie_fd_status;\n\n\t/* Advance the RFD list, since we're done with this descriptor. */\n\tsc->rframes[num]->ie_fd_status = 0;\n\tsc->rframes[num]->ie_fd_last |= IE_FD_LAST;\n\tsc->rframes[sc->rftail]->ie_fd_last &= ~IE_FD_LAST;\n\tsc->rftail = (sc->rftail + 1) % NFRAMES;\n\tsc->rfhead = (sc->rfhead + 1) % NFRAMES;\n\n\tif (status & IE_FD_OK) {\n#if NBPFILTER > 0\n\t\tm = ieget(sc, &eh, &bpf_gets_it);\n#else\n\t\tm = ieget(sc, &eh, 0);\n#endif\n\t\tie_drop_packet_buffer(sc);\n\t}\n\tif (m == 0) {\n\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\treturn;\n\t}\n\n#ifdef IEDEBUG\n\tif (sc->sc_debug & IED_READFRAME)\n\t\tprintf(\"%s: frame from ether %s type %x\\n\", sc->sc_dev.dv_xname,\n\t\t    ether_sprintf(eh.ether_shost), (u_int)eh.ether_type);\n#endif\n\n#if NBPFILTER > 0\n\t/*\n\t * Check for a BPF filter; if so, hand it up.\n\t * Note that we have to stick an extra mbuf up front, because bpf_mtap\n\t * expects to have the ether header at the front.\n\t * It doesn't matter that this results in an ill-formatted mbuf chain,\n\t * since BPF just looks at the data.  (It doesn't try to free the mbuf,\n\t * tho' it will make a copy for tcpdump.)\n\t */\n\tif (bpf_gets_it) {\n\t\tstruct mbuf m0;\n\t\tm0.m_len = sizeof eh;\n\t\tm0.m_data = (caddr_t)&eh;\n\t\tm0.m_next = m;\n\n\t\t/* Pass it up. */\n\t\tbpf_mtap(sc->sc_arpcom.ac_if.if_bpf, &m0);\n\n\t\t/*\n\t\t * A signal passed up from the filtering code indicating that\n\t\t * the packet is intended for BPF but not for the protocol\n\t\t * machinery.  We can save a few cycles by not handing it off\n\t\t * to them.\n\t\t */\n\t\tif (bpf_gets_it == 2) {\n\t\t\tm_freem(m);\n\t\t\treturn;\n\t\t}\n\t}\n#endif /* NBPFILTER > 0 */\n\n\t/*\n\t * In here there used to be code to check destination addresses upon\n\t * receipt of a packet.  We have deleted that code, and replaced it\n\t * with code to check the address much earlier in the cycle, before\n\t * copying the data in; this saves us valuable cycles when operating\n\t * as a multicast router or when using BPF.\n\t */\n\n\t/*\n\t * Finally pass this packet up to higher layers.\n\t */\n\tether_input(&sc->sc_arpcom.ac_if, &eh, m);\n\tsc->sc_arpcom.ac_if.if_ipackets++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define MEM \tsc->sc_maddr\n#define\tNFRAMES\t\t16\t\t/* number of receive frames */\n\nvoid ie_readframe;\nstatic int command_and_wait;\nvoid ierint;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nierint(sc)\n\tstruct ie_softc *sc;\n{\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tint i, status;\n\tstatic int timesthru = 1024;\n\n\ti = sc->rfhead;\n\tfor (;;) {\n\t\tstatus = sc->rframes[i]->ie_fd_status;\n\n\t\tif ((status & IE_FD_COMPLETE) && (status & IE_FD_OK)) {\n\t\t\tif (!--timesthru) {\n\t\t\t\tsc->sc_arpcom.ac_if.if_ierrors +=\n\t\t\t\t    scb->ie_err_crc + scb->ie_err_align +\n\t\t\t\t    scb->ie_err_resource + scb->ie_err_overrun;\n\t\t\t\tscb->ie_err_crc = scb->ie_err_align =\n\t\t\t\t    scb->ie_err_resource = scb->ie_err_overrun =\n\t\t\t\t    0;\n\t\t\t\ttimesthru = 1024;\n\t\t\t}\n\t\t\tie_readframe(sc, i);\n\t\t} else {\n\t\t\tif ((status & IE_FD_RNR) != 0 &&\n\t\t\t    (scb->ie_status & IE_RU_READY) == 0) {\n\t\t\t\tsc->rframes[0]->ie_fd_buf_desc =\n\t\t\t\t\t\tMK_16(MEM, sc->rbuffs[0]);\n\t\t\t\tscb->ie_recv_list = MK_16(MEM, sc->rframes[0]);\n\t\t\t\tcommand_and_wait(sc, IE_RU_START, 0, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\ti = (i + 1) % NFRAMES;\n\t}\n}"
  },
  {
    "function_name": "ieintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "833-904",
    "snippet": "int\nieintr(arg)\n\tvoid *arg;\n{\n\tstruct ie_softc *sc = arg;\n\tregister u_short status;\n\n\t/* Clear the interrupt latch on the 3C507. */\n\tif (sc->hard_type == IE_3C507)\n\t\toutb(PORT + IE507_ICTRL, 1);\n\n\t/* disable interrupts on the EE16. */\n\tif (sc->hard_type == IE_EE16)\n\t\toutb(PORT + IEE16_IRQ, sc->irq_encoded);\n\n\tstatus = sc->scb->ie_status & IE_ST_WHENCE;\n\tif (status == 0)\n\t\treturn 0;\n\nloop:\n\t/* Ack interrupts FIRST in case we receive more during the ISR. */\n\tie_ack(sc, status);\n\n\tif (status & (IE_ST_FR | IE_ST_RNR)) {\n#ifdef IEDEBUG\n\t\tin_ierint++;\n\t\tif (sc->sc_debug & IED_RINT)\n\t\t\tprintf(\"%s: rint\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\tierint(sc);\n#ifdef IEDEBUG\n\t\tin_ierint--;\n#endif\n\t}\n\n\tif (status & IE_ST_CX) {\n#ifdef IEDEBUG\n\t\tin_ietint++;\n\t\tif (sc->sc_debug & IED_TINT)\n\t\t\tprintf(\"%s: tint\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\tietint(sc);\n#ifdef IEDEBUG\n\t\tin_ietint--;\n#endif\n\t}\n\n\tif (status & IE_ST_RNR) {\n\t\tprintf(\"%s: receiver not ready\\n\", sc->sc_dev.dv_xname);\n\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\tiereset(sc);\n\t}\n\n#ifdef IEDEBUG\n\tif ((status & IE_ST_CNA) && (sc->sc_debug & IED_CNA))\n\t\tprintf(\"%s: cna\\n\", sc->sc_dev.dv_xname);\n#endif\n\n\t/* Clear the interrupt latch on the 3C507. */\n\tif (sc->hard_type == IE_3C507)\n\t\toutb(PORT + IE507_ICTRL, 1);\n\n\tstatus = sc->scb->ie_status & IE_ST_WHENCE;\n\tif (status == 0) {\n\t\t/* enable interrupts on the EE16. */\n\t\tif (sc->hard_type == IE_EE16)\n\t\t    outb(PORT + IEE16_IRQ, sc->irq_encoded | IEE16_IRQ_ENABLE);\n\t\treturn 1;\n\t}\n\n\tgoto loop;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define PORT\tsc->sc_iobase",
      "#define\tIED_CNA\t\t0x08",
      "#define\tIED_TINT\t0x02",
      "#define\tIED_RINT\t0x01"
    ],
    "globals_used": [
      "int ieintr",
      "void iereset",
      "void ierint",
      "void ietint",
      "static __inline void ie_ack",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "PORT + IEE16_IRQ",
            "sc->irq_encoded | IEE16_IRQ_ENABLE"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: cna\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iereset",
          "args": [
            "sc"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "iereset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1797-1817",
          "snippet": "void\niereset(sc)\n\tstruct ie_softc *sc;\n{\n\tint s = splnet();\n\n\tiestop(sc);\n\n\t/*\n\t * Stop i82586 dead in its tracks.\n\t */\n\tif (command_and_wait(sc, IE_RU_ABORT | IE_CU_ABORT, 0, 0))\n\t\tprintf(\"%s: abort commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\tif (command_and_wait(sc, IE_RU_DISABLE | IE_CU_STOP, 0, 0))\n\t\tprintf(\"%s: disable commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\tieinit(sc);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void iestop",
            "int ieinit",
            "void iereset",
            "static int command_and_wait",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iestop;\nint ieinit;\nvoid iereset;\nstatic int command_and_wait;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\niereset(sc)\n\tstruct ie_softc *sc;\n{\n\tint s = splnet();\n\n\tiestop(sc);\n\n\t/*\n\t * Stop i82586 dead in its tracks.\n\t */\n\tif (command_and_wait(sc, IE_RU_ABORT | IE_CU_ABORT, 0, 0))\n\t\tprintf(\"%s: abort commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\tif (command_and_wait(sc, IE_RU_DISABLE | IE_CU_STOP, 0, 0))\n\t\tprintf(\"%s: disable commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\tieinit(sc);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ietint",
          "args": [
            "sc"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "ietint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "951-1011",
          "snippet": "void\nietint(sc)\n\tstruct ie_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint status;\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tstatus = sc->xmit_cmds[sc->xctail]->ie_xmit_status;\n\n\tif (!(status & IE_STAT_COMPL) || (status & IE_STAT_BUSY))\n\t\tprintf(\"ietint: command still busy!\\n\");\n\n\tif (status & IE_STAT_OK) {\n\t\tifp->if_opackets++;\n\t\tifp->if_collisions += status & IE_XS_MAXCOLL;\n\t} else {\n\t\tifp->if_oerrors++;\n\t\t/*\n\t\t * XXX\n\t\t * Check SQE and DEFERRED?\n\t\t * What if more than one bit is set?\n\t\t */\n\t\tif (status & IE_STAT_ABORT)\n\t\t\tprintf(\"%s: send aborted\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_LATECOLL)\n\t\t\tprintf(\"%s: late collision\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_NOCARRIER)\n\t\t\tprintf(\"%s: no carrier\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_LOSTCTS)\n\t\t\tprintf(\"%s: lost CTS\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_UNDERRUN)\n\t\t\tprintf(\"%s: DMA underrun\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_EXCMAX) {\n\t\t\tprintf(\"%s: too many collisions\\n\", sc->sc_dev.dv_xname);\n\t\t\tifp->if_collisions += 16;\n\t\t}\n\t}\n\n\t/*\n\t * If multicast addresses were added or deleted while transmitting,\n\t * mc_reset() set the want_mcsetup flag indicating that we should do\n\t * it.\n\t */\n\tif (sc->want_mcsetup) {\n\t\tmc_setup(sc, (caddr_t)sc->xmit_cbuffs[sc->xctail]);\n\t\tsc->want_mcsetup = 0;\n\t}\n\n\t/* Done with the buffer. */\n\tsc->xmit_busy--;\n\tsc->xctail = (sc->xctail + 1) % NTXBUF;\n\n\t/* Start the next packet, if any, transmitting. */\n\tif (sc->xmit_busy > 0)\n\t\tiexmit(sc);\n\n\tiestart(ifp);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tNTXBUF\t\t2\t\t/* number of transmit commands */"
          ],
          "globals_used": [
            "void iestart",
            "void ietint",
            "void iexmit",
            "static int mc_setup",
            "static void mc_reset",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tNTXBUF\t\t2\t\t/* number of transmit commands */\n\nvoid iestart;\nvoid ietint;\nvoid iexmit;\nstatic int mc_setup;\nstatic void mc_reset;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nietint(sc)\n\tstruct ie_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint status;\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tstatus = sc->xmit_cmds[sc->xctail]->ie_xmit_status;\n\n\tif (!(status & IE_STAT_COMPL) || (status & IE_STAT_BUSY))\n\t\tprintf(\"ietint: command still busy!\\n\");\n\n\tif (status & IE_STAT_OK) {\n\t\tifp->if_opackets++;\n\t\tifp->if_collisions += status & IE_XS_MAXCOLL;\n\t} else {\n\t\tifp->if_oerrors++;\n\t\t/*\n\t\t * XXX\n\t\t * Check SQE and DEFERRED?\n\t\t * What if more than one bit is set?\n\t\t */\n\t\tif (status & IE_STAT_ABORT)\n\t\t\tprintf(\"%s: send aborted\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_LATECOLL)\n\t\t\tprintf(\"%s: late collision\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_NOCARRIER)\n\t\t\tprintf(\"%s: no carrier\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_LOSTCTS)\n\t\t\tprintf(\"%s: lost CTS\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_UNDERRUN)\n\t\t\tprintf(\"%s: DMA underrun\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_EXCMAX) {\n\t\t\tprintf(\"%s: too many collisions\\n\", sc->sc_dev.dv_xname);\n\t\t\tifp->if_collisions += 16;\n\t\t}\n\t}\n\n\t/*\n\t * If multicast addresses were added or deleted while transmitting,\n\t * mc_reset() set the want_mcsetup flag indicating that we should do\n\t * it.\n\t */\n\tif (sc->want_mcsetup) {\n\t\tmc_setup(sc, (caddr_t)sc->xmit_cbuffs[sc->xctail]);\n\t\tsc->want_mcsetup = 0;\n\t}\n\n\t/* Done with the buffer. */\n\tsc->xmit_busy--;\n\tsc->xctail = (sc->xctail + 1) % NTXBUF;\n\n\t/* Start the next packet, if any, transmitting. */\n\tif (sc->xmit_busy > 0)\n\t\tiexmit(sc);\n\n\tiestart(ifp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ierint",
          "args": [
            "sc"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "ierint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "909-944",
          "snippet": "void\nierint(sc)\n\tstruct ie_softc *sc;\n{\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tint i, status;\n\tstatic int timesthru = 1024;\n\n\ti = sc->rfhead;\n\tfor (;;) {\n\t\tstatus = sc->rframes[i]->ie_fd_status;\n\n\t\tif ((status & IE_FD_COMPLETE) && (status & IE_FD_OK)) {\n\t\t\tif (!--timesthru) {\n\t\t\t\tsc->sc_arpcom.ac_if.if_ierrors +=\n\t\t\t\t    scb->ie_err_crc + scb->ie_err_align +\n\t\t\t\t    scb->ie_err_resource + scb->ie_err_overrun;\n\t\t\t\tscb->ie_err_crc = scb->ie_err_align =\n\t\t\t\t    scb->ie_err_resource = scb->ie_err_overrun =\n\t\t\t\t    0;\n\t\t\t\ttimesthru = 1024;\n\t\t\t}\n\t\t\tie_readframe(sc, i);\n\t\t} else {\n\t\t\tif ((status & IE_FD_RNR) != 0 &&\n\t\t\t    (scb->ie_status & IE_RU_READY) == 0) {\n\t\t\t\tsc->rframes[0]->ie_fd_buf_desc =\n\t\t\t\t\t\tMK_16(MEM, sc->rbuffs[0]);\n\t\t\t\tscb->ie_recv_list = MK_16(MEM, sc->rframes[0]);\n\t\t\t\tcommand_and_wait(sc, IE_RU_START, 0, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\ti = (i + 1) % NFRAMES;\n\t}\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define MEM \tsc->sc_maddr",
            "#define\tNFRAMES\t\t16\t\t/* number of receive frames */"
          ],
          "globals_used": [
            "void ie_readframe",
            "static int command_and_wait",
            "void ierint",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define MEM \tsc->sc_maddr\n#define\tNFRAMES\t\t16\t\t/* number of receive frames */\n\nvoid ie_readframe;\nstatic int command_and_wait;\nvoid ierint;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nierint(sc)\n\tstruct ie_softc *sc;\n{\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\tint i, status;\n\tstatic int timesthru = 1024;\n\n\ti = sc->rfhead;\n\tfor (;;) {\n\t\tstatus = sc->rframes[i]->ie_fd_status;\n\n\t\tif ((status & IE_FD_COMPLETE) && (status & IE_FD_OK)) {\n\t\t\tif (!--timesthru) {\n\t\t\t\tsc->sc_arpcom.ac_if.if_ierrors +=\n\t\t\t\t    scb->ie_err_crc + scb->ie_err_align +\n\t\t\t\t    scb->ie_err_resource + scb->ie_err_overrun;\n\t\t\t\tscb->ie_err_crc = scb->ie_err_align =\n\t\t\t\t    scb->ie_err_resource = scb->ie_err_overrun =\n\t\t\t\t    0;\n\t\t\t\ttimesthru = 1024;\n\t\t\t}\n\t\t\tie_readframe(sc, i);\n\t\t} else {\n\t\t\tif ((status & IE_FD_RNR) != 0 &&\n\t\t\t    (scb->ie_status & IE_RU_READY) == 0) {\n\t\t\t\tsc->rframes[0]->ie_fd_buf_desc =\n\t\t\t\t\t\tMK_16(MEM, sc->rbuffs[0]);\n\t\t\t\tscb->ie_recv_list = MK_16(MEM, sc->rframes[0]);\n\t\t\t\tcommand_and_wait(sc, IE_RU_START, 0, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\ti = (i + 1) % NFRAMES;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ie_ack",
          "args": [
            "sc",
            "status"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "ie_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "364-376",
          "snippet": "static __inline void\nie_ack(sc, mask)\n\tstruct ie_softc *sc;\n\tu_int mask;\n{\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\n\tscb->ie_command = scb->ie_status & mask;\n\t(sc->chan_attn)(sc);\n\n\twhile (scb->ie_command)\n\t\t;\t\t/* Spin Lock */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void ie_ack",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline void ie_ack;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic __inline void\nie_ack(sc, mask)\n\tstruct ie_softc *sc;\n\tu_int mask;\n{\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\n\tscb->ie_command = scb->ie_status & mask;\n\t(sc->chan_attn)(sc);\n\n\twhile (scb->ie_command)\n\t\t;\t\t/* Spin Lock */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n#define\tIED_CNA\t\t0x08\n#define\tIED_TINT\t0x02\n#define\tIED_RINT\t0x01\n\nint ieintr;\nvoid iereset;\nvoid ierint;\nvoid ietint;\nstatic __inline void ie_ack;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nieintr(arg)\n\tvoid *arg;\n{\n\tstruct ie_softc *sc = arg;\n\tregister u_short status;\n\n\t/* Clear the interrupt latch on the 3C507. */\n\tif (sc->hard_type == IE_3C507)\n\t\toutb(PORT + IE507_ICTRL, 1);\n\n\t/* disable interrupts on the EE16. */\n\tif (sc->hard_type == IE_EE16)\n\t\toutb(PORT + IEE16_IRQ, sc->irq_encoded);\n\n\tstatus = sc->scb->ie_status & IE_ST_WHENCE;\n\tif (status == 0)\n\t\treturn 0;\n\nloop:\n\t/* Ack interrupts FIRST in case we receive more during the ISR. */\n\tie_ack(sc, status);\n\n\tif (status & (IE_ST_FR | IE_ST_RNR)) {\n#ifdef IEDEBUG\n\t\tin_ierint++;\n\t\tif (sc->sc_debug & IED_RINT)\n\t\t\tprintf(\"%s: rint\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\tierint(sc);\n#ifdef IEDEBUG\n\t\tin_ierint--;\n#endif\n\t}\n\n\tif (status & IE_ST_CX) {\n#ifdef IEDEBUG\n\t\tin_ietint++;\n\t\tif (sc->sc_debug & IED_TINT)\n\t\t\tprintf(\"%s: tint\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\tietint(sc);\n#ifdef IEDEBUG\n\t\tin_ietint--;\n#endif\n\t}\n\n\tif (status & IE_ST_RNR) {\n\t\tprintf(\"%s: receiver not ready\\n\", sc->sc_dev.dv_xname);\n\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\tiereset(sc);\n\t}\n\n#ifdef IEDEBUG\n\tif ((status & IE_ST_CNA) && (sc->sc_debug & IED_CNA))\n\t\tprintf(\"%s: cna\\n\", sc->sc_dev.dv_xname);\n#endif\n\n\t/* Clear the interrupt latch on the 3C507. */\n\tif (sc->hard_type == IE_3C507)\n\t\toutb(PORT + IE507_ICTRL, 1);\n\n\tstatus = sc->scb->ie_status & IE_ST_WHENCE;\n\tif (status == 0) {\n\t\t/* enable interrupts on the EE16. */\n\t\tif (sc->hard_type == IE_EE16)\n\t\t    outb(PORT + IEE16_IRQ, sc->irq_encoded | IEE16_IRQ_ENABLE);\n\t\treturn 1;\n\t}\n\n\tgoto loop;\n}"
  },
  {
    "function_name": "iewatchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "819-828",
    "snippet": "void\niewatchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ie_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++sc->sc_arpcom.ac_if.if_oerrors;\n\tiereset(sc);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void iewatchdog",
      "void iereset",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iereset",
          "args": [
            "sc"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "iereset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1797-1817",
          "snippet": "void\niereset(sc)\n\tstruct ie_softc *sc;\n{\n\tint s = splnet();\n\n\tiestop(sc);\n\n\t/*\n\t * Stop i82586 dead in its tracks.\n\t */\n\tif (command_and_wait(sc, IE_RU_ABORT | IE_CU_ABORT, 0, 0))\n\t\tprintf(\"%s: abort commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\tif (command_and_wait(sc, IE_RU_DISABLE | IE_CU_STOP, 0, 0))\n\t\tprintf(\"%s: disable commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\tieinit(sc);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void iestop",
            "int ieinit",
            "void iereset",
            "static int command_and_wait",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iestop;\nint ieinit;\nvoid iereset;\nstatic int command_and_wait;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\niereset(sc)\n\tstruct ie_softc *sc;\n{\n\tint s = splnet();\n\n\tiestop(sc);\n\n\t/*\n\t * Stop i82586 dead in its tracks.\n\t */\n\tif (command_and_wait(sc, IE_RU_ABORT | IE_CU_ABORT, 0, 0))\n\t\tprintf(\"%s: abort commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\tif (command_and_wait(sc, IE_RU_DISABLE | IE_CU_STOP, 0, 0))\n\t\tprintf(\"%s: disable commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\tieinit(sc);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: device timeout\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iewatchdog;\nvoid iereset;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\niewatchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ie_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++sc->sc_arpcom.ac_if.if_oerrors;\n\tiereset(sc);\n}"
  },
  {
    "function_name": "ieattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "781-813",
    "snippet": "void\nieattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct ie_softc *sc = (void *)self;\n\tstruct isa_attach_args *ia = aux;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = iestart;\n\tifp->if_ioctl = ieioctl;\n\tifp->if_watchdog = iewatchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n\tprintf(\": address %s, type %s R%d\\n\",\n\t    ether_sprintf(sc->sc_arpcom.ac_enaddr),\n\t    ie_hardware_names[sc->hard_type], sc->hard_vers + 1);\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t    sizeof(struct ether_header));\n#endif\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_NET, ieintr, sc, sc->sc_dev.dv_xname);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const char *ie_hardware_names[] = {\n\t\"StarLAN 10\",\n\t\"EN100\",\n\t\"StarLAN Fiber\",\n\t\"3C507\",\n\t\"EtherExpress 16\",\n\t\"Unknown\"\n};",
      "void iewatchdog",
      "int ieintr",
      "int ieioctl",
      "void iestart",
      "void\tieattach",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "ia->ia_irq",
            "IST_EDGE",
            "IPL_NET",
            "ieintr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&sc->sc_arpcom.ac_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": address %s, type %s R%d\\n\"",
            "ether_sprintf(sc->sc_arpcom.ac_enaddr)",
            "ie_hardware_names[sc->hard_type]",
            "sc->hard_vers + 1"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->sc_arpcom.ac_enaddr"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nconst char *ie_hardware_names[] = {\n\t\"StarLAN 10\",\n\t\"EN100\",\n\t\"StarLAN Fiber\",\n\t\"3C507\",\n\t\"EtherExpress 16\",\n\t\"Unknown\"\n};\nvoid iewatchdog;\nint ieintr;\nint ieioctl;\nvoid iestart;\nvoid\tieattach;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nieattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct ie_softc *sc = (void *)self;\n\tstruct isa_attach_args *ia = aux;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = iestart;\n\tifp->if_ioctl = ieioctl;\n\tifp->if_watchdog = iewatchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n\tprintf(\": address %s, type %s R%d\\n\",\n\t    ether_sprintf(sc->sc_arpcom.ac_enaddr),\n\t    ie_hardware_names[sc->hard_type], sc->hard_vers + 1);\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t    sizeof(struct ether_header));\n#endif\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_NET, ieintr, sc, sc->sc_dev.dv_xname);\n}"
  },
  {
    "function_name": "ee16_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "581-776",
    "snippet": "int\nee16_probe(sc, ia)\n\tstruct ie_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tint i;\n\tu_short board_id, id_var1, id_var2, checksum = 0;\n\tu_short eaddrtemp, irq;\n        u_short pg, adjust, decode, edecode;\n\tu_char\tbart_config;\n\n\tshort\tirq_translate[] = {0, 0x09, 0x03, 0x04, 0x05, 0x0a, 0x0b, 0};\n\n\t/* Need this for part of the probe. */\n\tsc->reset_586 = ee16_reset_586;\n\tsc->chan_attn = ee16_chan_attn;\n\n\t/* reset any ee16 at the current iobase */\n\toutb(ia->ia_iobase + IEE16_ECTRL, IEE16_RESET_ASIC);\n\toutb(ia->ia_iobase + IEE16_ECTRL, 0);\n\tdelay(240);\n\n\t/* now look for ee16. */\n\tboard_id = id_var1 = id_var2 = 0;\n\tfor (i=0; i<4 ; i++) {\n\t\tid_var1 = inb(ia->ia_iobase + IEE16_ID_PORT);\n\t\tid_var2 = ((id_var1 & 0x03) << 2);\n\t\tboard_id |= (( id_var1 >> 4)  << id_var2);\n\t\t}\n\n\tif (board_id != IEE16_ID)\n\t\treturn 0;\t\t\n\n\t/* need sc->sc_iobase for ee16_read_eeprom */\n\tsc->sc_iobase = ia->ia_iobase;\n\tsc->hard_type = IE_EE16;\n\n\t/*\n\t * If ia->maddr == MADDRUNK, use value in eeprom location 6.\n\t *\n\t * The shared RAM location on the EE16 is encoded into bits\n\t * 3-7 of EEPROM location 6.  We zero the upper byte, and \n\t * shift the 5 bits right 3.  The resulting number tells us\n\t * the RAM location.  Because the EE16 supports either 16k or 32k\n\t * of shared RAM, we only worry about the 32k locations. \n\t *\n\t * NOTE: if a 64k EE16 exists, it should be added to this switch.\n\t *       then the ia->ia_msize would need to be set per case statement.\n\t *\n\t *\tvalue\tmsize\tlocation\n\t *\t=====\t=====\t========\n\t *\t0x03\t0x8000\t0xCC000\n\t *\t0x06\t0x8000\t0xD0000\n\t *\t0x0C\t0x8000\t0xD4000\n\t *\t0x18\t0x8000\t0xD8000\n\t *\n\t */ \n\n\tif ((ia->ia_maddr == MADDRUNK) || (ia->ia_msize == 0)) {\n\t\ti = (ee16_read_eeprom(sc, 6) & 0x00ff ) >> 3;\n\t\tswitch(i) {\n\t\t\tcase 0x03:\n\t\t\t\tia->ia_maddr = 0xCC000;\n\t\t\t\tbreak;\n\t\t\tcase 0x06:\n\t\t\t\tia->ia_maddr = 0xD0000;\n\t\t\t\tbreak;\n\t\t\tcase 0x0c:\n\t\t\t\tia->ia_maddr = 0xD4000;\n\t\t\t\tbreak;\n\t\t\tcase 0x18:\n\t\t\t\tia->ia_maddr = 0xD8000;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn 0 ;\n\t\t\t\tbreak; /* NOTREACHED */\n\t\t}\n\t\tia->ia_msize = 0x8000; \n\t}\n\n\t/* need to set these after checking for MADDRUNK */\n\tsc->sc_maddr = ISA_HOLE_VADDR(ia->ia_maddr);\n\tsc->sc_msize = ia->ia_msize; \n\n\t/* need to put the 586 in RESET, and leave it */\n\toutb( PORT + IEE16_ECTRL, IEE16_RESET_586);  \n\n\t/* read the eeprom and checksum it, should == IEE16_ID */\n\tfor(i=0 ; i< 0x40 ; i++)\n\t\tchecksum += ee16_read_eeprom(sc, i);\n\n\tif (checksum != IEE16_ID)\n\t\treturn 0;\t\n\n\t/*\n\t * Size and test the memory on the board.  The size of the memory\n\t * can be one of 16k, 32k, 48k or 64k.  It can be located in the\n\t * address range 0xC0000 to 0xEFFFF on 16k boundaries. \n\t *\n\t * If the size does not match the passed in memory allocation size\n\t * issue a warning, but continue with the minimum of the two sizes.\n\t */\n\n\tswitch (ia->ia_msize) {\n\t\tcase 65536:\n\t\tcase 32768: /* XXX Only support 32k and 64k right now */\n\t\t\tbreak;\n\t\tcase 16384:\n\t\tcase 49512:\n\t\tdefault:\n\t\t\tprintf(\"ieprobe mapped memory size out of range\\n\");\n\t\t\treturn 0;\n\t\t\tbreak; /* NOTREACHED */\n\t}\n\n\tif ((kvtop(sc->sc_maddr) < 0xC0000) ||\n\t    (kvtop(sc->sc_maddr) + sc->sc_msize > 0xF0000)) {\n\t\tprintf(\"ieprobe mapped memory address out of range\\n\");\n\t\treturn 0;\n\t}\n\n\tpg = (kvtop(sc->sc_maddr) & 0x3C000) >> 14;\n\tadjust = IEE16_MCTRL_FMCS16 | (pg & 0x3) << 2;\n\tdecode = ((1 << (sc->sc_msize / 16384)) - 1) << pg;\n\tedecode = ((~decode >> 4) & 0xF0) | (decode >> 8);\n\n\t/* ZZZ This should be checked against eeprom location 6, low byte */\n\toutb(PORT + IEE16_MEMDEC, decode & 0xFF);\n\t/* ZZZ This should be checked against eeprom location 1, low byte */\n\toutb(PORT + IEE16_MCTRL, adjust);\n\t/* ZZZ Now if I could find this one I would have it made */\n\toutb(PORT + IEE16_MPCTRL, (~decode & 0xFF));\n\t/* ZZZ I think this is location 6, high byte */\n\toutb(PORT + IEE16_MECTRL, edecode); /*XXX disable Exxx */\n\n\t/*\n\t * first prime the stupid bart DRAM controller so that it\n\t * works, then zero out all of memory.\n\t */\n\tbzero(sc->sc_maddr, 32);\n\tbzero(sc->sc_maddr, sc->sc_msize);\n\n\t/*\n\t * Get the encoded interrupt number from the EEPROM, check it\n\t * against the passed in IRQ.  Issue a warning if they do not\n\t * match, and fail the probe.  If irq is 'IRQUNK' then we\n\t * use the EEPROM irq, and continue.\n\t */\n\tirq = ee16_read_eeprom(sc, IEE16_EEPROM_CONFIG1);\n\tirq = (irq & IEE16_EEPROM_IRQ) >> IEE16_EEPROM_IRQ_SHIFT;\n\tsc->irq_encoded = irq;\n\tirq = irq_translate[irq];\n\tif (ia->ia_irq != IRQUNK) {\n\t\tif (irq != ia->ia_irq) {\n#ifdef DIAGNOSTIC\n\t\t\tprintf(\"\\nie%d: fatal: board IRQ %d does not match kernel\\n\", sc->sc_dev.dv_unit, irq);\n#endif /* DIAGNOSTIC */\n\t\t\treturn 0; \t/* _must_ match or probe fails */\n\t\t}\n\t} else\n\t\tia->ia_irq = irq;\n\n\t/*\n\t * Get the hardware ethernet address from the EEPROM and\n\t * save it in the softc for use by the 586 setup code.\n\t */\n\teaddrtemp = ee16_read_eeprom(sc, IEE16_EEPROM_ENET_HIGH);\n\tsc->sc_arpcom.ac_enaddr[1] = eaddrtemp & 0xFF;\n\tsc->sc_arpcom.ac_enaddr[0] = eaddrtemp >> 8;\n\teaddrtemp = ee16_read_eeprom(sc, IEE16_EEPROM_ENET_MID);\n\tsc->sc_arpcom.ac_enaddr[3] = eaddrtemp & 0xFF;\n\tsc->sc_arpcom.ac_enaddr[2] = eaddrtemp >> 8;\n\teaddrtemp = ee16_read_eeprom(sc, IEE16_EEPROM_ENET_LOW);\n\tsc->sc_arpcom.ac_enaddr[5] = eaddrtemp & 0xFF;\n\tsc->sc_arpcom.ac_enaddr[4] = eaddrtemp >> 8;\n\n\t/* disable the board interrupts */\n\toutb(PORT + IEE16_IRQ, sc->irq_encoded);\n\n\t/* enable loopback to keep bad packets off the wire */\n\tif(sc->hard_type == IE_EE16) {\n\t\tbart_config = inb(PORT + IEE16_CONFIG);\n\t\tbart_config |= IEE16_BART_LOOPBACK;\n\t\tbart_config |= IEE16_BART_MCS16_TEST; /* inb doesn't get bit! */\n\t\toutb(PORT + IEE16_CONFIG, bart_config);\n\t\tbart_config = inb(PORT + IEE16_CONFIG);\n\t}\n\n\toutb(PORT + IEE16_ECTRL, 0);\n\tdelay(100);\n\tif (!check_ie_present(sc, sc->sc_maddr, sc->sc_msize))\n\t\treturn 0;\n\n\tia->ia_iosize = 16;\t/* the number of I/O ports */\n\treturn 1;\t\t/* found */\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define PORT\tsc->sc_iobase"
    ],
    "globals_used": [
      "static void ee16_reset_586",
      "static void ee16_chan_attn",
      "u_short ee16_read_eeprom",
      "int\tieprobe",
      "int\tee16_probe",
      "int\tcheck_ie_present",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_ie_present",
          "args": [
            "sc",
            "sc->sc_maddr",
            "sc->sc_msize"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "check_ie_present",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1538-1621",
          "snippet": "int\ncheck_ie_present(sc, where, size)\n\tstruct ie_softc *sc;\n\tcaddr_t where;\n\tu_int size;\n{\n\tvolatile struct ie_sys_conf_ptr *scp;\n\tvolatile struct ie_int_sys_conf_ptr *iscp;\n\tvolatile struct ie_sys_ctl_block *scb;\n\tu_long realbase;\n\tint s;\n\n\ts = splnet();\n\n\trealbase = (u_long)where + size - (1 << 24);\n\n\tscp = (volatile struct ie_sys_conf_ptr *)(realbase + IE_SCP_ADDR);\n\tbzero((char *)scp, sizeof *scp);\n\n\t/*\n\t * First we put the ISCP at the bottom of memory; this tests to make\n\t * sure that our idea of the size of memory is the same as the\n\t * controller's.  This is NOT where the ISCP will be in normal\n\t * operation.\n\t */\n\tiscp = (volatile struct ie_int_sys_conf_ptr *)where;\n\tbzero((char *)iscp, sizeof *iscp);\n\n\tscb = (volatile struct ie_sys_ctl_block *)where;\n\tbzero((char *)scb, sizeof *scb);\n\n\tscp->ie_bus_use = 0;\t\t/* 16-bit */\n\tscp->ie_iscp_ptr = (caddr_t)((volatile caddr_t)iscp -\n\t    (volatile caddr_t)realbase);\n\n\tiscp->ie_busy = 1;\n\tiscp->ie_scb_offset = MK_16(realbase, scb) + 256;\n\n\t(sc->reset_586)(sc);\n\t(sc->chan_attn)(sc);\n\n\tdelay(100);\t\t\t/* wait a while... */\n\n\tif (iscp->ie_busy) {\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Now relocate the ISCP to its real home, and reset the controller\n\t * again.\n\t */\n\tiscp = (void *)ALIGN(realbase + IE_SCP_ADDR - sizeof(*iscp));\n\tbzero((char *)iscp, sizeof *iscp);\n\n\tscp->ie_iscp_ptr = (caddr_t)((caddr_t)iscp - (caddr_t)realbase);\n\n\tiscp->ie_busy = 1;\n\tiscp->ie_scb_offset = MK_16(realbase, scb);\n\n\t(sc->reset_586)(sc);\n\t(sc->chan_attn)(sc);\n\n\tdelay(100);\n\n\tif (iscp->ie_busy) {\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\n\tsc->sc_msize = size;\n\tsc->sc_maddr = (caddr_t)realbase;\n\n\tsc->iscp = iscp;\n\tsc->scb = scb;\n\n\t/*\n\t * Acknowledge any interrupts we may have caused...\n\t */\n\tie_ack(sc, IE_ST_WHENCE);\n\tsplx(s);\n\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tcheck_ie_present",
            "static __inline void ie_ack",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tcheck_ie_present;\nstatic __inline void ie_ack;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\ncheck_ie_present(sc, where, size)\n\tstruct ie_softc *sc;\n\tcaddr_t where;\n\tu_int size;\n{\n\tvolatile struct ie_sys_conf_ptr *scp;\n\tvolatile struct ie_int_sys_conf_ptr *iscp;\n\tvolatile struct ie_sys_ctl_block *scb;\n\tu_long realbase;\n\tint s;\n\n\ts = splnet();\n\n\trealbase = (u_long)where + size - (1 << 24);\n\n\tscp = (volatile struct ie_sys_conf_ptr *)(realbase + IE_SCP_ADDR);\n\tbzero((char *)scp, sizeof *scp);\n\n\t/*\n\t * First we put the ISCP at the bottom of memory; this tests to make\n\t * sure that our idea of the size of memory is the same as the\n\t * controller's.  This is NOT where the ISCP will be in normal\n\t * operation.\n\t */\n\tiscp = (volatile struct ie_int_sys_conf_ptr *)where;\n\tbzero((char *)iscp, sizeof *iscp);\n\n\tscb = (volatile struct ie_sys_ctl_block *)where;\n\tbzero((char *)scb, sizeof *scb);\n\n\tscp->ie_bus_use = 0;\t\t/* 16-bit */\n\tscp->ie_iscp_ptr = (caddr_t)((volatile caddr_t)iscp -\n\t    (volatile caddr_t)realbase);\n\n\tiscp->ie_busy = 1;\n\tiscp->ie_scb_offset = MK_16(realbase, scb) + 256;\n\n\t(sc->reset_586)(sc);\n\t(sc->chan_attn)(sc);\n\n\tdelay(100);\t\t\t/* wait a while... */\n\n\tif (iscp->ie_busy) {\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Now relocate the ISCP to its real home, and reset the controller\n\t * again.\n\t */\n\tiscp = (void *)ALIGN(realbase + IE_SCP_ADDR - sizeof(*iscp));\n\tbzero((char *)iscp, sizeof *iscp);\n\n\tscp->ie_iscp_ptr = (caddr_t)((caddr_t)iscp - (caddr_t)realbase);\n\n\tiscp->ie_busy = 1;\n\tiscp->ie_scb_offset = MK_16(realbase, scb);\n\n\t(sc->reset_586)(sc);\n\t(sc->chan_attn)(sc);\n\n\tdelay(100);\n\n\tif (iscp->ie_busy) {\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\n\tsc->sc_msize = size;\n\tsc->sc_maddr = (caddr_t)realbase;\n\n\tsc->iscp = iscp;\n\tsc->scb = scb;\n\n\t/*\n\t * Acknowledge any interrupts we may have caused...\n\t */\n\tie_ack(sc, IE_ST_WHENCE);\n\tsplx(s);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "PORT + IEE16_ECTRL",
            "0"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "PORT + IEE16_CONFIG"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee16_read_eeprom",
          "args": [
            "sc",
            "IEE16_EEPROM_ENET_LOW"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_read_eeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1695-1716",
          "snippet": "u_short\nee16_read_eeprom(sc, location)\n\tstruct ie_softc *sc;\n\tint location;\n{\n\tint ectrl, edata;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= IEE16_ECTRL_MASK;\n\tectrl |= IEE16_ECTRL_EECS;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\n\tee16_eeprom_outbits(sc, IEE16_EEPROM_READ, IEE16_EEPROM_OPSIZE1);\n\tee16_eeprom_outbits(sc, location, IEE16_EEPROM_ADDR_SIZE);\n\tedata = ee16_eeprom_inbits(sc);\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~(IEE16_RESET_ASIC | IEE16_ECTRL_EEDI | IEE16_ECTRL_EECS);\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tee16_eeprom_clock(sc, 1);\n\tee16_eeprom_clock(sc, 0);\n\treturn edata;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "u_short ee16_read_eeprom",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nu_short ee16_read_eeprom;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nu_short\nee16_read_eeprom(sc, location)\n\tstruct ie_softc *sc;\n\tint location;\n{\n\tint ectrl, edata;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= IEE16_ECTRL_MASK;\n\tectrl |= IEE16_ECTRL_EECS;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\n\tee16_eeprom_outbits(sc, IEE16_EEPROM_READ, IEE16_EEPROM_OPSIZE1);\n\tee16_eeprom_outbits(sc, location, IEE16_EEPROM_ADDR_SIZE);\n\tedata = ee16_eeprom_inbits(sc);\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~(IEE16_RESET_ASIC | IEE16_ECTRL_EEDI | IEE16_ECTRL_EECS);\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tee16_eeprom_clock(sc, 1);\n\tee16_eeprom_clock(sc, 0);\n\treturn edata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nie%d: fatal: board IRQ %d does not match kernel\\n\"",
            "sc->sc_dev.dv_unit",
            "irq"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->sc_maddr",
            "sc->sc_msize"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->sc_maddr",
            "32"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvtop",
          "args": [
            "sc->sc_maddr"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvtop",
          "args": [
            "sc->sc_maddr"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvtop",
          "args": [
            "sc->sc_maddr"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_HOLE_VADDR",
          "args": [
            "ia->ia_maddr"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nstatic void ee16_reset_586;\nstatic void ee16_chan_attn;\nu_short ee16_read_eeprom;\nint\tieprobe;\nint\tee16_probe;\nint\tcheck_ie_present;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_probe(sc, ia)\n\tstruct ie_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tint i;\n\tu_short board_id, id_var1, id_var2, checksum = 0;\n\tu_short eaddrtemp, irq;\n        u_short pg, adjust, decode, edecode;\n\tu_char\tbart_config;\n\n\tshort\tirq_translate[] = {0, 0x09, 0x03, 0x04, 0x05, 0x0a, 0x0b, 0};\n\n\t/* Need this for part of the probe. */\n\tsc->reset_586 = ee16_reset_586;\n\tsc->chan_attn = ee16_chan_attn;\n\n\t/* reset any ee16 at the current iobase */\n\toutb(ia->ia_iobase + IEE16_ECTRL, IEE16_RESET_ASIC);\n\toutb(ia->ia_iobase + IEE16_ECTRL, 0);\n\tdelay(240);\n\n\t/* now look for ee16. */\n\tboard_id = id_var1 = id_var2 = 0;\n\tfor (i=0; i<4 ; i++) {\n\t\tid_var1 = inb(ia->ia_iobase + IEE16_ID_PORT);\n\t\tid_var2 = ((id_var1 & 0x03) << 2);\n\t\tboard_id |= (( id_var1 >> 4)  << id_var2);\n\t\t}\n\n\tif (board_id != IEE16_ID)\n\t\treturn 0;\t\t\n\n\t/* need sc->sc_iobase for ee16_read_eeprom */\n\tsc->sc_iobase = ia->ia_iobase;\n\tsc->hard_type = IE_EE16;\n\n\t/*\n\t * If ia->maddr == MADDRUNK, use value in eeprom location 6.\n\t *\n\t * The shared RAM location on the EE16 is encoded into bits\n\t * 3-7 of EEPROM location 6.  We zero the upper byte, and \n\t * shift the 5 bits right 3.  The resulting number tells us\n\t * the RAM location.  Because the EE16 supports either 16k or 32k\n\t * of shared RAM, we only worry about the 32k locations. \n\t *\n\t * NOTE: if a 64k EE16 exists, it should be added to this switch.\n\t *       then the ia->ia_msize would need to be set per case statement.\n\t *\n\t *\tvalue\tmsize\tlocation\n\t *\t=====\t=====\t========\n\t *\t0x03\t0x8000\t0xCC000\n\t *\t0x06\t0x8000\t0xD0000\n\t *\t0x0C\t0x8000\t0xD4000\n\t *\t0x18\t0x8000\t0xD8000\n\t *\n\t */ \n\n\tif ((ia->ia_maddr == MADDRUNK) || (ia->ia_msize == 0)) {\n\t\ti = (ee16_read_eeprom(sc, 6) & 0x00ff ) >> 3;\n\t\tswitch(i) {\n\t\t\tcase 0x03:\n\t\t\t\tia->ia_maddr = 0xCC000;\n\t\t\t\tbreak;\n\t\t\tcase 0x06:\n\t\t\t\tia->ia_maddr = 0xD0000;\n\t\t\t\tbreak;\n\t\t\tcase 0x0c:\n\t\t\t\tia->ia_maddr = 0xD4000;\n\t\t\t\tbreak;\n\t\t\tcase 0x18:\n\t\t\t\tia->ia_maddr = 0xD8000;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn 0 ;\n\t\t\t\tbreak; /* NOTREACHED */\n\t\t}\n\t\tia->ia_msize = 0x8000; \n\t}\n\n\t/* need to set these after checking for MADDRUNK */\n\tsc->sc_maddr = ISA_HOLE_VADDR(ia->ia_maddr);\n\tsc->sc_msize = ia->ia_msize; \n\n\t/* need to put the 586 in RESET, and leave it */\n\toutb( PORT + IEE16_ECTRL, IEE16_RESET_586);  \n\n\t/* read the eeprom and checksum it, should == IEE16_ID */\n\tfor(i=0 ; i< 0x40 ; i++)\n\t\tchecksum += ee16_read_eeprom(sc, i);\n\n\tif (checksum != IEE16_ID)\n\t\treturn 0;\t\n\n\t/*\n\t * Size and test the memory on the board.  The size of the memory\n\t * can be one of 16k, 32k, 48k or 64k.  It can be located in the\n\t * address range 0xC0000 to 0xEFFFF on 16k boundaries. \n\t *\n\t * If the size does not match the passed in memory allocation size\n\t * issue a warning, but continue with the minimum of the two sizes.\n\t */\n\n\tswitch (ia->ia_msize) {\n\t\tcase 65536:\n\t\tcase 32768: /* XXX Only support 32k and 64k right now */\n\t\t\tbreak;\n\t\tcase 16384:\n\t\tcase 49512:\n\t\tdefault:\n\t\t\tprintf(\"ieprobe mapped memory size out of range\\n\");\n\t\t\treturn 0;\n\t\t\tbreak; /* NOTREACHED */\n\t}\n\n\tif ((kvtop(sc->sc_maddr) < 0xC0000) ||\n\t    (kvtop(sc->sc_maddr) + sc->sc_msize > 0xF0000)) {\n\t\tprintf(\"ieprobe mapped memory address out of range\\n\");\n\t\treturn 0;\n\t}\n\n\tpg = (kvtop(sc->sc_maddr) & 0x3C000) >> 14;\n\tadjust = IEE16_MCTRL_FMCS16 | (pg & 0x3) << 2;\n\tdecode = ((1 << (sc->sc_msize / 16384)) - 1) << pg;\n\tedecode = ((~decode >> 4) & 0xF0) | (decode >> 8);\n\n\t/* ZZZ This should be checked against eeprom location 6, low byte */\n\toutb(PORT + IEE16_MEMDEC, decode & 0xFF);\n\t/* ZZZ This should be checked against eeprom location 1, low byte */\n\toutb(PORT + IEE16_MCTRL, adjust);\n\t/* ZZZ Now if I could find this one I would have it made */\n\toutb(PORT + IEE16_MPCTRL, (~decode & 0xFF));\n\t/* ZZZ I think this is location 6, high byte */\n\toutb(PORT + IEE16_MECTRL, edecode); /*XXX disable Exxx */\n\n\t/*\n\t * first prime the stupid bart DRAM controller so that it\n\t * works, then zero out all of memory.\n\t */\n\tbzero(sc->sc_maddr, 32);\n\tbzero(sc->sc_maddr, sc->sc_msize);\n\n\t/*\n\t * Get the encoded interrupt number from the EEPROM, check it\n\t * against the passed in IRQ.  Issue a warning if they do not\n\t * match, and fail the probe.  If irq is 'IRQUNK' then we\n\t * use the EEPROM irq, and continue.\n\t */\n\tirq = ee16_read_eeprom(sc, IEE16_EEPROM_CONFIG1);\n\tirq = (irq & IEE16_EEPROM_IRQ) >> IEE16_EEPROM_IRQ_SHIFT;\n\tsc->irq_encoded = irq;\n\tirq = irq_translate[irq];\n\tif (ia->ia_irq != IRQUNK) {\n\t\tif (irq != ia->ia_irq) {\n#ifdef DIAGNOSTIC\n\t\t\tprintf(\"\\nie%d: fatal: board IRQ %d does not match kernel\\n\", sc->sc_dev.dv_unit, irq);\n#endif /* DIAGNOSTIC */\n\t\t\treturn 0; \t/* _must_ match or probe fails */\n\t\t}\n\t} else\n\t\tia->ia_irq = irq;\n\n\t/*\n\t * Get the hardware ethernet address from the EEPROM and\n\t * save it in the softc for use by the 586 setup code.\n\t */\n\teaddrtemp = ee16_read_eeprom(sc, IEE16_EEPROM_ENET_HIGH);\n\tsc->sc_arpcom.ac_enaddr[1] = eaddrtemp & 0xFF;\n\tsc->sc_arpcom.ac_enaddr[0] = eaddrtemp >> 8;\n\teaddrtemp = ee16_read_eeprom(sc, IEE16_EEPROM_ENET_MID);\n\tsc->sc_arpcom.ac_enaddr[3] = eaddrtemp & 0xFF;\n\tsc->sc_arpcom.ac_enaddr[2] = eaddrtemp >> 8;\n\teaddrtemp = ee16_read_eeprom(sc, IEE16_EEPROM_ENET_LOW);\n\tsc->sc_arpcom.ac_enaddr[5] = eaddrtemp & 0xFF;\n\tsc->sc_arpcom.ac_enaddr[4] = eaddrtemp >> 8;\n\n\t/* disable the board interrupts */\n\toutb(PORT + IEE16_IRQ, sc->irq_encoded);\n\n\t/* enable loopback to keep bad packets off the wire */\n\tif(sc->hard_type == IE_EE16) {\n\t\tbart_config = inb(PORT + IEE16_CONFIG);\n\t\tbart_config |= IEE16_BART_LOOPBACK;\n\t\tbart_config |= IEE16_BART_MCS16_TEST; /* inb doesn't get bit! */\n\t\toutb(PORT + IEE16_CONFIG, bart_config);\n\t\tbart_config = inb(PORT + IEE16_CONFIG);\n\t}\n\n\toutb(PORT + IEE16_ECTRL, 0);\n\tdelay(100);\n\tif (!check_ie_present(sc, sc->sc_maddr, sc->sc_msize))\n\t\treturn 0;\n\n\tia->ia_iosize = 16;\t/* the number of I/O ports */\n\treturn 1;\t\t/* found */\n}"
  },
  {
    "function_name": "el_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "462-577",
    "snippet": "int\nel_probe(sc, ia)\n\tstruct ie_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tu_char c;\n\tint i, rval = 0;\n\tu_char signature[] = \"*3COM*\";\n\n\tsc->sc_iobase = ia->ia_iobase;\n\n\t/* Need this for part of the probe. */\n\tsc->reset_586 = el_reset_586;\n\tsc->chan_attn = el_chan_attn;\n\n\t/*\n\t * Map the Etherlink ID port for the probe sequence.\n\t */\n\tif (bus_space_map(iot, ELINK_ID_PORT, 1, 0, &ioh)) {\n\t\tprintf(\"3c507 probe: can't map Etherlink ID port\\n\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Reset and put card in CONFIG state without changing address.\n\t * XXX Indirect brokenness here!\n\t */\n\telink_reset(iot, ioh, sc->sc_dev.dv_parent->dv_unit);\n\telink_idseq(iot, ioh, ELINK_507_POLY);\n\telink_idseq(iot, ioh, ELINK_507_POLY);\n\toutb(ELINK_ID_PORT, 0xff);\n\n\t/* Check for 3COM signature before proceeding. */\n\toutb(PORT + IE507_CTRL, inb(PORT + IE507_CTRL) & 0xfc);\t/* XXX */\n\tfor (i = 0; i < 6; i++)\n\t\tif (inb(PORT + i) != signature[i])\n\t\t\tgoto out;\n\n\tc = inb(PORT + IE507_MADDR);\n\tif (c & 0x20) {\n\t\tprintf(\"%s: can't map 3C507 RAM in high memory\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto out;\n\t}\n\n\t/* Go to RUN state. */\n\toutb(ELINK_ID_PORT, 0x00);\n\telink_idseq(iot, ioh, ELINK_507_POLY);\n\toutb(ELINK_ID_PORT, 0x00);\n\n\t/* Set bank 2 for version info and read BCD version byte. */\n\toutb(PORT + IE507_CTRL, EL_CTRL_NRST | EL_CTRL_BNK2);\n\ti = inb(PORT + 3);\n\n\tsc->hard_type = IE_3C507;\n\tsc->hard_vers = 10*(i / 16) + (i % 16) - 1;\n\n\ti = inb(PORT + IE507_IRQ) & 0x0f;\n\n\tif (ia->ia_irq != IRQUNK) {\n\t\tif (ia->ia_irq != i) {\n\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq, i);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tia->ia_irq = i;\n\n\ti = ((inb(PORT + IE507_MADDR) & 0x1c) << 12) + 0xc0000;\n\n\tif (ia->ia_maddr != MADDRUNK) {\n\t\tif (ia->ia_maddr != i) {\n\t\t\tprintf(\"%s: maddr mismatch; kernel configured %x != board configured %x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ia->ia_maddr, i);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tia->ia_maddr = i;\n\n\toutb(PORT + IE507_CTRL, EL_CTRL_NORMAL);\n\n\t/*\n\t * Divine memory size on-board the card.\n\t */\n\tsc->sc_maddr = ISA_HOLE_VADDR(ia->ia_maddr);\n\tie_find_mem_size(sc);\n\n\tif (!sc->sc_msize) {\n\t\tprintf(\"%s: can't find shared memory\\n\", sc->sc_dev.dv_xname);\n\t\toutb(PORT + IE507_CTRL, EL_CTRL_NRST);\n\t\tgoto out;\n\t}\n\n\tif (!ia->ia_msize)\n\t\tia->ia_msize = sc->sc_msize;\n\telse if (ia->ia_msize != sc->sc_msize) {\n\t\tprintf(\"%s: msize mismatch; kernel configured %d != board configured %d\\n\",\n\t\t    sc->sc_dev.dv_xname, ia->ia_msize, sc->sc_msize);\n\t\toutb(PORT + IE507_CTRL, EL_CTRL_NRST);\n\t\tgoto out;\n\t}\n\n\tslel_get_address(sc);\n\n\t/* Clear the interrupt latch just in case. */\n\toutb(PORT + IE507_ICTRL, 1);\n\n\tia->ia_iosize = 16;\n\trval = 1;\n\n out:\n\tbus_space_unmap(iot, ioh, 1);\n\treturn rval;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define PORT\tsc->sc_iobase"
    ],
    "globals_used": [
      "static void el_reset_586",
      "static void el_chan_attn",
      "static void slel_get_address",
      "void ie_find_mem_size",
      "int\tel_probe",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh",
            "1"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "PORT + IE507_ICTRL",
            "1"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "slel_get_address",
          "args": [
            "sc"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "slel_get_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1786-1795",
          "snippet": "void\nslel_get_address(sc)\n\tstruct ie_softc *sc;\n{\n\tu_char *addr = sc->sc_arpcom.ac_enaddr;\n\tint i;\n\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\taddr[i] = inb(PORT + i);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase",
            "#define\tETHER_ADDR_LEN\t6"
          ],
          "globals_used": [
            "static void slel_get_address",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n#define\tETHER_ADDR_LEN\t6\n\nstatic void slel_get_address;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nslel_get_address(sc)\n\tstruct ie_softc *sc;\n{\n\tu_char *addr = sc->sc_arpcom.ac_enaddr;\n\tint i;\n\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\taddr[i] = inb(PORT + i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: msize mismatch; kernel configured %d != board configured %d\\n\"",
            "sc->sc_dev.dv_xname",
            "ia->ia_msize",
            "sc->sc_msize"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ie_find_mem_size",
          "args": [
            "sc"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "ie_find_mem_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1627-1640",
          "snippet": "void\nie_find_mem_size(sc)\n\tstruct ie_softc *sc;\n{\n\tu_int size;\n\n\tsc->sc_msize = 0;\n\n\tfor (size = 65536; size >= 16384; size -= 16384)\n\t\tif (check_ie_present(sc, sc->sc_maddr, size))\n\t\t\treturn;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ie_find_mem_size",
            "int\tcheck_ie_present",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ie_find_mem_size;\nint\tcheck_ie_present;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nie_find_mem_size(sc)\n\tstruct ie_softc *sc;\n{\n\tu_int size;\n\n\tsc->sc_msize = 0;\n\n\tfor (size = 65536; size >= 16384; size -= 16384)\n\t\tif (check_ie_present(sc, sc->sc_maddr, size))\n\t\t\treturn;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISA_HOLE_VADDR",
          "args": [
            "ia->ia_maddr"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "PORT + IE507_MADDR"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elink_idseq",
          "args": [
            "iot",
            "ioh",
            "ELINK_507_POLY"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "elink_idseq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/elink.c",
          "lines": "111-129",
          "snippet": "void\nelink_idseq(iot, ioh, p)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tregister u_char p;\n{\n\tregister int i;\n\tregister u_char c;\n\n\tc = 0xff;\n\tfor (i = 255; i; i--) {\n\t\tbus_space_write_1(iot, ioh, 0, c);\n\t\tif (c & 0x80) {\n\t\t\tc <<= 1;\n\t\t\tc ^= p;\n\t\t} else\n\t\t\tc <<= 1;\n\t}\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nelink_idseq(iot, ioh, p)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tregister u_char p;\n{\n\tregister int i;\n\tregister u_char c;\n\n\tc = 0xff;\n\tfor (i = 255; i; i--) {\n\t\tbus_space_write_1(iot, ioh, 0, c);\n\t\tif (c & 0x80) {\n\t\t\tc <<= 1;\n\t\t\tc ^= p;\n\t\t} else\n\t\t\tc <<= 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elink_reset",
          "args": [
            "iot",
            "ioh",
            "sc->sc_dev.dv_parent->dv_unit"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "elink_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/elink.c",
          "lines": "67-103",
          "snippet": "void\nelink_reset(iot, ioh, bus)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint bus;\n{\n\tstruct elink_done_reset *er;\n\n\tif (elink_all_resets_initialized == 0) {\n\t\tLIST_INIT(&elink_all_resets);\n\t\telink_all_resets_initialized = 1;\n\t}\n\n\t/*\n\t * Reset these cards if we haven't done so already.\n\t */\n\tfor (er = elink_all_resets.lh_first; er != NULL;\n\t    er = er->er_link.le_next)\n\t\tif (er->er_bus == bus)\n\t\t\tgoto out;\n\n\t/* Mark this bus so we don't do it again. */\n\ter = (struct elink_done_reset *)malloc(sizeof(struct elink_done_reset),\n\t    M_DEVBUF, M_NOWAIT);\n\tif (er == NULL)\n\t\tpanic(\"elink_reset: can't allocate state storage\");\n\n\ter->er_bus = bus;\n\tLIST_INSERT_HEAD(&elink_all_resets, er, er_link);\n\n\t/* Haven't reset the cards on this bus, yet. */\n\tbus_space_write_1(iot, ioh, 0, ELINK_RESET);\n\n out:\n\tbus_space_write_1(iot, ioh, 0, 0x00);\n\tbus_space_write_1(iot, ioh, 0, 0x00);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(, elink_done_reset) elink_all_resets;",
            "static int elink_all_resets_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic LIST_HEAD(, elink_done_reset) elink_all_resets;\nstatic int elink_all_resets_initialized;\n\nvoid\nelink_reset(iot, ioh, bus)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint bus;\n{\n\tstruct elink_done_reset *er;\n\n\tif (elink_all_resets_initialized == 0) {\n\t\tLIST_INIT(&elink_all_resets);\n\t\telink_all_resets_initialized = 1;\n\t}\n\n\t/*\n\t * Reset these cards if we haven't done so already.\n\t */\n\tfor (er = elink_all_resets.lh_first; er != NULL;\n\t    er = er->er_link.le_next)\n\t\tif (er->er_bus == bus)\n\t\t\tgoto out;\n\n\t/* Mark this bus so we don't do it again. */\n\ter = (struct elink_done_reset *)malloc(sizeof(struct elink_done_reset),\n\t    M_DEVBUF, M_NOWAIT);\n\tif (er == NULL)\n\t\tpanic(\"elink_reset: can't allocate state storage\");\n\n\ter->er_bus = bus;\n\tLIST_INSERT_HEAD(&elink_all_resets, er, er_link);\n\n\t/* Haven't reset the cards on this bus, yet. */\n\tbus_space_write_1(iot, ioh, 0, ELINK_RESET);\n\n out:\n\tbus_space_write_1(iot, ioh, 0, 0x00);\n\tbus_space_write_1(iot, ioh, 0, 0x00);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "ELINK_ID_PORT",
            "1",
            "0",
            "&ioh"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nstatic void el_reset_586;\nstatic void el_chan_attn;\nstatic void slel_get_address;\nvoid ie_find_mem_size;\nint\tel_probe;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nel_probe(sc, ia)\n\tstruct ie_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tu_char c;\n\tint i, rval = 0;\n\tu_char signature[] = \"*3COM*\";\n\n\tsc->sc_iobase = ia->ia_iobase;\n\n\t/* Need this for part of the probe. */\n\tsc->reset_586 = el_reset_586;\n\tsc->chan_attn = el_chan_attn;\n\n\t/*\n\t * Map the Etherlink ID port for the probe sequence.\n\t */\n\tif (bus_space_map(iot, ELINK_ID_PORT, 1, 0, &ioh)) {\n\t\tprintf(\"3c507 probe: can't map Etherlink ID port\\n\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Reset and put card in CONFIG state without changing address.\n\t * XXX Indirect brokenness here!\n\t */\n\telink_reset(iot, ioh, sc->sc_dev.dv_parent->dv_unit);\n\telink_idseq(iot, ioh, ELINK_507_POLY);\n\telink_idseq(iot, ioh, ELINK_507_POLY);\n\toutb(ELINK_ID_PORT, 0xff);\n\n\t/* Check for 3COM signature before proceeding. */\n\toutb(PORT + IE507_CTRL, inb(PORT + IE507_CTRL) & 0xfc);\t/* XXX */\n\tfor (i = 0; i < 6; i++)\n\t\tif (inb(PORT + i) != signature[i])\n\t\t\tgoto out;\n\n\tc = inb(PORT + IE507_MADDR);\n\tif (c & 0x20) {\n\t\tprintf(\"%s: can't map 3C507 RAM in high memory\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto out;\n\t}\n\n\t/* Go to RUN state. */\n\toutb(ELINK_ID_PORT, 0x00);\n\telink_idseq(iot, ioh, ELINK_507_POLY);\n\toutb(ELINK_ID_PORT, 0x00);\n\n\t/* Set bank 2 for version info and read BCD version byte. */\n\toutb(PORT + IE507_CTRL, EL_CTRL_NRST | EL_CTRL_BNK2);\n\ti = inb(PORT + 3);\n\n\tsc->hard_type = IE_3C507;\n\tsc->hard_vers = 10*(i / 16) + (i % 16) - 1;\n\n\ti = inb(PORT + IE507_IRQ) & 0x0f;\n\n\tif (ia->ia_irq != IRQUNK) {\n\t\tif (ia->ia_irq != i) {\n\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq, i);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tia->ia_irq = i;\n\n\ti = ((inb(PORT + IE507_MADDR) & 0x1c) << 12) + 0xc0000;\n\n\tif (ia->ia_maddr != MADDRUNK) {\n\t\tif (ia->ia_maddr != i) {\n\t\t\tprintf(\"%s: maddr mismatch; kernel configured %x != board configured %x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ia->ia_maddr, i);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tia->ia_maddr = i;\n\n\toutb(PORT + IE507_CTRL, EL_CTRL_NORMAL);\n\n\t/*\n\t * Divine memory size on-board the card.\n\t */\n\tsc->sc_maddr = ISA_HOLE_VADDR(ia->ia_maddr);\n\tie_find_mem_size(sc);\n\n\tif (!sc->sc_msize) {\n\t\tprintf(\"%s: can't find shared memory\\n\", sc->sc_dev.dv_xname);\n\t\toutb(PORT + IE507_CTRL, EL_CTRL_NRST);\n\t\tgoto out;\n\t}\n\n\tif (!ia->ia_msize)\n\t\tia->ia_msize = sc->sc_msize;\n\telse if (ia->ia_msize != sc->sc_msize) {\n\t\tprintf(\"%s: msize mismatch; kernel configured %d != board configured %d\\n\",\n\t\t    sc->sc_dev.dv_xname, ia->ia_msize, sc->sc_msize);\n\t\toutb(PORT + IE507_CTRL, EL_CTRL_NRST);\n\t\tgoto out;\n\t}\n\n\tslel_get_address(sc);\n\n\t/* Clear the interrupt latch just in case. */\n\toutb(PORT + IE507_ICTRL, 1);\n\n\tia->ia_iosize = 16;\n\trval = 1;\n\n out:\n\tbus_space_unmap(iot, ioh, 1);\n\treturn rval;\n}"
  },
  {
    "function_name": "sl_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "395-460",
    "snippet": "int\nsl_probe(sc, ia)\n\tstruct ie_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tu_char c;\n\n\tsc->sc_iobase = ia->ia_iobase;\n\n\t/* Need this for part of the probe. */\n\tsc->reset_586 = sl_reset_586;\n\tsc->chan_attn = sl_chan_attn;\n\n\tc = inb(PORT + IEATT_REVISION);\n\tswitch (SL_BOARD(c)) {\n\tcase SL10_BOARD:\n\t\tsc->hard_type = IE_STARLAN10;\n\t\tbreak;\n\tcase EN100_BOARD:\n\t\tsc->hard_type = IE_EN100;\n\t\tbreak;\n\tcase SLFIBER_BOARD:\n\t\tsc->hard_type = IE_SLFIBER;\n\t\tbreak;\n\n\tdefault:\n\t\t/* Anything else is not recognized or cannot be used. */\n#if 0\n\t\tprintf(\"%s: unknown AT&T board type code %d\\n\",\n\t\t    sc->sc_dev.dv_xname, SL_BOARD(c));\n#endif\n\t\treturn 0;\n\t}\n\n\tsc->hard_vers = SL_REV(c);\n\n\tif (ia->ia_irq == IRQUNK || ia->ia_maddr == MADDRUNK) {\n\t\tprintf(\"%s: %s does not have soft configuration\\n\",\n\t\t    sc->sc_dev.dv_xname, ie_hardware_names[sc->hard_type]);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Divine memory size on-board the card.  Ususally 16k.\n\t */\n\tsc->sc_maddr = ISA_HOLE_VADDR(ia->ia_maddr);\n\tie_find_mem_size(sc);\n\n\tif (!sc->sc_msize) {\n\t\tprintf(\"%s: can't find shared memory\\n\", sc->sc_dev.dv_xname);\n\t\treturn 0;\n\t}\n\n\tif (!ia->ia_msize)\n\t\tia->ia_msize = sc->sc_msize;\n\telse if (ia->ia_msize != sc->sc_msize) {\n\t\tprintf(\"%s: msize mismatch; kernel configured %d != board configured %d\\n\",\n\t\t    sc->sc_dev.dv_xname, ia->ia_msize, sc->sc_msize);\n\t\treturn 0;\n\t}\n\n\tslel_get_address(sc);\n\n\tia->ia_iosize = 16;\n\treturn 1;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define PORT\tsc->sc_iobase"
    ],
    "globals_used": [
      "const char *ie_hardware_names[] = {\n\t\"StarLAN 10\",\n\t\"EN100\",\n\t\"StarLAN Fiber\",\n\t\"3C507\",\n\t\"EtherExpress 16\",\n\t\"Unknown\"\n};",
      "static void sl_reset_586",
      "static void sl_chan_attn",
      "static void slel_get_address",
      "void ie_find_mem_size",
      "int\tsl_probe",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slel_get_address",
          "args": [
            "sc"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "slel_get_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1786-1795",
          "snippet": "void\nslel_get_address(sc)\n\tstruct ie_softc *sc;\n{\n\tu_char *addr = sc->sc_arpcom.ac_enaddr;\n\tint i;\n\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\taddr[i] = inb(PORT + i);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase",
            "#define\tETHER_ADDR_LEN\t6"
          ],
          "globals_used": [
            "static void slel_get_address",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n#define\tETHER_ADDR_LEN\t6\n\nstatic void slel_get_address;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nslel_get_address(sc)\n\tstruct ie_softc *sc;\n{\n\tu_char *addr = sc->sc_arpcom.ac_enaddr;\n\tint i;\n\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\taddr[i] = inb(PORT + i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: msize mismatch; kernel configured %d != board configured %d\\n\"",
            "sc->sc_dev.dv_xname",
            "ia->ia_msize",
            "sc->sc_msize"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ie_find_mem_size",
          "args": [
            "sc"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "ie_find_mem_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1627-1640",
          "snippet": "void\nie_find_mem_size(sc)\n\tstruct ie_softc *sc;\n{\n\tu_int size;\n\n\tsc->sc_msize = 0;\n\n\tfor (size = 65536; size >= 16384; size -= 16384)\n\t\tif (check_ie_present(sc, sc->sc_maddr, size))\n\t\t\treturn;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ie_find_mem_size",
            "int\tcheck_ie_present",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ie_find_mem_size;\nint\tcheck_ie_present;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nie_find_mem_size(sc)\n\tstruct ie_softc *sc;\n{\n\tu_int size;\n\n\tsc->sc_msize = 0;\n\n\tfor (size = 65536; size >= 16384; size -= 16384)\n\t\tif (check_ie_present(sc, sc->sc_maddr, size))\n\t\t\treturn;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISA_HOLE_VADDR",
          "args": [
            "ia->ia_maddr"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SL_REV",
          "args": [
            "c"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SL_BOARD",
          "args": [
            "c"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SL_BOARD",
          "args": [
            "c"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "PORT + IEATT_REVISION"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nconst char *ie_hardware_names[] = {\n\t\"StarLAN 10\",\n\t\"EN100\",\n\t\"StarLAN Fiber\",\n\t\"3C507\",\n\t\"EtherExpress 16\",\n\t\"Unknown\"\n};\nstatic void sl_reset_586;\nstatic void sl_chan_attn;\nstatic void slel_get_address;\nvoid ie_find_mem_size;\nint\tsl_probe;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nsl_probe(sc, ia)\n\tstruct ie_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tu_char c;\n\n\tsc->sc_iobase = ia->ia_iobase;\n\n\t/* Need this for part of the probe. */\n\tsc->reset_586 = sl_reset_586;\n\tsc->chan_attn = sl_chan_attn;\n\n\tc = inb(PORT + IEATT_REVISION);\n\tswitch (SL_BOARD(c)) {\n\tcase SL10_BOARD:\n\t\tsc->hard_type = IE_STARLAN10;\n\t\tbreak;\n\tcase EN100_BOARD:\n\t\tsc->hard_type = IE_EN100;\n\t\tbreak;\n\tcase SLFIBER_BOARD:\n\t\tsc->hard_type = IE_SLFIBER;\n\t\tbreak;\n\n\tdefault:\n\t\t/* Anything else is not recognized or cannot be used. */\n#if 0\n\t\tprintf(\"%s: unknown AT&T board type code %d\\n\",\n\t\t    sc->sc_dev.dv_xname, SL_BOARD(c));\n#endif\n\t\treturn 0;\n\t}\n\n\tsc->hard_vers = SL_REV(c);\n\n\tif (ia->ia_irq == IRQUNK || ia->ia_maddr == MADDRUNK) {\n\t\tprintf(\"%s: %s does not have soft configuration\\n\",\n\t\t    sc->sc_dev.dv_xname, ie_hardware_names[sc->hard_type]);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Divine memory size on-board the card.  Ususally 16k.\n\t */\n\tsc->sc_maddr = ISA_HOLE_VADDR(ia->ia_maddr);\n\tie_find_mem_size(sc);\n\n\tif (!sc->sc_msize) {\n\t\tprintf(\"%s: can't find shared memory\\n\", sc->sc_dev.dv_xname);\n\t\treturn 0;\n\t}\n\n\tif (!ia->ia_msize)\n\t\tia->ia_msize = sc->sc_msize;\n\telse if (ia->ia_msize != sc->sc_msize) {\n\t\tprintf(\"%s: msize mismatch; kernel configured %d != board configured %d\\n\",\n\t\t    sc->sc_dev.dv_xname, ia->ia_msize, sc->sc_msize);\n\t\treturn 0;\n\t}\n\n\tslel_get_address(sc);\n\n\tia->ia_iosize = 16;\n\treturn 1;\n}"
  },
  {
    "function_name": "ieprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "378-393",
    "snippet": "int\nieprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct ie_softc *sc = match;\n\tstruct isa_attach_args *ia = aux;\n\n\tif (sl_probe(sc, ia))\n\t\treturn 1;\n\tif (el_probe(sc, ia))\n\t\treturn 1;\n\tif (ee16_probe(sc, ia))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tieprobe",
      "int\tsl_probe",
      "int\tel_probe",
      "int\tee16_probe",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ee16_probe",
          "args": [
            "sc",
            "ia"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "581-776",
          "snippet": "int\nee16_probe(sc, ia)\n\tstruct ie_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tint i;\n\tu_short board_id, id_var1, id_var2, checksum = 0;\n\tu_short eaddrtemp, irq;\n        u_short pg, adjust, decode, edecode;\n\tu_char\tbart_config;\n\n\tshort\tirq_translate[] = {0, 0x09, 0x03, 0x04, 0x05, 0x0a, 0x0b, 0};\n\n\t/* Need this for part of the probe. */\n\tsc->reset_586 = ee16_reset_586;\n\tsc->chan_attn = ee16_chan_attn;\n\n\t/* reset any ee16 at the current iobase */\n\toutb(ia->ia_iobase + IEE16_ECTRL, IEE16_RESET_ASIC);\n\toutb(ia->ia_iobase + IEE16_ECTRL, 0);\n\tdelay(240);\n\n\t/* now look for ee16. */\n\tboard_id = id_var1 = id_var2 = 0;\n\tfor (i=0; i<4 ; i++) {\n\t\tid_var1 = inb(ia->ia_iobase + IEE16_ID_PORT);\n\t\tid_var2 = ((id_var1 & 0x03) << 2);\n\t\tboard_id |= (( id_var1 >> 4)  << id_var2);\n\t\t}\n\n\tif (board_id != IEE16_ID)\n\t\treturn 0;\t\t\n\n\t/* need sc->sc_iobase for ee16_read_eeprom */\n\tsc->sc_iobase = ia->ia_iobase;\n\tsc->hard_type = IE_EE16;\n\n\t/*\n\t * If ia->maddr == MADDRUNK, use value in eeprom location 6.\n\t *\n\t * The shared RAM location on the EE16 is encoded into bits\n\t * 3-7 of EEPROM location 6.  We zero the upper byte, and \n\t * shift the 5 bits right 3.  The resulting number tells us\n\t * the RAM location.  Because the EE16 supports either 16k or 32k\n\t * of shared RAM, we only worry about the 32k locations. \n\t *\n\t * NOTE: if a 64k EE16 exists, it should be added to this switch.\n\t *       then the ia->ia_msize would need to be set per case statement.\n\t *\n\t *\tvalue\tmsize\tlocation\n\t *\t=====\t=====\t========\n\t *\t0x03\t0x8000\t0xCC000\n\t *\t0x06\t0x8000\t0xD0000\n\t *\t0x0C\t0x8000\t0xD4000\n\t *\t0x18\t0x8000\t0xD8000\n\t *\n\t */ \n\n\tif ((ia->ia_maddr == MADDRUNK) || (ia->ia_msize == 0)) {\n\t\ti = (ee16_read_eeprom(sc, 6) & 0x00ff ) >> 3;\n\t\tswitch(i) {\n\t\t\tcase 0x03:\n\t\t\t\tia->ia_maddr = 0xCC000;\n\t\t\t\tbreak;\n\t\t\tcase 0x06:\n\t\t\t\tia->ia_maddr = 0xD0000;\n\t\t\t\tbreak;\n\t\t\tcase 0x0c:\n\t\t\t\tia->ia_maddr = 0xD4000;\n\t\t\t\tbreak;\n\t\t\tcase 0x18:\n\t\t\t\tia->ia_maddr = 0xD8000;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn 0 ;\n\t\t\t\tbreak; /* NOTREACHED */\n\t\t}\n\t\tia->ia_msize = 0x8000; \n\t}\n\n\t/* need to set these after checking for MADDRUNK */\n\tsc->sc_maddr = ISA_HOLE_VADDR(ia->ia_maddr);\n\tsc->sc_msize = ia->ia_msize; \n\n\t/* need to put the 586 in RESET, and leave it */\n\toutb( PORT + IEE16_ECTRL, IEE16_RESET_586);  \n\n\t/* read the eeprom and checksum it, should == IEE16_ID */\n\tfor(i=0 ; i< 0x40 ; i++)\n\t\tchecksum += ee16_read_eeprom(sc, i);\n\n\tif (checksum != IEE16_ID)\n\t\treturn 0;\t\n\n\t/*\n\t * Size and test the memory on the board.  The size of the memory\n\t * can be one of 16k, 32k, 48k or 64k.  It can be located in the\n\t * address range 0xC0000 to 0xEFFFF on 16k boundaries. \n\t *\n\t * If the size does not match the passed in memory allocation size\n\t * issue a warning, but continue with the minimum of the two sizes.\n\t */\n\n\tswitch (ia->ia_msize) {\n\t\tcase 65536:\n\t\tcase 32768: /* XXX Only support 32k and 64k right now */\n\t\t\tbreak;\n\t\tcase 16384:\n\t\tcase 49512:\n\t\tdefault:\n\t\t\tprintf(\"ieprobe mapped memory size out of range\\n\");\n\t\t\treturn 0;\n\t\t\tbreak; /* NOTREACHED */\n\t}\n\n\tif ((kvtop(sc->sc_maddr) < 0xC0000) ||\n\t    (kvtop(sc->sc_maddr) + sc->sc_msize > 0xF0000)) {\n\t\tprintf(\"ieprobe mapped memory address out of range\\n\");\n\t\treturn 0;\n\t}\n\n\tpg = (kvtop(sc->sc_maddr) & 0x3C000) >> 14;\n\tadjust = IEE16_MCTRL_FMCS16 | (pg & 0x3) << 2;\n\tdecode = ((1 << (sc->sc_msize / 16384)) - 1) << pg;\n\tedecode = ((~decode >> 4) & 0xF0) | (decode >> 8);\n\n\t/* ZZZ This should be checked against eeprom location 6, low byte */\n\toutb(PORT + IEE16_MEMDEC, decode & 0xFF);\n\t/* ZZZ This should be checked against eeprom location 1, low byte */\n\toutb(PORT + IEE16_MCTRL, adjust);\n\t/* ZZZ Now if I could find this one I would have it made */\n\toutb(PORT + IEE16_MPCTRL, (~decode & 0xFF));\n\t/* ZZZ I think this is location 6, high byte */\n\toutb(PORT + IEE16_MECTRL, edecode); /*XXX disable Exxx */\n\n\t/*\n\t * first prime the stupid bart DRAM controller so that it\n\t * works, then zero out all of memory.\n\t */\n\tbzero(sc->sc_maddr, 32);\n\tbzero(sc->sc_maddr, sc->sc_msize);\n\n\t/*\n\t * Get the encoded interrupt number from the EEPROM, check it\n\t * against the passed in IRQ.  Issue a warning if they do not\n\t * match, and fail the probe.  If irq is 'IRQUNK' then we\n\t * use the EEPROM irq, and continue.\n\t */\n\tirq = ee16_read_eeprom(sc, IEE16_EEPROM_CONFIG1);\n\tirq = (irq & IEE16_EEPROM_IRQ) >> IEE16_EEPROM_IRQ_SHIFT;\n\tsc->irq_encoded = irq;\n\tirq = irq_translate[irq];\n\tif (ia->ia_irq != IRQUNK) {\n\t\tif (irq != ia->ia_irq) {\n#ifdef DIAGNOSTIC\n\t\t\tprintf(\"\\nie%d: fatal: board IRQ %d does not match kernel\\n\", sc->sc_dev.dv_unit, irq);\n#endif /* DIAGNOSTIC */\n\t\t\treturn 0; \t/* _must_ match or probe fails */\n\t\t}\n\t} else\n\t\tia->ia_irq = irq;\n\n\t/*\n\t * Get the hardware ethernet address from the EEPROM and\n\t * save it in the softc for use by the 586 setup code.\n\t */\n\teaddrtemp = ee16_read_eeprom(sc, IEE16_EEPROM_ENET_HIGH);\n\tsc->sc_arpcom.ac_enaddr[1] = eaddrtemp & 0xFF;\n\tsc->sc_arpcom.ac_enaddr[0] = eaddrtemp >> 8;\n\teaddrtemp = ee16_read_eeprom(sc, IEE16_EEPROM_ENET_MID);\n\tsc->sc_arpcom.ac_enaddr[3] = eaddrtemp & 0xFF;\n\tsc->sc_arpcom.ac_enaddr[2] = eaddrtemp >> 8;\n\teaddrtemp = ee16_read_eeprom(sc, IEE16_EEPROM_ENET_LOW);\n\tsc->sc_arpcom.ac_enaddr[5] = eaddrtemp & 0xFF;\n\tsc->sc_arpcom.ac_enaddr[4] = eaddrtemp >> 8;\n\n\t/* disable the board interrupts */\n\toutb(PORT + IEE16_IRQ, sc->irq_encoded);\n\n\t/* enable loopback to keep bad packets off the wire */\n\tif(sc->hard_type == IE_EE16) {\n\t\tbart_config = inb(PORT + IEE16_CONFIG);\n\t\tbart_config |= IEE16_BART_LOOPBACK;\n\t\tbart_config |= IEE16_BART_MCS16_TEST; /* inb doesn't get bit! */\n\t\toutb(PORT + IEE16_CONFIG, bart_config);\n\t\tbart_config = inb(PORT + IEE16_CONFIG);\n\t}\n\n\toutb(PORT + IEE16_ECTRL, 0);\n\tdelay(100);\n\tif (!check_ie_present(sc, sc->sc_maddr, sc->sc_msize))\n\t\treturn 0;\n\n\tia->ia_iosize = 16;\t/* the number of I/O ports */\n\treturn 1;\t\t/* found */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "static void ee16_reset_586",
            "static void ee16_chan_attn",
            "u_short ee16_read_eeprom",
            "int\tieprobe",
            "int\tee16_probe",
            "int\tcheck_ie_present",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nstatic void ee16_reset_586;\nstatic void ee16_chan_attn;\nu_short ee16_read_eeprom;\nint\tieprobe;\nint\tee16_probe;\nint\tcheck_ie_present;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_probe(sc, ia)\n\tstruct ie_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tint i;\n\tu_short board_id, id_var1, id_var2, checksum = 0;\n\tu_short eaddrtemp, irq;\n        u_short pg, adjust, decode, edecode;\n\tu_char\tbart_config;\n\n\tshort\tirq_translate[] = {0, 0x09, 0x03, 0x04, 0x05, 0x0a, 0x0b, 0};\n\n\t/* Need this for part of the probe. */\n\tsc->reset_586 = ee16_reset_586;\n\tsc->chan_attn = ee16_chan_attn;\n\n\t/* reset any ee16 at the current iobase */\n\toutb(ia->ia_iobase + IEE16_ECTRL, IEE16_RESET_ASIC);\n\toutb(ia->ia_iobase + IEE16_ECTRL, 0);\n\tdelay(240);\n\n\t/* now look for ee16. */\n\tboard_id = id_var1 = id_var2 = 0;\n\tfor (i=0; i<4 ; i++) {\n\t\tid_var1 = inb(ia->ia_iobase + IEE16_ID_PORT);\n\t\tid_var2 = ((id_var1 & 0x03) << 2);\n\t\tboard_id |= (( id_var1 >> 4)  << id_var2);\n\t\t}\n\n\tif (board_id != IEE16_ID)\n\t\treturn 0;\t\t\n\n\t/* need sc->sc_iobase for ee16_read_eeprom */\n\tsc->sc_iobase = ia->ia_iobase;\n\tsc->hard_type = IE_EE16;\n\n\t/*\n\t * If ia->maddr == MADDRUNK, use value in eeprom location 6.\n\t *\n\t * The shared RAM location on the EE16 is encoded into bits\n\t * 3-7 of EEPROM location 6.  We zero the upper byte, and \n\t * shift the 5 bits right 3.  The resulting number tells us\n\t * the RAM location.  Because the EE16 supports either 16k or 32k\n\t * of shared RAM, we only worry about the 32k locations. \n\t *\n\t * NOTE: if a 64k EE16 exists, it should be added to this switch.\n\t *       then the ia->ia_msize would need to be set per case statement.\n\t *\n\t *\tvalue\tmsize\tlocation\n\t *\t=====\t=====\t========\n\t *\t0x03\t0x8000\t0xCC000\n\t *\t0x06\t0x8000\t0xD0000\n\t *\t0x0C\t0x8000\t0xD4000\n\t *\t0x18\t0x8000\t0xD8000\n\t *\n\t */ \n\n\tif ((ia->ia_maddr == MADDRUNK) || (ia->ia_msize == 0)) {\n\t\ti = (ee16_read_eeprom(sc, 6) & 0x00ff ) >> 3;\n\t\tswitch(i) {\n\t\t\tcase 0x03:\n\t\t\t\tia->ia_maddr = 0xCC000;\n\t\t\t\tbreak;\n\t\t\tcase 0x06:\n\t\t\t\tia->ia_maddr = 0xD0000;\n\t\t\t\tbreak;\n\t\t\tcase 0x0c:\n\t\t\t\tia->ia_maddr = 0xD4000;\n\t\t\t\tbreak;\n\t\t\tcase 0x18:\n\t\t\t\tia->ia_maddr = 0xD8000;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn 0 ;\n\t\t\t\tbreak; /* NOTREACHED */\n\t\t}\n\t\tia->ia_msize = 0x8000; \n\t}\n\n\t/* need to set these after checking for MADDRUNK */\n\tsc->sc_maddr = ISA_HOLE_VADDR(ia->ia_maddr);\n\tsc->sc_msize = ia->ia_msize; \n\n\t/* need to put the 586 in RESET, and leave it */\n\toutb( PORT + IEE16_ECTRL, IEE16_RESET_586);  \n\n\t/* read the eeprom and checksum it, should == IEE16_ID */\n\tfor(i=0 ; i< 0x40 ; i++)\n\t\tchecksum += ee16_read_eeprom(sc, i);\n\n\tif (checksum != IEE16_ID)\n\t\treturn 0;\t\n\n\t/*\n\t * Size and test the memory on the board.  The size of the memory\n\t * can be one of 16k, 32k, 48k or 64k.  It can be located in the\n\t * address range 0xC0000 to 0xEFFFF on 16k boundaries. \n\t *\n\t * If the size does not match the passed in memory allocation size\n\t * issue a warning, but continue with the minimum of the two sizes.\n\t */\n\n\tswitch (ia->ia_msize) {\n\t\tcase 65536:\n\t\tcase 32768: /* XXX Only support 32k and 64k right now */\n\t\t\tbreak;\n\t\tcase 16384:\n\t\tcase 49512:\n\t\tdefault:\n\t\t\tprintf(\"ieprobe mapped memory size out of range\\n\");\n\t\t\treturn 0;\n\t\t\tbreak; /* NOTREACHED */\n\t}\n\n\tif ((kvtop(sc->sc_maddr) < 0xC0000) ||\n\t    (kvtop(sc->sc_maddr) + sc->sc_msize > 0xF0000)) {\n\t\tprintf(\"ieprobe mapped memory address out of range\\n\");\n\t\treturn 0;\n\t}\n\n\tpg = (kvtop(sc->sc_maddr) & 0x3C000) >> 14;\n\tadjust = IEE16_MCTRL_FMCS16 | (pg & 0x3) << 2;\n\tdecode = ((1 << (sc->sc_msize / 16384)) - 1) << pg;\n\tedecode = ((~decode >> 4) & 0xF0) | (decode >> 8);\n\n\t/* ZZZ This should be checked against eeprom location 6, low byte */\n\toutb(PORT + IEE16_MEMDEC, decode & 0xFF);\n\t/* ZZZ This should be checked against eeprom location 1, low byte */\n\toutb(PORT + IEE16_MCTRL, adjust);\n\t/* ZZZ Now if I could find this one I would have it made */\n\toutb(PORT + IEE16_MPCTRL, (~decode & 0xFF));\n\t/* ZZZ I think this is location 6, high byte */\n\toutb(PORT + IEE16_MECTRL, edecode); /*XXX disable Exxx */\n\n\t/*\n\t * first prime the stupid bart DRAM controller so that it\n\t * works, then zero out all of memory.\n\t */\n\tbzero(sc->sc_maddr, 32);\n\tbzero(sc->sc_maddr, sc->sc_msize);\n\n\t/*\n\t * Get the encoded interrupt number from the EEPROM, check it\n\t * against the passed in IRQ.  Issue a warning if they do not\n\t * match, and fail the probe.  If irq is 'IRQUNK' then we\n\t * use the EEPROM irq, and continue.\n\t */\n\tirq = ee16_read_eeprom(sc, IEE16_EEPROM_CONFIG1);\n\tirq = (irq & IEE16_EEPROM_IRQ) >> IEE16_EEPROM_IRQ_SHIFT;\n\tsc->irq_encoded = irq;\n\tirq = irq_translate[irq];\n\tif (ia->ia_irq != IRQUNK) {\n\t\tif (irq != ia->ia_irq) {\n#ifdef DIAGNOSTIC\n\t\t\tprintf(\"\\nie%d: fatal: board IRQ %d does not match kernel\\n\", sc->sc_dev.dv_unit, irq);\n#endif /* DIAGNOSTIC */\n\t\t\treturn 0; \t/* _must_ match or probe fails */\n\t\t}\n\t} else\n\t\tia->ia_irq = irq;\n\n\t/*\n\t * Get the hardware ethernet address from the EEPROM and\n\t * save it in the softc for use by the 586 setup code.\n\t */\n\teaddrtemp = ee16_read_eeprom(sc, IEE16_EEPROM_ENET_HIGH);\n\tsc->sc_arpcom.ac_enaddr[1] = eaddrtemp & 0xFF;\n\tsc->sc_arpcom.ac_enaddr[0] = eaddrtemp >> 8;\n\teaddrtemp = ee16_read_eeprom(sc, IEE16_EEPROM_ENET_MID);\n\tsc->sc_arpcom.ac_enaddr[3] = eaddrtemp & 0xFF;\n\tsc->sc_arpcom.ac_enaddr[2] = eaddrtemp >> 8;\n\teaddrtemp = ee16_read_eeprom(sc, IEE16_EEPROM_ENET_LOW);\n\tsc->sc_arpcom.ac_enaddr[5] = eaddrtemp & 0xFF;\n\tsc->sc_arpcom.ac_enaddr[4] = eaddrtemp >> 8;\n\n\t/* disable the board interrupts */\n\toutb(PORT + IEE16_IRQ, sc->irq_encoded);\n\n\t/* enable loopback to keep bad packets off the wire */\n\tif(sc->hard_type == IE_EE16) {\n\t\tbart_config = inb(PORT + IEE16_CONFIG);\n\t\tbart_config |= IEE16_BART_LOOPBACK;\n\t\tbart_config |= IEE16_BART_MCS16_TEST; /* inb doesn't get bit! */\n\t\toutb(PORT + IEE16_CONFIG, bart_config);\n\t\tbart_config = inb(PORT + IEE16_CONFIG);\n\t}\n\n\toutb(PORT + IEE16_ECTRL, 0);\n\tdelay(100);\n\tif (!check_ie_present(sc, sc->sc_maddr, sc->sc_msize))\n\t\treturn 0;\n\n\tia->ia_iosize = 16;\t/* the number of I/O ports */\n\treturn 1;\t\t/* found */\n}"
        }
      },
      {
        "call_info": {
          "callee": "el_probe",
          "args": [
            "sc",
            "ia"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "el_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "462-577",
          "snippet": "int\nel_probe(sc, ia)\n\tstruct ie_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tu_char c;\n\tint i, rval = 0;\n\tu_char signature[] = \"*3COM*\";\n\n\tsc->sc_iobase = ia->ia_iobase;\n\n\t/* Need this for part of the probe. */\n\tsc->reset_586 = el_reset_586;\n\tsc->chan_attn = el_chan_attn;\n\n\t/*\n\t * Map the Etherlink ID port for the probe sequence.\n\t */\n\tif (bus_space_map(iot, ELINK_ID_PORT, 1, 0, &ioh)) {\n\t\tprintf(\"3c507 probe: can't map Etherlink ID port\\n\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Reset and put card in CONFIG state without changing address.\n\t * XXX Indirect brokenness here!\n\t */\n\telink_reset(iot, ioh, sc->sc_dev.dv_parent->dv_unit);\n\telink_idseq(iot, ioh, ELINK_507_POLY);\n\telink_idseq(iot, ioh, ELINK_507_POLY);\n\toutb(ELINK_ID_PORT, 0xff);\n\n\t/* Check for 3COM signature before proceeding. */\n\toutb(PORT + IE507_CTRL, inb(PORT + IE507_CTRL) & 0xfc);\t/* XXX */\n\tfor (i = 0; i < 6; i++)\n\t\tif (inb(PORT + i) != signature[i])\n\t\t\tgoto out;\n\n\tc = inb(PORT + IE507_MADDR);\n\tif (c & 0x20) {\n\t\tprintf(\"%s: can't map 3C507 RAM in high memory\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto out;\n\t}\n\n\t/* Go to RUN state. */\n\toutb(ELINK_ID_PORT, 0x00);\n\telink_idseq(iot, ioh, ELINK_507_POLY);\n\toutb(ELINK_ID_PORT, 0x00);\n\n\t/* Set bank 2 for version info and read BCD version byte. */\n\toutb(PORT + IE507_CTRL, EL_CTRL_NRST | EL_CTRL_BNK2);\n\ti = inb(PORT + 3);\n\n\tsc->hard_type = IE_3C507;\n\tsc->hard_vers = 10*(i / 16) + (i % 16) - 1;\n\n\ti = inb(PORT + IE507_IRQ) & 0x0f;\n\n\tif (ia->ia_irq != IRQUNK) {\n\t\tif (ia->ia_irq != i) {\n\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq, i);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tia->ia_irq = i;\n\n\ti = ((inb(PORT + IE507_MADDR) & 0x1c) << 12) + 0xc0000;\n\n\tif (ia->ia_maddr != MADDRUNK) {\n\t\tif (ia->ia_maddr != i) {\n\t\t\tprintf(\"%s: maddr mismatch; kernel configured %x != board configured %x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ia->ia_maddr, i);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tia->ia_maddr = i;\n\n\toutb(PORT + IE507_CTRL, EL_CTRL_NORMAL);\n\n\t/*\n\t * Divine memory size on-board the card.\n\t */\n\tsc->sc_maddr = ISA_HOLE_VADDR(ia->ia_maddr);\n\tie_find_mem_size(sc);\n\n\tif (!sc->sc_msize) {\n\t\tprintf(\"%s: can't find shared memory\\n\", sc->sc_dev.dv_xname);\n\t\toutb(PORT + IE507_CTRL, EL_CTRL_NRST);\n\t\tgoto out;\n\t}\n\n\tif (!ia->ia_msize)\n\t\tia->ia_msize = sc->sc_msize;\n\telse if (ia->ia_msize != sc->sc_msize) {\n\t\tprintf(\"%s: msize mismatch; kernel configured %d != board configured %d\\n\",\n\t\t    sc->sc_dev.dv_xname, ia->ia_msize, sc->sc_msize);\n\t\toutb(PORT + IE507_CTRL, EL_CTRL_NRST);\n\t\tgoto out;\n\t}\n\n\tslel_get_address(sc);\n\n\t/* Clear the interrupt latch just in case. */\n\toutb(PORT + IE507_ICTRL, 1);\n\n\tia->ia_iosize = 16;\n\trval = 1;\n\n out:\n\tbus_space_unmap(iot, ioh, 1);\n\treturn rval;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "static void el_reset_586",
            "static void el_chan_attn",
            "static void slel_get_address",
            "void ie_find_mem_size",
            "int\tel_probe",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nstatic void el_reset_586;\nstatic void el_chan_attn;\nstatic void slel_get_address;\nvoid ie_find_mem_size;\nint\tel_probe;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nel_probe(sc, ia)\n\tstruct ie_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tu_char c;\n\tint i, rval = 0;\n\tu_char signature[] = \"*3COM*\";\n\n\tsc->sc_iobase = ia->ia_iobase;\n\n\t/* Need this for part of the probe. */\n\tsc->reset_586 = el_reset_586;\n\tsc->chan_attn = el_chan_attn;\n\n\t/*\n\t * Map the Etherlink ID port for the probe sequence.\n\t */\n\tif (bus_space_map(iot, ELINK_ID_PORT, 1, 0, &ioh)) {\n\t\tprintf(\"3c507 probe: can't map Etherlink ID port\\n\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Reset and put card in CONFIG state without changing address.\n\t * XXX Indirect brokenness here!\n\t */\n\telink_reset(iot, ioh, sc->sc_dev.dv_parent->dv_unit);\n\telink_idseq(iot, ioh, ELINK_507_POLY);\n\telink_idseq(iot, ioh, ELINK_507_POLY);\n\toutb(ELINK_ID_PORT, 0xff);\n\n\t/* Check for 3COM signature before proceeding. */\n\toutb(PORT + IE507_CTRL, inb(PORT + IE507_CTRL) & 0xfc);\t/* XXX */\n\tfor (i = 0; i < 6; i++)\n\t\tif (inb(PORT + i) != signature[i])\n\t\t\tgoto out;\n\n\tc = inb(PORT + IE507_MADDR);\n\tif (c & 0x20) {\n\t\tprintf(\"%s: can't map 3C507 RAM in high memory\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto out;\n\t}\n\n\t/* Go to RUN state. */\n\toutb(ELINK_ID_PORT, 0x00);\n\telink_idseq(iot, ioh, ELINK_507_POLY);\n\toutb(ELINK_ID_PORT, 0x00);\n\n\t/* Set bank 2 for version info and read BCD version byte. */\n\toutb(PORT + IE507_CTRL, EL_CTRL_NRST | EL_CTRL_BNK2);\n\ti = inb(PORT + 3);\n\n\tsc->hard_type = IE_3C507;\n\tsc->hard_vers = 10*(i / 16) + (i % 16) - 1;\n\n\ti = inb(PORT + IE507_IRQ) & 0x0f;\n\n\tif (ia->ia_irq != IRQUNK) {\n\t\tif (ia->ia_irq != i) {\n\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq, i);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tia->ia_irq = i;\n\n\ti = ((inb(PORT + IE507_MADDR) & 0x1c) << 12) + 0xc0000;\n\n\tif (ia->ia_maddr != MADDRUNK) {\n\t\tif (ia->ia_maddr != i) {\n\t\t\tprintf(\"%s: maddr mismatch; kernel configured %x != board configured %x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ia->ia_maddr, i);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tia->ia_maddr = i;\n\n\toutb(PORT + IE507_CTRL, EL_CTRL_NORMAL);\n\n\t/*\n\t * Divine memory size on-board the card.\n\t */\n\tsc->sc_maddr = ISA_HOLE_VADDR(ia->ia_maddr);\n\tie_find_mem_size(sc);\n\n\tif (!sc->sc_msize) {\n\t\tprintf(\"%s: can't find shared memory\\n\", sc->sc_dev.dv_xname);\n\t\toutb(PORT + IE507_CTRL, EL_CTRL_NRST);\n\t\tgoto out;\n\t}\n\n\tif (!ia->ia_msize)\n\t\tia->ia_msize = sc->sc_msize;\n\telse if (ia->ia_msize != sc->sc_msize) {\n\t\tprintf(\"%s: msize mismatch; kernel configured %d != board configured %d\\n\",\n\t\t    sc->sc_dev.dv_xname, ia->ia_msize, sc->sc_msize);\n\t\toutb(PORT + IE507_CTRL, EL_CTRL_NRST);\n\t\tgoto out;\n\t}\n\n\tslel_get_address(sc);\n\n\t/* Clear the interrupt latch just in case. */\n\toutb(PORT + IE507_ICTRL, 1);\n\n\tia->ia_iosize = 16;\n\trval = 1;\n\n out:\n\tbus_space_unmap(iot, ioh, 1);\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sl_probe",
          "args": [
            "sc",
            "ia"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "sl_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "395-460",
          "snippet": "int\nsl_probe(sc, ia)\n\tstruct ie_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tu_char c;\n\n\tsc->sc_iobase = ia->ia_iobase;\n\n\t/* Need this for part of the probe. */\n\tsc->reset_586 = sl_reset_586;\n\tsc->chan_attn = sl_chan_attn;\n\n\tc = inb(PORT + IEATT_REVISION);\n\tswitch (SL_BOARD(c)) {\n\tcase SL10_BOARD:\n\t\tsc->hard_type = IE_STARLAN10;\n\t\tbreak;\n\tcase EN100_BOARD:\n\t\tsc->hard_type = IE_EN100;\n\t\tbreak;\n\tcase SLFIBER_BOARD:\n\t\tsc->hard_type = IE_SLFIBER;\n\t\tbreak;\n\n\tdefault:\n\t\t/* Anything else is not recognized or cannot be used. */\n#if 0\n\t\tprintf(\"%s: unknown AT&T board type code %d\\n\",\n\t\t    sc->sc_dev.dv_xname, SL_BOARD(c));\n#endif\n\t\treturn 0;\n\t}\n\n\tsc->hard_vers = SL_REV(c);\n\n\tif (ia->ia_irq == IRQUNK || ia->ia_maddr == MADDRUNK) {\n\t\tprintf(\"%s: %s does not have soft configuration\\n\",\n\t\t    sc->sc_dev.dv_xname, ie_hardware_names[sc->hard_type]);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Divine memory size on-board the card.  Ususally 16k.\n\t */\n\tsc->sc_maddr = ISA_HOLE_VADDR(ia->ia_maddr);\n\tie_find_mem_size(sc);\n\n\tif (!sc->sc_msize) {\n\t\tprintf(\"%s: can't find shared memory\\n\", sc->sc_dev.dv_xname);\n\t\treturn 0;\n\t}\n\n\tif (!ia->ia_msize)\n\t\tia->ia_msize = sc->sc_msize;\n\telse if (ia->ia_msize != sc->sc_msize) {\n\t\tprintf(\"%s: msize mismatch; kernel configured %d != board configured %d\\n\",\n\t\t    sc->sc_dev.dv_xname, ia->ia_msize, sc->sc_msize);\n\t\treturn 0;\n\t}\n\n\tslel_get_address(sc);\n\n\tia->ia_iosize = 16;\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "const char *ie_hardware_names[] = {\n\t\"StarLAN 10\",\n\t\"EN100\",\n\t\"StarLAN Fiber\",\n\t\"3C507\",\n\t\"EtherExpress 16\",\n\t\"Unknown\"\n};",
            "static void sl_reset_586",
            "static void sl_chan_attn",
            "static void slel_get_address",
            "void ie_find_mem_size",
            "int\tsl_probe",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nconst char *ie_hardware_names[] = {\n\t\"StarLAN 10\",\n\t\"EN100\",\n\t\"StarLAN Fiber\",\n\t\"3C507\",\n\t\"EtherExpress 16\",\n\t\"Unknown\"\n};\nstatic void sl_reset_586;\nstatic void sl_chan_attn;\nstatic void slel_get_address;\nvoid ie_find_mem_size;\nint\tsl_probe;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nsl_probe(sc, ia)\n\tstruct ie_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tu_char c;\n\n\tsc->sc_iobase = ia->ia_iobase;\n\n\t/* Need this for part of the probe. */\n\tsc->reset_586 = sl_reset_586;\n\tsc->chan_attn = sl_chan_attn;\n\n\tc = inb(PORT + IEATT_REVISION);\n\tswitch (SL_BOARD(c)) {\n\tcase SL10_BOARD:\n\t\tsc->hard_type = IE_STARLAN10;\n\t\tbreak;\n\tcase EN100_BOARD:\n\t\tsc->hard_type = IE_EN100;\n\t\tbreak;\n\tcase SLFIBER_BOARD:\n\t\tsc->hard_type = IE_SLFIBER;\n\t\tbreak;\n\n\tdefault:\n\t\t/* Anything else is not recognized or cannot be used. */\n#if 0\n\t\tprintf(\"%s: unknown AT&T board type code %d\\n\",\n\t\t    sc->sc_dev.dv_xname, SL_BOARD(c));\n#endif\n\t\treturn 0;\n\t}\n\n\tsc->hard_vers = SL_REV(c);\n\n\tif (ia->ia_irq == IRQUNK || ia->ia_maddr == MADDRUNK) {\n\t\tprintf(\"%s: %s does not have soft configuration\\n\",\n\t\t    sc->sc_dev.dv_xname, ie_hardware_names[sc->hard_type]);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Divine memory size on-board the card.  Ususally 16k.\n\t */\n\tsc->sc_maddr = ISA_HOLE_VADDR(ia->ia_maddr);\n\tie_find_mem_size(sc);\n\n\tif (!sc->sc_msize) {\n\t\tprintf(\"%s: can't find shared memory\\n\", sc->sc_dev.dv_xname);\n\t\treturn 0;\n\t}\n\n\tif (!ia->ia_msize)\n\t\tia->ia_msize = sc->sc_msize;\n\telse if (ia->ia_msize != sc->sc_msize) {\n\t\tprintf(\"%s: msize mismatch; kernel configured %d != board configured %d\\n\",\n\t\t    sc->sc_dev.dv_xname, ia->ia_msize, sc->sc_msize);\n\t\treturn 0;\n\t}\n\n\tslel_get_address(sc);\n\n\tia->ia_iosize = 16;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tieprobe;\nint\tsl_probe;\nint\tel_probe;\nint\tee16_probe;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nieprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct ie_softc *sc = match;\n\tstruct isa_attach_args *ia = aux;\n\n\tif (sl_probe(sc, ia))\n\t\treturn 1;\n\tif (el_probe(sc, ia))\n\t\treturn 1;\n\tif (ee16_probe(sc, ia))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ie_ack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "364-376",
    "snippet": "static __inline void\nie_ack(sc, mask)\n\tstruct ie_softc *sc;\n\tu_int mask;\n{\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\n\tscb->ie_command = scb->ie_status & mask;\n\t(sc->chan_attn)(sc);\n\n\twhile (scb->ie_command)\n\t\t;\t\t/* Spin Lock */\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline void ie_ack",
      "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline void ie_ack;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nstatic __inline void\nie_ack(sc, mask)\n\tstruct ie_softc *sc;\n\tu_int mask;\n{\n\tvolatile struct ie_sys_ctl_block *scb = sc->scb;\n\n\tscb->ie_command = scb->ie_status & mask;\n\t(sc->chan_attn)(sc);\n\n\twhile (scb->ie_command)\n\t\t;\t\t/* Spin Lock */\n}"
  },
  {
    "function_name": "ie_setup_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
    "lines": "344-362",
    "snippet": "static __inline void\nie_setup_config(cmd, promiscuous, manchester)\n\tvolatile struct ie_config_cmd *cmd;\n\tint promiscuous, manchester;\n{\n\n\tcmd->ie_config_count = 0x0c;\n\tcmd->ie_fifo = 8;\n\tcmd->ie_save_bad = 0x40;\n\tcmd->ie_addr_len = 0x2e;\n\tcmd->ie_priority = 0;\n\tcmd->ie_ifs = 0x60;\n\tcmd->ie_slot_low = 0;\n\tcmd->ie_slot_high = 0xf2;\n\tcmd->ie_promisc = promiscuous | manchester << 2;\n\tcmd->ie_crs_cdt = 0;\n\tcmd->ie_min_len = 64;\n\tcmd->ie_junk = 0xff;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_iee16.h>",
      "#include <dev/isa/if_ie507.h>",
      "#include <dev/isa/if_ieatt.h>",
      "#include <dev/ic/i82586reg.h>",
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline void ie_setup_config"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline void ie_setup_config;\n\nstatic __inline void\nie_setup_config(cmd, promiscuous, manchester)\n\tvolatile struct ie_config_cmd *cmd;\n\tint promiscuous, manchester;\n{\n\n\tcmd->ie_config_count = 0x0c;\n\tcmd->ie_fifo = 8;\n\tcmd->ie_save_bad = 0x40;\n\tcmd->ie_addr_len = 0x2e;\n\tcmd->ie_priority = 0;\n\tcmd->ie_ifs = 0x60;\n\tcmd->ie_slot_low = 0;\n\tcmd->ie_slot_high = 0xf2;\n\tcmd->ie_promisc = promiscuous | manchester << 2;\n\tcmd->ie_crs_cdt = 0;\n\tcmd->ie_min_len = 64;\n\tcmd->ie_junk = 0xff;\n}"
  }
]