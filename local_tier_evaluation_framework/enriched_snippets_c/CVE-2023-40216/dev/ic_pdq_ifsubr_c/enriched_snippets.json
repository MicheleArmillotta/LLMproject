[
  {
    "function_name": "pdq_ifattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq_ifsubr.c",
    "lines": "358-383",
    "snippet": "void\npdq_ifattach(\n    pdq_softc_t *sc,\n    ifnet_ret_t (*ifwatchdog)(int unit))\n{\n    struct ifnet *ifp = &sc->sc_if;\n\n    ifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_NOTRAILERS|IFF_MULTICAST;\n\n#if (defined(__FreeBSD__) && BSD >= 199506) || defined(__NetBSD__) || \\\n\tdefined(__OpenBSD__)\n    ifp->if_watchdog = pdq_ifwatchdog;\n#else\n    ifp->if_watchdog = ifwatchdog;\n#endif\n\n    ifp->if_ioctl = pdq_ifioctl;\n    ifp->if_output = fddi_output;\n    ifp->if_start = pdq_ifstart;\n  \n    if_attach(ifp);\n    fddi_ifattach(ifp);\n#if NBPFILTER > 0\n    PDQ_BPFATTACH(sc, DLT_FDDI, sizeof(struct fddi_header));\n#endif\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\"",
      "#include <vm/vm_param.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <i386/isa/isavar.h>",
      "#include <net/if_fddi.h>",
      "#include <netinet/if_fddi.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/devconf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tIFF_NOTRAILERS\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_BPFATTACH",
          "args": [
            "sc",
            "DLT_FDDI",
            "sizeof(struct fddi_header)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fddi_ifattach",
          "args": [
            "ifp"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <i386/isa/isavar.h>\n#include <net/if_fddi.h>\n#include <netinet/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/devconf.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\n#define\tIFF_NOTRAILERS\t0\n\nvoid\npdq_ifattach(\n    pdq_softc_t *sc,\n    ifnet_ret_t (*ifwatchdog)(int unit))\n{\n    struct ifnet *ifp = &sc->sc_if;\n\n    ifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_NOTRAILERS|IFF_MULTICAST;\n\n#if (defined(__FreeBSD__) && BSD >= 199506) || defined(__NetBSD__) || \\\n\tdefined(__OpenBSD__)\n    ifp->if_watchdog = pdq_ifwatchdog;\n#else\n    ifp->if_watchdog = ifwatchdog;\n#endif\n\n    ifp->if_ioctl = pdq_ifioctl;\n    ifp->if_output = fddi_output;\n    ifp->if_start = pdq_ifstart;\n  \n    if_attach(ifp);\n    fddi_ifattach(ifp);\n#if NBPFILTER > 0\n    PDQ_BPFATTACH(sc, DLT_FDDI, sizeof(struct fddi_header));\n#endif\n}"
  },
  {
    "function_name": "pdq_ifioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq_ifsubr.c",
    "lines": "267-352",
    "snippet": "int\npdq_ifioctl(\n    struct ifnet *ifp,\n    ioctl_cmd_t cmd,\n    caddr_t data)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) ((caddr_t) ifp - offsetof(pdq_softc_t, sc_ac.ac_if));\n    int s, error = 0;\n\n    s = splimp();\n\n    switch (cmd) {\n\tcase SIOCSIFADDR: {\n\t    struct ifaddr *ifa = (struct ifaddr *)data;\n\n\t    ifp->if_flags |= IFF_UP;\n\t    switch(ifa->ifa_addr->sa_family) {\n#if defined(INET)\n\t\tcase AF_INET: {\n\t\t    pdq_ifinit(sc);\n\t\t    arp_ifinit(&sc->sc_ac, ifa);\n\t\t    break;\n\t\t}\n#endif /* INET */\n\n#if defined(NS)\n\t\t/* This magic copied from if_is.c; I don't use XNS,\n\t\t * so I have no way of telling if this actually\n\t\t * works or not.\n\t\t */\n\t\tcase AF_NS: {\n\t\t    struct ns_addr *ina = &(IA_SNS(ifa)->sns_addr);\n\t\t    if (ns_nullhost(*ina)) {\n\t\t\tina->x_host = *(union ns_host *)(sc->sc_ac.ac_enaddr);\n\t\t    } else {\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t\tbcopy((caddr_t)ina->x_host.c_host,\n\t\t\t      (caddr_t)sc->sc_ac.ac_enaddr,\n\t\t\t      sizeof sc->sc_ac.ac_enaddr);\n\t\t    }\n\n\t\t    pdq_ifinit(sc);\n\t\t    break;\n\t\t}\n#endif /* NS */\n\n\t\tdefault: {\n\t\t    pdq_ifinit(sc);\n\t\t    break;\n\t\t}\n\t    }\n\t    break;\n\t}\n\n\tcase SIOCSIFFLAGS: {\n\t    pdq_ifinit(sc);\n\t    break;\n\t}\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI: {\n\t    /*\n\t     * Update multicast listeners\n\t     */\n\t    if (cmd == SIOCADDMULTI)\n\t\terror = ether_addmulti((struct ifreq *)data, &sc->sc_ac);\n\t    else\n\t\terror = ether_delmulti((struct ifreq *)data, &sc->sc_ac);\n\n\t    if (error == ENETRESET) {\n\t\tif (sc->sc_if.if_flags & IFF_RUNNING)\n\t\t    pdq_run(sc->sc_pdq);\n\t\terror = 0;\n\t    }\n\t    break;\n\t}\n\n\tdefault: {\n\t    error = EINVAL;\n\t    break;\n\t}\n    }\n\n    splx(s);\n    return error;\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\"",
      "#include <vm/vm_param.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <i386/isa/isavar.h>",
      "#include <net/if_fddi.h>",
      "#include <netinet/if_fddi.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/devconf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_run",
          "args": [
            "sc->sc_pdq"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "1170-1242",
          "snippet": "void\npdq_run(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_state_t state;\n\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    PDQ_ASSERT(state != PDQS_DMA_UNAVAILABLE);\n    PDQ_ASSERT(state != PDQS_RESET);\n    PDQ_ASSERT(state != PDQS_HALTED);\n    PDQ_ASSERT(state != PDQS_UPGRADE);\n    PDQ_ASSERT(state != PDQS_RING_MEMBER);\n    switch (state) {\n\tcase PDQS_DMA_AVAILABLE: {\n\t    /*\n\t     * The PDQ after being reset screws up some of its state.\n\t     * So we need to clear all the errors/interrupts so the real\n\t     * ones will get through.\n\t     */\n\t    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, 0xFF);\n\t    PDQ_CSR_WRITE(csrs, csr_host_int_enable, PDQ_HOST_INT_STATE_CHANGE|PDQ_HOST_INT_XMT_DATA_FLUSH\n\t\t|PDQ_HOST_INT_FATAL_ERROR|PDQ_HOST_INT_CMD_RSP_ENABLE|PDQ_HOST_INT_UNSOL_ENABLE\n\t\t|PDQ_HOST_INT_RX_ENABLE|PDQ_HOST_INT_TX_ENABLE|PDQ_HOST_INT_HOST_SMT_ENABLE);\n\t    /*\n\t     * Set the MAC and address filters and start up the PDQ.\n\t     */\n\t    pdq_process_unsolicited_events(pdq);\n\t    pdq_process_received_data(pdq, &pdq->pdq_rx_info,\n\t\t\t\t      pdq->pdq_dbp->pdqdb_receives,\n\t\t\t\t      pdq->pdq_cbp->pdqcb_receives,\n\t\t\t\t      PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives));\n\t    PDQ_DO_TYPE2_PRODUCER(pdq);\n\t    if (pdq->pdq_flags & PDQ_PASS_SMT) {\n\t\tpdq_process_received_data(pdq, &pdq->pdq_host_smt_info,\n\t\t\t\t\t  pdq->pdq_dbp->pdqdb_host_smt,\n\t\t\t\t\t  pdq->pdq_cbp->pdqcb_host_smt,\n\t\t\t\t\t  PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt));\n\t\tPDQ_CSR_WRITE(csrs, csr_host_smt_producer,\n\t\t\t      pdq->pdq_host_smt_info.rx_producer\n\t\t\t          | (pdq->pdq_host_smt_info.rx_completion << 8));\n\t    }\n\t    pdq->pdq_command_info.ci_pending_commands = PDQ_BITMASK(PDQC_FILTER_SET)\n\t\t| PDQ_BITMASK(PDQC_ADDR_FILTER_SET) | PDQ_BITMASK(PDQC_START);\n\t    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\t\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n\t    pdq_queue_commands(pdq);\n\t    break;\n\t}\n\tcase PDQS_LINK_UNAVAILABLE:\n\tcase PDQS_LINK_AVAILABLE: {\n\t    pdq->pdq_command_info.ci_pending_commands = PDQ_BITMASK(PDQC_FILTER_SET)\n\t\t| PDQ_BITMASK(PDQC_ADDR_FILTER_SET);\n\t    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\t\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n\t    if (pdq->pdq_flags & PDQ_PASS_SMT) {\n\t\tpdq_process_received_data(pdq, &pdq->pdq_host_smt_info,\n\t\t\t\t\t  pdq->pdq_dbp->pdqdb_host_smt,\n\t\t\t\t\t  pdq->pdq_cbp->pdqcb_host_smt,\n\t\t\t\t\t  PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt));\n\t\tPDQ_CSR_WRITE(csrs, csr_host_smt_producer,\n\t\t\t      pdq->pdq_host_smt_info.rx_producer\n\t\t\t          | (pdq->pdq_host_smt_info.rx_completion << 8));\n\t    }\n\t    pdq_process_unsolicited_events(pdq);\n\t    pdq_queue_commands(pdq);\n\t    break;\n\t}\n\tcase PDQS_RING_MEMBER: {\n\t}\n\tdefault:\n    }\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nvoid\npdq_run(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_state_t state;\n\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    PDQ_ASSERT(state != PDQS_DMA_UNAVAILABLE);\n    PDQ_ASSERT(state != PDQS_RESET);\n    PDQ_ASSERT(state != PDQS_HALTED);\n    PDQ_ASSERT(state != PDQS_UPGRADE);\n    PDQ_ASSERT(state != PDQS_RING_MEMBER);\n    switch (state) {\n\tcase PDQS_DMA_AVAILABLE: {\n\t    /*\n\t     * The PDQ after being reset screws up some of its state.\n\t     * So we need to clear all the errors/interrupts so the real\n\t     * ones will get through.\n\t     */\n\t    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, 0xFF);\n\t    PDQ_CSR_WRITE(csrs, csr_host_int_enable, PDQ_HOST_INT_STATE_CHANGE|PDQ_HOST_INT_XMT_DATA_FLUSH\n\t\t|PDQ_HOST_INT_FATAL_ERROR|PDQ_HOST_INT_CMD_RSP_ENABLE|PDQ_HOST_INT_UNSOL_ENABLE\n\t\t|PDQ_HOST_INT_RX_ENABLE|PDQ_HOST_INT_TX_ENABLE|PDQ_HOST_INT_HOST_SMT_ENABLE);\n\t    /*\n\t     * Set the MAC and address filters and start up the PDQ.\n\t     */\n\t    pdq_process_unsolicited_events(pdq);\n\t    pdq_process_received_data(pdq, &pdq->pdq_rx_info,\n\t\t\t\t      pdq->pdq_dbp->pdqdb_receives,\n\t\t\t\t      pdq->pdq_cbp->pdqcb_receives,\n\t\t\t\t      PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives));\n\t    PDQ_DO_TYPE2_PRODUCER(pdq);\n\t    if (pdq->pdq_flags & PDQ_PASS_SMT) {\n\t\tpdq_process_received_data(pdq, &pdq->pdq_host_smt_info,\n\t\t\t\t\t  pdq->pdq_dbp->pdqdb_host_smt,\n\t\t\t\t\t  pdq->pdq_cbp->pdqcb_host_smt,\n\t\t\t\t\t  PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt));\n\t\tPDQ_CSR_WRITE(csrs, csr_host_smt_producer,\n\t\t\t      pdq->pdq_host_smt_info.rx_producer\n\t\t\t          | (pdq->pdq_host_smt_info.rx_completion << 8));\n\t    }\n\t    pdq->pdq_command_info.ci_pending_commands = PDQ_BITMASK(PDQC_FILTER_SET)\n\t\t| PDQ_BITMASK(PDQC_ADDR_FILTER_SET) | PDQ_BITMASK(PDQC_START);\n\t    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\t\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n\t    pdq_queue_commands(pdq);\n\t    break;\n\t}\n\tcase PDQS_LINK_UNAVAILABLE:\n\tcase PDQS_LINK_AVAILABLE: {\n\t    pdq->pdq_command_info.ci_pending_commands = PDQ_BITMASK(PDQC_FILTER_SET)\n\t\t| PDQ_BITMASK(PDQC_ADDR_FILTER_SET);\n\t    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\t\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n\t    if (pdq->pdq_flags & PDQ_PASS_SMT) {\n\t\tpdq_process_received_data(pdq, &pdq->pdq_host_smt_info,\n\t\t\t\t\t  pdq->pdq_dbp->pdqdb_host_smt,\n\t\t\t\t\t  pdq->pdq_cbp->pdqcb_host_smt,\n\t\t\t\t\t  PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt));\n\t\tPDQ_CSR_WRITE(csrs, csr_host_smt_producer,\n\t\t\t      pdq->pdq_host_smt_info.rx_producer\n\t\t\t          | (pdq->pdq_host_smt_info.rx_completion << 8));\n\t    }\n\t    pdq_process_unsolicited_events(pdq);\n\t    pdq_queue_commands(pdq);\n\t    break;\n\t}\n\tcase PDQS_RING_MEMBER: {\n\t}\n\tdefault:\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "(struct ifreq *)data",
            "&sc->sc_ac"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "(struct ifreq *)data",
            "&sc->sc_ac"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_ifinit",
          "args": [
            "sc"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq_ifsubr.c",
          "lines": "108-136",
          "snippet": "void\npdq_ifinit(\n    pdq_softc_t *sc)\n{\n    if (sc->sc_if.if_flags & IFF_UP) {\n\tsc->sc_if.if_flags |= IFF_RUNNING;\n\tif (sc->sc_if.if_flags & IFF_PROMISC) {\n\t    sc->sc_pdq->pdq_flags |= PDQ_PROMISC;\n\t} else {\n\t    sc->sc_pdq->pdq_flags &= ~PDQ_PROMISC;\n\t}\n\tif (sc->sc_if.if_flags & IFF_ALLMULTI) {\n\t    sc->sc_pdq->pdq_flags |= PDQ_ALLMULTI;\n\t} else {\n\t    sc->sc_pdq->pdq_flags &= ~PDQ_ALLMULTI;\n\t}\n\tif (sc->sc_if.if_flags & IFF_LINK1) {\n\t    sc->sc_pdq->pdq_flags |= PDQ_PASS_SMT;\n\t} else {\n\t    sc->sc_pdq->pdq_flags &= ~PDQ_PASS_SMT;\n\t}\n\tsc->sc_pdq->pdq_flags |= PDQ_RUNNING;\n\tpdq_run(sc->sc_pdq);\n    } else {\n\tsc->sc_if.if_flags &= ~IFF_RUNNING;\n\tsc->sc_pdq->pdq_flags &= ~PDQ_RUNNING;\n\tpdq_stop(sc->sc_pdq);\n    }\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\"",
            "#include <vm/vm_param.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <i386/isa/isavar.h>",
            "#include <net/if_fddi.h>",
            "#include <netinet/if_fddi.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/devconf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <i386/isa/isavar.h>\n#include <net/if_fddi.h>\n#include <netinet/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/devconf.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nvoid\npdq_ifinit(\n    pdq_softc_t *sc)\n{\n    if (sc->sc_if.if_flags & IFF_UP) {\n\tsc->sc_if.if_flags |= IFF_RUNNING;\n\tif (sc->sc_if.if_flags & IFF_PROMISC) {\n\t    sc->sc_pdq->pdq_flags |= PDQ_PROMISC;\n\t} else {\n\t    sc->sc_pdq->pdq_flags &= ~PDQ_PROMISC;\n\t}\n\tif (sc->sc_if.if_flags & IFF_ALLMULTI) {\n\t    sc->sc_pdq->pdq_flags |= PDQ_ALLMULTI;\n\t} else {\n\t    sc->sc_pdq->pdq_flags &= ~PDQ_ALLMULTI;\n\t}\n\tif (sc->sc_if.if_flags & IFF_LINK1) {\n\t    sc->sc_pdq->pdq_flags |= PDQ_PASS_SMT;\n\t} else {\n\t    sc->sc_pdq->pdq_flags &= ~PDQ_PASS_SMT;\n\t}\n\tsc->sc_pdq->pdq_flags |= PDQ_RUNNING;\n\tpdq_run(sc->sc_pdq);\n    } else {\n\tsc->sc_if.if_flags &= ~IFF_RUNNING;\n\tsc->sc_pdq->pdq_flags &= ~PDQ_RUNNING;\n\tpdq_stop(sc->sc_pdq);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(caddr_t)ina->x_host.c_host",
            "(caddr_t)sc->sc_ac.ac_enaddr",
            "sizeof sc->sc_ac.ac_enaddr"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_nullhost",
          "args": [
            "*ina"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IA_SNS",
          "args": [
            "ifa"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->sc_ac",
            "ifa"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <i386/isa/isavar.h>\n#include <net/if_fddi.h>\n#include <netinet/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/devconf.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nint\npdq_ifioctl(\n    struct ifnet *ifp,\n    ioctl_cmd_t cmd,\n    caddr_t data)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) ((caddr_t) ifp - offsetof(pdq_softc_t, sc_ac.ac_if));\n    int s, error = 0;\n\n    s = splimp();\n\n    switch (cmd) {\n\tcase SIOCSIFADDR: {\n\t    struct ifaddr *ifa = (struct ifaddr *)data;\n\n\t    ifp->if_flags |= IFF_UP;\n\t    switch(ifa->ifa_addr->sa_family) {\n#if defined(INET)\n\t\tcase AF_INET: {\n\t\t    pdq_ifinit(sc);\n\t\t    arp_ifinit(&sc->sc_ac, ifa);\n\t\t    break;\n\t\t}\n#endif /* INET */\n\n#if defined(NS)\n\t\t/* This magic copied from if_is.c; I don't use XNS,\n\t\t * so I have no way of telling if this actually\n\t\t * works or not.\n\t\t */\n\t\tcase AF_NS: {\n\t\t    struct ns_addr *ina = &(IA_SNS(ifa)->sns_addr);\n\t\t    if (ns_nullhost(*ina)) {\n\t\t\tina->x_host = *(union ns_host *)(sc->sc_ac.ac_enaddr);\n\t\t    } else {\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t\tbcopy((caddr_t)ina->x_host.c_host,\n\t\t\t      (caddr_t)sc->sc_ac.ac_enaddr,\n\t\t\t      sizeof sc->sc_ac.ac_enaddr);\n\t\t    }\n\n\t\t    pdq_ifinit(sc);\n\t\t    break;\n\t\t}\n#endif /* NS */\n\n\t\tdefault: {\n\t\t    pdq_ifinit(sc);\n\t\t    break;\n\t\t}\n\t    }\n\t    break;\n\t}\n\n\tcase SIOCSIFFLAGS: {\n\t    pdq_ifinit(sc);\n\t    break;\n\t}\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI: {\n\t    /*\n\t     * Update multicast listeners\n\t     */\n\t    if (cmd == SIOCADDMULTI)\n\t\terror = ether_addmulti((struct ifreq *)data, &sc->sc_ac);\n\t    else\n\t\terror = ether_delmulti((struct ifreq *)data, &sc->sc_ac);\n\n\t    if (error == ENETRESET) {\n\t\tif (sc->sc_if.if_flags & IFF_RUNNING)\n\t\t    pdq_run(sc->sc_pdq);\n\t\terror = 0;\n\t    }\n\t    break;\n\t}\n\n\tdefault: {\n\t    error = EINVAL;\n\t    break;\n\t}\n    }\n\n    splx(s);\n    return error;\n}"
  },
  {
    "function_name": "pdq_os_addr_fill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq_ifsubr.c",
    "lines": "246-265",
    "snippet": "void\npdq_os_addr_fill(\n    pdq_t *pdq,\n    pdq_lanaddr_t *addr,\n    size_t num_addrs)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;\n    struct ether_multistep step;\n    struct ether_multi *enm;\n\n    ETHER_FIRST_MULTI(step, &sc->sc_ac, enm);\n    while (enm != NULL && num_addrs > 0) {\n\t((u_short *) addr->lanaddr_bytes)[0] = ((u_short *) enm->enm_addrlo)[0];\n\t((u_short *) addr->lanaddr_bytes)[1] = ((u_short *) enm->enm_addrlo)[1];\n\t((u_short *) addr->lanaddr_bytes)[2] = ((u_short *) enm->enm_addrlo)[2];\n\tETHER_NEXT_MULTI(step, enm);\n\taddr++;\n\tnum_addrs--;\n    }\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\"",
      "#include <vm/vm_param.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <i386/isa/isavar.h>",
      "#include <net/if_fddi.h>",
      "#include <netinet/if_fddi.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/devconf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "&sc->sc_ac",
            "enm"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <i386/isa/isavar.h>\n#include <net/if_fddi.h>\n#include <netinet/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/devconf.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nvoid\npdq_os_addr_fill(\n    pdq_t *pdq,\n    pdq_lanaddr_t *addr,\n    size_t num_addrs)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;\n    struct ether_multistep step;\n    struct ether_multi *enm;\n\n    ETHER_FIRST_MULTI(step, &sc->sc_ac, enm);\n    while (enm != NULL && num_addrs > 0) {\n\t((u_short *) addr->lanaddr_bytes)[0] = ((u_short *) enm->enm_addrlo)[0];\n\t((u_short *) addr->lanaddr_bytes)[1] = ((u_short *) enm->enm_addrlo)[1];\n\t((u_short *) addr->lanaddr_bytes)[2] = ((u_short *) enm->enm_addrlo)[2];\n\tETHER_NEXT_MULTI(step, enm);\n\taddr++;\n\tnum_addrs--;\n    }\n}"
  },
  {
    "function_name": "pdq_os_transmit_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq_ifsubr.c",
    "lines": "232-244",
    "snippet": "void\npdq_os_transmit_done(\n    pdq_t *pdq,\n    struct mbuf *m)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;\n#if NBPFILTER > 0\n    if (sc->sc_bpf != NULL)\n\tPDQ_BPF_MTAP(sc, m);\n#endif\n    m_freem(m);\n    sc->sc_if.if_opackets++;\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\"",
      "#include <vm/vm_param.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <i386/isa/isavar.h>",
      "#include <net/if_fddi.h>",
      "#include <netinet/if_fddi.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/devconf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_BPF_MTAP",
          "args": [
            "sc",
            "m"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <i386/isa/isavar.h>\n#include <net/if_fddi.h>\n#include <netinet/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/devconf.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nvoid\npdq_os_transmit_done(\n    pdq_t *pdq,\n    struct mbuf *m)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;\n#if NBPFILTER > 0\n    if (sc->sc_bpf != NULL)\n\tPDQ_BPF_MTAP(sc, m);\n#endif\n    m_freem(m);\n    sc->sc_if.if_opackets++;\n}"
  },
  {
    "function_name": "pdq_os_restart_transmitter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq_ifsubr.c",
    "lines": "218-230",
    "snippet": "void\npdq_os_restart_transmitter(\n    pdq_t *pdq)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;\n    sc->sc_if.if_flags &= ~IFF_OACTIVE;\n    if (sc->sc_if.if_snd.ifq_head != NULL) {\n\tsc->sc_if.if_timer = PDQ_OS_TX_TIMEOUT;\n\tpdq_ifstart(&sc->sc_if);\n    } else {\n\tsc->sc_if.if_timer = 0;\n    }\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\"",
      "#include <vm/vm_param.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <i386/isa/isavar.h>",
      "#include <net/if_fddi.h>",
      "#include <netinet/if_fddi.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/devconf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pdq_ifstart",
          "args": [
            "&sc->sc_if"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_ifstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq_ifsubr.c",
          "lines": "158-190",
          "snippet": "ifnet_ret_t\npdq_ifstart(\n    struct ifnet *ifp)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) ((caddr_t) ifp - offsetof(pdq_softc_t, sc_ac.ac_if));\n    struct ifqueue *ifq = &ifp->if_snd;\n    struct mbuf *m;\n    int tx = 0;\n\n    if ((ifp->if_flags & IFF_RUNNING) == 0)\n\treturn;\n\n    if (sc->sc_if.if_timer == 0)\n\tsc->sc_if.if_timer = PDQ_OS_TX_TIMEOUT;\n\n    if ((sc->sc_pdq->pdq_flags & PDQ_TXOK) == 0) {\n\tsc->sc_if.if_flags |= IFF_OACTIVE;\n\treturn;\n    }\n    for (;; tx = 1) {\n\tIF_DEQUEUE(ifq, m);\n\tif (m == NULL)\n\t    break;\n\n\tif (pdq_queue_transmit_data(sc->sc_pdq, m) == PDQ_FALSE) {\n\t    ifp->if_flags |= IFF_OACTIVE;\n\t    IF_PREPEND(ifq, m);\n\t    break;\n\t}\n    }\n    if (tx)\n\tPDQ_DO_TYPE2_PRODUCER(sc->sc_pdq);\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\"",
            "#include <vm/vm_param.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <i386/isa/isavar.h>",
            "#include <net/if_fddi.h>",
            "#include <netinet/if_fddi.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/devconf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <i386/isa/isavar.h>\n#include <net/if_fddi.h>\n#include <netinet/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/devconf.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nifnet_ret_t\npdq_ifstart(\n    struct ifnet *ifp)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) ((caddr_t) ifp - offsetof(pdq_softc_t, sc_ac.ac_if));\n    struct ifqueue *ifq = &ifp->if_snd;\n    struct mbuf *m;\n    int tx = 0;\n\n    if ((ifp->if_flags & IFF_RUNNING) == 0)\n\treturn;\n\n    if (sc->sc_if.if_timer == 0)\n\tsc->sc_if.if_timer = PDQ_OS_TX_TIMEOUT;\n\n    if ((sc->sc_pdq->pdq_flags & PDQ_TXOK) == 0) {\n\tsc->sc_if.if_flags |= IFF_OACTIVE;\n\treturn;\n    }\n    for (;; tx = 1) {\n\tIF_DEQUEUE(ifq, m);\n\tif (m == NULL)\n\t    break;\n\n\tif (pdq_queue_transmit_data(sc->sc_pdq, m) == PDQ_FALSE) {\n\t    ifp->if_flags |= IFF_OACTIVE;\n\t    IF_PREPEND(ifq, m);\n\t    break;\n\t}\n    }\n    if (tx)\n\tPDQ_DO_TYPE2_PRODUCER(sc->sc_pdq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <i386/isa/isavar.h>\n#include <net/if_fddi.h>\n#include <netinet/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/devconf.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nvoid\npdq_os_restart_transmitter(\n    pdq_t *pdq)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;\n    sc->sc_if.if_flags &= ~IFF_OACTIVE;\n    if (sc->sc_if.if_snd.ifq_head != NULL) {\n\tsc->sc_if.if_timer = PDQ_OS_TX_TIMEOUT;\n\tpdq_ifstart(&sc->sc_if);\n    } else {\n\tsc->sc_if.if_timer = 0;\n    }\n}"
  },
  {
    "function_name": "pdq_os_receive_pdu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq_ifsubr.c",
    "lines": "192-216",
    "snippet": "void\npdq_os_receive_pdu(\n    pdq_t *pdq,\n    struct mbuf *m,\n    size_t pktlen)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;\n    struct fddi_header *fh = mtod(m, struct fddi_header *);\n\n    sc->sc_if.if_ipackets++;\n#if NBPFILTER > 0\n    if (sc->sc_bpf != NULL)\n\tPDQ_BPF_MTAP(sc, m);\n    if ((fh->fddi_fc & (FDDIFC_L|FDDIFC_F)) != FDDIFC_LLC_ASYNC) {\n\tm_freem(m);\n\treturn;\n    }\n#endif\n\n    m->m_data += sizeof(struct fddi_header);\n    m->m_len  -= sizeof(struct fddi_header);\n    m->m_pkthdr.len = pktlen - sizeof(struct fddi_header);\n    m->m_pkthdr.rcvif = &sc->sc_if;\n    fddi_input(&sc->sc_if, fh, m);\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\"",
      "#include <vm/vm_param.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <i386/isa/isavar.h>",
      "#include <net/if_fddi.h>",
      "#include <netinet/if_fddi.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/devconf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fddi_input",
          "args": [
            "&sc->sc_if",
            "fh",
            "m"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_BPF_MTAP",
          "args": [
            "sc",
            "m"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structfddi_header*"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <i386/isa/isavar.h>\n#include <net/if_fddi.h>\n#include <netinet/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/devconf.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nvoid\npdq_os_receive_pdu(\n    pdq_t *pdq,\n    struct mbuf *m,\n    size_t pktlen)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;\n    struct fddi_header *fh = mtod(m, struct fddi_header *);\n\n    sc->sc_if.if_ipackets++;\n#if NBPFILTER > 0\n    if (sc->sc_bpf != NULL)\n\tPDQ_BPF_MTAP(sc, m);\n    if ((fh->fddi_fc & (FDDIFC_L|FDDIFC_F)) != FDDIFC_LLC_ASYNC) {\n\tm_freem(m);\n\treturn;\n    }\n#endif\n\n    m->m_data += sizeof(struct fddi_header);\n    m->m_len  -= sizeof(struct fddi_header);\n    m->m_pkthdr.len = pktlen - sizeof(struct fddi_header);\n    m->m_pkthdr.rcvif = &sc->sc_if;\n    fddi_input(&sc->sc_if, fh, m);\n}"
  },
  {
    "function_name": "pdq_ifstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq_ifsubr.c",
    "lines": "158-190",
    "snippet": "ifnet_ret_t\npdq_ifstart(\n    struct ifnet *ifp)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) ((caddr_t) ifp - offsetof(pdq_softc_t, sc_ac.ac_if));\n    struct ifqueue *ifq = &ifp->if_snd;\n    struct mbuf *m;\n    int tx = 0;\n\n    if ((ifp->if_flags & IFF_RUNNING) == 0)\n\treturn;\n\n    if (sc->sc_if.if_timer == 0)\n\tsc->sc_if.if_timer = PDQ_OS_TX_TIMEOUT;\n\n    if ((sc->sc_pdq->pdq_flags & PDQ_TXOK) == 0) {\n\tsc->sc_if.if_flags |= IFF_OACTIVE;\n\treturn;\n    }\n    for (;; tx = 1) {\n\tIF_DEQUEUE(ifq, m);\n\tif (m == NULL)\n\t    break;\n\n\tif (pdq_queue_transmit_data(sc->sc_pdq, m) == PDQ_FALSE) {\n\t    ifp->if_flags |= IFF_OACTIVE;\n\t    IF_PREPEND(ifq, m);\n\t    break;\n\t}\n    }\n    if (tx)\n\tPDQ_DO_TYPE2_PRODUCER(sc->sc_pdq);\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\"",
      "#include <vm/vm_param.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <i386/isa/isavar.h>",
      "#include <net/if_fddi.h>",
      "#include <netinet/if_fddi.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/devconf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_DO_TYPE2_PRODUCER",
          "args": [
            "sc->sc_pdq"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_PREPEND",
          "args": [
            "ifq",
            "m"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_queue_transmit_data",
          "args": [
            "sc->sc_pdq",
            "m"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_queue_transmit_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "822-888",
          "snippet": "pdq_boolean_t\npdq_queue_transmit_data(\n    pdq_t *pdq,\n    PDQ_OS_DATABUF_T *pdu)\n{\n    pdq_tx_info_t *tx = &pdq->pdq_tx_info;\n    pdq_descriptor_block_t *dbp = pdq->pdq_dbp;\n    pdq_uint32_t producer = tx->tx_producer;\n    pdq_txdesc_t *eop = NULL;\n    PDQ_OS_DATABUF_T *pdu0;\n    pdq_uint32_t freecnt;\n\n    if (tx->tx_free < 1)\n\treturn PDQ_FALSE;\n\n    dbp->pdqdb_transmits[producer] = tx->tx_hdrdesc;\n    PDQ_ADVANCE(producer, 1, PDQ_RING_MASK(dbp->pdqdb_transmits));\n\n    for (freecnt = tx->tx_free - 1, pdu0 = pdu; pdu0 != NULL && freecnt > 0;) {\n\tpdq_uint32_t fraglen, datalen = PDQ_OS_DATABUF_LEN(pdu0);\n\tconst pdq_uint8_t *dataptr = PDQ_OS_DATABUF_PTR(pdu0);\n\n\t/*\n\t * The first segment is limited to the space remaining in\n\t * page.  All segments after that can be up to a full page\n\t * in size.\n\t */\n\tfraglen = PDQ_OS_PAGESIZE - ((dataptr - (pdq_uint8_t *) NULL) & (PDQ_OS_PAGESIZE-1));\n\twhile (datalen > 0 && freecnt > 0) {\n\t    pdq_uint32_t seglen = (fraglen < datalen ? fraglen : datalen);\n\n\t    /*\n\t     * Initialize the transmit descriptor\n\t     */\n\t    eop = &dbp->pdqdb_transmits[producer];\n\t    eop->txd_seg_len = seglen;\n\t    eop->txd_pa_lo = PDQ_OS_VA_TO_PA(pdq, dataptr);\n\t    eop->txd_sop = eop->txd_eop = eop->txd_pa_hi = 0;\n\n\t    datalen -= seglen;\n\t    dataptr += seglen;\n\t    fraglen = PDQ_OS_PAGESIZE;\n\t    freecnt--;\n\t    PDQ_ADVANCE(producer, 1, PDQ_RING_MASK(dbp->pdqdb_transmits));\n\t}\n\tpdu0 = PDQ_OS_DATABUF_NEXT(pdu0);\n    }\n    if (pdu0 != NULL) {\n\tPDQ_ASSERT(freecnt == 0);\n\t/*\n\t * If we still have data to process then the ring was too full\n\t * to store the PDU.  Return FALSE so the caller will requeue\n\t * the PDU for later.\n\t */\n\treturn PDQ_FALSE;\n    }\n    /*\n     * Everything went fine.  Finish it up.\n     */\n    tx->tx_descriptor_count[tx->tx_producer] = tx->tx_free - freecnt;\n    eop->txd_eop = 1;\n    PDQ_OS_DATABUF_ENQUEUE(&tx->tx_txq, pdu);\n    tx->tx_producer = producer;\n    tx->tx_free = freecnt;\n    PDQ_DO_TYPE2_PRODUCER(pdq);\n    return PDQ_TRUE;\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\npdq_boolean_t\npdq_queue_transmit_data(\n    pdq_t *pdq,\n    PDQ_OS_DATABUF_T *pdu)\n{\n    pdq_tx_info_t *tx = &pdq->pdq_tx_info;\n    pdq_descriptor_block_t *dbp = pdq->pdq_dbp;\n    pdq_uint32_t producer = tx->tx_producer;\n    pdq_txdesc_t *eop = NULL;\n    PDQ_OS_DATABUF_T *pdu0;\n    pdq_uint32_t freecnt;\n\n    if (tx->tx_free < 1)\n\treturn PDQ_FALSE;\n\n    dbp->pdqdb_transmits[producer] = tx->tx_hdrdesc;\n    PDQ_ADVANCE(producer, 1, PDQ_RING_MASK(dbp->pdqdb_transmits));\n\n    for (freecnt = tx->tx_free - 1, pdu0 = pdu; pdu0 != NULL && freecnt > 0;) {\n\tpdq_uint32_t fraglen, datalen = PDQ_OS_DATABUF_LEN(pdu0);\n\tconst pdq_uint8_t *dataptr = PDQ_OS_DATABUF_PTR(pdu0);\n\n\t/*\n\t * The first segment is limited to the space remaining in\n\t * page.  All segments after that can be up to a full page\n\t * in size.\n\t */\n\tfraglen = PDQ_OS_PAGESIZE - ((dataptr - (pdq_uint8_t *) NULL) & (PDQ_OS_PAGESIZE-1));\n\twhile (datalen > 0 && freecnt > 0) {\n\t    pdq_uint32_t seglen = (fraglen < datalen ? fraglen : datalen);\n\n\t    /*\n\t     * Initialize the transmit descriptor\n\t     */\n\t    eop = &dbp->pdqdb_transmits[producer];\n\t    eop->txd_seg_len = seglen;\n\t    eop->txd_pa_lo = PDQ_OS_VA_TO_PA(pdq, dataptr);\n\t    eop->txd_sop = eop->txd_eop = eop->txd_pa_hi = 0;\n\n\t    datalen -= seglen;\n\t    dataptr += seglen;\n\t    fraglen = PDQ_OS_PAGESIZE;\n\t    freecnt--;\n\t    PDQ_ADVANCE(producer, 1, PDQ_RING_MASK(dbp->pdqdb_transmits));\n\t}\n\tpdu0 = PDQ_OS_DATABUF_NEXT(pdu0);\n    }\n    if (pdu0 != NULL) {\n\tPDQ_ASSERT(freecnt == 0);\n\t/*\n\t * If we still have data to process then the ring was too full\n\t * to store the PDU.  Return FALSE so the caller will requeue\n\t * the PDU for later.\n\t */\n\treturn PDQ_FALSE;\n    }\n    /*\n     * Everything went fine.  Finish it up.\n     */\n    tx->tx_descriptor_count[tx->tx_producer] = tx->tx_free - freecnt;\n    eop->txd_eop = 1;\n    PDQ_OS_DATABUF_ENQUEUE(&tx->tx_txq, pdu);\n    tx->tx_producer = producer;\n    tx->tx_free = freecnt;\n    PDQ_DO_TYPE2_PRODUCER(pdq);\n    return PDQ_TRUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "ifq",
            "m"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <i386/isa/isavar.h>\n#include <net/if_fddi.h>\n#include <netinet/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/devconf.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nifnet_ret_t\npdq_ifstart(\n    struct ifnet *ifp)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) ((caddr_t) ifp - offsetof(pdq_softc_t, sc_ac.ac_if));\n    struct ifqueue *ifq = &ifp->if_snd;\n    struct mbuf *m;\n    int tx = 0;\n\n    if ((ifp->if_flags & IFF_RUNNING) == 0)\n\treturn;\n\n    if (sc->sc_if.if_timer == 0)\n\tsc->sc_if.if_timer = PDQ_OS_TX_TIMEOUT;\n\n    if ((sc->sc_pdq->pdq_flags & PDQ_TXOK) == 0) {\n\tsc->sc_if.if_flags |= IFF_OACTIVE;\n\treturn;\n    }\n    for (;; tx = 1) {\n\tIF_DEQUEUE(ifq, m);\n\tif (m == NULL)\n\t    break;\n\n\tif (pdq_queue_transmit_data(sc->sc_pdq, m) == PDQ_FALSE) {\n\t    ifp->if_flags |= IFF_OACTIVE;\n\t    IF_PREPEND(ifq, m);\n\t    break;\n\t}\n    }\n    if (tx)\n\tPDQ_DO_TYPE2_PRODUCER(sc->sc_pdq);\n}"
  },
  {
    "function_name": "pdq_ifwatchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq_ifsubr.c",
    "lines": "138-156",
    "snippet": "void\npdq_ifwatchdog(\n    struct ifnet *ifp)\n{\n    /*\n     * No progress was made on the transmit queue for PDQ_OS_TX_TRANSMIT\n     * seconds.  Remove all queued packets.\n     */\n\n    ifp->if_flags &= ~IFF_OACTIVE;\n    ifp->if_timer = 0;\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&ifp->if_snd, m);\n\tif (m == NULL)\n\t    return;\n\tm_freem(m);\n    }\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\"",
      "#include <vm/vm_param.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <i386/isa/isavar.h>",
      "#include <net/if_fddi.h>",
      "#include <netinet/if_fddi.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/devconf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <i386/isa/isavar.h>\n#include <net/if_fddi.h>\n#include <netinet/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/devconf.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nvoid\npdq_ifwatchdog(\n    struct ifnet *ifp)\n{\n    /*\n     * No progress was made on the transmit queue for PDQ_OS_TX_TRANSMIT\n     * seconds.  Remove all queued packets.\n     */\n\n    ifp->if_flags &= ~IFF_OACTIVE;\n    ifp->if_timer = 0;\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&ifp->if_snd, m);\n\tif (m == NULL)\n\t    return;\n\tm_freem(m);\n    }\n}"
  },
  {
    "function_name": "pdq_ifinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq_ifsubr.c",
    "lines": "108-136",
    "snippet": "void\npdq_ifinit(\n    pdq_softc_t *sc)\n{\n    if (sc->sc_if.if_flags & IFF_UP) {\n\tsc->sc_if.if_flags |= IFF_RUNNING;\n\tif (sc->sc_if.if_flags & IFF_PROMISC) {\n\t    sc->sc_pdq->pdq_flags |= PDQ_PROMISC;\n\t} else {\n\t    sc->sc_pdq->pdq_flags &= ~PDQ_PROMISC;\n\t}\n\tif (sc->sc_if.if_flags & IFF_ALLMULTI) {\n\t    sc->sc_pdq->pdq_flags |= PDQ_ALLMULTI;\n\t} else {\n\t    sc->sc_pdq->pdq_flags &= ~PDQ_ALLMULTI;\n\t}\n\tif (sc->sc_if.if_flags & IFF_LINK1) {\n\t    sc->sc_pdq->pdq_flags |= PDQ_PASS_SMT;\n\t} else {\n\t    sc->sc_pdq->pdq_flags &= ~PDQ_PASS_SMT;\n\t}\n\tsc->sc_pdq->pdq_flags |= PDQ_RUNNING;\n\tpdq_run(sc->sc_pdq);\n    } else {\n\tsc->sc_if.if_flags &= ~IFF_RUNNING;\n\tsc->sc_pdq->pdq_flags &= ~PDQ_RUNNING;\n\tpdq_stop(sc->sc_pdq);\n    }\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\"",
      "#include <vm/vm_param.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <i386/isa/isavar.h>",
      "#include <net/if_fddi.h>",
      "#include <netinet/if_fddi.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/devconf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pdq_stop",
          "args": [
            "sc->sc_pdq"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "975-1168",
          "snippet": "pdq_state_t\npdq_stop(\n    pdq_t *pdq)\n{\n    pdq_state_t state;\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    int cnt, pass = 0, idx;\n    PDQ_OS_DATABUF_T **buffers;\n\n  restart:\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    if (state != PDQS_DMA_UNAVAILABLE) {\n\tpdq_hwreset(pdq);\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\tPDQ_ASSERT(state == PDQS_DMA_UNAVAILABLE);\n    }\n#if 0\n    switch (state) {\n\tcase PDQS_RING_MEMBER:\n\tcase PDQS_LINK_UNAVAILABLE:\n\tcase PDQS_LINK_AVAILABLE: {\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_SUB_CMD_LINK_UNINIT);\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n\t    pdq_do_port_control(csrs, PDQ_PCTL_SUB_CMD);\n\t    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\t    PDQ_ASSERT(state == PDQS_DMA_AVAILABLE);\n\t    /* FALL THROUGH */\n\t}\n\tcase PDQS_DMA_AVAILABLE: {\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_a, 0);\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n\t    pdq_do_port_control(csrs, PDQ_PCTL_DMA_UNINIT);\n\t    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\t    PDQ_ASSERT(state == PDQS_DMA_UNAVAILABLE);\n\t    /* FALL THROUGH */\n\t}\n\tcase PDQS_DMA_UNAVAILABLE: {\n\t    break;\n\t}\n    }\n#endif\n    /*\n     * Now we should be in DMA_UNAVAILABLE.  So bring the PDQ into\n     * DMA_AVAILABLE.\n     */\n\n    /*\n     * Obtain the hardware address and firmware revisions\n     * (MLA = my long address which is FDDI speak for hardware address)\n     */\n    pdq_read_mla(&pdq->pdq_csrs, &pdq->pdq_hwaddr);\n    pdq_read_fwrev(&pdq->pdq_csrs, &pdq->pdq_fwrev);\n    pdq->pdq_chip_rev = pdq_read_chiprev(&pdq->pdq_csrs);\n\n    if (pdq->pdq_type == PDQ_DEFPA) {\n\t/*\n\t * Disable interrupts and DMA.\n\t */\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control, 0);\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_status, 0x10);\n    }\n\n    /*\n     * Flush all the databuf queues.\n     */\n    pdq_flush_databuf_queue(&pdq->pdq_tx_info.tx_txq);\n    pdq->pdq_flags &= ~PDQ_TXOK;\n    buffers = (PDQ_OS_DATABUF_T **) pdq->pdq_rx_info.rx_buffers;\n    for (idx = 0; idx < PDQ_RING_SIZE(pdq->pdq_dbp->pdqdb_receives); idx++) {\n\tif (buffers[idx] != NULL) {\n\t    PDQ_OS_DATABUF_FREE(buffers[idx]);\n\t    buffers[idx] = NULL;\n\t}\n    }\n    pdq->pdq_rx_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives);\n    buffers = (PDQ_OS_DATABUF_T **) pdq->pdq_host_smt_info.rx_buffers;\n    for (idx = 0; idx < PDQ_RING_SIZE(pdq->pdq_dbp->pdqdb_host_smt); idx++) {\n\tif (buffers[idx] != NULL) {\n\t    PDQ_OS_DATABUF_FREE(buffers[idx]);\n\t    buffers[idx] = NULL;\n\t}\n    }\n    pdq->pdq_host_smt_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt);\n\n    /*\n     * Reset the consumer indexes to 0.\n     */\n    pdq->pdq_cbp->pdqcb_receives = 0;\n    pdq->pdq_cbp->pdqcb_transmits = 0;\n    pdq->pdq_cbp->pdqcb_host_smt = 0;\n    pdq->pdq_cbp->pdqcb_unsolicited_event = 0;\n    pdq->pdq_cbp->pdqcb_command_response = 0;\n    pdq->pdq_cbp->pdqcb_command_request = 0;\n\n    /*\n     * Reset the producer and completion indexes to 0.\n     */\n    pdq->pdq_command_info.ci_request_producer = 0;\n    pdq->pdq_command_info.ci_response_producer = 0;\n    pdq->pdq_command_info.ci_request_completion = 0;\n    pdq->pdq_command_info.ci_response_completion = 0;\n    pdq->pdq_unsolicited_info.ui_producer = 0;\n    pdq->pdq_unsolicited_info.ui_completion = 0;\n    pdq->pdq_rx_info.rx_producer = 0;\n    pdq->pdq_rx_info.rx_completion = 0;\n    pdq->pdq_tx_info.tx_producer = 0;\n    pdq->pdq_tx_info.tx_completion = 0;\n    pdq->pdq_host_smt_info.rx_producer = 0;\n    pdq->pdq_host_smt_info.rx_completion = 0;\n\n    pdq->pdq_command_info.ci_command_active = 0;\n    pdq->pdq_unsolicited_info.ui_free = PDQ_NUM_UNSOLICITED_EVENTS;\n    pdq->pdq_tx_info.tx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_transmits);\n\n    /*\n     * Allow the DEFPA to do DMA.  Then program the physical \n     * addresses of the consumer and descriptor blocks.\n     */\n    if (pdq->pdq_type == PDQ_DEFPA) {\n#ifdef PDQTEST\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control,\n\t\t      PDQ_PFI_MODE_DMA_ENABLE);\n#else\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control,\n\t\t      PDQ_PFI_MODE_DMA_ENABLE\n\t    /*|PDQ_PFI_MODE_PFI_PCI_INTR*/|PDQ_PFI_MODE_PDQ_PCI_INTR);\n#endif\n    }\n\n    /*\n     * Make sure the unsolicited queue has events ...\n     */\n    pdq_process_unsolicited_events(pdq);\n\n    if (pdq->pdq_type == PDQ_DEFEA && pdq->pdq_chip_rev == PDQ_CHIP_REV_E)\n\tPDQ_CSR_WRITE(csrs, csr_port_data_b, PDQ_DMA_BURST_16LW);\n    else\n\tPDQ_CSR_WRITE(csrs, csr_port_data_b, PDQ_DMA_BURST_8LW);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_SUB_CMD_DMA_BURST_SIZE_SET);\n    pdq_do_port_control(csrs, PDQ_PCTL_SUB_CMD);\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_OS_VA_TO_PA(pdq, pdq->pdq_cbp));\n    pdq_do_port_control(csrs, PDQ_PCTL_CONSUMER_BLOCK);\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a,\n\t\t  PDQ_OS_VA_TO_PA(pdq, pdq->pdq_dbp) | PDQ_DMA_INIT_LW_BSWAP_DATA);\n    pdq_do_port_control(csrs, PDQ_PCTL_DMA_INIT);\n\n    for (cnt = 0; cnt < 1000; cnt++) {\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\tif (state == PDQS_HALTED) {\n\t    if (pass > 0)\n\t\treturn PDQS_HALTED;\n\t    pass = 1;\n\t    goto restart;\n\t}\n\tif (state == PDQS_DMA_AVAILABLE) {\n\t    PDQ_PRINTF((\"Transition to DMA Available took %d spins\\n\", cnt));\n\t    break;\n\t}\n\tPDQ_OS_USEC_DELAY(1000);\n    }\n    PDQ_ASSERT(state == PDQS_DMA_AVAILABLE);\n    \n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, 0xFF);\n    PDQ_CSR_WRITE(csrs, csr_host_int_enable, 0) /* PDQ_HOST_INT_STATE_CHANGE\n\t|PDQ_HOST_INT_FATAL_ERROR|PDQ_HOST_INT_CMD_RSP_ENABLE\n\t|PDQ_HOST_INT_UNSOL_ENABLE */;\n\n    /*\n     * Any other command but START should be valid.\n     */\n    pdq->pdq_command_info.ci_pending_commands &= ~(PDQ_BITMASK(PDQC_START));\n    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n    pdq_queue_commands(pdq);\n\n    if (pdq->pdq_flags & PDQ_PRINTCHARS) {\n\t/*\n\t * Now wait (up to 100ms) for the command(s) to finish.\n\t */\n\tfor (cnt = 0; cnt < 1000; cnt++) {\n\t    pdq_process_command_responses(pdq);\n\t    if (pdq->pdq_command_info.ci_response_producer == pdq->pdq_command_info.ci_response_completion)\n\t\tbreak;\n\t    PDQ_OS_USEC_DELAY(1000);\n\t}\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    }\n\n    return state;\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\npdq_state_t\npdq_stop(\n    pdq_t *pdq)\n{\n    pdq_state_t state;\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    int cnt, pass = 0, idx;\n    PDQ_OS_DATABUF_T **buffers;\n\n  restart:\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    if (state != PDQS_DMA_UNAVAILABLE) {\n\tpdq_hwreset(pdq);\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\tPDQ_ASSERT(state == PDQS_DMA_UNAVAILABLE);\n    }\n#if 0\n    switch (state) {\n\tcase PDQS_RING_MEMBER:\n\tcase PDQS_LINK_UNAVAILABLE:\n\tcase PDQS_LINK_AVAILABLE: {\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_SUB_CMD_LINK_UNINIT);\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n\t    pdq_do_port_control(csrs, PDQ_PCTL_SUB_CMD);\n\t    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\t    PDQ_ASSERT(state == PDQS_DMA_AVAILABLE);\n\t    /* FALL THROUGH */\n\t}\n\tcase PDQS_DMA_AVAILABLE: {\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_a, 0);\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n\t    pdq_do_port_control(csrs, PDQ_PCTL_DMA_UNINIT);\n\t    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\t    PDQ_ASSERT(state == PDQS_DMA_UNAVAILABLE);\n\t    /* FALL THROUGH */\n\t}\n\tcase PDQS_DMA_UNAVAILABLE: {\n\t    break;\n\t}\n    }\n#endif\n    /*\n     * Now we should be in DMA_UNAVAILABLE.  So bring the PDQ into\n     * DMA_AVAILABLE.\n     */\n\n    /*\n     * Obtain the hardware address and firmware revisions\n     * (MLA = my long address which is FDDI speak for hardware address)\n     */\n    pdq_read_mla(&pdq->pdq_csrs, &pdq->pdq_hwaddr);\n    pdq_read_fwrev(&pdq->pdq_csrs, &pdq->pdq_fwrev);\n    pdq->pdq_chip_rev = pdq_read_chiprev(&pdq->pdq_csrs);\n\n    if (pdq->pdq_type == PDQ_DEFPA) {\n\t/*\n\t * Disable interrupts and DMA.\n\t */\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control, 0);\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_status, 0x10);\n    }\n\n    /*\n     * Flush all the databuf queues.\n     */\n    pdq_flush_databuf_queue(&pdq->pdq_tx_info.tx_txq);\n    pdq->pdq_flags &= ~PDQ_TXOK;\n    buffers = (PDQ_OS_DATABUF_T **) pdq->pdq_rx_info.rx_buffers;\n    for (idx = 0; idx < PDQ_RING_SIZE(pdq->pdq_dbp->pdqdb_receives); idx++) {\n\tif (buffers[idx] != NULL) {\n\t    PDQ_OS_DATABUF_FREE(buffers[idx]);\n\t    buffers[idx] = NULL;\n\t}\n    }\n    pdq->pdq_rx_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives);\n    buffers = (PDQ_OS_DATABUF_T **) pdq->pdq_host_smt_info.rx_buffers;\n    for (idx = 0; idx < PDQ_RING_SIZE(pdq->pdq_dbp->pdqdb_host_smt); idx++) {\n\tif (buffers[idx] != NULL) {\n\t    PDQ_OS_DATABUF_FREE(buffers[idx]);\n\t    buffers[idx] = NULL;\n\t}\n    }\n    pdq->pdq_host_smt_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt);\n\n    /*\n     * Reset the consumer indexes to 0.\n     */\n    pdq->pdq_cbp->pdqcb_receives = 0;\n    pdq->pdq_cbp->pdqcb_transmits = 0;\n    pdq->pdq_cbp->pdqcb_host_smt = 0;\n    pdq->pdq_cbp->pdqcb_unsolicited_event = 0;\n    pdq->pdq_cbp->pdqcb_command_response = 0;\n    pdq->pdq_cbp->pdqcb_command_request = 0;\n\n    /*\n     * Reset the producer and completion indexes to 0.\n     */\n    pdq->pdq_command_info.ci_request_producer = 0;\n    pdq->pdq_command_info.ci_response_producer = 0;\n    pdq->pdq_command_info.ci_request_completion = 0;\n    pdq->pdq_command_info.ci_response_completion = 0;\n    pdq->pdq_unsolicited_info.ui_producer = 0;\n    pdq->pdq_unsolicited_info.ui_completion = 0;\n    pdq->pdq_rx_info.rx_producer = 0;\n    pdq->pdq_rx_info.rx_completion = 0;\n    pdq->pdq_tx_info.tx_producer = 0;\n    pdq->pdq_tx_info.tx_completion = 0;\n    pdq->pdq_host_smt_info.rx_producer = 0;\n    pdq->pdq_host_smt_info.rx_completion = 0;\n\n    pdq->pdq_command_info.ci_command_active = 0;\n    pdq->pdq_unsolicited_info.ui_free = PDQ_NUM_UNSOLICITED_EVENTS;\n    pdq->pdq_tx_info.tx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_transmits);\n\n    /*\n     * Allow the DEFPA to do DMA.  Then program the physical \n     * addresses of the consumer and descriptor blocks.\n     */\n    if (pdq->pdq_type == PDQ_DEFPA) {\n#ifdef PDQTEST\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control,\n\t\t      PDQ_PFI_MODE_DMA_ENABLE);\n#else\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control,\n\t\t      PDQ_PFI_MODE_DMA_ENABLE\n\t    /*|PDQ_PFI_MODE_PFI_PCI_INTR*/|PDQ_PFI_MODE_PDQ_PCI_INTR);\n#endif\n    }\n\n    /*\n     * Make sure the unsolicited queue has events ...\n     */\n    pdq_process_unsolicited_events(pdq);\n\n    if (pdq->pdq_type == PDQ_DEFEA && pdq->pdq_chip_rev == PDQ_CHIP_REV_E)\n\tPDQ_CSR_WRITE(csrs, csr_port_data_b, PDQ_DMA_BURST_16LW);\n    else\n\tPDQ_CSR_WRITE(csrs, csr_port_data_b, PDQ_DMA_BURST_8LW);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_SUB_CMD_DMA_BURST_SIZE_SET);\n    pdq_do_port_control(csrs, PDQ_PCTL_SUB_CMD);\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_OS_VA_TO_PA(pdq, pdq->pdq_cbp));\n    pdq_do_port_control(csrs, PDQ_PCTL_CONSUMER_BLOCK);\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a,\n\t\t  PDQ_OS_VA_TO_PA(pdq, pdq->pdq_dbp) | PDQ_DMA_INIT_LW_BSWAP_DATA);\n    pdq_do_port_control(csrs, PDQ_PCTL_DMA_INIT);\n\n    for (cnt = 0; cnt < 1000; cnt++) {\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\tif (state == PDQS_HALTED) {\n\t    if (pass > 0)\n\t\treturn PDQS_HALTED;\n\t    pass = 1;\n\t    goto restart;\n\t}\n\tif (state == PDQS_DMA_AVAILABLE) {\n\t    PDQ_PRINTF((\"Transition to DMA Available took %d spins\\n\", cnt));\n\t    break;\n\t}\n\tPDQ_OS_USEC_DELAY(1000);\n    }\n    PDQ_ASSERT(state == PDQS_DMA_AVAILABLE);\n    \n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, 0xFF);\n    PDQ_CSR_WRITE(csrs, csr_host_int_enable, 0) /* PDQ_HOST_INT_STATE_CHANGE\n\t|PDQ_HOST_INT_FATAL_ERROR|PDQ_HOST_INT_CMD_RSP_ENABLE\n\t|PDQ_HOST_INT_UNSOL_ENABLE */;\n\n    /*\n     * Any other command but START should be valid.\n     */\n    pdq->pdq_command_info.ci_pending_commands &= ~(PDQ_BITMASK(PDQC_START));\n    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n    pdq_queue_commands(pdq);\n\n    if (pdq->pdq_flags & PDQ_PRINTCHARS) {\n\t/*\n\t * Now wait (up to 100ms) for the command(s) to finish.\n\t */\n\tfor (cnt = 0; cnt < 1000; cnt++) {\n\t    pdq_process_command_responses(pdq);\n\t    if (pdq->pdq_command_info.ci_response_producer == pdq->pdq_command_info.ci_response_completion)\n\t\tbreak;\n\t    PDQ_OS_USEC_DELAY(1000);\n\t}\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    }\n\n    return state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdq_run",
          "args": [
            "sc->sc_pdq"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "1170-1242",
          "snippet": "void\npdq_run(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_state_t state;\n\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    PDQ_ASSERT(state != PDQS_DMA_UNAVAILABLE);\n    PDQ_ASSERT(state != PDQS_RESET);\n    PDQ_ASSERT(state != PDQS_HALTED);\n    PDQ_ASSERT(state != PDQS_UPGRADE);\n    PDQ_ASSERT(state != PDQS_RING_MEMBER);\n    switch (state) {\n\tcase PDQS_DMA_AVAILABLE: {\n\t    /*\n\t     * The PDQ after being reset screws up some of its state.\n\t     * So we need to clear all the errors/interrupts so the real\n\t     * ones will get through.\n\t     */\n\t    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, 0xFF);\n\t    PDQ_CSR_WRITE(csrs, csr_host_int_enable, PDQ_HOST_INT_STATE_CHANGE|PDQ_HOST_INT_XMT_DATA_FLUSH\n\t\t|PDQ_HOST_INT_FATAL_ERROR|PDQ_HOST_INT_CMD_RSP_ENABLE|PDQ_HOST_INT_UNSOL_ENABLE\n\t\t|PDQ_HOST_INT_RX_ENABLE|PDQ_HOST_INT_TX_ENABLE|PDQ_HOST_INT_HOST_SMT_ENABLE);\n\t    /*\n\t     * Set the MAC and address filters and start up the PDQ.\n\t     */\n\t    pdq_process_unsolicited_events(pdq);\n\t    pdq_process_received_data(pdq, &pdq->pdq_rx_info,\n\t\t\t\t      pdq->pdq_dbp->pdqdb_receives,\n\t\t\t\t      pdq->pdq_cbp->pdqcb_receives,\n\t\t\t\t      PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives));\n\t    PDQ_DO_TYPE2_PRODUCER(pdq);\n\t    if (pdq->pdq_flags & PDQ_PASS_SMT) {\n\t\tpdq_process_received_data(pdq, &pdq->pdq_host_smt_info,\n\t\t\t\t\t  pdq->pdq_dbp->pdqdb_host_smt,\n\t\t\t\t\t  pdq->pdq_cbp->pdqcb_host_smt,\n\t\t\t\t\t  PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt));\n\t\tPDQ_CSR_WRITE(csrs, csr_host_smt_producer,\n\t\t\t      pdq->pdq_host_smt_info.rx_producer\n\t\t\t          | (pdq->pdq_host_smt_info.rx_completion << 8));\n\t    }\n\t    pdq->pdq_command_info.ci_pending_commands = PDQ_BITMASK(PDQC_FILTER_SET)\n\t\t| PDQ_BITMASK(PDQC_ADDR_FILTER_SET) | PDQ_BITMASK(PDQC_START);\n\t    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\t\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n\t    pdq_queue_commands(pdq);\n\t    break;\n\t}\n\tcase PDQS_LINK_UNAVAILABLE:\n\tcase PDQS_LINK_AVAILABLE: {\n\t    pdq->pdq_command_info.ci_pending_commands = PDQ_BITMASK(PDQC_FILTER_SET)\n\t\t| PDQ_BITMASK(PDQC_ADDR_FILTER_SET);\n\t    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\t\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n\t    if (pdq->pdq_flags & PDQ_PASS_SMT) {\n\t\tpdq_process_received_data(pdq, &pdq->pdq_host_smt_info,\n\t\t\t\t\t  pdq->pdq_dbp->pdqdb_host_smt,\n\t\t\t\t\t  pdq->pdq_cbp->pdqcb_host_smt,\n\t\t\t\t\t  PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt));\n\t\tPDQ_CSR_WRITE(csrs, csr_host_smt_producer,\n\t\t\t      pdq->pdq_host_smt_info.rx_producer\n\t\t\t          | (pdq->pdq_host_smt_info.rx_completion << 8));\n\t    }\n\t    pdq_process_unsolicited_events(pdq);\n\t    pdq_queue_commands(pdq);\n\t    break;\n\t}\n\tcase PDQS_RING_MEMBER: {\n\t}\n\tdefault:\n    }\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nvoid\npdq_run(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_state_t state;\n\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    PDQ_ASSERT(state != PDQS_DMA_UNAVAILABLE);\n    PDQ_ASSERT(state != PDQS_RESET);\n    PDQ_ASSERT(state != PDQS_HALTED);\n    PDQ_ASSERT(state != PDQS_UPGRADE);\n    PDQ_ASSERT(state != PDQS_RING_MEMBER);\n    switch (state) {\n\tcase PDQS_DMA_AVAILABLE: {\n\t    /*\n\t     * The PDQ after being reset screws up some of its state.\n\t     * So we need to clear all the errors/interrupts so the real\n\t     * ones will get through.\n\t     */\n\t    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, 0xFF);\n\t    PDQ_CSR_WRITE(csrs, csr_host_int_enable, PDQ_HOST_INT_STATE_CHANGE|PDQ_HOST_INT_XMT_DATA_FLUSH\n\t\t|PDQ_HOST_INT_FATAL_ERROR|PDQ_HOST_INT_CMD_RSP_ENABLE|PDQ_HOST_INT_UNSOL_ENABLE\n\t\t|PDQ_HOST_INT_RX_ENABLE|PDQ_HOST_INT_TX_ENABLE|PDQ_HOST_INT_HOST_SMT_ENABLE);\n\t    /*\n\t     * Set the MAC and address filters and start up the PDQ.\n\t     */\n\t    pdq_process_unsolicited_events(pdq);\n\t    pdq_process_received_data(pdq, &pdq->pdq_rx_info,\n\t\t\t\t      pdq->pdq_dbp->pdqdb_receives,\n\t\t\t\t      pdq->pdq_cbp->pdqcb_receives,\n\t\t\t\t      PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives));\n\t    PDQ_DO_TYPE2_PRODUCER(pdq);\n\t    if (pdq->pdq_flags & PDQ_PASS_SMT) {\n\t\tpdq_process_received_data(pdq, &pdq->pdq_host_smt_info,\n\t\t\t\t\t  pdq->pdq_dbp->pdqdb_host_smt,\n\t\t\t\t\t  pdq->pdq_cbp->pdqcb_host_smt,\n\t\t\t\t\t  PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt));\n\t\tPDQ_CSR_WRITE(csrs, csr_host_smt_producer,\n\t\t\t      pdq->pdq_host_smt_info.rx_producer\n\t\t\t          | (pdq->pdq_host_smt_info.rx_completion << 8));\n\t    }\n\t    pdq->pdq_command_info.ci_pending_commands = PDQ_BITMASK(PDQC_FILTER_SET)\n\t\t| PDQ_BITMASK(PDQC_ADDR_FILTER_SET) | PDQ_BITMASK(PDQC_START);\n\t    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\t\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n\t    pdq_queue_commands(pdq);\n\t    break;\n\t}\n\tcase PDQS_LINK_UNAVAILABLE:\n\tcase PDQS_LINK_AVAILABLE: {\n\t    pdq->pdq_command_info.ci_pending_commands = PDQ_BITMASK(PDQC_FILTER_SET)\n\t\t| PDQ_BITMASK(PDQC_ADDR_FILTER_SET);\n\t    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\t\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n\t    if (pdq->pdq_flags & PDQ_PASS_SMT) {\n\t\tpdq_process_received_data(pdq, &pdq->pdq_host_smt_info,\n\t\t\t\t\t  pdq->pdq_dbp->pdqdb_host_smt,\n\t\t\t\t\t  pdq->pdq_cbp->pdqcb_host_smt,\n\t\t\t\t\t  PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt));\n\t\tPDQ_CSR_WRITE(csrs, csr_host_smt_producer,\n\t\t\t      pdq->pdq_host_smt_info.rx_producer\n\t\t\t          | (pdq->pdq_host_smt_info.rx_completion << 8));\n\t    }\n\t    pdq_process_unsolicited_events(pdq);\n\t    pdq_queue_commands(pdq);\n\t    break;\n\t}\n\tcase PDQS_RING_MEMBER: {\n\t}\n\tdefault:\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <i386/isa/isavar.h>\n#include <net/if_fddi.h>\n#include <netinet/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/devconf.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nvoid\npdq_ifinit(\n    pdq_softc_t *sc)\n{\n    if (sc->sc_if.if_flags & IFF_UP) {\n\tsc->sc_if.if_flags |= IFF_RUNNING;\n\tif (sc->sc_if.if_flags & IFF_PROMISC) {\n\t    sc->sc_pdq->pdq_flags |= PDQ_PROMISC;\n\t} else {\n\t    sc->sc_pdq->pdq_flags &= ~PDQ_PROMISC;\n\t}\n\tif (sc->sc_if.if_flags & IFF_ALLMULTI) {\n\t    sc->sc_pdq->pdq_flags |= PDQ_ALLMULTI;\n\t} else {\n\t    sc->sc_pdq->pdq_flags &= ~PDQ_ALLMULTI;\n\t}\n\tif (sc->sc_if.if_flags & IFF_LINK1) {\n\t    sc->sc_pdq->pdq_flags |= PDQ_PASS_SMT;\n\t} else {\n\t    sc->sc_pdq->pdq_flags &= ~PDQ_PASS_SMT;\n\t}\n\tsc->sc_pdq->pdq_flags |= PDQ_RUNNING;\n\tpdq_run(sc->sc_pdq);\n    } else {\n\tsc->sc_if.if_flags &= ~IFF_RUNNING;\n\tsc->sc_pdq->pdq_flags &= ~PDQ_RUNNING;\n\tpdq_stop(sc->sc_pdq);\n    }\n}"
  }
]