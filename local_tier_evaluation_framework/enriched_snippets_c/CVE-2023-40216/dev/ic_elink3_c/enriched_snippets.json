[
  {
    "function_name": "epmbufempty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "1556-1572",
    "snippet": "void\nepmbufempty(sc)\n\tstruct ep_softc *sc;\n{\n\tint s, i;\n\n\ts = splnet();\n\tfor (i = 0; i<MAX_MBS; i++) {\n\t\tif (sc->mb[i]) {\n\t\t\tm_freem(sc->mb[i]);\n\t\t\tsc->mb[i] = NULL;\n\t\t}\n\t}\n\tsc->last_mb = sc->next_mb = 0;\n\tuntimeout(epmbuffill, sc);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tepmbuffill",
      "void\tepmbufempty",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "epmbuffill",
            "sc"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->mb[i]"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepmbuffill;\nvoid\tepmbufempty;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepmbufempty(sc)\n\tstruct ep_softc *sc;\n{\n\tint s, i;\n\n\ts = splnet();\n\tfor (i = 0; i<MAX_MBS; i++) {\n\t\tif (sc->mb[i]) {\n\t\t\tm_freem(sc->mb[i]);\n\t\t\tsc->mb[i] = NULL;\n\t\t}\n\t}\n\tsc->last_mb = sc->next_mb = 0;\n\tuntimeout(epmbuffill, sc);\n\tsplx(s);\n}"
  },
  {
    "function_name": "epmbuffill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "1533-1554",
    "snippet": "void\nepmbuffill(v)\n\tvoid *v;\n{\n\tstruct ep_softc *sc = v;\n\tint s, i;\n\n\ts = splnet();\n\ti = sc->last_mb;\n\tdo {\n\t\tif (sc->mb[i] == NULL)\n\t\t\tMGET(sc->mb[i], M_DONTWAIT, MT_DATA);\n\t\tif (sc->mb[i] == NULL)\n\t\t\tbreak;\n\t\ti = (i + 1) % MAX_MBS;\n\t} while (i != sc->next_mb);\n\tsc->last_mb = i;\n\t/* If the queue was not filled, try again. */\n\tif (sc->last_mb != sc->next_mb)\n\t\ttimeout(epmbuffill, sc, 1);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tepmbuffill",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "epmbuffill",
            "sc",
            "1"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MGET",
          "args": [
            "sc->mb[i]",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepmbuffill;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepmbuffill(v)\n\tvoid *v;\n{\n\tstruct ep_softc *sc = v;\n\tint s, i;\n\n\ts = splnet();\n\ti = sc->last_mb;\n\tdo {\n\t\tif (sc->mb[i] == NULL)\n\t\t\tMGET(sc->mb[i], M_DONTWAIT, MT_DATA);\n\t\tif (sc->mb[i] == NULL)\n\t\t\tbreak;\n\t\ti = (i + 1) % MAX_MBS;\n\t} while (i != sc->next_mb);\n\tsc->last_mb = i;\n\t/* If the queue was not filled, try again. */\n\tif (sc->last_mb != sc->next_mb)\n\t\ttimeout(epmbuffill, sc, 1);\n\tsplx(s);\n}"
  },
  {
    "function_name": "epbusyeeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "1504-1531",
    "snippet": "int\nepbusyeeprom(sc)\n\tstruct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i = 100, j;\n\n\twhile (i--) {\n\t\tj = bus_space_read_2(iot, ioh, EP_W0_EEPROM_COMMAND);\n\t\tif (j & EEPROM_BUSY)\n\t\t\tdelay(100);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!i) {\n\t\tprintf(\"\\n%s: eeprom failed to come ready\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\tif (sc->bustype != EP_BUS_PCMCIA && sc->bustype != EP_BUS_PCI &&\n\t    (j & EEPROM_TST_MODE)) {\n\t\tprintf(\"\\n%s: erase pencil mark, or disable PnP mode!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tepbusyeeprom",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n%s: erase pencil mark, or disable PnP mode!\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_W0_EEPROM_COMMAND"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tepbusyeeprom;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nint\nepbusyeeprom(sc)\n\tstruct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i = 100, j;\n\n\twhile (i--) {\n\t\tj = bus_space_read_2(iot, ioh, EP_W0_EEPROM_COMMAND);\n\t\tif (j & EEPROM_BUSY)\n\t\t\tdelay(100);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!i) {\n\t\tprintf(\"\\n%s: eeprom failed to come ready\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\tif (sc->bustype != EP_BUS_PCMCIA && sc->bustype != EP_BUS_PCI &&\n\t    (j & EEPROM_TST_MODE)) {\n\t\tprintf(\"\\n%s: erase pencil mark, or disable PnP mode!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "epreadeeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "1488-1502",
    "snippet": "u_int16_t\nepreadeeprom(iot, ioh, offset)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint offset;\n{\n\tu_int16_t data = 0;\n\tint i;\n\n\tbus_space_write_1(iot, ioh, 0, 0x80 + offset);\n\tdelay(1000);\n\tfor (i = 0; i < 16; i++)\n\t\tdata = (data << 1) | (bus_space_read_2(iot, ioh, 0) & 1);\n\treturn (data);\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "0"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "0",
            "0x80 + offset"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t\nepreadeeprom(iot, ioh, offset)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint offset;\n{\n\tu_int16_t data = 0;\n\tint i;\n\n\tbus_space_write_1(iot, ioh, 0, 0x80 + offset);\n\tdelay(1000);\n\tfor (i = 0; i < 16; i++)\n\t\tdata = (data << 1) | (bus_space_read_2(iot, ioh, 0) & 1);\n\treturn (data);\n}"
  },
  {
    "function_name": "epstop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "1447-1470",
    "snippet": "void\nepstop(sc)\n\tregister struct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, RX_DISABLE);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, RX_DISCARD_TOP_PACK);\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\tbus_space_write_2(iot, ioh, EP_COMMAND, TX_DISABLE);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, STOP_TRANSCEIVER);\n\n\tep_complete_cmd(sc, EP_COMMAND, RX_RESET);\n\tep_complete_cmd(sc, EP_COMMAND, TX_RESET);\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, C_INTR_LATCH);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_RD_0_MASK);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_INTR_MASK);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_RX_FILTER);\n\n\tepmbufempty(sc);\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tepmbufempty",
      "static inline void ep_complete_cmd",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "epmbufempty",
          "args": [
            "sc"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "epmbufempty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "1556-1572",
          "snippet": "void\nepmbufempty(sc)\n\tstruct ep_softc *sc;\n{\n\tint s, i;\n\n\ts = splnet();\n\tfor (i = 0; i<MAX_MBS; i++) {\n\t\tif (sc->mb[i]) {\n\t\t\tm_freem(sc->mb[i]);\n\t\t\tsc->mb[i] = NULL;\n\t\t}\n\t}\n\tsc->last_mb = sc->next_mb = 0;\n\tuntimeout(epmbuffill, sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tepmbuffill",
            "void\tepmbufempty",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepmbuffill;\nvoid\tepmbufempty;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepmbufempty(sc)\n\tstruct ep_softc *sc;\n{\n\tint s, i;\n\n\ts = splnet();\n\tfor (i = 0; i<MAX_MBS; i++) {\n\t\tif (sc->mb[i]) {\n\t\t\tm_freem(sc->mb[i]);\n\t\t\tsc->mb[i] = NULL;\n\t\t}\n\t}\n\tsc->last_mb = sc->next_mb = 0;\n\tuntimeout(epmbuffill, sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "SET_RX_FILTER"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "SET_INTR_MASK"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "SET_RD_0_MASK"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "C_INTR_LATCH"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_complete_cmd",
          "args": [
            "sc",
            "EP_COMMAND",
            "TX_RESET"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "ep_complete_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "178-196",
          "snippet": "static inline void\nep_complete_cmd(sc, cmd, arg)\n\tstruct ep_softc *sc;\n\tu_int cmd, arg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tbus_space_write_2(iot, ioh, cmd, arg);\n\n#ifdef notyet\n\t/* if this adapter family has S_COMMAND_IN_PROGRESS, use it */\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\telse\n#else\n\tDELAY(100000);\t/* need at least 1 ms, but be generous. */\n#endif\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ep_complete_cmd",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline void ep_complete_cmd;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nstatic inline void\nep_complete_cmd(sc, cmd, arg)\n\tstruct ep_softc *sc;\n\tu_int cmd, arg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tbus_space_write_2(iot, ioh, cmd, arg);\n\n#ifdef notyet\n\t/* if this adapter family has S_COMMAND_IN_PROGRESS, use it */\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\telse\n#else\n\tDELAY(100000);\t/* need at least 1 ms, but be generous. */\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "STOP_TRANSCEIVER"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "TX_DISABLE"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_STATUS"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "RX_DISCARD_TOP_PACK"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "RX_DISABLE"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepmbufempty;\nstatic inline void ep_complete_cmd;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepstop(sc)\n\tregister struct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, RX_DISABLE);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, RX_DISCARD_TOP_PACK);\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\tbus_space_write_2(iot, ioh, EP_COMMAND, TX_DISABLE);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, STOP_TRANSCEIVER);\n\n\tep_complete_cmd(sc, EP_COMMAND, RX_RESET);\n\tep_complete_cmd(sc, EP_COMMAND, TX_RESET);\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, C_INTR_LATCH);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_RD_0_MASK);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_INTR_MASK);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_RX_FILTER);\n\n\tepmbufempty(sc);\n}"
  },
  {
    "function_name": "epwatchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "1435-1445",
    "snippet": "void\nepwatchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ep_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++sc->sc_arpcom.ac_if.if_oerrors;\n\n\tepreset(sc);\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tepwatchdog",
      "void\tepreset",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "epreset",
          "args": [
            "sc"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "epreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "1423-1433",
          "snippet": "void\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tepreset",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepreset;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: device timeout\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepwatchdog;\nvoid\tepreset;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepwatchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ep_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++sc->sc_arpcom.ac_if.if_oerrors;\n\n\tepreset(sc);\n}"
  },
  {
    "function_name": "epreset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "1423-1433",
    "snippet": "void\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tepreset",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epinit",
          "args": [
            "sc"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "epinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "523-597",
          "snippet": "void\nepinit(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\n\tif (sc->bustype != EP_BUS_PCI) {\n\t\tGO_WINDOW(0);\n\t\tbus_space_write_2(iot, ioh, EP_W0_CONFIG_CTRL, 0);\n\t\tbus_space_write_2(iot, ioh, EP_W0_CONFIG_CTRL, ENABLE_DRQ_IRQ);\n\t}\n\n\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\tbus_space_write_2(iot, ioh, EP_W0_RESOURCE_CFG, 0x3f00);\n\t}\n\n\tGO_WINDOW(2);\n\tfor (i = 0; i < 6; i++)\t/* Reload the ether_addr. */\n\t\tbus_space_write_1(iot, ioh, EP_W2_ADDR_0 + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\tif (sc->bustype == EP_BUS_PCI || sc->bustype == EP_BUS_EISA)\n\t\t/*\n\t\t * Reset the station-address receive filter.\n\t\t * A bug workaround for busmastering  (Vortex, Demon) cards.\n\t\t */\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tbus_space_write_1(iot, ioh, EP_W2_RECVMASK_0 + i, 0);\n\n\tep_complete_cmd(sc, EP_COMMAND, RX_RESET);\n\tep_complete_cmd(sc, EP_COMMAND, TX_RESET);\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\tfor (i = 0; i < 31; i++)\n\t\tbus_space_read_1(iot, ioh, EP_W1_TX_STATUS);\n\n\t/* Set threshold for for Tx-space available interrupt. */\n\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t    SET_TX_AVAIL_THRESH | (1600 >> sc->txashift));\n\n\t/* Enable interrupts. */\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_RD_0_MASK |\n\t    S_CARD_FAILURE | S_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_INTR_MASK |\n\t    S_CARD_FAILURE | S_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\n\t/*\n\t * Attempt to get rid of any stray interrupts that occured during\n\t * configuration.  On the i386 this isn't possible because one may\n\t * already be queued.  However, a single stray interrupt is\n\t * unimportant.\n\t */\n\tbus_space_write_2(iot, ioh, EP_COMMAND, ACK_INTR | 0xff);\n\n\tepsetfilter(sc);\n\tepsetmedia(sc, sc->sc_media.ifm_cur->ifm_data);\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, RX_ENABLE);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, TX_ENABLE);\n\n\tepmbuffill(sc);\n\n\t/* Interface is now `running', with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Attempt to start output, if any. */\n\tepstart(ifp);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tepstart",
            "void\tepmbuffill",
            "void\tepsetfilter",
            "int\tepsetmedia",
            "static inline void ep_complete_cmd",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepstart;\nvoid\tepmbuffill;\nvoid\tepsetfilter;\nint\tepsetmedia;\nstatic inline void ep_complete_cmd;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepinit(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\n\tif (sc->bustype != EP_BUS_PCI) {\n\t\tGO_WINDOW(0);\n\t\tbus_space_write_2(iot, ioh, EP_W0_CONFIG_CTRL, 0);\n\t\tbus_space_write_2(iot, ioh, EP_W0_CONFIG_CTRL, ENABLE_DRQ_IRQ);\n\t}\n\n\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\tbus_space_write_2(iot, ioh, EP_W0_RESOURCE_CFG, 0x3f00);\n\t}\n\n\tGO_WINDOW(2);\n\tfor (i = 0; i < 6; i++)\t/* Reload the ether_addr. */\n\t\tbus_space_write_1(iot, ioh, EP_W2_ADDR_0 + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\tif (sc->bustype == EP_BUS_PCI || sc->bustype == EP_BUS_EISA)\n\t\t/*\n\t\t * Reset the station-address receive filter.\n\t\t * A bug workaround for busmastering  (Vortex, Demon) cards.\n\t\t */\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tbus_space_write_1(iot, ioh, EP_W2_RECVMASK_0 + i, 0);\n\n\tep_complete_cmd(sc, EP_COMMAND, RX_RESET);\n\tep_complete_cmd(sc, EP_COMMAND, TX_RESET);\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\tfor (i = 0; i < 31; i++)\n\t\tbus_space_read_1(iot, ioh, EP_W1_TX_STATUS);\n\n\t/* Set threshold for for Tx-space available interrupt. */\n\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t    SET_TX_AVAIL_THRESH | (1600 >> sc->txashift));\n\n\t/* Enable interrupts. */\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_RD_0_MASK |\n\t    S_CARD_FAILURE | S_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_INTR_MASK |\n\t    S_CARD_FAILURE | S_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\n\t/*\n\t * Attempt to get rid of any stray interrupts that occured during\n\t * configuration.  On the i386 this isn't possible because one may\n\t * already be queued.  However, a single stray interrupt is\n\t * unimportant.\n\t */\n\tbus_space_write_2(iot, ioh, EP_COMMAND, ACK_INTR | 0xff);\n\n\tepsetfilter(sc);\n\tepsetmedia(sc, sc->sc_media.ifm_cur->ifm_data);\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, RX_ENABLE);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, TX_ENABLE);\n\n\tepmbuffill(sc);\n\n\t/* Interface is now `running', with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Attempt to start output, if any. */\n\tepstart(ifp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "epstop",
          "args": [
            "sc"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "epstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "1447-1470",
          "snippet": "void\nepstop(sc)\n\tregister struct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, RX_DISABLE);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, RX_DISCARD_TOP_PACK);\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\tbus_space_write_2(iot, ioh, EP_COMMAND, TX_DISABLE);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, STOP_TRANSCEIVER);\n\n\tep_complete_cmd(sc, EP_COMMAND, RX_RESET);\n\tep_complete_cmd(sc, EP_COMMAND, TX_RESET);\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, C_INTR_LATCH);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_RD_0_MASK);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_INTR_MASK);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_RX_FILTER);\n\n\tepmbufempty(sc);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tepmbufempty",
            "static inline void ep_complete_cmd",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepmbufempty;\nstatic inline void ep_complete_cmd;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepstop(sc)\n\tregister struct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, RX_DISABLE);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, RX_DISCARD_TOP_PACK);\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\tbus_space_write_2(iot, ioh, EP_COMMAND, TX_DISABLE);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, STOP_TRANSCEIVER);\n\n\tep_complete_cmd(sc, EP_COMMAND, RX_RESET);\n\tep_complete_cmd(sc, EP_COMMAND, TX_RESET);\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, C_INTR_LATCH);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_RD_0_MASK);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_INTR_MASK);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_RX_FILTER);\n\n\tepmbufempty(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepreset;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}"
  },
  {
    "function_name": "epioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "1329-1421",
    "snippet": "int\nepioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ep_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tepinit(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tepinit(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFMEDIA:\n\tcase SIOCGIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tepstop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tepinit(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * deal with flags changes:\n\t\t\t * IFF_MULTICAST, IFF_PROMISC,\n\t\t\t * IFF_LINK0, IFF_LINK1.\n\t\t\t */\n\t\t\tepsetfilter(sc);\n/*\t\t\tepsetmedia(sc, sc->sc_media);*/\t/* XXX */\n\t\t\tepsetmedia(sc, sc->sc_media.ifm_cur->ifm_data);\n\t\t}\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom) :\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tepreset(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tepioctl",
      "void\tepreset",
      "void\tepsetfilter",
      "int\tepsetmedia",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epreset",
          "args": [
            "sc"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "epreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "1423-1433",
          "snippet": "void\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tepreset",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepreset;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epsetmedia",
          "args": [
            "sc",
            "sc->sc_media.ifm_cur->ifm_data"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "epsetmedia",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "634-746",
          "snippet": "int\nepsetmedia(sc, medium)\n\tstruct ep_softc *sc;\n\tint medium;\n{\n/*\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;*/\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint w4_media;\n\tint config0, config1;\n\n\t/*\n\t * you can `ifconfig (link0|-link0) ep0' to get the following\n\t * behaviour:\n\t *\t-link0\tdisable AUI/UTP. enable BNC.\n\t *\tlink0\tdisable BNC. enable AUI.\n\t *\tlink1\tif the card has a UTP connector, and link0 is\n\t *\t\tset too, then you get the UTP port.\n\t */\n\n\t/*\n\t * First, change the media-control bits in EP_W4_MEDIA_TYPE.\n\t */\n\n\t /* Turn everything off.  First turn off linkbeat and UTP. */\n\tGO_WINDOW(4);\n\tw4_media = bus_space_read_2(iot, ioh, EP_W4_MEDIA_TYPE);\n\tw4_media =  w4_media & ~(ENABLE_UTP|SQE_ENABLE);\n\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE, w4_media);\n\n\t/* Turn off coax */\n\tbus_space_write_2(iot, ioh, EP_COMMAND, STOP_TRANSCEIVER);\n\tdelay(1000);\n\n\t/*\n\t * Now turn on the selected media/transceiver.\n\t */\n\tGO_WINDOW(4);\n\tswitch  (medium) {\n\tcase EPMEDIA_10BASE_T:\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | ENABLE_UTP);\n\t\tbreak;\n\n\tcase EPMEDIA_10BASE_2:\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND, START_TRANSCEIVER);\n\t\tDELAY(1000);\t/* 50ms not enough? */\n\t\tbreak;\n\n\t/* XXX following only for new-generation cards */\n\tcase EPMEDIA_100BASE_TX:\n\tcase EPMEDIA_100BASE_FX:\n\tcase EPMEDIA_100BASE_T4:\t/* XXX check documentation */\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | LINKBEAT_ENABLE);\n\t\tDELAY(1000);\t/* not strictly necessary? */\n\t\tbreak;\n\n\tcase EPMEDIA_AUI:\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | SQE_ENABLE);\n\t\tDELAY(1000);\t/*  not strictly necessary? */\n\t\tbreak;\n\tcase EPMEDIA_MII:\n\t\tbreak;\n\tdefault:\n#if defined(EP_DEBUG)\n\t\tprintf(\"%s unknown media 0x%x\\n\", sc->sc_dev.dv_xname, medium);\n#endif\n\t\tbreak;\n\t\t\n\t}\n\n\t/*\n\t * Tell the chip which PHY [sic] to use.\n\t */\n\tswitch (sc->ep_chipset) {\n\tcase EP_CHIPSET_VORTEX:\n\tcase EP_CHIPSET_BOOMERANG2:\n\t\tGO_WINDOW(3);\n\t\tconfig0 = (u_int)bus_space_read_2(iot, ioh,\n\t\t    EP_W3_INTERNAL_CONFIG);\n\t\tconfig1 = (u_int)bus_space_read_2(iot, ioh,\n\t\t    EP_W3_INTERNAL_CONFIG + 2);\n\n#if defined(EP_DEBUG)\n\t\tprintf(\"%s:  read 0x%x, 0x%x from EP_W3_CONFIG register\\n\",\n\t\t       sc->sc_dev.dv_xname, config0, config1);\n#endif\n\t\tconfig1 = config1 & ~CONFIG_MEDIAMASK;\n\t\tconfig1 |= (medium << CONFIG_MEDIAMASK_SHIFT);\n\t\t\n#if defined(EP_DEBUG)\n\t\tprintf(\"epsetmedia: %s: medium 0x%x, 0x%x to EP_W3_CONFIG\\n\",\n\t\t    sc->sc_dev.dv_xname, medium, config1);\n#endif\n\t\tbus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG, config0);\n\t\tbus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2, config1);\n\t\tbreak;\n\n\tcase EP_CHIPSET_3C509:\n\t\tGO_WINDOW(0);\n\t\tconfig0 = bus_space_read_2(iot, ioh, EP_W0_ADDRESS_CFG);\n\t\tconfig0 &= 0x3fff;\n\t\tbus_space_write_2(iot, ioh, EP_W0_ADDRESS_CFG,\n\t\t    config0 | (medium << 14));\n\t\tDELAY(1000);\n\t\tbreak;\n\t}\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tepsetmedia",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tepsetmedia;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nint\nepsetmedia(sc, medium)\n\tstruct ep_softc *sc;\n\tint medium;\n{\n/*\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;*/\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint w4_media;\n\tint config0, config1;\n\n\t/*\n\t * you can `ifconfig (link0|-link0) ep0' to get the following\n\t * behaviour:\n\t *\t-link0\tdisable AUI/UTP. enable BNC.\n\t *\tlink0\tdisable BNC. enable AUI.\n\t *\tlink1\tif the card has a UTP connector, and link0 is\n\t *\t\tset too, then you get the UTP port.\n\t */\n\n\t/*\n\t * First, change the media-control bits in EP_W4_MEDIA_TYPE.\n\t */\n\n\t /* Turn everything off.  First turn off linkbeat and UTP. */\n\tGO_WINDOW(4);\n\tw4_media = bus_space_read_2(iot, ioh, EP_W4_MEDIA_TYPE);\n\tw4_media =  w4_media & ~(ENABLE_UTP|SQE_ENABLE);\n\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE, w4_media);\n\n\t/* Turn off coax */\n\tbus_space_write_2(iot, ioh, EP_COMMAND, STOP_TRANSCEIVER);\n\tdelay(1000);\n\n\t/*\n\t * Now turn on the selected media/transceiver.\n\t */\n\tGO_WINDOW(4);\n\tswitch  (medium) {\n\tcase EPMEDIA_10BASE_T:\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | ENABLE_UTP);\n\t\tbreak;\n\n\tcase EPMEDIA_10BASE_2:\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND, START_TRANSCEIVER);\n\t\tDELAY(1000);\t/* 50ms not enough? */\n\t\tbreak;\n\n\t/* XXX following only for new-generation cards */\n\tcase EPMEDIA_100BASE_TX:\n\tcase EPMEDIA_100BASE_FX:\n\tcase EPMEDIA_100BASE_T4:\t/* XXX check documentation */\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | LINKBEAT_ENABLE);\n\t\tDELAY(1000);\t/* not strictly necessary? */\n\t\tbreak;\n\n\tcase EPMEDIA_AUI:\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | SQE_ENABLE);\n\t\tDELAY(1000);\t/*  not strictly necessary? */\n\t\tbreak;\n\tcase EPMEDIA_MII:\n\t\tbreak;\n\tdefault:\n#if defined(EP_DEBUG)\n\t\tprintf(\"%s unknown media 0x%x\\n\", sc->sc_dev.dv_xname, medium);\n#endif\n\t\tbreak;\n\t\t\n\t}\n\n\t/*\n\t * Tell the chip which PHY [sic] to use.\n\t */\n\tswitch (sc->ep_chipset) {\n\tcase EP_CHIPSET_VORTEX:\n\tcase EP_CHIPSET_BOOMERANG2:\n\t\tGO_WINDOW(3);\n\t\tconfig0 = (u_int)bus_space_read_2(iot, ioh,\n\t\t    EP_W3_INTERNAL_CONFIG);\n\t\tconfig1 = (u_int)bus_space_read_2(iot, ioh,\n\t\t    EP_W3_INTERNAL_CONFIG + 2);\n\n#if defined(EP_DEBUG)\n\t\tprintf(\"%s:  read 0x%x, 0x%x from EP_W3_CONFIG register\\n\",\n\t\t       sc->sc_dev.dv_xname, config0, config1);\n#endif\n\t\tconfig1 = config1 & ~CONFIG_MEDIAMASK;\n\t\tconfig1 |= (medium << CONFIG_MEDIAMASK_SHIFT);\n\t\t\n#if defined(EP_DEBUG)\n\t\tprintf(\"epsetmedia: %s: medium 0x%x, 0x%x to EP_W3_CONFIG\\n\",\n\t\t    sc->sc_dev.dv_xname, medium, config1);\n#endif\n\t\tbus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG, config0);\n\t\tbus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2, config1);\n\t\tbreak;\n\n\tcase EP_CHIPSET_3C509:\n\t\tGO_WINDOW(0);\n\t\tconfig0 = bus_space_read_2(iot, ioh, EP_W0_ADDRESS_CFG);\n\t\tconfig0 &= 0x3fff;\n\t\tbus_space_write_2(iot, ioh, EP_W0_ADDRESS_CFG,\n\t\t    config0 | (medium << 14));\n\t\tDELAY(1000);\n\t\tbreak;\n\t}\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "epsetfilter",
          "args": [
            "sc"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "epsetfilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "604-615",
          "snippet": "void\nepsetfilter(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\tbus_space_write_2(sc->sc_iot, sc->sc_ioh, EP_COMMAND, SET_RX_FILTER |\n\t    FIL_INDIVIDUAL | FIL_BRDCST |\n\t    ((ifp->if_flags & IFF_MULTICAST) ? FIL_MULTICAST : 0 ) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? FIL_PROMISC : 0 ));\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tepsetfilter",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepsetfilter;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepsetfilter(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\tbus_space_write_2(sc->sc_iot, sc->sc_ioh, EP_COMMAND, SET_RX_FILTER |\n\t    FIL_INDIVIDUAL | FIL_BRDCST |\n\t    ((ifp->if_flags & IFF_MULTICAST) ? FIL_MULTICAST : 0 ) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? FIL_PROMISC : 0 ));\n}"
        }
      },
      {
        "call_info": {
          "callee": "epinit",
          "args": [
            "sc"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "epinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "523-597",
          "snippet": "void\nepinit(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\n\tif (sc->bustype != EP_BUS_PCI) {\n\t\tGO_WINDOW(0);\n\t\tbus_space_write_2(iot, ioh, EP_W0_CONFIG_CTRL, 0);\n\t\tbus_space_write_2(iot, ioh, EP_W0_CONFIG_CTRL, ENABLE_DRQ_IRQ);\n\t}\n\n\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\tbus_space_write_2(iot, ioh, EP_W0_RESOURCE_CFG, 0x3f00);\n\t}\n\n\tGO_WINDOW(2);\n\tfor (i = 0; i < 6; i++)\t/* Reload the ether_addr. */\n\t\tbus_space_write_1(iot, ioh, EP_W2_ADDR_0 + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\tif (sc->bustype == EP_BUS_PCI || sc->bustype == EP_BUS_EISA)\n\t\t/*\n\t\t * Reset the station-address receive filter.\n\t\t * A bug workaround for busmastering  (Vortex, Demon) cards.\n\t\t */\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tbus_space_write_1(iot, ioh, EP_W2_RECVMASK_0 + i, 0);\n\n\tep_complete_cmd(sc, EP_COMMAND, RX_RESET);\n\tep_complete_cmd(sc, EP_COMMAND, TX_RESET);\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\tfor (i = 0; i < 31; i++)\n\t\tbus_space_read_1(iot, ioh, EP_W1_TX_STATUS);\n\n\t/* Set threshold for for Tx-space available interrupt. */\n\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t    SET_TX_AVAIL_THRESH | (1600 >> sc->txashift));\n\n\t/* Enable interrupts. */\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_RD_0_MASK |\n\t    S_CARD_FAILURE | S_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_INTR_MASK |\n\t    S_CARD_FAILURE | S_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\n\t/*\n\t * Attempt to get rid of any stray interrupts that occured during\n\t * configuration.  On the i386 this isn't possible because one may\n\t * already be queued.  However, a single stray interrupt is\n\t * unimportant.\n\t */\n\tbus_space_write_2(iot, ioh, EP_COMMAND, ACK_INTR | 0xff);\n\n\tepsetfilter(sc);\n\tepsetmedia(sc, sc->sc_media.ifm_cur->ifm_data);\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, RX_ENABLE);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, TX_ENABLE);\n\n\tepmbuffill(sc);\n\n\t/* Interface is now `running', with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Attempt to start output, if any. */\n\tepstart(ifp);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tepstart",
            "void\tepmbuffill",
            "void\tepsetfilter",
            "int\tepsetmedia",
            "static inline void ep_complete_cmd",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepstart;\nvoid\tepmbuffill;\nvoid\tepsetfilter;\nint\tepsetmedia;\nstatic inline void ep_complete_cmd;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepinit(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\n\tif (sc->bustype != EP_BUS_PCI) {\n\t\tGO_WINDOW(0);\n\t\tbus_space_write_2(iot, ioh, EP_W0_CONFIG_CTRL, 0);\n\t\tbus_space_write_2(iot, ioh, EP_W0_CONFIG_CTRL, ENABLE_DRQ_IRQ);\n\t}\n\n\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\tbus_space_write_2(iot, ioh, EP_W0_RESOURCE_CFG, 0x3f00);\n\t}\n\n\tGO_WINDOW(2);\n\tfor (i = 0; i < 6; i++)\t/* Reload the ether_addr. */\n\t\tbus_space_write_1(iot, ioh, EP_W2_ADDR_0 + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\tif (sc->bustype == EP_BUS_PCI || sc->bustype == EP_BUS_EISA)\n\t\t/*\n\t\t * Reset the station-address receive filter.\n\t\t * A bug workaround for busmastering  (Vortex, Demon) cards.\n\t\t */\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tbus_space_write_1(iot, ioh, EP_W2_RECVMASK_0 + i, 0);\n\n\tep_complete_cmd(sc, EP_COMMAND, RX_RESET);\n\tep_complete_cmd(sc, EP_COMMAND, TX_RESET);\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\tfor (i = 0; i < 31; i++)\n\t\tbus_space_read_1(iot, ioh, EP_W1_TX_STATUS);\n\n\t/* Set threshold for for Tx-space available interrupt. */\n\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t    SET_TX_AVAIL_THRESH | (1600 >> sc->txashift));\n\n\t/* Enable interrupts. */\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_RD_0_MASK |\n\t    S_CARD_FAILURE | S_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_INTR_MASK |\n\t    S_CARD_FAILURE | S_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\n\t/*\n\t * Attempt to get rid of any stray interrupts that occured during\n\t * configuration.  On the i386 this isn't possible because one may\n\t * already be queued.  However, a single stray interrupt is\n\t * unimportant.\n\t */\n\tbus_space_write_2(iot, ioh, EP_COMMAND, ACK_INTR | 0xff);\n\n\tepsetfilter(sc);\n\tepsetmedia(sc, sc->sc_media.ifm_cur->ifm_data);\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, RX_ENABLE);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, TX_ENABLE);\n\n\tepmbuffill(sc);\n\n\t/* Interface is now `running', with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Attempt to start output, if any. */\n\tepstart(ifp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "epstop",
          "args": [
            "sc"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "epstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "1447-1470",
          "snippet": "void\nepstop(sc)\n\tregister struct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, RX_DISABLE);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, RX_DISCARD_TOP_PACK);\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\tbus_space_write_2(iot, ioh, EP_COMMAND, TX_DISABLE);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, STOP_TRANSCEIVER);\n\n\tep_complete_cmd(sc, EP_COMMAND, RX_RESET);\n\tep_complete_cmd(sc, EP_COMMAND, TX_RESET);\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, C_INTR_LATCH);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_RD_0_MASK);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_INTR_MASK);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_RX_FILTER);\n\n\tepmbufempty(sc);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tepmbufempty",
            "static inline void ep_complete_cmd",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepmbufempty;\nstatic inline void ep_complete_cmd;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepstop(sc)\n\tregister struct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, RX_DISABLE);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, RX_DISCARD_TOP_PACK);\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\tbus_space_write_2(iot, ioh, EP_COMMAND, TX_DISABLE);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, STOP_TRANSCEIVER);\n\n\tep_complete_cmd(sc, EP_COMMAND, RX_RESET);\n\tep_complete_cmd(sc, EP_COMMAND, TX_RESET);\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, C_INTR_LATCH);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_RD_0_MASK);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_INTR_MASK);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_RX_FILTER);\n\n\tepmbufempty(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&sc->sc_media",
            "cmd"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->sc_arpcom",
            "ifa"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "&sc->sc_arpcom",
            "cmd",
            "data"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "301-348",
          "snippet": "int\nfxp_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tfxp_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t /* Set new address. */\n\t\t\t fxp_init(sc);\n\t\t\t break;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tfxp_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fxp_init",
            "int\tfxp_ether_ioctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid fxp_init;\nint\tfxp_ether_ioctl;\n\nint\nfxp_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tfxp_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t /* Set new address. */\n\t\t\t fxp_init(sc);\n\t\t\t break;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tfxp_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tepioctl;\nvoid\tepreset;\nvoid\tepsetfilter;\nint\tepsetmedia;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nint\nepioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ep_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tepinit(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tepinit(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFMEDIA:\n\tcase SIOCGIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tepstop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tepinit(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * deal with flags changes:\n\t\t\t * IFF_MULTICAST, IFF_PROMISC,\n\t\t\t * IFF_LINK0, IFF_LINK1.\n\t\t\t */\n\t\t\tepsetfilter(sc);\n/*\t\t\tepsetmedia(sc, sc->sc_media);*/\t/* XXX */\n\t\t\tepsetmedia(sc, sc->sc_media.ifm_cur->ifm_data);\n\t\t}\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom) :\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tepreset(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}"
  },
  {
    "function_name": "epread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "1109-1220",
    "snippet": "void\nepread(sc)\n\tregister struct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\tint len;\n\n\tlen = bus_space_read_2(iot, ioh, EP_W1_RX_STATUS);\n\nagain:\n#ifdef EP_DEBUG\n\tif (ifp->if_flags & IFF_DEBUG) {\n\t\tint err = len & ERR_MASK;\n\t\tchar *s = NULL;\n\n\t\tif (len & ERR_INCOMPLETE)\n\t\t\ts = \"incomplete packet\";\n\t\telse if (err == ERR_OVERRUN)\n\t\t\ts = \"packet overrun\";\n\t\telse if (err == ERR_RUNT)\n\t\t\ts = \"runt packet\";\n\t\telse if (err == ERR_ALIGNMENT)\n\t\t\ts = \"bad alignment\";\n\t\telse if (err == ERR_CRC)\n\t\t\ts = \"bad crc\";\n\t\telse if (err == ERR_OVERSIZE)\n\t\t\ts = \"oversized packet\";\n\t\telse if (err == ERR_DRIBBLE)\n\t\t\ts = \"dribble bits\";\n\n\t\tif (s)\n\t\t\tprintf(\"%s: %s\\n\", sc->sc_dev.dv_xname, s);\n\t}\n#endif\n\n\tif (len & ERR_INCOMPLETE)\n\t\treturn;\n\n\tif (len & ERR_RX) {\n\t\t++ifp->if_ierrors;\n\t\tgoto abort;\n\t}\n\n\tlen &= RX_BYTES_MASK;\t/* Lower 11 bits = RX bytes. */\n\n\t/* Pull packet off interface. */\n\tm = epget(sc, len);\n\tif (m == 0) {\n\t\tifp->if_ierrors++;\n\t\tgoto abort;\n\t}\n\n\t++ifp->if_ipackets;\n\n\t/* We assume the header fit entirely in one mbuf. */\n\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.\n\t * If so, hand off the raw packet to BPF.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t/* We assume the header fit entirely in one mbuf. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n\n\t/*\n\t * In periods of high traffic we can actually receive enough\n\t * packets so that the fifo overrun bit will be set at this point,\n\t * even though we just read a packet. In this case we\n\t * are not going to receive any more interrupts. We check for\n\t * this condition and read again until the fifo is not full.\n\t * We could simplify this test by not using epstatus(), but\n\t * rechecking the RX_STATUS register directly. This test could\n\t * result in unnecessary looping in cases where there is a new\n\t * packet but the fifo is not full, but it will not fix the\n\t * stuck behavior.\n\t *\n\t * Even with this improvement, we still get packet overrun errors\n\t * which are hurting performance. Maybe when I get some more time\n\t * I'll modify epread() so that it can handle RX_EARLY interrupts.\n\t */\n\tif (epstatus(sc)) {\n\t\tlen = bus_space_read_2(iot, ioh, EP_W1_RX_STATUS);\n\t\t/* Check if we are stuck and reset [see XXX comment] */\n\t\tif (len & ERR_INCOMPLETE) {\n#ifdef EP_DEBUG\n\t\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: adapter reset\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\t\tepreset(sc);\n\t\t\treturn;\n\t\t}\n\t\tgoto again;\n\t}\n\n\treturn;\n\nabort:\n\tbus_space_write_2(iot, ioh, EP_COMMAND, RX_DISCARD_TOP_PACK);\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tepstatus",
      "void\tepreset",
      "void\tepread",
      "struct mbuf *epget",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_STATUS"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "RX_DISCARD_TOP_PACK"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epreset",
          "args": [
            "sc"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "epreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "1423-1433",
          "snippet": "void\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tepreset",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepreset;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: adapter reset\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_W1_RX_STATUS"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epstatus",
          "args": [
            "sc"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "epstatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "958-1008",
          "snippet": "int\nepstatus(sc)\n\tregister struct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t fifost;\n\n\t/*\n\t * Check the FIFO status and act accordingly\n\t */\n\tGO_WINDOW(4);\n\tfifost = bus_space_read_2(iot, ioh, EP_W4_FIFO_DIAG);\n\tGO_WINDOW(1);\n\n\tif (fifost & FIFOS_RX_UNDERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX underrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\tif (fifost & FIFOS_RX_STATUS_OVERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX Status overrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_RX_OVERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX overrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_TX_OVERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: TX overrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tepstatus",
            "void\tepreset",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tepstatus;\nvoid\tepreset;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nint\nepstatus(sc)\n\tregister struct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t fifost;\n\n\t/*\n\t * Check the FIFO status and act accordingly\n\t */\n\tGO_WINDOW(4);\n\tfifost = bus_space_read_2(iot, ioh, EP_W4_FIFO_DIAG);\n\tGO_WINDOW(1);\n\n\tif (fifost & FIFOS_RX_UNDERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX underrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\tif (fifost & FIFOS_RX_STATUS_OVERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX Status overrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_RX_OVERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX overrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_TX_OVERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: TX overrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "sizeof(struct ether_header)"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epget",
          "args": [
            "sc",
            "len"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_W1_RX_STATUS"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tepstatus;\nvoid\tepreset;\nvoid\tepread;\nstruct mbuf *epget;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepread(sc)\n\tregister struct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\tint len;\n\n\tlen = bus_space_read_2(iot, ioh, EP_W1_RX_STATUS);\n\nagain:\n#ifdef EP_DEBUG\n\tif (ifp->if_flags & IFF_DEBUG) {\n\t\tint err = len & ERR_MASK;\n\t\tchar *s = NULL;\n\n\t\tif (len & ERR_INCOMPLETE)\n\t\t\ts = \"incomplete packet\";\n\t\telse if (err == ERR_OVERRUN)\n\t\t\ts = \"packet overrun\";\n\t\telse if (err == ERR_RUNT)\n\t\t\ts = \"runt packet\";\n\t\telse if (err == ERR_ALIGNMENT)\n\t\t\ts = \"bad alignment\";\n\t\telse if (err == ERR_CRC)\n\t\t\ts = \"bad crc\";\n\t\telse if (err == ERR_OVERSIZE)\n\t\t\ts = \"oversized packet\";\n\t\telse if (err == ERR_DRIBBLE)\n\t\t\ts = \"dribble bits\";\n\n\t\tif (s)\n\t\t\tprintf(\"%s: %s\\n\", sc->sc_dev.dv_xname, s);\n\t}\n#endif\n\n\tif (len & ERR_INCOMPLETE)\n\t\treturn;\n\n\tif (len & ERR_RX) {\n\t\t++ifp->if_ierrors;\n\t\tgoto abort;\n\t}\n\n\tlen &= RX_BYTES_MASK;\t/* Lower 11 bits = RX bytes. */\n\n\t/* Pull packet off interface. */\n\tm = epget(sc, len);\n\tif (m == 0) {\n\t\tifp->if_ierrors++;\n\t\tgoto abort;\n\t}\n\n\t++ifp->if_ipackets;\n\n\t/* We assume the header fit entirely in one mbuf. */\n\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.\n\t * If so, hand off the raw packet to BPF.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t/* We assume the header fit entirely in one mbuf. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n\n\t/*\n\t * In periods of high traffic we can actually receive enough\n\t * packets so that the fifo overrun bit will be set at this point,\n\t * even though we just read a packet. In this case we\n\t * are not going to receive any more interrupts. We check for\n\t * this condition and read again until the fifo is not full.\n\t * We could simplify this test by not using epstatus(), but\n\t * rechecking the RX_STATUS register directly. This test could\n\t * result in unnecessary looping in cases where there is a new\n\t * packet but the fifo is not full, but it will not fix the\n\t * stuck behavior.\n\t *\n\t * Even with this improvement, we still get packet overrun errors\n\t * which are hurting performance. Maybe when I get some more time\n\t * I'll modify epread() so that it can handle RX_EARLY interrupts.\n\t */\n\tif (epstatus(sc)) {\n\t\tlen = bus_space_read_2(iot, ioh, EP_W1_RX_STATUS);\n\t\t/* Check if we are stuck and reset [see XXX comment] */\n\t\tif (len & ERR_INCOMPLETE) {\n#ifdef EP_DEBUG\n\t\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: adapter reset\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\t\tepreset(sc);\n\t\t\treturn;\n\t\t}\n\t\tgoto again;\n\t}\n\n\treturn;\n\nabort:\n\tbus_space_write_2(iot, ioh, EP_COMMAND, RX_DISCARD_TOP_PACK);\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n}"
  },
  {
    "function_name": "epintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "1057-1107",
    "snippet": "int\nepintr(arg)\n\tvoid *arg;\n{\n\tregister struct ep_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_int16_t status;\n\tint ret = 0;\n\n\tfor (;;) {\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND, C_INTR_LATCH);\n\n\t\tstatus = bus_space_read_2(iot, ioh, EP_STATUS);\n\n\t\tif ((status & (S_TX_COMPLETE | S_TX_AVAIL |\n\t\t\t       S_RX_COMPLETE | S_CARD_FAILURE)) == 0)\n\t\t\tbreak;\n\n\t\tret = 1;\n\n\t\t/*\n\t\t * Acknowledge any interrupts.  It's important that we do this\n\t\t * first, since there would otherwise be a race condition.\n\t\t * Due to the i386 interrupt queueing, we may get spurious\n\t\t * interrupts occasionally.\n\t\t */\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND, ACK_INTR | status);\n\n\t\tif (status & S_RX_COMPLETE)\n\t\t\tepread(sc);\n\t\tif (status & S_TX_AVAIL) {\n\t\t\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\t\t\tepstart(&sc->sc_arpcom.ac_if);\n\t\t}\n\t\tif (status & S_CARD_FAILURE) {\n\t\t\tprintf(\"%s: adapter failure (%x)\\n\",\n\t\t\t    sc->sc_dev.dv_xname, status);\n\t\t\tepreset(sc);\n\t\t\treturn (1);\n\t\t}\n\t\tif (status & S_TX_COMPLETE) {\n\t\t\teptxstat(sc);\n\t\t\tepstart(ifp);\n\t\t}\n\t}\t\n\n\t/* no more interrupts */\n\treturn (ret);\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\teptxstat",
      "void\tepstart",
      "void\tepreset",
      "void\tepread",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "epstart",
          "args": [
            "ifp"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "epstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "813-948",
          "snippet": "void\nepstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ep_softc *sc = ifp->if_softc;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct mbuf *m, *m0;\n\tint sh, len, pad;\n\n\t/* Don't transmit if interface is busy or not running */\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\nstartagain:\n\t/* Sneak a peek at the next packet */\n\tm0 = ifp->if_snd.ifq_head;\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"epstart: no header mbuf\");\n\tlen = m0->m_pkthdr.len;\n\n\tpad = (4 - len) & 3;\n\n\t/*\n\t * The 3c509 automatically pads short packets to minimum ethernet\n\t * length, but we drop packets that are too large. Perhaps we should\n\t * truncate them instead?\n\t */\n\tif (len + pad > ETHER_MAX_LEN) {\n\t\t/* packet is obviously too large: toss it */\n\t\t++ifp->if_oerrors;\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tm_freem(m0);\n\t\tgoto readcheck;\n\t}\n\n\tif (bus_space_read_2(iot, ioh, EP_W1_FREE_TX) < len + pad + 4) {\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t\t    SET_TX_AVAIL_THRESH | ((len + pad + 4) >> sc->txashift));\n\t\t/* not enough room in FIFO */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t} else {\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t\t    SET_TX_AVAIL_THRESH | EP_THRESH_DISABLE);\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\t\t/* not really needed */\n\t\treturn;\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_TX_START_THRESH |\n\t    ((len / 4 + sc->tx_start_thresh) /*>> sc->txashift*/));\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/*\n\t * Do the output at splhigh() so that an interrupt from another device\n\t * won't cause a FIFO underrun.\n\t */\n\tsh = splhigh();\n\n\tbus_space_write_2(iot, ioh, EP_W1_TX_PIO_WR_1, len);\n\tbus_space_write_2(iot, ioh, EP_W1_TX_PIO_WR_1,\n\t    0xffff);\t/* Second dword meaningless */\n\tif (EP_IS_BUS_32(sc->bustype)) {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 3)\n\t\t\t\tbus_space_write_raw_multi_4(iot, ioh,\n\t\t\t\t    EP_W1_TX_PIO_WR_1, mtod(m, u_int8_t *),\n\t\t\t\t    m->m_len & ~3);\n\t\t\tif (m->m_len & 3)\n\t\t\t\tbus_space_write_multi_1(iot, ioh,\n\t\t\t\t    EP_W1_TX_PIO_WR_1,\n\t\t\t\t    mtod(m, u_int8_t *) + (m->m_len & ~3),\n\t\t\t\t    m->m_len & 3);\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t} else {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 1)\n\t\t\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t\t\t    EP_W1_TX_PIO_WR_1, mtod(m, u_int8_t *),\n\t\t\t\t    m->m_len & ~1);\n\t\t\tif (m->m_len & 1)\n\t\t\t\tbus_space_write_1(iot, ioh, EP_W1_TX_PIO_WR_1,\n\t\t\t\t     *(mtod(m, u_int8_t *) + m->m_len - 1));\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t}\n\twhile (pad--)\n\t\tbus_space_write_1(iot, ioh, EP_W1_TX_PIO_WR_1, 0);\n\n\tsplx(sh);\n\n\t++ifp->if_opackets;\n\nreadcheck:\n\tif ((bus_space_read_2(iot, ioh, EP_W1_RX_STATUS) & ERR_INCOMPLETE) ==\n\t    0) {\n\t\t/* We received a complete packet. */\n\t\tu_int16_t status = bus_space_read_2(iot, ioh, EP_STATUS);\n\n\t\tif ((status & S_INTR_LATCH) == 0) {\n\t\t\t/*\n\t\t\t * No interrupt, read the packet and continue\n\t\t\t * Is  this supposed to happen? Is my motherboard \n\t\t\t * completely busted?\n\t\t\t */\n\t\t\tepread(sc);\n\t\t} else\n\t\t\t/* Got an interrupt, return to get it serviced. */\n\t\t\treturn;\n\t} else {\n\t\t/* Check if we are stuck and reset [see XXX comment] */\n\t\tif (epstatus(sc)) {\n#ifdef EP_DEBUG\n\t\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: adapter reset\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\t\tepreset(sc);\n\t\t}\n\t}\n\n\tgoto startagain;\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ETHER_MAX_LEN   1518"
          ],
          "globals_used": [
            "int\tepstatus",
            "void\tepstart",
            "void\tepreset",
            "void\tepread",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_MAX_LEN   1518\n\nint\tepstatus;\nvoid\tepstart;\nvoid\tepreset;\nvoid\tepread;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ep_softc *sc = ifp->if_softc;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct mbuf *m, *m0;\n\tint sh, len, pad;\n\n\t/* Don't transmit if interface is busy or not running */\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\nstartagain:\n\t/* Sneak a peek at the next packet */\n\tm0 = ifp->if_snd.ifq_head;\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"epstart: no header mbuf\");\n\tlen = m0->m_pkthdr.len;\n\n\tpad = (4 - len) & 3;\n\n\t/*\n\t * The 3c509 automatically pads short packets to minimum ethernet\n\t * length, but we drop packets that are too large. Perhaps we should\n\t * truncate them instead?\n\t */\n\tif (len + pad > ETHER_MAX_LEN) {\n\t\t/* packet is obviously too large: toss it */\n\t\t++ifp->if_oerrors;\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tm_freem(m0);\n\t\tgoto readcheck;\n\t}\n\n\tif (bus_space_read_2(iot, ioh, EP_W1_FREE_TX) < len + pad + 4) {\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t\t    SET_TX_AVAIL_THRESH | ((len + pad + 4) >> sc->txashift));\n\t\t/* not enough room in FIFO */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t} else {\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t\t    SET_TX_AVAIL_THRESH | EP_THRESH_DISABLE);\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\t\t/* not really needed */\n\t\treturn;\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_TX_START_THRESH |\n\t    ((len / 4 + sc->tx_start_thresh) /*>> sc->txashift*/));\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/*\n\t * Do the output at splhigh() so that an interrupt from another device\n\t * won't cause a FIFO underrun.\n\t */\n\tsh = splhigh();\n\n\tbus_space_write_2(iot, ioh, EP_W1_TX_PIO_WR_1, len);\n\tbus_space_write_2(iot, ioh, EP_W1_TX_PIO_WR_1,\n\t    0xffff);\t/* Second dword meaningless */\n\tif (EP_IS_BUS_32(sc->bustype)) {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 3)\n\t\t\t\tbus_space_write_raw_multi_4(iot, ioh,\n\t\t\t\t    EP_W1_TX_PIO_WR_1, mtod(m, u_int8_t *),\n\t\t\t\t    m->m_len & ~3);\n\t\t\tif (m->m_len & 3)\n\t\t\t\tbus_space_write_multi_1(iot, ioh,\n\t\t\t\t    EP_W1_TX_PIO_WR_1,\n\t\t\t\t    mtod(m, u_int8_t *) + (m->m_len & ~3),\n\t\t\t\t    m->m_len & 3);\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t} else {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 1)\n\t\t\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t\t\t    EP_W1_TX_PIO_WR_1, mtod(m, u_int8_t *),\n\t\t\t\t    m->m_len & ~1);\n\t\t\tif (m->m_len & 1)\n\t\t\t\tbus_space_write_1(iot, ioh, EP_W1_TX_PIO_WR_1,\n\t\t\t\t     *(mtod(m, u_int8_t *) + m->m_len - 1));\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t}\n\twhile (pad--)\n\t\tbus_space_write_1(iot, ioh, EP_W1_TX_PIO_WR_1, 0);\n\n\tsplx(sh);\n\n\t++ifp->if_opackets;\n\nreadcheck:\n\tif ((bus_space_read_2(iot, ioh, EP_W1_RX_STATUS) & ERR_INCOMPLETE) ==\n\t    0) {\n\t\t/* We received a complete packet. */\n\t\tu_int16_t status = bus_space_read_2(iot, ioh, EP_STATUS);\n\n\t\tif ((status & S_INTR_LATCH) == 0) {\n\t\t\t/*\n\t\t\t * No interrupt, read the packet and continue\n\t\t\t * Is  this supposed to happen? Is my motherboard \n\t\t\t * completely busted?\n\t\t\t */\n\t\t\tepread(sc);\n\t\t} else\n\t\t\t/* Got an interrupt, return to get it serviced. */\n\t\t\treturn;\n\t} else {\n\t\t/* Check if we are stuck and reset [see XXX comment] */\n\t\tif (epstatus(sc)) {\n#ifdef EP_DEBUG\n\t\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: adapter reset\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\t\tepreset(sc);\n\t\t}\n\t}\n\n\tgoto startagain;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eptxstat",
          "args": [
            "sc"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "eptxstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "1011-1055",
          "snippet": "void\neptxstat(sc)\n\tregister struct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\t/*\n\t * We need to read+write TX_STATUS until we get a 0 status\n\t * in order to turn off the interrupt flag.\n\t */\n\twhile ((i = bus_space_read_1(iot, ioh, EP_W1_TX_STATUS)) &\n\t    TXS_COMPLETE) {\n\t\tbus_space_write_1(iot, ioh, EP_W1_TX_STATUS, 0x0);\n\n\t\tif (i & TXS_JABBER) {\n\t\t\t++sc->sc_arpcom.ac_if.if_oerrors;\n#ifdef EP_DEBUG\n\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: jabber (%x)\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, i);\n#endif\n\t\t\tepreset(sc);\n\t\t} else if (i & TXS_UNDERRUN) {\n\t\t\t++sc->sc_arpcom.ac_if.if_oerrors;\n#ifdef EP_DEBUG\n\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: fifo underrun (%x) @%d\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, i,\n\t\t\t\t       sc->tx_start_thresh);\n#endif\n\t\t\tif (sc->tx_succ_ok < 100)\n\t\t\t\t    sc->tx_start_thresh = min(ETHER_MAX_LEN,\n\t\t\t\t\t    sc->tx_start_thresh + 20);\n\t\t\tsc->tx_succ_ok = 0;\n\t\t\tepreset(sc);\n\t\t} else if (i & TXS_MAX_COLLISION) {\n\t\t\t++sc->sc_arpcom.ac_if.if_collisions;\n\t\t\tbus_space_write_2(iot, ioh, EP_COMMAND, TX_ENABLE);\n\t\t\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\t\t} else\n\t\t\tsc->tx_succ_ok = (sc->tx_succ_ok+1) & 127;\n\t}\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ETHER_MAX_LEN   1518"
          ],
          "globals_used": [
            "void\teptxstat",
            "void\tepreset",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_MAX_LEN   1518\n\nvoid\teptxstat;\nvoid\tepreset;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\neptxstat(sc)\n\tregister struct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\t/*\n\t * We need to read+write TX_STATUS until we get a 0 status\n\t * in order to turn off the interrupt flag.\n\t */\n\twhile ((i = bus_space_read_1(iot, ioh, EP_W1_TX_STATUS)) &\n\t    TXS_COMPLETE) {\n\t\tbus_space_write_1(iot, ioh, EP_W1_TX_STATUS, 0x0);\n\n\t\tif (i & TXS_JABBER) {\n\t\t\t++sc->sc_arpcom.ac_if.if_oerrors;\n#ifdef EP_DEBUG\n\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: jabber (%x)\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, i);\n#endif\n\t\t\tepreset(sc);\n\t\t} else if (i & TXS_UNDERRUN) {\n\t\t\t++sc->sc_arpcom.ac_if.if_oerrors;\n#ifdef EP_DEBUG\n\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: fifo underrun (%x) @%d\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, i,\n\t\t\t\t       sc->tx_start_thresh);\n#endif\n\t\t\tif (sc->tx_succ_ok < 100)\n\t\t\t\t    sc->tx_start_thresh = min(ETHER_MAX_LEN,\n\t\t\t\t\t    sc->tx_start_thresh + 20);\n\t\t\tsc->tx_succ_ok = 0;\n\t\t\tepreset(sc);\n\t\t} else if (i & TXS_MAX_COLLISION) {\n\t\t\t++sc->sc_arpcom.ac_if.if_collisions;\n\t\t\tbus_space_write_2(iot, ioh, EP_COMMAND, TX_ENABLE);\n\t\t\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\t\t} else\n\t\t\tsc->tx_succ_ok = (sc->tx_succ_ok+1) & 127;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "epreset",
          "args": [
            "sc"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "epreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "1423-1433",
          "snippet": "void\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tepreset",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepreset;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: adapter failure (%x)\\n\"",
            "sc->sc_dev.dv_xname",
            "status"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "epread",
          "args": [
            "sc"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "epreadeeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "1488-1502",
          "snippet": "u_int16_t\nepreadeeprom(iot, ioh, offset)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint offset;\n{\n\tu_int16_t data = 0;\n\tint i;\n\n\tbus_space_write_1(iot, ioh, 0, 0x80 + offset);\n\tdelay(1000);\n\tfor (i = 0; i < 16; i++)\n\t\tdata = (data << 1) | (bus_space_read_2(iot, ioh, 0) & 1);\n\treturn (data);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t\nepreadeeprom(iot, ioh, offset)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint offset;\n{\n\tu_int16_t data = 0;\n\tint i;\n\n\tbus_space_write_1(iot, ioh, 0, 0x80 + offset);\n\tdelay(1000);\n\tfor (i = 0; i < 16; i++)\n\t\tdata = (data << 1) | (bus_space_read_2(iot, ioh, 0) & 1);\n\treturn (data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "ACK_INTR | status"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_STATUS"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "C_INTR_LATCH"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\teptxstat;\nvoid\tepstart;\nvoid\tepreset;\nvoid\tepread;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nint\nepintr(arg)\n\tvoid *arg;\n{\n\tregister struct ep_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_int16_t status;\n\tint ret = 0;\n\n\tfor (;;) {\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND, C_INTR_LATCH);\n\n\t\tstatus = bus_space_read_2(iot, ioh, EP_STATUS);\n\n\t\tif ((status & (S_TX_COMPLETE | S_TX_AVAIL |\n\t\t\t       S_RX_COMPLETE | S_CARD_FAILURE)) == 0)\n\t\t\tbreak;\n\n\t\tret = 1;\n\n\t\t/*\n\t\t * Acknowledge any interrupts.  It's important that we do this\n\t\t * first, since there would otherwise be a race condition.\n\t\t * Due to the i386 interrupt queueing, we may get spurious\n\t\t * interrupts occasionally.\n\t\t */\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND, ACK_INTR | status);\n\n\t\tif (status & S_RX_COMPLETE)\n\t\t\tepread(sc);\n\t\tif (status & S_TX_AVAIL) {\n\t\t\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\t\t\tepstart(&sc->sc_arpcom.ac_if);\n\t\t}\n\t\tif (status & S_CARD_FAILURE) {\n\t\t\tprintf(\"%s: adapter failure (%x)\\n\",\n\t\t\t    sc->sc_dev.dv_xname, status);\n\t\t\tepreset(sc);\n\t\t\treturn (1);\n\t\t}\n\t\tif (status & S_TX_COMPLETE) {\n\t\t\teptxstat(sc);\n\t\t\tepstart(ifp);\n\t\t}\n\t}\t\n\n\t/* no more interrupts */\n\treturn (ret);\n}"
  },
  {
    "function_name": "eptxstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "1011-1055",
    "snippet": "void\neptxstat(sc)\n\tregister struct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\t/*\n\t * We need to read+write TX_STATUS until we get a 0 status\n\t * in order to turn off the interrupt flag.\n\t */\n\twhile ((i = bus_space_read_1(iot, ioh, EP_W1_TX_STATUS)) &\n\t    TXS_COMPLETE) {\n\t\tbus_space_write_1(iot, ioh, EP_W1_TX_STATUS, 0x0);\n\n\t\tif (i & TXS_JABBER) {\n\t\t\t++sc->sc_arpcom.ac_if.if_oerrors;\n#ifdef EP_DEBUG\n\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: jabber (%x)\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, i);\n#endif\n\t\t\tepreset(sc);\n\t\t} else if (i & TXS_UNDERRUN) {\n\t\t\t++sc->sc_arpcom.ac_if.if_oerrors;\n#ifdef EP_DEBUG\n\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: fifo underrun (%x) @%d\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, i,\n\t\t\t\t       sc->tx_start_thresh);\n#endif\n\t\t\tif (sc->tx_succ_ok < 100)\n\t\t\t\t    sc->tx_start_thresh = min(ETHER_MAX_LEN,\n\t\t\t\t\t    sc->tx_start_thresh + 20);\n\t\t\tsc->tx_succ_ok = 0;\n\t\t\tepreset(sc);\n\t\t} else if (i & TXS_MAX_COLLISION) {\n\t\t\t++sc->sc_arpcom.ac_if.if_collisions;\n\t\t\tbus_space_write_2(iot, ioh, EP_COMMAND, TX_ENABLE);\n\t\t\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\t\t} else\n\t\t\tsc->tx_succ_ok = (sc->tx_succ_ok+1) & 127;\n\t}\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ETHER_MAX_LEN   1518"
    ],
    "globals_used": [
      "void\teptxstat",
      "void\tepreset",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "TX_ENABLE"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epreset",
          "args": [
            "sc"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "epreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "1423-1433",
          "snippet": "void\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tepreset",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepreset;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "ETHER_MAX_LEN",
            "sc->tx_start_thresh + 20"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_meminit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "231-295",
          "snippet": "void\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: fifo underrun (%x) @%d\\n\"",
            "sc->sc_dev.dv_xname",
            "i",
            "sc->tx_start_thresh"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "EP_W1_TX_STATUS",
            "0x0"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "EP_W1_TX_STATUS"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_MAX_LEN   1518\n\nvoid\teptxstat;\nvoid\tepreset;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\neptxstat(sc)\n\tregister struct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\t/*\n\t * We need to read+write TX_STATUS until we get a 0 status\n\t * in order to turn off the interrupt flag.\n\t */\n\twhile ((i = bus_space_read_1(iot, ioh, EP_W1_TX_STATUS)) &\n\t    TXS_COMPLETE) {\n\t\tbus_space_write_1(iot, ioh, EP_W1_TX_STATUS, 0x0);\n\n\t\tif (i & TXS_JABBER) {\n\t\t\t++sc->sc_arpcom.ac_if.if_oerrors;\n#ifdef EP_DEBUG\n\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: jabber (%x)\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, i);\n#endif\n\t\t\tepreset(sc);\n\t\t} else if (i & TXS_UNDERRUN) {\n\t\t\t++sc->sc_arpcom.ac_if.if_oerrors;\n#ifdef EP_DEBUG\n\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: fifo underrun (%x) @%d\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, i,\n\t\t\t\t       sc->tx_start_thresh);\n#endif\n\t\t\tif (sc->tx_succ_ok < 100)\n\t\t\t\t    sc->tx_start_thresh = min(ETHER_MAX_LEN,\n\t\t\t\t\t    sc->tx_start_thresh + 20);\n\t\t\tsc->tx_succ_ok = 0;\n\t\t\tepreset(sc);\n\t\t} else if (i & TXS_MAX_COLLISION) {\n\t\t\t++sc->sc_arpcom.ac_if.if_collisions;\n\t\t\tbus_space_write_2(iot, ioh, EP_COMMAND, TX_ENABLE);\n\t\t\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\t\t} else\n\t\t\tsc->tx_succ_ok = (sc->tx_succ_ok+1) & 127;\n\t}\n}"
  },
  {
    "function_name": "epstatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "958-1008",
    "snippet": "int\nepstatus(sc)\n\tregister struct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t fifost;\n\n\t/*\n\t * Check the FIFO status and act accordingly\n\t */\n\tGO_WINDOW(4);\n\tfifost = bus_space_read_2(iot, ioh, EP_W4_FIFO_DIAG);\n\tGO_WINDOW(1);\n\n\tif (fifost & FIFOS_RX_UNDERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX underrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\tif (fifost & FIFOS_RX_STATUS_OVERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX Status overrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_RX_OVERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX overrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_TX_OVERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: TX overrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tepstatus",
      "void\tepreset",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "epreset",
          "args": [
            "sc"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "epreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "1423-1433",
          "snippet": "void\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tepreset",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepreset;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: TX overrun\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "1"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_W4_FIFO_DIAG"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "4"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tepstatus;\nvoid\tepreset;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nint\nepstatus(sc)\n\tregister struct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t fifost;\n\n\t/*\n\t * Check the FIFO status and act accordingly\n\t */\n\tGO_WINDOW(4);\n\tfifost = bus_space_read_2(iot, ioh, EP_W4_FIFO_DIAG);\n\tGO_WINDOW(1);\n\n\tif (fifost & FIFOS_RX_UNDERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX underrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\tif (fifost & FIFOS_RX_STATUS_OVERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX Status overrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_RX_OVERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX overrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_TX_OVERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: TX overrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "epstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "813-948",
    "snippet": "void\nepstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ep_softc *sc = ifp->if_softc;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct mbuf *m, *m0;\n\tint sh, len, pad;\n\n\t/* Don't transmit if interface is busy or not running */\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\nstartagain:\n\t/* Sneak a peek at the next packet */\n\tm0 = ifp->if_snd.ifq_head;\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"epstart: no header mbuf\");\n\tlen = m0->m_pkthdr.len;\n\n\tpad = (4 - len) & 3;\n\n\t/*\n\t * The 3c509 automatically pads short packets to minimum ethernet\n\t * length, but we drop packets that are too large. Perhaps we should\n\t * truncate them instead?\n\t */\n\tif (len + pad > ETHER_MAX_LEN) {\n\t\t/* packet is obviously too large: toss it */\n\t\t++ifp->if_oerrors;\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tm_freem(m0);\n\t\tgoto readcheck;\n\t}\n\n\tif (bus_space_read_2(iot, ioh, EP_W1_FREE_TX) < len + pad + 4) {\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t\t    SET_TX_AVAIL_THRESH | ((len + pad + 4) >> sc->txashift));\n\t\t/* not enough room in FIFO */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t} else {\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t\t    SET_TX_AVAIL_THRESH | EP_THRESH_DISABLE);\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\t\t/* not really needed */\n\t\treturn;\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_TX_START_THRESH |\n\t    ((len / 4 + sc->tx_start_thresh) /*>> sc->txashift*/));\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/*\n\t * Do the output at splhigh() so that an interrupt from another device\n\t * won't cause a FIFO underrun.\n\t */\n\tsh = splhigh();\n\n\tbus_space_write_2(iot, ioh, EP_W1_TX_PIO_WR_1, len);\n\tbus_space_write_2(iot, ioh, EP_W1_TX_PIO_WR_1,\n\t    0xffff);\t/* Second dword meaningless */\n\tif (EP_IS_BUS_32(sc->bustype)) {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 3)\n\t\t\t\tbus_space_write_raw_multi_4(iot, ioh,\n\t\t\t\t    EP_W1_TX_PIO_WR_1, mtod(m, u_int8_t *),\n\t\t\t\t    m->m_len & ~3);\n\t\t\tif (m->m_len & 3)\n\t\t\t\tbus_space_write_multi_1(iot, ioh,\n\t\t\t\t    EP_W1_TX_PIO_WR_1,\n\t\t\t\t    mtod(m, u_int8_t *) + (m->m_len & ~3),\n\t\t\t\t    m->m_len & 3);\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t} else {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 1)\n\t\t\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t\t\t    EP_W1_TX_PIO_WR_1, mtod(m, u_int8_t *),\n\t\t\t\t    m->m_len & ~1);\n\t\t\tif (m->m_len & 1)\n\t\t\t\tbus_space_write_1(iot, ioh, EP_W1_TX_PIO_WR_1,\n\t\t\t\t     *(mtod(m, u_int8_t *) + m->m_len - 1));\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t}\n\twhile (pad--)\n\t\tbus_space_write_1(iot, ioh, EP_W1_TX_PIO_WR_1, 0);\n\n\tsplx(sh);\n\n\t++ifp->if_opackets;\n\nreadcheck:\n\tif ((bus_space_read_2(iot, ioh, EP_W1_RX_STATUS) & ERR_INCOMPLETE) ==\n\t    0) {\n\t\t/* We received a complete packet. */\n\t\tu_int16_t status = bus_space_read_2(iot, ioh, EP_STATUS);\n\n\t\tif ((status & S_INTR_LATCH) == 0) {\n\t\t\t/*\n\t\t\t * No interrupt, read the packet and continue\n\t\t\t * Is  this supposed to happen? Is my motherboard \n\t\t\t * completely busted?\n\t\t\t */\n\t\t\tepread(sc);\n\t\t} else\n\t\t\t/* Got an interrupt, return to get it serviced. */\n\t\t\treturn;\n\t} else {\n\t\t/* Check if we are stuck and reset [see XXX comment] */\n\t\tif (epstatus(sc)) {\n#ifdef EP_DEBUG\n\t\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: adapter reset\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\t\tepreset(sc);\n\t\t}\n\t}\n\n\tgoto startagain;\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ETHER_MAX_LEN   1518"
    ],
    "globals_used": [
      "int\tepstatus",
      "void\tepstart",
      "void\tepreset",
      "void\tepread",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "epreset",
          "args": [
            "sc"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "epreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "1423-1433",
          "snippet": "void\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tepreset",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepreset;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepreset(sc)\n\tstruct ep_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tepstop(sc);\n\tepinit(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: adapter reset\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "epstatus",
          "args": [
            "sc"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "epstatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "958-1008",
          "snippet": "int\nepstatus(sc)\n\tregister struct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t fifost;\n\n\t/*\n\t * Check the FIFO status and act accordingly\n\t */\n\tGO_WINDOW(4);\n\tfifost = bus_space_read_2(iot, ioh, EP_W4_FIFO_DIAG);\n\tGO_WINDOW(1);\n\n\tif (fifost & FIFOS_RX_UNDERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX underrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\tif (fifost & FIFOS_RX_STATUS_OVERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX Status overrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_RX_OVERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX overrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_TX_OVERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: TX overrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tepstatus",
            "void\tepreset",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tepstatus;\nvoid\tepreset;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nint\nepstatus(sc)\n\tregister struct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t fifost;\n\n\t/*\n\t * Check the FIFO status and act accordingly\n\t */\n\tGO_WINDOW(4);\n\tfifost = bus_space_read_2(iot, ioh, EP_W4_FIFO_DIAG);\n\tGO_WINDOW(1);\n\n\tif (fifost & FIFOS_RX_UNDERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX underrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\tif (fifost & FIFOS_RX_STATUS_OVERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX Status overrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_RX_OVERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: RX overrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\treturn 1;\n\t}\n\n\tif (fifost & FIFOS_TX_OVERRUN) {\n#ifdef EP_DEBUG\n\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\tprintf(\"%s: TX overrun\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\tepreset(sc);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "epread",
          "args": [
            "sc"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "epreadeeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "1488-1502",
          "snippet": "u_int16_t\nepreadeeprom(iot, ioh, offset)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint offset;\n{\n\tu_int16_t data = 0;\n\tint i;\n\n\tbus_space_write_1(iot, ioh, 0, 0x80 + offset);\n\tdelay(1000);\n\tfor (i = 0; i < 16; i++)\n\t\tdata = (data << 1) | (bus_space_read_2(iot, ioh, 0) & 1);\n\treturn (data);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t\nepreadeeprom(iot, ioh, offset)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint offset;\n{\n\tu_int16_t data = 0;\n\tint i;\n\n\tbus_space_write_1(iot, ioh, 0, 0x80 + offset);\n\tdelay(1000);\n\tfor (i = 0; i < 16; i++)\n\t\tdata = (data << 1) | (bus_space_read_2(iot, ioh, 0) & 1);\n\treturn (data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_STATUS"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_W1_RX_STATUS"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "sh"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "EP_W1_TX_PIO_WR_1",
            "0"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MFREE",
          "args": [
            "m",
            "m0"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "EP_W1_TX_PIO_WR_1",
            "*(mtod(m, u_int8_t *) + m->m_len - 1)"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_raw_multi_2",
          "args": [
            "iot",
            "ioh",
            "EP_W1_TX_PIO_WR_1",
            "mtod(m, u_int8_t *)",
            "m->m_len & ~1"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int8_t*"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MFREE",
          "args": [
            "m",
            "m0"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_multi_1",
          "args": [
            "iot",
            "ioh",
            "EP_W1_TX_PIO_WR_1",
            "mtod(m, u_int8_t *) + (m->m_len & ~3)",
            "m->m_len & 3"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int8_t*"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_raw_multi_4",
          "args": [
            "iot",
            "ioh",
            "EP_W1_TX_PIO_WR_1",
            "mtod(m, u_int8_t *)",
            "m->m_len & ~3"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int8_t*"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EP_IS_BUS_32",
          "args": [
            "sc->bustype"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_W1_TX_PIO_WR_1",
            "0xffff"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_W1_TX_PIO_WR_1",
            "len"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m0"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "SET_TX_START_THRESH |\n\t    ((len / 4 + sc->tx_start_thresh) /*>> sc->txashift*/)"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "SET_TX_AVAIL_THRESH | EP_THRESH_DISABLE"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "SET_TX_AVAIL_THRESH | ((len + pad + 4) >> sc->txashift)"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_W1_FREE_TX"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"epstart: no header mbuf\""
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_MAX_LEN   1518\n\nint\tepstatus;\nvoid\tepstart;\nvoid\tepreset;\nvoid\tepread;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ep_softc *sc = ifp->if_softc;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct mbuf *m, *m0;\n\tint sh, len, pad;\n\n\t/* Don't transmit if interface is busy or not running */\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\nstartagain:\n\t/* Sneak a peek at the next packet */\n\tm0 = ifp->if_snd.ifq_head;\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"epstart: no header mbuf\");\n\tlen = m0->m_pkthdr.len;\n\n\tpad = (4 - len) & 3;\n\n\t/*\n\t * The 3c509 automatically pads short packets to minimum ethernet\n\t * length, but we drop packets that are too large. Perhaps we should\n\t * truncate them instead?\n\t */\n\tif (len + pad > ETHER_MAX_LEN) {\n\t\t/* packet is obviously too large: toss it */\n\t\t++ifp->if_oerrors;\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tm_freem(m0);\n\t\tgoto readcheck;\n\t}\n\n\tif (bus_space_read_2(iot, ioh, EP_W1_FREE_TX) < len + pad + 4) {\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t\t    SET_TX_AVAIL_THRESH | ((len + pad + 4) >> sc->txashift));\n\t\t/* not enough room in FIFO */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t} else {\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t\t    SET_TX_AVAIL_THRESH | EP_THRESH_DISABLE);\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\t\t/* not really needed */\n\t\treturn;\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_TX_START_THRESH |\n\t    ((len / 4 + sc->tx_start_thresh) /*>> sc->txashift*/));\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/*\n\t * Do the output at splhigh() so that an interrupt from another device\n\t * won't cause a FIFO underrun.\n\t */\n\tsh = splhigh();\n\n\tbus_space_write_2(iot, ioh, EP_W1_TX_PIO_WR_1, len);\n\tbus_space_write_2(iot, ioh, EP_W1_TX_PIO_WR_1,\n\t    0xffff);\t/* Second dword meaningless */\n\tif (EP_IS_BUS_32(sc->bustype)) {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 3)\n\t\t\t\tbus_space_write_raw_multi_4(iot, ioh,\n\t\t\t\t    EP_W1_TX_PIO_WR_1, mtod(m, u_int8_t *),\n\t\t\t\t    m->m_len & ~3);\n\t\t\tif (m->m_len & 3)\n\t\t\t\tbus_space_write_multi_1(iot, ioh,\n\t\t\t\t    EP_W1_TX_PIO_WR_1,\n\t\t\t\t    mtod(m, u_int8_t *) + (m->m_len & ~3),\n\t\t\t\t    m->m_len & 3);\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t} else {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 1)\n\t\t\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t\t\t    EP_W1_TX_PIO_WR_1, mtod(m, u_int8_t *),\n\t\t\t\t    m->m_len & ~1);\n\t\t\tif (m->m_len & 1)\n\t\t\t\tbus_space_write_1(iot, ioh, EP_W1_TX_PIO_WR_1,\n\t\t\t\t     *(mtod(m, u_int8_t *) + m->m_len - 1));\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t}\n\twhile (pad--)\n\t\tbus_space_write_1(iot, ioh, EP_W1_TX_PIO_WR_1, 0);\n\n\tsplx(sh);\n\n\t++ifp->if_opackets;\n\nreadcheck:\n\tif ((bus_space_read_2(iot, ioh, EP_W1_RX_STATUS) & ERR_INCOMPLETE) ==\n\t    0) {\n\t\t/* We received a complete packet. */\n\t\tu_int16_t status = bus_space_read_2(iot, ioh, EP_STATUS);\n\n\t\tif ((status & S_INTR_LATCH) == 0) {\n\t\t\t/*\n\t\t\t * No interrupt, read the packet and continue\n\t\t\t * Is  this supposed to happen? Is my motherboard \n\t\t\t * completely busted?\n\t\t\t */\n\t\t\tepread(sc);\n\t\t} else\n\t\t\t/* Got an interrupt, return to get it serviced. */\n\t\t\treturn;\n\t} else {\n\t\t/* Check if we are stuck and reset [see XXX comment] */\n\t\tif (epstatus(sc)) {\n#ifdef EP_DEBUG\n\t\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: adapter reset\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\t\tepreset(sc);\n\t\t}\n\t}\n\n\tgoto startagain;\n}"
  },
  {
    "function_name": "ep_media_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "753-805",
    "snippet": "void\nep_media_status(ifp, req)\n\tstruct ifnet *ifp;\n\tstruct ifmediareq *req;\n{\n\tregister struct ep_softc *sc = ifp->if_softc;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int config1;\n\tu_int ep_mediastatus;\n\n\t/* XXX read from softc when we start autosensing media */\n\treq->ifm_active = sc->sc_media.ifm_cur->ifm_media;\n\t\n\tswitch (sc->ep_chipset) {\n\tcase EP_CHIPSET_VORTEX:\n\tcase EP_CHIPSET_BOOMERANG:\n\t\tGO_WINDOW(3);\n\t\tdelay(5000);\n\n\t\tconfig1 = bus_space_read_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2);\n\t\tGO_WINDOW(1);\n\n\t\tconfig1 = \n\t\t    (config1 & CONFIG_MEDIAMASK) >> CONFIG_MEDIAMASK_SHIFT;\n\t\treq->ifm_active = ep_default_to_media[config1];\n\n\t\t/* XXX check full-duplex bits? */\n\n\t\tGO_WINDOW(4);\n\t\treq->ifm_status = IFM_AVALID;\t/* XXX */\n\t\tep_mediastatus = bus_space_read_2(iot, ioh, EP_W4_MEDIA_TYPE);\n\t\tif (ep_mediastatus & LINKBEAT_DETECT)\n\t\t\treq->ifm_status |= IFM_ACTIVE; \t/* XXX  automedia */\n\n\t\tbreak;\n\n\tcase EP_CHIPSET_UNKNOWN:\n\tcase EP_CHIPSET_3C509:\n\t\treq->ifm_status = 0;\t/* XXX */\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: media_status on unknown chipset 0x%x\\n\",\n\t\t       ifp->if_xname, sc->ep_chipset);\n\t\tbreak;\n\t}\n\n\t/* XXX look for softc heartbeat for other chips or media */\n\n\tGO_WINDOW(1);\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const u_int ep_default_to_media[8] = {\n\tIFM_ETHER | IFM_10_T,\n\tIFM_ETHER | IFM_10_5,\n\t0, \t\t\t/* reserved by 3Com */\n\tIFM_ETHER | IFM_10_2,\n\tIFM_ETHER | IFM_100_TX,\n\tIFM_ETHER | IFM_100_FX,\n\tIFM_ETHER | IFM_100_TX,\t/* XXX really MII: need to talk to PHY */\n\tIFM_ETHER | IFM_100_T4,\n};",
      "void\tep_media_status",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "1"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: media_status on unknown chipset 0x%x\\n\"",
            "ifp->if_xname",
            "sc->ep_chipset"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_W4_MEDIA_TYPE"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "4"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "1"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_W3_INTERNAL_CONFIG + 2"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "5000"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "3"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nconst u_int ep_default_to_media[8] = {\n\tIFM_ETHER | IFM_10_T,\n\tIFM_ETHER | IFM_10_5,\n\t0, \t\t\t/* reserved by 3Com */\n\tIFM_ETHER | IFM_10_2,\n\tIFM_ETHER | IFM_100_TX,\n\tIFM_ETHER | IFM_100_FX,\n\tIFM_ETHER | IFM_100_TX,\t/* XXX really MII: need to talk to PHY */\n\tIFM_ETHER | IFM_100_T4,\n};\nvoid\tep_media_status;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nep_media_status(ifp, req)\n\tstruct ifnet *ifp;\n\tstruct ifmediareq *req;\n{\n\tregister struct ep_softc *sc = ifp->if_softc;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int config1;\n\tu_int ep_mediastatus;\n\n\t/* XXX read from softc when we start autosensing media */\n\treq->ifm_active = sc->sc_media.ifm_cur->ifm_media;\n\t\n\tswitch (sc->ep_chipset) {\n\tcase EP_CHIPSET_VORTEX:\n\tcase EP_CHIPSET_BOOMERANG:\n\t\tGO_WINDOW(3);\n\t\tdelay(5000);\n\n\t\tconfig1 = bus_space_read_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2);\n\t\tGO_WINDOW(1);\n\n\t\tconfig1 = \n\t\t    (config1 & CONFIG_MEDIAMASK) >> CONFIG_MEDIAMASK_SHIFT;\n\t\treq->ifm_active = ep_default_to_media[config1];\n\n\t\t/* XXX check full-duplex bits? */\n\n\t\tGO_WINDOW(4);\n\t\treq->ifm_status = IFM_AVALID;\t/* XXX */\n\t\tep_mediastatus = bus_space_read_2(iot, ioh, EP_W4_MEDIA_TYPE);\n\t\tif (ep_mediastatus & LINKBEAT_DETECT)\n\t\t\treq->ifm_status |= IFM_ACTIVE; \t/* XXX  automedia */\n\n\t\tbreak;\n\n\tcase EP_CHIPSET_UNKNOWN:\n\tcase EP_CHIPSET_3C509:\n\t\treq->ifm_status = 0;\t/* XXX */\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: media_status on unknown chipset 0x%x\\n\",\n\t\t       ifp->if_xname, sc->ep_chipset);\n\t\tbreak;\n\t}\n\n\t/* XXX look for softc heartbeat for other chips or media */\n\n\tGO_WINDOW(1);\n\treturn;\n}"
  },
  {
    "function_name": "epsetmedia",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "634-746",
    "snippet": "int\nepsetmedia(sc, medium)\n\tstruct ep_softc *sc;\n\tint medium;\n{\n/*\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;*/\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint w4_media;\n\tint config0, config1;\n\n\t/*\n\t * you can `ifconfig (link0|-link0) ep0' to get the following\n\t * behaviour:\n\t *\t-link0\tdisable AUI/UTP. enable BNC.\n\t *\tlink0\tdisable BNC. enable AUI.\n\t *\tlink1\tif the card has a UTP connector, and link0 is\n\t *\t\tset too, then you get the UTP port.\n\t */\n\n\t/*\n\t * First, change the media-control bits in EP_W4_MEDIA_TYPE.\n\t */\n\n\t /* Turn everything off.  First turn off linkbeat and UTP. */\n\tGO_WINDOW(4);\n\tw4_media = bus_space_read_2(iot, ioh, EP_W4_MEDIA_TYPE);\n\tw4_media =  w4_media & ~(ENABLE_UTP|SQE_ENABLE);\n\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE, w4_media);\n\n\t/* Turn off coax */\n\tbus_space_write_2(iot, ioh, EP_COMMAND, STOP_TRANSCEIVER);\n\tdelay(1000);\n\n\t/*\n\t * Now turn on the selected media/transceiver.\n\t */\n\tGO_WINDOW(4);\n\tswitch  (medium) {\n\tcase EPMEDIA_10BASE_T:\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | ENABLE_UTP);\n\t\tbreak;\n\n\tcase EPMEDIA_10BASE_2:\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND, START_TRANSCEIVER);\n\t\tDELAY(1000);\t/* 50ms not enough? */\n\t\tbreak;\n\n\t/* XXX following only for new-generation cards */\n\tcase EPMEDIA_100BASE_TX:\n\tcase EPMEDIA_100BASE_FX:\n\tcase EPMEDIA_100BASE_T4:\t/* XXX check documentation */\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | LINKBEAT_ENABLE);\n\t\tDELAY(1000);\t/* not strictly necessary? */\n\t\tbreak;\n\n\tcase EPMEDIA_AUI:\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | SQE_ENABLE);\n\t\tDELAY(1000);\t/*  not strictly necessary? */\n\t\tbreak;\n\tcase EPMEDIA_MII:\n\t\tbreak;\n\tdefault:\n#if defined(EP_DEBUG)\n\t\tprintf(\"%s unknown media 0x%x\\n\", sc->sc_dev.dv_xname, medium);\n#endif\n\t\tbreak;\n\t\t\n\t}\n\n\t/*\n\t * Tell the chip which PHY [sic] to use.\n\t */\n\tswitch (sc->ep_chipset) {\n\tcase EP_CHIPSET_VORTEX:\n\tcase EP_CHIPSET_BOOMERANG2:\n\t\tGO_WINDOW(3);\n\t\tconfig0 = (u_int)bus_space_read_2(iot, ioh,\n\t\t    EP_W3_INTERNAL_CONFIG);\n\t\tconfig1 = (u_int)bus_space_read_2(iot, ioh,\n\t\t    EP_W3_INTERNAL_CONFIG + 2);\n\n#if defined(EP_DEBUG)\n\t\tprintf(\"%s:  read 0x%x, 0x%x from EP_W3_CONFIG register\\n\",\n\t\t       sc->sc_dev.dv_xname, config0, config1);\n#endif\n\t\tconfig1 = config1 & ~CONFIG_MEDIAMASK;\n\t\tconfig1 |= (medium << CONFIG_MEDIAMASK_SHIFT);\n\t\t\n#if defined(EP_DEBUG)\n\t\tprintf(\"epsetmedia: %s: medium 0x%x, 0x%x to EP_W3_CONFIG\\n\",\n\t\t    sc->sc_dev.dv_xname, medium, config1);\n#endif\n\t\tbus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG, config0);\n\t\tbus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2, config1);\n\t\tbreak;\n\n\tcase EP_CHIPSET_3C509:\n\t\tGO_WINDOW(0);\n\t\tconfig0 = bus_space_read_2(iot, ioh, EP_W0_ADDRESS_CFG);\n\t\tconfig0 &= 0x3fff;\n\t\tbus_space_write_2(iot, ioh, EP_W0_ADDRESS_CFG,\n\t\t    config0 | (medium << 14));\n\t\tDELAY(1000);\n\t\tbreak;\n\t}\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tepsetmedia",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "1"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_W0_ADDRESS_CFG",
            "config0 | (medium << 14)"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_W0_ADDRESS_CFG"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "0"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_W3_INTERNAL_CONFIG + 2",
            "config1"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_W3_INTERNAL_CONFIG",
            "config0"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"epsetmedia: %s: medium 0x%x, 0x%x to EP_W3_CONFIG\\n\"",
            "sc->sc_dev.dv_xname",
            "medium",
            "config1"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_W3_INTERNAL_CONFIG + 2"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_W3_INTERNAL_CONFIG"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "3"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_W4_MEDIA_TYPE",
            "w4_media | SQE_ENABLE"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_W4_MEDIA_TYPE",
            "w4_media | LINKBEAT_ENABLE"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "START_TRANSCEIVER"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_W4_MEDIA_TYPE",
            "w4_media | ENABLE_UTP"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "4"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "STOP_TRANSCEIVER"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_W4_MEDIA_TYPE",
            "w4_media"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_W4_MEDIA_TYPE"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "4"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tepsetmedia;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nint\nepsetmedia(sc, medium)\n\tstruct ep_softc *sc;\n\tint medium;\n{\n/*\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;*/\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint w4_media;\n\tint config0, config1;\n\n\t/*\n\t * you can `ifconfig (link0|-link0) ep0' to get the following\n\t * behaviour:\n\t *\t-link0\tdisable AUI/UTP. enable BNC.\n\t *\tlink0\tdisable BNC. enable AUI.\n\t *\tlink1\tif the card has a UTP connector, and link0 is\n\t *\t\tset too, then you get the UTP port.\n\t */\n\n\t/*\n\t * First, change the media-control bits in EP_W4_MEDIA_TYPE.\n\t */\n\n\t /* Turn everything off.  First turn off linkbeat and UTP. */\n\tGO_WINDOW(4);\n\tw4_media = bus_space_read_2(iot, ioh, EP_W4_MEDIA_TYPE);\n\tw4_media =  w4_media & ~(ENABLE_UTP|SQE_ENABLE);\n\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE, w4_media);\n\n\t/* Turn off coax */\n\tbus_space_write_2(iot, ioh, EP_COMMAND, STOP_TRANSCEIVER);\n\tdelay(1000);\n\n\t/*\n\t * Now turn on the selected media/transceiver.\n\t */\n\tGO_WINDOW(4);\n\tswitch  (medium) {\n\tcase EPMEDIA_10BASE_T:\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | ENABLE_UTP);\n\t\tbreak;\n\n\tcase EPMEDIA_10BASE_2:\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND, START_TRANSCEIVER);\n\t\tDELAY(1000);\t/* 50ms not enough? */\n\t\tbreak;\n\n\t/* XXX following only for new-generation cards */\n\tcase EPMEDIA_100BASE_TX:\n\tcase EPMEDIA_100BASE_FX:\n\tcase EPMEDIA_100BASE_T4:\t/* XXX check documentation */\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | LINKBEAT_ENABLE);\n\t\tDELAY(1000);\t/* not strictly necessary? */\n\t\tbreak;\n\n\tcase EPMEDIA_AUI:\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | SQE_ENABLE);\n\t\tDELAY(1000);\t/*  not strictly necessary? */\n\t\tbreak;\n\tcase EPMEDIA_MII:\n\t\tbreak;\n\tdefault:\n#if defined(EP_DEBUG)\n\t\tprintf(\"%s unknown media 0x%x\\n\", sc->sc_dev.dv_xname, medium);\n#endif\n\t\tbreak;\n\t\t\n\t}\n\n\t/*\n\t * Tell the chip which PHY [sic] to use.\n\t */\n\tswitch (sc->ep_chipset) {\n\tcase EP_CHIPSET_VORTEX:\n\tcase EP_CHIPSET_BOOMERANG2:\n\t\tGO_WINDOW(3);\n\t\tconfig0 = (u_int)bus_space_read_2(iot, ioh,\n\t\t    EP_W3_INTERNAL_CONFIG);\n\t\tconfig1 = (u_int)bus_space_read_2(iot, ioh,\n\t\t    EP_W3_INTERNAL_CONFIG + 2);\n\n#if defined(EP_DEBUG)\n\t\tprintf(\"%s:  read 0x%x, 0x%x from EP_W3_CONFIG register\\n\",\n\t\t       sc->sc_dev.dv_xname, config0, config1);\n#endif\n\t\tconfig1 = config1 & ~CONFIG_MEDIAMASK;\n\t\tconfig1 |= (medium << CONFIG_MEDIAMASK_SHIFT);\n\t\t\n#if defined(EP_DEBUG)\n\t\tprintf(\"epsetmedia: %s: medium 0x%x, 0x%x to EP_W3_CONFIG\\n\",\n\t\t    sc->sc_dev.dv_xname, medium, config1);\n#endif\n\t\tbus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG, config0);\n\t\tbus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2, config1);\n\t\tbreak;\n\n\tcase EP_CHIPSET_3C509:\n\t\tGO_WINDOW(0);\n\t\tconfig0 = bus_space_read_2(iot, ioh, EP_W0_ADDRESS_CFG);\n\t\tconfig0 &= 0x3fff;\n\t\tbus_space_write_2(iot, ioh, EP_W0_ADDRESS_CFG,\n\t\t    config0 | (medium << 14));\n\t\tDELAY(1000);\n\t\tbreak;\n\t}\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\treturn (0);\n}"
  },
  {
    "function_name": "ep_media_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "618-625",
    "snippet": "int\nep_media_change(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ep_softc *sc = ifp->if_softc;\n\n\treturn\tepsetmedia(sc, sc->sc_media.ifm_cur->ifm_data);\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tepsetmedia",
      "int\tep_media_change",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "epsetmedia",
          "args": [
            "sc",
            "sc->sc_media.ifm_cur->ifm_data"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "epsetmedia",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "634-746",
          "snippet": "int\nepsetmedia(sc, medium)\n\tstruct ep_softc *sc;\n\tint medium;\n{\n/*\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;*/\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint w4_media;\n\tint config0, config1;\n\n\t/*\n\t * you can `ifconfig (link0|-link0) ep0' to get the following\n\t * behaviour:\n\t *\t-link0\tdisable AUI/UTP. enable BNC.\n\t *\tlink0\tdisable BNC. enable AUI.\n\t *\tlink1\tif the card has a UTP connector, and link0 is\n\t *\t\tset too, then you get the UTP port.\n\t */\n\n\t/*\n\t * First, change the media-control bits in EP_W4_MEDIA_TYPE.\n\t */\n\n\t /* Turn everything off.  First turn off linkbeat and UTP. */\n\tGO_WINDOW(4);\n\tw4_media = bus_space_read_2(iot, ioh, EP_W4_MEDIA_TYPE);\n\tw4_media =  w4_media & ~(ENABLE_UTP|SQE_ENABLE);\n\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE, w4_media);\n\n\t/* Turn off coax */\n\tbus_space_write_2(iot, ioh, EP_COMMAND, STOP_TRANSCEIVER);\n\tdelay(1000);\n\n\t/*\n\t * Now turn on the selected media/transceiver.\n\t */\n\tGO_WINDOW(4);\n\tswitch  (medium) {\n\tcase EPMEDIA_10BASE_T:\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | ENABLE_UTP);\n\t\tbreak;\n\n\tcase EPMEDIA_10BASE_2:\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND, START_TRANSCEIVER);\n\t\tDELAY(1000);\t/* 50ms not enough? */\n\t\tbreak;\n\n\t/* XXX following only for new-generation cards */\n\tcase EPMEDIA_100BASE_TX:\n\tcase EPMEDIA_100BASE_FX:\n\tcase EPMEDIA_100BASE_T4:\t/* XXX check documentation */\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | LINKBEAT_ENABLE);\n\t\tDELAY(1000);\t/* not strictly necessary? */\n\t\tbreak;\n\n\tcase EPMEDIA_AUI:\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | SQE_ENABLE);\n\t\tDELAY(1000);\t/*  not strictly necessary? */\n\t\tbreak;\n\tcase EPMEDIA_MII:\n\t\tbreak;\n\tdefault:\n#if defined(EP_DEBUG)\n\t\tprintf(\"%s unknown media 0x%x\\n\", sc->sc_dev.dv_xname, medium);\n#endif\n\t\tbreak;\n\t\t\n\t}\n\n\t/*\n\t * Tell the chip which PHY [sic] to use.\n\t */\n\tswitch (sc->ep_chipset) {\n\tcase EP_CHIPSET_VORTEX:\n\tcase EP_CHIPSET_BOOMERANG2:\n\t\tGO_WINDOW(3);\n\t\tconfig0 = (u_int)bus_space_read_2(iot, ioh,\n\t\t    EP_W3_INTERNAL_CONFIG);\n\t\tconfig1 = (u_int)bus_space_read_2(iot, ioh,\n\t\t    EP_W3_INTERNAL_CONFIG + 2);\n\n#if defined(EP_DEBUG)\n\t\tprintf(\"%s:  read 0x%x, 0x%x from EP_W3_CONFIG register\\n\",\n\t\t       sc->sc_dev.dv_xname, config0, config1);\n#endif\n\t\tconfig1 = config1 & ~CONFIG_MEDIAMASK;\n\t\tconfig1 |= (medium << CONFIG_MEDIAMASK_SHIFT);\n\t\t\n#if defined(EP_DEBUG)\n\t\tprintf(\"epsetmedia: %s: medium 0x%x, 0x%x to EP_W3_CONFIG\\n\",\n\t\t    sc->sc_dev.dv_xname, medium, config1);\n#endif\n\t\tbus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG, config0);\n\t\tbus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2, config1);\n\t\tbreak;\n\n\tcase EP_CHIPSET_3C509:\n\t\tGO_WINDOW(0);\n\t\tconfig0 = bus_space_read_2(iot, ioh, EP_W0_ADDRESS_CFG);\n\t\tconfig0 &= 0x3fff;\n\t\tbus_space_write_2(iot, ioh, EP_W0_ADDRESS_CFG,\n\t\t    config0 | (medium << 14));\n\t\tDELAY(1000);\n\t\tbreak;\n\t}\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tepsetmedia",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tepsetmedia;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nint\nepsetmedia(sc, medium)\n\tstruct ep_softc *sc;\n\tint medium;\n{\n/*\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;*/\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint w4_media;\n\tint config0, config1;\n\n\t/*\n\t * you can `ifconfig (link0|-link0) ep0' to get the following\n\t * behaviour:\n\t *\t-link0\tdisable AUI/UTP. enable BNC.\n\t *\tlink0\tdisable BNC. enable AUI.\n\t *\tlink1\tif the card has a UTP connector, and link0 is\n\t *\t\tset too, then you get the UTP port.\n\t */\n\n\t/*\n\t * First, change the media-control bits in EP_W4_MEDIA_TYPE.\n\t */\n\n\t /* Turn everything off.  First turn off linkbeat and UTP. */\n\tGO_WINDOW(4);\n\tw4_media = bus_space_read_2(iot, ioh, EP_W4_MEDIA_TYPE);\n\tw4_media =  w4_media & ~(ENABLE_UTP|SQE_ENABLE);\n\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE, w4_media);\n\n\t/* Turn off coax */\n\tbus_space_write_2(iot, ioh, EP_COMMAND, STOP_TRANSCEIVER);\n\tdelay(1000);\n\n\t/*\n\t * Now turn on the selected media/transceiver.\n\t */\n\tGO_WINDOW(4);\n\tswitch  (medium) {\n\tcase EPMEDIA_10BASE_T:\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | ENABLE_UTP);\n\t\tbreak;\n\n\tcase EPMEDIA_10BASE_2:\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND, START_TRANSCEIVER);\n\t\tDELAY(1000);\t/* 50ms not enough? */\n\t\tbreak;\n\n\t/* XXX following only for new-generation cards */\n\tcase EPMEDIA_100BASE_TX:\n\tcase EPMEDIA_100BASE_FX:\n\tcase EPMEDIA_100BASE_T4:\t/* XXX check documentation */\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | LINKBEAT_ENABLE);\n\t\tDELAY(1000);\t/* not strictly necessary? */\n\t\tbreak;\n\n\tcase EPMEDIA_AUI:\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | SQE_ENABLE);\n\t\tDELAY(1000);\t/*  not strictly necessary? */\n\t\tbreak;\n\tcase EPMEDIA_MII:\n\t\tbreak;\n\tdefault:\n#if defined(EP_DEBUG)\n\t\tprintf(\"%s unknown media 0x%x\\n\", sc->sc_dev.dv_xname, medium);\n#endif\n\t\tbreak;\n\t\t\n\t}\n\n\t/*\n\t * Tell the chip which PHY [sic] to use.\n\t */\n\tswitch (sc->ep_chipset) {\n\tcase EP_CHIPSET_VORTEX:\n\tcase EP_CHIPSET_BOOMERANG2:\n\t\tGO_WINDOW(3);\n\t\tconfig0 = (u_int)bus_space_read_2(iot, ioh,\n\t\t    EP_W3_INTERNAL_CONFIG);\n\t\tconfig1 = (u_int)bus_space_read_2(iot, ioh,\n\t\t    EP_W3_INTERNAL_CONFIG + 2);\n\n#if defined(EP_DEBUG)\n\t\tprintf(\"%s:  read 0x%x, 0x%x from EP_W3_CONFIG register\\n\",\n\t\t       sc->sc_dev.dv_xname, config0, config1);\n#endif\n\t\tconfig1 = config1 & ~CONFIG_MEDIAMASK;\n\t\tconfig1 |= (medium << CONFIG_MEDIAMASK_SHIFT);\n\t\t\n#if defined(EP_DEBUG)\n\t\tprintf(\"epsetmedia: %s: medium 0x%x, 0x%x to EP_W3_CONFIG\\n\",\n\t\t    sc->sc_dev.dv_xname, medium, config1);\n#endif\n\t\tbus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG, config0);\n\t\tbus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2, config1);\n\t\tbreak;\n\n\tcase EP_CHIPSET_3C509:\n\t\tGO_WINDOW(0);\n\t\tconfig0 = bus_space_read_2(iot, ioh, EP_W0_ADDRESS_CFG);\n\t\tconfig0 &= 0x3fff;\n\t\tbus_space_write_2(iot, ioh, EP_W0_ADDRESS_CFG,\n\t\t    config0 | (medium << 14));\n\t\tDELAY(1000);\n\t\tbreak;\n\t}\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tepsetmedia;\nint\tep_media_change;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nint\nep_media_change(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ep_softc *sc = ifp->if_softc;\n\n\treturn\tepsetmedia(sc, sc->sc_media.ifm_cur->ifm_data);\n}"
  },
  {
    "function_name": "epsetfilter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "604-615",
    "snippet": "void\nepsetfilter(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\tbus_space_write_2(sc->sc_iot, sc->sc_ioh, EP_COMMAND, SET_RX_FILTER |\n\t    FIL_INDIVIDUAL | FIL_BRDCST |\n\t    ((ifp->if_flags & IFF_MULTICAST) ? FIL_MULTICAST : 0 ) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? FIL_PROMISC : 0 ));\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tepsetfilter",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "EP_COMMAND",
            "SET_RX_FILTER |\n\t    FIL_INDIVIDUAL | FIL_BRDCST |\n\t    ((ifp->if_flags & IFF_MULTICAST) ? FIL_MULTICAST : 0 ) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? FIL_PROMISC : 0 )"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "1"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepsetfilter;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepsetfilter(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\tbus_space_write_2(sc->sc_iot, sc->sc_ioh, EP_COMMAND, SET_RX_FILTER |\n\t    FIL_INDIVIDUAL | FIL_BRDCST |\n\t    ((ifp->if_flags & IFF_MULTICAST) ? FIL_MULTICAST : 0 ) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? FIL_PROMISC : 0 ));\n}"
  },
  {
    "function_name": "epinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "523-597",
    "snippet": "void\nepinit(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\n\tif (sc->bustype != EP_BUS_PCI) {\n\t\tGO_WINDOW(0);\n\t\tbus_space_write_2(iot, ioh, EP_W0_CONFIG_CTRL, 0);\n\t\tbus_space_write_2(iot, ioh, EP_W0_CONFIG_CTRL, ENABLE_DRQ_IRQ);\n\t}\n\n\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\tbus_space_write_2(iot, ioh, EP_W0_RESOURCE_CFG, 0x3f00);\n\t}\n\n\tGO_WINDOW(2);\n\tfor (i = 0; i < 6; i++)\t/* Reload the ether_addr. */\n\t\tbus_space_write_1(iot, ioh, EP_W2_ADDR_0 + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\tif (sc->bustype == EP_BUS_PCI || sc->bustype == EP_BUS_EISA)\n\t\t/*\n\t\t * Reset the station-address receive filter.\n\t\t * A bug workaround for busmastering  (Vortex, Demon) cards.\n\t\t */\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tbus_space_write_1(iot, ioh, EP_W2_RECVMASK_0 + i, 0);\n\n\tep_complete_cmd(sc, EP_COMMAND, RX_RESET);\n\tep_complete_cmd(sc, EP_COMMAND, TX_RESET);\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\tfor (i = 0; i < 31; i++)\n\t\tbus_space_read_1(iot, ioh, EP_W1_TX_STATUS);\n\n\t/* Set threshold for for Tx-space available interrupt. */\n\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t    SET_TX_AVAIL_THRESH | (1600 >> sc->txashift));\n\n\t/* Enable interrupts. */\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_RD_0_MASK |\n\t    S_CARD_FAILURE | S_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_INTR_MASK |\n\t    S_CARD_FAILURE | S_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\n\t/*\n\t * Attempt to get rid of any stray interrupts that occured during\n\t * configuration.  On the i386 this isn't possible because one may\n\t * already be queued.  However, a single stray interrupt is\n\t * unimportant.\n\t */\n\tbus_space_write_2(iot, ioh, EP_COMMAND, ACK_INTR | 0xff);\n\n\tepsetfilter(sc);\n\tepsetmedia(sc, sc->sc_media.ifm_cur->ifm_data);\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, RX_ENABLE);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, TX_ENABLE);\n\n\tepmbuffill(sc);\n\n\t/* Interface is now `running', with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Attempt to start output, if any. */\n\tepstart(ifp);\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tepstart",
      "void\tepmbuffill",
      "void\tepsetfilter",
      "int\tepsetmedia",
      "static inline void ep_complete_cmd",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "epstart",
          "args": [
            "ifp"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "epstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "813-948",
          "snippet": "void\nepstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ep_softc *sc = ifp->if_softc;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct mbuf *m, *m0;\n\tint sh, len, pad;\n\n\t/* Don't transmit if interface is busy or not running */\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\nstartagain:\n\t/* Sneak a peek at the next packet */\n\tm0 = ifp->if_snd.ifq_head;\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"epstart: no header mbuf\");\n\tlen = m0->m_pkthdr.len;\n\n\tpad = (4 - len) & 3;\n\n\t/*\n\t * The 3c509 automatically pads short packets to minimum ethernet\n\t * length, but we drop packets that are too large. Perhaps we should\n\t * truncate them instead?\n\t */\n\tif (len + pad > ETHER_MAX_LEN) {\n\t\t/* packet is obviously too large: toss it */\n\t\t++ifp->if_oerrors;\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tm_freem(m0);\n\t\tgoto readcheck;\n\t}\n\n\tif (bus_space_read_2(iot, ioh, EP_W1_FREE_TX) < len + pad + 4) {\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t\t    SET_TX_AVAIL_THRESH | ((len + pad + 4) >> sc->txashift));\n\t\t/* not enough room in FIFO */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t} else {\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t\t    SET_TX_AVAIL_THRESH | EP_THRESH_DISABLE);\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\t\t/* not really needed */\n\t\treturn;\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_TX_START_THRESH |\n\t    ((len / 4 + sc->tx_start_thresh) /*>> sc->txashift*/));\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/*\n\t * Do the output at splhigh() so that an interrupt from another device\n\t * won't cause a FIFO underrun.\n\t */\n\tsh = splhigh();\n\n\tbus_space_write_2(iot, ioh, EP_W1_TX_PIO_WR_1, len);\n\tbus_space_write_2(iot, ioh, EP_W1_TX_PIO_WR_1,\n\t    0xffff);\t/* Second dword meaningless */\n\tif (EP_IS_BUS_32(sc->bustype)) {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 3)\n\t\t\t\tbus_space_write_raw_multi_4(iot, ioh,\n\t\t\t\t    EP_W1_TX_PIO_WR_1, mtod(m, u_int8_t *),\n\t\t\t\t    m->m_len & ~3);\n\t\t\tif (m->m_len & 3)\n\t\t\t\tbus_space_write_multi_1(iot, ioh,\n\t\t\t\t    EP_W1_TX_PIO_WR_1,\n\t\t\t\t    mtod(m, u_int8_t *) + (m->m_len & ~3),\n\t\t\t\t    m->m_len & 3);\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t} else {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 1)\n\t\t\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t\t\t    EP_W1_TX_PIO_WR_1, mtod(m, u_int8_t *),\n\t\t\t\t    m->m_len & ~1);\n\t\t\tif (m->m_len & 1)\n\t\t\t\tbus_space_write_1(iot, ioh, EP_W1_TX_PIO_WR_1,\n\t\t\t\t     *(mtod(m, u_int8_t *) + m->m_len - 1));\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t}\n\twhile (pad--)\n\t\tbus_space_write_1(iot, ioh, EP_W1_TX_PIO_WR_1, 0);\n\n\tsplx(sh);\n\n\t++ifp->if_opackets;\n\nreadcheck:\n\tif ((bus_space_read_2(iot, ioh, EP_W1_RX_STATUS) & ERR_INCOMPLETE) ==\n\t    0) {\n\t\t/* We received a complete packet. */\n\t\tu_int16_t status = bus_space_read_2(iot, ioh, EP_STATUS);\n\n\t\tif ((status & S_INTR_LATCH) == 0) {\n\t\t\t/*\n\t\t\t * No interrupt, read the packet and continue\n\t\t\t * Is  this supposed to happen? Is my motherboard \n\t\t\t * completely busted?\n\t\t\t */\n\t\t\tepread(sc);\n\t\t} else\n\t\t\t/* Got an interrupt, return to get it serviced. */\n\t\t\treturn;\n\t} else {\n\t\t/* Check if we are stuck and reset [see XXX comment] */\n\t\tif (epstatus(sc)) {\n#ifdef EP_DEBUG\n\t\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: adapter reset\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\t\tepreset(sc);\n\t\t}\n\t}\n\n\tgoto startagain;\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ETHER_MAX_LEN   1518"
          ],
          "globals_used": [
            "int\tepstatus",
            "void\tepstart",
            "void\tepreset",
            "void\tepread",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_MAX_LEN   1518\n\nint\tepstatus;\nvoid\tepstart;\nvoid\tepreset;\nvoid\tepread;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ep_softc *sc = ifp->if_softc;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct mbuf *m, *m0;\n\tint sh, len, pad;\n\n\t/* Don't transmit if interface is busy or not running */\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\nstartagain:\n\t/* Sneak a peek at the next packet */\n\tm0 = ifp->if_snd.ifq_head;\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"epstart: no header mbuf\");\n\tlen = m0->m_pkthdr.len;\n\n\tpad = (4 - len) & 3;\n\n\t/*\n\t * The 3c509 automatically pads short packets to minimum ethernet\n\t * length, but we drop packets that are too large. Perhaps we should\n\t * truncate them instead?\n\t */\n\tif (len + pad > ETHER_MAX_LEN) {\n\t\t/* packet is obviously too large: toss it */\n\t\t++ifp->if_oerrors;\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tm_freem(m0);\n\t\tgoto readcheck;\n\t}\n\n\tif (bus_space_read_2(iot, ioh, EP_W1_FREE_TX) < len + pad + 4) {\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t\t    SET_TX_AVAIL_THRESH | ((len + pad + 4) >> sc->txashift));\n\t\t/* not enough room in FIFO */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t} else {\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t\t    SET_TX_AVAIL_THRESH | EP_THRESH_DISABLE);\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\t\t/* not really needed */\n\t\treturn;\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_TX_START_THRESH |\n\t    ((len / 4 + sc->tx_start_thresh) /*>> sc->txashift*/));\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/*\n\t * Do the output at splhigh() so that an interrupt from another device\n\t * won't cause a FIFO underrun.\n\t */\n\tsh = splhigh();\n\n\tbus_space_write_2(iot, ioh, EP_W1_TX_PIO_WR_1, len);\n\tbus_space_write_2(iot, ioh, EP_W1_TX_PIO_WR_1,\n\t    0xffff);\t/* Second dword meaningless */\n\tif (EP_IS_BUS_32(sc->bustype)) {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 3)\n\t\t\t\tbus_space_write_raw_multi_4(iot, ioh,\n\t\t\t\t    EP_W1_TX_PIO_WR_1, mtod(m, u_int8_t *),\n\t\t\t\t    m->m_len & ~3);\n\t\t\tif (m->m_len & 3)\n\t\t\t\tbus_space_write_multi_1(iot, ioh,\n\t\t\t\t    EP_W1_TX_PIO_WR_1,\n\t\t\t\t    mtod(m, u_int8_t *) + (m->m_len & ~3),\n\t\t\t\t    m->m_len & 3);\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t} else {\n\t\tfor (m = m0; m; ) {\n\t\t\tif (m->m_len > 1)\n\t\t\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t\t\t    EP_W1_TX_PIO_WR_1, mtod(m, u_int8_t *),\n\t\t\t\t    m->m_len & ~1);\n\t\t\tif (m->m_len & 1)\n\t\t\t\tbus_space_write_1(iot, ioh, EP_W1_TX_PIO_WR_1,\n\t\t\t\t     *(mtod(m, u_int8_t *) + m->m_len - 1));\n\t\t\tMFREE(m, m0);\n\t\t\tm = m0;\n\t\t}\n\t}\n\twhile (pad--)\n\t\tbus_space_write_1(iot, ioh, EP_W1_TX_PIO_WR_1, 0);\n\n\tsplx(sh);\n\n\t++ifp->if_opackets;\n\nreadcheck:\n\tif ((bus_space_read_2(iot, ioh, EP_W1_RX_STATUS) & ERR_INCOMPLETE) ==\n\t    0) {\n\t\t/* We received a complete packet. */\n\t\tu_int16_t status = bus_space_read_2(iot, ioh, EP_STATUS);\n\n\t\tif ((status & S_INTR_LATCH) == 0) {\n\t\t\t/*\n\t\t\t * No interrupt, read the packet and continue\n\t\t\t * Is  this supposed to happen? Is my motherboard \n\t\t\t * completely busted?\n\t\t\t */\n\t\t\tepread(sc);\n\t\t} else\n\t\t\t/* Got an interrupt, return to get it serviced. */\n\t\t\treturn;\n\t} else {\n\t\t/* Check if we are stuck and reset [see XXX comment] */\n\t\tif (epstatus(sc)) {\n#ifdef EP_DEBUG\n\t\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: adapter reset\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\t\tepreset(sc);\n\t\t}\n\t}\n\n\tgoto startagain;\n}"
        }
      },
      {
        "call_info": {
          "callee": "epmbuffill",
          "args": [
            "sc"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "epmbuffill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "1533-1554",
          "snippet": "void\nepmbuffill(v)\n\tvoid *v;\n{\n\tstruct ep_softc *sc = v;\n\tint s, i;\n\n\ts = splnet();\n\ti = sc->last_mb;\n\tdo {\n\t\tif (sc->mb[i] == NULL)\n\t\t\tMGET(sc->mb[i], M_DONTWAIT, MT_DATA);\n\t\tif (sc->mb[i] == NULL)\n\t\t\tbreak;\n\t\ti = (i + 1) % MAX_MBS;\n\t} while (i != sc->next_mb);\n\tsc->last_mb = i;\n\t/* If the queue was not filled, try again. */\n\tif (sc->last_mb != sc->next_mb)\n\t\ttimeout(epmbuffill, sc, 1);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tepmbuffill",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepmbuffill;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepmbuffill(v)\n\tvoid *v;\n{\n\tstruct ep_softc *sc = v;\n\tint s, i;\n\n\ts = splnet();\n\ti = sc->last_mb;\n\tdo {\n\t\tif (sc->mb[i] == NULL)\n\t\t\tMGET(sc->mb[i], M_DONTWAIT, MT_DATA);\n\t\tif (sc->mb[i] == NULL)\n\t\t\tbreak;\n\t\ti = (i + 1) % MAX_MBS;\n\t} while (i != sc->next_mb);\n\tsc->last_mb = i;\n\t/* If the queue was not filled, try again. */\n\tif (sc->last_mb != sc->next_mb)\n\t\ttimeout(epmbuffill, sc, 1);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "TX_ENABLE"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "RX_ENABLE"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epsetmedia",
          "args": [
            "sc",
            "sc->sc_media.ifm_cur->ifm_data"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "epsetmedia",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "634-746",
          "snippet": "int\nepsetmedia(sc, medium)\n\tstruct ep_softc *sc;\n\tint medium;\n{\n/*\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;*/\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint w4_media;\n\tint config0, config1;\n\n\t/*\n\t * you can `ifconfig (link0|-link0) ep0' to get the following\n\t * behaviour:\n\t *\t-link0\tdisable AUI/UTP. enable BNC.\n\t *\tlink0\tdisable BNC. enable AUI.\n\t *\tlink1\tif the card has a UTP connector, and link0 is\n\t *\t\tset too, then you get the UTP port.\n\t */\n\n\t/*\n\t * First, change the media-control bits in EP_W4_MEDIA_TYPE.\n\t */\n\n\t /* Turn everything off.  First turn off linkbeat and UTP. */\n\tGO_WINDOW(4);\n\tw4_media = bus_space_read_2(iot, ioh, EP_W4_MEDIA_TYPE);\n\tw4_media =  w4_media & ~(ENABLE_UTP|SQE_ENABLE);\n\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE, w4_media);\n\n\t/* Turn off coax */\n\tbus_space_write_2(iot, ioh, EP_COMMAND, STOP_TRANSCEIVER);\n\tdelay(1000);\n\n\t/*\n\t * Now turn on the selected media/transceiver.\n\t */\n\tGO_WINDOW(4);\n\tswitch  (medium) {\n\tcase EPMEDIA_10BASE_T:\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | ENABLE_UTP);\n\t\tbreak;\n\n\tcase EPMEDIA_10BASE_2:\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND, START_TRANSCEIVER);\n\t\tDELAY(1000);\t/* 50ms not enough? */\n\t\tbreak;\n\n\t/* XXX following only for new-generation cards */\n\tcase EPMEDIA_100BASE_TX:\n\tcase EPMEDIA_100BASE_FX:\n\tcase EPMEDIA_100BASE_T4:\t/* XXX check documentation */\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | LINKBEAT_ENABLE);\n\t\tDELAY(1000);\t/* not strictly necessary? */\n\t\tbreak;\n\n\tcase EPMEDIA_AUI:\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | SQE_ENABLE);\n\t\tDELAY(1000);\t/*  not strictly necessary? */\n\t\tbreak;\n\tcase EPMEDIA_MII:\n\t\tbreak;\n\tdefault:\n#if defined(EP_DEBUG)\n\t\tprintf(\"%s unknown media 0x%x\\n\", sc->sc_dev.dv_xname, medium);\n#endif\n\t\tbreak;\n\t\t\n\t}\n\n\t/*\n\t * Tell the chip which PHY [sic] to use.\n\t */\n\tswitch (sc->ep_chipset) {\n\tcase EP_CHIPSET_VORTEX:\n\tcase EP_CHIPSET_BOOMERANG2:\n\t\tGO_WINDOW(3);\n\t\tconfig0 = (u_int)bus_space_read_2(iot, ioh,\n\t\t    EP_W3_INTERNAL_CONFIG);\n\t\tconfig1 = (u_int)bus_space_read_2(iot, ioh,\n\t\t    EP_W3_INTERNAL_CONFIG + 2);\n\n#if defined(EP_DEBUG)\n\t\tprintf(\"%s:  read 0x%x, 0x%x from EP_W3_CONFIG register\\n\",\n\t\t       sc->sc_dev.dv_xname, config0, config1);\n#endif\n\t\tconfig1 = config1 & ~CONFIG_MEDIAMASK;\n\t\tconfig1 |= (medium << CONFIG_MEDIAMASK_SHIFT);\n\t\t\n#if defined(EP_DEBUG)\n\t\tprintf(\"epsetmedia: %s: medium 0x%x, 0x%x to EP_W3_CONFIG\\n\",\n\t\t    sc->sc_dev.dv_xname, medium, config1);\n#endif\n\t\tbus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG, config0);\n\t\tbus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2, config1);\n\t\tbreak;\n\n\tcase EP_CHIPSET_3C509:\n\t\tGO_WINDOW(0);\n\t\tconfig0 = bus_space_read_2(iot, ioh, EP_W0_ADDRESS_CFG);\n\t\tconfig0 &= 0x3fff;\n\t\tbus_space_write_2(iot, ioh, EP_W0_ADDRESS_CFG,\n\t\t    config0 | (medium << 14));\n\t\tDELAY(1000);\n\t\tbreak;\n\t}\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tepsetmedia",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tepsetmedia;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nint\nepsetmedia(sc, medium)\n\tstruct ep_softc *sc;\n\tint medium;\n{\n/*\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;*/\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint w4_media;\n\tint config0, config1;\n\n\t/*\n\t * you can `ifconfig (link0|-link0) ep0' to get the following\n\t * behaviour:\n\t *\t-link0\tdisable AUI/UTP. enable BNC.\n\t *\tlink0\tdisable BNC. enable AUI.\n\t *\tlink1\tif the card has a UTP connector, and link0 is\n\t *\t\tset too, then you get the UTP port.\n\t */\n\n\t/*\n\t * First, change the media-control bits in EP_W4_MEDIA_TYPE.\n\t */\n\n\t /* Turn everything off.  First turn off linkbeat and UTP. */\n\tGO_WINDOW(4);\n\tw4_media = bus_space_read_2(iot, ioh, EP_W4_MEDIA_TYPE);\n\tw4_media =  w4_media & ~(ENABLE_UTP|SQE_ENABLE);\n\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE, w4_media);\n\n\t/* Turn off coax */\n\tbus_space_write_2(iot, ioh, EP_COMMAND, STOP_TRANSCEIVER);\n\tdelay(1000);\n\n\t/*\n\t * Now turn on the selected media/transceiver.\n\t */\n\tGO_WINDOW(4);\n\tswitch  (medium) {\n\tcase EPMEDIA_10BASE_T:\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | ENABLE_UTP);\n\t\tbreak;\n\n\tcase EPMEDIA_10BASE_2:\n\t\tbus_space_write_2(iot, ioh, EP_COMMAND, START_TRANSCEIVER);\n\t\tDELAY(1000);\t/* 50ms not enough? */\n\t\tbreak;\n\n\t/* XXX following only for new-generation cards */\n\tcase EPMEDIA_100BASE_TX:\n\tcase EPMEDIA_100BASE_FX:\n\tcase EPMEDIA_100BASE_T4:\t/* XXX check documentation */\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | LINKBEAT_ENABLE);\n\t\tDELAY(1000);\t/* not strictly necessary? */\n\t\tbreak;\n\n\tcase EPMEDIA_AUI:\n\t\tbus_space_write_2(iot, ioh, EP_W4_MEDIA_TYPE,\n\t\t    w4_media | SQE_ENABLE);\n\t\tDELAY(1000);\t/*  not strictly necessary? */\n\t\tbreak;\n\tcase EPMEDIA_MII:\n\t\tbreak;\n\tdefault:\n#if defined(EP_DEBUG)\n\t\tprintf(\"%s unknown media 0x%x\\n\", sc->sc_dev.dv_xname, medium);\n#endif\n\t\tbreak;\n\t\t\n\t}\n\n\t/*\n\t * Tell the chip which PHY [sic] to use.\n\t */\n\tswitch (sc->ep_chipset) {\n\tcase EP_CHIPSET_VORTEX:\n\tcase EP_CHIPSET_BOOMERANG2:\n\t\tGO_WINDOW(3);\n\t\tconfig0 = (u_int)bus_space_read_2(iot, ioh,\n\t\t    EP_W3_INTERNAL_CONFIG);\n\t\tconfig1 = (u_int)bus_space_read_2(iot, ioh,\n\t\t    EP_W3_INTERNAL_CONFIG + 2);\n\n#if defined(EP_DEBUG)\n\t\tprintf(\"%s:  read 0x%x, 0x%x from EP_W3_CONFIG register\\n\",\n\t\t       sc->sc_dev.dv_xname, config0, config1);\n#endif\n\t\tconfig1 = config1 & ~CONFIG_MEDIAMASK;\n\t\tconfig1 |= (medium << CONFIG_MEDIAMASK_SHIFT);\n\t\t\n#if defined(EP_DEBUG)\n\t\tprintf(\"epsetmedia: %s: medium 0x%x, 0x%x to EP_W3_CONFIG\\n\",\n\t\t    sc->sc_dev.dv_xname, medium, config1);\n#endif\n\t\tbus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG, config0);\n\t\tbus_space_write_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2, config1);\n\t\tbreak;\n\n\tcase EP_CHIPSET_3C509:\n\t\tGO_WINDOW(0);\n\t\tconfig0 = bus_space_read_2(iot, ioh, EP_W0_ADDRESS_CFG);\n\t\tconfig0 &= 0x3fff;\n\t\tbus_space_write_2(iot, ioh, EP_W0_ADDRESS_CFG,\n\t\t    config0 | (medium << 14));\n\t\tDELAY(1000);\n\t\tbreak;\n\t}\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "epsetfilter",
          "args": [
            "sc"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "epsetfilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "604-615",
          "snippet": "void\nepsetfilter(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\tbus_space_write_2(sc->sc_iot, sc->sc_ioh, EP_COMMAND, SET_RX_FILTER |\n\t    FIL_INDIVIDUAL | FIL_BRDCST |\n\t    ((ifp->if_flags & IFF_MULTICAST) ? FIL_MULTICAST : 0 ) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? FIL_PROMISC : 0 ));\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tepsetfilter",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepsetfilter;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepsetfilter(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\tbus_space_write_2(sc->sc_iot, sc->sc_ioh, EP_COMMAND, SET_RX_FILTER |\n\t    FIL_INDIVIDUAL | FIL_BRDCST |\n\t    ((ifp->if_flags & IFF_MULTICAST) ? FIL_MULTICAST : 0 ) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? FIL_PROMISC : 0 ));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "ACK_INTR | 0xff"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "SET_INTR_MASK |\n\t    S_CARD_FAILURE | S_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "SET_RD_0_MASK |\n\t    S_CARD_FAILURE | S_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "SET_TX_AVAIL_THRESH | (1600 >> sc->txashift)"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "EP_W1_TX_STATUS"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "1"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_complete_cmd",
          "args": [
            "sc",
            "EP_COMMAND",
            "TX_RESET"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "ep_complete_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "178-196",
          "snippet": "static inline void\nep_complete_cmd(sc, cmd, arg)\n\tstruct ep_softc *sc;\n\tu_int cmd, arg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tbus_space_write_2(iot, ioh, cmd, arg);\n\n#ifdef notyet\n\t/* if this adapter family has S_COMMAND_IN_PROGRESS, use it */\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\telse\n#else\n\tDELAY(100000);\t/* need at least 1 ms, but be generous. */\n#endif\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ep_complete_cmd",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline void ep_complete_cmd;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nstatic inline void\nep_complete_cmd(sc, cmd, arg)\n\tstruct ep_softc *sc;\n\tu_int cmd, arg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tbus_space_write_2(iot, ioh, cmd, arg);\n\n#ifdef notyet\n\t/* if this adapter family has S_COMMAND_IN_PROGRESS, use it */\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\telse\n#else\n\tDELAY(100000);\t/* need at least 1 ms, but be generous. */\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "EP_W2_RECVMASK_0 + i",
            "0"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "EP_W2_ADDR_0 + i",
            "sc->sc_arpcom.ac_enaddr[i]"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "2"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_W0_RESOURCE_CFG",
            "0x3f00"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_W0_CONFIG_CTRL",
            "ENABLE_DRQ_IRQ"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_W0_CONFIG_CTRL",
            "0"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "0"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_STATUS"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tepstart;\nvoid\tepmbuffill;\nvoid\tepsetfilter;\nint\tepsetmedia;\nstatic inline void ep_complete_cmd;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepinit(sc)\n\tregister struct ep_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\n\tif (sc->bustype != EP_BUS_PCI) {\n\t\tGO_WINDOW(0);\n\t\tbus_space_write_2(iot, ioh, EP_W0_CONFIG_CTRL, 0);\n\t\tbus_space_write_2(iot, ioh, EP_W0_CONFIG_CTRL, ENABLE_DRQ_IRQ);\n\t}\n\n\tif (sc->bustype == EP_BUS_PCMCIA) {\n\t\tbus_space_write_2(iot, ioh, EP_W0_RESOURCE_CFG, 0x3f00);\n\t}\n\n\tGO_WINDOW(2);\n\tfor (i = 0; i < 6; i++)\t/* Reload the ether_addr. */\n\t\tbus_space_write_1(iot, ioh, EP_W2_ADDR_0 + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\tif (sc->bustype == EP_BUS_PCI || sc->bustype == EP_BUS_EISA)\n\t\t/*\n\t\t * Reset the station-address receive filter.\n\t\t * A bug workaround for busmastering  (Vortex, Demon) cards.\n\t\t */\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tbus_space_write_1(iot, ioh, EP_W2_RECVMASK_0 + i, 0);\n\n\tep_complete_cmd(sc, EP_COMMAND, RX_RESET);\n\tep_complete_cmd(sc, EP_COMMAND, TX_RESET);\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\tfor (i = 0; i < 31; i++)\n\t\tbus_space_read_1(iot, ioh, EP_W1_TX_STATUS);\n\n\t/* Set threshold for for Tx-space available interrupt. */\n\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t    SET_TX_AVAIL_THRESH | (1600 >> sc->txashift));\n\n\t/* Enable interrupts. */\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_RD_0_MASK |\n\t    S_CARD_FAILURE | S_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, SET_INTR_MASK |\n\t    S_CARD_FAILURE | S_RX_COMPLETE | S_TX_COMPLETE | S_TX_AVAIL);\n\n\t/*\n\t * Attempt to get rid of any stray interrupts that occured during\n\t * configuration.  On the i386 this isn't possible because one may\n\t * already be queued.  However, a single stray interrupt is\n\t * unimportant.\n\t */\n\tbus_space_write_2(iot, ioh, EP_COMMAND, ACK_INTR | 0xff);\n\n\tepsetfilter(sc);\n\tepsetmedia(sc, sc->sc_media.ifm_cur->ifm_data);\n\n\tbus_space_write_2(iot, ioh, EP_COMMAND, RX_ENABLE);\n\tbus_space_write_2(iot, ioh, EP_COMMAND, TX_ENABLE);\n\n\tepmbuffill(sc);\n\n\t/* Interface is now `running', with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Attempt to start output, if any. */\n\tepstart(ifp);\n}"
  },
  {
    "function_name": "ep_vortex_probemedia",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "458-515",
    "snippet": "void\nep_vortex_probemedia(sc)\n\tstruct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifmedia *ifm = &sc->sc_media;\n\tu_int config1, conn;\n\tint reset_options;\n\tint default_media;\t/* 3-bit encoding of default (EEPROM) media */\n\tint autoselect;\t\t/* boolean: should default to autoselect */\n\tconst char *medium_name;\n\tregister int i;\n\n\tGO_WINDOW(3);\n\tconfig1 = (u_int)bus_space_read_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2);\n\treset_options  = (int)bus_space_read_1(iot, ioh, EP_W3_RESET_OPTIONS);\n\tGO_WINDOW(0);\n\n\tdefault_media = (config1 & CONFIG_MEDIAMASK) >> CONFIG_MEDIAMASK_SHIFT;\n        autoselect = (config1 & CONFIG_AUTOSELECT) >> CONFIG_AUTOSELECT_SHIFT;\n\n\t/* set available media options */\n\tconn = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tstruct ep_media * epm = ep_vortex_media + i;\n\n\t\tif ((reset_options & epm->epm_eeprom_data) != 0) {\n\t\t\tif (conn) printf(\"/\");\n\t\t\tprintf(epm->epm_name);\n\t\t\tconn |= epm->epm_conn;\n\t\t\tifmedia_add(ifm, epm->epm_ifmedia, epm->epm_ifdata, 0);\n\t\t}\n\t}\n\n\tsc->ep_connectors = conn;\n\n\t/* Show  eeprom's idea of default media.  */\n\tmedium_name = (default_media > 8)\n\t\t? \"(unknown/impossible media)\"\n\t\t: ep_vortex_media[default_media].epm_name;\n\tprintf(\" default %s%s\",\n\t       medium_name,  (autoselect)? \"/autoselect\" : \"\" );\n/*\tsc->sc_media = ep_vortex_media[default_media].epm_ifdata;*/\n\n#ifdef notyet\t\n\t/*\n\t * Set default: either the active interface the card\n\t * reads  from the EEPROM, or if autoselect is true,\n\t * whatever we find is actually connected. \n\t *\n\t * XXX autoselect not yet implemented.\n\t */\n#endif\t/* notyet */\n\n\t/* tell ifconfig what currently-active media is. */\n\tifmedia_set(ifm, ep_default_to_media[default_media]);\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct ep_media ep_vortex_media[8] = {\n  { EP_PCI_UTP,        EPC_UTP, \"utp\",\t    IFM_ETHER|IFM_10_T,\n       EPMEDIA_10BASE_T },\n  { EP_PCI_AUI,        EPC_AUI, \"aui\",\t    IFM_ETHER|IFM_10_5,\n       EPMEDIA_AUI },\n  { 0,                 0,  \t\"reserved\", IFM_NONE,  EPMEDIA_RESV1 },\n  { EP_PCI_BNC,        EPC_BNC, \"bnc\",\t    IFM_ETHER|IFM_10_2,\n       EPMEDIA_10BASE_2 },\n  { EP_PCI_100BASE_TX, EPC_100TX, \"100-TX\", IFM_ETHER|IFM_100_TX,\n       EPMEDIA_100BASE_TX },\n  { EP_PCI_100BASE_FX, EPC_100FX, \"100-FX\", IFM_ETHER|IFM_100_FX,\n       EPMEDIA_100BASE_FX },\n  { EP_PCI_100BASE_MII,EPC_MII,   \"mii\",    IFM_ETHER|IFM_100_TX,\n       EPMEDIA_MII },\n  { EP_PCI_100BASE_T4, EPC_100T4, \"100-T4\", IFM_ETHER|IFM_100_T4,\n       EPMEDIA_100BASE_T4 }\n};",
      "const u_int ep_default_to_media[8] = {\n\tIFM_ETHER | IFM_10_T,\n\tIFM_ETHER | IFM_10_5,\n\t0, \t\t\t/* reserved by 3Com */\n\tIFM_ETHER | IFM_10_2,\n\tIFM_ETHER | IFM_100_TX,\n\tIFM_ETHER | IFM_100_FX,\n\tIFM_ETHER | IFM_100_TX,\t/* XXX really MII: need to talk to PHY */\n\tIFM_ETHER | IFM_100_T4,\n};",
      "void\tep_vortex_probemedia",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "ifm",
            "ep_default_to_media[default_media]"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" default %s%s\"",
            "medium_name",
            "(autoselect)? \"/autoselect\" : \"\""
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "ifm",
            "epm->epm_ifmedia",
            "epm->epm_ifdata",
            "0"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "0"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "EP_W3_RESET_OPTIONS"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_W3_INTERNAL_CONFIG + 2"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "3"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct ep_media ep_vortex_media[8] = {\n  { EP_PCI_UTP,        EPC_UTP, \"utp\",\t    IFM_ETHER|IFM_10_T,\n       EPMEDIA_10BASE_T },\n  { EP_PCI_AUI,        EPC_AUI, \"aui\",\t    IFM_ETHER|IFM_10_5,\n       EPMEDIA_AUI },\n  { 0,                 0,  \t\"reserved\", IFM_NONE,  EPMEDIA_RESV1 },\n  { EP_PCI_BNC,        EPC_BNC, \"bnc\",\t    IFM_ETHER|IFM_10_2,\n       EPMEDIA_10BASE_2 },\n  { EP_PCI_100BASE_TX, EPC_100TX, \"100-TX\", IFM_ETHER|IFM_100_TX,\n       EPMEDIA_100BASE_TX },\n  { EP_PCI_100BASE_FX, EPC_100FX, \"100-FX\", IFM_ETHER|IFM_100_FX,\n       EPMEDIA_100BASE_FX },\n  { EP_PCI_100BASE_MII,EPC_MII,   \"mii\",    IFM_ETHER|IFM_100_TX,\n       EPMEDIA_MII },\n  { EP_PCI_100BASE_T4, EPC_100T4, \"100-T4\", IFM_ETHER|IFM_100_T4,\n       EPMEDIA_100BASE_T4 }\n};\nconst u_int ep_default_to_media[8] = {\n\tIFM_ETHER | IFM_10_T,\n\tIFM_ETHER | IFM_10_5,\n\t0, \t\t\t/* reserved by 3Com */\n\tIFM_ETHER | IFM_10_2,\n\tIFM_ETHER | IFM_100_TX,\n\tIFM_ETHER | IFM_100_FX,\n\tIFM_ETHER | IFM_100_TX,\t/* XXX really MII: need to talk to PHY */\n\tIFM_ETHER | IFM_100_T4,\n};\nvoid\tep_vortex_probemedia;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nep_vortex_probemedia(sc)\n\tstruct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifmedia *ifm = &sc->sc_media;\n\tu_int config1, conn;\n\tint reset_options;\n\tint default_media;\t/* 3-bit encoding of default (EEPROM) media */\n\tint autoselect;\t\t/* boolean: should default to autoselect */\n\tconst char *medium_name;\n\tregister int i;\n\n\tGO_WINDOW(3);\n\tconfig1 = (u_int)bus_space_read_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2);\n\treset_options  = (int)bus_space_read_1(iot, ioh, EP_W3_RESET_OPTIONS);\n\tGO_WINDOW(0);\n\n\tdefault_media = (config1 & CONFIG_MEDIAMASK) >> CONFIG_MEDIAMASK_SHIFT;\n        autoselect = (config1 & CONFIG_AUTOSELECT) >> CONFIG_AUTOSELECT_SHIFT;\n\n\t/* set available media options */\n\tconn = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tstruct ep_media * epm = ep_vortex_media + i;\n\n\t\tif ((reset_options & epm->epm_eeprom_data) != 0) {\n\t\t\tif (conn) printf(\"/\");\n\t\t\tprintf(epm->epm_name);\n\t\t\tconn |= epm->epm_conn;\n\t\t\tifmedia_add(ifm, epm->epm_ifmedia, epm->epm_ifdata, 0);\n\t\t}\n\t}\n\n\tsc->ep_connectors = conn;\n\n\t/* Show  eeprom's idea of default media.  */\n\tmedium_name = (default_media > 8)\n\t\t? \"(unknown/impossible media)\"\n\t\t: ep_vortex_media[default_media].epm_name;\n\tprintf(\" default %s%s\",\n\t       medium_name,  (autoselect)? \"/autoselect\" : \"\" );\n/*\tsc->sc_media = ep_vortex_media[default_media].epm_ifdata;*/\n\n#ifdef notyet\t\n\t/*\n\t * Set default: either the active interface the card\n\t * reads  from the EEPROM, or if autoselect is true,\n\t * whatever we find is actually connected. \n\t *\n\t * XXX autoselect not yet implemented.\n\t */\n#endif\t/* notyet */\n\n\t/* tell ifconfig what currently-active media is. */\n\tifmedia_set(ifm, ep_default_to_media[default_media]);\n}"
  },
  {
    "function_name": "ep_isa_probemedia",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "406-447",
    "snippet": "void\nep_isa_probemedia(sc)\n\tstruct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifmedia *ifm = &sc->sc_media;\n\tint\tconn, i;\n\tu_int16_t ep_w0_config, port;\n\n\tconn = 0;\n\tGO_WINDOW(0);\n\tep_w0_config = bus_space_read_2(iot, ioh, EP_W0_CONFIG_CTRL);\n\tfor (i = 0; i < 3; i++) {\n\t\tstruct ep_media * epm = ep_isa_media + i;\n\n\t\tif ((ep_w0_config & epm->epm_eeprom_data) != 0) {\n\t\t\tifmedia_add(ifm, epm->epm_ifmedia, epm->epm_ifdata, 0);\n\t\t\tif (conn)\n\t\t\t\tprintf(\"/\");\n\t\t\tprintf(epm->epm_name);\n\t\t\tconn |= epm->epm_conn;\n\t\t}\n\t}\n\tsc->ep_connectors = conn;\n\n\t/* get default medium from EEPROM */\n\tif (epbusyeeprom(sc))\n\t\treturn;\t\t/* XXX why is eeprom busy? */\n\tbus_space_write_2(iot, ioh, EP_W0_EEPROM_COMMAND,\n\t    READ_EEPROM | EEPROM_ADDR_CFG);\n\tif (epbusyeeprom(sc))\n\t\treturn;\t\t/* XXX why is  eeprom busy? */\n\tport = bus_space_read_2(iot, ioh, EP_W0_EEPROM_DATA);\n\tport = port >> 14;\n\n\tprintf(\" (default %s)\\n\", ep_vortex_media[port].epm_name);\n\t/* tell ifconfig what currently-active media is. */\n\tifmedia_set(ifm, ep_default_to_media[port]);\n\n\t/* XXX autoselect not yet implemented */\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct ep_media ep_vortex_media[8] = {\n  { EP_PCI_UTP,        EPC_UTP, \"utp\",\t    IFM_ETHER|IFM_10_T,\n       EPMEDIA_10BASE_T },\n  { EP_PCI_AUI,        EPC_AUI, \"aui\",\t    IFM_ETHER|IFM_10_5,\n       EPMEDIA_AUI },\n  { 0,                 0,  \t\"reserved\", IFM_NONE,  EPMEDIA_RESV1 },\n  { EP_PCI_BNC,        EPC_BNC, \"bnc\",\t    IFM_ETHER|IFM_10_2,\n       EPMEDIA_10BASE_2 },\n  { EP_PCI_100BASE_TX, EPC_100TX, \"100-TX\", IFM_ETHER|IFM_100_TX,\n       EPMEDIA_100BASE_TX },\n  { EP_PCI_100BASE_FX, EPC_100FX, \"100-FX\", IFM_ETHER|IFM_100_FX,\n       EPMEDIA_100BASE_FX },\n  { EP_PCI_100BASE_MII,EPC_MII,   \"mii\",    IFM_ETHER|IFM_100_TX,\n       EPMEDIA_MII },\n  { EP_PCI_100BASE_T4, EPC_100T4, \"100-T4\", IFM_ETHER|IFM_100_T4,\n       EPMEDIA_100BASE_T4 }\n};",
      "struct ep_media ep_isa_media[3] = {\n  { EP_W0_CC_UTP,  EPC_UTP, \"utp\",   IFM_ETHER|IFM_10_T, EPMEDIA_10BASE_T },\n  { EP_W0_CC_AUI,  EPC_AUI, \"aui\",   IFM_ETHER|IFM_10_5, EPMEDIA_AUI },\n  { EP_W0_CC_BNC,  EPC_BNC, \"bnc\",   IFM_ETHER|IFM_10_2, EPMEDIA_10BASE_2 },\n};",
      "const u_int ep_default_to_media[8] = {\n\tIFM_ETHER | IFM_10_T,\n\tIFM_ETHER | IFM_10_5,\n\t0, \t\t\t/* reserved by 3Com */\n\tIFM_ETHER | IFM_10_2,\n\tIFM_ETHER | IFM_100_TX,\n\tIFM_ETHER | IFM_100_FX,\n\tIFM_ETHER | IFM_100_TX,\t/* XXX really MII: need to talk to PHY */\n\tIFM_ETHER | IFM_100_T4,\n};",
      "void\tep_isa_probemedia",
      "int\tepbusyeeprom",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "ifm",
            "ep_default_to_media[port]"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" (default %s)\\n\"",
            "ep_vortex_media[port].epm_name"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_W0_EEPROM_DATA"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epbusyeeprom",
          "args": [
            "sc"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "epbusyeeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "1504-1531",
          "snippet": "int\nepbusyeeprom(sc)\n\tstruct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i = 100, j;\n\n\twhile (i--) {\n\t\tj = bus_space_read_2(iot, ioh, EP_W0_EEPROM_COMMAND);\n\t\tif (j & EEPROM_BUSY)\n\t\t\tdelay(100);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!i) {\n\t\tprintf(\"\\n%s: eeprom failed to come ready\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\tif (sc->bustype != EP_BUS_PCMCIA && sc->bustype != EP_BUS_PCI &&\n\t    (j & EEPROM_TST_MODE)) {\n\t\tprintf(\"\\n%s: erase pencil mark, or disable PnP mode!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tepbusyeeprom",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tepbusyeeprom;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nint\nepbusyeeprom(sc)\n\tstruct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i = 100, j;\n\n\twhile (i--) {\n\t\tj = bus_space_read_2(iot, ioh, EP_W0_EEPROM_COMMAND);\n\t\tif (j & EEPROM_BUSY)\n\t\t\tdelay(100);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!i) {\n\t\tprintf(\"\\n%s: eeprom failed to come ready\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\tif (sc->bustype != EP_BUS_PCMCIA && sc->bustype != EP_BUS_PCI &&\n\t    (j & EEPROM_TST_MODE)) {\n\t\tprintf(\"\\n%s: erase pencil mark, or disable PnP mode!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_W0_EEPROM_COMMAND",
            "READ_EEPROM | EEPROM_ADDR_CFG"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "ifm",
            "epm->epm_ifmedia",
            "epm->epm_ifdata",
            "0"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_W0_CONFIG_CTRL"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "0"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct ep_media ep_vortex_media[8] = {\n  { EP_PCI_UTP,        EPC_UTP, \"utp\",\t    IFM_ETHER|IFM_10_T,\n       EPMEDIA_10BASE_T },\n  { EP_PCI_AUI,        EPC_AUI, \"aui\",\t    IFM_ETHER|IFM_10_5,\n       EPMEDIA_AUI },\n  { 0,                 0,  \t\"reserved\", IFM_NONE,  EPMEDIA_RESV1 },\n  { EP_PCI_BNC,        EPC_BNC, \"bnc\",\t    IFM_ETHER|IFM_10_2,\n       EPMEDIA_10BASE_2 },\n  { EP_PCI_100BASE_TX, EPC_100TX, \"100-TX\", IFM_ETHER|IFM_100_TX,\n       EPMEDIA_100BASE_TX },\n  { EP_PCI_100BASE_FX, EPC_100FX, \"100-FX\", IFM_ETHER|IFM_100_FX,\n       EPMEDIA_100BASE_FX },\n  { EP_PCI_100BASE_MII,EPC_MII,   \"mii\",    IFM_ETHER|IFM_100_TX,\n       EPMEDIA_MII },\n  { EP_PCI_100BASE_T4, EPC_100T4, \"100-T4\", IFM_ETHER|IFM_100_T4,\n       EPMEDIA_100BASE_T4 }\n};\nstruct ep_media ep_isa_media[3] = {\n  { EP_W0_CC_UTP,  EPC_UTP, \"utp\",   IFM_ETHER|IFM_10_T, EPMEDIA_10BASE_T },\n  { EP_W0_CC_AUI,  EPC_AUI, \"aui\",   IFM_ETHER|IFM_10_5, EPMEDIA_AUI },\n  { EP_W0_CC_BNC,  EPC_BNC, \"bnc\",   IFM_ETHER|IFM_10_2, EPMEDIA_10BASE_2 },\n};\nconst u_int ep_default_to_media[8] = {\n\tIFM_ETHER | IFM_10_T,\n\tIFM_ETHER | IFM_10_5,\n\t0, \t\t\t/* reserved by 3Com */\n\tIFM_ETHER | IFM_10_2,\n\tIFM_ETHER | IFM_100_TX,\n\tIFM_ETHER | IFM_100_FX,\n\tIFM_ETHER | IFM_100_TX,\t/* XXX really MII: need to talk to PHY */\n\tIFM_ETHER | IFM_100_T4,\n};\nvoid\tep_isa_probemedia;\nint\tepbusyeeprom;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nep_isa_probemedia(sc)\n\tstruct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifmedia *ifm = &sc->sc_media;\n\tint\tconn, i;\n\tu_int16_t ep_w0_config, port;\n\n\tconn = 0;\n\tGO_WINDOW(0);\n\tep_w0_config = bus_space_read_2(iot, ioh, EP_W0_CONFIG_CTRL);\n\tfor (i = 0; i < 3; i++) {\n\t\tstruct ep_media * epm = ep_isa_media + i;\n\n\t\tif ((ep_w0_config & epm->epm_eeprom_data) != 0) {\n\t\t\tifmedia_add(ifm, epm->epm_ifmedia, epm->epm_ifdata, 0);\n\t\t\tif (conn)\n\t\t\t\tprintf(\"/\");\n\t\t\tprintf(epm->epm_name);\n\t\t\tconn |= epm->epm_conn;\n\t\t}\n\t}\n\tsc->ep_connectors = conn;\n\n\t/* get default medium from EEPROM */\n\tif (epbusyeeprom(sc))\n\t\treturn;\t\t/* XXX why is eeprom busy? */\n\tbus_space_write_2(iot, ioh, EP_W0_EEPROM_COMMAND,\n\t    READ_EEPROM | EEPROM_ADDR_CFG);\n\tif (epbusyeeprom(sc))\n\t\treturn;\t\t/* XXX why is  eeprom busy? */\n\tport = bus_space_read_2(iot, ioh, EP_W0_EEPROM_DATA);\n\tport = port >> 14;\n\n\tprintf(\" (default %s)\\n\", ep_vortex_media[port].epm_name);\n\t/* tell ifconfig what currently-active media is. */\n\tifmedia_set(ifm, ep_default_to_media[port]);\n\n\t/* XXX autoselect not yet implemented */\n}"
  },
  {
    "function_name": "ep_internalconfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "360-393",
    "snippet": "void\nep_internalconfig(sc)\n\tstruct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tu_int config0;\n\tu_int config1;\n\n\tint  ram_size, ram_width, ram_speed, rom_size, ram_split;\n\t/*\n\t * NVRAM buffer Rx:Tx config names for busmastering cards\n\t * (Demon, Vortex, and later).\n\t */\n\tconst char *onboard_ram_config[] = {\n\t\t\"5:3\", \"3:1\", \"1:1\", \"(undefined)\" };\n\n\tGO_WINDOW(3);\n\tconfig0 = (u_int)bus_space_read_2(iot, ioh, EP_W3_INTERNAL_CONFIG);\n\tconfig1 = (u_int)bus_space_read_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2);\n\tGO_WINDOW(0);\n\n\tram_size  = (config0 & CONFIG_RAMSIZE) >> CONFIG_RAMSIZE_SHIFT;\n\tram_width = (config0 & CONFIG_RAMWIDTH) >> CONFIG_RAMWIDTH_SHIFT;\n\tram_speed = (config0 & CONFIG_RAMSPEED) >> CONFIG_RAMSPEED_SHIFT;\n\trom_size  = (config0 & CONFIG_ROMSIZE) >> CONFIG_ROMSIZE_SHIFT;\n\n\tram_split  = (config1 & CONFIG_RAMSPLIT) >> CONFIG_RAMSPLIT_SHIFT;\n\n\tprintf(\"%s: %dKB %s-wide FIFO, %s Rx:Tx split, \",\n\t    sc->sc_dev.dv_xname, 8 << ram_size, (ram_width) ? \"word\" : \"byte\",\n\t    onboard_ram_config[ram_split]);\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %dKB %s-wide FIFO, %s Rx:Tx split, \"",
            "sc->sc_dev.dv_xname",
            "8 << ram_size",
            "(ram_width) ? \"word\" : \"byte\"",
            "onboard_ram_config[ram_split]"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "0"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_W3_INTERNAL_CONFIG + 2"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_W3_INTERNAL_CONFIG"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "3"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nep_internalconfig(sc)\n\tstruct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tu_int config0;\n\tu_int config1;\n\n\tint  ram_size, ram_width, ram_speed, rom_size, ram_split;\n\t/*\n\t * NVRAM buffer Rx:Tx config names for busmastering cards\n\t * (Demon, Vortex, and later).\n\t */\n\tconst char *onboard_ram_config[] = {\n\t\t\"5:3\", \"3:1\", \"1:1\", \"(undefined)\" };\n\n\tGO_WINDOW(3);\n\tconfig0 = (u_int)bus_space_read_2(iot, ioh, EP_W3_INTERNAL_CONFIG);\n\tconfig1 = (u_int)bus_space_read_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2);\n\tGO_WINDOW(0);\n\n\tram_size  = (config0 & CONFIG_RAMSIZE) >> CONFIG_RAMSIZE_SHIFT;\n\tram_width = (config0 & CONFIG_RAMWIDTH) >> CONFIG_RAMWIDTH_SHIFT;\n\tram_speed = (config0 & CONFIG_RAMSPEED) >> CONFIG_RAMSPEED_SHIFT;\n\trom_size  = (config0 & CONFIG_ROMSIZE) >> CONFIG_ROMSIZE_SHIFT;\n\n\tram_split  = (config1 & CONFIG_RAMSPLIT) >> CONFIG_RAMSPLIT_SHIFT;\n\n\tprintf(\"%s: %dKB %s-wide FIFO, %s Rx:Tx split, \",\n\t    sc->sc_dev.dv_xname, 8 << ram_size, (ram_width) ? \"word\" : \"byte\",\n\t    onboard_ram_config[ram_split]);\n}"
  },
  {
    "function_name": "epconfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "201-351",
    "snippet": "void\nepconfig(sc, chipset, enaddr)\n\tstruct ep_softc *sc;\n\tu_short chipset;\n\tu_int8_t *enaddr;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t i;\n\n\tsc->ep_chipset = chipset;\n\n\t/*\n\t * We could have been groveling around in other register\n\t * windows in the front-end; make sure we're in window 0\n\t * to read the EEPROM.\n\t */\n\tGO_WINDOW(0);\n\n\tif (enaddr == NULL) {\n\t\t/*\n\t\t * Read the station address from the eeprom\n\t\t */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tu_int16_t x;\n\t\t\tif (epbusyeeprom(sc))\n\t\t\t\treturn;\t\t/* XXX why is eeprom busy? */\n\t\t\tbus_space_write_2(iot, ioh, EP_W0_EEPROM_COMMAND,\n\t\t\t    READ_EEPROM | i);\n\t\t\tif (epbusyeeprom(sc))\n\t\t\t\treturn;\t\t/* XXX why is eeprom busy? */\n\t\t\tx = bus_space_read_2(iot, ioh, EP_W0_EEPROM_DATA);\n\t\t\tsc->sc_arpcom.ac_enaddr[(i << 1)] = x >> 8;\n\t\t\tsc->sc_arpcom.ac_enaddr[(i << 1) + 1] = x;\n\t\t}\n\t} else {\n\t\tbcopy(enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\t}\n\n\tprintf(\" address %s, \", ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\t/*\n\t * Vortex-based (3c59x pci,eisa) cards allow FDDI-sized (4500) byte\n\t * packets.  Commands only take an 11-bit parameter, and  11 bits\n\t * isn't enough to hold a full-size packet length.\n\t * Commands to these cards implicitly upshift a packet size\n\t * or threshold by 2 bits. \n\t * To detect  cards with large-packet support, we probe by setting\n\t * the transmit threshold register, then change windows and\n\t * read back the threshold register directly, and see if the\n\t * threshold value was shifted or not.\n\t */\n\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t\t\t  SET_TX_AVAIL_THRESH | EP_LARGEWIN_PROBE ); \n\tGO_WINDOW(5);\n\ti = bus_space_read_2(iot, ioh, EP_W5_TX_AVAIL_THRESH);\n\tGO_WINDOW(1);\n\tswitch (i)  {\n\tcase EP_LARGEWIN_PROBE:\n\tcase (EP_LARGEWIN_PROBE & EP_LARGEWIN_MASK):\n\t\tsc->txashift = 0;\n\t\tbreak;\n\n\tcase (EP_LARGEWIN_PROBE << 2):\n\t\tsc->txashift = 2;\n\t\t/* XXX does the 3c515 support Vortex-style RESET_OPTIONS? */\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"wrote %d to TX_AVAIL_THRESH, read back %d. \"\n\t\t    \"Interface disabled\\n\", EP_THRESH_DISABLE, (int) i);\n\t\treturn;\n\t}\n\n\t/*\n\t * Ensure Tx-available interrupts are enabled for \n\t * start the interface.\n\t * XXX should be in epinit()?\n\t */\n\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t    SET_TX_AVAIL_THRESH | (1600 >> sc->txashift));\n\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = epstart;\n\tifp->if_ioctl = epioctl;\n\tifp->if_watchdog = epwatchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n\t/*\n\t * Finish configuration: \n\t * determine chipset if the front-end couldn't do so,\n\t * show board details, set media.\n\t */\n\n#ifdef __NetBSD__\n\t/* print RAM size */\n\tep_internalconfig(sc);\n#endif\n\tGO_WINDOW(0);\n\n\tifmedia_init(&sc->sc_media, 0, ep_media_change, ep_media_status);\n\n\t/*\n\t * If we've got an indirect (ISA, PCMCIA?) board, the chipset\n\t * is unknown.  If the board has large-packet support, it's a\n\t * Vortex/Boomerang, otherwise it's a 3c509.\n\t * XXX use eeprom capability word instead?\n\t */\n\tif (sc->ep_chipset == EP_CHIPSET_UNKNOWN && sc->txashift)  {\n\t\tprintf(\"warning: unknown chipset, possibly 3c515?\\n\");\n#ifdef notyet\n\t\tsc->sc_chipset = EP_CHIPSET_VORTEX;\n#endif\t/* notyet */\n\t}\n\n\t/*\n\t * Ascertain which media types are present and inform ifmedia.\n\t */\n\tswitch (sc->ep_chipset) {\n\t/* on a direct bus, the attach routine can tell, but check anyway. */\n\tcase EP_CHIPSET_VORTEX:\n\tcase EP_CHIPSET_BOOMERANG2:\n\t\tep_vortex_probemedia(sc);\n\t\tbreak;\n\n\t/* on ISA we can't yet tell 3c509 from 3c515. Assume the former. */\n\tcase EP_CHIPSET_3C509:\n\tdefault:\n\t\tep_isa_probemedia(sc);\n\t\tbreak;\n\t}\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t    sizeof (struct ether_header));\n#endif\n\n\tsc->tx_start_thresh = 20;\t/* probably a good starting point. */\n\n\tep_complete_cmd(sc, EP_COMMAND, RX_RESET);\n\tep_complete_cmd(sc, EP_COMMAND, TX_RESET);\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ETHER_ADDR_LEN  6"
    ],
    "globals_used": [
      "void\tep_vortex_probemedia",
      "void\tep_isa_probemedia",
      "int\tepioctl",
      "void\tepstart",
      "void\tepwatchdog",
      "int\tep_media_change",
      "void\tep_media_status",
      "int\tepbusyeeprom",
      "static inline void ep_complete_cmd",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_complete_cmd",
          "args": [
            "sc",
            "EP_COMMAND",
            "TX_RESET"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "ep_complete_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "178-196",
          "snippet": "static inline void\nep_complete_cmd(sc, cmd, arg)\n\tstruct ep_softc *sc;\n\tu_int cmd, arg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tbus_space_write_2(iot, ioh, cmd, arg);\n\n#ifdef notyet\n\t/* if this adapter family has S_COMMAND_IN_PROGRESS, use it */\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\telse\n#else\n\tDELAY(100000);\t/* need at least 1 ms, but be generous. */\n#endif\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ep_complete_cmd",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline void ep_complete_cmd;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nstatic inline void\nep_complete_cmd(sc, cmd, arg)\n\tstruct ep_softc *sc;\n\tu_int cmd, arg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tbus_space_write_2(iot, ioh, cmd, arg);\n\n#ifdef notyet\n\t/* if this adapter family has S_COMMAND_IN_PROGRESS, use it */\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\telse\n#else\n\tDELAY(100000);\t/* need at least 1 ms, but be generous. */\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&sc->sc_arpcom.ac_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof (struct ether_header)"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "1"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_isa_probemedia",
          "args": [
            "sc"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "ep_isa_probemedia",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "406-447",
          "snippet": "void\nep_isa_probemedia(sc)\n\tstruct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifmedia *ifm = &sc->sc_media;\n\tint\tconn, i;\n\tu_int16_t ep_w0_config, port;\n\n\tconn = 0;\n\tGO_WINDOW(0);\n\tep_w0_config = bus_space_read_2(iot, ioh, EP_W0_CONFIG_CTRL);\n\tfor (i = 0; i < 3; i++) {\n\t\tstruct ep_media * epm = ep_isa_media + i;\n\n\t\tif ((ep_w0_config & epm->epm_eeprom_data) != 0) {\n\t\t\tifmedia_add(ifm, epm->epm_ifmedia, epm->epm_ifdata, 0);\n\t\t\tif (conn)\n\t\t\t\tprintf(\"/\");\n\t\t\tprintf(epm->epm_name);\n\t\t\tconn |= epm->epm_conn;\n\t\t}\n\t}\n\tsc->ep_connectors = conn;\n\n\t/* get default medium from EEPROM */\n\tif (epbusyeeprom(sc))\n\t\treturn;\t\t/* XXX why is eeprom busy? */\n\tbus_space_write_2(iot, ioh, EP_W0_EEPROM_COMMAND,\n\t    READ_EEPROM | EEPROM_ADDR_CFG);\n\tif (epbusyeeprom(sc))\n\t\treturn;\t\t/* XXX why is  eeprom busy? */\n\tport = bus_space_read_2(iot, ioh, EP_W0_EEPROM_DATA);\n\tport = port >> 14;\n\n\tprintf(\" (default %s)\\n\", ep_vortex_media[port].epm_name);\n\t/* tell ifconfig what currently-active media is. */\n\tifmedia_set(ifm, ep_default_to_media[port]);\n\n\t/* XXX autoselect not yet implemented */\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct ep_media ep_vortex_media[8] = {\n  { EP_PCI_UTP,        EPC_UTP, \"utp\",\t    IFM_ETHER|IFM_10_T,\n       EPMEDIA_10BASE_T },\n  { EP_PCI_AUI,        EPC_AUI, \"aui\",\t    IFM_ETHER|IFM_10_5,\n       EPMEDIA_AUI },\n  { 0,                 0,  \t\"reserved\", IFM_NONE,  EPMEDIA_RESV1 },\n  { EP_PCI_BNC,        EPC_BNC, \"bnc\",\t    IFM_ETHER|IFM_10_2,\n       EPMEDIA_10BASE_2 },\n  { EP_PCI_100BASE_TX, EPC_100TX, \"100-TX\", IFM_ETHER|IFM_100_TX,\n       EPMEDIA_100BASE_TX },\n  { EP_PCI_100BASE_FX, EPC_100FX, \"100-FX\", IFM_ETHER|IFM_100_FX,\n       EPMEDIA_100BASE_FX },\n  { EP_PCI_100BASE_MII,EPC_MII,   \"mii\",    IFM_ETHER|IFM_100_TX,\n       EPMEDIA_MII },\n  { EP_PCI_100BASE_T4, EPC_100T4, \"100-T4\", IFM_ETHER|IFM_100_T4,\n       EPMEDIA_100BASE_T4 }\n};",
            "struct ep_media ep_isa_media[3] = {\n  { EP_W0_CC_UTP,  EPC_UTP, \"utp\",   IFM_ETHER|IFM_10_T, EPMEDIA_10BASE_T },\n  { EP_W0_CC_AUI,  EPC_AUI, \"aui\",   IFM_ETHER|IFM_10_5, EPMEDIA_AUI },\n  { EP_W0_CC_BNC,  EPC_BNC, \"bnc\",   IFM_ETHER|IFM_10_2, EPMEDIA_10BASE_2 },\n};",
            "const u_int ep_default_to_media[8] = {\n\tIFM_ETHER | IFM_10_T,\n\tIFM_ETHER | IFM_10_5,\n\t0, \t\t\t/* reserved by 3Com */\n\tIFM_ETHER | IFM_10_2,\n\tIFM_ETHER | IFM_100_TX,\n\tIFM_ETHER | IFM_100_FX,\n\tIFM_ETHER | IFM_100_TX,\t/* XXX really MII: need to talk to PHY */\n\tIFM_ETHER | IFM_100_T4,\n};",
            "void\tep_isa_probemedia",
            "int\tepbusyeeprom",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct ep_media ep_vortex_media[8] = {\n  { EP_PCI_UTP,        EPC_UTP, \"utp\",\t    IFM_ETHER|IFM_10_T,\n       EPMEDIA_10BASE_T },\n  { EP_PCI_AUI,        EPC_AUI, \"aui\",\t    IFM_ETHER|IFM_10_5,\n       EPMEDIA_AUI },\n  { 0,                 0,  \t\"reserved\", IFM_NONE,  EPMEDIA_RESV1 },\n  { EP_PCI_BNC,        EPC_BNC, \"bnc\",\t    IFM_ETHER|IFM_10_2,\n       EPMEDIA_10BASE_2 },\n  { EP_PCI_100BASE_TX, EPC_100TX, \"100-TX\", IFM_ETHER|IFM_100_TX,\n       EPMEDIA_100BASE_TX },\n  { EP_PCI_100BASE_FX, EPC_100FX, \"100-FX\", IFM_ETHER|IFM_100_FX,\n       EPMEDIA_100BASE_FX },\n  { EP_PCI_100BASE_MII,EPC_MII,   \"mii\",    IFM_ETHER|IFM_100_TX,\n       EPMEDIA_MII },\n  { EP_PCI_100BASE_T4, EPC_100T4, \"100-T4\", IFM_ETHER|IFM_100_T4,\n       EPMEDIA_100BASE_T4 }\n};\nstruct ep_media ep_isa_media[3] = {\n  { EP_W0_CC_UTP,  EPC_UTP, \"utp\",   IFM_ETHER|IFM_10_T, EPMEDIA_10BASE_T },\n  { EP_W0_CC_AUI,  EPC_AUI, \"aui\",   IFM_ETHER|IFM_10_5, EPMEDIA_AUI },\n  { EP_W0_CC_BNC,  EPC_BNC, \"bnc\",   IFM_ETHER|IFM_10_2, EPMEDIA_10BASE_2 },\n};\nconst u_int ep_default_to_media[8] = {\n\tIFM_ETHER | IFM_10_T,\n\tIFM_ETHER | IFM_10_5,\n\t0, \t\t\t/* reserved by 3Com */\n\tIFM_ETHER | IFM_10_2,\n\tIFM_ETHER | IFM_100_TX,\n\tIFM_ETHER | IFM_100_FX,\n\tIFM_ETHER | IFM_100_TX,\t/* XXX really MII: need to talk to PHY */\n\tIFM_ETHER | IFM_100_T4,\n};\nvoid\tep_isa_probemedia;\nint\tepbusyeeprom;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nep_isa_probemedia(sc)\n\tstruct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifmedia *ifm = &sc->sc_media;\n\tint\tconn, i;\n\tu_int16_t ep_w0_config, port;\n\n\tconn = 0;\n\tGO_WINDOW(0);\n\tep_w0_config = bus_space_read_2(iot, ioh, EP_W0_CONFIG_CTRL);\n\tfor (i = 0; i < 3; i++) {\n\t\tstruct ep_media * epm = ep_isa_media + i;\n\n\t\tif ((ep_w0_config & epm->epm_eeprom_data) != 0) {\n\t\t\tifmedia_add(ifm, epm->epm_ifmedia, epm->epm_ifdata, 0);\n\t\t\tif (conn)\n\t\t\t\tprintf(\"/\");\n\t\t\tprintf(epm->epm_name);\n\t\t\tconn |= epm->epm_conn;\n\t\t}\n\t}\n\tsc->ep_connectors = conn;\n\n\t/* get default medium from EEPROM */\n\tif (epbusyeeprom(sc))\n\t\treturn;\t\t/* XXX why is eeprom busy? */\n\tbus_space_write_2(iot, ioh, EP_W0_EEPROM_COMMAND,\n\t    READ_EEPROM | EEPROM_ADDR_CFG);\n\tif (epbusyeeprom(sc))\n\t\treturn;\t\t/* XXX why is  eeprom busy? */\n\tport = bus_space_read_2(iot, ioh, EP_W0_EEPROM_DATA);\n\tport = port >> 14;\n\n\tprintf(\" (default %s)\\n\", ep_vortex_media[port].epm_name);\n\t/* tell ifconfig what currently-active media is. */\n\tifmedia_set(ifm, ep_default_to_media[port]);\n\n\t/* XXX autoselect not yet implemented */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_vortex_probemedia",
          "args": [
            "sc"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "ep_vortex_probemedia",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "458-515",
          "snippet": "void\nep_vortex_probemedia(sc)\n\tstruct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifmedia *ifm = &sc->sc_media;\n\tu_int config1, conn;\n\tint reset_options;\n\tint default_media;\t/* 3-bit encoding of default (EEPROM) media */\n\tint autoselect;\t\t/* boolean: should default to autoselect */\n\tconst char *medium_name;\n\tregister int i;\n\n\tGO_WINDOW(3);\n\tconfig1 = (u_int)bus_space_read_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2);\n\treset_options  = (int)bus_space_read_1(iot, ioh, EP_W3_RESET_OPTIONS);\n\tGO_WINDOW(0);\n\n\tdefault_media = (config1 & CONFIG_MEDIAMASK) >> CONFIG_MEDIAMASK_SHIFT;\n        autoselect = (config1 & CONFIG_AUTOSELECT) >> CONFIG_AUTOSELECT_SHIFT;\n\n\t/* set available media options */\n\tconn = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tstruct ep_media * epm = ep_vortex_media + i;\n\n\t\tif ((reset_options & epm->epm_eeprom_data) != 0) {\n\t\t\tif (conn) printf(\"/\");\n\t\t\tprintf(epm->epm_name);\n\t\t\tconn |= epm->epm_conn;\n\t\t\tifmedia_add(ifm, epm->epm_ifmedia, epm->epm_ifdata, 0);\n\t\t}\n\t}\n\n\tsc->ep_connectors = conn;\n\n\t/* Show  eeprom's idea of default media.  */\n\tmedium_name = (default_media > 8)\n\t\t? \"(unknown/impossible media)\"\n\t\t: ep_vortex_media[default_media].epm_name;\n\tprintf(\" default %s%s\",\n\t       medium_name,  (autoselect)? \"/autoselect\" : \"\" );\n/*\tsc->sc_media = ep_vortex_media[default_media].epm_ifdata;*/\n\n#ifdef notyet\t\n\t/*\n\t * Set default: either the active interface the card\n\t * reads  from the EEPROM, or if autoselect is true,\n\t * whatever we find is actually connected. \n\t *\n\t * XXX autoselect not yet implemented.\n\t */\n#endif\t/* notyet */\n\n\t/* tell ifconfig what currently-active media is. */\n\tifmedia_set(ifm, ep_default_to_media[default_media]);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct ep_media ep_vortex_media[8] = {\n  { EP_PCI_UTP,        EPC_UTP, \"utp\",\t    IFM_ETHER|IFM_10_T,\n       EPMEDIA_10BASE_T },\n  { EP_PCI_AUI,        EPC_AUI, \"aui\",\t    IFM_ETHER|IFM_10_5,\n       EPMEDIA_AUI },\n  { 0,                 0,  \t\"reserved\", IFM_NONE,  EPMEDIA_RESV1 },\n  { EP_PCI_BNC,        EPC_BNC, \"bnc\",\t    IFM_ETHER|IFM_10_2,\n       EPMEDIA_10BASE_2 },\n  { EP_PCI_100BASE_TX, EPC_100TX, \"100-TX\", IFM_ETHER|IFM_100_TX,\n       EPMEDIA_100BASE_TX },\n  { EP_PCI_100BASE_FX, EPC_100FX, \"100-FX\", IFM_ETHER|IFM_100_FX,\n       EPMEDIA_100BASE_FX },\n  { EP_PCI_100BASE_MII,EPC_MII,   \"mii\",    IFM_ETHER|IFM_100_TX,\n       EPMEDIA_MII },\n  { EP_PCI_100BASE_T4, EPC_100T4, \"100-T4\", IFM_ETHER|IFM_100_T4,\n       EPMEDIA_100BASE_T4 }\n};",
            "const u_int ep_default_to_media[8] = {\n\tIFM_ETHER | IFM_10_T,\n\tIFM_ETHER | IFM_10_5,\n\t0, \t\t\t/* reserved by 3Com */\n\tIFM_ETHER | IFM_10_2,\n\tIFM_ETHER | IFM_100_TX,\n\tIFM_ETHER | IFM_100_FX,\n\tIFM_ETHER | IFM_100_TX,\t/* XXX really MII: need to talk to PHY */\n\tIFM_ETHER | IFM_100_T4,\n};",
            "void\tep_vortex_probemedia",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct ep_media ep_vortex_media[8] = {\n  { EP_PCI_UTP,        EPC_UTP, \"utp\",\t    IFM_ETHER|IFM_10_T,\n       EPMEDIA_10BASE_T },\n  { EP_PCI_AUI,        EPC_AUI, \"aui\",\t    IFM_ETHER|IFM_10_5,\n       EPMEDIA_AUI },\n  { 0,                 0,  \t\"reserved\", IFM_NONE,  EPMEDIA_RESV1 },\n  { EP_PCI_BNC,        EPC_BNC, \"bnc\",\t    IFM_ETHER|IFM_10_2,\n       EPMEDIA_10BASE_2 },\n  { EP_PCI_100BASE_TX, EPC_100TX, \"100-TX\", IFM_ETHER|IFM_100_TX,\n       EPMEDIA_100BASE_TX },\n  { EP_PCI_100BASE_FX, EPC_100FX, \"100-FX\", IFM_ETHER|IFM_100_FX,\n       EPMEDIA_100BASE_FX },\n  { EP_PCI_100BASE_MII,EPC_MII,   \"mii\",    IFM_ETHER|IFM_100_TX,\n       EPMEDIA_MII },\n  { EP_PCI_100BASE_T4, EPC_100T4, \"100-T4\", IFM_ETHER|IFM_100_T4,\n       EPMEDIA_100BASE_T4 }\n};\nconst u_int ep_default_to_media[8] = {\n\tIFM_ETHER | IFM_10_T,\n\tIFM_ETHER | IFM_10_5,\n\t0, \t\t\t/* reserved by 3Com */\n\tIFM_ETHER | IFM_10_2,\n\tIFM_ETHER | IFM_100_TX,\n\tIFM_ETHER | IFM_100_FX,\n\tIFM_ETHER | IFM_100_TX,\t/* XXX really MII: need to talk to PHY */\n\tIFM_ETHER | IFM_100_T4,\n};\nvoid\tep_vortex_probemedia;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nep_vortex_probemedia(sc)\n\tstruct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifmedia *ifm = &sc->sc_media;\n\tu_int config1, conn;\n\tint reset_options;\n\tint default_media;\t/* 3-bit encoding of default (EEPROM) media */\n\tint autoselect;\t\t/* boolean: should default to autoselect */\n\tconst char *medium_name;\n\tregister int i;\n\n\tGO_WINDOW(3);\n\tconfig1 = (u_int)bus_space_read_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2);\n\treset_options  = (int)bus_space_read_1(iot, ioh, EP_W3_RESET_OPTIONS);\n\tGO_WINDOW(0);\n\n\tdefault_media = (config1 & CONFIG_MEDIAMASK) >> CONFIG_MEDIAMASK_SHIFT;\n        autoselect = (config1 & CONFIG_AUTOSELECT) >> CONFIG_AUTOSELECT_SHIFT;\n\n\t/* set available media options */\n\tconn = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tstruct ep_media * epm = ep_vortex_media + i;\n\n\t\tif ((reset_options & epm->epm_eeprom_data) != 0) {\n\t\t\tif (conn) printf(\"/\");\n\t\t\tprintf(epm->epm_name);\n\t\t\tconn |= epm->epm_conn;\n\t\t\tifmedia_add(ifm, epm->epm_ifmedia, epm->epm_ifdata, 0);\n\t\t}\n\t}\n\n\tsc->ep_connectors = conn;\n\n\t/* Show  eeprom's idea of default media.  */\n\tmedium_name = (default_media > 8)\n\t\t? \"(unknown/impossible media)\"\n\t\t: ep_vortex_media[default_media].epm_name;\n\tprintf(\" default %s%s\",\n\t       medium_name,  (autoselect)? \"/autoselect\" : \"\" );\n/*\tsc->sc_media = ep_vortex_media[default_media].epm_ifdata;*/\n\n#ifdef notyet\t\n\t/*\n\t * Set default: either the active interface the card\n\t * reads  from the EEPROM, or if autoselect is true,\n\t * whatever we find is actually connected. \n\t *\n\t * XXX autoselect not yet implemented.\n\t */\n#endif\t/* notyet */\n\n\t/* tell ifconfig what currently-active media is. */\n\tifmedia_set(ifm, ep_default_to_media[default_media]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"warning: unknown chipset, possibly 3c515?\\n\""
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->sc_media",
            "0",
            "ep_media_change",
            "ep_media_status"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "0"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_internalconfig",
          "args": [
            "sc"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "ep_internalconfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "360-393",
          "snippet": "void\nep_internalconfig(sc)\n\tstruct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tu_int config0;\n\tu_int config1;\n\n\tint  ram_size, ram_width, ram_speed, rom_size, ram_split;\n\t/*\n\t * NVRAM buffer Rx:Tx config names for busmastering cards\n\t * (Demon, Vortex, and later).\n\t */\n\tconst char *onboard_ram_config[] = {\n\t\t\"5:3\", \"3:1\", \"1:1\", \"(undefined)\" };\n\n\tGO_WINDOW(3);\n\tconfig0 = (u_int)bus_space_read_2(iot, ioh, EP_W3_INTERNAL_CONFIG);\n\tconfig1 = (u_int)bus_space_read_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2);\n\tGO_WINDOW(0);\n\n\tram_size  = (config0 & CONFIG_RAMSIZE) >> CONFIG_RAMSIZE_SHIFT;\n\tram_width = (config0 & CONFIG_RAMWIDTH) >> CONFIG_RAMWIDTH_SHIFT;\n\tram_speed = (config0 & CONFIG_RAMSPEED) >> CONFIG_RAMSPEED_SHIFT;\n\trom_size  = (config0 & CONFIG_ROMSIZE) >> CONFIG_ROMSIZE_SHIFT;\n\n\tram_split  = (config1 & CONFIG_RAMSPLIT) >> CONFIG_RAMSPLIT_SHIFT;\n\n\tprintf(\"%s: %dKB %s-wide FIFO, %s Rx:Tx split, \",\n\t    sc->sc_dev.dv_xname, 8 << ram_size, (ram_width) ? \"word\" : \"byte\",\n\t    onboard_ram_config[ram_split]);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nep_internalconfig(sc)\n\tstruct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tu_int config0;\n\tu_int config1;\n\n\tint  ram_size, ram_width, ram_speed, rom_size, ram_split;\n\t/*\n\t * NVRAM buffer Rx:Tx config names for busmastering cards\n\t * (Demon, Vortex, and later).\n\t */\n\tconst char *onboard_ram_config[] = {\n\t\t\"5:3\", \"3:1\", \"1:1\", \"(undefined)\" };\n\n\tGO_WINDOW(3);\n\tconfig0 = (u_int)bus_space_read_2(iot, ioh, EP_W3_INTERNAL_CONFIG);\n\tconfig1 = (u_int)bus_space_read_2(iot, ioh, EP_W3_INTERNAL_CONFIG + 2);\n\tGO_WINDOW(0);\n\n\tram_size  = (config0 & CONFIG_RAMSIZE) >> CONFIG_RAMSIZE_SHIFT;\n\tram_width = (config0 & CONFIG_RAMWIDTH) >> CONFIG_RAMWIDTH_SHIFT;\n\tram_speed = (config0 & CONFIG_RAMSPEED) >> CONFIG_RAMSPEED_SHIFT;\n\trom_size  = (config0 & CONFIG_ROMSIZE) >> CONFIG_ROMSIZE_SHIFT;\n\n\tram_split  = (config1 & CONFIG_RAMSPLIT) >> CONFIG_RAMSPLIT_SHIFT;\n\n\tprintf(\"%s: %dKB %s-wide FIFO, %s Rx:Tx split, \",\n\t    sc->sc_dev.dv_xname, 8 << ram_size, (ram_width) ? \"word\" : \"byte\",\n\t    onboard_ram_config[ram_split]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "SET_TX_AVAIL_THRESH | (1600 >> sc->txashift)"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "1"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_W5_TX_AVAIL_THRESH"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "5"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_COMMAND",
            "SET_TX_AVAIL_THRESH | EP_LARGEWIN_PROBE"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->sc_arpcom.ac_enaddr"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_W0_EEPROM_DATA"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epbusyeeprom",
          "args": [
            "sc"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "epbusyeeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
          "lines": "1504-1531",
          "snippet": "int\nepbusyeeprom(sc)\n\tstruct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i = 100, j;\n\n\twhile (i--) {\n\t\tj = bus_space_read_2(iot, ioh, EP_W0_EEPROM_COMMAND);\n\t\tif (j & EEPROM_BUSY)\n\t\t\tdelay(100);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!i) {\n\t\tprintf(\"\\n%s: eeprom failed to come ready\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\tif (sc->bustype != EP_BUS_PCMCIA && sc->bustype != EP_BUS_PCI &&\n\t    (j & EEPROM_TST_MODE)) {\n\t\tprintf(\"\\n%s: erase pencil mark, or disable PnP mode!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/elink3reg.h>",
            "#include <dev/ic/elink3var.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tepbusyeeprom",
            "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tepbusyeeprom;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nint\nepbusyeeprom(sc)\n\tstruct ep_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i = 100, j;\n\n\twhile (i--) {\n\t\tj = bus_space_read_2(iot, ioh, EP_W0_EEPROM_COMMAND);\n\t\tif (j & EEPROM_BUSY)\n\t\t\tdelay(100);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!i) {\n\t\tprintf(\"\\n%s: eeprom failed to come ready\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\tif (sc->bustype != EP_BUS_PCMCIA && sc->bustype != EP_BUS_PCI &&\n\t    (j & EEPROM_TST_MODE)) {\n\t\tprintf(\"\\n%s: erase pencil mark, or disable PnP mode!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "EP_W0_EEPROM_COMMAND",
            "READ_EEPROM | i"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GO_WINDOW",
          "args": [
            "0"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_ADDR_LEN  6\n\nvoid\tep_vortex_probemedia;\nvoid\tep_isa_probemedia;\nint\tepioctl;\nvoid\tepstart;\nvoid\tepwatchdog;\nint\tep_media_change;\nvoid\tep_media_status;\nint\tepbusyeeprom;\nstatic inline void ep_complete_cmd;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nvoid\nepconfig(sc, chipset, enaddr)\n\tstruct ep_softc *sc;\n\tu_short chipset;\n\tu_int8_t *enaddr;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t i;\n\n\tsc->ep_chipset = chipset;\n\n\t/*\n\t * We could have been groveling around in other register\n\t * windows in the front-end; make sure we're in window 0\n\t * to read the EEPROM.\n\t */\n\tGO_WINDOW(0);\n\n\tif (enaddr == NULL) {\n\t\t/*\n\t\t * Read the station address from the eeprom\n\t\t */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tu_int16_t x;\n\t\t\tif (epbusyeeprom(sc))\n\t\t\t\treturn;\t\t/* XXX why is eeprom busy? */\n\t\t\tbus_space_write_2(iot, ioh, EP_W0_EEPROM_COMMAND,\n\t\t\t    READ_EEPROM | i);\n\t\t\tif (epbusyeeprom(sc))\n\t\t\t\treturn;\t\t/* XXX why is eeprom busy? */\n\t\t\tx = bus_space_read_2(iot, ioh, EP_W0_EEPROM_DATA);\n\t\t\tsc->sc_arpcom.ac_enaddr[(i << 1)] = x >> 8;\n\t\t\tsc->sc_arpcom.ac_enaddr[(i << 1) + 1] = x;\n\t\t}\n\t} else {\n\t\tbcopy(enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\t}\n\n\tprintf(\" address %s, \", ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\t/*\n\t * Vortex-based (3c59x pci,eisa) cards allow FDDI-sized (4500) byte\n\t * packets.  Commands only take an 11-bit parameter, and  11 bits\n\t * isn't enough to hold a full-size packet length.\n\t * Commands to these cards implicitly upshift a packet size\n\t * or threshold by 2 bits. \n\t * To detect  cards with large-packet support, we probe by setting\n\t * the transmit threshold register, then change windows and\n\t * read back the threshold register directly, and see if the\n\t * threshold value was shifted or not.\n\t */\n\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t\t\t  SET_TX_AVAIL_THRESH | EP_LARGEWIN_PROBE ); \n\tGO_WINDOW(5);\n\ti = bus_space_read_2(iot, ioh, EP_W5_TX_AVAIL_THRESH);\n\tGO_WINDOW(1);\n\tswitch (i)  {\n\tcase EP_LARGEWIN_PROBE:\n\tcase (EP_LARGEWIN_PROBE & EP_LARGEWIN_MASK):\n\t\tsc->txashift = 0;\n\t\tbreak;\n\n\tcase (EP_LARGEWIN_PROBE << 2):\n\t\tsc->txashift = 2;\n\t\t/* XXX does the 3c515 support Vortex-style RESET_OPTIONS? */\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"wrote %d to TX_AVAIL_THRESH, read back %d. \"\n\t\t    \"Interface disabled\\n\", EP_THRESH_DISABLE, (int) i);\n\t\treturn;\n\t}\n\n\t/*\n\t * Ensure Tx-available interrupts are enabled for \n\t * start the interface.\n\t * XXX should be in epinit()?\n\t */\n\tbus_space_write_2(iot, ioh, EP_COMMAND,\n\t    SET_TX_AVAIL_THRESH | (1600 >> sc->txashift));\n\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = epstart;\n\tifp->if_ioctl = epioctl;\n\tifp->if_watchdog = epwatchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n\t/*\n\t * Finish configuration: \n\t * determine chipset if the front-end couldn't do so,\n\t * show board details, set media.\n\t */\n\n#ifdef __NetBSD__\n\t/* print RAM size */\n\tep_internalconfig(sc);\n#endif\n\tGO_WINDOW(0);\n\n\tifmedia_init(&sc->sc_media, 0, ep_media_change, ep_media_status);\n\n\t/*\n\t * If we've got an indirect (ISA, PCMCIA?) board, the chipset\n\t * is unknown.  If the board has large-packet support, it's a\n\t * Vortex/Boomerang, otherwise it's a 3c509.\n\t * XXX use eeprom capability word instead?\n\t */\n\tif (sc->ep_chipset == EP_CHIPSET_UNKNOWN && sc->txashift)  {\n\t\tprintf(\"warning: unknown chipset, possibly 3c515?\\n\");\n#ifdef notyet\n\t\tsc->sc_chipset = EP_CHIPSET_VORTEX;\n#endif\t/* notyet */\n\t}\n\n\t/*\n\t * Ascertain which media types are present and inform ifmedia.\n\t */\n\tswitch (sc->ep_chipset) {\n\t/* on a direct bus, the attach routine can tell, but check anyway. */\n\tcase EP_CHIPSET_VORTEX:\n\tcase EP_CHIPSET_BOOMERANG2:\n\t\tep_vortex_probemedia(sc);\n\t\tbreak;\n\n\t/* on ISA we can't yet tell 3c509 from 3c515. Assume the former. */\n\tcase EP_CHIPSET_3C509:\n\tdefault:\n\t\tep_isa_probemedia(sc);\n\t\tbreak;\n\t}\n\n\tGO_WINDOW(1);\t\t/* Window 1 is operating window */\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t    sizeof (struct ether_header));\n#endif\n\n\tsc->tx_start_thresh = 20;\t/* probably a good starting point. */\n\n\tep_complete_cmd(sc, EP_COMMAND, RX_RESET);\n\tep_complete_cmd(sc, EP_COMMAND, TX_RESET);\n}"
  },
  {
    "function_name": "ep_complete_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/elink3.c",
    "lines": "178-196",
    "snippet": "static inline void\nep_complete_cmd(sc, cmd, arg)\n\tstruct ep_softc *sc;\n\tu_int cmd, arg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tbus_space_write_2(iot, ioh, cmd, arg);\n\n#ifdef notyet\n\t/* if this adapter family has S_COMMAND_IN_PROGRESS, use it */\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\telse\n#else\n\tDELAY(100000);\t/* need at least 1 ms, but be generous. */\n#endif\n}",
    "includes": [
      "#include <dev/ic/elink3reg.h>",
      "#include <dev/ic/elink3var.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ep_complete_cmd",
      "struct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100000"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "EP_STATUS"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "cmd",
            "arg"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/elink3reg.h>\n#include <dev/ic/elink3var.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline void ep_complete_cmd;\nstruct mbuf *\nepget(sc, totlen)\n\tstruct ep_softc *sc;\n\nstatic inline void\nep_complete_cmd(sc, cmd, arg)\n\tstruct ep_softc *sc;\n\tu_int cmd, arg;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tbus_space_write_2(iot, ioh, cmd, arg);\n\n#ifdef notyet\n\t/* if this adapter family has S_COMMAND_IN_PROGRESS, use it */\n\twhile (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)\n\t\t;\n\telse\n#else\n\tDELAY(100000);\t/* need at least 1 ms, but be generous. */\n#endif\n}"
  }
]