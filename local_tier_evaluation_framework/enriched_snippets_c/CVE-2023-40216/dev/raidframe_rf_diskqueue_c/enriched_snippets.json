[
  {
    "function_name": "rf_FreeDiskQueueData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
    "lines": "596-601",
    "snippet": "void \nrf_FreeDiskQueueData(p)\n\tRF_DiskQueueData_t *p;\n{\n\tRF_FREELIST_FREE_CLEAN(rf_dqd_freelist, p, next, clean_dqd);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_fifo.h\"",
      "#include \"rf_sstf.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_dqd(RF_DiskQueueData_t *);",
      "static void clean_dqd(RF_DiskQueueData_t *);",
      "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);",
      "static RF_FreeList_t *rf_dqd_freelist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_FREE_CLEAN",
          "args": [
            "rf_dqd_freelist",
            "p",
            "next",
            "clean_dqd"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\nstatic RF_FreeList_t *rf_dqd_freelist;\n\nvoid \nrf_FreeDiskQueueData(p)\n\tRF_DiskQueueData_t *p;\n{\n\tRF_FREELIST_FREE_CLEAN(rf_dqd_freelist, p, next, clean_dqd);\n}"
  },
  {
    "function_name": "rf_CreateDiskQueueDataFull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
    "lines": "554-594",
    "snippet": "RF_DiskQueueData_t *\nrf_CreateDiskQueueDataFull(\n    RF_IoType_t typ,\n    RF_SectorNum_t ssect,\n    RF_SectorCount_t nsect,\n    caddr_t buf,\n    RF_StripeNum_t parityStripeID,\n    RF_ReconUnitNum_t which_ru,\n    int (*wakeF) (void *, int),\n    void *arg,\n    RF_DiskQueueData_t * next,\n    RF_AccTraceEntry_t * tracerec,\n    int priority,\n    int (*AuxFunc) (void *,...),\n    caddr_t buf2,\n    void *raidPtr,\n    RF_DiskQueueDataFlags_t flags,\n    void *kb_proc)\n{\n\tRF_DiskQueueData_t *p;\n\n\tRF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);\n\n\tp->sectorOffset = ssect + rf_protectedSectors;\n\tp->numSector = nsect;\n\tp->type = typ;\n\tp->buf = buf;\n\tp->parityStripeID = parityStripeID;\n\tp->which_ru = which_ru;\n\tp->CompleteFunc = wakeF;\n\tp->argument = arg;\n\tp->next = next;\n\tp->tracerec = tracerec;\n\tp->priority = priority;\n\tp->AuxFunc = AuxFunc;\n\tp->buf2 = buf2;\n\tp->raidPtr = raidPtr;\n\tp->flags = flags;\n\tp->b_proc = kb_proc;\n\treturn (p);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_fifo.h\"",
      "#include \"rf_sstf.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_dqd(RF_DiskQueueData_t *);",
      "static void clean_dqd(RF_DiskQueueData_t *);",
      "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);",
      "static RF_FreeList_t *rf_dqd_freelist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_GET_INIT",
          "args": [
            "rf_dqd_freelist",
            "p",
            "next",
            "(RF_DiskQueueData_t *), init_dqd"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\nstatic RF_FreeList_t *rf_dqd_freelist;\n\nRF_DiskQueueData_t *\nrf_CreateDiskQueueDataFull(\n    RF_IoType_t typ,\n    RF_SectorNum_t ssect,\n    RF_SectorCount_t nsect,\n    caddr_t buf,\n    RF_StripeNum_t parityStripeID,\n    RF_ReconUnitNum_t which_ru,\n    int (*wakeF) (void *, int),\n    void *arg,\n    RF_DiskQueueData_t * next,\n    RF_AccTraceEntry_t * tracerec,\n    int priority,\n    int (*AuxFunc) (void *,...),\n    caddr_t buf2,\n    void *raidPtr,\n    RF_DiskQueueDataFlags_t flags,\n    void *kb_proc)\n{\n\tRF_DiskQueueData_t *p;\n\n\tRF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);\n\n\tp->sectorOffset = ssect + rf_protectedSectors;\n\tp->numSector = nsect;\n\tp->type = typ;\n\tp->buf = buf;\n\tp->parityStripeID = parityStripeID;\n\tp->which_ru = which_ru;\n\tp->CompleteFunc = wakeF;\n\tp->argument = arg;\n\tp->next = next;\n\tp->tracerec = tracerec;\n\tp->priority = priority;\n\tp->AuxFunc = AuxFunc;\n\tp->buf2 = buf2;\n\tp->raidPtr = raidPtr;\n\tp->flags = flags;\n\tp->b_proc = kb_proc;\n\treturn (p);\n}"
  },
  {
    "function_name": "rf_CreateDiskQueueData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
    "lines": "515-552",
    "snippet": "RF_DiskQueueData_t *\nrf_CreateDiskQueueData(\n    RF_IoType_t typ,\n    RF_SectorNum_t ssect,\n    RF_SectorCount_t nsect,\n    caddr_t buf,\n    RF_StripeNum_t parityStripeID,\n    RF_ReconUnitNum_t which_ru,\n    int (*wakeF) (void *, int),\n    void *arg,\n    RF_DiskQueueData_t * next,\n    RF_AccTraceEntry_t * tracerec,\n    void *raidPtr,\n    RF_DiskQueueDataFlags_t flags,\n    void *kb_proc)\n{\n\tRF_DiskQueueData_t *p;\n\n\tRF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);\n\n\tp->sectorOffset = ssect + rf_protectedSectors;\n\tp->numSector = nsect;\n\tp->type = typ;\n\tp->buf = buf;\n\tp->parityStripeID = parityStripeID;\n\tp->which_ru = which_ru;\n\tp->CompleteFunc = wakeF;\n\tp->argument = arg;\n\tp->next = next;\n\tp->tracerec = tracerec;\n\tp->priority = RF_IO_NORMAL_PRIORITY;\n\tp->AuxFunc = NULL;\n\tp->buf2 = NULL;\n\tp->raidPtr = raidPtr;\n\tp->flags = flags;\n\tp->b_proc = kb_proc;\n\treturn (p);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_fifo.h\"",
      "#include \"rf_sstf.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_dqd(RF_DiskQueueData_t *);",
      "static void clean_dqd(RF_DiskQueueData_t *);",
      "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);",
      "static RF_FreeList_t *rf_dqd_freelist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_GET_INIT",
          "args": [
            "rf_dqd_freelist",
            "p",
            "next",
            "(RF_DiskQueueData_t *), init_dqd"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\nstatic RF_FreeList_t *rf_dqd_freelist;\n\nRF_DiskQueueData_t *\nrf_CreateDiskQueueData(\n    RF_IoType_t typ,\n    RF_SectorNum_t ssect,\n    RF_SectorCount_t nsect,\n    caddr_t buf,\n    RF_StripeNum_t parityStripeID,\n    RF_ReconUnitNum_t which_ru,\n    int (*wakeF) (void *, int),\n    void *arg,\n    RF_DiskQueueData_t * next,\n    RF_AccTraceEntry_t * tracerec,\n    void *raidPtr,\n    RF_DiskQueueDataFlags_t flags,\n    void *kb_proc)\n{\n\tRF_DiskQueueData_t *p;\n\n\tRF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);\n\n\tp->sectorOffset = ssect + rf_protectedSectors;\n\tp->numSector = nsect;\n\tp->type = typ;\n\tp->buf = buf;\n\tp->parityStripeID = parityStripeID;\n\tp->which_ru = which_ru;\n\tp->CompleteFunc = wakeF;\n\tp->argument = arg;\n\tp->next = next;\n\tp->tracerec = tracerec;\n\tp->priority = RF_IO_NORMAL_PRIORITY;\n\tp->AuxFunc = NULL;\n\tp->buf2 = NULL;\n\tp->raidPtr = raidPtr;\n\tp->flags = flags;\n\tp->b_proc = kb_proc;\n\treturn (p);\n}"
  },
  {
    "function_name": "rf_DiskIOPromote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
    "lines": "499-513",
    "snippet": "int \nrf_DiskIOPromote(queue, parityStripeID, which_ru)\n\tRF_DiskQueue_t *queue;\n\tRF_StripeNum_t parityStripeID;\n\tRF_ReconUnitNum_t which_ru;\n{\n\tint     retval;\n\n\tif (!queue->qPtr->Promote)\n\t\treturn (-1);\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOPromote\");\n\tretval = (queue->qPtr->Promote) (queue->qHdr, parityStripeID, which_ru);\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOPromote\");\n\treturn (retval);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_fifo.h\"",
      "#include \"rf_sstf.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_QUEUE_MUTEX",
          "args": [
            "queue",
            "\"DiskIOPromote\""
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "queue->qHdr",
            "parityStripeID",
            "which_ru"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_QUEUE_MUTEX",
          "args": [
            "queue",
            "\"DiskIOPromote\""
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nint \nrf_DiskIOPromote(queue, parityStripeID, which_ru)\n\tRF_DiskQueue_t *queue;\n\tRF_StripeNum_t parityStripeID;\n\tRF_ReconUnitNum_t which_ru;\n{\n\tint     retval;\n\n\tif (!queue->qPtr->Promote)\n\t\treturn (-1);\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOPromote\");\n\tretval = (queue->qPtr->Promote) (queue->qHdr, parityStripeID, which_ru);\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOPromote\");\n\treturn (retval);\n}"
  },
  {
    "function_name": "rf_DiskIOComplete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
    "lines": "408-493",
    "snippet": "void \nrf_DiskIOComplete(queue, req, status)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     status;\n{\n\tint     done = 0;\n\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOComplete\");\n\n\t/* unlock the queue: (1) after an unlocking req completes (2) after a\n\t * locking req fails */\n\tif (RF_UNLOCKING_REQ(req) || (RF_LOCKING_REQ(req) && status)) {\n\t\tDprintf2(\"DiskIOComplete: unlocking queue at r %d c %d\\n\", queue->row, queue->col);\n\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue) && (queue->unlockingOp == NULL));\n\t\tRF_UNLOCK_QUEUE(queue);\n\t}\n\tqueue->numOutstanding--;\n\tRF_ASSERT(queue->numOutstanding >= 0);\n\n\t/* dispatch requests to the disk until we find one that we can't. */\n\t/* no reason to continue once we've filled up the queue */\n\t/* no reason to even start if the queue is locked */\n\n\twhile (!done && !RF_QUEUE_FULL(queue) && !RF_QUEUE_LOCKED(queue)) {\n\t\tif (queue->nextLockingOp) {\n\t\t\treq = queue->nextLockingOp;\n\t\t\tqueue->nextLockingOp = NULL;\n\t\t\tDprintf3(\"DiskIOComplete: a pri %d locking req was pending at r %d c %d\\n\", req->priority, queue->row, queue->col);\n\t\t} else {\n\t\t\treq = (queue->qPtr->Dequeue) (queue->qHdr);\n\t\t\tif (req != NULL) {\n\t\t\t\tDprintf3(\"DiskIOComplete: extracting pri %d req from queue at r %d c %d\\n\", req->priority, queue->row, queue->col);\n\t\t\t} else {\n\t\t\t\tDprintf1(\"DiskIOComplete: no more requests to extract.\\n\", \"\");\n\t\t\t}\n\t\t}\n\t\tif (req) {\n\t\t\tqueue->queueLength--;\t/* decrement count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tRF_ASSERT(queue->queueLength >= 0);\n\t\t}\n\t\tif (!req)\n\t\t\tdone = 1;\n\t\telse\n\t\t\tif (RF_LOCKING_REQ(req)) {\n\t\t\t\tif (RF_QUEUE_EMPTY(queue)) {\t/* dispatch it */\n\t\t\t\t\tDprintf3(\"DiskIOComplete: dispatching pri %d locking req to r %d c %d (queue empty)\\n\", req->priority, queue->row, queue->col);\n\t\t\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t\t\tdone = 1;\n\t\t\t\t} else {\t/* put it aside to wait for\n\t\t\t\t\t\t * the queue to drain */\n\t\t\t\t\tDprintf3(\"DiskIOComplete: postponing pri %d locking req to r %d c %d\\n\", req->priority, queue->row, queue->col);\n\t\t\t\t\tRF_ASSERT(queue->nextLockingOp == NULL);\n\t\t\t\t\tqueue->nextLockingOp = req;\n\t\t\t\t\tdone = 1;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tif (RF_UNLOCKING_REQ(req)) {\t/* should not happen:\n\t\t\t\t\t\t\t\t * unlocking ops should\n\t\t\t\t\t\t\t\t * not get queued */\n\t\t\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\t/* support it anyway for\n\t\t\t\t\t\t\t\t\t\t * the future */\n\t\t\t\t\tDprintf3(\"DiskIOComplete: dispatching pri %d unl req to r %d c %d (SHOULD NOT SEE THIS)\\n\", req->priority, queue->row, queue->col);\n\t\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t\t\tdone = 1;\n\t\t\t\t} else\n\t\t\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\t\t\tDprintf3(\"DiskIOComplete: dispatching pri %d regular req to r %d c %d (ok to dispatch)\\n\", req->priority, queue->row, queue->col);\n\t\t\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t\t\t} else {\t/* we can't dispatch it,\n\t\t\t\t\t\t\t * so just re-enqueue\n\t\t\t\t\t\t\t * it.  */\n\t\t\t\t\t\t/* potential trouble here if\n\t\t\t\t\t\t * disk queues batch reqs */\n\t\t\t\t\t\tDprintf3(\"DiskIOComplete: re-enqueueing pri %d regular req to r %d c %d\\n\", req->priority, queue->row, queue->col);\n\t\t\t\t\t\tqueue->queueLength++;\n\t\t\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, req->priority);\n\t\t\t\t\t\tdone = 1;\n\t\t\t\t\t}\n\t}\n\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOComplete\");\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_fifo.h\"",
      "#include \"rf_sstf.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_dqd(RF_DiskQueueData_t *);",
      "static void clean_dqd(RF_DiskQueueData_t *);",
      "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_QUEUE_MUTEX",
          "args": [
            "queue",
            "\"DiskIOComplete\""
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "queue->qHdr",
            "req",
            "req->priority"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"DiskIOComplete: re-enqueueing pri %d regular req to r %d c %d\\n\"",
            "req->priority",
            "queue->row",
            "queue->col"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_DispatchKernelIO",
          "args": [
            "queue",
            "req"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DispatchKernelIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_netbsdkintf.c",
          "lines": "1476-1589",
          "snippet": "int \nrf_DispatchKernelIO(queue, req)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n{\n\tint     op = (req->type == RF_IO_TYPE_READ) ? B_READ : B_WRITE;\n\tstruct buf *bp;\n\tstruct raidbuf *raidbp = NULL;\n\tstruct raid_softc *rs;\n\tint     unit;\n\tint s;\n\n\ts=0;\n\t/* s = splbio();*/ /* want to test this */\n\t/* XXX along with the vnode, we also need the softc associated with\n\t * this device.. */\n\n\treq->queue = queue;\n\n\tunit = queue->raidPtr->raidid;\n\n\tdb1_printf((\"DispatchKernelIO unit: %d\\n\", unit));\n\n\tif (unit >= numraid) {\n\t\tprintf(\"Invalid unit number: %d %d\\n\", unit, numraid);\n\t\tpanic(\"Invalid Unit number in rf_DispatchKernelIO\\n\");\n\t}\n\trs = &raid_softc[unit];\n\n\t/* XXX is this the right place? */\n\tdisk_busy(&rs->sc_dkdev);\n\n\tbp = req->bp;\n#if 1\n\t/* XXX when there is a physical disk failure, someone is passing us a\n\t * buffer that contains old stuff!!  Attempt to deal with this problem\n\t * without taking a performance hit... (not sure where the real bug\n\t * is.  It's buried in RAIDframe somewhere) :-(  GO ) */\n\n\tif (bp->b_flags & B_ERROR) {\n\t\tbp->b_flags &= ~B_ERROR;\n\t}\n\tif (bp->b_error != 0) {\n\t\tbp->b_error = 0;\n\t}\n#endif\n\traidbp = RAIDGETBUF(rs);\n\n\traidbp->rf_flags = 0;\t/* XXX not really used anywhere... */\n\n\t/*\n\t * context for raidiodone\n\t */\n\traidbp->rf_obp = bp;\n\traidbp->req = req;\n\n\tLIST_INIT(&raidbp->rf_buf.b_dep);\n\n\tswitch (req->type) {\n\tcase RF_IO_TYPE_NOP:\t/* used primarily to unlock a locked queue */\n\t\t/* XXX need to do something extra here.. */\n\t\t/* I'm leaving this in, as I've never actually seen it used,\n\t\t * and I'd like folks to report it... GO */\n\t\tprintf((\"WAKEUP CALLED\\n\"));\n\t\tqueue->numOutstanding++;\n\n\t\t/* XXX need to glue the original buffer into this??  */\n\n\t\tKernelWakeupFunc(&raidbp->rf_buf);\n\t\tbreak;\n\n\tcase RF_IO_TYPE_READ:\n\tcase RF_IO_TYPE_WRITE:\n\n\t\tif (req->tracerec) {\n\t\t\tRF_ETIMER_START(req->tracerec->timer);\n\t\t}\n\t\tInitBP(&raidbp->rf_buf, queue->rf_cinfo->ci_vp,\n\t\t    op | bp->b_flags, queue->rf_cinfo->ci_dev,\n\t\t    req->sectorOffset, req->numSector,\n\t\t    req->buf, KernelWakeupFunc, (void *) req,\n\t\t    queue->raidPtr->logBytesPerSector, req->b_proc);\n\n\t\tif (rf_debugKernelAccess) {\n\t\t\tdb1_printf((\"dispatch: bp->b_blkno = %ld\\n\",\n\t\t\t\t(long) bp->b_blkno));\n\t\t}\n\t\tqueue->numOutstanding++;\n\t\tqueue->last_deq_sector = req->sectorOffset;\n\t\t/* acc wouldn't have been let in if there were any pending\n\t\t * reqs at any other priority */\n\t\tqueue->curPriority = req->priority;\n\n\t\tdb1_printf((\"Going for %c to unit %d row %d col %d\\n\",\n\t\t\treq->type, unit, queue->row, queue->col));\n\t\tdb1_printf((\"sector %d count %d (%d bytes) %d\\n\",\n\t\t\t(int) req->sectorOffset, (int) req->numSector,\n\t\t\t(int) (req->numSector <<\n\t\t\t    queue->raidPtr->logBytesPerSector),\n\t\t\t(int) queue->raidPtr->logBytesPerSector));\n\t\tif ((raidbp->rf_buf.b_flags & B_READ) == 0) {\n\t\t\traidbp->rf_buf.b_vp->v_numoutput++;\n\t\t}\n\t\tVOP_STRATEGY(&raidbp->rf_buf);\n\n\t\tbreak;\n\n\tdefault:\n\t\tpanic(\"bad req->type in rf_DispatchKernelIO\");\n\t}\n\tdb1_printf((\"Exiting from DispatchKernelIO\\n\"));\n\t/* splx(s); */ /* want to test this */\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/disklabel.h>",
            "#include <machine/types.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/vnode.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/pool.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void KernelWakeupFunc(struct buf * bp);",
            "static void InitBP(struct buf * bp, struct vnode *, unsigned rw_flag, \n\t\t   dev_t dev, RF_SectorNum_t startSect, \n\t\t   RF_SectorCount_t numSect, caddr_t buf,\n\t\t   void (*cbFunc) (struct buf *), void *cbArg, \n\t\t   int logBytesPerSector, struct proc * b_proc);",
            "static int numraid = 0;",
            "struct raid_softc *raid_softc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/disklabel.h>\n#include <machine/types.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/vnode.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/pool.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nstatic void KernelWakeupFunc(struct buf * bp);\nstatic void InitBP(struct buf * bp, struct vnode *, unsigned rw_flag, \n\t\t   dev_t dev, RF_SectorNum_t startSect, \n\t\t   RF_SectorCount_t numSect, caddr_t buf,\n\t\t   void (*cbFunc) (struct buf *), void *cbArg, \n\t\t   int logBytesPerSector, struct proc * b_proc);\nstatic int numraid = 0;\nstruct raid_softc *raid_softc;\n\nint \nrf_DispatchKernelIO(queue, req)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n{\n\tint     op = (req->type == RF_IO_TYPE_READ) ? B_READ : B_WRITE;\n\tstruct buf *bp;\n\tstruct raidbuf *raidbp = NULL;\n\tstruct raid_softc *rs;\n\tint     unit;\n\tint s;\n\n\ts=0;\n\t/* s = splbio();*/ /* want to test this */\n\t/* XXX along with the vnode, we also need the softc associated with\n\t * this device.. */\n\n\treq->queue = queue;\n\n\tunit = queue->raidPtr->raidid;\n\n\tdb1_printf((\"DispatchKernelIO unit: %d\\n\", unit));\n\n\tif (unit >= numraid) {\n\t\tprintf(\"Invalid unit number: %d %d\\n\", unit, numraid);\n\t\tpanic(\"Invalid Unit number in rf_DispatchKernelIO\\n\");\n\t}\n\trs = &raid_softc[unit];\n\n\t/* XXX is this the right place? */\n\tdisk_busy(&rs->sc_dkdev);\n\n\tbp = req->bp;\n#if 1\n\t/* XXX when there is a physical disk failure, someone is passing us a\n\t * buffer that contains old stuff!!  Attempt to deal with this problem\n\t * without taking a performance hit... (not sure where the real bug\n\t * is.  It's buried in RAIDframe somewhere) :-(  GO ) */\n\n\tif (bp->b_flags & B_ERROR) {\n\t\tbp->b_flags &= ~B_ERROR;\n\t}\n\tif (bp->b_error != 0) {\n\t\tbp->b_error = 0;\n\t}\n#endif\n\traidbp = RAIDGETBUF(rs);\n\n\traidbp->rf_flags = 0;\t/* XXX not really used anywhere... */\n\n\t/*\n\t * context for raidiodone\n\t */\n\traidbp->rf_obp = bp;\n\traidbp->req = req;\n\n\tLIST_INIT(&raidbp->rf_buf.b_dep);\n\n\tswitch (req->type) {\n\tcase RF_IO_TYPE_NOP:\t/* used primarily to unlock a locked queue */\n\t\t/* XXX need to do something extra here.. */\n\t\t/* I'm leaving this in, as I've never actually seen it used,\n\t\t * and I'd like folks to report it... GO */\n\t\tprintf((\"WAKEUP CALLED\\n\"));\n\t\tqueue->numOutstanding++;\n\n\t\t/* XXX need to glue the original buffer into this??  */\n\n\t\tKernelWakeupFunc(&raidbp->rf_buf);\n\t\tbreak;\n\n\tcase RF_IO_TYPE_READ:\n\tcase RF_IO_TYPE_WRITE:\n\n\t\tif (req->tracerec) {\n\t\t\tRF_ETIMER_START(req->tracerec->timer);\n\t\t}\n\t\tInitBP(&raidbp->rf_buf, queue->rf_cinfo->ci_vp,\n\t\t    op | bp->b_flags, queue->rf_cinfo->ci_dev,\n\t\t    req->sectorOffset, req->numSector,\n\t\t    req->buf, KernelWakeupFunc, (void *) req,\n\t\t    queue->raidPtr->logBytesPerSector, req->b_proc);\n\n\t\tif (rf_debugKernelAccess) {\n\t\t\tdb1_printf((\"dispatch: bp->b_blkno = %ld\\n\",\n\t\t\t\t(long) bp->b_blkno));\n\t\t}\n\t\tqueue->numOutstanding++;\n\t\tqueue->last_deq_sector = req->sectorOffset;\n\t\t/* acc wouldn't have been let in if there were any pending\n\t\t * reqs at any other priority */\n\t\tqueue->curPriority = req->priority;\n\n\t\tdb1_printf((\"Going for %c to unit %d row %d col %d\\n\",\n\t\t\treq->type, unit, queue->row, queue->col));\n\t\tdb1_printf((\"sector %d count %d (%d bytes) %d\\n\",\n\t\t\t(int) req->sectorOffset, (int) req->numSector,\n\t\t\t(int) (req->numSector <<\n\t\t\t    queue->raidPtr->logBytesPerSector),\n\t\t\t(int) queue->raidPtr->logBytesPerSector));\n\t\tif ((raidbp->rf_buf.b_flags & B_READ) == 0) {\n\t\t\traidbp->rf_buf.b_vp->v_numoutput++;\n\t\t}\n\t\tVOP_STRATEGY(&raidbp->rf_buf);\n\n\t\tbreak;\n\n\tdefault:\n\t\tpanic(\"bad req->type in rf_DispatchKernelIO\");\n\t}\n\tdb1_printf((\"Exiting from DispatchKernelIO\\n\"));\n\t/* splx(s); */ /* want to test this */\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"DiskIOComplete: dispatching pri %d regular req to r %d c %d (ok to dispatch)\\n\"",
            "req->priority",
            "queue->row",
            "queue->col"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_OK_TO_DISPATCH",
          "args": [
            "queue",
            "req"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"DiskIOComplete: dispatching pri %d unl req to r %d c %d (SHOULD NOT SEE THIS)\\n\"",
            "req->priority",
            "queue->row",
            "queue->col"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "RF_QUEUE_LOCKED(queue)"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_QUEUE_LOCKED",
          "args": [
            "queue"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCKING_REQ",
          "args": [
            "req"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "queue->nextLockingOp == NULL"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"DiskIOComplete: postponing pri %d locking req to r %d c %d\\n\"",
            "req->priority",
            "queue->row",
            "queue->col"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_QUEUE",
          "args": [
            "queue"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"DiskIOComplete: dispatching pri %d locking req to r %d c %d (queue empty)\\n\"",
            "req->priority",
            "queue->row",
            "queue->col"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_QUEUE_EMPTY",
          "args": [
            "queue"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCKING_REQ",
          "args": [
            "req"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "queue->queueLength >= 0"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf1",
          "args": [
            "\"DiskIOComplete: no more requests to extract.\\n\"",
            "\"\""
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"DiskIOComplete: extracting pri %d req from queue at r %d c %d\\n\"",
            "req->priority",
            "queue->row",
            "queue->col"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "queue->qHdr"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"DiskIOComplete: a pri %d locking req was pending at r %d c %d\\n\"",
            "req->priority",
            "queue->row",
            "queue->col"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_QUEUE_LOCKED",
          "args": [
            "queue"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_QUEUE_FULL",
          "args": [
            "queue"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "queue->numOutstanding >= 0"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_QUEUE",
          "args": [
            "queue"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "RF_QUEUE_LOCKED(queue) && (queue->unlockingOp == NULL)"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_QUEUE_LOCKED",
          "args": [
            "queue"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf2",
          "args": [
            "\"DiskIOComplete: unlocking queue at r %d c %d\\n\"",
            "queue->row",
            "queue->col"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCKING_REQ",
          "args": [
            "req"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCKING_REQ",
          "args": [
            "req"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_QUEUE_MUTEX",
          "args": [
            "queue",
            "\"DiskIOComplete\""
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\n\nvoid \nrf_DiskIOComplete(queue, req, status)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     status;\n{\n\tint     done = 0;\n\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOComplete\");\n\n\t/* unlock the queue: (1) after an unlocking req completes (2) after a\n\t * locking req fails */\n\tif (RF_UNLOCKING_REQ(req) || (RF_LOCKING_REQ(req) && status)) {\n\t\tDprintf2(\"DiskIOComplete: unlocking queue at r %d c %d\\n\", queue->row, queue->col);\n\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue) && (queue->unlockingOp == NULL));\n\t\tRF_UNLOCK_QUEUE(queue);\n\t}\n\tqueue->numOutstanding--;\n\tRF_ASSERT(queue->numOutstanding >= 0);\n\n\t/* dispatch requests to the disk until we find one that we can't. */\n\t/* no reason to continue once we've filled up the queue */\n\t/* no reason to even start if the queue is locked */\n\n\twhile (!done && !RF_QUEUE_FULL(queue) && !RF_QUEUE_LOCKED(queue)) {\n\t\tif (queue->nextLockingOp) {\n\t\t\treq = queue->nextLockingOp;\n\t\t\tqueue->nextLockingOp = NULL;\n\t\t\tDprintf3(\"DiskIOComplete: a pri %d locking req was pending at r %d c %d\\n\", req->priority, queue->row, queue->col);\n\t\t} else {\n\t\t\treq = (queue->qPtr->Dequeue) (queue->qHdr);\n\t\t\tif (req != NULL) {\n\t\t\t\tDprintf3(\"DiskIOComplete: extracting pri %d req from queue at r %d c %d\\n\", req->priority, queue->row, queue->col);\n\t\t\t} else {\n\t\t\t\tDprintf1(\"DiskIOComplete: no more requests to extract.\\n\", \"\");\n\t\t\t}\n\t\t}\n\t\tif (req) {\n\t\t\tqueue->queueLength--;\t/* decrement count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tRF_ASSERT(queue->queueLength >= 0);\n\t\t}\n\t\tif (!req)\n\t\t\tdone = 1;\n\t\telse\n\t\t\tif (RF_LOCKING_REQ(req)) {\n\t\t\t\tif (RF_QUEUE_EMPTY(queue)) {\t/* dispatch it */\n\t\t\t\t\tDprintf3(\"DiskIOComplete: dispatching pri %d locking req to r %d c %d (queue empty)\\n\", req->priority, queue->row, queue->col);\n\t\t\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t\t\tdone = 1;\n\t\t\t\t} else {\t/* put it aside to wait for\n\t\t\t\t\t\t * the queue to drain */\n\t\t\t\t\tDprintf3(\"DiskIOComplete: postponing pri %d locking req to r %d c %d\\n\", req->priority, queue->row, queue->col);\n\t\t\t\t\tRF_ASSERT(queue->nextLockingOp == NULL);\n\t\t\t\t\tqueue->nextLockingOp = req;\n\t\t\t\t\tdone = 1;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tif (RF_UNLOCKING_REQ(req)) {\t/* should not happen:\n\t\t\t\t\t\t\t\t * unlocking ops should\n\t\t\t\t\t\t\t\t * not get queued */\n\t\t\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\t/* support it anyway for\n\t\t\t\t\t\t\t\t\t\t * the future */\n\t\t\t\t\tDprintf3(\"DiskIOComplete: dispatching pri %d unl req to r %d c %d (SHOULD NOT SEE THIS)\\n\", req->priority, queue->row, queue->col);\n\t\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t\t\tdone = 1;\n\t\t\t\t} else\n\t\t\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\t\t\tDprintf3(\"DiskIOComplete: dispatching pri %d regular req to r %d c %d (ok to dispatch)\\n\", req->priority, queue->row, queue->col);\n\t\t\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t\t\t} else {\t/* we can't dispatch it,\n\t\t\t\t\t\t\t * so just re-enqueue\n\t\t\t\t\t\t\t * it.  */\n\t\t\t\t\t\t/* potential trouble here if\n\t\t\t\t\t\t * disk queues batch reqs */\n\t\t\t\t\t\tDprintf3(\"DiskIOComplete: re-enqueueing pri %d regular req to r %d c %d\\n\", req->priority, queue->row, queue->col);\n\t\t\t\t\t\tqueue->queueLength++;\n\t\t\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, req->priority);\n\t\t\t\t\t\tdone = 1;\n\t\t\t\t\t}\n\t}\n\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOComplete\");\n}"
  },
  {
    "function_name": "rf_DiskIOEnqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
    "lines": "350-404",
    "snippet": "void \nrf_DiskIOEnqueue(queue, req, pri)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     pri;\n{\n\tRF_ETIMER_START(req->qtime);\n\tRF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);\n\treq->priority = pri;\n\n\tif (rf_queueDebug && (req->numSector == 0)) {\n\t\tprintf(\"Warning: Enqueueing zero-sector access\\n\");\n\t}\n\t/*\n         * kernel\n         */\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n\t/* locking request */\n\tif (RF_LOCKING_REQ(req)) {\n\t\tif (RF_QUEUE_EMPTY(queue)) {\n\t\t\tDprintf3(\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\", pri, queue->row, queue->col);\n\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t} else {\n\t\t\tqueue->queueLength++;\t/* increment count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tDprintf3(\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\", pri, queue->row, queue->col);\n\t\t\treq->queue = (void *) queue;\n\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t}\n\t}\n\t/* unlocking request */\n\telse\n\t\tif (RF_UNLOCKING_REQ(req)) {\t/* we'll do the actual unlock\n\t\t\t\t\t\t * when this I/O completes */\n\t\t\tDprintf3(\"Dispatching pri %d unlocking op to r %d c %d\\n\", pri, queue->row, queue->col);\n\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t}\n\t/* normal request */\n\t\telse\n\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\tDprintf3(\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t} else {\n\t\t\t\tqueue->queueLength++;\t/* increment count of\n\t\t\t\t\t\t\t * number of requests\n\t\t\t\t\t\t\t * waiting in this queue */\n\t\t\t\tDprintf3(\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\treq->queue = (void *) queue;\n\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t\t}\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_fifo.h\"",
      "#include \"rf_sstf.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_dqd(RF_DiskQueueData_t *);",
      "static void clean_dqd(RF_DiskQueueData_t *);",
      "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_QUEUE_MUTEX",
          "args": [
            "queue",
            "\"DiskIOEnqueue\""
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "queue->qHdr",
            "req",
            "pri"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\"",
            "pri",
            "queue->row",
            "queue->col"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_DispatchKernelIO",
          "args": [
            "queue",
            "req"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DispatchKernelIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_netbsdkintf.c",
          "lines": "1476-1589",
          "snippet": "int \nrf_DispatchKernelIO(queue, req)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n{\n\tint     op = (req->type == RF_IO_TYPE_READ) ? B_READ : B_WRITE;\n\tstruct buf *bp;\n\tstruct raidbuf *raidbp = NULL;\n\tstruct raid_softc *rs;\n\tint     unit;\n\tint s;\n\n\ts=0;\n\t/* s = splbio();*/ /* want to test this */\n\t/* XXX along with the vnode, we also need the softc associated with\n\t * this device.. */\n\n\treq->queue = queue;\n\n\tunit = queue->raidPtr->raidid;\n\n\tdb1_printf((\"DispatchKernelIO unit: %d\\n\", unit));\n\n\tif (unit >= numraid) {\n\t\tprintf(\"Invalid unit number: %d %d\\n\", unit, numraid);\n\t\tpanic(\"Invalid Unit number in rf_DispatchKernelIO\\n\");\n\t}\n\trs = &raid_softc[unit];\n\n\t/* XXX is this the right place? */\n\tdisk_busy(&rs->sc_dkdev);\n\n\tbp = req->bp;\n#if 1\n\t/* XXX when there is a physical disk failure, someone is passing us a\n\t * buffer that contains old stuff!!  Attempt to deal with this problem\n\t * without taking a performance hit... (not sure where the real bug\n\t * is.  It's buried in RAIDframe somewhere) :-(  GO ) */\n\n\tif (bp->b_flags & B_ERROR) {\n\t\tbp->b_flags &= ~B_ERROR;\n\t}\n\tif (bp->b_error != 0) {\n\t\tbp->b_error = 0;\n\t}\n#endif\n\traidbp = RAIDGETBUF(rs);\n\n\traidbp->rf_flags = 0;\t/* XXX not really used anywhere... */\n\n\t/*\n\t * context for raidiodone\n\t */\n\traidbp->rf_obp = bp;\n\traidbp->req = req;\n\n\tLIST_INIT(&raidbp->rf_buf.b_dep);\n\n\tswitch (req->type) {\n\tcase RF_IO_TYPE_NOP:\t/* used primarily to unlock a locked queue */\n\t\t/* XXX need to do something extra here.. */\n\t\t/* I'm leaving this in, as I've never actually seen it used,\n\t\t * and I'd like folks to report it... GO */\n\t\tprintf((\"WAKEUP CALLED\\n\"));\n\t\tqueue->numOutstanding++;\n\n\t\t/* XXX need to glue the original buffer into this??  */\n\n\t\tKernelWakeupFunc(&raidbp->rf_buf);\n\t\tbreak;\n\n\tcase RF_IO_TYPE_READ:\n\tcase RF_IO_TYPE_WRITE:\n\n\t\tif (req->tracerec) {\n\t\t\tRF_ETIMER_START(req->tracerec->timer);\n\t\t}\n\t\tInitBP(&raidbp->rf_buf, queue->rf_cinfo->ci_vp,\n\t\t    op | bp->b_flags, queue->rf_cinfo->ci_dev,\n\t\t    req->sectorOffset, req->numSector,\n\t\t    req->buf, KernelWakeupFunc, (void *) req,\n\t\t    queue->raidPtr->logBytesPerSector, req->b_proc);\n\n\t\tif (rf_debugKernelAccess) {\n\t\t\tdb1_printf((\"dispatch: bp->b_blkno = %ld\\n\",\n\t\t\t\t(long) bp->b_blkno));\n\t\t}\n\t\tqueue->numOutstanding++;\n\t\tqueue->last_deq_sector = req->sectorOffset;\n\t\t/* acc wouldn't have been let in if there were any pending\n\t\t * reqs at any other priority */\n\t\tqueue->curPriority = req->priority;\n\n\t\tdb1_printf((\"Going for %c to unit %d row %d col %d\\n\",\n\t\t\treq->type, unit, queue->row, queue->col));\n\t\tdb1_printf((\"sector %d count %d (%d bytes) %d\\n\",\n\t\t\t(int) req->sectorOffset, (int) req->numSector,\n\t\t\t(int) (req->numSector <<\n\t\t\t    queue->raidPtr->logBytesPerSector),\n\t\t\t(int) queue->raidPtr->logBytesPerSector));\n\t\tif ((raidbp->rf_buf.b_flags & B_READ) == 0) {\n\t\t\traidbp->rf_buf.b_vp->v_numoutput++;\n\t\t}\n\t\tVOP_STRATEGY(&raidbp->rf_buf);\n\n\t\tbreak;\n\n\tdefault:\n\t\tpanic(\"bad req->type in rf_DispatchKernelIO\");\n\t}\n\tdb1_printf((\"Exiting from DispatchKernelIO\\n\"));\n\t/* splx(s); */ /* want to test this */\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/disklabel.h>",
            "#include <machine/types.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/vnode.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/pool.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void KernelWakeupFunc(struct buf * bp);",
            "static void InitBP(struct buf * bp, struct vnode *, unsigned rw_flag, \n\t\t   dev_t dev, RF_SectorNum_t startSect, \n\t\t   RF_SectorCount_t numSect, caddr_t buf,\n\t\t   void (*cbFunc) (struct buf *), void *cbArg, \n\t\t   int logBytesPerSector, struct proc * b_proc);",
            "static int numraid = 0;",
            "struct raid_softc *raid_softc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/disklabel.h>\n#include <machine/types.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/vnode.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/pool.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nstatic void KernelWakeupFunc(struct buf * bp);\nstatic void InitBP(struct buf * bp, struct vnode *, unsigned rw_flag, \n\t\t   dev_t dev, RF_SectorNum_t startSect, \n\t\t   RF_SectorCount_t numSect, caddr_t buf,\n\t\t   void (*cbFunc) (struct buf *), void *cbArg, \n\t\t   int logBytesPerSector, struct proc * b_proc);\nstatic int numraid = 0;\nstruct raid_softc *raid_softc;\n\nint \nrf_DispatchKernelIO(queue, req)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n{\n\tint     op = (req->type == RF_IO_TYPE_READ) ? B_READ : B_WRITE;\n\tstruct buf *bp;\n\tstruct raidbuf *raidbp = NULL;\n\tstruct raid_softc *rs;\n\tint     unit;\n\tint s;\n\n\ts=0;\n\t/* s = splbio();*/ /* want to test this */\n\t/* XXX along with the vnode, we also need the softc associated with\n\t * this device.. */\n\n\treq->queue = queue;\n\n\tunit = queue->raidPtr->raidid;\n\n\tdb1_printf((\"DispatchKernelIO unit: %d\\n\", unit));\n\n\tif (unit >= numraid) {\n\t\tprintf(\"Invalid unit number: %d %d\\n\", unit, numraid);\n\t\tpanic(\"Invalid Unit number in rf_DispatchKernelIO\\n\");\n\t}\n\trs = &raid_softc[unit];\n\n\t/* XXX is this the right place? */\n\tdisk_busy(&rs->sc_dkdev);\n\n\tbp = req->bp;\n#if 1\n\t/* XXX when there is a physical disk failure, someone is passing us a\n\t * buffer that contains old stuff!!  Attempt to deal with this problem\n\t * without taking a performance hit... (not sure where the real bug\n\t * is.  It's buried in RAIDframe somewhere) :-(  GO ) */\n\n\tif (bp->b_flags & B_ERROR) {\n\t\tbp->b_flags &= ~B_ERROR;\n\t}\n\tif (bp->b_error != 0) {\n\t\tbp->b_error = 0;\n\t}\n#endif\n\traidbp = RAIDGETBUF(rs);\n\n\traidbp->rf_flags = 0;\t/* XXX not really used anywhere... */\n\n\t/*\n\t * context for raidiodone\n\t */\n\traidbp->rf_obp = bp;\n\traidbp->req = req;\n\n\tLIST_INIT(&raidbp->rf_buf.b_dep);\n\n\tswitch (req->type) {\n\tcase RF_IO_TYPE_NOP:\t/* used primarily to unlock a locked queue */\n\t\t/* XXX need to do something extra here.. */\n\t\t/* I'm leaving this in, as I've never actually seen it used,\n\t\t * and I'd like folks to report it... GO */\n\t\tprintf((\"WAKEUP CALLED\\n\"));\n\t\tqueue->numOutstanding++;\n\n\t\t/* XXX need to glue the original buffer into this??  */\n\n\t\tKernelWakeupFunc(&raidbp->rf_buf);\n\t\tbreak;\n\n\tcase RF_IO_TYPE_READ:\n\tcase RF_IO_TYPE_WRITE:\n\n\t\tif (req->tracerec) {\n\t\t\tRF_ETIMER_START(req->tracerec->timer);\n\t\t}\n\t\tInitBP(&raidbp->rf_buf, queue->rf_cinfo->ci_vp,\n\t\t    op | bp->b_flags, queue->rf_cinfo->ci_dev,\n\t\t    req->sectorOffset, req->numSector,\n\t\t    req->buf, KernelWakeupFunc, (void *) req,\n\t\t    queue->raidPtr->logBytesPerSector, req->b_proc);\n\n\t\tif (rf_debugKernelAccess) {\n\t\t\tdb1_printf((\"dispatch: bp->b_blkno = %ld\\n\",\n\t\t\t\t(long) bp->b_blkno));\n\t\t}\n\t\tqueue->numOutstanding++;\n\t\tqueue->last_deq_sector = req->sectorOffset;\n\t\t/* acc wouldn't have been let in if there were any pending\n\t\t * reqs at any other priority */\n\t\tqueue->curPriority = req->priority;\n\n\t\tdb1_printf((\"Going for %c to unit %d row %d col %d\\n\",\n\t\t\treq->type, unit, queue->row, queue->col));\n\t\tdb1_printf((\"sector %d count %d (%d bytes) %d\\n\",\n\t\t\t(int) req->sectorOffset, (int) req->numSector,\n\t\t\t(int) (req->numSector <<\n\t\t\t    queue->raidPtr->logBytesPerSector),\n\t\t\t(int) queue->raidPtr->logBytesPerSector));\n\t\tif ((raidbp->rf_buf.b_flags & B_READ) == 0) {\n\t\t\traidbp->rf_buf.b_vp->v_numoutput++;\n\t\t}\n\t\tVOP_STRATEGY(&raidbp->rf_buf);\n\n\t\tbreak;\n\n\tdefault:\n\t\tpanic(\"bad req->type in rf_DispatchKernelIO\");\n\t}\n\tdb1_printf((\"Exiting from DispatchKernelIO\\n\"));\n\t/* splx(s); */ /* want to test this */\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\"",
            "pri",
            "queue->row",
            "queue->col"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_OK_TO_DISPATCH",
          "args": [
            "queue",
            "req"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "RF_QUEUE_LOCKED(queue)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_QUEUE_LOCKED",
          "args": [
            "queue"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"Dispatching pri %d unlocking op to r %d c %d\\n\"",
            "pri",
            "queue->row",
            "queue->col"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCKING_REQ",
          "args": [
            "req"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "queue->qHdr",
            "req",
            "pri"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\"",
            "pri",
            "queue->row",
            "queue->col"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_QUEUE",
          "args": [
            "queue"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\"",
            "pri",
            "queue->row",
            "queue->col"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_QUEUE_EMPTY",
          "args": [
            "queue"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCKING_REQ",
          "args": [
            "req"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_QUEUE_MUTEX",
          "args": [
            "queue",
            "\"DiskIOEnqueue\""
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Warning: Enqueueing zero-sector access\\n\""
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "req->type == RF_IO_TYPE_NOP || req->numSector"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "req->qtime"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\n\nvoid \nrf_DiskIOEnqueue(queue, req, pri)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     pri;\n{\n\tRF_ETIMER_START(req->qtime);\n\tRF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);\n\treq->priority = pri;\n\n\tif (rf_queueDebug && (req->numSector == 0)) {\n\t\tprintf(\"Warning: Enqueueing zero-sector access\\n\");\n\t}\n\t/*\n         * kernel\n         */\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n\t/* locking request */\n\tif (RF_LOCKING_REQ(req)) {\n\t\tif (RF_QUEUE_EMPTY(queue)) {\n\t\t\tDprintf3(\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\", pri, queue->row, queue->col);\n\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t} else {\n\t\t\tqueue->queueLength++;\t/* increment count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tDprintf3(\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\", pri, queue->row, queue->col);\n\t\t\treq->queue = (void *) queue;\n\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t}\n\t}\n\t/* unlocking request */\n\telse\n\t\tif (RF_UNLOCKING_REQ(req)) {\t/* we'll do the actual unlock\n\t\t\t\t\t\t * when this I/O completes */\n\t\t\tDprintf3(\"Dispatching pri %d unlocking op to r %d c %d\\n\", pri, queue->row, queue->col);\n\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t}\n\t/* normal request */\n\t\telse\n\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\tDprintf3(\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t} else {\n\t\t\t\tqueue->queueLength++;\t/* increment count of\n\t\t\t\t\t\t\t * number of requests\n\t\t\t\t\t\t\t * waiting in this queue */\n\t\t\t\tDprintf3(\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\treq->queue = (void *) queue;\n\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t\t}\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n}"
  },
  {
    "function_name": "rf_ConfigureDiskQueues",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
    "lines": "264-320",
    "snippet": "int \nrf_ConfigureDiskQueues(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tRF_DiskQueue_t **diskQueues, *spareQueues;\n\tRF_DiskQueueSW_t *p;\n\tRF_RowCol_t r, c;\n\tint     rc, i;\n\n\traidPtr->maxQueueDepth = cfgPtr->maxOutstandingDiskReqs;\n\n\tfor (p = NULL, i = 0; i < NUM_DISK_QUEUE_TYPES; i++) {\n\t\tif (!strcmp(diskqueuesw[i].queueType, cfgPtr->diskQueueType)) {\n\t\t\tp = &diskqueuesw[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (p == NULL) {\n\t\tRF_ERRORMSG2(\"Unknown queue type \\\"%s\\\".  Using %s\\n\", cfgPtr->diskQueueType, diskqueuesw[0].queueType);\n\t\tp = &diskqueuesw[0];\n\t}\n\tRF_CallocAndAdd(diskQueues, raidPtr->numRow, sizeof(RF_DiskQueue_t *), (RF_DiskQueue_t **), raidPtr->cleanupList);\n\tif (diskQueues == NULL) {\n\t\treturn (ENOMEM);\n\t}\n\traidPtr->Queues = diskQueues;\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tRF_CallocAndAdd(diskQueues[r], raidPtr->numCol + \n\t\t\t\t ((r == 0) ? RF_MAXSPARE : 0), \n\t\t\t\tsizeof(RF_DiskQueue_t), (RF_DiskQueue_t *), \n\t\t\t\traidPtr->cleanupList);\n\t\tif (diskQueues[r] == NULL)\n\t\t\treturn (ENOMEM);\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\trc = config_disk_queue(raidPtr, &diskQueues[r][c], r, c, p,\n\t\t\t    raidPtr->sectorsPerDisk, raidPtr->Disks[r][c].dev,\n\t\t\t    cfgPtr->maxOutstandingDiskReqs, listp, raidPtr->cleanupList);\n\t\t\tif (rc)\n\t\t\t\treturn (rc);\n\t\t}\n\t}\n\n\tspareQueues = &raidPtr->Queues[0][raidPtr->numCol];\n\tfor (r = 0; r < raidPtr->numSpare; r++) {\n\t\trc = config_disk_queue(raidPtr, &spareQueues[r],\n\t\t    0, raidPtr->numCol + r, p,\n\t\t    raidPtr->sectorsPerDisk,\n\t\t    raidPtr->Disks[0][raidPtr->numCol + r].dev,\n\t\t    cfgPtr->maxOutstandingDiskReqs, listp,\n\t\t    raidPtr->cleanupList);\n\t\tif (rc)\n\t\t\treturn (rc);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_fifo.h\"",
      "#include \"rf_sstf.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [
      "#define NUM_DISK_QUEUE_TYPES (sizeof(diskqueuesw)/sizeof(RF_DiskQueueSW_t))"
    ],
    "globals_used": [
      "static RF_DiskQueueSW_t diskqueuesw[] = {\n\t{\"fifo\",\t\t/* FIFO */\n\t\trf_FifoCreate,\n\t\trf_FifoEnqueue,\n\t\trf_FifoDequeue,\n\t\trf_FifoPeek,\n\trf_FifoPromote},\n\n\t{\"cvscan\",\t\t/* cvscan */\n\t\trf_CvscanCreate,\n\t\trf_CvscanEnqueue,\n\t\trf_CvscanDequeue,\n\t\trf_CvscanPeek,\n\trf_CvscanPromote},\n\n\t{\"sstf\",\t\t/* shortest seek time first */\n\t\trf_SstfCreate,\n\t\trf_SstfEnqueue,\n\t\trf_SstfDequeue,\n\t\trf_SstfPeek,\n\trf_SstfPromote},\n\n\t{\"scan\",\t\t/* SCAN (two-way elevator) */\n\t\trf_ScanCreate,\n\t\trf_SstfEnqueue,\n\t\trf_ScanDequeue,\n\t\trf_ScanPeek,\n\trf_SstfPromote},\n\n\t{\"cscan\",\t\t/* CSCAN (one-way elevator) */\n\t\trf_CscanCreate,\n\t\trf_SstfEnqueue,\n\t\trf_CscanDequeue,\n\t\trf_CscanPeek,\n\trf_SstfPromote},\n\n#if !defined(_KERNEL) && RF_INCLUDE_QUEUE_RANDOM > 0\n\t/* to make a point to Chris :-> */\n\t{\"random\",\t\t/* random */\n\t\trf_FifoCreate,\n\t\trf_FifoEnqueue,\n\t\trf_RandomDequeue,\n\t\trf_RandomPeek,\n\trf_FifoPromote},\n#endif\t\t\t\t/* !_KERNEL && RF_INCLUDE_QUEUE_RANDOM > 0 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_disk_queue",
          "args": [
            "raidPtr",
            "&spareQueues[r]",
            "0",
            "raidPtr->numCol + r",
            "p",
            "raidPtr->sectorsPerDisk",
            "raidPtr->Disks[0][raidPtr->numCol + r].dev",
            "cfgPtr->maxOutstandingDiskReqs",
            "listp",
            "raidPtr->cleanupList"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "config_disk_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "189-233",
          "snippet": "int \nconfig_disk_queue(\n    RF_Raid_t * raidPtr,\n    RF_DiskQueue_t * diskqueue,\n    RF_RowCol_t r,\t\t/* row & col -- debug only.  BZZT not any\n\t\t\t\t * more... */\n    RF_RowCol_t c,\n    RF_DiskQueueSW_t * p,\n    RF_SectorCount_t sectPerDisk,\n    dev_t dev,\n    int maxOutstanding,\n    RF_ShutdownList_t ** listp,\n    RF_AllocListElem_t * clList)\n{\n\tint     rc;\n\n\tdiskqueue->row = r;\n\tdiskqueue->col = c;\n\tdiskqueue->qPtr = p;\n\tdiskqueue->qHdr = (p->Create) (sectPerDisk, clList, listp);\n\tdiskqueue->dev = dev;\n\tdiskqueue->numOutstanding = 0;\n\tdiskqueue->queueLength = 0;\n\tdiskqueue->maxOutstanding = maxOutstanding;\n\tdiskqueue->curPriority = RF_IO_NORMAL_PRIORITY;\n\tdiskqueue->nextLockingOp = NULL;\n\tdiskqueue->unlockingOp = NULL;\n\tdiskqueue->numWaiting = 0;\n\tdiskqueue->flags = 0;\n\tdiskqueue->raidPtr = raidPtr;\n\tdiskqueue->rf_cinfo = &raidPtr->raid_cinfo[r][c];\n\trc = rf_create_managed_mutex(listp, &diskqueue->mutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\treturn (rc);\n\t}\n\trc = rf_create_managed_cond(listp, &diskqueue->cond);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init cond file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\treturn (rc);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int config_disk_queue(RF_Raid_t *, RF_DiskQueue_t *, RF_RowCol_t, \n\t\t      RF_RowCol_t, RF_DiskQueueSW_t *,\n\t\t      RF_SectorCount_t, dev_t, int, \n\t\t      RF_ShutdownList_t **,\n\t\t      RF_AllocListElem_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nint config_disk_queue(RF_Raid_t *, RF_DiskQueue_t *, RF_RowCol_t, \n\t\t      RF_RowCol_t, RF_DiskQueueSW_t *,\n\t\t      RF_SectorCount_t, dev_t, int, \n\t\t      RF_ShutdownList_t **,\n\t\t      RF_AllocListElem_t *);\n\nint \nconfig_disk_queue(\n    RF_Raid_t * raidPtr,\n    RF_DiskQueue_t * diskqueue,\n    RF_RowCol_t r,\t\t/* row & col -- debug only.  BZZT not any\n\t\t\t\t * more... */\n    RF_RowCol_t c,\n    RF_DiskQueueSW_t * p,\n    RF_SectorCount_t sectPerDisk,\n    dev_t dev,\n    int maxOutstanding,\n    RF_ShutdownList_t ** listp,\n    RF_AllocListElem_t * clList)\n{\n\tint     rc;\n\n\tdiskqueue->row = r;\n\tdiskqueue->col = c;\n\tdiskqueue->qPtr = p;\n\tdiskqueue->qHdr = (p->Create) (sectPerDisk, clList, listp);\n\tdiskqueue->dev = dev;\n\tdiskqueue->numOutstanding = 0;\n\tdiskqueue->queueLength = 0;\n\tdiskqueue->maxOutstanding = maxOutstanding;\n\tdiskqueue->curPriority = RF_IO_NORMAL_PRIORITY;\n\tdiskqueue->nextLockingOp = NULL;\n\tdiskqueue->unlockingOp = NULL;\n\tdiskqueue->numWaiting = 0;\n\tdiskqueue->flags = 0;\n\tdiskqueue->raidPtr = raidPtr;\n\tdiskqueue->rf_cinfo = &raidPtr->raid_cinfo[r][c];\n\trc = rf_create_managed_mutex(listp, &diskqueue->mutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\treturn (rc);\n\t}\n\trc = rf_create_managed_cond(listp, &diskqueue->cond);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init cond file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\treturn (rc);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_CallocAndAdd",
          "args": [
            "diskQueues[r]",
            "raidPtr->numCol + \n\t\t\t\t ((r == 0) ? RF_MAXSPARE : 0)",
            "sizeof(RF_DiskQueue_t)",
            "(RF_DiskQueue_t *), \n\t\t\t\traidPtr->cleanupList"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CallocAndAdd",
          "args": [
            "diskQueues",
            "raidPtr->numRow",
            "sizeof(RF_DiskQueue_t *)",
            "(RF_DiskQueue_t **), raidPtr->cleanupList"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG2",
          "args": [
            "\"Unknown queue type \\\"%s\\\".  Using %s\\n\"",
            "cfgPtr->diskQueueType",
            "diskqueuesw[0].queueType"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "diskqueuesw[i].queueType",
            "cfgPtr->diskQueueType"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define NUM_DISK_QUEUE_TYPES (sizeof(diskqueuesw)/sizeof(RF_DiskQueueSW_t))\n\nstatic RF_DiskQueueSW_t diskqueuesw[] = {\n\t{\"fifo\",\t\t/* FIFO */\n\t\trf_FifoCreate,\n\t\trf_FifoEnqueue,\n\t\trf_FifoDequeue,\n\t\trf_FifoPeek,\n\trf_FifoPromote},\n\n\t{\"cvscan\",\t\t/* cvscan */\n\t\trf_CvscanCreate,\n\t\trf_CvscanEnqueue,\n\t\trf_CvscanDequeue,\n\t\trf_CvscanPeek,\n\trf_CvscanPromote},\n\n\t{\"sstf\",\t\t/* shortest seek time first */\n\t\trf_SstfCreate,\n\t\trf_SstfEnqueue,\n\t\trf_SstfDequeue,\n\t\trf_SstfPeek,\n\trf_SstfPromote},\n\n\t{\"scan\",\t\t/* SCAN (two-way elevator) */\n\t\trf_ScanCreate,\n\t\trf_SstfEnqueue,\n\t\trf_ScanDequeue,\n\t\trf_ScanPeek,\n\trf_SstfPromote},\n\n\t{\"cscan\",\t\t/* CSCAN (one-way elevator) */\n\t\trf_CscanCreate,\n\t\trf_SstfEnqueue,\n\t\trf_CscanDequeue,\n\t\trf_CscanPeek,\n\trf_SstfPromote},\n\n#if !defined(_KERNEL) && RF_INCLUDE_QUEUE_RANDOM > 0\n\t/* to make a point to Chris :-> */\n\t{\"random\",\t\t/* random */\n\t\trf_FifoCreate,\n\t\trf_FifoEnqueue,\n\t\trf_RandomDequeue,\n\t\trf_RandomPeek,\n\trf_FifoPromote},\n#endif\t\t\t\t/* !_KERNEL && RF_INCLUDE_QUEUE_RANDOM > 0 */\n};\n\nint \nrf_ConfigureDiskQueues(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tRF_DiskQueue_t **diskQueues, *spareQueues;\n\tRF_DiskQueueSW_t *p;\n\tRF_RowCol_t r, c;\n\tint     rc, i;\n\n\traidPtr->maxQueueDepth = cfgPtr->maxOutstandingDiskReqs;\n\n\tfor (p = NULL, i = 0; i < NUM_DISK_QUEUE_TYPES; i++) {\n\t\tif (!strcmp(diskqueuesw[i].queueType, cfgPtr->diskQueueType)) {\n\t\t\tp = &diskqueuesw[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (p == NULL) {\n\t\tRF_ERRORMSG2(\"Unknown queue type \\\"%s\\\".  Using %s\\n\", cfgPtr->diskQueueType, diskqueuesw[0].queueType);\n\t\tp = &diskqueuesw[0];\n\t}\n\tRF_CallocAndAdd(diskQueues, raidPtr->numRow, sizeof(RF_DiskQueue_t *), (RF_DiskQueue_t **), raidPtr->cleanupList);\n\tif (diskQueues == NULL) {\n\t\treturn (ENOMEM);\n\t}\n\traidPtr->Queues = diskQueues;\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tRF_CallocAndAdd(diskQueues[r], raidPtr->numCol + \n\t\t\t\t ((r == 0) ? RF_MAXSPARE : 0), \n\t\t\t\tsizeof(RF_DiskQueue_t), (RF_DiskQueue_t *), \n\t\t\t\traidPtr->cleanupList);\n\t\tif (diskQueues[r] == NULL)\n\t\t\treturn (ENOMEM);\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\trc = config_disk_queue(raidPtr, &diskQueues[r][c], r, c, p,\n\t\t\t    raidPtr->sectorsPerDisk, raidPtr->Disks[r][c].dev,\n\t\t\t    cfgPtr->maxOutstandingDiskReqs, listp, raidPtr->cleanupList);\n\t\t\tif (rc)\n\t\t\t\treturn (rc);\n\t\t}\n\t}\n\n\tspareQueues = &raidPtr->Queues[0][raidPtr->numCol];\n\tfor (r = 0; r < raidPtr->numSpare; r++) {\n\t\trc = config_disk_queue(raidPtr, &spareQueues[r],\n\t\t    0, raidPtr->numCol + r, p,\n\t\t    raidPtr->sectorsPerDisk,\n\t\t    raidPtr->Disks[0][raidPtr->numCol + r].dev,\n\t\t    cfgPtr->maxOutstandingDiskReqs, listp,\n\t\t    raidPtr->cleanupList);\n\t\tif (rc)\n\t\t\treturn (rc);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_ConfigureDiskQueueSystem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
    "lines": "242-262",
    "snippet": "int \nrf_ConfigureDiskQueueSystem(listp)\n\tRF_ShutdownList_t **listp;\n{\n\tint     rc;\n\n\tRF_FREELIST_CREATE(rf_dqd_freelist, RF_MAX_FREE_DQD,\n\t    RF_DQD_INC, sizeof(RF_DiskQueueData_t));\n\tif (rf_dqd_freelist == NULL)\n\t\treturn (ENOMEM);\n\trc = rf_ShutdownCreate(listp, rf_ShutdownDiskQueueSystem, NULL);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\",\n\t\t    __FILE__, __LINE__, rc);\n\t\trf_ShutdownDiskQueueSystem(NULL);\n\t\treturn (rc);\n\t}\n\tRF_FREELIST_PRIME_INIT(rf_dqd_freelist, RF_DQD_INITIAL, next,\n\t    (RF_DiskQueueData_t *), init_dqd);\n\treturn (0);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_fifo.h\"",
      "#include \"rf_sstf.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [
      "#define RF_DQD_INITIAL   64",
      "#define RF_DQD_INC       16",
      "#define RF_MAX_FREE_DQD 256"
    ],
    "globals_used": [
      "static int init_dqd(RF_DiskQueueData_t *);",
      "static void clean_dqd(RF_DiskQueueData_t *);",
      "static void rf_ShutdownDiskQueueSystem(void *);",
      "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);",
      "static RF_FreeList_t *rf_dqd_freelist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_PRIME_INIT",
          "args": [
            "rf_dqd_freelist",
            "RF_DQD_INITIAL",
            "next",
            "(RF_DiskQueueData_t *), init_dqd"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownDiskQueueSystem",
          "args": [
            "NULL"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ShutdownDiskQueueSystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "235-240",
          "snippet": "static void \nrf_ShutdownDiskQueueSystem(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY_CLEAN(rf_dqd_freelist, next, (RF_DiskQueueData_t *), clean_dqd);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "static void rf_ShutdownDiskQueueSystem(void *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);",
            "static RF_FreeList_t *rf_dqd_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nstatic void rf_ShutdownDiskQueueSystem(void *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\nstatic RF_FreeList_t *rf_dqd_freelist;\n\nstatic void \nrf_ShutdownDiskQueueSystem(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY_CLEAN(rf_dqd_freelist, next, (RF_DiskQueueData_t *), clean_dqd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to add to shutdown list file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownCreate",
          "args": [
            "listp",
            "rf_ShutdownDiskQueueSystem",
            "NULL"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_CREATE",
          "args": [
            "rf_dqd_freelist",
            "RF_MAX_FREE_DQD",
            "RF_DQD_INC",
            "sizeof(RF_DiskQueueData_t)"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define RF_DQD_INITIAL   64\n#define RF_DQD_INC       16\n#define RF_MAX_FREE_DQD 256\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nstatic void rf_ShutdownDiskQueueSystem(void *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\nstatic RF_FreeList_t *rf_dqd_freelist;\n\nint \nrf_ConfigureDiskQueueSystem(listp)\n\tRF_ShutdownList_t **listp;\n{\n\tint     rc;\n\n\tRF_FREELIST_CREATE(rf_dqd_freelist, RF_MAX_FREE_DQD,\n\t    RF_DQD_INC, sizeof(RF_DiskQueueData_t));\n\tif (rf_dqd_freelist == NULL)\n\t\treturn (ENOMEM);\n\trc = rf_ShutdownCreate(listp, rf_ShutdownDiskQueueSystem, NULL);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\",\n\t\t    __FILE__, __LINE__, rc);\n\t\trf_ShutdownDiskQueueSystem(NULL);\n\t\treturn (rc);\n\t}\n\tRF_FREELIST_PRIME_INIT(rf_dqd_freelist, RF_DQD_INITIAL, next,\n\t    (RF_DiskQueueData_t *), init_dqd);\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_ShutdownDiskQueueSystem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
    "lines": "235-240",
    "snippet": "static void \nrf_ShutdownDiskQueueSystem(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY_CLEAN(rf_dqd_freelist, next, (RF_DiskQueueData_t *), clean_dqd);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_fifo.h\"",
      "#include \"rf_sstf.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_dqd(RF_DiskQueueData_t *);",
      "static void clean_dqd(RF_DiskQueueData_t *);",
      "static void rf_ShutdownDiskQueueSystem(void *);",
      "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);",
      "static RF_FreeList_t *rf_dqd_freelist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_DESTROY_CLEAN",
          "args": [
            "rf_dqd_freelist",
            "next",
            "(RF_DiskQueueData_t *), clean_dqd"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nstatic void rf_ShutdownDiskQueueSystem(void *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\nstatic RF_FreeList_t *rf_dqd_freelist;\n\nstatic void \nrf_ShutdownDiskQueueSystem(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY_CLEAN(rf_dqd_freelist, next, (RF_DiskQueueData_t *), clean_dqd);\n}"
  },
  {
    "function_name": "config_disk_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
    "lines": "189-233",
    "snippet": "int \nconfig_disk_queue(\n    RF_Raid_t * raidPtr,\n    RF_DiskQueue_t * diskqueue,\n    RF_RowCol_t r,\t\t/* row & col -- debug only.  BZZT not any\n\t\t\t\t * more... */\n    RF_RowCol_t c,\n    RF_DiskQueueSW_t * p,\n    RF_SectorCount_t sectPerDisk,\n    dev_t dev,\n    int maxOutstanding,\n    RF_ShutdownList_t ** listp,\n    RF_AllocListElem_t * clList)\n{\n\tint     rc;\n\n\tdiskqueue->row = r;\n\tdiskqueue->col = c;\n\tdiskqueue->qPtr = p;\n\tdiskqueue->qHdr = (p->Create) (sectPerDisk, clList, listp);\n\tdiskqueue->dev = dev;\n\tdiskqueue->numOutstanding = 0;\n\tdiskqueue->queueLength = 0;\n\tdiskqueue->maxOutstanding = maxOutstanding;\n\tdiskqueue->curPriority = RF_IO_NORMAL_PRIORITY;\n\tdiskqueue->nextLockingOp = NULL;\n\tdiskqueue->unlockingOp = NULL;\n\tdiskqueue->numWaiting = 0;\n\tdiskqueue->flags = 0;\n\tdiskqueue->raidPtr = raidPtr;\n\tdiskqueue->rf_cinfo = &raidPtr->raid_cinfo[r][c];\n\trc = rf_create_managed_mutex(listp, &diskqueue->mutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\treturn (rc);\n\t}\n\trc = rf_create_managed_cond(listp, &diskqueue->cond);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init cond file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\treturn (rc);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_fifo.h\"",
      "#include \"rf_sstf.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int config_disk_queue(RF_Raid_t *, RF_DiskQueue_t *, RF_RowCol_t, \n\t\t      RF_RowCol_t, RF_DiskQueueSW_t *,\n\t\t      RF_SectorCount_t, dev_t, int, \n\t\t      RF_ShutdownList_t **,\n\t\t      RF_AllocListElem_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to init cond file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_create_managed_cond",
          "args": [
            "listp",
            "&diskqueue->cond"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "_rf_create_managed_cond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_threadstuff.c",
          "lines": "92-113",
          "snippet": "int \n_rf_create_managed_cond(listp, c, file, line)\n\tRF_ShutdownList_t **listp;\nRF_DECLARE_COND(*c)\n\tchar   *file;\n\tint     line;\n{\n\tint     rc, rc1;\n\n\trc = rf_cond_init(c);\n\tif (rc)\n\t\treturn (rc);\n\trc = _rf_ShutdownCreate(listp, cond_destroyer, (void *) c, file, line);\n\tif (rc) {\n\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d adding shutdown entry\\n\", rc);\n\t\trc1 = rf_cond_destroy(c);\n\t\tif (rc1) {\n\t\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d destroying cond\\n\", rc1);\n\t\t}\n\t}\n\treturn (rc);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cond_destroyer(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic void cond_destroyer(void *);\n\nint \n_rf_create_managed_cond(listp, c, file, line)\n\tRF_ShutdownList_t **listp;\nRF_DECLARE_COND(*c)\n\tchar   *file;\n\tint     line;\n{\n\tint     rc, rc1;\n\n\trc = rf_cond_init(c);\n\tif (rc)\n\t\treturn (rc);\n\trc = _rf_ShutdownCreate(listp, cond_destroyer, (void *) c, file, line);\n\tif (rc) {\n\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d adding shutdown entry\\n\", rc);\n\t\trc1 = rf_cond_destroy(c);\n\t\tif (rc1) {\n\t\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d destroying cond\\n\", rc1);\n\t\t}\n\t}\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to init mutex file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_create_managed_mutex",
          "args": [
            "listp",
            "&diskqueue->mutex"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "_rf_create_managed_mutex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_threadstuff.c",
          "lines": "69-90",
          "snippet": "int \n_rf_create_managed_mutex(listp, m, file, line)\n\tRF_ShutdownList_t **listp;\nRF_DECLARE_MUTEX(*m)\n\tchar   *file;\n\tint     line;\n{\n\tint     rc, rc1;\n\n\trc = rf_mutex_init(m);\n\tif (rc)\n\t\treturn (rc);\n\trc = _rf_ShutdownCreate(listp, mutex_destroyer, (void *) m, file, line);\n\tif (rc) {\n\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d adding shutdown entry\\n\", rc);\n\t\trc1 = rf_mutex_destroy(m);\n\t\tif (rc1) {\n\t\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d destroying mutex\\n\", rc1);\n\t\t}\n\t}\n\treturn (rc);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mutex_destroyer(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic void mutex_destroyer(void *);\n\nint \n_rf_create_managed_mutex(listp, m, file, line)\n\tRF_ShutdownList_t **listp;\nRF_DECLARE_MUTEX(*m)\n\tchar   *file;\n\tint     line;\n{\n\tint     rc, rc1;\n\n\trc = rf_mutex_init(m);\n\tif (rc)\n\t\treturn (rc);\n\trc = _rf_ShutdownCreate(listp, mutex_destroyer, (void *) m, file, line);\n\tif (rc) {\n\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d adding shutdown entry\\n\", rc);\n\t\trc1 = rf_mutex_destroy(m);\n\t\tif (rc1) {\n\t\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d destroying mutex\\n\", rc1);\n\t\t}\n\t}\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sectPerDisk",
            "clList",
            "listp"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nint config_disk_queue(RF_Raid_t *, RF_DiskQueue_t *, RF_RowCol_t, \n\t\t      RF_RowCol_t, RF_DiskQueueSW_t *,\n\t\t      RF_SectorCount_t, dev_t, int, \n\t\t      RF_ShutdownList_t **,\n\t\t      RF_AllocListElem_t *);\n\nint \nconfig_disk_queue(\n    RF_Raid_t * raidPtr,\n    RF_DiskQueue_t * diskqueue,\n    RF_RowCol_t r,\t\t/* row & col -- debug only.  BZZT not any\n\t\t\t\t * more... */\n    RF_RowCol_t c,\n    RF_DiskQueueSW_t * p,\n    RF_SectorCount_t sectPerDisk,\n    dev_t dev,\n    int maxOutstanding,\n    RF_ShutdownList_t ** listp,\n    RF_AllocListElem_t * clList)\n{\n\tint     rc;\n\n\tdiskqueue->row = r;\n\tdiskqueue->col = c;\n\tdiskqueue->qPtr = p;\n\tdiskqueue->qHdr = (p->Create) (sectPerDisk, clList, listp);\n\tdiskqueue->dev = dev;\n\tdiskqueue->numOutstanding = 0;\n\tdiskqueue->queueLength = 0;\n\tdiskqueue->maxOutstanding = maxOutstanding;\n\tdiskqueue->curPriority = RF_IO_NORMAL_PRIORITY;\n\tdiskqueue->nextLockingOp = NULL;\n\tdiskqueue->unlockingOp = NULL;\n\tdiskqueue->numWaiting = 0;\n\tdiskqueue->flags = 0;\n\tdiskqueue->raidPtr = raidPtr;\n\tdiskqueue->rf_cinfo = &raidPtr->raid_cinfo[r][c];\n\trc = rf_create_managed_mutex(listp, &diskqueue->mutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\treturn (rc);\n\t}\n\trc = rf_create_managed_cond(listp, &diskqueue->cond);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init cond file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\treturn (rc);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "clean_dqd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
    "lines": "177-182",
    "snippet": "static void \nclean_dqd(dqd)\n\tRF_DiskQueueData_t *dqd;\n{\n\tfree(dqd->bp, M_RAIDFRAME);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_fifo.h\"",
      "#include \"rf_sstf.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_dqd(RF_DiskQueueData_t *);",
      "static void clean_dqd(RF_DiskQueueData_t *);",
      "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dqd->bp",
            "M_RAIDFRAME"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "rf_free_1d_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_utils.c",
          "lines": "90-96",
          "snippet": "void \nrf_free_1d_array(a, n)\n\tRF_RowCol_t *a;\n\tint     n;\n{\n\tRF_Free(a, n * sizeof(RF_RowCol_t));\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_utils.h\"",
            "#include <sys/time.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_utils.h\"\n#include <sys/time.h>\n#include \"rf_threadstuff.h\"\n\nvoid \nrf_free_1d_array(a, n)\n\tRF_RowCol_t *a;\n\tint     n;\n{\n\tRF_Free(a, n * sizeof(RF_RowCol_t));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\n\nstatic void \nclean_dqd(dqd)\n\tRF_DiskQueueData_t *dqd;\n{\n\tfree(dqd->bp, M_RAIDFRAME);\n}"
  },
  {
    "function_name": "init_dqd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
    "lines": "162-175",
    "snippet": "static int \ninit_dqd(dqd)\n\tRF_DiskQueueData_t *dqd;\n{\n\t/* XXX not sure if the following malloc is appropriate... probably not\n\t * quite... */\n\tdqd->bp = (struct buf *) malloc(sizeof(struct buf), M_RAIDFRAME, M_NOWAIT);\n\tif (dqd->bp == NULL) {\n\t\treturn (ENOMEM);\n\t}\n\tmemset(dqd->bp, 0, sizeof(struct buf));\t/* if you don't do it, nobody\n\t\t\t\t\t\t * else will.. */\n\treturn (0);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_fifo.h\"",
      "#include \"rf_sstf.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_dqd(RF_DiskQueueData_t *);",
      "static void clean_dqd(RF_DiskQueueData_t *);",
      "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dqd->bp",
            "0",
            "sizeof(struct buf)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct buf)",
            "M_RAIDFRAME",
            "M_NOWAIT"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\n\nstatic int \ninit_dqd(dqd)\n\tRF_DiskQueueData_t *dqd;\n{\n\t/* XXX not sure if the following malloc is appropriate... probably not\n\t * quite... */\n\tdqd->bp = (struct buf *) malloc(sizeof(struct buf), M_RAIDFRAME, M_NOWAIT);\n\tif (dqd->bp == NULL) {\n\t\treturn (ENOMEM);\n\t}\n\tmemset(dqd->bp, 0, sizeof(struct buf));\t/* if you don't do it, nobody\n\t\t\t\t\t\t * else will.. */\n\treturn (0);\n}"
  }
]