[
  {
    "function_name": "print_tuple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
    "lines": "918-940",
    "snippet": "static void\nprint_tuple(tuple, len, data)\n     u_int8_t *tuple;\n     int len;\n     void *data;\n{\n    int i;\n\n    printf(\"tuple: %s len %d\\n\", tuple_name(tuple[0]), len);\n\n    for (i = 0; i < len; ++i) {\n\tif (i % 16 == 0) {\n\t    printf(\"  0x%2x:\", i);\n\t}\n\tprintf(\" %x\",tuple[i]);\n\tif (i % 16 == 15) {\n\t    printf(\"\\n\");\n\t}\n    }\n    if (i % 16 != 0) {\n\tprintf(\"\\n\");\n    }\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/pci/pcivar.h>\t/* XXX */",
      "#include <dev/cardbus/cardbus_exrom.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u_int8_t *\ndecode_tuple(tuple, func, data)\n     u_int8_t *tuple;",
      "void *data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuple_name",
          "args": [
            "tuple[0]"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic u_int8_t *\ndecode_tuple(tuple, func, data)\n     u_int8_t *tuple;\nvoid *data;\n\nstatic void\nprint_tuple(tuple, len, data)\n     u_int8_t *tuple;\n     int len;\n     void *data;\n{\n    int i;\n\n    printf(\"tuple: %s len %d\\n\", tuple_name(tuple[0]), len);\n\n    for (i = 0; i < len; ++i) {\n\tif (i % 16 == 0) {\n\t    printf(\"  0x%2x:\", i);\n\t}\n\tprintf(\" %x\",tuple[i]);\n\tif (i % 16 == 15) {\n\t    printf(\"\\n\");\n\t}\n    }\n    if (i % 16 != 0) {\n\tprintf(\"\\n\");\n    }\n}"
  },
  {
    "function_name": "decode_tuples",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
    "lines": "834-855",
    "snippet": "static int\ndecode_tuples(tuple, buflen, func, data)\n     u_int8_t *tuple;\n     int buflen;\n     tuple_decode_func func;\n     void *data;\n{\n  u_int8_t *tp = tuple;\n\n  if (PCMCIA_CISTPL_LINKTARGET != *tuple) {\n    DPRINTF((\"WRONG TUPLE: 0x%x\\n\", *tuple));\n    return 0;\n  }\n\n  while (NULL != (tp = decode_tuple(tp, func, data))) {\n    if (tuple + buflen < tp) {\n      break;\n    }\n  }\n  \n  return 1;\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/pci/pcivar.h>\t/* XXX */",
      "#include <dev/cardbus/cardbus_exrom.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int decode_tuples",
      "int (*func)",
      "static u_int8_t *\ndecode_tuple",
      "static u_int8_t *\ndecode_tuple(tuple, func, data)\n     u_int8_t *tuple;",
      "tuple_decode_func func;",
      "void *data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "decode_tuple",
          "args": [
            "tp",
            "func",
            "data"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "decode_tuples",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
          "lines": "834-855",
          "snippet": "static int\ndecode_tuples(tuple, buflen, func, data)\n     u_int8_t *tuple;\n     int buflen;\n     tuple_decode_func func;\n     void *data;\n{\n  u_int8_t *tp = tuple;\n\n  if (PCMCIA_CISTPL_LINKTARGET != *tuple) {\n    DPRINTF((\"WRONG TUPLE: 0x%x\\n\", *tuple));\n    return 0;\n  }\n\n  while (NULL != (tp = decode_tuple(tp, func, data))) {\n    if (tuple + buflen < tp) {\n      break;\n    }\n  }\n  \n  return 1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"WRONG TUPLE: 0x%x\\n\", *tuple)"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int decode_tuples;\nint (*func);\nstatic u_int8_t *\ndecode_tuple;\nstatic u_int8_t *\ndecode_tuple(tuple, func, data)\n     u_int8_t *tuple;\ntuple_decode_func func;\nvoid *data;\n\nstatic int\ndecode_tuples(tuple, buflen, func, data)\n     u_int8_t *tuple;\n     int buflen;\n     tuple_decode_func func;\n     void *data;\n{\n  u_int8_t *tp = tuple;\n\n  if (PCMCIA_CISTPL_LINKTARGET != *tuple) {\n    DPRINTF((\"WRONG TUPLE: 0x%x\\n\", *tuple));\n    return 0;\n  }\n\n  while (NULL != (tp = decode_tuple(tp, func, data))) {\n    if (tuple + buflen < tp) {\n      break;\n    }\n  }\n  \n  return 1;\n}"
  },
  {
    "function_name": "cardbus_get_capability",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
    "lines": "788-823",
    "snippet": "int\ncardbus_get_capability(cc, cf, tag, capid, offset, value)\n\tcardbus_chipset_tag_t cc;\n\tcardbus_function_tag_t cf;\n\tcardbustag_t tag;\n\tint capid;\n\tint *offset;\n\tcardbusreg_t *value;\n{\n\tcardbusreg_t reg;\n\tunsigned int ofs;\n\n\treg = cardbus_conf_read(cc, cf, tag, PCI_COMMAND_STATUS_REG);\n\tif (!(reg & PCI_STATUS_CAPLIST_SUPPORT))\n\t\treturn (0);\n\n\tofs = PCI_CAPLIST_PTR(cardbus_conf_read(cc, cf, tag,\n\t    PCI_CAPLISTPTR_REG));\n\twhile (ofs != 0) {\n#ifdef DIAGNOSTIC\n\t\tif ((ofs & 3) || (ofs < 0x40))\n\t\t\tpanic(\"cardbus_get_capability\");\n#endif\n\t\treg = cardbus_conf_read(cc, cf, tag, ofs);\n\t\tif (PCI_CAPLIST_CAP(reg) == capid) {\n\t\t\tif (offset)\n\t\t\t\t*offset = ofs;\n\t\t\tif (value)\n\t\t\t\t*value = reg;\n\t\t\treturn (1);\n\t\t}\n\t\tofs = PCI_CAPLIST_NEXT(reg);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/pci/pcivar.h>\t/* XXX */",
      "#include <dev/cardbus/cardbus_exrom.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *\ncardbus_intr_establish(cc, cf, irq, level, func, arg)\n     cardbus_chipset_tag_t cc;",
      "cardbus_function_tag_t cf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_CAPLIST_NEXT",
          "args": [
            "reg"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CAPLIST_CAP",
          "args": [
            "reg"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "ofs"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"cardbus_get_capability\""
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CAPLIST_PTR",
          "args": [
            "cardbus_conf_read(cc, cf, tag,\n\t    PCI_CAPLISTPTR_REG)"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "PCI_CAPLISTPTR_REG"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\ncardbus_intr_establish(cc, cf, irq, level, func, arg)\n     cardbus_chipset_tag_t cc;\ncardbus_function_tag_t cf;\n\nint\ncardbus_get_capability(cc, cf, tag, capid, offset, value)\n\tcardbus_chipset_tag_t cc;\n\tcardbus_function_tag_t cf;\n\tcardbustag_t tag;\n\tint capid;\n\tint *offset;\n\tcardbusreg_t *value;\n{\n\tcardbusreg_t reg;\n\tunsigned int ofs;\n\n\treg = cardbus_conf_read(cc, cf, tag, PCI_COMMAND_STATUS_REG);\n\tif (!(reg & PCI_STATUS_CAPLIST_SUPPORT))\n\t\treturn (0);\n\n\tofs = PCI_CAPLIST_PTR(cardbus_conf_read(cc, cf, tag,\n\t    PCI_CAPLISTPTR_REG));\n\twhile (ofs != 0) {\n#ifdef DIAGNOSTIC\n\t\tif ((ofs & 3) || (ofs < 0x40))\n\t\t\tpanic(\"cardbus_get_capability\");\n#endif\n\t\treg = cardbus_conf_read(cc, cf, tag, ofs);\n\t\tif (PCI_CAPLIST_CAP(reg) == capid) {\n\t\t\tif (offset)\n\t\t\t\t*offset = ofs;\n\t\t\tif (value)\n\t\t\t\t*value = reg;\n\t\t\treturn (1);\n\t\t}\n\t\tofs = PCI_CAPLIST_NEXT(reg);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "cardbus_function_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
    "lines": "767-778",
    "snippet": "int\ncardbus_function_disable(sc, func)\n     struct cardbus_softc *sc;\n     int func;\n{\n\n  DPRINTF((\"entering cardbus_function_disable...  \"));\n\n  disable_function(sc, func);\n\n  return 0;\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/pci/pcivar.h>\t/* XXX */",
      "#include <dev/cardbus/cardbus_exrom.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void disable_function",
      "int (*func)",
      "tuple_decode_func func;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_function",
          "args": [
            "sc",
            "func"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "disable_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
          "lines": "709-720",
          "snippet": "static void\ndisable_function(sc, function)\n     struct cardbus_softc *sc; \n     int function;\n{\n\n    sc->sc_poweron_func &= ~(1 << function);\n    if (sc->sc_poweron_func == 0) {\n\t/* power-off because no functions are enabled */\n\tsc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_0V);\n    }\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pci/pcireg.h>\t/* XXX */",
            "#include <dev/pci/pcivar.h>\t/* XXX */",
            "#include <dev/cardbus/cardbus_exrom.h>",
            "#include <dev/cardbus/cardbusdevs.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void disable_function"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void disable_function;\n\nstatic void\ndisable_function(sc, function)\n     struct cardbus_softc *sc; \n     int function;\n{\n\n    sc->sc_poweron_func &= ~(1 << function);\n    if (sc->sc_poweron_func == 0) {\n\t/* power-off because no functions are enabled */\n\tsc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_0V);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"entering cardbus_function_disable...  \")"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void disable_function;\nint (*func);\ntuple_decode_func func;\n\nint\ncardbus_function_disable(sc, func)\n     struct cardbus_softc *sc;\n     int func;\n{\n\n  DPRINTF((\"entering cardbus_function_disable...  \"));\n\n  disable_function(sc, func);\n\n  return 0;\n}"
  },
  {
    "function_name": "cardbus_function_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
    "lines": "728-758",
    "snippet": "int\ncardbus_function_enable(sc, func)\n     struct cardbus_softc *sc;\n     int func;\n{\n  cardbus_chipset_tag_t cc = sc->sc_cc;\n  cardbus_function_tag_t cf = sc->sc_cf;\n  cardbusreg_t command;\n  cardbustag_t tag;\n\n  DPRINTF((\"entering cardbus_function_enable...  \"));\n\n  /* entering critical area */\n\n  enable_function(sc, CARDBUS_3V_CARD, func); /* XXX: sc_vold should be used */\n\n  /* exiting critical area */\n\n  tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, func);\n\n  command = cardbus_conf_read(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG);\n  command |= (CARDBUS_COMMAND_MEM_ENABLE | CARDBUS_COMMAND_IO_ENABLE | CARDBUS_COMMAND_MASTER_ENABLE); /* XXX: good guess needed */\n\n  cardbus_conf_write(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG, command);\n\n  cardbus_free_tag(cc, cf, tag);\n\n  DPRINTF((\"%x\\n\", sc->sc_poweron_func));\n\n  return 0;\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/pci/pcivar.h>\t/* XXX */",
      "#include <dev/cardbus/cardbus_exrom.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void enable_function",
      "void *\ncardbus_intr_establish(cc, cf, irq, level, func, arg)\n     cardbus_chipset_tag_t cc;",
      "cardbus_function_tag_t cf;",
      "int (*func)",
      "tuple_decode_func func;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%x\\n\", sc->sc_poweron_func)"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_free_tag",
          "args": [
            "cc",
            "cf",
            "tag"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_COMMAND_STATUS_REG",
            "command"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_COMMAND_STATUS_REG"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_make_tag",
          "args": [
            "cc",
            "cf",
            "sc->sc_bus",
            "sc->sc_device",
            "func"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enable_function",
          "args": [
            "sc",
            "CARDBUS_3V_CARD",
            "func"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "enable_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
          "lines": "689-707",
          "snippet": "static void\nenable_function(sc, cdstatus, function)\n     struct cardbus_softc *sc;\n     int cdstatus;\n     int function;\n{\n\n    if (sc->sc_poweron_func == 0) {\n\t/* switch to 3V and/or wait for power to stabilize */\n\tif (cdstatus & CARDBUS_3V_CARD) {\n\t    sc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_3V);\n\t} else {\n\t    /* No cards other than 3.3V cards. */\n\t    return;\n\t}\n\t(sc->sc_cf->cardbus_ctrl)(sc->sc_cc, CARDBUS_RESET);\n    }\n    sc->sc_poweron_func |= (1 << function);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pci/pcireg.h>\t/* XXX */",
            "#include <dev/pci/pcivar.h>\t/* XXX */",
            "#include <dev/cardbus/cardbus_exrom.h>",
            "#include <dev/cardbus/cardbusdevs.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void enable_function"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void enable_function;\n\nstatic void\nenable_function(sc, cdstatus, function)\n     struct cardbus_softc *sc;\n     int cdstatus;\n     int function;\n{\n\n    if (sc->sc_poweron_func == 0) {\n\t/* switch to 3V and/or wait for power to stabilize */\n\tif (cdstatus & CARDBUS_3V_CARD) {\n\t    sc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_3V);\n\t} else {\n\t    /* No cards other than 3.3V cards. */\n\t    return;\n\t}\n\t(sc->sc_cf->cardbus_ctrl)(sc->sc_cc, CARDBUS_RESET);\n    }\n    sc->sc_poweron_func |= (1 << function);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"entering cardbus_function_enable...  \")"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void enable_function;\nvoid *\ncardbus_intr_establish(cc, cf, irq, level, func, arg)\n     cardbus_chipset_tag_t cc;\ncardbus_function_tag_t cf;\nint (*func);\ntuple_decode_func func;\n\nint\ncardbus_function_enable(sc, func)\n     struct cardbus_softc *sc;\n     int func;\n{\n  cardbus_chipset_tag_t cc = sc->sc_cc;\n  cardbus_function_tag_t cf = sc->sc_cf;\n  cardbusreg_t command;\n  cardbustag_t tag;\n\n  DPRINTF((\"entering cardbus_function_enable...  \"));\n\n  /* entering critical area */\n\n  enable_function(sc, CARDBUS_3V_CARD, func); /* XXX: sc_vold should be used */\n\n  /* exiting critical area */\n\n  tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, func);\n\n  command = cardbus_conf_read(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG);\n  command |= (CARDBUS_COMMAND_MEM_ENABLE | CARDBUS_COMMAND_IO_ENABLE | CARDBUS_COMMAND_MASTER_ENABLE); /* XXX: good guess needed */\n\n  cardbus_conf_write(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG, command);\n\n  cardbus_free_tag(cc, cf, tag);\n\n  DPRINTF((\"%x\\n\", sc->sc_poweron_func));\n\n  return 0;\n}"
  },
  {
    "function_name": "disable_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
    "lines": "709-720",
    "snippet": "static void\ndisable_function(sc, function)\n     struct cardbus_softc *sc; \n     int function;\n{\n\n    sc->sc_poweron_func &= ~(1 << function);\n    if (sc->sc_poweron_func == 0) {\n\t/* power-off because no functions are enabled */\n\tsc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_0V);\n    }\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/pci/pcivar.h>\t/* XXX */",
      "#include <dev/cardbus/cardbus_exrom.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void disable_function"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->sc_cf->cardbus_power",
          "args": [
            "sc->sc_cc",
            "CARDBUS_VCC_0V"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void disable_function;\n\nstatic void\ndisable_function(sc, function)\n     struct cardbus_softc *sc; \n     int function;\n{\n\n    sc->sc_poweron_func &= ~(1 << function);\n    if (sc->sc_poweron_func == 0) {\n\t/* power-off because no functions are enabled */\n\tsc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_0V);\n    }\n}"
  },
  {
    "function_name": "enable_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
    "lines": "689-707",
    "snippet": "static void\nenable_function(sc, cdstatus, function)\n     struct cardbus_softc *sc;\n     int cdstatus;\n     int function;\n{\n\n    if (sc->sc_poweron_func == 0) {\n\t/* switch to 3V and/or wait for power to stabilize */\n\tif (cdstatus & CARDBUS_3V_CARD) {\n\t    sc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_3V);\n\t} else {\n\t    /* No cards other than 3.3V cards. */\n\t    return;\n\t}\n\t(sc->sc_cf->cardbus_ctrl)(sc->sc_cc, CARDBUS_RESET);\n    }\n    sc->sc_poweron_func |= (1 << function);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/pci/pcivar.h>\t/* XXX */",
      "#include <dev/cardbus/cardbus_exrom.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void enable_function"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_cc",
            "CARDBUS_RESET"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->sc_cf->cardbus_power",
          "args": [
            "sc->sc_cc",
            "CARDBUS_VCC_3V"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void enable_function;\n\nstatic void\nenable_function(sc, cdstatus, function)\n     struct cardbus_softc *sc;\n     int cdstatus;\n     int function;\n{\n\n    if (sc->sc_poweron_func == 0) {\n\t/* switch to 3V and/or wait for power to stabilize */\n\tif (cdstatus & CARDBUS_3V_CARD) {\n\t    sc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_3V);\n\t} else {\n\t    /* No cards other than 3.3V cards. */\n\t    return;\n\t}\n\t(sc->sc_cf->cardbus_ctrl)(sc->sc_cc, CARDBUS_RESET);\n    }\n    sc->sc_poweron_func |= (1 << function);\n}"
  },
  {
    "function_name": "cardbus_intr_disestablish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
    "lines": "672-682",
    "snippet": "void\ncardbus_intr_disestablish(cc, cf, handler)\n     cardbus_chipset_tag_t cc;\n     cardbus_function_tag_t cf;\n     void *handler;\n{\n  DPRINTF((\"- pccard_intr_disestablish\\n\"));\n\n (*cf->cardbus_intr_disestablish)(cc, handler);\n  return;\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/pci/pcivar.h>\t/* XXX */",
      "#include <dev/cardbus/cardbus_exrom.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *\ncardbus_intr_establish(cc, cf, irq, level, func, arg)\n     cardbus_chipset_tag_t cc;",
      "cardbus_function_tag_t cf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "cc",
            "handler"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"- pccard_intr_disestablish\\n\")"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\ncardbus_intr_establish(cc, cf, irq, level, func, arg)\n     cardbus_chipset_tag_t cc;\ncardbus_function_tag_t cf;\n\nvoid\ncardbus_intr_disestablish(cc, cf, handler)\n     cardbus_chipset_tag_t cc;\n     cardbus_function_tag_t cf;\n     void *handler;\n{\n  DPRINTF((\"- pccard_intr_disestablish\\n\"));\n\n (*cf->cardbus_intr_disestablish)(cc, handler);\n  return;\n}"
  },
  {
    "function_name": "cardbus_detach_card",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
    "lines": "610-638",
    "snippet": "void\ncardbus_detach_card(sc)\n     struct cardbus_softc *sc;\n{\n    struct cardbus_devfunc *ct, *ct_next, **prev_next;\n\n    prev_next = &(sc->sc_funcs->ct_next);\n\n    for (ct = sc->sc_funcs; ct != NULL; ct = ct_next) {\n\tstruct device *fndev = ct->ct_device;\n\tct_next = ct->ct_next;\n\n\tDPRINTF((\"%s: detaching %s\\n\", sc->sc_dev.dv_xname, fndev->dv_xname));\n\t/* call device detach function */\n\n\tif (0 != config_detach(fndev, 0)) {\n\t    printf(\"%s: cannot detaching dev %s, function %d\\n\",\n\t\t   sc->sc_dev.dv_xname, fndev->dv_xname, ct->ct_func);\n\t    prev_next = &(ct->ct_next);\n\t} else {\n\t    sc->sc_poweron_func &= ~(1 << ct->ct_func);\n\t    *prev_next = ct->ct_next;\n\t    free(ct, M_DEVBUF);\n\t}\n    }\n\n    sc->sc_poweron_func = 0;\n    sc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/pci/pcivar.h>\t/* XXX */",
      "#include <dev/cardbus/cardbus_exrom.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cardbusattach __P((struct device *, struct device *, void *));",
      "cardbusmatch __P((struct device *, void *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->sc_cf->cardbus_power",
          "args": [
            "sc->sc_cc",
            "CARDBUS_VCC_0V | CARDBUS_VPP_0V"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ct",
            "M_DEVBUF"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "rbus_space_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/rbus.c",
          "lines": "179-207",
          "snippet": "int\nrbus_space_free(rbt, bsh, size, addrp)\n     rbus_tag_t rbt;\n     bus_space_handle_t bsh;\n     bus_size_t size;\n     bus_addr_t *addrp;\n{\n  int exflags = EX_FAST | EX_NOWAIT;\n  bus_addr_t addr;\n  int status = 1;\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    md_space_unmap(rbt->rb_bt, bsh, size, &addr);\n\n    extent_free(rbt->rb_ext, addr, size, exflags);\n\n    status = 0;\n  } else {\n    /* error. INVALID rbustag */\n    status = 1;\n  }\n  if (addrp != NULL) {\n    *addrp = addr;\n  }\n  return status;\n}",
          "includes": [
            "#include <dev/cardbus/rbus.h>",
            "#include <machine/bus.h>",
            "#include <sys/extent.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/cardbus/rbus.h>\n#include <machine/bus.h>\n#include <sys/extent.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\nrbus_space_free(rbt, bsh, size, addrp)\n     rbus_tag_t rbt;\n     bus_space_handle_t bsh;\n     bus_size_t size;\n     bus_addr_t *addrp;\n{\n  int exflags = EX_FAST | EX_NOWAIT;\n  bus_addr_t addr;\n  int status = 1;\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    md_space_unmap(rbt->rb_bt, bsh, size, &addr);\n\n    extent_free(rbt->rb_ext, addr, size, exflags);\n\n    status = 0;\n  } else {\n    /* error. INVALID rbustag */\n    status = 1;\n  }\n  if (addrp != NULL) {\n    *addrp = addr;\n  }\n  return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: cannot detaching dev %s, function %d\\n\"",
            "sc->sc_dev.dv_xname",
            "fndev->dv_xname",
            "ct->ct_func"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_detach",
          "args": [
            "fndev",
            "0"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: detaching %s\\n\", sc->sc_dev.dv_xname, fndev->dv_xname)"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncardbusattach __P((struct device *, struct device *, void *));\ncardbusmatch __P((struct device *, void *, void *));\n\nvoid\ncardbus_detach_card(sc)\n     struct cardbus_softc *sc;\n{\n    struct cardbus_devfunc *ct, *ct_next, **prev_next;\n\n    prev_next = &(sc->sc_funcs->ct_next);\n\n    for (ct = sc->sc_funcs; ct != NULL; ct = ct_next) {\n\tstruct device *fndev = ct->ct_device;\n\tct_next = ct->ct_next;\n\n\tDPRINTF((\"%s: detaching %s\\n\", sc->sc_dev.dv_xname, fndev->dv_xname));\n\t/* call device detach function */\n\n\tif (0 != config_detach(fndev, 0)) {\n\t    printf(\"%s: cannot detaching dev %s, function %d\\n\",\n\t\t   sc->sc_dev.dv_xname, fndev->dv_xname, ct->ct_func);\n\t    prev_next = &(ct->ct_next);\n\t} else {\n\t    sc->sc_poweron_func &= ~(1 << ct->ct_func);\n\t    *prev_next = ct->ct_next;\n\t    free(ct, M_DEVBUF);\n\t}\n    }\n\n    sc->sc_poweron_func = 0;\n    sc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);\n}"
  },
  {
    "function_name": "cardbusprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
    "lines": "569-595",
    "snippet": "static int\ncardbusprint(aux, pnp)\n     void *aux;\n     const char *pnp;\n{\n    struct cardbus_attach_args *ca = aux;\n    char devinfo[256];\n    int i;\n    if (pnp) {\n\tpci_devinfo(ca->ca_id, ca->ca_class, 1, devinfo);\n\tfor (i = 0; i < 4; i++) {\n\t    if (ca->ca_cis.cis1_info[i] == NULL)\n\t\tbreak;\n\t    if (i)\n\t\tprintf(\", \");\n\t    printf(\"%s\", ca->ca_cis.cis1_info[i]);\n\t}\n\tif (i)\n\t    printf(\" \");\n\tprintf(\"(manufacturer 0x%x, product 0x%x)\", ca->ca_cis.manufacturer,\n\t       ca->ca_cis.product);\n\tprintf(\" %s at %s\", devinfo, pnp);\n    }\n    printf(\" dev %d function %d\", ca->ca_device, ca->ca_function);\n\n    return UNCONF;\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/pci/pcivar.h>\t/* XXX */",
      "#include <dev/cardbus/cardbus_exrom.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cardbusprint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" dev %d function %d\"",
            "ca->ca_device",
            "ca->ca_function"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_devinfo",
          "args": [
            "ca->ca_id",
            "ca->ca_class",
            "1",
            "devinfo"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "pci_devinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_subr.c",
          "lines": "215-306",
          "snippet": "void\npci_devinfo(id_reg, class_reg, showclass, cp)\n\tpcireg_t id_reg, class_reg;\n\tint showclass;\n\tchar *cp;\n{\n\tpci_vendor_id_t vendor;\n\tpci_product_id_t product;\n\tpci_class_t class;\n\tpci_subclass_t subclass;\n\tpci_interface_t interface;\n\tpci_revision_t revision;\n\tchar *vendor_namep, *product_namep;\n\tstruct pci_class *classp, *subclassp;\n#ifdef PCIVERBOSE\n\tstruct pci_knowndev *kdp;\n\tconst char *unmatched = \"unknown \";\n#else\n\tconst char *unmatched = \"\";\n#endif\n\n\tvendor = PCI_VENDOR(id_reg);\n\tproduct = PCI_PRODUCT(id_reg);\n\n\tclass = PCI_CLASS(class_reg);\n\tsubclass = PCI_SUBCLASS(class_reg);\n\tinterface = PCI_INTERFACE(class_reg);\n\trevision = PCI_REVISION(class_reg);\n\n#ifdef PCIVERBOSE\n\tkdp = pci_knowndevs;\n        while (kdp->vendorname != NULL) {\t/* all have vendor name */\n                if (kdp->vendor == vendor && (kdp->product == product ||\n\t\t    (kdp->flags & PCI_KNOWNDEV_NOPROD) != 0))\n                        break;\n\t\tkdp++;\n\t}\n        if (kdp->vendorname == NULL)\n\t\tvendor_namep = product_namep = NULL;\n\telse {\n\t\tvendor_namep = kdp->vendorname;\n\t\tproduct_namep = (kdp->flags & PCI_KNOWNDEV_NOPROD) == 0 ?\n\t\t    kdp->productname : NULL;\n        }\n#else /* PCIVERBOSE */\n\tvendor_namep = product_namep = NULL;\n#endif /* PCIVERBOSE */\n\n\tclassp = pci_class;\n\twhile (classp->name != NULL) {\n\t\tif (class == classp->val)\n\t\t\tbreak;\n\t\tclassp++;\n\t}\n\n\tsubclassp = (classp->name != NULL) ? classp->subclasses : NULL;\n\twhile (subclassp && subclassp->name != NULL) {\n\t\tif (subclass == subclassp->val)\n\t\t\tbreak;\n\t\tsubclassp++;\n\t}\n\n\tif (vendor_namep == NULL)\n\t\tcp += sprintf(cp, \"%svendor 0x%04x product 0x%04x\",\n\t\t    unmatched, vendor, product);\n\telse if (product_namep != NULL)\n\t\tcp += sprintf(cp, \"\\\"%s %s\\\"\", vendor_namep, product_namep);\n\telse\n\t\tcp += sprintf(cp, \"vendor \\\"%s\\\", unknown product 0x%x\",\n\t\t    vendor_namep, product);\n\tif (showclass && product_namep == NULL) {\n\t\tcp += sprintf(cp, \" (\");\n\t\tif (classp->name == NULL)\n\t\t\tcp += sprintf(cp,\n\t\t\t    \"unknown class 0x%2x, subclass 0x%02x\",\n\t\t\t    class, subclass);\n\t\telse {\n\t\t\tcp += sprintf(cp, \"class %s, \", classp->name);\n\t\t\tif (subclassp == NULL || subclassp->name == NULL)\n\t\t\t\tcp += sprintf(cp, \"unknown subclass 0x%02x\",\n\t\t\t\t    subclass);\n\t\t\telse\n\t\t\t\tcp += sprintf(cp, \"subclass %s\",\n\t\t\t\t    subclassp->name);\n\t\t}\n#if 0 /* not very useful */\n\t\tcp += sprintf(cp, \", interface 0x%02x\", interface);\n#endif\n\t\tcp += sprintf(cp, \", rev 0x%02x)\", revision);\n\t} else\n\t\tcp += sprintf(cp, \" rev 0x%02x\", revision);\n}",
          "includes": [
            "#include <dev/pci/pcidevs_data.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tPCI_KNOWNDEV_NOPROD\t0x01\t\t/* match on vendor only */"
          ],
          "globals_used": [
            "struct pci_class pci_class[] = {\n\t{ \"prehistoric\",\tPCI_CLASS_PREHISTORIC,\n\t    pci_subclass_prehistoric,\t\t\t\t},\n\t{ \"mass storage\",\tPCI_CLASS_MASS_STORAGE,\n\t    pci_subclass_mass_storage,\t\t\t\t},\n\t{ \"network\",\t\tPCI_CLASS_NETWORK,\n\t    pci_subclass_network,\t\t\t\t},\n\t{ \"display\",\t\tPCI_CLASS_DISPLAY,\n\t    pci_subclass_display,\t\t\t\t},\n\t{ \"multimedia\",\t\tPCI_CLASS_MULTIMEDIA,\n\t    pci_subclass_multimedia,\t\t\t\t},\n\t{ \"memory\",\t\tPCI_CLASS_MEMORY,\n\t    pci_subclass_memory,\t\t\t\t},\n\t{ \"bridge\",\t\tPCI_CLASS_BRIDGE,\n\t    pci_subclass_bridge,\t\t\t\t},\n\t{ \"communications\",\tPCI_CLASS_COMMUNICATIONS,\n\t    pci_subclass_communications,\t\t\t},\n\t{ \"system\",\t\tPCI_CLASS_SYSTEM,\n\t    pci_subclass_system,\t\t\t\t},\n\t{ \"input\",\t\tPCI_CLASS_INPUT,\n\t    pci_subclass_input,\t\t\t\t\t},\n\t{ \"dock\",\t\tPCI_CLASS_DOCK,\n\t    pci_subclass_dock,\t\t\t\t\t},\n\t{ \"processor\",\t\tPCI_CLASS_PROCESSOR,\n\t    pci_subclass_processor,\t\t\t\t},\n\t{ \"serial bus\",\t\tPCI_CLASS_SERIALBUS,\n\t    pci_subclass_serialbus,\t\t\t\t},\n\t{ \"undefined\",\t\tPCI_CLASS_UNDEFINED,\n\t    0,\t\t\t\t\t\t\t},\n\t{ 0 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs_data.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tPCI_KNOWNDEV_NOPROD\t0x01\t\t/* match on vendor only */\n\nstruct pci_class pci_class[] = {\n\t{ \"prehistoric\",\tPCI_CLASS_PREHISTORIC,\n\t    pci_subclass_prehistoric,\t\t\t\t},\n\t{ \"mass storage\",\tPCI_CLASS_MASS_STORAGE,\n\t    pci_subclass_mass_storage,\t\t\t\t},\n\t{ \"network\",\t\tPCI_CLASS_NETWORK,\n\t    pci_subclass_network,\t\t\t\t},\n\t{ \"display\",\t\tPCI_CLASS_DISPLAY,\n\t    pci_subclass_display,\t\t\t\t},\n\t{ \"multimedia\",\t\tPCI_CLASS_MULTIMEDIA,\n\t    pci_subclass_multimedia,\t\t\t\t},\n\t{ \"memory\",\t\tPCI_CLASS_MEMORY,\n\t    pci_subclass_memory,\t\t\t\t},\n\t{ \"bridge\",\t\tPCI_CLASS_BRIDGE,\n\t    pci_subclass_bridge,\t\t\t\t},\n\t{ \"communications\",\tPCI_CLASS_COMMUNICATIONS,\n\t    pci_subclass_communications,\t\t\t},\n\t{ \"system\",\t\tPCI_CLASS_SYSTEM,\n\t    pci_subclass_system,\t\t\t\t},\n\t{ \"input\",\t\tPCI_CLASS_INPUT,\n\t    pci_subclass_input,\t\t\t\t\t},\n\t{ \"dock\",\t\tPCI_CLASS_DOCK,\n\t    pci_subclass_dock,\t\t\t\t\t},\n\t{ \"processor\",\t\tPCI_CLASS_PROCESSOR,\n\t    pci_subclass_processor,\t\t\t\t},\n\t{ \"serial bus\",\t\tPCI_CLASS_SERIALBUS,\n\t    pci_subclass_serialbus,\t\t\t\t},\n\t{ \"undefined\",\t\tPCI_CLASS_UNDEFINED,\n\t    0,\t\t\t\t\t\t\t},\n\t{ 0 },\n};\n\nvoid\npci_devinfo(id_reg, class_reg, showclass, cp)\n\tpcireg_t id_reg, class_reg;\n\tint showclass;\n\tchar *cp;\n{\n\tpci_vendor_id_t vendor;\n\tpci_product_id_t product;\n\tpci_class_t class;\n\tpci_subclass_t subclass;\n\tpci_interface_t interface;\n\tpci_revision_t revision;\n\tchar *vendor_namep, *product_namep;\n\tstruct pci_class *classp, *subclassp;\n#ifdef PCIVERBOSE\n\tstruct pci_knowndev *kdp;\n\tconst char *unmatched = \"unknown \";\n#else\n\tconst char *unmatched = \"\";\n#endif\n\n\tvendor = PCI_VENDOR(id_reg);\n\tproduct = PCI_PRODUCT(id_reg);\n\n\tclass = PCI_CLASS(class_reg);\n\tsubclass = PCI_SUBCLASS(class_reg);\n\tinterface = PCI_INTERFACE(class_reg);\n\trevision = PCI_REVISION(class_reg);\n\n#ifdef PCIVERBOSE\n\tkdp = pci_knowndevs;\n        while (kdp->vendorname != NULL) {\t/* all have vendor name */\n                if (kdp->vendor == vendor && (kdp->product == product ||\n\t\t    (kdp->flags & PCI_KNOWNDEV_NOPROD) != 0))\n                        break;\n\t\tkdp++;\n\t}\n        if (kdp->vendorname == NULL)\n\t\tvendor_namep = product_namep = NULL;\n\telse {\n\t\tvendor_namep = kdp->vendorname;\n\t\tproduct_namep = (kdp->flags & PCI_KNOWNDEV_NOPROD) == 0 ?\n\t\t    kdp->productname : NULL;\n        }\n#else /* PCIVERBOSE */\n\tvendor_namep = product_namep = NULL;\n#endif /* PCIVERBOSE */\n\n\tclassp = pci_class;\n\twhile (classp->name != NULL) {\n\t\tif (class == classp->val)\n\t\t\tbreak;\n\t\tclassp++;\n\t}\n\n\tsubclassp = (classp->name != NULL) ? classp->subclasses : NULL;\n\twhile (subclassp && subclassp->name != NULL) {\n\t\tif (subclass == subclassp->val)\n\t\t\tbreak;\n\t\tsubclassp++;\n\t}\n\n\tif (vendor_namep == NULL)\n\t\tcp += sprintf(cp, \"%svendor 0x%04x product 0x%04x\",\n\t\t    unmatched, vendor, product);\n\telse if (product_namep != NULL)\n\t\tcp += sprintf(cp, \"\\\"%s %s\\\"\", vendor_namep, product_namep);\n\telse\n\t\tcp += sprintf(cp, \"vendor \\\"%s\\\", unknown product 0x%x\",\n\t\t    vendor_namep, product);\n\tif (showclass && product_namep == NULL) {\n\t\tcp += sprintf(cp, \" (\");\n\t\tif (classp->name == NULL)\n\t\t\tcp += sprintf(cp,\n\t\t\t    \"unknown class 0x%2x, subclass 0x%02x\",\n\t\t\t    class, subclass);\n\t\telse {\n\t\t\tcp += sprintf(cp, \"class %s, \", classp->name);\n\t\t\tif (subclassp == NULL || subclassp->name == NULL)\n\t\t\t\tcp += sprintf(cp, \"unknown subclass 0x%02x\",\n\t\t\t\t    subclass);\n\t\t\telse\n\t\t\t\tcp += sprintf(cp, \"subclass %s\",\n\t\t\t\t    subclassp->name);\n\t\t}\n#if 0 /* not very useful */\n\t\tcp += sprintf(cp, \", interface 0x%02x\", interface);\n#endif\n\t\tcp += sprintf(cp, \", rev 0x%02x)\", revision);\n\t} else\n\t\tcp += sprintf(cp, \" rev 0x%02x\", revision);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int cardbusprint;\n\nstatic int\ncardbusprint(aux, pnp)\n     void *aux;\n     const char *pnp;\n{\n    struct cardbus_attach_args *ca = aux;\n    char devinfo[256];\n    int i;\n    if (pnp) {\n\tpci_devinfo(ca->ca_id, ca->ca_class, 1, devinfo);\n\tfor (i = 0; i < 4; i++) {\n\t    if (ca->ca_cis.cis1_info[i] == NULL)\n\t\tbreak;\n\t    if (i)\n\t\tprintf(\", \");\n\t    printf(\"%s\", ca->ca_cis.cis1_info[i]);\n\t}\n\tif (i)\n\t    printf(\" \");\n\tprintf(\"(manufacturer 0x%x, product 0x%x)\", ca->ca_cis.manufacturer,\n\t       ca->ca_cis.product);\n\tprintf(\" %s at %s\", devinfo, pnp);\n    }\n    printf(\" dev %d function %d\", ca->ca_device, ca->ca_function);\n\n    return UNCONF;\n}"
  },
  {
    "function_name": "cardbussubmatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
    "lines": "546-565",
    "snippet": "static int\ncardbussubmatch(parent, match, aux)\n     struct device *parent;\n     void *match;\n     void *aux;\n{\n  struct cfdata *cf = match;\n  struct cardbus_attach_args *ca = aux;\n\n  if (cf->cardbuscf_dev != CARDBUS_UNK_DEV &&\n      cf->cardbuscf_dev != ca->ca_unit) {\n    return 0;\n  }\n  if (cf->cardbuscf_function != CARDBUS_UNK_FUNCTION &&\n      cf->cardbuscf_function != ca->ca_function) {\n    return 0;\n  }\n\n  return ((*cf->cf_attach->ca_match)(parent, cf, aux));\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/pci/pcivar.h>\t/* XXX */",
      "#include <dev/cardbus/cardbus_exrom.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cardbusattach __P((struct device *, struct device *, void *));",
      "cardbusmatch __P((struct device *, void *, void *));",
      "static int cardbussubmatch",
      "cardbus_function_tag_t cf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "parent",
            "cf",
            "aux"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncardbusattach __P((struct device *, struct device *, void *));\ncardbusmatch __P((struct device *, void *, void *));\nstatic int cardbussubmatch;\ncardbus_function_tag_t cf;\n\nstatic int\ncardbussubmatch(parent, match, aux)\n     struct device *parent;\n     void *match;\n     void *aux;\n{\n  struct cfdata *cf = match;\n  struct cardbus_attach_args *ca = aux;\n\n  if (cf->cardbuscf_dev != CARDBUS_UNK_DEV &&\n      cf->cardbuscf_dev != ca->ca_unit) {\n    return 0;\n  }\n  if (cf->cardbuscf_function != CARDBUS_UNK_FUNCTION &&\n      cf->cardbuscf_function != ca->ca_function) {\n    return 0;\n  }\n\n  return ((*cf->cf_attach->ca_match)(parent, cf, aux));\n}"
  },
  {
    "function_name": "cardbus_attach_card",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
    "lines": "382-543",
    "snippet": "int\ncardbus_attach_card(sc)\n     struct cardbus_softc *sc;\n{\n  cardbus_chipset_tag_t cc;\n  cardbus_function_tag_t cf;\n  int cdstatus;\n  cardbustag_t tag;\n  cardbusreg_t id, class, cis_ptr;\n  cardbusreg_t bhlc;\n  u_int8_t tuple[2048];\n  int function, nfunction;\n  struct cardbus_devfunc **previous_next = &(sc->sc_funcs);\n  struct device *csc;\n  int no_work_funcs = 0;\n  cardbus_devfunc_t ct;\n\n  cc = sc->sc_cc;\n  cf = sc->sc_cf;\n\n  DPRINTF((\"cardbus_attach_card: cb%d start\\n\", sc->sc_dev.dv_unit));\n\n  /* inspect initial voltage */\n  if (0 == (cdstatus = (cf->cardbus_ctrl)(cc, CARDBUS_CD))) {\n    DPRINTF((\"cardbusattach: no CardBus card on cb%d\\n\", sc->sc_dev.dv_unit));\n    return 0;\n  }\n\n  enable_function(sc, cdstatus, 8); /* XXX use fake function 8 to\n\t\t\t\t       keep power on during whole\n\t\t\t\t       configuration */\n\n  function = 0;\n\n  tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, function);\n\n  /*\n   * Wait until power comes up.  Maxmum 500 ms.\n   */\n  {\n    int i;\n    for (i = 0; i < 5; ++i) {\n      id = cardbus_conf_read(cc, cf, tag, CARDBUS_ID_REG);\n      if (id != 0xffffffff && id != 0) {\n\tbreak;\n      }\n      if (cold) {\t\t/* before kernel thread invoked */\n\tdelay(100*1000);\n      } else {\t\t\t/* thread context */\n\tif (tsleep((void *)sc, PCATCH, \"cardbus\", hz/10) != EWOULDBLOCK) {\n\t  break;\n\t}\n      }\n    }\n    if (i == 5) {\n      return 0;\n    }\n  }\n  \n  bhlc = cardbus_conf_read(cc, cf, tag, CARDBUS_BHLC_REG);\n  if (CARDBUS_LATTIMER(bhlc) < 0x10) {\n    bhlc &= ~(CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT);\n    bhlc |= (0x10 << CARDBUS_LATTIMER_SHIFT);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BHLC_REG, bhlc);\n  }\n\n  nfunction = CARDBUS_HDRTYPE_MULTIFN(bhlc) ? 8 : 1;\n\n  for(function = 0; function < nfunction; function++) {\n    struct cardbus_attach_args ca;\n\n    tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, function);\n  \n    id = cardbus_conf_read(cc, cf, tag, CARDBUS_ID_REG);\n    class = cardbus_conf_read(cc, cf, tag, CARDBUS_CLASS_REG);\n    cis_ptr = cardbus_conf_read(cc, cf, tag, CARDBUS_CIS_REG);\n  \n    /* Invalid vendor ID value? */\n    if (CARDBUS_VENDOR(id) == CARDBUS_VENDOR_INVALID) {\n      continue;\n    }\n      \n    DPRINTF((\"cardbus_attach_card: Vendor 0x%x, Product 0x%x, CIS 0x%x\\n\",\n\t     CARDBUS_VENDOR(id), CARDBUS_PRODUCT(id), cis_ptr));\n\n    enable_function(sc, cdstatus, function);\n\n    /* clean up every BAR */\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE0_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE1_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE2_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE3_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE4_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE5_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_ROM_REG, 0);\n    \n    /*\n     * We need to allocate the ct here, since we might \n     * need it when reading the CIS\n     */\n    if (NULL == (ct = (cardbus_devfunc_t)malloc(sizeof(struct cardbus_devfunc),\n\t\t\t\t\t\tM_DEVBUF, M_NOWAIT))) {\n      panic(\"no room for cardbus_tag\");\n    }\n\n    ct->ct_cc = sc->sc_cc;\n    ct->ct_cf = sc->sc_cf;\n    ct->ct_bus = sc->sc_bus;\n    ct->ct_dev = sc->sc_device;\n    ct->ct_func = function;\n    ct->ct_sc = sc;\n    ct->ct_next = NULL;\n    *previous_next = ct;\n\n    memset(&ca, 0, sizeof(ca));\n\n    ca.ca_unit = sc->sc_dev.dv_unit;\n    ca.ca_ct = ct;\n\n    ca.ca_iot = sc->sc_iot;\n    ca.ca_memt = sc->sc_memt;\n    ca.ca_dmat = sc->sc_dmat;\n\n    ca.ca_tag = tag;\n    ca.ca_device = sc->sc_device;\n    ca.ca_function = function;\n    ca.ca_id = id;\n    ca.ca_class = class;\n\n    ca.ca_intrline = sc->sc_intrline;\n\n    bzero(tuple, 2048);\n\n    if(cardbus_read_tuples(&ca, cis_ptr, tuple, sizeof(tuple))) {\n      printf(\"cardbus_attach_card: failed to read CIS\\n\");\n    } else {\n#ifdef CARDBUS_DEBUG\n      decode_tuples(tuple, 2048, print_tuple, NULL);\n#endif\n      decode_tuples(tuple, 2048, parse_tuple, &ca.ca_cis);\n    }\n\n    if (NULL == (csc = config_found_sm((void *)sc, &ca, cardbusprint, cardbussubmatch))) {\n      /* do not match */\n      disable_function(sc, function);\n      free(ct, M_DEVBUF);\n      *previous_next = NULL;\n    } else {\n      /* found */\n      previous_next = &(ct->ct_next);\n      ct->ct_device = csc;\n      ++no_work_funcs;\n    }\n  }\n  /*\n   * XXX power down pseudo function 8 (this will power down the card\n   * if no functions were attached).\n   */\n  disable_function(sc, 8);\n\n  return no_work_funcs;\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/pci/pcivar.h>\t/* XXX */",
      "#include <dev/cardbus/cardbus_exrom.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern int cold;",
      "cardbusattach __P((struct device *, struct device *, void *));",
      "int cardbus_attach_card",
      "cardbusmatch __P((struct device *, void *, void *));",
      "static int cardbussubmatch",
      "static int cardbusprint",
      "static int decode_tuples",
      "static int cardbus_read_tuples",
      "static void enable_function",
      "static void disable_function",
      "void *\ncardbus_intr_establish(cc, cf, irq, level, func, arg)\n     cardbus_chipset_tag_t cc;",
      "cardbus_function_tag_t cf;",
      "static u_int8_t *\ndecode_tuple(tuple, func, data)\n     u_int8_t *tuple;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_function",
          "args": [
            "sc",
            "8"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "disable_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
          "lines": "709-720",
          "snippet": "static void\ndisable_function(sc, function)\n     struct cardbus_softc *sc; \n     int function;\n{\n\n    sc->sc_poweron_func &= ~(1 << function);\n    if (sc->sc_poweron_func == 0) {\n\t/* power-off because no functions are enabled */\n\tsc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_0V);\n    }\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pci/pcireg.h>\t/* XXX */",
            "#include <dev/pci/pcivar.h>\t/* XXX */",
            "#include <dev/cardbus/cardbus_exrom.h>",
            "#include <dev/cardbus/cardbusdevs.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void disable_function"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void disable_function;\n\nstatic void\ndisable_function(sc, function)\n     struct cardbus_softc *sc; \n     int function;\n{\n\n    sc->sc_poweron_func &= ~(1 << function);\n    if (sc->sc_poweron_func == 0) {\n\t/* power-off because no functions are enabled */\n\tsc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_0V);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ct",
            "M_DEVBUF"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "rbus_space_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/rbus.c",
          "lines": "179-207",
          "snippet": "int\nrbus_space_free(rbt, bsh, size, addrp)\n     rbus_tag_t rbt;\n     bus_space_handle_t bsh;\n     bus_size_t size;\n     bus_addr_t *addrp;\n{\n  int exflags = EX_FAST | EX_NOWAIT;\n  bus_addr_t addr;\n  int status = 1;\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    md_space_unmap(rbt->rb_bt, bsh, size, &addr);\n\n    extent_free(rbt->rb_ext, addr, size, exflags);\n\n    status = 0;\n  } else {\n    /* error. INVALID rbustag */\n    status = 1;\n  }\n  if (addrp != NULL) {\n    *addrp = addr;\n  }\n  return status;\n}",
          "includes": [
            "#include <dev/cardbus/rbus.h>",
            "#include <machine/bus.h>",
            "#include <sys/extent.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/cardbus/rbus.h>\n#include <machine/bus.h>\n#include <sys/extent.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\nrbus_space_free(rbt, bsh, size, addrp)\n     rbus_tag_t rbt;\n     bus_space_handle_t bsh;\n     bus_size_t size;\n     bus_addr_t *addrp;\n{\n  int exflags = EX_FAST | EX_NOWAIT;\n  bus_addr_t addr;\n  int status = 1;\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    md_space_unmap(rbt->rb_bt, bsh, size, &addr);\n\n    extent_free(rbt->rb_ext, addr, size, exflags);\n\n    status = 0;\n  } else {\n    /* error. INVALID rbustag */\n    status = 1;\n  }\n  if (addrp != NULL) {\n    *addrp = addr;\n  }\n  return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_found_sm",
          "args": [
            "(void *)sc",
            "&ca",
            "cardbusprint",
            "cardbussubmatch"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_tuples",
          "args": [
            "tuple",
            "2048",
            "parse_tuple",
            "&ca.ca_cis"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "decode_tuples",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
          "lines": "834-855",
          "snippet": "static int\ndecode_tuples(tuple, buflen, func, data)\n     u_int8_t *tuple;\n     int buflen;\n     tuple_decode_func func;\n     void *data;\n{\n  u_int8_t *tp = tuple;\n\n  if (PCMCIA_CISTPL_LINKTARGET != *tuple) {\n    DPRINTF((\"WRONG TUPLE: 0x%x\\n\", *tuple));\n    return 0;\n  }\n\n  while (NULL != (tp = decode_tuple(tp, func, data))) {\n    if (tuple + buflen < tp) {\n      break;\n    }\n  }\n  \n  return 1;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pci/pcireg.h>\t/* XXX */",
            "#include <dev/pci/pcivar.h>\t/* XXX */",
            "#include <dev/cardbus/cardbus_exrom.h>",
            "#include <dev/cardbus/cardbusdevs.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int decode_tuples",
            "int (*func)",
            "static u_int8_t *\ndecode_tuple",
            "static u_int8_t *\ndecode_tuple(tuple, func, data)\n     u_int8_t *tuple;",
            "tuple_decode_func func;",
            "void *data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int decode_tuples;\nint (*func);\nstatic u_int8_t *\ndecode_tuple;\nstatic u_int8_t *\ndecode_tuple(tuple, func, data)\n     u_int8_t *tuple;\ntuple_decode_func func;\nvoid *data;\n\nstatic int\ndecode_tuples(tuple, buflen, func, data)\n     u_int8_t *tuple;\n     int buflen;\n     tuple_decode_func func;\n     void *data;\n{\n  u_int8_t *tp = tuple;\n\n  if (PCMCIA_CISTPL_LINKTARGET != *tuple) {\n    DPRINTF((\"WRONG TUPLE: 0x%x\\n\", *tuple));\n    return 0;\n  }\n\n  while (NULL != (tp = decode_tuple(tp, func, data))) {\n    if (tuple + buflen < tp) {\n      break;\n    }\n  }\n  \n  return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cardbus_attach_card: failed to read CIS\\n\""
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cardbus_read_tuples",
          "args": [
            "&ca",
            "cis_ptr",
            "tuple",
            "sizeof(tuple)"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "cardbus_read_tuples",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
          "lines": "155-292",
          "snippet": "static int\ncardbus_read_tuples(ca, cis_ptr, tuples, len)\n     struct cardbus_attach_args *ca;\n     cardbusreg_t cis_ptr;\n     u_int8_t *tuples;\n     size_t len;\n{\n    struct cardbus_softc *sc = ca->ca_ct->ct_sc;\n    cardbus_chipset_tag_t cc = ca->ca_ct->ct_cc;\n    cardbus_function_tag_t cf = ca->ca_ct->ct_cf;\n    cardbustag_t tag = ca->ca_tag;\n    cardbusreg_t command;\n    int found = 0;\n\n    int i, j;\n    int cardbus_space = cis_ptr & CARDBUS_CIS_ASIMASK;\n    bus_space_handle_t bar_memh;\n    bus_size_t bar_size;\n    bus_addr_t bar_addr;\n    \n    int reg;\n      \n    memset(tuples, 0, len);\n\n    cis_ptr = cis_ptr & CARDBUS_CIS_ADDRMASK;\n\n    switch(cardbus_space) {\n    case CARDBUS_CIS_ASI_TUPLE:\n\tDPRINTF((\"%s: reading CIS data from configuration space\\n\", \n\t\t sc->sc_dev.dv_xname));\n\tfor (i = cis_ptr, j = 0; i < 0xff; i += 4) {\n\t    u_int32_t e = (cf->cardbus_conf_read)(cc, tag, i);\n\t    tuples[j] = 0xff & e;\n\t    e >>= 8;\n\t    tuples[j + 1] = 0xff & e;\n\t    e >>= 8;\n\t    tuples[j + 2] = 0xff & e;\n\t    e >>= 8;\n\t    tuples[j + 3] = 0xff & e;\n\t    j += 4;\n\t}\n\tfound++;\n\tbreak;\n\n    case CARDBUS_CIS_ASI_BAR0:\n    case CARDBUS_CIS_ASI_BAR1:\n    case CARDBUS_CIS_ASI_BAR2:\n    case CARDBUS_CIS_ASI_BAR3:\n    case CARDBUS_CIS_ASI_BAR4:\n    case CARDBUS_CIS_ASI_BAR5:\n    case CARDBUS_CIS_ASI_ROM:\n\tif(cardbus_space == CARDBUS_CIS_ASI_ROM) {\n\t    reg = CARDBUS_ROM_REG;\n\t    DPRINTF((\"%s: reading CIS data from ROM\\n\",\n\t\t     sc->sc_dev.dv_xname));\n\t} else {\n\t    reg = CARDBUS_BASE0_REG + (cardbus_space - 1) * 4;\n\t    DPRINTF((\"%s: reading CIS data from BAR%d\\n\",\n\t\t     sc->sc_dev.dv_xname, cardbus_space - 1));\n\t}\n\n\t/* XXX zero register so mapreg_map doesn't get confused by old\n           contents */\n\tcardbus_conf_write(cc, cf, tag, reg, 0);\n\tif(Cardbus_mapreg_map(ca->ca_ct, reg,\n\t\t\t      CARDBUS_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT,\n\t\t\t      0, \n\t\t\t      NULL, &bar_memh, &bar_addr, &bar_size)) {\n\t    printf(\"%s: failed to map memory\\n\", sc->sc_dev.dv_xname);\n\t    return 1;\n\t}\n\n\n\tif(cardbus_space == CARDBUS_CIS_ASI_ROM) {\n\t    cardbusreg_t exrom;\n\t    int save;\n\t    struct cardbus_rom_image_head rom_image;\n\t    struct cardbus_rom_image *p;\n\t\t    \n\t    save = splhigh();\n\t    /* enable rom address decoder */\n\t    exrom = cardbus_conf_read(cc, cf, tag, reg);\n\t    cardbus_conf_write(cc, cf, tag, reg, exrom | 1);\n\t    \n\t    command = cardbus_conf_read(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG);\n\t    cardbus_conf_write(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG, \n\t\t\t       command | CARDBUS_COMMAND_MEM_ENABLE);\n\n\t    if(cardbus_read_exrom(ca->ca_memt, bar_memh, &rom_image))\n\t\tgoto out;\n\n\t    for(p = SIMPLEQ_FIRST(&rom_image);\n\t\tp;\n\t\tp = SIMPLEQ_NEXT(p, next)) {\n\t\tif(p->rom_image == CARDBUS_CIS_ASI_ROM_IMAGE(cis_ptr)) {\n\t\t    bus_space_read_region_1(p->romt, p->romh,\n\t\t\t\t\t    CARDBUS_CIS_ADDR(cis_ptr),\n\t\t\t\t\t    tuples, 256);\n\t\t    found++;\n\t\t}\n\t\tbreak;\n\t    }\n\t    while((p = SIMPLEQ_FIRST(&rom_image)) != NULL) {\n\t\tSIMPLEQ_REMOVE_HEAD(&rom_image, p, next);\n\t\tfree(p, M_DEVBUF);\n\t    }\n\tout:\n\t    exrom = cardbus_conf_read(cc, cf, tag, reg);\n\t    cardbus_conf_write(cc, cf, tag, reg, exrom & ~1);\n\t    splx(save);\n\t} else {\n\t    command = cardbus_conf_read(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG);\n\t    cardbus_conf_write(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG, \n\t\t\t       command | CARDBUS_COMMAND_MEM_ENABLE);\n\t    /* XXX byte order? */\n\t    bus_space_read_region_1(ca->ca_memt, bar_memh, \n\t\t\t\t    cis_ptr, tuples, 256);\n\t    found++;\n\t}\n\tcommand = cardbus_conf_read(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG, \n\t\t\t   command & ~CARDBUS_COMMAND_MEM_ENABLE);\n\tcardbus_conf_write(cc, cf, tag, reg, 0);\n#if 0\n\t/* XXX unmap memory */\n\t(*ca->ca_ct->ct_cf->cardbus_space_free)(ca->ca_ct, \n\t\t\t\t\t\tca->ca_ct->ct_sc->sc_rbus_memt, \n\t\t\t\t\t\tbar_memh, bar_size);\n#endif\n\tbreak;\n\n#ifdef DIAGNOSTIC\n    default:\n\tpanic(\"%s: bad CIS space (%d)\", sc->sc_dev.dv_xname, cardbus_space);\n#endif\n    }\n    return !found;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pci/pcireg.h>\t/* XXX */",
            "#include <dev/pci/pcivar.h>\t/* XXX */",
            "#include <dev/cardbus/cardbus_exrom.h>",
            "#include <dev/cardbus/cardbusdevs.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cardbus_read_tuples",
            "void *\ncardbus_intr_establish(cc, cf, irq, level, func, arg)\n     cardbus_chipset_tag_t cc;",
            "cardbus_function_tag_t cf;",
            "void *data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int cardbus_read_tuples;\nvoid *\ncardbus_intr_establish(cc, cf, irq, level, func, arg)\n     cardbus_chipset_tag_t cc;\ncardbus_function_tag_t cf;\nvoid *data;\n\nstatic int\ncardbus_read_tuples(ca, cis_ptr, tuples, len)\n     struct cardbus_attach_args *ca;\n     cardbusreg_t cis_ptr;\n     u_int8_t *tuples;\n     size_t len;\n{\n    struct cardbus_softc *sc = ca->ca_ct->ct_sc;\n    cardbus_chipset_tag_t cc = ca->ca_ct->ct_cc;\n    cardbus_function_tag_t cf = ca->ca_ct->ct_cf;\n    cardbustag_t tag = ca->ca_tag;\n    cardbusreg_t command;\n    int found = 0;\n\n    int i, j;\n    int cardbus_space = cis_ptr & CARDBUS_CIS_ASIMASK;\n    bus_space_handle_t bar_memh;\n    bus_size_t bar_size;\n    bus_addr_t bar_addr;\n    \n    int reg;\n      \n    memset(tuples, 0, len);\n\n    cis_ptr = cis_ptr & CARDBUS_CIS_ADDRMASK;\n\n    switch(cardbus_space) {\n    case CARDBUS_CIS_ASI_TUPLE:\n\tDPRINTF((\"%s: reading CIS data from configuration space\\n\", \n\t\t sc->sc_dev.dv_xname));\n\tfor (i = cis_ptr, j = 0; i < 0xff; i += 4) {\n\t    u_int32_t e = (cf->cardbus_conf_read)(cc, tag, i);\n\t    tuples[j] = 0xff & e;\n\t    e >>= 8;\n\t    tuples[j + 1] = 0xff & e;\n\t    e >>= 8;\n\t    tuples[j + 2] = 0xff & e;\n\t    e >>= 8;\n\t    tuples[j + 3] = 0xff & e;\n\t    j += 4;\n\t}\n\tfound++;\n\tbreak;\n\n    case CARDBUS_CIS_ASI_BAR0:\n    case CARDBUS_CIS_ASI_BAR1:\n    case CARDBUS_CIS_ASI_BAR2:\n    case CARDBUS_CIS_ASI_BAR3:\n    case CARDBUS_CIS_ASI_BAR4:\n    case CARDBUS_CIS_ASI_BAR5:\n    case CARDBUS_CIS_ASI_ROM:\n\tif(cardbus_space == CARDBUS_CIS_ASI_ROM) {\n\t    reg = CARDBUS_ROM_REG;\n\t    DPRINTF((\"%s: reading CIS data from ROM\\n\",\n\t\t     sc->sc_dev.dv_xname));\n\t} else {\n\t    reg = CARDBUS_BASE0_REG + (cardbus_space - 1) * 4;\n\t    DPRINTF((\"%s: reading CIS data from BAR%d\\n\",\n\t\t     sc->sc_dev.dv_xname, cardbus_space - 1));\n\t}\n\n\t/* XXX zero register so mapreg_map doesn't get confused by old\n           contents */\n\tcardbus_conf_write(cc, cf, tag, reg, 0);\n\tif(Cardbus_mapreg_map(ca->ca_ct, reg,\n\t\t\t      CARDBUS_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT,\n\t\t\t      0, \n\t\t\t      NULL, &bar_memh, &bar_addr, &bar_size)) {\n\t    printf(\"%s: failed to map memory\\n\", sc->sc_dev.dv_xname);\n\t    return 1;\n\t}\n\n\n\tif(cardbus_space == CARDBUS_CIS_ASI_ROM) {\n\t    cardbusreg_t exrom;\n\t    int save;\n\t    struct cardbus_rom_image_head rom_image;\n\t    struct cardbus_rom_image *p;\n\t\t    \n\t    save = splhigh();\n\t    /* enable rom address decoder */\n\t    exrom = cardbus_conf_read(cc, cf, tag, reg);\n\t    cardbus_conf_write(cc, cf, tag, reg, exrom | 1);\n\t    \n\t    command = cardbus_conf_read(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG);\n\t    cardbus_conf_write(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG, \n\t\t\t       command | CARDBUS_COMMAND_MEM_ENABLE);\n\n\t    if(cardbus_read_exrom(ca->ca_memt, bar_memh, &rom_image))\n\t\tgoto out;\n\n\t    for(p = SIMPLEQ_FIRST(&rom_image);\n\t\tp;\n\t\tp = SIMPLEQ_NEXT(p, next)) {\n\t\tif(p->rom_image == CARDBUS_CIS_ASI_ROM_IMAGE(cis_ptr)) {\n\t\t    bus_space_read_region_1(p->romt, p->romh,\n\t\t\t\t\t    CARDBUS_CIS_ADDR(cis_ptr),\n\t\t\t\t\t    tuples, 256);\n\t\t    found++;\n\t\t}\n\t\tbreak;\n\t    }\n\t    while((p = SIMPLEQ_FIRST(&rom_image)) != NULL) {\n\t\tSIMPLEQ_REMOVE_HEAD(&rom_image, p, next);\n\t\tfree(p, M_DEVBUF);\n\t    }\n\tout:\n\t    exrom = cardbus_conf_read(cc, cf, tag, reg);\n\t    cardbus_conf_write(cc, cf, tag, reg, exrom & ~1);\n\t    splx(save);\n\t} else {\n\t    command = cardbus_conf_read(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG);\n\t    cardbus_conf_write(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG, \n\t\t\t       command | CARDBUS_COMMAND_MEM_ENABLE);\n\t    /* XXX byte order? */\n\t    bus_space_read_region_1(ca->ca_memt, bar_memh, \n\t\t\t\t    cis_ptr, tuples, 256);\n\t    found++;\n\t}\n\tcommand = cardbus_conf_read(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG, \n\t\t\t   command & ~CARDBUS_COMMAND_MEM_ENABLE);\n\tcardbus_conf_write(cc, cf, tag, reg, 0);\n#if 0\n\t/* XXX unmap memory */\n\t(*ca->ca_ct->ct_cf->cardbus_space_free)(ca->ca_ct, \n\t\t\t\t\t\tca->ca_ct->ct_sc->sc_rbus_memt, \n\t\t\t\t\t\tbar_memh, bar_size);\n#endif\n\tbreak;\n\n#ifdef DIAGNOSTIC\n    default:\n\tpanic(\"%s: bad CIS space (%d)\", sc->sc_dev.dv_xname, cardbus_space);\n#endif\n    }\n    return !found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "tuple",
            "2048"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ca",
            "0",
            "sizeof(ca)"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"no room for cardbus_tag\""
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct cardbus_devfunc)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_ROM_REG",
            "0"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_BASE5_REG",
            "0"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_BASE4_REG",
            "0"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_BASE3_REG",
            "0"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_BASE2_REG",
            "0"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_BASE1_REG",
            "0"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_BASE0_REG",
            "0"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enable_function",
          "args": [
            "sc",
            "cdstatus",
            "function"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "enable_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
          "lines": "689-707",
          "snippet": "static void\nenable_function(sc, cdstatus, function)\n     struct cardbus_softc *sc;\n     int cdstatus;\n     int function;\n{\n\n    if (sc->sc_poweron_func == 0) {\n\t/* switch to 3V and/or wait for power to stabilize */\n\tif (cdstatus & CARDBUS_3V_CARD) {\n\t    sc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_3V);\n\t} else {\n\t    /* No cards other than 3.3V cards. */\n\t    return;\n\t}\n\t(sc->sc_cf->cardbus_ctrl)(sc->sc_cc, CARDBUS_RESET);\n    }\n    sc->sc_poweron_func |= (1 << function);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pci/pcireg.h>\t/* XXX */",
            "#include <dev/pci/pcivar.h>\t/* XXX */",
            "#include <dev/cardbus/cardbus_exrom.h>",
            "#include <dev/cardbus/cardbusdevs.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void enable_function"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void enable_function;\n\nstatic void\nenable_function(sc, cdstatus, function)\n     struct cardbus_softc *sc;\n     int cdstatus;\n     int function;\n{\n\n    if (sc->sc_poweron_func == 0) {\n\t/* switch to 3V and/or wait for power to stabilize */\n\tif (cdstatus & CARDBUS_3V_CARD) {\n\t    sc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_3V);\n\t} else {\n\t    /* No cards other than 3.3V cards. */\n\t    return;\n\t}\n\t(sc->sc_cf->cardbus_ctrl)(sc->sc_cc, CARDBUS_RESET);\n    }\n    sc->sc_poweron_func |= (1 << function);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"cardbus_attach_card: Vendor 0x%x, Product 0x%x, CIS 0x%x\\n\",\n\t     CARDBUS_VENDOR(id), CARDBUS_PRODUCT(id), cis_ptr)"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDBUS_PRODUCT",
          "args": [
            "id"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDBUS_VENDOR",
          "args": [
            "id"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDBUS_VENDOR",
          "args": [
            "id"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_CIS_REG"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_CLASS_REG"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_ID_REG"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_make_tag",
          "args": [
            "cc",
            "cf",
            "sc->sc_bus",
            "sc->sc_device",
            "function"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDBUS_HDRTYPE_MULTIFN",
          "args": [
            "bhlc"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_BHLC_REG",
            "bhlc"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDBUS_LATTIMER",
          "args": [
            "bhlc"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_BHLC_REG"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "(void *)sc",
            "PCATCH",
            "\"cardbus\"",
            "hz/10"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100*1000"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_ID_REG"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_make_tag",
          "args": [
            "cc",
            "cf",
            "sc->sc_bus",
            "sc->sc_device",
            "function"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"cardbusattach: no CardBus card on cb%d\\n\", sc->sc_dev.dv_unit)"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cc",
            "CARDBUS_CD"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"cardbus_attach_card: cb%d start\\n\", sc->sc_dev.dv_unit)"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nextern int cold;\ncardbusattach __P((struct device *, struct device *, void *));\nint cardbus_attach_card;\ncardbusmatch __P((struct device *, void *, void *));\nstatic int cardbussubmatch;\nstatic int cardbusprint;\nstatic int decode_tuples;\nstatic int cardbus_read_tuples;\nstatic void enable_function;\nstatic void disable_function;\nvoid *\ncardbus_intr_establish(cc, cf, irq, level, func, arg)\n     cardbus_chipset_tag_t cc;\ncardbus_function_tag_t cf;\nstatic u_int8_t *\ndecode_tuple(tuple, func, data)\n     u_int8_t *tuple;\n\nint\ncardbus_attach_card(sc)\n     struct cardbus_softc *sc;\n{\n  cardbus_chipset_tag_t cc;\n  cardbus_function_tag_t cf;\n  int cdstatus;\n  cardbustag_t tag;\n  cardbusreg_t id, class, cis_ptr;\n  cardbusreg_t bhlc;\n  u_int8_t tuple[2048];\n  int function, nfunction;\n  struct cardbus_devfunc **previous_next = &(sc->sc_funcs);\n  struct device *csc;\n  int no_work_funcs = 0;\n  cardbus_devfunc_t ct;\n\n  cc = sc->sc_cc;\n  cf = sc->sc_cf;\n\n  DPRINTF((\"cardbus_attach_card: cb%d start\\n\", sc->sc_dev.dv_unit));\n\n  /* inspect initial voltage */\n  if (0 == (cdstatus = (cf->cardbus_ctrl)(cc, CARDBUS_CD))) {\n    DPRINTF((\"cardbusattach: no CardBus card on cb%d\\n\", sc->sc_dev.dv_unit));\n    return 0;\n  }\n\n  enable_function(sc, cdstatus, 8); /* XXX use fake function 8 to\n\t\t\t\t       keep power on during whole\n\t\t\t\t       configuration */\n\n  function = 0;\n\n  tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, function);\n\n  /*\n   * Wait until power comes up.  Maxmum 500 ms.\n   */\n  {\n    int i;\n    for (i = 0; i < 5; ++i) {\n      id = cardbus_conf_read(cc, cf, tag, CARDBUS_ID_REG);\n      if (id != 0xffffffff && id != 0) {\n\tbreak;\n      }\n      if (cold) {\t\t/* before kernel thread invoked */\n\tdelay(100*1000);\n      } else {\t\t\t/* thread context */\n\tif (tsleep((void *)sc, PCATCH, \"cardbus\", hz/10) != EWOULDBLOCK) {\n\t  break;\n\t}\n      }\n    }\n    if (i == 5) {\n      return 0;\n    }\n  }\n  \n  bhlc = cardbus_conf_read(cc, cf, tag, CARDBUS_BHLC_REG);\n  if (CARDBUS_LATTIMER(bhlc) < 0x10) {\n    bhlc &= ~(CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT);\n    bhlc |= (0x10 << CARDBUS_LATTIMER_SHIFT);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BHLC_REG, bhlc);\n  }\n\n  nfunction = CARDBUS_HDRTYPE_MULTIFN(bhlc) ? 8 : 1;\n\n  for(function = 0; function < nfunction; function++) {\n    struct cardbus_attach_args ca;\n\n    tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, function);\n  \n    id = cardbus_conf_read(cc, cf, tag, CARDBUS_ID_REG);\n    class = cardbus_conf_read(cc, cf, tag, CARDBUS_CLASS_REG);\n    cis_ptr = cardbus_conf_read(cc, cf, tag, CARDBUS_CIS_REG);\n  \n    /* Invalid vendor ID value? */\n    if (CARDBUS_VENDOR(id) == CARDBUS_VENDOR_INVALID) {\n      continue;\n    }\n      \n    DPRINTF((\"cardbus_attach_card: Vendor 0x%x, Product 0x%x, CIS 0x%x\\n\",\n\t     CARDBUS_VENDOR(id), CARDBUS_PRODUCT(id), cis_ptr));\n\n    enable_function(sc, cdstatus, function);\n\n    /* clean up every BAR */\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE0_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE1_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE2_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE3_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE4_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE5_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_ROM_REG, 0);\n    \n    /*\n     * We need to allocate the ct here, since we might \n     * need it when reading the CIS\n     */\n    if (NULL == (ct = (cardbus_devfunc_t)malloc(sizeof(struct cardbus_devfunc),\n\t\t\t\t\t\tM_DEVBUF, M_NOWAIT))) {\n      panic(\"no room for cardbus_tag\");\n    }\n\n    ct->ct_cc = sc->sc_cc;\n    ct->ct_cf = sc->sc_cf;\n    ct->ct_bus = sc->sc_bus;\n    ct->ct_dev = sc->sc_device;\n    ct->ct_func = function;\n    ct->ct_sc = sc;\n    ct->ct_next = NULL;\n    *previous_next = ct;\n\n    memset(&ca, 0, sizeof(ca));\n\n    ca.ca_unit = sc->sc_dev.dv_unit;\n    ca.ca_ct = ct;\n\n    ca.ca_iot = sc->sc_iot;\n    ca.ca_memt = sc->sc_memt;\n    ca.ca_dmat = sc->sc_dmat;\n\n    ca.ca_tag = tag;\n    ca.ca_device = sc->sc_device;\n    ca.ca_function = function;\n    ca.ca_id = id;\n    ca.ca_class = class;\n\n    ca.ca_intrline = sc->sc_intrline;\n\n    bzero(tuple, 2048);\n\n    if(cardbus_read_tuples(&ca, cis_ptr, tuple, sizeof(tuple))) {\n      printf(\"cardbus_attach_card: failed to read CIS\\n\");\n    } else {\n#ifdef CARDBUS_DEBUG\n      decode_tuples(tuple, 2048, print_tuple, NULL);\n#endif\n      decode_tuples(tuple, 2048, parse_tuple, &ca.ca_cis);\n    }\n\n    if (NULL == (csc = config_found_sm((void *)sc, &ca, cardbusprint, cardbussubmatch))) {\n      /* do not match */\n      disable_function(sc, function);\n      free(ct, M_DEVBUF);\n      *previous_next = NULL;\n    } else {\n      /* found */\n      previous_next = &(ct->ct_next);\n      ct->ct_device = csc;\n      ++no_work_funcs;\n    }\n  }\n  /*\n   * XXX power down pseudo function 8 (this will power down the card\n   * if no functions were attached).\n   */\n  disable_function(sc, 8);\n\n  return no_work_funcs;\n}"
  },
  {
    "function_name": "parse_tuple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
    "lines": "294-371",
    "snippet": "static void\nparse_tuple(u_int8_t *tuple, int len, void *data)\n{\n#ifdef CARDBUS_DEBUG\n    static const char func[] = \"parse_tuple\";\n#endif\n    struct cardbus_cis_info *cis = data;\n    int bar_index;\n    int i;\n    char *p;\n    switch(tuple[0]) {\n    case PCMCIA_CISTPL_MANFID:\n\tif(tuple[1] != 5) {\n\t    DPRINTF((\"%s: wrong length manufacturer id (%d)\\n\", \n\t\t     func, tuple[1]));\n\t    break;\n\t}\n\tcis->manufacturer = tuple[2] | (tuple[3] << 8);\n\tcis->product = tuple[4] | (tuple[5] << 8);\n\tbreak;\n    case PCMCIA_CISTPL_VERS_1:\n\tbcopy(tuple + 2, cis->cis1_info_buf, tuple[1]);\n\ti = 0;\n\tp = cis->cis1_info_buf + 2;\n\twhile(i < sizeof(cis->cis1_info) / sizeof(cis->cis1_info[0])) {\n\t    cis->cis1_info[i++] = p;\n\t    while(*p != '\\0' && *p != '\\xff')\n\t\tp++;\n\t    if(*p == '\\xff')\n\t\tbreak;\n\t    p++;\n\t}\n\tbreak;\n    case PCMCIA_CISTPL_BAR:\n\tif(tuple[1] != 6) {\n\t    DPRINTF((\"%s: BAR with short length (%d)\\n\", func, tuple[1]));\n\t    break;\n\t}\n\tbar_index = tuple[2] & 7;\n\tif(bar_index == 0) {\n\t    DPRINTF((\"%s: invalid ASI in BAR tuple\\n\", func));\n\t    break;\n\t}\n\tbar_index--;\n\tcis->bar[bar_index].flags = tuple[2];\n\tcis->bar[bar_index].size = (tuple[4] << 0) |\n\t\t\t\t    (tuple[5] << 8) |\n\t\t\t\t    (tuple[6] << 16) |\n\t\t\t\t    (tuple[7] << 24);\n\tbreak;\n    case PCMCIA_CISTPL_FUNCID:\n\tcis->funcid = tuple[2];\n\tbreak;\n\t\n    case PCMCIA_CISTPL_FUNCE:\n\tswitch(cis->funcid) {\n\tcase PCMCIA_FUNCTION_SERIAL:\n\t    if(tuple[1] >= 2 && \n\t       tuple[2] == 0 /* XXX PCMCIA_TPLFE_TYPE_SERIAL_??? */) {\n\t\tcis->funce.serial.uart_type = tuple[3] & 0x1f;\n\t\tcis->funce.serial.uart_present = 1;\n\t    }\n\t    break;\n\tcase PCMCIA_FUNCTION_NETWORK:\n\t    if(tuple[1] >= 8 && tuple[2] == PCMCIA_TPLFE_TYPE_LAN_NID) {\n\t\tif(tuple[3] > sizeof(cis->funce.network.netid)) {\n\t\t    DPRINTF((\"%s: unknown network id type (len = %d)\\n\", \n\t\t\t     func, tuple[3]));\n\t\t} else {\n\t\t    cis->funce.network.netid_present = 1;\n\t\t    bcopy(tuple + 4, cis->funce.network.netid, \n\t\t\t   tuple[3]);\n\t\t}\n\t    }\n\t}\n\tbreak;\n    }\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/pci/pcivar.h>\t/* XXX */",
      "#include <dev/cardbus/cardbus_exrom.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int (*func)",
      "static u_int8_t *\ndecode_tuple(tuple, func, data)\n     u_int8_t *tuple;",
      "tuple_decode_func func;",
      "void *data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "tuple + 4",
            "cis->funce.network.netid",
            "tuple[3]"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: unknown network id type (len = %d)\\n\", \n\t\t\t     func, tuple[3])"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: invalid ASI in BAR tuple\\n\", func)"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: BAR with short length (%d)\\n\", func, tuple[1])"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: wrong length manufacturer id (%d)\\n\", \n\t\t     func, tuple[1])"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint (*func);\nstatic u_int8_t *\ndecode_tuple(tuple, func, data)\n     u_int8_t *tuple;\ntuple_decode_func func;\nvoid *data;\n\nstatic void\nparse_tuple(u_int8_t *tuple, int len, void *data)\n{\n#ifdef CARDBUS_DEBUG\n    static const char func[] = \"parse_tuple\";\n#endif\n    struct cardbus_cis_info *cis = data;\n    int bar_index;\n    int i;\n    char *p;\n    switch(tuple[0]) {\n    case PCMCIA_CISTPL_MANFID:\n\tif(tuple[1] != 5) {\n\t    DPRINTF((\"%s: wrong length manufacturer id (%d)\\n\", \n\t\t     func, tuple[1]));\n\t    break;\n\t}\n\tcis->manufacturer = tuple[2] | (tuple[3] << 8);\n\tcis->product = tuple[4] | (tuple[5] << 8);\n\tbreak;\n    case PCMCIA_CISTPL_VERS_1:\n\tbcopy(tuple + 2, cis->cis1_info_buf, tuple[1]);\n\ti = 0;\n\tp = cis->cis1_info_buf + 2;\n\twhile(i < sizeof(cis->cis1_info) / sizeof(cis->cis1_info[0])) {\n\t    cis->cis1_info[i++] = p;\n\t    while(*p != '\\0' && *p != '\\xff')\n\t\tp++;\n\t    if(*p == '\\xff')\n\t\tbreak;\n\t    p++;\n\t}\n\tbreak;\n    case PCMCIA_CISTPL_BAR:\n\tif(tuple[1] != 6) {\n\t    DPRINTF((\"%s: BAR with short length (%d)\\n\", func, tuple[1]));\n\t    break;\n\t}\n\tbar_index = tuple[2] & 7;\n\tif(bar_index == 0) {\n\t    DPRINTF((\"%s: invalid ASI in BAR tuple\\n\", func));\n\t    break;\n\t}\n\tbar_index--;\n\tcis->bar[bar_index].flags = tuple[2];\n\tcis->bar[bar_index].size = (tuple[4] << 0) |\n\t\t\t\t    (tuple[5] << 8) |\n\t\t\t\t    (tuple[6] << 16) |\n\t\t\t\t    (tuple[7] << 24);\n\tbreak;\n    case PCMCIA_CISTPL_FUNCID:\n\tcis->funcid = tuple[2];\n\tbreak;\n\t\n    case PCMCIA_CISTPL_FUNCE:\n\tswitch(cis->funcid) {\n\tcase PCMCIA_FUNCTION_SERIAL:\n\t    if(tuple[1] >= 2 && \n\t       tuple[2] == 0 /* XXX PCMCIA_TPLFE_TYPE_SERIAL_??? */) {\n\t\tcis->funce.serial.uart_type = tuple[3] & 0x1f;\n\t\tcis->funce.serial.uart_present = 1;\n\t    }\n\t    break;\n\tcase PCMCIA_FUNCTION_NETWORK:\n\t    if(tuple[1] >= 8 && tuple[2] == PCMCIA_TPLFE_TYPE_LAN_NID) {\n\t\tif(tuple[3] > sizeof(cis->funce.network.netid)) {\n\t\t    DPRINTF((\"%s: unknown network id type (len = %d)\\n\", \n\t\t\t     func, tuple[3]));\n\t\t} else {\n\t\t    cis->funce.network.netid_present = 1;\n\t\t    bcopy(tuple + 4, cis->funce.network.netid, \n\t\t\t   tuple[3]);\n\t\t}\n\t    }\n\t}\n\tbreak;\n    }\n}"
  },
  {
    "function_name": "cardbus_read_tuples",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
    "lines": "155-292",
    "snippet": "static int\ncardbus_read_tuples(ca, cis_ptr, tuples, len)\n     struct cardbus_attach_args *ca;\n     cardbusreg_t cis_ptr;\n     u_int8_t *tuples;\n     size_t len;\n{\n    struct cardbus_softc *sc = ca->ca_ct->ct_sc;\n    cardbus_chipset_tag_t cc = ca->ca_ct->ct_cc;\n    cardbus_function_tag_t cf = ca->ca_ct->ct_cf;\n    cardbustag_t tag = ca->ca_tag;\n    cardbusreg_t command;\n    int found = 0;\n\n    int i, j;\n    int cardbus_space = cis_ptr & CARDBUS_CIS_ASIMASK;\n    bus_space_handle_t bar_memh;\n    bus_size_t bar_size;\n    bus_addr_t bar_addr;\n    \n    int reg;\n      \n    memset(tuples, 0, len);\n\n    cis_ptr = cis_ptr & CARDBUS_CIS_ADDRMASK;\n\n    switch(cardbus_space) {\n    case CARDBUS_CIS_ASI_TUPLE:\n\tDPRINTF((\"%s: reading CIS data from configuration space\\n\", \n\t\t sc->sc_dev.dv_xname));\n\tfor (i = cis_ptr, j = 0; i < 0xff; i += 4) {\n\t    u_int32_t e = (cf->cardbus_conf_read)(cc, tag, i);\n\t    tuples[j] = 0xff & e;\n\t    e >>= 8;\n\t    tuples[j + 1] = 0xff & e;\n\t    e >>= 8;\n\t    tuples[j + 2] = 0xff & e;\n\t    e >>= 8;\n\t    tuples[j + 3] = 0xff & e;\n\t    j += 4;\n\t}\n\tfound++;\n\tbreak;\n\n    case CARDBUS_CIS_ASI_BAR0:\n    case CARDBUS_CIS_ASI_BAR1:\n    case CARDBUS_CIS_ASI_BAR2:\n    case CARDBUS_CIS_ASI_BAR3:\n    case CARDBUS_CIS_ASI_BAR4:\n    case CARDBUS_CIS_ASI_BAR5:\n    case CARDBUS_CIS_ASI_ROM:\n\tif(cardbus_space == CARDBUS_CIS_ASI_ROM) {\n\t    reg = CARDBUS_ROM_REG;\n\t    DPRINTF((\"%s: reading CIS data from ROM\\n\",\n\t\t     sc->sc_dev.dv_xname));\n\t} else {\n\t    reg = CARDBUS_BASE0_REG + (cardbus_space - 1) * 4;\n\t    DPRINTF((\"%s: reading CIS data from BAR%d\\n\",\n\t\t     sc->sc_dev.dv_xname, cardbus_space - 1));\n\t}\n\n\t/* XXX zero register so mapreg_map doesn't get confused by old\n           contents */\n\tcardbus_conf_write(cc, cf, tag, reg, 0);\n\tif(Cardbus_mapreg_map(ca->ca_ct, reg,\n\t\t\t      CARDBUS_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT,\n\t\t\t      0, \n\t\t\t      NULL, &bar_memh, &bar_addr, &bar_size)) {\n\t    printf(\"%s: failed to map memory\\n\", sc->sc_dev.dv_xname);\n\t    return 1;\n\t}\n\n\n\tif(cardbus_space == CARDBUS_CIS_ASI_ROM) {\n\t    cardbusreg_t exrom;\n\t    int save;\n\t    struct cardbus_rom_image_head rom_image;\n\t    struct cardbus_rom_image *p;\n\t\t    \n\t    save = splhigh();\n\t    /* enable rom address decoder */\n\t    exrom = cardbus_conf_read(cc, cf, tag, reg);\n\t    cardbus_conf_write(cc, cf, tag, reg, exrom | 1);\n\t    \n\t    command = cardbus_conf_read(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG);\n\t    cardbus_conf_write(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG, \n\t\t\t       command | CARDBUS_COMMAND_MEM_ENABLE);\n\n\t    if(cardbus_read_exrom(ca->ca_memt, bar_memh, &rom_image))\n\t\tgoto out;\n\n\t    for(p = SIMPLEQ_FIRST(&rom_image);\n\t\tp;\n\t\tp = SIMPLEQ_NEXT(p, next)) {\n\t\tif(p->rom_image == CARDBUS_CIS_ASI_ROM_IMAGE(cis_ptr)) {\n\t\t    bus_space_read_region_1(p->romt, p->romh,\n\t\t\t\t\t    CARDBUS_CIS_ADDR(cis_ptr),\n\t\t\t\t\t    tuples, 256);\n\t\t    found++;\n\t\t}\n\t\tbreak;\n\t    }\n\t    while((p = SIMPLEQ_FIRST(&rom_image)) != NULL) {\n\t\tSIMPLEQ_REMOVE_HEAD(&rom_image, p, next);\n\t\tfree(p, M_DEVBUF);\n\t    }\n\tout:\n\t    exrom = cardbus_conf_read(cc, cf, tag, reg);\n\t    cardbus_conf_write(cc, cf, tag, reg, exrom & ~1);\n\t    splx(save);\n\t} else {\n\t    command = cardbus_conf_read(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG);\n\t    cardbus_conf_write(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG, \n\t\t\t       command | CARDBUS_COMMAND_MEM_ENABLE);\n\t    /* XXX byte order? */\n\t    bus_space_read_region_1(ca->ca_memt, bar_memh, \n\t\t\t\t    cis_ptr, tuples, 256);\n\t    found++;\n\t}\n\tcommand = cardbus_conf_read(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG, \n\t\t\t   command & ~CARDBUS_COMMAND_MEM_ENABLE);\n\tcardbus_conf_write(cc, cf, tag, reg, 0);\n#if 0\n\t/* XXX unmap memory */\n\t(*ca->ca_ct->ct_cf->cardbus_space_free)(ca->ca_ct, \n\t\t\t\t\t\tca->ca_ct->ct_sc->sc_rbus_memt, \n\t\t\t\t\t\tbar_memh, bar_size);\n#endif\n\tbreak;\n\n#ifdef DIAGNOSTIC\n    default:\n\tpanic(\"%s: bad CIS space (%d)\", sc->sc_dev.dv_xname, cardbus_space);\n#endif\n    }\n    return !found;\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/pci/pcivar.h>\t/* XXX */",
      "#include <dev/cardbus/cardbus_exrom.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cardbus_read_tuples",
      "void *\ncardbus_intr_establish(cc, cf, irq, level, func, arg)\n     cardbus_chipset_tag_t cc;",
      "cardbus_function_tag_t cf;",
      "void *data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: bad CIS space (%d)\"",
            "sc->sc_dev.dv_xname",
            "cardbus_space"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "ca->ca_ct",
            "ca->ca_ct->ct_sc->sc_rbus_memt",
            "bar_memh",
            "bar_size"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "reg",
            "0"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_COMMAND_STATUS_REG",
            "command & ~CARDBUS_COMMAND_MEM_ENABLE"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_COMMAND_STATUS_REG"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_region_1",
          "args": [
            "ca->ca_memt",
            "bar_memh",
            "cis_ptr",
            "tuples",
            "256"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_COMMAND_STATUS_REG",
            "command | CARDBUS_COMMAND_MEM_ENABLE"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_COMMAND_STATUS_REG"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "save"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "reg",
            "exrom & ~1"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "reg"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p",
            "M_DEVBUF"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "rbus_space_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/rbus.c",
          "lines": "179-207",
          "snippet": "int\nrbus_space_free(rbt, bsh, size, addrp)\n     rbus_tag_t rbt;\n     bus_space_handle_t bsh;\n     bus_size_t size;\n     bus_addr_t *addrp;\n{\n  int exflags = EX_FAST | EX_NOWAIT;\n  bus_addr_t addr;\n  int status = 1;\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    md_space_unmap(rbt->rb_bt, bsh, size, &addr);\n\n    extent_free(rbt->rb_ext, addr, size, exflags);\n\n    status = 0;\n  } else {\n    /* error. INVALID rbustag */\n    status = 1;\n  }\n  if (addrp != NULL) {\n    *addrp = addr;\n  }\n  return status;\n}",
          "includes": [
            "#include <dev/cardbus/rbus.h>",
            "#include <machine/bus.h>",
            "#include <sys/extent.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/cardbus/rbus.h>\n#include <machine/bus.h>\n#include <sys/extent.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\nrbus_space_free(rbt, bsh, size, addrp)\n     rbus_tag_t rbt;\n     bus_space_handle_t bsh;\n     bus_size_t size;\n     bus_addr_t *addrp;\n{\n  int exflags = EX_FAST | EX_NOWAIT;\n  bus_addr_t addr;\n  int status = 1;\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    md_space_unmap(rbt->rb_bt, bsh, size, &addr);\n\n    extent_free(rbt->rb_ext, addr, size, exflags);\n\n    status = 0;\n  } else {\n    /* error. INVALID rbustag */\n    status = 1;\n  }\n  if (addrp != NULL) {\n    *addrp = addr;\n  }\n  return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_REMOVE_HEAD",
          "args": [
            "&rom_image",
            "p",
            "next"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&rom_image"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_region_1",
          "args": [
            "p->romt",
            "p->romh",
            "CARDBUS_CIS_ADDR(cis_ptr)",
            "tuples",
            "256"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDBUS_CIS_ADDR",
          "args": [
            "cis_ptr"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDBUS_CIS_ASI_ROM_IMAGE",
          "args": [
            "cis_ptr"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_NEXT",
          "args": [
            "p",
            "next"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&rom_image"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_read_exrom",
          "args": [
            "ca->ca_memt",
            "bar_memh",
            "&rom_image"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "cardbus_read_exrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus_exrom.c",
          "lines": "90-143",
          "snippet": "int\ncardbus_read_exrom(romt, romh, head)\n     bus_space_tag_t romt;\n     bus_space_handle_t romh;\n     struct cardbus_rom_image_head *head;\n{\n    static const char func[] = \"cardbus_read_exrom\";\n\n    size_t addr = 0; /* offset of current rom image */\n    size_t dataptr;\n    unsigned int rom_image = 0;\n    \n    SIMPLEQ_INIT(head);\n    do {\n\tsize_t image_size;\n\tstruct cardbus_rom_image *image;\n\tu_int16_t val;\n\n\tval = READ_INT16(romt, romh, addr + CARDBUS_EXROM_SIGNATURE);\n\tif(val != 0xaa55) {\n\t    printf(\"%s: bad header signature in ROM image %u: 0x%04x\\n\", \n\t\t   func, rom_image, val);\n\t    return 1;\n\t}\n\tdataptr = addr + READ_INT16(romt, romh, addr + CARDBUS_EXROM_DATA_PTR);\n\t/* get the ROM image size, in blocks */\n\timage_size = READ_INT16(romt, romh, \n\t\t         dataptr + CARDBUS_EXROM_DATA_IMAGE_LENGTH);\n\tif(image_size == 0) \n\t    /* XXX some ROMs seem to have this as zero, can we assume\n               this means 1 block? */\n\t    image_size = 1;\n\timage_size <<= 9;\n\timage = malloc(sizeof(*image), M_DEVBUF, M_NOWAIT);\n\tif(image == NULL) {\n\t    printf(\"%s: out of memory\\n\", func);\n\t    return 1;\n\t}\n\timage->rom_image = rom_image;\n\timage->image_size = image_size;\n\timage->romt = romt;\n\tif(bus_space_subregion(romt, romh, addr, \n\t\t\t       image_size, &image->romh)) {\n\t    printf(\"%s: bus_space_subregion failed\", func);\n\t    free(image, M_DEVBUF);\n\t    return 1;\n\t}\n\tSIMPLEQ_INSERT_TAIL(head, image, next);\n\taddr += image_size;\n\trom_image++;\n    } while ((bus_space_read_1(romt, romh, \n                  dataptr + CARDBUS_EXROM_DATA_INDICATOR) & 0x80) == 0);\n    return 0;\n}",
          "includes": [
            "#include <dev/cardbus/cardbus_exrom.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/cardbus/cardbus_exrom.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ncardbus_read_exrom(romt, romh, head)\n     bus_space_tag_t romt;\n     bus_space_handle_t romh;\n     struct cardbus_rom_image_head *head;\n{\n    static const char func[] = \"cardbus_read_exrom\";\n\n    size_t addr = 0; /* offset of current rom image */\n    size_t dataptr;\n    unsigned int rom_image = 0;\n    \n    SIMPLEQ_INIT(head);\n    do {\n\tsize_t image_size;\n\tstruct cardbus_rom_image *image;\n\tu_int16_t val;\n\n\tval = READ_INT16(romt, romh, addr + CARDBUS_EXROM_SIGNATURE);\n\tif(val != 0xaa55) {\n\t    printf(\"%s: bad header signature in ROM image %u: 0x%04x\\n\", \n\t\t   func, rom_image, val);\n\t    return 1;\n\t}\n\tdataptr = addr + READ_INT16(romt, romh, addr + CARDBUS_EXROM_DATA_PTR);\n\t/* get the ROM image size, in blocks */\n\timage_size = READ_INT16(romt, romh, \n\t\t         dataptr + CARDBUS_EXROM_DATA_IMAGE_LENGTH);\n\tif(image_size == 0) \n\t    /* XXX some ROMs seem to have this as zero, can we assume\n               this means 1 block? */\n\t    image_size = 1;\n\timage_size <<= 9;\n\timage = malloc(sizeof(*image), M_DEVBUF, M_NOWAIT);\n\tif(image == NULL) {\n\t    printf(\"%s: out of memory\\n\", func);\n\t    return 1;\n\t}\n\timage->rom_image = rom_image;\n\timage->image_size = image_size;\n\timage->romt = romt;\n\tif(bus_space_subregion(romt, romh, addr, \n\t\t\t       image_size, &image->romh)) {\n\t    printf(\"%s: bus_space_subregion failed\", func);\n\t    free(image, M_DEVBUF);\n\t    return 1;\n\t}\n\tSIMPLEQ_INSERT_TAIL(head, image, next);\n\taddr += image_size;\n\trom_image++;\n    } while ((bus_space_read_1(romt, romh, \n                  dataptr + CARDBUS_EXROM_DATA_INDICATOR) & 0x80) == 0);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_COMMAND_STATUS_REG",
            "command | CARDBUS_COMMAND_MEM_ENABLE"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_COMMAND_STATUS_REG"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "reg",
            "exrom | 1"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "reg"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: failed to map memory\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Cardbus_mapreg_map",
          "args": [
            "ca->ca_ct",
            "reg",
            "CARDBUS_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT",
            "0",
            "NULL",
            "&bar_memh",
            "&bar_addr",
            "&bar_size"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "reg",
            "0"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: reading CIS data from BAR%d\\n\",\n\t\t     sc->sc_dev.dv_xname, cardbus_space - 1)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: reading CIS data from ROM\\n\",\n\t\t     sc->sc_dev.dv_xname)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cc",
            "tag",
            "i"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: reading CIS data from configuration space\\n\", \n\t\t sc->sc_dev.dv_xname)"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tuples",
            "0",
            "len"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int cardbus_read_tuples;\nvoid *\ncardbus_intr_establish(cc, cf, irq, level, func, arg)\n     cardbus_chipset_tag_t cc;\ncardbus_function_tag_t cf;\nvoid *data;\n\nstatic int\ncardbus_read_tuples(ca, cis_ptr, tuples, len)\n     struct cardbus_attach_args *ca;\n     cardbusreg_t cis_ptr;\n     u_int8_t *tuples;\n     size_t len;\n{\n    struct cardbus_softc *sc = ca->ca_ct->ct_sc;\n    cardbus_chipset_tag_t cc = ca->ca_ct->ct_cc;\n    cardbus_function_tag_t cf = ca->ca_ct->ct_cf;\n    cardbustag_t tag = ca->ca_tag;\n    cardbusreg_t command;\n    int found = 0;\n\n    int i, j;\n    int cardbus_space = cis_ptr & CARDBUS_CIS_ASIMASK;\n    bus_space_handle_t bar_memh;\n    bus_size_t bar_size;\n    bus_addr_t bar_addr;\n    \n    int reg;\n      \n    memset(tuples, 0, len);\n\n    cis_ptr = cis_ptr & CARDBUS_CIS_ADDRMASK;\n\n    switch(cardbus_space) {\n    case CARDBUS_CIS_ASI_TUPLE:\n\tDPRINTF((\"%s: reading CIS data from configuration space\\n\", \n\t\t sc->sc_dev.dv_xname));\n\tfor (i = cis_ptr, j = 0; i < 0xff; i += 4) {\n\t    u_int32_t e = (cf->cardbus_conf_read)(cc, tag, i);\n\t    tuples[j] = 0xff & e;\n\t    e >>= 8;\n\t    tuples[j + 1] = 0xff & e;\n\t    e >>= 8;\n\t    tuples[j + 2] = 0xff & e;\n\t    e >>= 8;\n\t    tuples[j + 3] = 0xff & e;\n\t    j += 4;\n\t}\n\tfound++;\n\tbreak;\n\n    case CARDBUS_CIS_ASI_BAR0:\n    case CARDBUS_CIS_ASI_BAR1:\n    case CARDBUS_CIS_ASI_BAR2:\n    case CARDBUS_CIS_ASI_BAR3:\n    case CARDBUS_CIS_ASI_BAR4:\n    case CARDBUS_CIS_ASI_BAR5:\n    case CARDBUS_CIS_ASI_ROM:\n\tif(cardbus_space == CARDBUS_CIS_ASI_ROM) {\n\t    reg = CARDBUS_ROM_REG;\n\t    DPRINTF((\"%s: reading CIS data from ROM\\n\",\n\t\t     sc->sc_dev.dv_xname));\n\t} else {\n\t    reg = CARDBUS_BASE0_REG + (cardbus_space - 1) * 4;\n\t    DPRINTF((\"%s: reading CIS data from BAR%d\\n\",\n\t\t     sc->sc_dev.dv_xname, cardbus_space - 1));\n\t}\n\n\t/* XXX zero register so mapreg_map doesn't get confused by old\n           contents */\n\tcardbus_conf_write(cc, cf, tag, reg, 0);\n\tif(Cardbus_mapreg_map(ca->ca_ct, reg,\n\t\t\t      CARDBUS_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT,\n\t\t\t      0, \n\t\t\t      NULL, &bar_memh, &bar_addr, &bar_size)) {\n\t    printf(\"%s: failed to map memory\\n\", sc->sc_dev.dv_xname);\n\t    return 1;\n\t}\n\n\n\tif(cardbus_space == CARDBUS_CIS_ASI_ROM) {\n\t    cardbusreg_t exrom;\n\t    int save;\n\t    struct cardbus_rom_image_head rom_image;\n\t    struct cardbus_rom_image *p;\n\t\t    \n\t    save = splhigh();\n\t    /* enable rom address decoder */\n\t    exrom = cardbus_conf_read(cc, cf, tag, reg);\n\t    cardbus_conf_write(cc, cf, tag, reg, exrom | 1);\n\t    \n\t    command = cardbus_conf_read(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG);\n\t    cardbus_conf_write(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG, \n\t\t\t       command | CARDBUS_COMMAND_MEM_ENABLE);\n\n\t    if(cardbus_read_exrom(ca->ca_memt, bar_memh, &rom_image))\n\t\tgoto out;\n\n\t    for(p = SIMPLEQ_FIRST(&rom_image);\n\t\tp;\n\t\tp = SIMPLEQ_NEXT(p, next)) {\n\t\tif(p->rom_image == CARDBUS_CIS_ASI_ROM_IMAGE(cis_ptr)) {\n\t\t    bus_space_read_region_1(p->romt, p->romh,\n\t\t\t\t\t    CARDBUS_CIS_ADDR(cis_ptr),\n\t\t\t\t\t    tuples, 256);\n\t\t    found++;\n\t\t}\n\t\tbreak;\n\t    }\n\t    while((p = SIMPLEQ_FIRST(&rom_image)) != NULL) {\n\t\tSIMPLEQ_REMOVE_HEAD(&rom_image, p, next);\n\t\tfree(p, M_DEVBUF);\n\t    }\n\tout:\n\t    exrom = cardbus_conf_read(cc, cf, tag, reg);\n\t    cardbus_conf_write(cc, cf, tag, reg, exrom & ~1);\n\t    splx(save);\n\t} else {\n\t    command = cardbus_conf_read(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG);\n\t    cardbus_conf_write(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG, \n\t\t\t       command | CARDBUS_COMMAND_MEM_ENABLE);\n\t    /* XXX byte order? */\n\t    bus_space_read_region_1(ca->ca_memt, bar_memh, \n\t\t\t\t    cis_ptr, tuples, 256);\n\t    found++;\n\t}\n\tcommand = cardbus_conf_read(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG, \n\t\t\t   command & ~CARDBUS_COMMAND_MEM_ENABLE);\n\tcardbus_conf_write(cc, cf, tag, reg, 0);\n#if 0\n\t/* XXX unmap memory */\n\t(*ca->ca_ct->ct_cf->cardbus_space_free)(ca->ca_ct, \n\t\t\t\t\t\tca->ca_ct->ct_sc->sc_rbus_memt, \n\t\t\t\t\t\tbar_memh, bar_size);\n#endif\n\tbreak;\n\n#ifdef DIAGNOSTIC\n    default:\n\tpanic(\"%s: bad CIS space (%d)\", sc->sc_dev.dv_xname, cardbus_space);\n#endif\n    }\n    return !found;\n}"
  },
  {
    "function_name": "cardbusattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
    "lines": "120-153",
    "snippet": "STATIC void\ncardbusattach(parent, self, aux)\n     struct device *parent;\n     struct device *self;\n     void *aux;\n{\n  struct cardbus_softc *sc = (void *)self;\n  struct cbslot_attach_args *cba = aux;\n  int cdstatus;\n\n  sc->sc_bus = cba->cba_bus;\n  sc->sc_device = 0;\n  sc->sc_intrline = cba->cba_intrline;\n  sc->sc_cacheline = cba->cba_cacheline;\n  sc->sc_lattimer = cba->cba_lattimer;\n\n  printf(\": bus %d device %d\", sc->sc_bus, sc->sc_device);\n  printf(\" cacheline 0x%x, lattimer 0x%x\\n\", sc->sc_cacheline,sc->sc_lattimer);\n\n  sc->sc_iot = cba->cba_iot;\t/* CardBus I/O space tag */\n  sc->sc_memt = cba->cba_memt;\t/* CardBus MEM space tag */\n  sc->sc_dmat = cba->cba_dmat;\t/* DMA tag */\n  sc->sc_cc = cba->cba_cc;\n  sc->sc_cf = cba->cba_cf;\n\n#if rbus\n  sc->sc_rbus_iot = cba->cba_rbus_iot;\n  sc->sc_rbus_memt = cba->cba_rbus_memt;\n#endif\n\n  sc->sc_funcs = NULL;\n\n  cdstatus = 0;\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/pci/pcivar.h>\t/* XXX */",
      "#include <dev/cardbus/cardbus_exrom.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "cardbusattach __P((struct device *, struct device *, void *));",
      "STATIC int",
      "cardbusmatch __P((struct device *, void *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" cacheline 0x%x, lattimer 0x%x\\n\"",
            "sc->sc_cacheline",
            "sc->sc_lattimer"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC void;\ncardbusattach __P((struct device *, struct device *, void *));\nSTATIC int;\ncardbusmatch __P((struct device *, void *, void *));\n\nSTATIC void\ncardbusattach(parent, self, aux)\n     struct device *parent;\n     struct device *self;\n     void *aux;\n{\n  struct cardbus_softc *sc = (void *)self;\n  struct cbslot_attach_args *cba = aux;\n  int cdstatus;\n\n  sc->sc_bus = cba->cba_bus;\n  sc->sc_device = 0;\n  sc->sc_intrline = cba->cba_intrline;\n  sc->sc_cacheline = cba->cba_cacheline;\n  sc->sc_lattimer = cba->cba_lattimer;\n\n  printf(\": bus %d device %d\", sc->sc_bus, sc->sc_device);\n  printf(\" cacheline 0x%x, lattimer 0x%x\\n\", sc->sc_cacheline,sc->sc_lattimer);\n\n  sc->sc_iot = cba->cba_iot;\t/* CardBus I/O space tag */\n  sc->sc_memt = cba->cba_memt;\t/* CardBus MEM space tag */\n  sc->sc_dmat = cba->cba_dmat;\t/* DMA tag */\n  sc->sc_cc = cba->cba_cc;\n  sc->sc_cf = cba->cba_cf;\n\n#if rbus\n  sc->sc_rbus_iot = cba->cba_rbus_iot;\n  sc->sc_rbus_memt = cba->cba_rbus_memt;\n#endif\n\n  sc->sc_funcs = NULL;\n\n  cdstatus = 0;\n}"
  },
  {
    "function_name": "cardbusmatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
    "lines": "100-116",
    "snippet": "STATIC int\ncardbusmatch(parent, match, aux)\n     struct device *parent;\n     void *match;\n     void *aux;\n{\n  struct cfdata *cf = match;\n  struct cbslot_attach_args *cba = aux;\n\n  if (strcmp(cba->cba_busname, cf->cf_driver->cd_name)) {\n    DPRINTF((\"cardbusmatch: busname differs %s <=> %s\\n\",\n\t     cba->cba_busname, cf->cf_driver->cd_name));\n    return 0;\n  }\n\n  return 1;\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/pci/pcivar.h>\t/* XXX */",
      "#include <dev/cardbus/cardbus_exrom.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "cardbusattach __P((struct device *, struct device *, void *));",
      "STATIC int",
      "cardbusmatch __P((struct device *, void *, void *));",
      "cardbus_function_tag_t cf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"cardbusmatch: busname differs %s <=> %s\\n\",\n\t     cba->cba_busname, cf->cf_driver->cd_name)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cba->cba_busname",
            "cf->cf_driver->cd_name"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC void;\ncardbusattach __P((struct device *, struct device *, void *));\nSTATIC int;\ncardbusmatch __P((struct device *, void *, void *));\ncardbus_function_tag_t cf;\n\nSTATIC int\ncardbusmatch(parent, match, aux)\n     struct device *parent;\n     void *match;\n     void *aux;\n{\n  struct cfdata *cf = match;\n  struct cbslot_attach_args *cba = aux;\n\n  if (strcmp(cba->cba_busname, cf->cf_driver->cd_name)) {\n    DPRINTF((\"cardbusmatch: busname differs %s <=> %s\\n\",\n\t     cba->cba_busname, cf->cf_driver->cd_name));\n    return 0;\n  }\n\n  return 1;\n}"
  }
]