[
  {
    "function_name": "ms_softint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/ms.c",
    "lines": "579-644",
    "snippet": "static void\nms_softint(cs)\n\tstruct zs_chanstate *cs;\n{\n\tregister struct ms_softc *ms;\n\tregister int get, c, s;\n\tint intr_flags;\n\tregister u_short ring_data;\n\n\tms = cs->cs_private;\n\n\t/* Atomically get and clear flags. */\n\ts = splzs();\n\tintr_flags = ms->ms_intr_flags;\n\tms->ms_intr_flags = 0;\n\n\t/* Now lower to spltty for the rest. */\n\t(void) spltty();\n\n\t/*\n\t * Copy data from the receive ring to the event layer.\n\t */\n\tget = ms->ms_rbget;\n\twhile (get != ms->ms_rbput) {\n\t\tring_data = ms->ms_rbuf[get];\n\t\tget = (get + 1) & MS_RX_RING_MASK;\n\n\t\t/* low byte of ring_data is rr1 */\n\t\tc = (ring_data >> 8) & 0xff;\n\n\t\tif (ring_data & ZSRR1_DO)\n\t\t\tintr_flags |= INTR_RX_OVERRUN;\n\t\tif (ring_data & (ZSRR1_FE | ZSRR1_PE)) {\n\t\t\tlog(LOG_ERR, \"%s: input error (0x%x)\\n\",\n\t\t\t\tms->ms_dev.dv_xname, ring_data);\n\t\t\tc = -1;\t/* signal input error */\n\t\t}\n\n\t\t/* Pass this up to the \"middle\" layer. */\n\t\tms_input(ms, c);\n\t}\n\tif (intr_flags & INTR_RX_OVERRUN) {\n\t\tlog(LOG_ERR, \"%s: input overrun\\n\",\n\t\t    ms->ms_dev.dv_xname);\n\t}\n\tms->ms_rbget = get;\n\n\tif (intr_flags & INTR_TX_EMPTY) {\n\t\t/*\n\t\t * Transmit done.  (Not expected.)\n\t\t */\n\t\tlog(LOG_ERR, \"%s: transmit interrupt?\\n\",\n\t\t    ms->ms_dev.dv_xname);\n\t}\n\n\tif (intr_flags & INTR_ST_CHECK) {\n\t\t/*\n\t\t * Status line change.  (Not expected.)\n\t\t */\n\t\tlog(LOG_ERR, \"%s: status interrupt?\\n\",\n\t\t    ms->ms_dev.dv_xname);\n\t\tcs->cs_rr0_delta = 0;\n\t}\n\n\tsplx(s);\n}",
    "includes": [
      "#include \"event_var.h\"",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <machine/vuid_event.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define INTR_ST_CHECK   4",
      "#define INTR_TX_EMPTY   2",
      "#define\tINTR_RX_OVERRUN 1",
      "#define MS_RX_RING_MASK (MS_RX_RING_SIZE-1)"
    ],
    "globals_used": [
      "struct ms_softc {\n\tstruct\tdevice ms_dev;\t\t/* required first: base device */\n\tstruct\tzs_chanstate *ms_cs;\n\n\t/* Flags to communicate with ms_softintr() */\n\tvolatile int ms_intr_flags;\n#define\tINTR_RX_OVERRUN 1\n#define INTR_TX_EMPTY   2\n#define INTR_ST_CHECK   4\n\n\t/*\n\t * The receive ring buffer.\n\t */\n\tu_int\tms_rbget;\t/* ring buffer `get' index */\n\tvolatile u_int\tms_rbput;\t/* ring buffer `put' index */\n\tu_short\tms_rbuf[MS_RX_RING_SIZE]; /* rr1, data pairs */\n\n\t/*\n\t * State of input translator\n\t */\n\tshort\tms_byteno;\t\t/* input byte number, for decode */\n\tchar\tms_mb;\t\t\t/* mouse button state */\n\tchar\tms_ub;\t\t\t/* user button state */\n\tint\tms_dx;\t\t\t/* delta-x */\n\tint\tms_dy;\t\t\t/* delta-y */\n\n\t/*\n\t * State of upper interface.\n\t */\n\tvolatile int ms_ready;\t\t/* event queue is ready */\n\tstruct\tevvar ms_events;\t/* event queue state */\n} ms_softc;",
      "static void ms_input",
      "static void ms_softint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: status interrupt?\\n\"",
            "ms->ms_dev.dv_xname"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ms_input",
          "args": [
            "ms",
            "c"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "ms_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/ms.c",
          "lines": "352-484",
          "snippet": "void\nms_input(ms, c)\n\tregister struct ms_softc *ms;\n\tregister int c;\n{\n\tregister struct firm_event *fe;\n\tregister int mb, ub, d, get, put, any;\n\tstatic const char to_one[] = { 1, 2, 2, 4, 4, 4, 4 };\n\tstatic const int to_id[] = { MS_RIGHT, MS_MIDDLE, 0, MS_LEFT };\n\n\t/*\n\t * Discard input if not ready.  Drop sync on parity or framing\n\t * error; gain sync on button byte.\n\t */\n\tif (ms->ms_ready == 0)\n\t\treturn;\n\tif (c == -1) {\n\t\tms->ms_byteno = -1;\n\t\treturn;\n\t}\n\tif ((c & ~7) == 0x80)\t/* if in 0x80..0x87 */\n\t\tms->ms_byteno = 0;\n\n\t/*\n\t * Run the decode loop, adding to the current information.\n\t * We add, rather than replace, deltas, so that if the event queue\n\t * fills, we accumulate data for when it opens up again.\n\t */\n\tswitch (ms->ms_byteno) {\n\n\tcase -1:\n\t\treturn;\n\n\tcase 0:\n\t\t/* buttons */\n\t\tms->ms_byteno = 1;\n\t\tms->ms_mb = (~c) & 0x7;\n\t\treturn;\n\n\tcase 1:\n\t\t/* first delta-x */\n\t\tms->ms_byteno = 2;\n\t\tms->ms_dx += (char)c;\n\t\treturn;\n\n\tcase 2:\n\t\t/* first delta-y */\n\t\tms->ms_byteno = 3;\n\t\tms->ms_dy += (char)c;\n\t\treturn;\n\n\tcase 3:\n\t\t/* second delta-x */\n\t\tms->ms_byteno = 4;\n\t\tms->ms_dx += (char)c;\n\t\treturn;\n\n\tcase 4:\n\t\t/* second delta-x */\n\t\tms->ms_byteno = -1;\t/* wait for button-byte again */\n\t\tms->ms_dy += (char)c;\n\t\tbreak;\n\n\tdefault:\n\t\tpanic(\"ms_rint\");\n\t\t/* NOTREACHED */\n\t}\n\n\t/*\n\t * We have at least one event (mouse button, delta-X, or\n\t * delta-Y; possibly all three, and possibly three separate\n\t * button events).  Deliver these events until we are out\n\t * of changes or out of room.  As events get delivered,\n\t * mark them `unchanged'.\n\t */\n\tany = 0;\n\tget = ms->ms_events.ev_get;\n\tput = ms->ms_events.ev_put;\n\tfe = &ms->ms_events.ev_q[put];\n\n\t/* NEXT prepares to put the next event, backing off if necessary */\n#define\tNEXT \\\n\tif ((++put) % EV_QSIZE == get) { \\\n\t\tput--; \\\n\t\tgoto out; \\\n\t}\n\t/* ADVANCE completes the `put' of the event */\n#define\tADVANCE \\\n\tfe++; \\\n\tif (put >= EV_QSIZE) { \\\n\t\tput = 0; \\\n\t\tfe = &ms->ms_events.ev_q[0]; \\\n\t} \\\n\tany = 1\n\n\tmb = ms->ms_mb;\n\tub = ms->ms_ub;\n\twhile ((d = mb ^ ub) != 0) {\n\t\t/*\n\t\t * Mouse button change.  Convert up to three changes\n\t\t * to the `first' change, and drop it into the event queue.\n\t\t */\n\t\tNEXT;\n\t\td = to_one[d - 1];\t\t/* from 1..7 to {1,2,4} */\n\t\tfe->id = to_id[d - 1];\t\t/* from {1,2,4} to ID */\n\t\tfe->value = mb & d ? VKEY_DOWN : VKEY_UP;\n\t\tfe->time = time;\n\t\tADVANCE;\n\t\tub ^= d;\n\t}\n\tif (ms->ms_dx) {\n\t\tNEXT;\n\t\tfe->id = LOC_X_DELTA;\n\t\tfe->value = ms->ms_dx;\n\t\tfe->time = time;\n\t\tADVANCE;\n\t\tms->ms_dx = 0;\n\t}\n\tif (ms->ms_dy) {\n\t\tNEXT;\n\t\tfe->id = LOC_Y_DELTA;\n\t\tfe->value = ms->ms_dy;\n\t\tfe->time = time;\n\t\tADVANCE;\n\t\tms->ms_dy = 0;\n\t}\nout:\n\tif (any) {\n\t\tms->ms_ub = ub;\n\t\tms->ms_events.ev_put = put;\n\t\tEV_WAKEUP(&ms->ms_events);\n\t}\n}",
          "includes": [
            "#include \"event_var.h\"",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <machine/vuid_event.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tADVANCE \\\n\tfe++; \\\n\tif (put >= EV_QSIZE) { \\\n\t\tput = 0; \\\n\t\tfe = &ms->ms_events.ev_q[0]; \\\n\t} \\\n\tany = 1",
            "#define\tNEXT \\\n\tif ((++put) % EV_QSIZE == get) { \\\n\t\tput--; \\\n\t\tgoto out; \\\n\t}"
          ],
          "globals_used": [
            "static void ms_input"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"event_var.h\"\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <machine/vuid_event.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tADVANCE \\\n\tfe++; \\\n\tif (put >= EV_QSIZE) { \\\n\t\tput = 0; \\\n\t\tfe = &ms->ms_events.ev_q[0]; \\\n\t} \\\n\tany = 1\n#define\tNEXT \\\n\tif ((++put) % EV_QSIZE == get) { \\\n\t\tput--; \\\n\t\tgoto out; \\\n\t}\n\nstatic void ms_input;\n\nvoid\nms_input(ms, c)\n\tregister struct ms_softc *ms;\n\tregister int c;\n{\n\tregister struct firm_event *fe;\n\tregister int mb, ub, d, get, put, any;\n\tstatic const char to_one[] = { 1, 2, 2, 4, 4, 4, 4 };\n\tstatic const int to_id[] = { MS_RIGHT, MS_MIDDLE, 0, MS_LEFT };\n\n\t/*\n\t * Discard input if not ready.  Drop sync on parity or framing\n\t * error; gain sync on button byte.\n\t */\n\tif (ms->ms_ready == 0)\n\t\treturn;\n\tif (c == -1) {\n\t\tms->ms_byteno = -1;\n\t\treturn;\n\t}\n\tif ((c & ~7) == 0x80)\t/* if in 0x80..0x87 */\n\t\tms->ms_byteno = 0;\n\n\t/*\n\t * Run the decode loop, adding to the current information.\n\t * We add, rather than replace, deltas, so that if the event queue\n\t * fills, we accumulate data for when it opens up again.\n\t */\n\tswitch (ms->ms_byteno) {\n\n\tcase -1:\n\t\treturn;\n\n\tcase 0:\n\t\t/* buttons */\n\t\tms->ms_byteno = 1;\n\t\tms->ms_mb = (~c) & 0x7;\n\t\treturn;\n\n\tcase 1:\n\t\t/* first delta-x */\n\t\tms->ms_byteno = 2;\n\t\tms->ms_dx += (char)c;\n\t\treturn;\n\n\tcase 2:\n\t\t/* first delta-y */\n\t\tms->ms_byteno = 3;\n\t\tms->ms_dy += (char)c;\n\t\treturn;\n\n\tcase 3:\n\t\t/* second delta-x */\n\t\tms->ms_byteno = 4;\n\t\tms->ms_dx += (char)c;\n\t\treturn;\n\n\tcase 4:\n\t\t/* second delta-x */\n\t\tms->ms_byteno = -1;\t/* wait for button-byte again */\n\t\tms->ms_dy += (char)c;\n\t\tbreak;\n\n\tdefault:\n\t\tpanic(\"ms_rint\");\n\t\t/* NOTREACHED */\n\t}\n\n\t/*\n\t * We have at least one event (mouse button, delta-X, or\n\t * delta-Y; possibly all three, and possibly three separate\n\t * button events).  Deliver these events until we are out\n\t * of changes or out of room.  As events get delivered,\n\t * mark them `unchanged'.\n\t */\n\tany = 0;\n\tget = ms->ms_events.ev_get;\n\tput = ms->ms_events.ev_put;\n\tfe = &ms->ms_events.ev_q[put];\n\n\t/* NEXT prepares to put the next event, backing off if necessary */\n#define\tNEXT \\\n\tif ((++put) % EV_QSIZE == get) { \\\n\t\tput--; \\\n\t\tgoto out; \\\n\t}\n\t/* ADVANCE completes the `put' of the event */\n#define\tADVANCE \\\n\tfe++; \\\n\tif (put >= EV_QSIZE) { \\\n\t\tput = 0; \\\n\t\tfe = &ms->ms_events.ev_q[0]; \\\n\t} \\\n\tany = 1\n\n\tmb = ms->ms_mb;\n\tub = ms->ms_ub;\n\twhile ((d = mb ^ ub) != 0) {\n\t\t/*\n\t\t * Mouse button change.  Convert up to three changes\n\t\t * to the `first' change, and drop it into the event queue.\n\t\t */\n\t\tNEXT;\n\t\td = to_one[d - 1];\t\t/* from 1..7 to {1,2,4} */\n\t\tfe->id = to_id[d - 1];\t\t/* from {1,2,4} to ID */\n\t\tfe->value = mb & d ? VKEY_DOWN : VKEY_UP;\n\t\tfe->time = time;\n\t\tADVANCE;\n\t\tub ^= d;\n\t}\n\tif (ms->ms_dx) {\n\t\tNEXT;\n\t\tfe->id = LOC_X_DELTA;\n\t\tfe->value = ms->ms_dx;\n\t\tfe->time = time;\n\t\tADVANCE;\n\t\tms->ms_dx = 0;\n\t}\n\tif (ms->ms_dy) {\n\t\tNEXT;\n\t\tfe->id = LOC_Y_DELTA;\n\t\tfe->value = ms->ms_dy;\n\t\tfe->time = time;\n\t\tADVANCE;\n\t\tms->ms_dy = 0;\n\t}\nout:\n\tif (any) {\n\t\tms->ms_ub = ub;\n\t\tms->ms_events.ev_put = put;\n\t\tEV_WAKEUP(&ms->ms_events);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: input error (0x%x)\\n\"",
            "ms->ms_dev.dv_xname",
            "ring_data"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splzs",
          "args": [],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"event_var.h\"\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <machine/vuid_event.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define INTR_ST_CHECK   4\n#define INTR_TX_EMPTY   2\n#define\tINTR_RX_OVERRUN 1\n#define MS_RX_RING_MASK (MS_RX_RING_SIZE-1)\n\nstruct ms_softc {\n\tstruct\tdevice ms_dev;\t\t/* required first: base device */\n\tstruct\tzs_chanstate *ms_cs;\n\n\t/* Flags to communicate with ms_softintr() */\n\tvolatile int ms_intr_flags;\n#define\tINTR_RX_OVERRUN 1\n#define INTR_TX_EMPTY   2\n#define INTR_ST_CHECK   4\n\n\t/*\n\t * The receive ring buffer.\n\t */\n\tu_int\tms_rbget;\t/* ring buffer `get' index */\n\tvolatile u_int\tms_rbput;\t/* ring buffer `put' index */\n\tu_short\tms_rbuf[MS_RX_RING_SIZE]; /* rr1, data pairs */\n\n\t/*\n\t * State of input translator\n\t */\n\tshort\tms_byteno;\t\t/* input byte number, for decode */\n\tchar\tms_mb;\t\t\t/* mouse button state */\n\tchar\tms_ub;\t\t\t/* user button state */\n\tint\tms_dx;\t\t\t/* delta-x */\n\tint\tms_dy;\t\t\t/* delta-y */\n\n\t/*\n\t * State of upper interface.\n\t */\n\tvolatile int ms_ready;\t\t/* event queue is ready */\n\tstruct\tevvar ms_events;\t/* event queue state */\n} ms_softc;\nstatic void ms_input;\nstatic void ms_softint;\n\nstatic void\nms_softint(cs)\n\tstruct zs_chanstate *cs;\n{\n\tregister struct ms_softc *ms;\n\tregister int get, c, s;\n\tint intr_flags;\n\tregister u_short ring_data;\n\n\tms = cs->cs_private;\n\n\t/* Atomically get and clear flags. */\n\ts = splzs();\n\tintr_flags = ms->ms_intr_flags;\n\tms->ms_intr_flags = 0;\n\n\t/* Now lower to spltty for the rest. */\n\t(void) spltty();\n\n\t/*\n\t * Copy data from the receive ring to the event layer.\n\t */\n\tget = ms->ms_rbget;\n\twhile (get != ms->ms_rbput) {\n\t\tring_data = ms->ms_rbuf[get];\n\t\tget = (get + 1) & MS_RX_RING_MASK;\n\n\t\t/* low byte of ring_data is rr1 */\n\t\tc = (ring_data >> 8) & 0xff;\n\n\t\tif (ring_data & ZSRR1_DO)\n\t\t\tintr_flags |= INTR_RX_OVERRUN;\n\t\tif (ring_data & (ZSRR1_FE | ZSRR1_PE)) {\n\t\t\tlog(LOG_ERR, \"%s: input error (0x%x)\\n\",\n\t\t\t\tms->ms_dev.dv_xname, ring_data);\n\t\t\tc = -1;\t/* signal input error */\n\t\t}\n\n\t\t/* Pass this up to the \"middle\" layer. */\n\t\tms_input(ms, c);\n\t}\n\tif (intr_flags & INTR_RX_OVERRUN) {\n\t\tlog(LOG_ERR, \"%s: input overrun\\n\",\n\t\t    ms->ms_dev.dv_xname);\n\t}\n\tms->ms_rbget = get;\n\n\tif (intr_flags & INTR_TX_EMPTY) {\n\t\t/*\n\t\t * Transmit done.  (Not expected.)\n\t\t */\n\t\tlog(LOG_ERR, \"%s: transmit interrupt?\\n\",\n\t\t    ms->ms_dev.dv_xname);\n\t}\n\n\tif (intr_flags & INTR_ST_CHECK) {\n\t\t/*\n\t\t * Status line change.  (Not expected.)\n\t\t */\n\t\tlog(LOG_ERR, \"%s: status interrupt?\\n\",\n\t\t    ms->ms_dev.dv_xname);\n\t\tcs->cs_rr0_delta = 0;\n\t}\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "ms_stint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/ms.c",
    "lines": "551-576",
    "snippet": "static void\nms_stint(cs)\n\tregister struct zs_chanstate *cs;\n{\n\tregister struct ms_softc *ms;\n\tregister int rr0;\n\n\tms = cs->cs_private;\n\n\trr0 = zs_read_csr(cs);\n\tzs_write_csr(cs, ZSWR0_RESET_STATUS);\n\n\t/*\n\t * We have to accumulate status line changes here.\n\t * Otherwise, if we get multiple status interrupts\n\t * before the softint runs, we could fail to notice\n\t * some status line changes in the softint routine.\n\t * Fix from Bill Studenmund, October 1996.\n\t */\n\tcs->cs_rr0_delta |= (cs->cs_rr0 ^ rr0);\n\tcs->cs_rr0 = rr0;\n\tms->ms_intr_flags |= INTR_ST_CHECK;\n\n\t/* Ask for softint() call. */\n\tcs->cs_softreq = 1;\n}",
    "includes": [
      "#include \"event_var.h\"",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <machine/vuid_event.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define INTR_ST_CHECK   4"
    ],
    "globals_used": [
      "static void ms_stint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zs_write_csr",
          "args": [
            "cs",
            "ZSWR0_RESET_STATUS"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_read_csr",
          "args": [
            "cs"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"event_var.h\"\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <machine/vuid_event.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define INTR_ST_CHECK   4\n\nstatic void ms_stint;\n\nstatic void\nms_stint(cs)\n\tregister struct zs_chanstate *cs;\n{\n\tregister struct ms_softc *ms;\n\tregister int rr0;\n\n\tms = cs->cs_private;\n\n\trr0 = zs_read_csr(cs);\n\tzs_write_csr(cs, ZSWR0_RESET_STATUS);\n\n\t/*\n\t * We have to accumulate status line changes here.\n\t * Otherwise, if we get multiple status interrupts\n\t * before the softint runs, we could fail to notice\n\t * some status line changes in the softint routine.\n\t * Fix from Bill Studenmund, October 1996.\n\t */\n\tcs->cs_rr0_delta |= (cs->cs_rr0 ^ rr0);\n\tcs->cs_rr0 = rr0;\n\tms->ms_intr_flags |= INTR_ST_CHECK;\n\n\t/* Ask for softint() call. */\n\tcs->cs_softreq = 1;\n}"
  },
  {
    "function_name": "ms_txint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/ms.c",
    "lines": "537-548",
    "snippet": "static void\nms_txint(cs)\n\tregister struct zs_chanstate *cs;\n{\n\tregister struct ms_softc *ms;\n\n\tms = cs->cs_private;\n\tzs_write_csr(cs, ZSWR0_RESET_TXINT);\n\tms->ms_intr_flags |= INTR_TX_EMPTY;\n\t/* Ask for softint() call. */\n\tcs->cs_softreq = 1;\n}",
    "includes": [
      "#include \"event_var.h\"",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <machine/vuid_event.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define INTR_TX_EMPTY   2"
    ],
    "globals_used": [
      "static void ms_txint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zs_write_csr",
          "args": [
            "cs",
            "ZSWR0_RESET_TXINT"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"event_var.h\"\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <machine/vuid_event.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define INTR_TX_EMPTY   2\n\nstatic void ms_txint;\n\nstatic void\nms_txint(cs)\n\tregister struct zs_chanstate *cs;\n{\n\tregister struct ms_softc *ms;\n\n\tms = cs->cs_private;\n\tzs_write_csr(cs, ZSWR0_RESET_TXINT);\n\tms->ms_intr_flags |= INTR_TX_EMPTY;\n\t/* Ask for softint() call. */\n\tcs->cs_softreq = 1;\n}"
  },
  {
    "function_name": "ms_rxint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/ms.c",
    "lines": "495-534",
    "snippet": "static void\nms_rxint(cs)\n\tregister struct zs_chanstate *cs;\n{\n\tregister struct ms_softc *ms;\n\tregister int put, put_next;\n\tregister u_char c, rr1;\n\n\tms = cs->cs_private;\n\tput = ms->ms_rbput;\n\n\t/*\n\t * First read the status, because reading the received char\n\t * destroys the status of this char.\n\t */\n\trr1 = zs_read_reg(cs, 1);\n\tc = zs_read_data(cs);\n\n\tif (rr1 & (ZSRR1_FE | ZSRR1_DO | ZSRR1_PE)) {\n\t\t/* Clear the receive error. */\n\t\tzs_write_csr(cs, ZSWR0_RESET_ERRORS);\n\t}\n\n\tms->ms_rbuf[put] = (c << 8) | rr1;\n\tput_next = (put + 1) & MS_RX_RING_MASK;\n\n\t/* Would overrun if increment makes (put==get). */\n\tif (put_next == ms->ms_rbget) {\n\t\tms->ms_intr_flags |= INTR_RX_OVERRUN;\n\t} else {\n\t\t/* OK, really increment. */\n\t\tput = put_next;\n\t}\n\n\t/* Done reading. */\n\tms->ms_rbput = put;\n\n\t/* Ask for softint() call. */\n\tcs->cs_softreq = 1;\n}",
    "includes": [
      "#include \"event_var.h\"",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <machine/vuid_event.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tINTR_RX_OVERRUN 1",
      "#define MS_RX_RING_MASK (MS_RX_RING_SIZE-1)"
    ],
    "globals_used": [
      "struct ms_softc {\n\tstruct\tdevice ms_dev;\t\t/* required first: base device */\n\tstruct\tzs_chanstate *ms_cs;\n\n\t/* Flags to communicate with ms_softintr() */\n\tvolatile int ms_intr_flags;\n#define\tINTR_RX_OVERRUN 1\n#define INTR_TX_EMPTY   2\n#define INTR_ST_CHECK   4\n\n\t/*\n\t * The receive ring buffer.\n\t */\n\tu_int\tms_rbget;\t/* ring buffer `get' index */\n\tvolatile u_int\tms_rbput;\t/* ring buffer `put' index */\n\tu_short\tms_rbuf[MS_RX_RING_SIZE]; /* rr1, data pairs */\n\n\t/*\n\t * State of input translator\n\t */\n\tshort\tms_byteno;\t\t/* input byte number, for decode */\n\tchar\tms_mb;\t\t\t/* mouse button state */\n\tchar\tms_ub;\t\t\t/* user button state */\n\tint\tms_dx;\t\t\t/* delta-x */\n\tint\tms_dy;\t\t\t/* delta-y */\n\n\t/*\n\t * State of upper interface.\n\t */\n\tvolatile int ms_ready;\t\t/* event queue is ready */\n\tstruct\tevvar ms_events;\t/* event queue state */\n} ms_softc;",
      "static void ms_rxint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zs_write_csr",
          "args": [
            "cs",
            "ZSWR0_RESET_ERRORS"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_read_data",
          "args": [
            "cs"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_read_reg",
          "args": [
            "cs",
            "1"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"event_var.h\"\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <machine/vuid_event.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tINTR_RX_OVERRUN 1\n#define MS_RX_RING_MASK (MS_RX_RING_SIZE-1)\n\nstruct ms_softc {\n\tstruct\tdevice ms_dev;\t\t/* required first: base device */\n\tstruct\tzs_chanstate *ms_cs;\n\n\t/* Flags to communicate with ms_softintr() */\n\tvolatile int ms_intr_flags;\n#define\tINTR_RX_OVERRUN 1\n#define INTR_TX_EMPTY   2\n#define INTR_ST_CHECK   4\n\n\t/*\n\t * The receive ring buffer.\n\t */\n\tu_int\tms_rbget;\t/* ring buffer `get' index */\n\tvolatile u_int\tms_rbput;\t/* ring buffer `put' index */\n\tu_short\tms_rbuf[MS_RX_RING_SIZE]; /* rr1, data pairs */\n\n\t/*\n\t * State of input translator\n\t */\n\tshort\tms_byteno;\t\t/* input byte number, for decode */\n\tchar\tms_mb;\t\t\t/* mouse button state */\n\tchar\tms_ub;\t\t\t/* user button state */\n\tint\tms_dx;\t\t\t/* delta-x */\n\tint\tms_dy;\t\t\t/* delta-y */\n\n\t/*\n\t * State of upper interface.\n\t */\n\tvolatile int ms_ready;\t\t/* event queue is ready */\n\tstruct\tevvar ms_events;\t/* event queue state */\n} ms_softc;\nstatic void ms_rxint;\n\nstatic void\nms_rxint(cs)\n\tregister struct zs_chanstate *cs;\n{\n\tregister struct ms_softc *ms;\n\tregister int put, put_next;\n\tregister u_char c, rr1;\n\n\tms = cs->cs_private;\n\tput = ms->ms_rbput;\n\n\t/*\n\t * First read the status, because reading the received char\n\t * destroys the status of this char.\n\t */\n\trr1 = zs_read_reg(cs, 1);\n\tc = zs_read_data(cs);\n\n\tif (rr1 & (ZSRR1_FE | ZSRR1_DO | ZSRR1_PE)) {\n\t\t/* Clear the receive error. */\n\t\tzs_write_csr(cs, ZSWR0_RESET_ERRORS);\n\t}\n\n\tms->ms_rbuf[put] = (c << 8) | rr1;\n\tput_next = (put + 1) & MS_RX_RING_MASK;\n\n\t/* Would overrun if increment makes (put==get). */\n\tif (put_next == ms->ms_rbget) {\n\t\tms->ms_intr_flags |= INTR_RX_OVERRUN;\n\t} else {\n\t\t/* OK, really increment. */\n\t\tput = put_next;\n\t}\n\n\t/* Done reading. */\n\tms->ms_rbput = put;\n\n\t/* Ask for softint() call. */\n\tcs->cs_softreq = 1;\n}"
  },
  {
    "function_name": "ms_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/ms.c",
    "lines": "352-484",
    "snippet": "void\nms_input(ms, c)\n\tregister struct ms_softc *ms;\n\tregister int c;\n{\n\tregister struct firm_event *fe;\n\tregister int mb, ub, d, get, put, any;\n\tstatic const char to_one[] = { 1, 2, 2, 4, 4, 4, 4 };\n\tstatic const int to_id[] = { MS_RIGHT, MS_MIDDLE, 0, MS_LEFT };\n\n\t/*\n\t * Discard input if not ready.  Drop sync on parity or framing\n\t * error; gain sync on button byte.\n\t */\n\tif (ms->ms_ready == 0)\n\t\treturn;\n\tif (c == -1) {\n\t\tms->ms_byteno = -1;\n\t\treturn;\n\t}\n\tif ((c & ~7) == 0x80)\t/* if in 0x80..0x87 */\n\t\tms->ms_byteno = 0;\n\n\t/*\n\t * Run the decode loop, adding to the current information.\n\t * We add, rather than replace, deltas, so that if the event queue\n\t * fills, we accumulate data for when it opens up again.\n\t */\n\tswitch (ms->ms_byteno) {\n\n\tcase -1:\n\t\treturn;\n\n\tcase 0:\n\t\t/* buttons */\n\t\tms->ms_byteno = 1;\n\t\tms->ms_mb = (~c) & 0x7;\n\t\treturn;\n\n\tcase 1:\n\t\t/* first delta-x */\n\t\tms->ms_byteno = 2;\n\t\tms->ms_dx += (char)c;\n\t\treturn;\n\n\tcase 2:\n\t\t/* first delta-y */\n\t\tms->ms_byteno = 3;\n\t\tms->ms_dy += (char)c;\n\t\treturn;\n\n\tcase 3:\n\t\t/* second delta-x */\n\t\tms->ms_byteno = 4;\n\t\tms->ms_dx += (char)c;\n\t\treturn;\n\n\tcase 4:\n\t\t/* second delta-x */\n\t\tms->ms_byteno = -1;\t/* wait for button-byte again */\n\t\tms->ms_dy += (char)c;\n\t\tbreak;\n\n\tdefault:\n\t\tpanic(\"ms_rint\");\n\t\t/* NOTREACHED */\n\t}\n\n\t/*\n\t * We have at least one event (mouse button, delta-X, or\n\t * delta-Y; possibly all three, and possibly three separate\n\t * button events).  Deliver these events until we are out\n\t * of changes or out of room.  As events get delivered,\n\t * mark them `unchanged'.\n\t */\n\tany = 0;\n\tget = ms->ms_events.ev_get;\n\tput = ms->ms_events.ev_put;\n\tfe = &ms->ms_events.ev_q[put];\n\n\t/* NEXT prepares to put the next event, backing off if necessary */\n#define\tNEXT \\\n\tif ((++put) % EV_QSIZE == get) { \\\n\t\tput--; \\\n\t\tgoto out; \\\n\t}\n\t/* ADVANCE completes the `put' of the event */\n#define\tADVANCE \\\n\tfe++; \\\n\tif (put >= EV_QSIZE) { \\\n\t\tput = 0; \\\n\t\tfe = &ms->ms_events.ev_q[0]; \\\n\t} \\\n\tany = 1\n\n\tmb = ms->ms_mb;\n\tub = ms->ms_ub;\n\twhile ((d = mb ^ ub) != 0) {\n\t\t/*\n\t\t * Mouse button change.  Convert up to three changes\n\t\t * to the `first' change, and drop it into the event queue.\n\t\t */\n\t\tNEXT;\n\t\td = to_one[d - 1];\t\t/* from 1..7 to {1,2,4} */\n\t\tfe->id = to_id[d - 1];\t\t/* from {1,2,4} to ID */\n\t\tfe->value = mb & d ? VKEY_DOWN : VKEY_UP;\n\t\tfe->time = time;\n\t\tADVANCE;\n\t\tub ^= d;\n\t}\n\tif (ms->ms_dx) {\n\t\tNEXT;\n\t\tfe->id = LOC_X_DELTA;\n\t\tfe->value = ms->ms_dx;\n\t\tfe->time = time;\n\t\tADVANCE;\n\t\tms->ms_dx = 0;\n\t}\n\tif (ms->ms_dy) {\n\t\tNEXT;\n\t\tfe->id = LOC_Y_DELTA;\n\t\tfe->value = ms->ms_dy;\n\t\tfe->time = time;\n\t\tADVANCE;\n\t\tms->ms_dy = 0;\n\t}\nout:\n\tif (any) {\n\t\tms->ms_ub = ub;\n\t\tms->ms_events.ev_put = put;\n\t\tEV_WAKEUP(&ms->ms_events);\n\t}\n}",
    "includes": [
      "#include \"event_var.h\"",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <machine/vuid_event.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tADVANCE \\\n\tfe++; \\\n\tif (put >= EV_QSIZE) { \\\n\t\tput = 0; \\\n\t\tfe = &ms->ms_events.ev_q[0]; \\\n\t} \\\n\tany = 1",
      "#define\tNEXT \\\n\tif ((++put) % EV_QSIZE == get) { \\\n\t\tput--; \\\n\t\tgoto out; \\\n\t}"
    ],
    "globals_used": [
      "static void ms_input"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EV_WAKEUP",
          "args": [
            "&ms->ms_events"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ms_rint\""
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"event_var.h\"\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <machine/vuid_event.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tADVANCE \\\n\tfe++; \\\n\tif (put >= EV_QSIZE) { \\\n\t\tput = 0; \\\n\t\tfe = &ms->ms_events.ev_q[0]; \\\n\t} \\\n\tany = 1\n#define\tNEXT \\\n\tif ((++put) % EV_QSIZE == get) { \\\n\t\tput--; \\\n\t\tgoto out; \\\n\t}\n\nstatic void ms_input;\n\nvoid\nms_input(ms, c)\n\tregister struct ms_softc *ms;\n\tregister int c;\n{\n\tregister struct firm_event *fe;\n\tregister int mb, ub, d, get, put, any;\n\tstatic const char to_one[] = { 1, 2, 2, 4, 4, 4, 4 };\n\tstatic const int to_id[] = { MS_RIGHT, MS_MIDDLE, 0, MS_LEFT };\n\n\t/*\n\t * Discard input if not ready.  Drop sync on parity or framing\n\t * error; gain sync on button byte.\n\t */\n\tif (ms->ms_ready == 0)\n\t\treturn;\n\tif (c == -1) {\n\t\tms->ms_byteno = -1;\n\t\treturn;\n\t}\n\tif ((c & ~7) == 0x80)\t/* if in 0x80..0x87 */\n\t\tms->ms_byteno = 0;\n\n\t/*\n\t * Run the decode loop, adding to the current information.\n\t * We add, rather than replace, deltas, so that if the event queue\n\t * fills, we accumulate data for when it opens up again.\n\t */\n\tswitch (ms->ms_byteno) {\n\n\tcase -1:\n\t\treturn;\n\n\tcase 0:\n\t\t/* buttons */\n\t\tms->ms_byteno = 1;\n\t\tms->ms_mb = (~c) & 0x7;\n\t\treturn;\n\n\tcase 1:\n\t\t/* first delta-x */\n\t\tms->ms_byteno = 2;\n\t\tms->ms_dx += (char)c;\n\t\treturn;\n\n\tcase 2:\n\t\t/* first delta-y */\n\t\tms->ms_byteno = 3;\n\t\tms->ms_dy += (char)c;\n\t\treturn;\n\n\tcase 3:\n\t\t/* second delta-x */\n\t\tms->ms_byteno = 4;\n\t\tms->ms_dx += (char)c;\n\t\treturn;\n\n\tcase 4:\n\t\t/* second delta-x */\n\t\tms->ms_byteno = -1;\t/* wait for button-byte again */\n\t\tms->ms_dy += (char)c;\n\t\tbreak;\n\n\tdefault:\n\t\tpanic(\"ms_rint\");\n\t\t/* NOTREACHED */\n\t}\n\n\t/*\n\t * We have at least one event (mouse button, delta-X, or\n\t * delta-Y; possibly all three, and possibly three separate\n\t * button events).  Deliver these events until we are out\n\t * of changes or out of room.  As events get delivered,\n\t * mark them `unchanged'.\n\t */\n\tany = 0;\n\tget = ms->ms_events.ev_get;\n\tput = ms->ms_events.ev_put;\n\tfe = &ms->ms_events.ev_q[put];\n\n\t/* NEXT prepares to put the next event, backing off if necessary */\n#define\tNEXT \\\n\tif ((++put) % EV_QSIZE == get) { \\\n\t\tput--; \\\n\t\tgoto out; \\\n\t}\n\t/* ADVANCE completes the `put' of the event */\n#define\tADVANCE \\\n\tfe++; \\\n\tif (put >= EV_QSIZE) { \\\n\t\tput = 0; \\\n\t\tfe = &ms->ms_events.ev_q[0]; \\\n\t} \\\n\tany = 1\n\n\tmb = ms->ms_mb;\n\tub = ms->ms_ub;\n\twhile ((d = mb ^ ub) != 0) {\n\t\t/*\n\t\t * Mouse button change.  Convert up to three changes\n\t\t * to the `first' change, and drop it into the event queue.\n\t\t */\n\t\tNEXT;\n\t\td = to_one[d - 1];\t\t/* from 1..7 to {1,2,4} */\n\t\tfe->id = to_id[d - 1];\t\t/* from {1,2,4} to ID */\n\t\tfe->value = mb & d ? VKEY_DOWN : VKEY_UP;\n\t\tfe->time = time;\n\t\tADVANCE;\n\t\tub ^= d;\n\t}\n\tif (ms->ms_dx) {\n\t\tNEXT;\n\t\tfe->id = LOC_X_DELTA;\n\t\tfe->value = ms->ms_dx;\n\t\tfe->time = time;\n\t\tADVANCE;\n\t\tms->ms_dx = 0;\n\t}\n\tif (ms->ms_dy) {\n\t\tNEXT;\n\t\tfe->id = LOC_Y_DELTA;\n\t\tfe->value = ms->ms_dy;\n\t\tfe->time = time;\n\t\tADVANCE;\n\t\tms->ms_dy = 0;\n\t}\nout:\n\tif (any) {\n\t\tms->ms_ub = ub;\n\t\tms->ms_events.ev_put = put;\n\t\tEV_WAKEUP(&ms->ms_events);\n\t}\n}"
  },
  {
    "function_name": "msselect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/ms.c",
    "lines": "329-339",
    "snippet": "int\nmsselect(dev, rw, p)\n\tdev_t dev;\n\tint rw;\n\tstruct proc *p;\n{\n\tstruct ms_softc *ms;\n\n\tms = ms_cd.cd_devs[minor(dev)];\n\treturn (ev_select(&ms->ms_events, rw, p));\n}",
    "includes": [
      "#include \"event_var.h\"",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <machine/vuid_event.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver ms_cd = {\n\tNULL, \"ms\", DV_DULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ev_select",
          "args": [
            "&ms->ms_events",
            "rw",
            "p"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "ev_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/event.c",
          "lines": "148-173",
          "snippet": "int\nev_select(ev, rw, p)\n\tregister struct evvar *ev;\n\tint rw;\n\tstruct proc *p;\n{\n\tint s = splev();\n\n\tswitch (rw) {\n\n\tcase FREAD:\n\t\t/* succeed if there is something to read */\n\t\tif (ev->ev_get != ev->ev_put) {\n\t\t\tsplx(s);\n\t\t\treturn (1);\n\t\t}\n\t\tselrecord(p, &ev->ev_sel);\n\t\tbreak;\n\n\tcase FWRITE:\n\t\tsplx(s);\n\t\treturn (1);\t/* always fails => never blocks */\n\t}\n\tsplx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/sun/event_var.h>",
            "#include <machine/vuid_event.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/sun/event_var.h>\n#include <machine/vuid_event.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n\nint\nev_select(ev, rw, p)\n\tregister struct evvar *ev;\n\tint rw;\n\tstruct proc *p;\n{\n\tint s = splev();\n\n\tswitch (rw) {\n\n\tcase FREAD:\n\t\t/* succeed if there is something to read */\n\t\tif (ev->ev_get != ev->ev_put) {\n\t\t\tsplx(s);\n\t\t\treturn (1);\n\t\t}\n\t\tselrecord(p, &ev->ev_sel);\n\t\tbreak;\n\n\tcase FWRITE:\n\t\tsplx(s);\n\t\treturn (1);\t/* always fails => never blocks */\n\t}\n\tsplx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"event_var.h\"\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <machine/vuid_event.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct cfdriver ms_cd = {\n\tNULL, \"ms\", DV_DULL\n};\n\nint\nmsselect(dev, rw, p)\n\tdev_t dev;\n\tint rw;\n\tstruct proc *p;\n{\n\tstruct ms_softc *ms;\n\n\tms = ms_cd.cd_devs[minor(dev)];\n\treturn (ev_select(&ms->ms_events, rw, p));\n}"
  },
  {
    "function_name": "msioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/ms.c",
    "lines": "290-327",
    "snippet": "int\nmsioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tregister caddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct ms_softc *ms;\n\n\tms = ms_cd.cd_devs[minor(dev)];\n\n\tswitch (cmd) {\n\n\tcase FIONBIO:\t\t/* we will remove this someday (soon???) */\n\t\treturn (0);\n\n\tcase FIOASYNC:\n\t\tms->ms_events.ev_async = *(int *)data != 0;\n\t\treturn (0);\n\n\tcase TIOCSPGRP:\n\t\tif (*(int *)data != ms->ms_events.ev_io->p_pgid)\n\t\t\treturn (EPERM);\n\t\treturn (0);\n\n\tcase VUIDGFORMAT:\n\t\t/* we only do firm_events */\n\t\t*(int *)data = VUID_FIRM_EVENT;\n\t\treturn (0);\n\n\tcase VUIDSFORMAT:\n\t\tif (*(int *)data != VUID_FIRM_EVENT)\n\t\t\treturn (EINVAL);\n\t\treturn (0);\n\t}\n\treturn (ENOTTY);\n}",
    "includes": [
      "#include \"event_var.h\"",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <machine/vuid_event.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver ms_cd = {\n\tNULL, \"ms\", DV_DULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"event_var.h\"\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <machine/vuid_event.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct cfdriver ms_cd = {\n\tNULL, \"ms\", DV_DULL\n};\n\nint\nmsioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tregister caddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct ms_softc *ms;\n\n\tms = ms_cd.cd_devs[minor(dev)];\n\n\tswitch (cmd) {\n\n\tcase FIONBIO:\t\t/* we will remove this someday (soon???) */\n\t\treturn (0);\n\n\tcase FIOASYNC:\n\t\tms->ms_events.ev_async = *(int *)data != 0;\n\t\treturn (0);\n\n\tcase TIOCSPGRP:\n\t\tif (*(int *)data != ms->ms_events.ev_io->p_pgid)\n\t\t\treturn (EPERM);\n\t\treturn (0);\n\n\tcase VUIDGFORMAT:\n\t\t/* we only do firm_events */\n\t\t*(int *)data = VUID_FIRM_EVENT;\n\t\treturn (0);\n\n\tcase VUIDSFORMAT:\n\t\tif (*(int *)data != VUID_FIRM_EVENT)\n\t\t\treturn (EINVAL);\n\t\treturn (0);\n\t}\n\treturn (ENOTTY);\n}"
  },
  {
    "function_name": "mswrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/ms.c",
    "lines": "280-288",
    "snippet": "int\nmswrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\n\treturn (EOPNOTSUPP);\n}",
    "includes": [
      "#include \"event_var.h\"",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <machine/vuid_event.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"event_var.h\"\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <machine/vuid_event.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nmswrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\n\treturn (EOPNOTSUPP);\n}"
  },
  {
    "function_name": "msread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/ms.c",
    "lines": "267-277",
    "snippet": "int\nmsread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tstruct ms_softc *ms;\n\n\tms = ms_cd.cd_devs[minor(dev)];\n\treturn (ev_read(&ms->ms_events, uio, flags));\n}",
    "includes": [
      "#include \"event_var.h\"",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <machine/vuid_event.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver ms_cd = {\n\tNULL, \"ms\", DV_DULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ev_read",
          "args": [
            "&ms->ms_events",
            "uio",
            "flags"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "ev_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/event.c",
          "lines": "91-146",
          "snippet": "int\nev_read(ev, uio, flags)\n\tregister struct evvar *ev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint s, n, cnt, error;\n\n\t/*\n\t * Make sure we can return at least 1.\n\t */\n\tif (uio->uio_resid < sizeof(struct firm_event))\n\t\treturn (EMSGSIZE);\t/* ??? */\n\ts = splev();\n\twhile (ev->ev_get == ev->ev_put) {\n\t\tif (flags & IO_NDELAY) {\n\t\t\tsplx(s);\n\t\t\treturn (EWOULDBLOCK);\n\t\t}\n\t\tev->ev_wanted = 1;\n\t\terror = tsleep((caddr_t)ev, PEVENT | PCATCH, \"firm_event\", 0);\n\t\tif (error) {\n\t\t\tsplx(s);\n\t\t\treturn (error);\n\t\t}\n\t}\n\t/*\n\t * Move firm_events from tail end of queue (there is at least one\n\t * there).\n\t */\n\tif (ev->ev_put < ev->ev_get)\n\t\tcnt = EV_QSIZE - ev->ev_get;\t/* events in [get..QSIZE) */\n\telse\n\t\tcnt = ev->ev_put - ev->ev_get;\t/* events in [get..put) */\n\tsplx(s);\n\tn = howmany(uio->uio_resid, sizeof(struct firm_event));\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->ev_q[ev->ev_get],\n\t    cnt * sizeof(struct firm_event), uio);\n\tn -= cnt;\n\t/*\n\t * If we do not wrap to 0, used up all our space, or had an error,\n\t * stop.  Otherwise move from front of queue to put index, if there\n\t * is anything there to move.\n\t */\n\tif ((ev->ev_get = (ev->ev_get + cnt) % EV_QSIZE) != 0 ||\n\t    n == 0 || error || (cnt = ev->ev_put) == 0)\n\t\treturn (error);\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->ev_q[0],\n\t    cnt * sizeof(struct firm_event), uio);\n\tev->ev_get = cnt;\n\treturn (error);\n}",
          "includes": [
            "#include <dev/sun/event_var.h>",
            "#include <machine/vuid_event.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/sun/event_var.h>\n#include <machine/vuid_event.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n\nint\nev_read(ev, uio, flags)\n\tregister struct evvar *ev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint s, n, cnt, error;\n\n\t/*\n\t * Make sure we can return at least 1.\n\t */\n\tif (uio->uio_resid < sizeof(struct firm_event))\n\t\treturn (EMSGSIZE);\t/* ??? */\n\ts = splev();\n\twhile (ev->ev_get == ev->ev_put) {\n\t\tif (flags & IO_NDELAY) {\n\t\t\tsplx(s);\n\t\t\treturn (EWOULDBLOCK);\n\t\t}\n\t\tev->ev_wanted = 1;\n\t\terror = tsleep((caddr_t)ev, PEVENT | PCATCH, \"firm_event\", 0);\n\t\tif (error) {\n\t\t\tsplx(s);\n\t\t\treturn (error);\n\t\t}\n\t}\n\t/*\n\t * Move firm_events from tail end of queue (there is at least one\n\t * there).\n\t */\n\tif (ev->ev_put < ev->ev_get)\n\t\tcnt = EV_QSIZE - ev->ev_get;\t/* events in [get..QSIZE) */\n\telse\n\t\tcnt = ev->ev_put - ev->ev_get;\t/* events in [get..put) */\n\tsplx(s);\n\tn = howmany(uio->uio_resid, sizeof(struct firm_event));\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->ev_q[ev->ev_get],\n\t    cnt * sizeof(struct firm_event), uio);\n\tn -= cnt;\n\t/*\n\t * If we do not wrap to 0, used up all our space, or had an error,\n\t * stop.  Otherwise move from front of queue to put index, if there\n\t * is anything there to move.\n\t */\n\tif ((ev->ev_get = (ev->ev_get + cnt) % EV_QSIZE) != 0 ||\n\t    n == 0 || error || (cnt = ev->ev_put) == 0)\n\t\treturn (error);\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->ev_q[0],\n\t    cnt * sizeof(struct firm_event), uio);\n\tev->ev_get = cnt;\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"event_var.h\"\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <machine/vuid_event.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct cfdriver ms_cd = {\n\tNULL, \"ms\", DV_DULL\n};\n\nint\nmsread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tstruct ms_softc *ms;\n\n\tms = ms_cd.cd_devs[minor(dev)];\n\treturn (ev_read(&ms->ms_events, uio, flags));\n}"
  },
  {
    "function_name": "msclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/ms.c",
    "lines": "251-265",
    "snippet": "int\nmsclose(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct ms_softc *ms;\n\n\tms = ms_cd.cd_devs[minor(dev)];\n\tms->ms_ready = 0;\t\t/* stop accepting events */\n\tev_fini(&ms->ms_events);\n\n\tms->ms_events.ev_io = NULL;\n\treturn (0);\n}",
    "includes": [
      "#include \"event_var.h\"",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <machine/vuid_event.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver ms_cd = {\n\tNULL, \"ms\", DV_DULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ev_fini",
          "args": [
            "&ms->ms_events"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "ev_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/event.c",
          "lines": "79-85",
          "snippet": "void\nev_fini(ev)\n\tregister struct evvar *ev;\n{\n\n\tfree(ev->ev_q, M_DEVBUF);\n}",
          "includes": [
            "#include <dev/sun/event_var.h>",
            "#include <machine/vuid_event.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/sun/event_var.h>\n#include <machine/vuid_event.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n\nvoid\nev_fini(ev)\n\tregister struct evvar *ev;\n{\n\n\tfree(ev->ev_q, M_DEVBUF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"event_var.h\"\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <machine/vuid_event.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct cfdriver ms_cd = {\n\tNULL, \"ms\", DV_DULL\n};\n\nint\nmsclose(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct ms_softc *ms;\n\n\tms = ms_cd.cd_devs[minor(dev)];\n\tms->ms_ready = 0;\t\t/* stop accepting events */\n\tev_fini(&ms->ms_events);\n\n\tms->ms_events.ev_io = NULL;\n\treturn (0);\n}"
  },
  {
    "function_name": "msopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/ms.c",
    "lines": "225-249",
    "snippet": "int\nmsopen(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct ms_softc *ms;\n\tint unit;\n\n\tunit = minor(dev);\n\tif (unit >= ms_cd.cd_ndevs)\n\t\treturn (ENXIO);\n\tms = ms_cd.cd_devs[unit];\n\tif (ms == NULL)\n\t\treturn (ENXIO);\n\n\t/* This is an exclusive open device. */\n\tif (ms->ms_events.ev_io)\n\t\treturn (EBUSY);\n\tms->ms_events.ev_io = p;\n\tev_init(&ms->ms_events);\t/* may cause sleep */\n\n\tms->ms_ready = 1;\t\t/* start accepting events */\n\treturn (0);\n}",
    "includes": [
      "#include \"event_var.h\"",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <machine/vuid_event.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tms_match(struct device *, void *, void *);",
      "static void\tms_attach(struct device *, struct device *, void *);",
      "struct cfdriver ms_cd = {\n\tNULL, \"ms\", DV_DULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ev_init",
          "args": [
            "&ms->ms_events"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "ev_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/event.c",
          "lines": "65-74",
          "snippet": "void\nev_init(ev)\n\tregister struct evvar *ev;\n{\n\n\tev->ev_get = ev->ev_put = 0;\n\tev->ev_q = malloc((u_long)EV_QSIZE * sizeof(struct firm_event),\n\t    M_DEVBUF, M_WAITOK);\n\tbzero((caddr_t)ev->ev_q, EV_QSIZE * sizeof(struct firm_event));\n}",
          "includes": [
            "#include <dev/sun/event_var.h>",
            "#include <machine/vuid_event.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/sun/event_var.h>\n#include <machine/vuid_event.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n\nvoid\nev_init(ev)\n\tregister struct evvar *ev;\n{\n\n\tev->ev_get = ev->ev_put = 0;\n\tev->ev_q = malloc((u_long)EV_QSIZE * sizeof(struct firm_event),\n\t    M_DEVBUF, M_WAITOK);\n\tbzero((caddr_t)ev->ev_q, EV_QSIZE * sizeof(struct firm_event));\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"event_var.h\"\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <machine/vuid_event.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\tms_match(struct device *, void *, void *);\nstatic void\tms_attach(struct device *, struct device *, void *);\nstruct cfdriver ms_cd = {\n\tNULL, \"ms\", DV_DULL\n};\n\nint\nmsopen(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct ms_softc *ms;\n\tint unit;\n\n\tunit = minor(dev);\n\tif (unit >= ms_cd.cd_ndevs)\n\t\treturn (ENXIO);\n\tms = ms_cd.cd_devs[unit];\n\tif (ms == NULL)\n\t\treturn (ENXIO);\n\n\t/* This is an exclusive open device. */\n\tif (ms->ms_events.ev_io)\n\t\treturn (EBUSY);\n\tms->ms_events.ev_io = p;\n\tev_init(&ms->ms_events);\t/* may cause sleep */\n\n\tms->ms_ready = 1;\t\t/* start accepting events */\n\treturn (0);\n}"
  },
  {
    "function_name": "ms_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/ms.c",
    "lines": "179-218",
    "snippet": "void \nms_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid   *aux;\n\n{\n\tstruct zsc_softc *zsc = (void *) parent;\n\tstruct ms_softc *ms = (void *) self;\n\tstruct zsc_attach_args *args = aux;\n\tstruct zs_chanstate *cs;\n\tstruct cfdata *cf;\n\tint channel, ms_unit;\n\tint reset, s;\n\n\tcf = ms->ms_dev.dv_cfdata;\n\tms_unit = ms->ms_dev.dv_unit;\n\tchannel = args->channel;\n\tcs = zsc->zsc_cs[channel];\n\tcs->cs_private = ms;\n\tcs->cs_ops = &zsops_ms;\n\tms->ms_cs = cs;\n\n\tprintf(\"\\n\");\n\n\t/* Initialize the speed, etc. */\n\ts = splzs();\n\t/* May need reset... */\n\treset = (channel == 0) ?\n\t\tZSWR9_A_RESET : ZSWR9_B_RESET;\n\tzs_write_reg(cs, 9, reset);\n\t/* These are OK as set by zscc: WR3, WR4, WR5 */\n\t/* We don't care about status or tx interrupts. */\n\tcs->cs_preg[1] = ZSWR1_RIE;\n\t(void) zs_set_speed(cs, MS_BPS);\n\tzs_loadchannelregs(cs);\n\tsplx(s);\n\n\t/* Initialize translator. */\n\tms->ms_byteno = -1;\n}",
    "includes": [
      "#include \"event_var.h\"",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <machine/vuid_event.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MS_BPS 1200"
    ],
    "globals_used": [
      "struct zsops zsops_ms;",
      "static int\tms_match(struct device *, void *, void *);",
      "static void\tms_attach(struct device *, struct device *, void *);",
      "struct zsops zsops_ms = {\n\tms_rxint,\t/* receive char available */\n\tms_stint,\t/* external/status */\n\tms_txint,\t/* xmit buffer empty */\n\tms_softint,\t/* process software interrupt */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_loadchannelregs",
          "args": [
            "cs"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "zs_loadchannelregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530sc.c",
          "lines": "144-207",
          "snippet": "void\nzs_loadchannelregs(cs)\n\tstruct zs_chanstate *cs;\n{\n\tu_char *reg;\n\n\t/* Copy \"pending\" regs to \"current\" */\n\tbcopy((caddr_t)cs->cs_preg, (caddr_t)cs->cs_creg, 16);\n\treg = cs->cs_creg;\t/* current regs */\n\n\tzs_write_csr(cs, ZSM_RESET_ERR);\t/* XXX: reset error condition */\n\n#if 1\n\t/*\n\t * XXX: Is this really a good idea?\n\t * XXX: Should go elsewhere! -gwr\n\t */\n\tzs_iflush(cs);\t/* XXX */\n#endif\n\n\t/* baud clock divisor, stop bits, parity */\n\tzs_write_reg(cs, 4, reg[4]);\n\n\t/* misc. TX/RX control bits */\n\tzs_write_reg(cs, 10, reg[10]);\n\n\t/* char size, enable (RX/TX) */\n\tzs_write_reg(cs, 3, reg[3] & ~ZSWR3_RX_ENABLE);\n\tzs_write_reg(cs, 5, reg[5] & ~ZSWR5_TX_ENABLE);\n\n\t/* interrupt enables: TX, TX, STATUS */\n\tzs_write_reg(cs, 1, reg[1]);\n\n#if 0\n\t/*\n\t * Registers 2 and 9 are special because they are\n\t * actually common to both channels, but must be\n\t * programmed through channel A.  The \"zsc\" attach\n\t * function takes care of setting these registers\n\t * and they should not be touched thereafter.\n\t */\n\t/* interrupt vector */\n\tzs_write_reg(cs, 2, reg[2]);\n\t/* master interrupt control */\n\tzs_write_reg(cs, 9, reg[9]);\n#endif\n\n\t/* clock mode control */\n\tzs_write_reg(cs, 11, reg[11]);\n\n\t/* baud rate (lo/hi) */\n\tzs_write_reg(cs, 12, reg[12]);\n\tzs_write_reg(cs, 13, reg[13]);\n\n\t/* Misc. control bits */\n\tzs_write_reg(cs, 14, reg[14]);\n\n\t/* which lines cause status interrupts */\n\tzs_write_reg(cs, 15, reg[15]);\n\n\t/* char size, enable (RX/TX)*/\n\tzs_write_reg(cs, 3, reg[3]);\n\tzs_write_reg(cs, 5, reg[5]);\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nzs_loadchannelregs(cs)\n\tstruct zs_chanstate *cs;\n{\n\tu_char *reg;\n\n\t/* Copy \"pending\" regs to \"current\" */\n\tbcopy((caddr_t)cs->cs_preg, (caddr_t)cs->cs_creg, 16);\n\treg = cs->cs_creg;\t/* current regs */\n\n\tzs_write_csr(cs, ZSM_RESET_ERR);\t/* XXX: reset error condition */\n\n#if 1\n\t/*\n\t * XXX: Is this really a good idea?\n\t * XXX: Should go elsewhere! -gwr\n\t */\n\tzs_iflush(cs);\t/* XXX */\n#endif\n\n\t/* baud clock divisor, stop bits, parity */\n\tzs_write_reg(cs, 4, reg[4]);\n\n\t/* misc. TX/RX control bits */\n\tzs_write_reg(cs, 10, reg[10]);\n\n\t/* char size, enable (RX/TX) */\n\tzs_write_reg(cs, 3, reg[3] & ~ZSWR3_RX_ENABLE);\n\tzs_write_reg(cs, 5, reg[5] & ~ZSWR5_TX_ENABLE);\n\n\t/* interrupt enables: TX, TX, STATUS */\n\tzs_write_reg(cs, 1, reg[1]);\n\n#if 0\n\t/*\n\t * Registers 2 and 9 are special because they are\n\t * actually common to both channels, but must be\n\t * programmed through channel A.  The \"zsc\" attach\n\t * function takes care of setting these registers\n\t * and they should not be touched thereafter.\n\t */\n\t/* interrupt vector */\n\tzs_write_reg(cs, 2, reg[2]);\n\t/* master interrupt control */\n\tzs_write_reg(cs, 9, reg[9]);\n#endif\n\n\t/* clock mode control */\n\tzs_write_reg(cs, 11, reg[11]);\n\n\t/* baud rate (lo/hi) */\n\tzs_write_reg(cs, 12, reg[12]);\n\tzs_write_reg(cs, 13, reg[13]);\n\n\t/* Misc. control bits */\n\tzs_write_reg(cs, 14, reg[14]);\n\n\t/* which lines cause status interrupts */\n\tzs_write_reg(cs, 15, reg[15]);\n\n\t/* char size, enable (RX/TX)*/\n\tzs_write_reg(cs, 3, reg[3]);\n\tzs_write_reg(cs, 5, reg[5]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zs_set_speed",
          "args": [
            "cs",
            "MS_BPS"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "9",
            "reset"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splzs",
          "args": [],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"event_var.h\"\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <machine/vuid_event.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MS_BPS 1200\n\nstruct zsops zsops_ms;\nstatic int\tms_match(struct device *, void *, void *);\nstatic void\tms_attach(struct device *, struct device *, void *);\nstruct zsops zsops_ms = {\n\tms_rxint,\t/* receive char available */\n\tms_stint,\t/* external/status */\n\tms_txint,\t/* xmit buffer empty */\n\tms_softint,\t/* process software interrupt */\n};\n\nvoid \nms_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid   *aux;\n\n{\n\tstruct zsc_softc *zsc = (void *) parent;\n\tstruct ms_softc *ms = (void *) self;\n\tstruct zsc_attach_args *args = aux;\n\tstruct zs_chanstate *cs;\n\tstruct cfdata *cf;\n\tint channel, ms_unit;\n\tint reset, s;\n\n\tcf = ms->ms_dev.dv_cfdata;\n\tms_unit = ms->ms_dev.dv_unit;\n\tchannel = args->channel;\n\tcs = zsc->zsc_cs[channel];\n\tcs->cs_private = ms;\n\tcs->cs_ops = &zsops_ms;\n\tms->ms_cs = cs;\n\n\tprintf(\"\\n\");\n\n\t/* Initialize the speed, etc. */\n\ts = splzs();\n\t/* May need reset... */\n\treset = (channel == 0) ?\n\t\tZSWR9_A_RESET : ZSWR9_B_RESET;\n\tzs_write_reg(cs, 9, reset);\n\t/* These are OK as set by zscc: WR3, WR4, WR5 */\n\t/* We don't care about status or tx interrupts. */\n\tcs->cs_preg[1] = ZSWR1_RIE;\n\t(void) zs_set_speed(cs, MS_BPS);\n\tzs_loadchannelregs(cs);\n\tsplx(s);\n\n\t/* Initialize translator. */\n\tms->ms_byteno = -1;\n}"
  },
  {
    "function_name": "ms_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/ms.c",
    "lines": "164-177",
    "snippet": "int \nms_match(parent, vcf, aux)\n\tstruct device *parent;\n\tvoid *vcf, *aux;\n{\n\tstruct cfdata *cf = vcf;\n\tstruct zsc_attach_args *args = aux;\n\n\t/* Exact match required for keyboard. */\n\tif (cf->cf_loc[0] == args->channel)\n\t\treturn 2;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"event_var.h\"",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <machine/vuid_event.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tms_match(struct device *, void *, void *);",
      "static void\tms_attach(struct device *, struct device *, void *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"event_var.h\"\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <machine/vuid_event.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\tms_match(struct device *, void *, void *);\nstatic void\tms_attach(struct device *, struct device *, void *);\n\nint \nms_match(parent, vcf, aux)\n\tstruct device *parent;\n\tvoid *vcf, *aux;\n{\n\tstruct cfdata *cf = vcf;\n\tstruct zsc_attach_args *args = aux;\n\n\t/* Exact match required for keyboard. */\n\tif (cf->cf_loc[0] == args->channel)\n\t\treturn 2;\n\n\treturn 0;\n}"
  }
]