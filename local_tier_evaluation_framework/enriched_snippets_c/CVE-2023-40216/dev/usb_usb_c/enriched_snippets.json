[
  {
    "function_name": "usb_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
    "lines": "768-774",
    "snippet": "int\nusb_detach(device_t self)\n{\n\tDPRINTF((\"%s: unload, prevented\\n\", USBDEVNAME(self)));\n\n\treturn (EINVAL);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <machine/bus.h>",
      "#include \"usb_if.h\"",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/vnode.h>",
      "#include <sys/select.h>",
      "#include <sys/poll.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/filio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/kthread.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: unload, prevented\\n\", USBDEVNAME(self))"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "self"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nusb_detach(device_t self)\n{\n\tDPRINTF((\"%s: unload, prevented\\n\", USBDEVNAME(self)));\n\n\treturn (EINVAL);\n}"
  },
  {
    "function_name": "usb_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
    "lines": "735-766",
    "snippet": "int\nusb_detach(self, flags)\n\tdevice_ptr_t self;\n\tint flags;\n{\n\tstruct usb_softc *sc = (struct usb_softc *)self;\n\tstruct usb_event ue;\n\n\tDPRINTF((\"usb_detach: start\\n\"));\n\n\tsc->sc_dying = 1;\n\n\t/* Make all devices disconnect. */\n\tif (sc->sc_port.device)\n\t\tusb_disconnect_port(&sc->sc_port, self);\n\n\t/* Kill off event thread. */\n\tif (sc->sc_event_thread) {\n\t\twakeup(&sc->sc_bus->needs_explore);\n\t\tif (tsleep(sc, PWAIT, \"usbdet\", hz * 60))\n\t\t\tprintf(\"%s: event thread didn't die\\n\",\n\t\t\t       USBDEVNAME(sc->sc_dev));\n\t\tDPRINTF((\"usb_detach: event thread dead\\n\"));\n\t}\n\n\tusbd_finish();\n\n\tue.u.ue_ctrlr.ue_bus = USBDEVUNIT(sc->sc_dev);\n\tusb_add_event(USB_EVENT_CTRLR_DETACH, &ue);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <machine/bus.h>",
      "#include \"usb_if.h\"",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/vnode.h>",
      "#include <sys/select.h>",
      "#include <sys/poll.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/filio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/kthread.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usb_discover __P((struct usb_softc *));",
      "Static struct",
      "Static struct",
      "usb_add_event __P((int, struct usb_event *));",
      "usb_get_next_event __P((struct usb_event *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_add_event",
          "args": [
            "USB_EVENT_CTRLR_DETACH",
            "&ue"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "usb_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
          "lines": "672-701",
          "snippet": "Static void\nusb_add_event(type, uep)\n\tint type;\n\tstruct usb_event *uep;\n{\n\tstruct usb_event_q *ueq;\n\tstruct usb_event ue;\n\tstruct timeval thetime;\n\tint s;\n\n\tmicrotime(&thetime);\n\t/* Don't want to wait here inside splusb() */\n\tueq = malloc(sizeof *ueq, M_USBDEV, M_WAITOK);\n\tueq->ue = *uep;\n\tueq->ue.ue_type = type;\n\tTIMEVAL_TO_TIMESPEC(&thetime, &ueq->ue.ue_time);\n\n\ts = splusb();\n\tif (++usb_nevents >= USB_MAX_EVENTS) {\n\t\t/* Too many queued events, drop an old one. */\n\t\tDPRINTFN(-1,(\"usb: event dropped\\n\"));\n\t\t(void)usb_get_next_event(&ue);\n\t}\n\tSIMPLEQ_INSERT_TAIL(&usb_events, ueq, next);\n\twakeup(&usb_events);\n\tselwakeup(&usb_selevent);\n\tif (usb_async_proc != NULL)\n\t\tpsignal(usb_async_proc, SIGIO);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <machine/bus.h>",
            "#include \"usb_if.h\"",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/vnode.h>",
            "#include <sys/select.h>",
            "#include <sys/poll.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/filio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/proc.h>",
            "#include <sys/kthread.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define USB_MAX_EVENTS 100"
          ],
          "globals_used": [
            "Static void",
            "Static void",
            "Static SIMPLEQ_HEAD(, usb_event_q) usb_events = \n\tSIMPLEQ_HEAD_INITIALIZER(usb_events);",
            "Static int usb_nevents = 0;",
            "Static struct",
            "selinfo usb_selevent;",
            "Static struct",
            "proc *usb_async_proc;",
            "Static void",
            "usb_add_event __P((int, struct usb_event *));",
            "Static int",
            "usb_get_next_event __P((struct usb_event *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define USB_MAX_EVENTS 100\n\nStatic void;\nStatic void;\nStatic SIMPLEQ_HEAD(, usb_event_q) usb_events = \n\tSIMPLEQ_HEAD_INITIALIZER(usb_events);\nStatic int usb_nevents = 0;\nStatic struct;\nselinfo usb_selevent;\nStatic struct;\nproc *usb_async_proc;\nStatic void;\nusb_add_event __P((int, struct usb_event *));\nStatic int;\nusb_get_next_event __P((struct usb_event *));\n\nStatic void\nusb_add_event(type, uep)\n\tint type;\n\tstruct usb_event *uep;\n{\n\tstruct usb_event_q *ueq;\n\tstruct usb_event ue;\n\tstruct timeval thetime;\n\tint s;\n\n\tmicrotime(&thetime);\n\t/* Don't want to wait here inside splusb() */\n\tueq = malloc(sizeof *ueq, M_USBDEV, M_WAITOK);\n\tueq->ue = *uep;\n\tueq->ue.ue_type = type;\n\tTIMEVAL_TO_TIMESPEC(&thetime, &ueq->ue.ue_time);\n\n\ts = splusb();\n\tif (++usb_nevents >= USB_MAX_EVENTS) {\n\t\t/* Too many queued events, drop an old one. */\n\t\tDPRINTFN(-1,(\"usb: event dropped\\n\"));\n\t\t(void)usb_get_next_event(&ue);\n\t}\n\tSIMPLEQ_INSERT_TAIL(&usb_events, ueq, next);\n\twakeup(&usb_events);\n\tselwakeup(&usb_selevent);\n\tif (usb_async_proc != NULL)\n\t\tpsignal(usb_async_proc, SIGIO);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVUNIT",
          "args": [
            "sc->sc_dev"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_finish",
          "args": [],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "95-99",
          "snippet": "void\nusbd_finish()\n{\n\t--usbd_nbuses;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static int usbd_nbuses = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic int usbd_nbuses = 0;\n\nvoid\nusbd_finish()\n{\n\t--usbd_nbuses;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usb_detach: event thread dead\\n\")"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: event thread didn't die\\n\"",
            "USBDEVNAME(sc->sc_dev)"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "sc",
            "PWAIT",
            "\"usbdet\"",
            "hz * 60"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&sc->sc_bus->needs_explore"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usb_disconnect_port",
          "args": [
            "&sc->sc_port",
            "self"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "usb_disconnect_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "1271-1312",
          "snippet": "void\nusb_disconnect_port(up, parent)\n\tstruct usbd_port *up;\n\tdevice_ptr_t parent;\n{\n\tusbd_device_handle dev = up->device;\n\tchar *hubname = USBDEVPTRNAME(parent);\n\tint i;\n\n\tDPRINTFN(3,(\"uhub_disconnect: up=%p dev=%p port=%d\\n\", \n\t\t    up, dev, up->portno));\n\n#ifdef DIAGNOSTIC\n\tif (dev == NULL) {\n\t\tprintf(\"usb_disconnect_port: no device\\n\");\n\t\treturn;\n\t}\n#endif\n\n\tif (dev->subdevs != NULL) {\n\t\tDPRINTFN(3,(\"usb_disconnect_port: disconnect subdevs\\n\"));\n\t\tfor (i = 0; dev->subdevs[i]; i++) {\n\t\t\tprintf(\"%s: at %s\", USBDEVPTRNAME(dev->subdevs[i]), \n\t\t\t       hubname);\n\t\t\tif (up->portno != 0)\n\t\t\t\tprintf(\" port %d\", up->portno);\n\t\t\tprintf(\" (addr %d) disconnected\\n\", dev->address);\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\t\t\tconfig_detach(dev->subdevs[i], DETACH_FORCE);\n#elif defined(__FreeBSD__)\n                        device_delete_child(device_get_parent(dev->subdevs[i]),\n\t\t\t\t\t    dev->subdevs[i]);\n#endif\n\n\t\t}\n\t}\n\n\tusbd_add_dev_event(USB_EVENT_DEVICE_DETACH, dev);\n\tdev->bus->devices[dev->address] = NULL;\n\tup->device = NULL;\n\tusb_free_device(dev);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "usbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nusbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusb_disconnect_port(up, parent)\n\tstruct usbd_port *up;\n\tdevice_ptr_t parent;\n{\n\tusbd_device_handle dev = up->device;\n\tchar *hubname = USBDEVPTRNAME(parent);\n\tint i;\n\n\tDPRINTFN(3,(\"uhub_disconnect: up=%p dev=%p port=%d\\n\", \n\t\t    up, dev, up->portno));\n\n#ifdef DIAGNOSTIC\n\tif (dev == NULL) {\n\t\tprintf(\"usb_disconnect_port: no device\\n\");\n\t\treturn;\n\t}\n#endif\n\n\tif (dev->subdevs != NULL) {\n\t\tDPRINTFN(3,(\"usb_disconnect_port: disconnect subdevs\\n\"));\n\t\tfor (i = 0; dev->subdevs[i]; i++) {\n\t\t\tprintf(\"%s: at %s\", USBDEVPTRNAME(dev->subdevs[i]), \n\t\t\t       hubname);\n\t\t\tif (up->portno != 0)\n\t\t\t\tprintf(\" port %d\", up->portno);\n\t\t\tprintf(\" (addr %d) disconnected\\n\", dev->address);\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\t\t\tconfig_detach(dev->subdevs[i], DETACH_FORCE);\n#elif defined(__FreeBSD__)\n                        device_delete_child(device_get_parent(dev->subdevs[i]),\n\t\t\t\t\t    dev->subdevs[i]);\n#endif\n\n\t\t}\n\t}\n\n\tusbd_add_dev_event(USB_EVENT_DEVICE_DETACH, dev);\n\tdev->bus->devices[dev->address] = NULL;\n\tup->device = NULL;\n\tusb_free_device(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usb_detach: start\\n\")"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusb_discover __P((struct usb_softc *));\nStatic struct;\nStatic struct;\nusb_add_event __P((int, struct usb_event *));\nusb_get_next_event __P((struct usb_event *));\n\nint\nusb_detach(self, flags)\n\tdevice_ptr_t self;\n\tint flags;\n{\n\tstruct usb_softc *sc = (struct usb_softc *)self;\n\tstruct usb_event ue;\n\n\tDPRINTF((\"usb_detach: start\\n\"));\n\n\tsc->sc_dying = 1;\n\n\t/* Make all devices disconnect. */\n\tif (sc->sc_port.device)\n\t\tusb_disconnect_port(&sc->sc_port, self);\n\n\t/* Kill off event thread. */\n\tif (sc->sc_event_thread) {\n\t\twakeup(&sc->sc_bus->needs_explore);\n\t\tif (tsleep(sc, PWAIT, \"usbdet\", hz * 60))\n\t\t\tprintf(\"%s: event thread didn't die\\n\",\n\t\t\t       USBDEVNAME(sc->sc_dev));\n\t\tDPRINTF((\"usb_detach: event thread dead\\n\"));\n\t}\n\n\tusbd_finish();\n\n\tue.u.ue_ctrlr.ue_bus = USBDEVUNIT(sc->sc_dev);\n\tusb_add_event(USB_EVENT_CTRLR_DETACH, &ue);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "usb_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
    "lines": "710-733",
    "snippet": "int\nusb_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct usb_softc *sc = (struct usb_softc *)self;\n\tusbd_device_handle dev = sc->sc_port.device;\n\tint i, rv = 0;\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tsc->sc_dying = 1;\n\t\tif (dev && dev->cdesc && dev->subdevs) {\n\t\t\tfor (i = 0; dev->subdevs[i]; i++)\n\t\t\t\trv |= config_deactivate(dev->subdevs[i]);\n\t\t}\n\t\tbreak;\n\t}\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <machine/bus.h>",
      "#include \"usb_if.h\"",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/vnode.h>",
      "#include <sys/select.h>",
      "#include <sys/poll.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/filio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/kthread.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usb_discover __P((struct usb_softc *));",
      "Static struct",
      "Static struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_deactivate",
          "args": [
            "dev->subdevs[i]"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusb_discover __P((struct usb_softc *));\nStatic struct;\nStatic struct;\n\nint\nusb_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct usb_softc *sc = (struct usb_softc *)self;\n\tusbd_device_handle dev = sc->sc_port.device;\n\tint i, rv = 0;\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tsc->sc_dying = 1;\n\t\tif (dev && dev->cdesc && dev->subdevs) {\n\t\t\tfor (i = 0; dev->subdevs[i]; i++)\n\t\t\t\trv |= config_deactivate(dev->subdevs[i]);\n\t\t}\n\t\tbreak;\n\t}\n\treturn (rv);\n}"
  },
  {
    "function_name": "usb_schedsoftintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
    "lines": "702-707",
    "snippet": "void\nusb_schedsoftintr(bus)\n\tstruct usbd_bus *bus;\n{\n\tbus->methods->soft_intr(bus);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <machine/bus.h>",
      "#include \"usb_if.h\"",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/vnode.h>",
      "#include <sys/select.h>",
      "#include <sys/poll.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/filio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/kthread.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus->methods->soft_intr",
          "args": [
            "bus"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nStatic struct;\n\nvoid\nusb_schedsoftintr(bus)\n\tstruct usbd_bus *bus;\n{\n\tbus->methods->soft_intr(bus);\n}"
  },
  {
    "function_name": "usb_add_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
    "lines": "672-701",
    "snippet": "Static void\nusb_add_event(type, uep)\n\tint type;\n\tstruct usb_event *uep;\n{\n\tstruct usb_event_q *ueq;\n\tstruct usb_event ue;\n\tstruct timeval thetime;\n\tint s;\n\n\tmicrotime(&thetime);\n\t/* Don't want to wait here inside splusb() */\n\tueq = malloc(sizeof *ueq, M_USBDEV, M_WAITOK);\n\tueq->ue = *uep;\n\tueq->ue.ue_type = type;\n\tTIMEVAL_TO_TIMESPEC(&thetime, &ueq->ue.ue_time);\n\n\ts = splusb();\n\tif (++usb_nevents >= USB_MAX_EVENTS) {\n\t\t/* Too many queued events, drop an old one. */\n\t\tDPRINTFN(-1,(\"usb: event dropped\\n\"));\n\t\t(void)usb_get_next_event(&ue);\n\t}\n\tSIMPLEQ_INSERT_TAIL(&usb_events, ueq, next);\n\twakeup(&usb_events);\n\tselwakeup(&usb_selevent);\n\tif (usb_async_proc != NULL)\n\t\tpsignal(usb_async_proc, SIGIO);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <machine/bus.h>",
      "#include \"usb_if.h\"",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/vnode.h>",
      "#include <sys/select.h>",
      "#include <sys/poll.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/filio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/kthread.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define USB_MAX_EVENTS 100"
    ],
    "globals_used": [
      "Static void",
      "Static void",
      "Static SIMPLEQ_HEAD(, usb_event_q) usb_events = \n\tSIMPLEQ_HEAD_INITIALIZER(usb_events);",
      "Static int usb_nevents = 0;",
      "Static struct",
      "selinfo usb_selevent;",
      "Static struct",
      "proc *usb_async_proc;",
      "Static void",
      "usb_add_event __P((int, struct usb_event *));",
      "Static int",
      "usb_get_next_event __P((struct usb_event *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psignal",
          "args": [
            "usb_async_proc",
            "SIGIO"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selwakeup",
          "args": [
            "&usb_selevent"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&usb_events"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INSERT_TAIL",
          "args": [
            "&usb_events",
            "ueq",
            "next"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_get_next_event",
          "args": [
            "&ue"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "usb_get_next_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
          "lines": "631-645",
          "snippet": "int\nusb_get_next_event(ue)\n\tstruct usb_event *ue;\n{\n\tstruct usb_event_q *ueq;\n\n\tif (usb_nevents <= 0)\n\t\treturn (0);\n\tueq = SIMPLEQ_FIRST(&usb_events);\n\t*ue = ueq->ue;\n\tSIMPLEQ_REMOVE_HEAD(&usb_events, ueq, next);\n\tfree(ueq, M_USBDEV);\n\tusb_nevents--;\n\treturn (1);\n}",
          "includes": [
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <machine/bus.h>",
            "#include \"usb_if.h\"",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/vnode.h>",
            "#include <sys/select.h>",
            "#include <sys/poll.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/filio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/proc.h>",
            "#include <sys/kthread.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static SIMPLEQ_HEAD(, usb_event_q) usb_events = \n\tSIMPLEQ_HEAD_INITIALIZER(usb_events);",
            "Static int usb_nevents = 0;",
            "Static struct",
            "Static struct",
            "usb_add_event __P((int, struct usb_event *));",
            "usb_get_next_event __P((struct usb_event *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic SIMPLEQ_HEAD(, usb_event_q) usb_events = \n\tSIMPLEQ_HEAD_INITIALIZER(usb_events);\nStatic int usb_nevents = 0;\nStatic struct;\nStatic struct;\nusb_add_event __P((int, struct usb_event *));\nusb_get_next_event __P((struct usb_event *));\n\nint\nusb_get_next_event(ue)\n\tstruct usb_event *ue;\n{\n\tstruct usb_event_q *ueq;\n\n\tif (usb_nevents <= 0)\n\t\treturn (0);\n\tueq = SIMPLEQ_FIRST(&usb_events);\n\t*ue = ueq->ue;\n\tSIMPLEQ_REMOVE_HEAD(&usb_events, ueq, next);\n\tfree(ueq, M_USBDEV);\n\tusb_nevents--;\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "-1",
            "(\"usb: event dropped\\n\")"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMEVAL_TO_TIMESPEC",
          "args": [
            "&thetime",
            "&ueq->ue.ue_time"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof *ueq",
            "M_USBDEV",
            "M_WAITOK"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "microtime",
          "args": [
            "&thetime"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define USB_MAX_EVENTS 100\n\nStatic void;\nStatic void;\nStatic SIMPLEQ_HEAD(, usb_event_q) usb_events = \n\tSIMPLEQ_HEAD_INITIALIZER(usb_events);\nStatic int usb_nevents = 0;\nStatic struct;\nselinfo usb_selevent;\nStatic struct;\nproc *usb_async_proc;\nStatic void;\nusb_add_event __P((int, struct usb_event *));\nStatic int;\nusb_get_next_event __P((struct usb_event *));\n\nStatic void\nusb_add_event(type, uep)\n\tint type;\n\tstruct usb_event *uep;\n{\n\tstruct usb_event_q *ueq;\n\tstruct usb_event ue;\n\tstruct timeval thetime;\n\tint s;\n\n\tmicrotime(&thetime);\n\t/* Don't want to wait here inside splusb() */\n\tueq = malloc(sizeof *ueq, M_USBDEV, M_WAITOK);\n\tueq->ue = *uep;\n\tueq->ue.ue_type = type;\n\tTIMEVAL_TO_TIMESPEC(&thetime, &ueq->ue.ue_time);\n\n\ts = splusb();\n\tif (++usb_nevents >= USB_MAX_EVENTS) {\n\t\t/* Too many queued events, drop an old one. */\n\t\tDPRINTFN(-1,(\"usb: event dropped\\n\"));\n\t\t(void)usb_get_next_event(&ue);\n\t}\n\tSIMPLEQ_INSERT_TAIL(&usb_events, ueq, next);\n\twakeup(&usb_events);\n\tselwakeup(&usb_selevent);\n\tif (usb_async_proc != NULL)\n\t\tpsignal(usb_async_proc, SIGIO);\n\tsplx(s);\n}"
  },
  {
    "function_name": "usbd_add_drv_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
    "lines": "658-670",
    "snippet": "void\nusbd_add_drv_event(type, udev, dev)\n\tint type;\n\tusbd_device_handle udev;\n\tdevice_ptr_t dev;\n{\n\tstruct usb_event ue;\n\n\tue.u.ue_driver.ue_cookie = udev->cookie;\n\tstrncpy(ue.u.ue_driver.ue_devname, USBDEVPTRNAME(dev), \n\t    sizeof ue.u.ue_driver.ue_devname);\n\tusb_add_event(type, &ue);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <machine/bus.h>",
      "#include \"usb_if.h\"",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/vnode.h>",
      "#include <sys/select.h>",
      "#include <sys/poll.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/filio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/kthread.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static struct",
      "usb_add_event __P((int, struct usb_event *));",
      "usb_get_next_event __P((struct usb_event *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_add_event",
          "args": [
            "type",
            "&ue"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "usb_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
          "lines": "672-701",
          "snippet": "Static void\nusb_add_event(type, uep)\n\tint type;\n\tstruct usb_event *uep;\n{\n\tstruct usb_event_q *ueq;\n\tstruct usb_event ue;\n\tstruct timeval thetime;\n\tint s;\n\n\tmicrotime(&thetime);\n\t/* Don't want to wait here inside splusb() */\n\tueq = malloc(sizeof *ueq, M_USBDEV, M_WAITOK);\n\tueq->ue = *uep;\n\tueq->ue.ue_type = type;\n\tTIMEVAL_TO_TIMESPEC(&thetime, &ueq->ue.ue_time);\n\n\ts = splusb();\n\tif (++usb_nevents >= USB_MAX_EVENTS) {\n\t\t/* Too many queued events, drop an old one. */\n\t\tDPRINTFN(-1,(\"usb: event dropped\\n\"));\n\t\t(void)usb_get_next_event(&ue);\n\t}\n\tSIMPLEQ_INSERT_TAIL(&usb_events, ueq, next);\n\twakeup(&usb_events);\n\tselwakeup(&usb_selevent);\n\tif (usb_async_proc != NULL)\n\t\tpsignal(usb_async_proc, SIGIO);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <machine/bus.h>",
            "#include \"usb_if.h\"",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/vnode.h>",
            "#include <sys/select.h>",
            "#include <sys/poll.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/filio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/proc.h>",
            "#include <sys/kthread.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define USB_MAX_EVENTS 100"
          ],
          "globals_used": [
            "Static void",
            "Static void",
            "Static SIMPLEQ_HEAD(, usb_event_q) usb_events = \n\tSIMPLEQ_HEAD_INITIALIZER(usb_events);",
            "Static int usb_nevents = 0;",
            "Static struct",
            "selinfo usb_selevent;",
            "Static struct",
            "proc *usb_async_proc;",
            "Static void",
            "usb_add_event __P((int, struct usb_event *));",
            "Static int",
            "usb_get_next_event __P((struct usb_event *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define USB_MAX_EVENTS 100\n\nStatic void;\nStatic void;\nStatic SIMPLEQ_HEAD(, usb_event_q) usb_events = \n\tSIMPLEQ_HEAD_INITIALIZER(usb_events);\nStatic int usb_nevents = 0;\nStatic struct;\nselinfo usb_selevent;\nStatic struct;\nproc *usb_async_proc;\nStatic void;\nusb_add_event __P((int, struct usb_event *));\nStatic int;\nusb_get_next_event __P((struct usb_event *));\n\nStatic void\nusb_add_event(type, uep)\n\tint type;\n\tstruct usb_event *uep;\n{\n\tstruct usb_event_q *ueq;\n\tstruct usb_event ue;\n\tstruct timeval thetime;\n\tint s;\n\n\tmicrotime(&thetime);\n\t/* Don't want to wait here inside splusb() */\n\tueq = malloc(sizeof *ueq, M_USBDEV, M_WAITOK);\n\tueq->ue = *uep;\n\tueq->ue.ue_type = type;\n\tTIMEVAL_TO_TIMESPEC(&thetime, &ueq->ue.ue_time);\n\n\ts = splusb();\n\tif (++usb_nevents >= USB_MAX_EVENTS) {\n\t\t/* Too many queued events, drop an old one. */\n\t\tDPRINTFN(-1,(\"usb: event dropped\\n\"));\n\t\t(void)usb_get_next_event(&ue);\n\t}\n\tSIMPLEQ_INSERT_TAIL(&usb_events, ueq, next);\n\twakeup(&usb_events);\n\tselwakeup(&usb_selevent);\n\tif (usb_async_proc != NULL)\n\t\tpsignal(usb_async_proc, SIGIO);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ue.u.ue_driver.ue_devname",
            "USBDEVPTRNAME(dev)",
            "sizeof ue.u.ue_driver.ue_devname"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVPTRNAME",
          "args": [
            "dev"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nStatic struct;\nusb_add_event __P((int, struct usb_event *));\nusb_get_next_event __P((struct usb_event *));\n\nvoid\nusbd_add_drv_event(type, udev, dev)\n\tint type;\n\tusbd_device_handle udev;\n\tdevice_ptr_t dev;\n{\n\tstruct usb_event ue;\n\n\tue.u.ue_driver.ue_cookie = udev->cookie;\n\tstrncpy(ue.u.ue_driver.ue_devname, USBDEVPTRNAME(dev), \n\t    sizeof ue.u.ue_driver.ue_devname);\n\tusb_add_event(type, &ue);\n}"
  },
  {
    "function_name": "usbd_add_dev_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
    "lines": "647-656",
    "snippet": "void\nusbd_add_dev_event(type, udev)\n\tint type;\n\tusbd_device_handle udev;\n{\n\tstruct usb_event ue;\n\n\tusbd_fill_deviceinfo(udev, &ue.u.ue_device);\n\tusb_add_event(type, &ue);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <machine/bus.h>",
      "#include \"usb_if.h\"",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/vnode.h>",
      "#include <sys/select.h>",
      "#include <sys/poll.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/filio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/kthread.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static struct",
      "usb_add_event __P((int, struct usb_event *));",
      "usb_get_next_event __P((struct usb_event *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_add_event",
          "args": [
            "type",
            "&ue"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "usb_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
          "lines": "672-701",
          "snippet": "Static void\nusb_add_event(type, uep)\n\tint type;\n\tstruct usb_event *uep;\n{\n\tstruct usb_event_q *ueq;\n\tstruct usb_event ue;\n\tstruct timeval thetime;\n\tint s;\n\n\tmicrotime(&thetime);\n\t/* Don't want to wait here inside splusb() */\n\tueq = malloc(sizeof *ueq, M_USBDEV, M_WAITOK);\n\tueq->ue = *uep;\n\tueq->ue.ue_type = type;\n\tTIMEVAL_TO_TIMESPEC(&thetime, &ueq->ue.ue_time);\n\n\ts = splusb();\n\tif (++usb_nevents >= USB_MAX_EVENTS) {\n\t\t/* Too many queued events, drop an old one. */\n\t\tDPRINTFN(-1,(\"usb: event dropped\\n\"));\n\t\t(void)usb_get_next_event(&ue);\n\t}\n\tSIMPLEQ_INSERT_TAIL(&usb_events, ueq, next);\n\twakeup(&usb_events);\n\tselwakeup(&usb_selevent);\n\tif (usb_async_proc != NULL)\n\t\tpsignal(usb_async_proc, SIGIO);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <machine/bus.h>",
            "#include \"usb_if.h\"",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/vnode.h>",
            "#include <sys/select.h>",
            "#include <sys/poll.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/filio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/proc.h>",
            "#include <sys/kthread.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define USB_MAX_EVENTS 100"
          ],
          "globals_used": [
            "Static void",
            "Static void",
            "Static SIMPLEQ_HEAD(, usb_event_q) usb_events = \n\tSIMPLEQ_HEAD_INITIALIZER(usb_events);",
            "Static int usb_nevents = 0;",
            "Static struct",
            "selinfo usb_selevent;",
            "Static struct",
            "proc *usb_async_proc;",
            "Static void",
            "usb_add_event __P((int, struct usb_event *));",
            "Static int",
            "usb_get_next_event __P((struct usb_event *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define USB_MAX_EVENTS 100\n\nStatic void;\nStatic void;\nStatic SIMPLEQ_HEAD(, usb_event_q) usb_events = \n\tSIMPLEQ_HEAD_INITIALIZER(usb_events);\nStatic int usb_nevents = 0;\nStatic struct;\nselinfo usb_selevent;\nStatic struct;\nproc *usb_async_proc;\nStatic void;\nusb_add_event __P((int, struct usb_event *));\nStatic int;\nusb_get_next_event __P((struct usb_event *));\n\nStatic void\nusb_add_event(type, uep)\n\tint type;\n\tstruct usb_event *uep;\n{\n\tstruct usb_event_q *ueq;\n\tstruct usb_event ue;\n\tstruct timeval thetime;\n\tint s;\n\n\tmicrotime(&thetime);\n\t/* Don't want to wait here inside splusb() */\n\tueq = malloc(sizeof *ueq, M_USBDEV, M_WAITOK);\n\tueq->ue = *uep;\n\tueq->ue.ue_type = type;\n\tTIMEVAL_TO_TIMESPEC(&thetime, &ueq->ue.ue_time);\n\n\ts = splusb();\n\tif (++usb_nevents >= USB_MAX_EVENTS) {\n\t\t/* Too many queued events, drop an old one. */\n\t\tDPRINTFN(-1,(\"usb: event dropped\\n\"));\n\t\t(void)usb_get_next_event(&ue);\n\t}\n\tSIMPLEQ_INSERT_TAIL(&usb_events, ueq, next);\n\twakeup(&usb_events);\n\tselwakeup(&usb_selevent);\n\tif (usb_async_proc != NULL)\n\t\tpsignal(usb_async_proc, SIGIO);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_fill_deviceinfo",
          "args": [
            "udev",
            "&ue.u.ue_device"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_fill_deviceinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "1171-1231",
          "snippet": "void\nusbd_fill_deviceinfo(dev, di)\n\tusbd_device_handle dev;\n\tstruct usb_device_info *di;\n{\n\tstruct usbd_port *p;\n\tint i, err, s;\n\n\tdi->bus = USBDEVUNIT(dev->bus->bdev);\n\tdi->addr = dev->address;\n\tdi->cookie = dev->cookie;\n\tusbd_devinfo_vp(dev, di->vendor, di->product);\n\tusbd_printBCD(di->release, UGETW(dev->ddesc.bcdDevice));\n\tdi->vendorNo = UGETW(dev->ddesc.idVendor);\n\tdi->productNo = UGETW(dev->ddesc.idProduct);\n\tdi->releaseNo = UGETW(dev->ddesc.bcdDevice);\n\tdi->class = dev->ddesc.bDeviceClass;\n\tdi->subclass = dev->ddesc.bDeviceSubClass;\n\tdi->protocol = dev->ddesc.bDeviceProtocol;\n\tdi->config = dev->config;\n\tdi->power = dev->self_powered ? 0 : dev->power;\n\tdi->lowspeed = dev->lowspeed;\n\n\tif (dev->subdevs != NULL) {\n\t\tfor (i = 0; dev->subdevs[i] &&\n\t\t\t     i < USB_MAX_DEVNAMES; i++) {\n\t\t\tstrncpy(di->devnames[i], USBDEVPTRNAME(dev->subdevs[i]),\n\t\t\t\tUSB_MAX_DEVNAMELEN);\n\t\t\tdi->devnames[i][USB_MAX_DEVNAMELEN-1] = '\\0';\n                }\n        } else {\n                i = 0;\n        }\n        for (/*i is set */; i < USB_MAX_DEVNAMES; i++)\n                di->devnames[i][0] = 0;                 /* empty */\n\n\tif (dev->hub) {\n\t\tfor (i = 0; \n\t\t     i < sizeof(di->ports) / sizeof(di->ports[0]) &&\n\t\t\t     i < dev->hub->hubdesc.bNbrPorts;\n\t\t     i++) {\n\t\t\tp = &dev->hub->ports[i];\n\t\t\tif (p->device)\n\t\t\t\terr = p->device->address;\n\t\t\telse {\n\t\t\t\ts = UGETW(p->status.wPortStatus);\n\t\t\t\tif (s & UPS_PORT_ENABLED)\n\t\t\t\t\terr = USB_PORT_ENABLED;\n\t\t\t\telse if (s & UPS_SUSPEND)\n\t\t\t\t\terr = USB_PORT_SUSPENDED;\n\t\t\t\telse if (s & UPS_PORT_POWER)\n\t\t\t\t\terr = USB_PORT_POWERED;\n\t\t\t\telse\n\t\t\t\t\terr = USB_PORT_DISABLED;\n\t\t\t}\n\t\t\tdi->ports[i] = err;\n\t\t}\n\t\tdi->nports = dev->hub->hubdesc.bNbrPorts;\n\t} else\n\t\tdi->nports = 0;\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "usbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));",
            "const char *\nusbd_errstr(err)\n\tusbd_status err;",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nusbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_fill_deviceinfo(dev, di)\n\tusbd_device_handle dev;\n\tstruct usb_device_info *di;\n{\n\tstruct usbd_port *p;\n\tint i, err, s;\n\n\tdi->bus = USBDEVUNIT(dev->bus->bdev);\n\tdi->addr = dev->address;\n\tdi->cookie = dev->cookie;\n\tusbd_devinfo_vp(dev, di->vendor, di->product);\n\tusbd_printBCD(di->release, UGETW(dev->ddesc.bcdDevice));\n\tdi->vendorNo = UGETW(dev->ddesc.idVendor);\n\tdi->productNo = UGETW(dev->ddesc.idProduct);\n\tdi->releaseNo = UGETW(dev->ddesc.bcdDevice);\n\tdi->class = dev->ddesc.bDeviceClass;\n\tdi->subclass = dev->ddesc.bDeviceSubClass;\n\tdi->protocol = dev->ddesc.bDeviceProtocol;\n\tdi->config = dev->config;\n\tdi->power = dev->self_powered ? 0 : dev->power;\n\tdi->lowspeed = dev->lowspeed;\n\n\tif (dev->subdevs != NULL) {\n\t\tfor (i = 0; dev->subdevs[i] &&\n\t\t\t     i < USB_MAX_DEVNAMES; i++) {\n\t\t\tstrncpy(di->devnames[i], USBDEVPTRNAME(dev->subdevs[i]),\n\t\t\t\tUSB_MAX_DEVNAMELEN);\n\t\t\tdi->devnames[i][USB_MAX_DEVNAMELEN-1] = '\\0';\n                }\n        } else {\n                i = 0;\n        }\n        for (/*i is set */; i < USB_MAX_DEVNAMES; i++)\n                di->devnames[i][0] = 0;                 /* empty */\n\n\tif (dev->hub) {\n\t\tfor (i = 0; \n\t\t     i < sizeof(di->ports) / sizeof(di->ports[0]) &&\n\t\t\t     i < dev->hub->hubdesc.bNbrPorts;\n\t\t     i++) {\n\t\t\tp = &dev->hub->ports[i];\n\t\t\tif (p->device)\n\t\t\t\terr = p->device->address;\n\t\t\telse {\n\t\t\t\ts = UGETW(p->status.wPortStatus);\n\t\t\t\tif (s & UPS_PORT_ENABLED)\n\t\t\t\t\terr = USB_PORT_ENABLED;\n\t\t\t\telse if (s & UPS_SUSPEND)\n\t\t\t\t\terr = USB_PORT_SUSPENDED;\n\t\t\t\telse if (s & UPS_PORT_POWER)\n\t\t\t\t\terr = USB_PORT_POWERED;\n\t\t\t\telse\n\t\t\t\t\terr = USB_PORT_DISABLED;\n\t\t\t}\n\t\t\tdi->ports[i] = err;\n\t\t}\n\t\tdi->nports = dev->hub->hubdesc.bNbrPorts;\n\t} else\n\t\tdi->nports = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nStatic struct;\nusb_add_event __P((int, struct usb_event *));\nusb_get_next_event __P((struct usb_event *));\n\nvoid\nusbd_add_dev_event(type, udev)\n\tint type;\n\tusbd_device_handle udev;\n{\n\tstruct usb_event ue;\n\n\tusbd_fill_deviceinfo(udev, &ue.u.ue_device);\n\tusb_add_event(type, &ue);\n}"
  },
  {
    "function_name": "usb_get_next_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
    "lines": "631-645",
    "snippet": "int\nusb_get_next_event(ue)\n\tstruct usb_event *ue;\n{\n\tstruct usb_event_q *ueq;\n\n\tif (usb_nevents <= 0)\n\t\treturn (0);\n\tueq = SIMPLEQ_FIRST(&usb_events);\n\t*ue = ueq->ue;\n\tSIMPLEQ_REMOVE_HEAD(&usb_events, ueq, next);\n\tfree(ueq, M_USBDEV);\n\tusb_nevents--;\n\treturn (1);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <machine/bus.h>",
      "#include \"usb_if.h\"",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/vnode.h>",
      "#include <sys/select.h>",
      "#include <sys/poll.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/filio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/kthread.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static SIMPLEQ_HEAD(, usb_event_q) usb_events = \n\tSIMPLEQ_HEAD_INITIALIZER(usb_events);",
      "Static int usb_nevents = 0;",
      "Static struct",
      "Static struct",
      "usb_add_event __P((int, struct usb_event *));",
      "usb_get_next_event __P((struct usb_event *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ueq",
            "M_USBDEV"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_REMOVE_HEAD",
          "args": [
            "&usb_events",
            "ueq",
            "next"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&usb_events"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic SIMPLEQ_HEAD(, usb_event_q) usb_events = \n\tSIMPLEQ_HEAD_INITIALIZER(usb_events);\nStatic int usb_nevents = 0;\nStatic struct;\nStatic struct;\nusb_add_event __P((int, struct usb_event *));\nusb_get_next_event __P((struct usb_event *));\n\nint\nusb_get_next_event(ue)\n\tstruct usb_event *ue;\n{\n\tstruct usb_event_q *ueq;\n\n\tif (usb_nevents <= 0)\n\t\treturn (0);\n\tueq = SIMPLEQ_FIRST(&usb_events);\n\t*ue = ueq->ue;\n\tSIMPLEQ_REMOVE_HEAD(&usb_events, ueq, next);\n\tfree(ueq, M_USBDEV);\n\tusb_nevents--;\n\treturn (1);\n}"
  },
  {
    "function_name": "usb_needs_explore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
    "lines": "618-628",
    "snippet": "void\nusb_needs_explore(bus)\n\tusbd_bus_handle bus;\n{\n\tbus->needs_explore = 1;\n#if defined(__FreeBSD__)\n\t/* This part should be deleted when kthreads is available */\n\tselwakeup(&bus->usbctl->sc_consel);\n#endif\n\twakeup(&bus->needs_explore);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <machine/bus.h>",
      "#include \"usb_if.h\"",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/vnode.h>",
      "#include <sys/select.h>",
      "#include <sys/poll.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/filio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/kthread.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&bus->needs_explore"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "selwakeup",
          "args": [
            "&bus->usbctl->sc_consel"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_needs_explore(bus)\n\tusbd_bus_handle bus;\n{\n\tbus->needs_explore = 1;\n#if defined(__FreeBSD__)\n\t/* This part should be deleted when kthreads is available */\n\tselwakeup(&bus->usbctl->sc_consel);\n#endif\n\twakeup(&bus->needs_explore);\n}"
  },
  {
    "function_name": "usb_discover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
    "lines": "584-616",
    "snippet": "usbd_status\nusb_discover(sc)\n\tstruct usb_softc *sc;\n{\n#if defined(__FreeBSD__)\n\t/* The splxxx parts should be deleted when kthreads is available */\n\tint s;\n#endif\n\n\t/* \n\t * We need mutual exclusion while traversing the device tree,\n\t * but this is guaranteed since this function is only called\n\t * from the event thread for the controller.\n\t */\n#if defined(__FreeBSD__)\n\ts = splusb();\n#endif\n\twhile (sc->sc_bus->needs_explore && !sc->sc_dying) {\n\t\tsc->sc_bus->needs_explore = 0;\n#if defined(__FreeBSD__)\n\t\tsplx(s);\n#endif\n\t\tsc->sc_bus->root_hub->hub->explore(sc->sc_bus->root_hub);\n#if defined(__FreeBSD__)\n\t\ts = splusb();\n#endif\n\t}\n#if defined(__FreeBSD__)\n\tsplx(s);\n#endif\n\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <machine/bus.h>",
      "#include \"usb_if.h\"",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/vnode.h>",
      "#include <sys/select.h>",
      "#include <sys/poll.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/filio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/kthread.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usb_discover __P((struct usb_softc *));",
      "Static struct",
      "Static struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->sc_bus->root_hub->hub->explore",
          "args": [
            "sc->sc_bus->root_hub"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusb_discover __P((struct usb_softc *));\nStatic struct;\nStatic struct;\n\nusbd_status\nusb_discover(sc)\n\tstruct usb_softc *sc;\n{\n#if defined(__FreeBSD__)\n\t/* The splxxx parts should be deleted when kthreads is available */\n\tint s;\n#endif\n\n\t/* \n\t * We need mutual exclusion while traversing the device tree,\n\t * but this is guaranteed since this function is only called\n\t * from the event thread for the controller.\n\t */\n#if defined(__FreeBSD__)\n\ts = splusb();\n#endif\n\twhile (sc->sc_bus->needs_explore && !sc->sc_dying) {\n\t\tsc->sc_bus->needs_explore = 0;\n#if defined(__FreeBSD__)\n\t\tsplx(s);\n#endif\n\t\tsc->sc_bus->root_hub->hub->explore(sc->sc_bus->root_hub);\n#if defined(__FreeBSD__)\n\t\ts = splusb();\n#endif\n\t}\n#if defined(__FreeBSD__)\n\tsplx(s);\n#endif\n\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "usbpoll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
    "lines": "538-581",
    "snippet": "int\nusbpoll(dev, events, p)\n\tdev_t dev;\n\tint events;\n\tstruct proc *p;\n{\n\tint revents, mask, s;\n\n\tif (minor(dev) == USB_DEV_MINOR) {\n\t\trevents = 0;\n\t\tmask = POLLIN | POLLRDNORM;\n\t\t\n\t\ts = splusb();\n\t\tif (events & mask && usb_nevents > 0)\n\t\t\trevents |= events & mask;\n\t\tif (revents == 0 && events & mask)\n\t\t\tselrecord(p, &usb_selevent);\n\t\tsplx(s);\n\t\t\n\t\treturn (revents);\n\t} else {\n#if defined(__FreeBSD__)\n\t\t/* This part should be deleted when kthreads is available */\n\t\tstruct usb_softc *sc;\n\t\tint unit = minor(dev);\n\n\t\tUSB_GET_SC(usb, unit, sc);\n\n\t\trevents = 0;\n\t\tmask = POLLOUT | POLLRDNORM;\n\n\t\ts = splusb();\n\t\tif (events & mask && sc->sc_bus->needs_explore)\n\t\t\trevents |= events & mask;\n\t\tif (revents == 0 && events & mask)\n\t\t\tselrecord(p, &sc->sc_consel);\n\t\tsplx(s);\n\n\t\treturn (revents);\n#else\n\t\treturn (ENXIO);\n#endif\n\t}\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <machine/bus.h>",
      "#include \"usb_if.h\"",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/vnode.h>",
      "#include <sys/select.h>",
      "#include <sys/poll.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/filio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/kthread.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define USB_DEV_MINOR 255"
    ],
    "globals_used": [
      "usb_discover __P((struct usb_softc *));",
      "Static int usb_nevents = 0;",
      "Static struct",
      "selinfo usb_selevent;",
      "Static struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selrecord",
          "args": [
            "p",
            "&sc->sc_consel"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USB_GET_SC",
          "args": [
            "usb",
            "unit",
            "sc"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selrecord",
          "args": [
            "p",
            "&usb_selevent"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define USB_DEV_MINOR 255\n\nusb_discover __P((struct usb_softc *));\nStatic int usb_nevents = 0;\nStatic struct;\nselinfo usb_selevent;\nStatic struct;\n\nint\nusbpoll(dev, events, p)\n\tdev_t dev;\n\tint events;\n\tstruct proc *p;\n{\n\tint revents, mask, s;\n\n\tif (minor(dev) == USB_DEV_MINOR) {\n\t\trevents = 0;\n\t\tmask = POLLIN | POLLRDNORM;\n\t\t\n\t\ts = splusb();\n\t\tif (events & mask && usb_nevents > 0)\n\t\t\trevents |= events & mask;\n\t\tif (revents == 0 && events & mask)\n\t\t\tselrecord(p, &usb_selevent);\n\t\tsplx(s);\n\t\t\n\t\treturn (revents);\n\t} else {\n#if defined(__FreeBSD__)\n\t\t/* This part should be deleted when kthreads is available */\n\t\tstruct usb_softc *sc;\n\t\tint unit = minor(dev);\n\n\t\tUSB_GET_SC(usb, unit, sc);\n\n\t\trevents = 0;\n\t\tmask = POLLOUT | POLLRDNORM;\n\n\t\ts = splusb();\n\t\tif (events & mask && sc->sc_bus->needs_explore)\n\t\t\trevents |= events & mask;\n\t\tif (revents == 0 && events & mask)\n\t\t\tselrecord(p, &sc->sc_consel);\n\t\tsplx(s);\n\n\t\treturn (revents);\n#else\n\t\treturn (ENXIO);\n#endif\n\t}\n}"
  },
  {
    "function_name": "usbioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
    "lines": "406-536",
    "snippet": "int\nusbioctl(devt, cmd, data, flag, p)\n\tdev_t devt;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct usb_softc *sc;\n\tint unit = minor(devt);\n\n\tif (unit == USB_DEV_MINOR) {\n\t\tswitch (cmd) {\n\t\tcase FIONBIO:\n\t\t\t/* All handled in the upper FS layer. */\n\t\t\treturn (0);\n\t\t\t\n\t\tcase FIOASYNC:\n\t\t\tif (*(int *)data)\n\t\t\t\tusb_async_proc = p;\n\t\t\telse\n\t\t\t\tusb_async_proc = 0;\n\t\t\treturn (0);\n\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\t}\n\n\tUSB_GET_SC(usb, unit, sc);\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tswitch (cmd) {\n#if defined(__FreeBSD__) \n\t/* This part should be deleted when kthreads is available */\n  \tcase USB_DISCOVER:\n  \t\tusb_discover(sc);\n  \t\tbreak;\n#endif\n#ifdef USB_DEBUG\n\tcase USB_SETDEBUG:\n\t\tusbdebug  = ((*(int *)data) & 0x000000ff);\n#ifdef UHCI_DEBUG\n\t\tuhcidebug = ((*(int *)data) & 0x0000ff00) >> 8;\n#endif\n#ifdef OHCI_DEBUG\n\t\tohcidebug = ((*(int *)data) & 0x00ff0000) >> 16;\n#endif\n\t\tbreak;\n#endif\n\tcase USB_REQUEST:\n\t{\n\t\tstruct usb_ctl_request *ur = (void *)data;\n\t\tint len = UGETW(ur->request.wLength);\n\t\tstruct iovec iov;\n\t\tstruct uio uio;\n\t\tvoid *ptr = 0;\n\t\tint addr = ur->addr;\n\t\tusbd_status err;\n\t\tint error = 0;\n\n\t\tDPRINTF((\"usbioctl: USB_REQUEST addr=%d len=%d\\n\", addr, len));\n\t\tif (len < 0 || len > 32768)\n\t\t\treturn (EINVAL);\n\t\tif (addr < 0 || addr >= USB_MAX_DEVICES || \n\t\t    sc->sc_bus->devices[addr] == 0)\n\t\t\treturn (EINVAL);\n\t\tif (len != 0) {\n\t\t\tiov.iov_base = (caddr_t)ur->data;\n\t\t\tiov.iov_len = len;\n\t\t\tuio.uio_iov = &iov;\n\t\t\tuio.uio_iovcnt = 1;\n\t\t\tuio.uio_resid = len;\n\t\t\tuio.uio_offset = 0;\n\t\t\tuio.uio_segflg = UIO_USERSPACE;\n\t\t\tuio.uio_rw =\n\t\t\t\tur->request.bmRequestType & UT_READ ? \n\t\t\t\tUIO_READ : UIO_WRITE;\n\t\t\tuio.uio_procp = p;\n\t\t\tptr = malloc(len, M_TEMP, M_WAITOK);\n\t\t\tif (uio.uio_rw == UIO_WRITE) {\n\t\t\t\terror = uiomove(ptr, len, &uio);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\t\terr = usbd_do_request_flags(sc->sc_bus->devices[addr],\n\t\t\t  &ur->request, ptr, ur->flags, &ur->actlen);\n\t\tif (err) {\n\t\t\terror = EIO;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (len != 0) {\n\t\t\tif (uio.uio_rw == UIO_READ) {\n\t\t\t\terror = uiomove(ptr, len, &uio);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\tret:\n\t\tif (ptr)\n\t\t\tfree(ptr, M_TEMP);\n\t\treturn (error);\n\t}\n\n\tcase USB_DEVICEINFO:\n\t{\n\t\tstruct usb_device_info *di = (void *)data;\n\t\tint addr = di->addr;\n\t\tusbd_device_handle dev;\n\n\t\tif (addr < 1 || addr >= USB_MAX_DEVICES)\n\t\t\treturn (EINVAL);\n\t\tdev = sc->sc_bus->devices[addr];\n\t\tif (dev == NULL)\n\t\t\treturn (ENXIO);\n\t\tusbd_fill_deviceinfo(dev, di);\n\t\tbreak;\n\t}\n\n\tcase USB_DEVICESTATS:\n\t\t*(struct usb_device_stats *)data = sc->sc_bus->stats;\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <machine/bus.h>",
      "#include \"usb_if.h\"",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/vnode.h>",
      "#include <sys/select.h>",
      "#include <sys/poll.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/filio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/kthread.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define USB_DEV_MINOR 255"
    ],
    "globals_used": [
      "Static usbd_status",
      "usb_discover __P((struct usb_softc *));",
      "Static struct",
      "Static struct",
      "proc *usb_async_proc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_fill_deviceinfo",
          "args": [
            "dev",
            "di"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_fill_deviceinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "1171-1231",
          "snippet": "void\nusbd_fill_deviceinfo(dev, di)\n\tusbd_device_handle dev;\n\tstruct usb_device_info *di;\n{\n\tstruct usbd_port *p;\n\tint i, err, s;\n\n\tdi->bus = USBDEVUNIT(dev->bus->bdev);\n\tdi->addr = dev->address;\n\tdi->cookie = dev->cookie;\n\tusbd_devinfo_vp(dev, di->vendor, di->product);\n\tusbd_printBCD(di->release, UGETW(dev->ddesc.bcdDevice));\n\tdi->vendorNo = UGETW(dev->ddesc.idVendor);\n\tdi->productNo = UGETW(dev->ddesc.idProduct);\n\tdi->releaseNo = UGETW(dev->ddesc.bcdDevice);\n\tdi->class = dev->ddesc.bDeviceClass;\n\tdi->subclass = dev->ddesc.bDeviceSubClass;\n\tdi->protocol = dev->ddesc.bDeviceProtocol;\n\tdi->config = dev->config;\n\tdi->power = dev->self_powered ? 0 : dev->power;\n\tdi->lowspeed = dev->lowspeed;\n\n\tif (dev->subdevs != NULL) {\n\t\tfor (i = 0; dev->subdevs[i] &&\n\t\t\t     i < USB_MAX_DEVNAMES; i++) {\n\t\t\tstrncpy(di->devnames[i], USBDEVPTRNAME(dev->subdevs[i]),\n\t\t\t\tUSB_MAX_DEVNAMELEN);\n\t\t\tdi->devnames[i][USB_MAX_DEVNAMELEN-1] = '\\0';\n                }\n        } else {\n                i = 0;\n        }\n        for (/*i is set */; i < USB_MAX_DEVNAMES; i++)\n                di->devnames[i][0] = 0;                 /* empty */\n\n\tif (dev->hub) {\n\t\tfor (i = 0; \n\t\t     i < sizeof(di->ports) / sizeof(di->ports[0]) &&\n\t\t\t     i < dev->hub->hubdesc.bNbrPorts;\n\t\t     i++) {\n\t\t\tp = &dev->hub->ports[i];\n\t\t\tif (p->device)\n\t\t\t\terr = p->device->address;\n\t\t\telse {\n\t\t\t\ts = UGETW(p->status.wPortStatus);\n\t\t\t\tif (s & UPS_PORT_ENABLED)\n\t\t\t\t\terr = USB_PORT_ENABLED;\n\t\t\t\telse if (s & UPS_SUSPEND)\n\t\t\t\t\terr = USB_PORT_SUSPENDED;\n\t\t\t\telse if (s & UPS_PORT_POWER)\n\t\t\t\t\terr = USB_PORT_POWERED;\n\t\t\t\telse\n\t\t\t\t\terr = USB_PORT_DISABLED;\n\t\t\t}\n\t\t\tdi->ports[i] = err;\n\t\t}\n\t\tdi->nports = dev->hub->hubdesc.bNbrPorts;\n\t} else\n\t\tdi->nports = 0;\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "usbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));",
            "const char *\nusbd_errstr(err)\n\tusbd_status err;",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nusbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_fill_deviceinfo(dev, di)\n\tusbd_device_handle dev;\n\tstruct usb_device_info *di;\n{\n\tstruct usbd_port *p;\n\tint i, err, s;\n\n\tdi->bus = USBDEVUNIT(dev->bus->bdev);\n\tdi->addr = dev->address;\n\tdi->cookie = dev->cookie;\n\tusbd_devinfo_vp(dev, di->vendor, di->product);\n\tusbd_printBCD(di->release, UGETW(dev->ddesc.bcdDevice));\n\tdi->vendorNo = UGETW(dev->ddesc.idVendor);\n\tdi->productNo = UGETW(dev->ddesc.idProduct);\n\tdi->releaseNo = UGETW(dev->ddesc.bcdDevice);\n\tdi->class = dev->ddesc.bDeviceClass;\n\tdi->subclass = dev->ddesc.bDeviceSubClass;\n\tdi->protocol = dev->ddesc.bDeviceProtocol;\n\tdi->config = dev->config;\n\tdi->power = dev->self_powered ? 0 : dev->power;\n\tdi->lowspeed = dev->lowspeed;\n\n\tif (dev->subdevs != NULL) {\n\t\tfor (i = 0; dev->subdevs[i] &&\n\t\t\t     i < USB_MAX_DEVNAMES; i++) {\n\t\t\tstrncpy(di->devnames[i], USBDEVPTRNAME(dev->subdevs[i]),\n\t\t\t\tUSB_MAX_DEVNAMELEN);\n\t\t\tdi->devnames[i][USB_MAX_DEVNAMELEN-1] = '\\0';\n                }\n        } else {\n                i = 0;\n        }\n        for (/*i is set */; i < USB_MAX_DEVNAMES; i++)\n                di->devnames[i][0] = 0;                 /* empty */\n\n\tif (dev->hub) {\n\t\tfor (i = 0; \n\t\t     i < sizeof(di->ports) / sizeof(di->ports[0]) &&\n\t\t\t     i < dev->hub->hubdesc.bNbrPorts;\n\t\t     i++) {\n\t\t\tp = &dev->hub->ports[i];\n\t\t\tif (p->device)\n\t\t\t\terr = p->device->address;\n\t\t\telse {\n\t\t\t\ts = UGETW(p->status.wPortStatus);\n\t\t\t\tif (s & UPS_PORT_ENABLED)\n\t\t\t\t\terr = USB_PORT_ENABLED;\n\t\t\t\telse if (s & UPS_SUSPEND)\n\t\t\t\t\terr = USB_PORT_SUSPENDED;\n\t\t\t\telse if (s & UPS_PORT_POWER)\n\t\t\t\t\terr = USB_PORT_POWERED;\n\t\t\t\telse\n\t\t\t\t\terr = USB_PORT_DISABLED;\n\t\t\t}\n\t\t\tdi->ports[i] = err;\n\t\t}\n\t\tdi->nports = dev->hub->hubdesc.bNbrPorts;\n\t} else\n\t\tdi->nports = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ptr",
            "M_TEMP"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "ptr",
            "len",
            "&uio"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_do_request_flags",
          "args": [
            "sc->sc_bus->devices[addr]",
            "&ur->request",
            "ptr",
            "ur->flags",
            "&ur->actlen"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_do_request_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "952-1033",
          "snippet": "usbd_status\nusbd_do_request_flags(dev, req, data, flags, actlen)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n\tu_int16_t flags;\n\tint *actlen;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n#ifdef DIAGNOSTIC\n#if defined(__i386__) && defined(__FreeBSD__)\n\tKASSERT(intr_nesting_level == 0,\n\t       \t(\"usbd_do_request: in interrupt context\"));\n#endif\n\tif (dev->bus->intr_context) {\n\t\tprintf(\"usbd_do_request: not in process context\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t\t\t\t   data, UGETW(req->wLength), flags, 0);\n\terr = usbd_sync_transfer(xfer);\n#if defined(USB_DEBUG) || defined(DIAGNOSTIC)\n\tif (xfer->actlen > xfer->length)\n\t\tDPRINTF((\"usbd_do_request: overrun addr=%d type=0x%02x req=0x\"\n\t\t\t \"%02x val=%d index=%d rlen=%d length=%d actlen=%d\\n\",\n\t\t\t dev->address, xfer->request.bmRequestType,\n\t\t\t xfer->request.bRequest, UGETW(xfer->request.wValue),\n\t\t\t UGETW(xfer->request.wIndex), \n\t\t\t UGETW(xfer->request.wLength), \n\t\t\t xfer->length, xfer->actlen));\n#endif\n\tif (actlen != NULL)\n\t\t*actlen = xfer->actlen;\n\tif (err == USBD_STALLED) {\n\t\t/* \n\t\t * The control endpoint has stalled.  Control endpoints\n\t\t * should not halt, but some may do so anyway so clear\n\t\t * any halt condition.\n\t\t */\n\t\tusb_device_request_t treq;\n\t\tusb_status_t status;\n\t\tu_int16_t s;\n\t\tusbd_status nerr;\n\n\t\ttreq.bmRequestType = UT_READ_ENDPOINT;\n\t\ttreq.bRequest = UR_GET_STATUS;\n\t\tUSETW(treq.wValue, 0);\n\t\tUSETW(treq.wIndex, 0);\n\t\tUSETW(treq.wLength, sizeof(usb_status_t));\n\t\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,\n\t\t\t\t\t   &treq, &status,sizeof(usb_status_t),\n\t\t\t\t\t   0, 0);\n\t\tnerr = usbd_sync_transfer(xfer);\n\t\tif (nerr)\n\t\t\tgoto bad;\n\t\ts = UGETW(status.wStatus);\n\t\tDPRINTF((\"usbd_do_request: status = 0x%04x\\n\", s));\n\t\tif (!(s & UES_HALT))\n\t\t\tgoto bad;\n\t\ttreq.bmRequestType = UT_WRITE_ENDPOINT;\n\t\ttreq.bRequest = UR_CLEAR_FEATURE;\n\t\tUSETW(treq.wValue, UF_ENDPOINT_HALT);\n\t\tUSETW(treq.wIndex, 0);\n\t\tUSETW(treq.wLength, 0);\n\t\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,\n\t\t\t\t\t   &treq, &status, 0, 0, 0);\n\t\tnerr = usbd_sync_transfer(xfer);\n\t\tif (nerr)\n\t\t\tgoto bad;\n\t}\n\n bad:\n\tusbd_free_xfer(xfer);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "u_int8_t index;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;",
            "u_int8_t address;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nu_int8_t index;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\nu_int8_t address;\n\nusbd_status\nusbd_do_request_flags(dev, req, data, flags, actlen)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n\tu_int16_t flags;\n\tint *actlen;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n#ifdef DIAGNOSTIC\n#if defined(__i386__) && defined(__FreeBSD__)\n\tKASSERT(intr_nesting_level == 0,\n\t       \t(\"usbd_do_request: in interrupt context\"));\n#endif\n\tif (dev->bus->intr_context) {\n\t\tprintf(\"usbd_do_request: not in process context\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t\t\t\t   data, UGETW(req->wLength), flags, 0);\n\terr = usbd_sync_transfer(xfer);\n#if defined(USB_DEBUG) || defined(DIAGNOSTIC)\n\tif (xfer->actlen > xfer->length)\n\t\tDPRINTF((\"usbd_do_request: overrun addr=%d type=0x%02x req=0x\"\n\t\t\t \"%02x val=%d index=%d rlen=%d length=%d actlen=%d\\n\",\n\t\t\t dev->address, xfer->request.bmRequestType,\n\t\t\t xfer->request.bRequest, UGETW(xfer->request.wValue),\n\t\t\t UGETW(xfer->request.wIndex), \n\t\t\t UGETW(xfer->request.wLength), \n\t\t\t xfer->length, xfer->actlen));\n#endif\n\tif (actlen != NULL)\n\t\t*actlen = xfer->actlen;\n\tif (err == USBD_STALLED) {\n\t\t/* \n\t\t * The control endpoint has stalled.  Control endpoints\n\t\t * should not halt, but some may do so anyway so clear\n\t\t * any halt condition.\n\t\t */\n\t\tusb_device_request_t treq;\n\t\tusb_status_t status;\n\t\tu_int16_t s;\n\t\tusbd_status nerr;\n\n\t\ttreq.bmRequestType = UT_READ_ENDPOINT;\n\t\ttreq.bRequest = UR_GET_STATUS;\n\t\tUSETW(treq.wValue, 0);\n\t\tUSETW(treq.wIndex, 0);\n\t\tUSETW(treq.wLength, sizeof(usb_status_t));\n\t\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,\n\t\t\t\t\t   &treq, &status,sizeof(usb_status_t),\n\t\t\t\t\t   0, 0);\n\t\tnerr = usbd_sync_transfer(xfer);\n\t\tif (nerr)\n\t\t\tgoto bad;\n\t\ts = UGETW(status.wStatus);\n\t\tDPRINTF((\"usbd_do_request: status = 0x%04x\\n\", s));\n\t\tif (!(s & UES_HALT))\n\t\t\tgoto bad;\n\t\ttreq.bmRequestType = UT_WRITE_ENDPOINT;\n\t\ttreq.bRequest = UR_CLEAR_FEATURE;\n\t\tUSETW(treq.wValue, UF_ENDPOINT_HALT);\n\t\tUSETW(treq.wIndex, 0);\n\t\tUSETW(treq.wLength, 0);\n\t\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,\n\t\t\t\t\t   &treq, &status, 0, 0, 0);\n\t\tnerr = usbd_sync_transfer(xfer);\n\t\tif (nerr)\n\t\t\tgoto bad;\n\t}\n\n bad:\n\tusbd_free_xfer(xfer);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "ptr",
            "len",
            "&uio"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len",
            "M_TEMP",
            "M_WAITOK"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbioctl: USB_REQUEST addr=%d len=%d\\n\", addr, len)"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "ur->request.wLength"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_discover",
          "args": [
            "sc"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "usb_discover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
          "lines": "584-616",
          "snippet": "usbd_status\nusb_discover(sc)\n\tstruct usb_softc *sc;\n{\n#if defined(__FreeBSD__)\n\t/* The splxxx parts should be deleted when kthreads is available */\n\tint s;\n#endif\n\n\t/* \n\t * We need mutual exclusion while traversing the device tree,\n\t * but this is guaranteed since this function is only called\n\t * from the event thread for the controller.\n\t */\n#if defined(__FreeBSD__)\n\ts = splusb();\n#endif\n\twhile (sc->sc_bus->needs_explore && !sc->sc_dying) {\n\t\tsc->sc_bus->needs_explore = 0;\n#if defined(__FreeBSD__)\n\t\tsplx(s);\n#endif\n\t\tsc->sc_bus->root_hub->hub->explore(sc->sc_bus->root_hub);\n#if defined(__FreeBSD__)\n\t\ts = splusb();\n#endif\n\t}\n#if defined(__FreeBSD__)\n\tsplx(s);\n#endif\n\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <machine/bus.h>",
            "#include \"usb_if.h\"",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/vnode.h>",
            "#include <sys/select.h>",
            "#include <sys/poll.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/filio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/proc.h>",
            "#include <sys/kthread.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usb_discover __P((struct usb_softc *));",
            "Static struct",
            "Static struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusb_discover __P((struct usb_softc *));\nStatic struct;\nStatic struct;\n\nusbd_status\nusb_discover(sc)\n\tstruct usb_softc *sc;\n{\n#if defined(__FreeBSD__)\n\t/* The splxxx parts should be deleted when kthreads is available */\n\tint s;\n#endif\n\n\t/* \n\t * We need mutual exclusion while traversing the device tree,\n\t * but this is guaranteed since this function is only called\n\t * from the event thread for the controller.\n\t */\n#if defined(__FreeBSD__)\n\ts = splusb();\n#endif\n\twhile (sc->sc_bus->needs_explore && !sc->sc_dying) {\n\t\tsc->sc_bus->needs_explore = 0;\n#if defined(__FreeBSD__)\n\t\tsplx(s);\n#endif\n\t\tsc->sc_bus->root_hub->hub->explore(sc->sc_bus->root_hub);\n#if defined(__FreeBSD__)\n\t\ts = splusb();\n#endif\n\t}\n#if defined(__FreeBSD__)\n\tsplx(s);\n#endif\n\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USB_GET_SC",
          "args": [
            "usb",
            "unit",
            "sc"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "devt"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define USB_DEV_MINOR 255\n\nStatic usbd_status;\nusb_discover __P((struct usb_softc *));\nStatic struct;\nStatic struct;\nproc *usb_async_proc;\n\nint\nusbioctl(devt, cmd, data, flag, p)\n\tdev_t devt;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct usb_softc *sc;\n\tint unit = minor(devt);\n\n\tif (unit == USB_DEV_MINOR) {\n\t\tswitch (cmd) {\n\t\tcase FIONBIO:\n\t\t\t/* All handled in the upper FS layer. */\n\t\t\treturn (0);\n\t\t\t\n\t\tcase FIOASYNC:\n\t\t\tif (*(int *)data)\n\t\t\t\tusb_async_proc = p;\n\t\t\telse\n\t\t\t\tusb_async_proc = 0;\n\t\t\treturn (0);\n\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\t}\n\n\tUSB_GET_SC(usb, unit, sc);\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tswitch (cmd) {\n#if defined(__FreeBSD__) \n\t/* This part should be deleted when kthreads is available */\n  \tcase USB_DISCOVER:\n  \t\tusb_discover(sc);\n  \t\tbreak;\n#endif\n#ifdef USB_DEBUG\n\tcase USB_SETDEBUG:\n\t\tusbdebug  = ((*(int *)data) & 0x000000ff);\n#ifdef UHCI_DEBUG\n\t\tuhcidebug = ((*(int *)data) & 0x0000ff00) >> 8;\n#endif\n#ifdef OHCI_DEBUG\n\t\tohcidebug = ((*(int *)data) & 0x00ff0000) >> 16;\n#endif\n\t\tbreak;\n#endif\n\tcase USB_REQUEST:\n\t{\n\t\tstruct usb_ctl_request *ur = (void *)data;\n\t\tint len = UGETW(ur->request.wLength);\n\t\tstruct iovec iov;\n\t\tstruct uio uio;\n\t\tvoid *ptr = 0;\n\t\tint addr = ur->addr;\n\t\tusbd_status err;\n\t\tint error = 0;\n\n\t\tDPRINTF((\"usbioctl: USB_REQUEST addr=%d len=%d\\n\", addr, len));\n\t\tif (len < 0 || len > 32768)\n\t\t\treturn (EINVAL);\n\t\tif (addr < 0 || addr >= USB_MAX_DEVICES || \n\t\t    sc->sc_bus->devices[addr] == 0)\n\t\t\treturn (EINVAL);\n\t\tif (len != 0) {\n\t\t\tiov.iov_base = (caddr_t)ur->data;\n\t\t\tiov.iov_len = len;\n\t\t\tuio.uio_iov = &iov;\n\t\t\tuio.uio_iovcnt = 1;\n\t\t\tuio.uio_resid = len;\n\t\t\tuio.uio_offset = 0;\n\t\t\tuio.uio_segflg = UIO_USERSPACE;\n\t\t\tuio.uio_rw =\n\t\t\t\tur->request.bmRequestType & UT_READ ? \n\t\t\t\tUIO_READ : UIO_WRITE;\n\t\t\tuio.uio_procp = p;\n\t\t\tptr = malloc(len, M_TEMP, M_WAITOK);\n\t\t\tif (uio.uio_rw == UIO_WRITE) {\n\t\t\t\terror = uiomove(ptr, len, &uio);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\t\terr = usbd_do_request_flags(sc->sc_bus->devices[addr],\n\t\t\t  &ur->request, ptr, ur->flags, &ur->actlen);\n\t\tif (err) {\n\t\t\terror = EIO;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (len != 0) {\n\t\t\tif (uio.uio_rw == UIO_READ) {\n\t\t\t\terror = uiomove(ptr, len, &uio);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\tret:\n\t\tif (ptr)\n\t\t\tfree(ptr, M_TEMP);\n\t\treturn (error);\n\t}\n\n\tcase USB_DEVICEINFO:\n\t{\n\t\tstruct usb_device_info *di = (void *)data;\n\t\tint addr = di->addr;\n\t\tusbd_device_handle dev;\n\n\t\tif (addr < 1 || addr >= USB_MAX_DEVICES)\n\t\t\treturn (EINVAL);\n\t\tdev = sc->sc_bus->devices[addr];\n\t\tif (dev == NULL)\n\t\t\treturn (ENXIO);\n\t\tusbd_fill_deviceinfo(dev, di);\n\t\tbreak;\n\t}\n\n\tcase USB_DEVICESTATS:\n\t\t*(struct usb_device_stats *)data = sc->sc_bus->stats;\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "usbclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
    "lines": "390-404",
    "snippet": "int\nusbclose(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag, mode;\n\tstruct proc *p;\n{\n\tint unit = minor(dev);\n\n\tif (unit == USB_DEV_MINOR) {\n\t\tusb_async_proc = 0;\n\t\tusb_dev_open = 0;\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <machine/bus.h>",
      "#include \"usb_if.h\"",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/vnode.h>",
      "#include <sys/select.h>",
      "#include <sys/poll.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/filio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/kthread.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define USB_DEV_MINOR 255"
    ],
    "globals_used": [
      "Static struct",
      "Static struct",
      "proc *usb_async_proc;",
      "Static int usb_dev_open = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define USB_DEV_MINOR 255\n\nStatic struct;\nStatic struct;\nproc *usb_async_proc;\nStatic int usb_dev_open = 0;\n\nint\nusbclose(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag, mode;\n\tstruct proc *p;\n{\n\tint unit = minor(dev);\n\n\tif (unit == USB_DEV_MINOR) {\n\t\tusb_async_proc = 0;\n\t\tusb_dev_open = 0;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "usbread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
    "lines": "354-388",
    "snippet": "int\nusbread(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct usb_event ue;\n\tint s, error, n;\n\n\tif (minor(dev) != USB_DEV_MINOR)\n\t\treturn (ENXIO);\n\n\tif (uio->uio_resid != sizeof(struct usb_event))\n\t\treturn (EINVAL);\n\n\terror = 0;\n\ts = splusb();\n\tfor (;;) {\n\t\tn = usb_get_next_event(&ue);\n\t\tif (n != 0)\n\t\t\tbreak;\n\t\tif (flag & IO_NDELAY) {\n\t\t\terror = EWOULDBLOCK;\n\t\t\tbreak;\n\t\t}\n\t\terror = tsleep(&usb_events, PZERO | PCATCH, \"usbrea\", 0);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\tsplx(s);\n\tif (!error)\n\t\terror = uiomove((void *)&ue, uio->uio_resid, uio);\n\n\treturn (error);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <machine/bus.h>",
      "#include \"usb_if.h\"",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/vnode.h>",
      "#include <sys/select.h>",
      "#include <sys/poll.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/filio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/kthread.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define USB_DEV_MINOR 255"
    ],
    "globals_used": [
      "Static SIMPLEQ_HEAD(, usb_event_q) usb_events = \n\tSIMPLEQ_HEAD_INITIALIZER(usb_events);",
      "Static struct",
      "Static struct",
      "usb_add_event __P((int, struct usb_event *));",
      "usb_get_next_event __P((struct usb_event *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "(void *)&ue",
            "uio->uio_resid",
            "uio"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "&usb_events",
            "PZERO | PCATCH",
            "\"usbrea\"",
            "0"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_get_next_event",
          "args": [
            "&ue"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "usb_get_next_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
          "lines": "631-645",
          "snippet": "int\nusb_get_next_event(ue)\n\tstruct usb_event *ue;\n{\n\tstruct usb_event_q *ueq;\n\n\tif (usb_nevents <= 0)\n\t\treturn (0);\n\tueq = SIMPLEQ_FIRST(&usb_events);\n\t*ue = ueq->ue;\n\tSIMPLEQ_REMOVE_HEAD(&usb_events, ueq, next);\n\tfree(ueq, M_USBDEV);\n\tusb_nevents--;\n\treturn (1);\n}",
          "includes": [
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <machine/bus.h>",
            "#include \"usb_if.h\"",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/vnode.h>",
            "#include <sys/select.h>",
            "#include <sys/poll.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/filio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/proc.h>",
            "#include <sys/kthread.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static SIMPLEQ_HEAD(, usb_event_q) usb_events = \n\tSIMPLEQ_HEAD_INITIALIZER(usb_events);",
            "Static int usb_nevents = 0;",
            "Static struct",
            "Static struct",
            "usb_add_event __P((int, struct usb_event *));",
            "usb_get_next_event __P((struct usb_event *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic SIMPLEQ_HEAD(, usb_event_q) usb_events = \n\tSIMPLEQ_HEAD_INITIALIZER(usb_events);\nStatic int usb_nevents = 0;\nStatic struct;\nStatic struct;\nusb_add_event __P((int, struct usb_event *));\nusb_get_next_event __P((struct usb_event *));\n\nint\nusb_get_next_event(ue)\n\tstruct usb_event *ue;\n{\n\tstruct usb_event_q *ueq;\n\n\tif (usb_nevents <= 0)\n\t\treturn (0);\n\tueq = SIMPLEQ_FIRST(&usb_events);\n\t*ue = ueq->ue;\n\tSIMPLEQ_REMOVE_HEAD(&usb_events, ueq, next);\n\tfree(ueq, M_USBDEV);\n\tusb_nevents--;\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define USB_DEV_MINOR 255\n\nStatic SIMPLEQ_HEAD(, usb_event_q) usb_events = \n\tSIMPLEQ_HEAD_INITIALIZER(usb_events);\nStatic struct;\nStatic struct;\nusb_add_event __P((int, struct usb_event *));\nusb_get_next_event __P((struct usb_event *));\n\nint\nusbread(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct usb_event ue;\n\tint s, error, n;\n\n\tif (minor(dev) != USB_DEV_MINOR)\n\t\treturn (ENXIO);\n\n\tif (uio->uio_resid != sizeof(struct usb_event))\n\t\treturn (EINVAL);\n\n\terror = 0;\n\ts = splusb();\n\tfor (;;) {\n\t\tn = usb_get_next_event(&ue);\n\t\tif (n != 0)\n\t\t\tbreak;\n\t\tif (flag & IO_NDELAY) {\n\t\t\terror = EWOULDBLOCK;\n\t\t\tbreak;\n\t\t}\n\t\terror = tsleep(&usb_events, PZERO | PCATCH, \"usbrea\", 0);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\tsplx(s);\n\tif (!error)\n\t\terror = uiomove((void *)&ue, uio->uio_resid, uio);\n\n\treturn (error);\n}"
  },
  {
    "function_name": "usbopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
    "lines": "329-352",
    "snippet": "int\nusbopen(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag, mode;\n\tstruct proc *p;\n{\n\tint unit = minor(dev);\n\tstruct usb_softc *sc;\n\n\tif (unit == USB_DEV_MINOR) {\n\t\tif (usb_dev_open)\n\t\t\treturn (EBUSY);\n\t\tusb_dev_open = 1;\n\t\tusb_async_proc = 0;\n\t\treturn (0);\n\t}\n\n\tUSB_GET_SC_OPEN(usb, unit, sc);\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <machine/bus.h>",
      "#include \"usb_if.h\"",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/vnode.h>",
      "#include <sys/select.h>",
      "#include <sys/poll.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/filio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/kthread.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define USB_DEV_MINOR 255"
    ],
    "globals_used": [
      "usb_discover __P((struct usb_softc *));",
      "Static struct",
      "Static struct",
      "proc *usb_async_proc;",
      "Static int usb_dev_open = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "USB_GET_SC_OPEN",
          "args": [
            "usb",
            "unit",
            "sc"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define USB_DEV_MINOR 255\n\nusb_discover __P((struct usb_softc *));\nStatic struct;\nStatic struct;\nproc *usb_async_proc;\nStatic int usb_dev_open = 0;\n\nint\nusbopen(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag, mode;\n\tstruct proc *p;\n{\n\tint unit = minor(dev);\n\tstruct usb_softc *sc;\n\n\tif (unit == USB_DEV_MINOR) {\n\t\tif (usb_dev_open)\n\t\t\treturn (EBUSY);\n\t\tusb_dev_open = 1;\n\t\tusb_async_proc = 0;\n\t\treturn (0);\n\t}\n\n\tUSB_GET_SC_OPEN(usb, unit, sc);\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "usbctlprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
    "lines": "316-326",
    "snippet": "int\nusbctlprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\t/* only \"usb\"es can attach to host controllers */\n\tif (pnp)\n\t\tprintf(\"usb at %s\", pnp);\n\n\treturn (UNCONF);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <machine/bus.h>",
      "#include \"usb_if.h\"",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/vnode.h>",
      "#include <sys/select.h>",
      "#include <sys/poll.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/filio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/kthread.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"usb at %s\"",
            "pnp"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nusbctlprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\t/* only \"usb\"es can attach to host controllers */\n\tif (pnp)\n\t\tprintf(\"usb at %s\", pnp);\n\n\treturn (UNCONF);\n}"
  },
  {
    "function_name": "usb_event_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
    "lines": "278-314",
    "snippet": "void\nusb_event_thread(arg)\n\tvoid *arg;\n{\n\tstruct usb_softc *sc = arg;\n\tint first = 1;\n\n\tDPRINTF((\"usb_event_thread: start\\n\"));\n\n\t/* Make sure first discover does something. */\n\tsc->sc_bus->needs_explore = 1;\n\n\twhile (!sc->sc_dying) {\n#ifdef USB_DEBUG\n\t\tif (usb_noexplore < 2)\n#endif\n\t\tusb_discover(sc);\n\t\tif (first) {\n\t\t\tconfig_pending_decr();\n\t\t\tfirst = 0;\n\t\t}\n\t\t(void)tsleep(&sc->sc_bus->needs_explore, PWAIT, \"usbevt\",\n#ifdef USB_DEBUG\n\t\t\t     usb_noexplore ? 0 :\n#endif\n\t\t\t     hz*60\n\t\t\t);\n\t\tDPRINTFN(2,(\"usb_event_thread: woke up\\n\"));\n\t}\n\tsc->sc_event_thread = 0;\n\n\t/* In case parent is waiting for us to exit. */\n\twakeup(sc);\n\n\tDPRINTF((\"usb_event_thread: exit\\n\"));\n\tkthread_exit(0);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <machine/bus.h>",
      "#include \"usb_if.h\"",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/vnode.h>",
      "#include <sys/select.h>",
      "#include <sys/poll.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/filio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/kthread.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usb_discover __P((struct usb_softc *));",
      "Static struct",
      "Static struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_exit",
          "args": [
            "0"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usb_event_thread: exit\\n\")"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "sc"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"usb_event_thread: woke up\\n\")"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "&sc->sc_bus->needs_explore",
            "PWAIT",
            "\"usbevt\"",
            "#ifdef USB_DEBUGusb_noexplore ? 0 :\n#endif\n\t\t\t     hz*60"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_pending_decr",
          "args": [],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_discover",
          "args": [
            "sc"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "usb_discover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
          "lines": "584-616",
          "snippet": "usbd_status\nusb_discover(sc)\n\tstruct usb_softc *sc;\n{\n#if defined(__FreeBSD__)\n\t/* The splxxx parts should be deleted when kthreads is available */\n\tint s;\n#endif\n\n\t/* \n\t * We need mutual exclusion while traversing the device tree,\n\t * but this is guaranteed since this function is only called\n\t * from the event thread for the controller.\n\t */\n#if defined(__FreeBSD__)\n\ts = splusb();\n#endif\n\twhile (sc->sc_bus->needs_explore && !sc->sc_dying) {\n\t\tsc->sc_bus->needs_explore = 0;\n#if defined(__FreeBSD__)\n\t\tsplx(s);\n#endif\n\t\tsc->sc_bus->root_hub->hub->explore(sc->sc_bus->root_hub);\n#if defined(__FreeBSD__)\n\t\ts = splusb();\n#endif\n\t}\n#if defined(__FreeBSD__)\n\tsplx(s);\n#endif\n\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <machine/bus.h>",
            "#include \"usb_if.h\"",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/vnode.h>",
            "#include <sys/select.h>",
            "#include <sys/poll.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/filio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/proc.h>",
            "#include <sys/kthread.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usb_discover __P((struct usb_softc *));",
            "Static struct",
            "Static struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusb_discover __P((struct usb_softc *));\nStatic struct;\nStatic struct;\n\nusbd_status\nusb_discover(sc)\n\tstruct usb_softc *sc;\n{\n#if defined(__FreeBSD__)\n\t/* The splxxx parts should be deleted when kthreads is available */\n\tint s;\n#endif\n\n\t/* \n\t * We need mutual exclusion while traversing the device tree,\n\t * but this is guaranteed since this function is only called\n\t * from the event thread for the controller.\n\t */\n#if defined(__FreeBSD__)\n\ts = splusb();\n#endif\n\twhile (sc->sc_bus->needs_explore && !sc->sc_dying) {\n\t\tsc->sc_bus->needs_explore = 0;\n#if defined(__FreeBSD__)\n\t\tsplx(s);\n#endif\n\t\tsc->sc_bus->root_hub->hub->explore(sc->sc_bus->root_hub);\n#if defined(__FreeBSD__)\n\t\ts = splusb();\n#endif\n\t}\n#if defined(__FreeBSD__)\n\tsplx(s);\n#endif\n\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usb_event_thread: start\\n\")"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusb_discover __P((struct usb_softc *));\nStatic struct;\nStatic struct;\n\nvoid\nusb_event_thread(arg)\n\tvoid *arg;\n{\n\tstruct usb_softc *sc = arg;\n\tint first = 1;\n\n\tDPRINTF((\"usb_event_thread: start\\n\"));\n\n\t/* Make sure first discover does something. */\n\tsc->sc_bus->needs_explore = 1;\n\n\twhile (!sc->sc_dying) {\n#ifdef USB_DEBUG\n\t\tif (usb_noexplore < 2)\n#endif\n\t\tusb_discover(sc);\n\t\tif (first) {\n\t\t\tconfig_pending_decr();\n\t\t\tfirst = 0;\n\t\t}\n\t\t(void)tsleep(&sc->sc_bus->needs_explore, PWAIT, \"usbevt\",\n#ifdef USB_DEBUG\n\t\t\t     usb_noexplore ? 0 :\n#endif\n\t\t\t     hz*60\n\t\t\t);\n\t\tDPRINTFN(2,(\"usb_event_thread: woke up\\n\"));\n\t}\n\tsc->sc_event_thread = 0;\n\n\t/* In case parent is waiting for us to exit. */\n\twakeup(sc);\n\n\tDPRINTF((\"usb_event_thread: exit\\n\"));\n\tkthread_exit(0);\n}"
  },
  {
    "function_name": "usb_create_event_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
    "lines": "264-276",
    "snippet": "void\nusb_create_event_thread(arg)\n\tvoid *arg;\n{\n\tstruct usb_softc *sc = arg;\n\n\tif (usb_kthread_create1(usb_event_thread, sc, &sc->sc_event_thread,\n\t\t\t   \"%s\", sc->sc_dev.dv_xname)) {\n\t\tprintf(\"%s: unable to create event thread for\\n\",\n\t\t       sc->sc_dev.dv_xname);\n\t\tpanic(\"usb_create_event_thread\");\n\t}\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <machine/bus.h>",
      "#include \"usb_if.h\"",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/vnode.h>",
      "#include <sys/select.h>",
      "#include <sys/poll.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/filio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/proc.h>",
      "#include <sys/kthread.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usb_discover __P((struct usb_softc *));",
      "Static struct",
      "Static struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"usb_create_event_thread\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unable to create event thread for\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usb_kthread_create1",
          "args": [
            "usb_event_thread",
            "sc",
            "&sc->sc_event_thread",
            "\"%s\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusb_discover __P((struct usb_softc *));\nStatic struct;\nStatic struct;\n\nvoid\nusb_create_event_thread(arg)\n\tvoid *arg;\n{\n\tstruct usb_softc *sc = arg;\n\n\tif (usb_kthread_create1(usb_event_thread, sc, &sc->sc_event_thread,\n\t\t\t   \"%s\", sc->sc_dev.dv_xname)) {\n\t\tprintf(\"%s: unable to create event thread for\\n\",\n\t\t       sc->sc_dev.dv_xname);\n\t\tpanic(\"usb_create_event_thread\");\n\t}\n}"
  }
]