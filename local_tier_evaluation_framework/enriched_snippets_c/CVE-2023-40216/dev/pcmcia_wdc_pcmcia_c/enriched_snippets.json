[
  {
    "function_name": "wdc_pcmcia_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/wdc_pcmcia.c",
    "lines": "480-514",
    "snippet": "int\nwdc_pcmcia_enable(arg, onoff)\n\tvoid *arg;\n\tint onoff;\n{\n\tstruct wdc_pcmcia_softc *sc = arg;\n\n\tif (onoff) {\n                if ((sc->sc_flags & WDC_PCMCIA_ATTACH) == 0) {\n\t\t\tif (pcmcia_function_enable(sc->sc_pf)) {\n\t\t\t\tprintf(\"%s: couldn't enable PCMCIA function\\n\",\n\t\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\t\t\t\treturn (EIO);\n\t\t\t}\n\n\t\t\tsc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_BIO, \n\t\t\t    wdcintr, &sc->wdc_channel);\n\t\t\tif (sc->sc_ih == NULL) {\n\t\t\t\tprintf(\"%s: \"\n\t\t\t\t    \"couldn't establish interrupt handler\\n\",\n\t\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\t\t\t\tpcmcia_function_disable(sc->sc_pf);\n\t\t\t\treturn (EIO);\n\t\t\t}\n\n\t\t\twdcreset(&sc->wdc_channel, VERBOSE);\n\t\t}\n\t} else {\n                if ((sc->sc_flags & WDC_PCMCIA_ATTACH) == 0)\n\t\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\t\tpcmcia_function_disable(sc->sc_pf);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define WDC_PCMCIA_ATTACH       0x0001"
    ],
    "globals_used": [
      "int\twdc_pcmcia_enable"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_function_disable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "570-622",
          "snippet": "void\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_disestablish",
          "args": [
            "sc->sc_pf",
            "sc->sc_ih"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_intr_disestablish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "784-866",
          "snippet": "void\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int pcmcia_card_intr",
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int ipl;",
            "int (*ih_fct)",
            "void *ih_arg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint pcmcia_card_intr;\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint ipl;\nint (*ih_fct);\nvoid *ih_arg;\n\nvoid\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdcreset",
          "args": [
            "&sc->wdc_channel",
            "VERBOSE"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "wdcreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "788-820",
          "snippet": "int\nwdcreset(chp, verb)\n\tstruct channel_softc *chp;\n\tint verb;\n{\n\tint drv_mask1, drv_mask2;\n\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM); /* master */\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_RST | WDCTL_IDS);\n\tdelay(1000);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n\tdelay(2000);\n\t(void) CHP_READ_REG(chp,wdr_error);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);\n\n\tdrv_mask1 = (chp->ch_drive[0].drive_flags & DRIVE) ? 0x01:0x00;\n\tdrv_mask1 |= (chp->ch_drive[1].drive_flags & DRIVE) ? 0x02:0x00;\n\tdrv_mask2 = __wdcwait_reset(chp, drv_mask1);\n\tif (verb && drv_mask2 != drv_mask1) {\n\t\tprintf(\"%s channel %d: reset failed for\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel);\n\t\tif ((drv_mask1 & 0x01) != 0 && (drv_mask2 & 0x01) == 0)\n\t\t\tprintf(\" drive 0\");\n\t\tif ((drv_mask1 & 0x02) != 0 && (drv_mask2 & 0x02) == 0)\n\t\t\tprintf(\" drive 1\");\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn  (drv_mask1 != drv_mask2) ? 1 : 0;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int   __wdcwait_reset",
            "struct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int   __wdcwait_reset;\nstruct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};\n\nint\nwdcreset(chp, verb)\n\tstruct channel_softc *chp;\n\tint verb;\n{\n\tint drv_mask1, drv_mask2;\n\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM); /* master */\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_RST | WDCTL_IDS);\n\tdelay(1000);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n\tdelay(2000);\n\t(void) CHP_READ_REG(chp,wdr_error);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);\n\n\tdrv_mask1 = (chp->ch_drive[0].drive_flags & DRIVE) ? 0x01:0x00;\n\tdrv_mask1 |= (chp->ch_drive[1].drive_flags & DRIVE) ? 0x02:0x00;\n\tdrv_mask2 = __wdcwait_reset(chp, drv_mask1);\n\tif (verb && drv_mask2 != drv_mask1) {\n\t\tprintf(\"%s channel %d: reset failed for\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel);\n\t\tif ((drv_mask1 & 0x01) != 0 && (drv_mask2 & 0x01) == 0)\n\t\t\tprintf(\" drive 0\");\n\t\tif ((drv_mask1 & 0x02) != 0 && (drv_mask2 & 0x02) == 0)\n\t\t\tprintf(\" drive 1\");\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn  (drv_mask1 != drv_mask2) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: \"\n\t\t\t\t    \"couldn't establish interrupt handler\\n\"",
            "sc->sc_wdcdev.sc_dev.dv_xname"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_establish",
          "args": [
            "sc->sc_pf",
            "IPL_BIO",
            "wdcintr",
            "&sc->wdc_channel"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_function_enable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "419-567",
          "snippet": "int\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int (*ih_fct)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\n\nint\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/wdcvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WDC_PCMCIA_ATTACH       0x0001\n\nint\twdc_pcmcia_enable;\n\nint\nwdc_pcmcia_enable(arg, onoff)\n\tvoid *arg;\n\tint onoff;\n{\n\tstruct wdc_pcmcia_softc *sc = arg;\n\n\tif (onoff) {\n                if ((sc->sc_flags & WDC_PCMCIA_ATTACH) == 0) {\n\t\t\tif (pcmcia_function_enable(sc->sc_pf)) {\n\t\t\t\tprintf(\"%s: couldn't enable PCMCIA function\\n\",\n\t\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\t\t\t\treturn (EIO);\n\t\t\t}\n\n\t\t\tsc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_BIO, \n\t\t\t    wdcintr, &sc->wdc_channel);\n\t\t\tif (sc->sc_ih == NULL) {\n\t\t\t\tprintf(\"%s: \"\n\t\t\t\t    \"couldn't establish interrupt handler\\n\",\n\t\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\t\t\t\tpcmcia_function_disable(sc->sc_pf);\n\t\t\t\treturn (EIO);\n\t\t\t}\n\n\t\t\twdcreset(&sc->wdc_channel, VERBOSE);\n\t\t}\n\t} else {\n                if ((sc->sc_flags & WDC_PCMCIA_ATTACH) == 0)\n\t\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\t\tpcmcia_function_disable(sc->sc_pf);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "wdc_pcmcia_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/wdc_pcmcia.c",
    "lines": "436-477",
    "snippet": "int\nwdc_pcmcia_activate(self, act)\n\tstruct device *self;\n\tenum devact act;\n{\n\tstruct wdc_pcmcia_softc *sc = (struct wdc_pcmcia_softc *)self;\n\tint rv = 0, s;\n\n\ts = splbio();\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\tif (pcmcia_function_enable(sc->sc_pf)) {\n\t\t\tprintf(\"%s: couldn't enable PCMCIA function\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\t\t\trv = EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tsc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_BIO, \n\t\t    wdcintr, &sc->wdc_channel);\n\t\tif (sc->sc_ih == NULL) {\n\t\t\tprintf(\"%s: \"\n\t\t\t    \"couldn't establish interrupt handler\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\t\t\tpcmcia_function_disable(sc->sc_pf);\n\t\t\trv = EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\twdcreset(&sc->wdc_channel, VERBOSE);\n\t\trv = wdcactivate(self, act);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\t\tpcmcia_function_disable(sc->sc_pf);\n\t\trv = wdcactivate(self, act);\n\t\tbreak;\n\t}\n\tsplx(s);\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int    wdc_pcmcia_activate"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdcactivate",
          "args": [
            "self",
            "act"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "wdcactivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "454-467",
          "snippet": "int\nwdcactivate(self, act)\n\tstruct device *self;\n\tenum devact act;\n{\n\tint error = 0;\n\tint s;\n\n\ts = splbio();\n\tconfig_activate_children(self, act);\n\tsplx(s);\n\n\treturn (error);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nwdcactivate(self, act)\n\tstruct device *self;\n\tenum devact act;\n{\n\tint error = 0;\n\tint s;\n\n\ts = splbio();\n\tconfig_activate_children(self, act);\n\tsplx(s);\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_function_disable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "570-622",
          "snippet": "void\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_disestablish",
          "args": [
            "sc->sc_pf",
            "sc->sc_ih"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_intr_disestablish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "784-866",
          "snippet": "void\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int pcmcia_card_intr",
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int ipl;",
            "int (*ih_fct)",
            "void *ih_arg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint pcmcia_card_intr;\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint ipl;\nint (*ih_fct);\nvoid *ih_arg;\n\nvoid\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdcreset",
          "args": [
            "&sc->wdc_channel",
            "VERBOSE"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "wdcreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "788-820",
          "snippet": "int\nwdcreset(chp, verb)\n\tstruct channel_softc *chp;\n\tint verb;\n{\n\tint drv_mask1, drv_mask2;\n\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM); /* master */\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_RST | WDCTL_IDS);\n\tdelay(1000);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n\tdelay(2000);\n\t(void) CHP_READ_REG(chp,wdr_error);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);\n\n\tdrv_mask1 = (chp->ch_drive[0].drive_flags & DRIVE) ? 0x01:0x00;\n\tdrv_mask1 |= (chp->ch_drive[1].drive_flags & DRIVE) ? 0x02:0x00;\n\tdrv_mask2 = __wdcwait_reset(chp, drv_mask1);\n\tif (verb && drv_mask2 != drv_mask1) {\n\t\tprintf(\"%s channel %d: reset failed for\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel);\n\t\tif ((drv_mask1 & 0x01) != 0 && (drv_mask2 & 0x01) == 0)\n\t\t\tprintf(\" drive 0\");\n\t\tif ((drv_mask1 & 0x02) != 0 && (drv_mask2 & 0x02) == 0)\n\t\t\tprintf(\" drive 1\");\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn  (drv_mask1 != drv_mask2) ? 1 : 0;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int   __wdcwait_reset",
            "struct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int   __wdcwait_reset;\nstruct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};\n\nint\nwdcreset(chp, verb)\n\tstruct channel_softc *chp;\n\tint verb;\n{\n\tint drv_mask1, drv_mask2;\n\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM); /* master */\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_RST | WDCTL_IDS);\n\tdelay(1000);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n\tdelay(2000);\n\t(void) CHP_READ_REG(chp,wdr_error);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);\n\n\tdrv_mask1 = (chp->ch_drive[0].drive_flags & DRIVE) ? 0x01:0x00;\n\tdrv_mask1 |= (chp->ch_drive[1].drive_flags & DRIVE) ? 0x02:0x00;\n\tdrv_mask2 = __wdcwait_reset(chp, drv_mask1);\n\tif (verb && drv_mask2 != drv_mask1) {\n\t\tprintf(\"%s channel %d: reset failed for\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel);\n\t\tif ((drv_mask1 & 0x01) != 0 && (drv_mask2 & 0x01) == 0)\n\t\t\tprintf(\" drive 0\");\n\t\tif ((drv_mask1 & 0x02) != 0 && (drv_mask2 & 0x02) == 0)\n\t\t\tprintf(\" drive 1\");\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn  (drv_mask1 != drv_mask2) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: \"\n\t\t\t    \"couldn't establish interrupt handler\\n\"",
            "sc->sc_wdcdev.sc_dev.dv_xname"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_establish",
          "args": [
            "sc->sc_pf",
            "IPL_BIO",
            "wdcintr",
            "&sc->wdc_channel"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_function_enable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "419-567",
          "snippet": "int\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int (*ih_fct)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\n\nint\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/wdcvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint    wdc_pcmcia_activate;\n\nint\nwdc_pcmcia_activate(self, act)\n\tstruct device *self;\n\tenum devact act;\n{\n\tstruct wdc_pcmcia_softc *sc = (struct wdc_pcmcia_softc *)self;\n\tint rv = 0, s;\n\n\ts = splbio();\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\tif (pcmcia_function_enable(sc->sc_pf)) {\n\t\t\tprintf(\"%s: couldn't enable PCMCIA function\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\t\t\trv = EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tsc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_BIO, \n\t\t    wdcintr, &sc->wdc_channel);\n\t\tif (sc->sc_ih == NULL) {\n\t\t\tprintf(\"%s: \"\n\t\t\t    \"couldn't establish interrupt handler\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\t\t\tpcmcia_function_disable(sc->sc_pf);\n\t\t\trv = EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\twdcreset(&sc->wdc_channel, VERBOSE);\n\t\trv = wdcactivate(self, act);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\t\tpcmcia_function_disable(sc->sc_pf);\n\t\trv = wdcactivate(self, act);\n\t\tbreak;\n\t}\n\tsplx(s);\n\treturn (rv);\n}"
  },
  {
    "function_name": "wdc_pcmcia_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/wdc_pcmcia.c",
    "lines": "407-434",
    "snippet": "int\nwdc_pcmcia_detach(self, flags)\n\tstruct device *self;\n\tint  flags;\n{\n        struct wdc_pcmcia_softc *sc = (struct wdc_pcmcia_softc *)self;\n        int error;\n\n        if (sc->sc_iowindow == -1)\n                /* Nothing to detach */\n                return (0);\n\t\n\tif ((error = wdcdetach(&sc->wdc_channel, flags)) != 0) \n\t\treturn (error);\n\n        if (sc->wdc_channel.ch_queue != NULL)\n                free(sc->wdc_channel.ch_queue, M_DEVBUF);\n\n        /* Unmap our i/o window and i/o space. */\n        pcmcia_io_unmap(sc->sc_pf, sc->sc_iowindow);\n        pcmcia_io_free(sc->sc_pf, &sc->sc_pioh);\n        if (sc->sc_auxiowindow != -1) {\n                pcmcia_io_unmap(sc->sc_pf, sc->sc_auxiowindow);\n                pcmcia_io_free(sc->sc_pf, &sc->sc_auxpioh);\n        }\n\n        return (0);\n}",
    "includes": [
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int    wdc_pcmcia_detach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_io_free",
          "args": [
            "sc->sc_pf",
            "&sc->sc_auxpioh"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1873-1896",
          "snippet": "void\npccbb_pcmcia_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n#if !rbus\n\tbus_space_tag_t iot = pcihp->iot;\n#endif\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n#if rbus\n\tstruct pccbb_softc *sc =\n\t    (struct pccbb_softc *)((struct pcic_handle *)pch)->ph_parent;\n\trbus_tag_t rb = sc->sc_rbus_iot;\n\n\trbus_space_free(rb, ioh, size, NULL);\n#else\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n#endif\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "pccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));",
            "pccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));",
            "pccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\npccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));\npccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));\npccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nvoid\npccbb_pcmcia_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n#if !rbus\n\tbus_space_tag_t iot = pcihp->iot;\n#endif\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n#if rbus\n\tstruct pccbb_softc *sc =\n\t    (struct pccbb_softc *)((struct pcic_handle *)pch)->ph_parent;\n\trbus_tag_t rb = sc->sc_rbus_iot;\n\n\trbus_space_free(rb, ioh, size, NULL);\n#else\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_io_unmap",
          "args": [
            "sc->sc_pf",
            "sc->sc_auxiowindow"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2057-2081",
          "snippet": "STATIC void\npccbb_pcmcia_io_unmap(pch, win)\n\tpcmcia_chipset_handle_t pch;\n\tint win;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (win >= PCIC_IO_WINS || win < 0) {\n\t\tpanic(\"pccbb_pcmcia_io_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->ioalloc &= ~(1 << win);\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pcic_handle *ph = poll->ph;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pcic_handle *ph = poll->ph;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_io_unmap(pch, win)\n\tpcmcia_chipset_handle_t pch;\n\tint win;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (win >= PCIC_IO_WINS || win < 0) {\n\t\tpanic(\"pccbb_pcmcia_io_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->ioalloc &= ~(1 << win);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sc->wdc_channel.ch_queue",
            "M_DEVBUF"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "ray_free_ccs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2156-2172",
          "snippet": "u_int8_t\nray_free_ccs(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tu_int8_t stat;\n\n\tRAY_DPRINTF((\"%s: free_ccs idx %ld\\n\", sc->sc_xname,\n\t    RAY_GET_INDEX(ccs)));\n\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_FREE);\n\tif (ccs <= RAY_GET_CCS(RAY_CCS_LAST))\n\t\tsc->sc_ccsinuse[RAY_GET_INDEX(ccs)] = 0;\n\n\treturn (stat);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "u_int8_t ray_free_ccs"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nu_int8_t ray_free_ccs;\n\nu_int8_t\nray_free_ccs(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tu_int8_t stat;\n\n\tRAY_DPRINTF((\"%s: free_ccs idx %ld\\n\", sc->sc_xname,\n\t    RAY_GET_INDEX(ccs)));\n\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_FREE);\n\tif (ccs <= RAY_GET_CCS(RAY_CCS_LAST))\n\t\tsc->sc_ccsinuse[RAY_GET_INDEX(ccs)] = 0;\n\n\treturn (stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdcdetach",
          "args": [
            "&sc->wdc_channel",
            "flags"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "wdcdetach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "712-726",
          "snippet": "int\nwdcdetach(chp, flags)\n\tstruct channel_softc *chp;\n\tint flags;\n{\n\tint s, rv;\n\n\ts = splbio();\n\twdc_kill_pending(chp);\n\n\trv = config_detach_children((struct device *)chp->wdc, flags);\n\tsplx(s);\n\n\treturn (rv);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void  wdc_kill_pending",
            "struct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid  wdc_kill_pending;\nstruct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;\n\nint\nwdcdetach(chp, flags)\n\tstruct channel_softc *chp;\n\tint flags;\n{\n\tint s, rv;\n\n\ts = splbio();\n\twdc_kill_pending(chp);\n\n\trv = config_detach_children((struct device *)chp->wdc, flags);\n\tsplx(s);\n\n\treturn (rv);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/wdcvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint    wdc_pcmcia_detach;\n\nint\nwdc_pcmcia_detach(self, flags)\n\tstruct device *self;\n\tint  flags;\n{\n        struct wdc_pcmcia_softc *sc = (struct wdc_pcmcia_softc *)self;\n        int error;\n\n        if (sc->sc_iowindow == -1)\n                /* Nothing to detach */\n                return (0);\n\t\n\tif ((error = wdcdetach(&sc->wdc_channel, flags)) != 0) \n\t\treturn (error);\n\n        if (sc->wdc_channel.ch_queue != NULL)\n                free(sc->wdc_channel.ch_queue, M_DEVBUF);\n\n        /* Unmap our i/o window and i/o space. */\n        pcmcia_io_unmap(sc->sc_pf, sc->sc_iowindow);\n        pcmcia_io_free(sc->sc_pf, &sc->sc_pioh);\n        if (sc->sc_auxiowindow != -1) {\n                pcmcia_io_unmap(sc->sc_pf, sc->sc_auxiowindow);\n                pcmcia_io_free(sc->sc_pf, &sc->sc_auxpioh);\n        }\n\n        return (0);\n}"
  },
  {
    "function_name": "wdc_pcmcia_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/wdc_pcmcia.c",
    "lines": "247-405",
    "snippet": "static void\nwdc_pcmcia_attach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tstruct wdc_pcmcia_softc *sc = (void *)self;\n\tstruct pcmcia_attach_args *pa = aux;\n\tstruct pcmcia_config_entry *cfe;\n\tstruct wdc_pcmcia_product *wpp;\n\tint quirks;\n\n\tsc->sc_pf = pa->pf;\n\n\tfor (cfe = SIMPLEQ_FIRST(&pa->pf->cfe_head); cfe != NULL;\n\t    cfe = SIMPLEQ_NEXT(cfe, cfe_list)) {\n\t\tif (cfe->num_iospace != 1 && cfe->num_iospace != 2)\n\t\t\tcontinue;\n\n\t\tif (pcmcia_io_alloc(pa->pf, cfe->iospace[0].start,\n\t\t    cfe->iospace[0].length,\n\t\t    cfe->iospace[0].start == 0 ? cfe->iospace[0].length : 0,\n\t\t    &sc->sc_pioh))\n\t\t\tcontinue;\n\n\t\tif (cfe->num_iospace == 2) {\n\t\t\tif (!pcmcia_io_alloc(pa->pf, cfe->iospace[1].start,\n\t\t\t    cfe->iospace[1].length, 0, &sc->sc_auxpioh))\n\t\t\t\tbreak;\n\t\t} else /* num_iospace == 1 */ {\n\t\t\tsc->sc_auxpioh.iot = sc->sc_pioh.iot;\n\t\t\tif (!bus_space_subregion(sc->sc_pioh.iot,\n\t\t\t    sc->sc_pioh.ioh, WDC_PCMCIA_AUXREG_OFFSET,\n\t\t\t    WDC_PCMCIA_AUXREG_NPORTS, &sc->sc_auxpioh.ioh))\n\t\t\t\tbreak;\n\t\t}\n\t\tpcmcia_io_free(pa->pf, &sc->sc_pioh);\n\t}\n\n\tif (cfe == NULL) {\n\t\tprintf(\": can't handle card info\\n\");\n\t\tgoto no_config_entry;\n\t}\n\n\t/* Enable the card. */\n\tpcmcia_function_init(pa->pf, cfe);\n\tif (pcmcia_function_enable(pa->pf)) {\n\t\tprintf(\": function enable failed\\n\");\n\t\tgoto enable_failed;\n\t}\n\n\t/*\n\t * XXX  DEC Mobile Media CDROM is not yet tested whether it works\n\t * XXX  with PCMCIA_WIDTH_IO16.  HAGIWARA SYS-COM HPC-CF32 doesn't\n\t * XXX  work with PCMCIA_WIDTH_AUTO.\n\t * XXX  CANON FC-8M (SANDISK SDCFB 8M) works for both _AUTO and IO16.\n\t * XXX  So, here is temporary work around.\n\t */\n\twpp = wdc_pcmcia_lookup(pa);\n\tif (wpp != NULL)\n\t\tquirks = wpp->wpp_quirk_flag;\n\telse\n\t\tquirks = 0;\n\n\tif (pcmcia_io_map(pa->pf, quirks & WDC_PCMCIA_FORCE_16BIT_IO ?\n\t    PCMCIA_WIDTH_IO16 : PCMCIA_WIDTH_AUTO, 0,\n\t    sc->sc_pioh.size, &sc->sc_pioh, &sc->sc_iowindow)) {\n\t\tprintf(\": can't map first I/O space\\n\");\n\t\tgoto iomap_failed;\n\t} \n\n\t/*\n\t * Currently, # of iospace is 1 except DIGITAL Mobile Media CD-ROM.\n\t * So whether the work around like above is necessary or not\n\t * is unknown.  XXX.\n\t */\n\tif (cfe->num_iospace <= 1)\n\t\tsc->sc_auxiowindow = -1;\n\telse if (pcmcia_io_map(pa->pf, PCMCIA_WIDTH_AUTO, 0,\n\t    sc->sc_auxpioh.size, &sc->sc_auxpioh, &sc->sc_auxiowindow)) {\n\t\tprintf(\": can't map second I/O space\\n\");\n\t\tgoto iomapaux_failed;\n\t}\n\n\tprintf(\" port 0x%lx/%d\",\n\t    sc->sc_pioh.addr, sc->sc_pioh.size);\n\tif (cfe->num_iospace > 1 && sc->sc_auxpioh.size > 0)\n\t\tprintf(\",0x%lx/%d\",\n\t\t    sc->sc_auxpioh.addr, sc->sc_auxpioh.size);\n\n\tsc->wdc_channel.cmd_iot = sc->sc_pioh.iot;\n\tsc->wdc_channel.cmd_ioh = sc->sc_pioh.ioh;\n\tsc->wdc_channel.ctl_iot = sc->sc_auxpioh.iot;\n\tsc->wdc_channel.ctl_ioh = sc->sc_auxpioh.ioh;\n\tsc->wdc_channel.data32iot = sc->wdc_channel.cmd_iot;\n\tsc->wdc_channel.data32ioh = sc->wdc_channel.cmd_ioh;\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32;\n\tsc->sc_wdcdev.PIO_cap = 0;\n\tsc->wdc_chanptr = &sc->wdc_channel;\n\tsc->sc_wdcdev.channels = &sc->wdc_chanptr;\n\tsc->sc_wdcdev.nchannels = 1;\n\tsc->wdc_channel.channel = 0;\n\tsc->wdc_channel.wdc = &sc->sc_wdcdev;\n\tsc->wdc_channel.ch_queue = malloc(sizeof(struct channel_queue),\n\t    M_DEVBUF, M_NOWAIT);\n\tif (sc->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\"can't allocate memory for command queue\\n\");\n\t\tgoto ch_queue_alloc_failed;\n\t}\n\tif (quirks & WDC_PCMCIA_NO_EXTRA_RESETS)\n\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_NO_EXTRA_RESETS;\n\n#ifdef notyet\n\t/* We can enable and disable the controller. */\n\tsc->sc_wdcdev.sc_atapi_adapter.scsipi_enable = wdc_pcmcia_enable;\n\n\t/*\n\t * Disable the pcmcia function now; wdcattach() will enable\n\t * us again as it adds references to probe for children.\n\t */\n\tpcmcia_function_disable(pa->pf);\n#else\n\t/* Establish the interrupt handler. */\n\tsc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_BIO, wdcintr,\n\t    &sc->wdc_channel);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"couldn't establish interrupt handler\");\n\t}\n#endif\n\n\tprintf(\"\\n\");\n\n\tsc->sc_flags |= WDC_PCMCIA_ATTACH;\n\twdcattach(&sc->wdc_channel);\n\tsc->sc_flags &= ~WDC_PCMCIA_ATTACH;\n\treturn;\n\n ch_queue_alloc_failed:\n        /* Unmap our aux i/o window. */\n        if (sc->sc_auxiowindow != -1)\n                pcmcia_io_unmap(sc->sc_pf, sc->sc_auxiowindow);\n\n iomapaux_failed:\n        /* Unmap our i/o window. */\n        pcmcia_io_unmap(sc->sc_pf, sc->sc_iowindow);\n\n iomap_failed:\n        /* Disable the function */\n        pcmcia_function_disable(sc->sc_pf);\n\n enable_failed:\n        /* Unmap our i/o space. */\n        pcmcia_io_free(sc->sc_pf, &sc->sc_pioh);\n        if (cfe->num_iospace == 2)\n                pcmcia_io_free(sc->sc_pf, &sc->sc_auxpioh);\n\n no_config_entry:\n        sc->sc_iowindow = -1;\n}",
    "includes": [
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define WDC_PCMCIA_NO_EXTRA_RESETS\t0x02 /* Only reset ctrl once */",
      "#define WDC_PCMCIA_FORCE_16BIT_IO\t0x01 /* Don't use PCMCIA_WIDTH_AUTO */",
      "#define WDC_PCMCIA_ATTACH       0x0001",
      "#define WDC_PCMCIA_AUXREG_NPORTS   2",
      "#define WDC_PCMCIA_AUXREG_OFFSET   (WDC_PCMCIA_REG_NPORTS + 6)"
    ],
    "globals_used": [
      "static void wdc_pcmcia_attach",
      "struct wdc_pcmcia_product *\n\twdc_pcmcia_lookup",
      "int\twdc_pcmcia_enable",
      "struct wdc_pcmcia_product *\nwdc_pcmcia_lookup(pa)\n\tstruct pcmcia_attach_args *pa;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_io_free",
          "args": [
            "sc->sc_pf",
            "&sc->sc_auxpioh"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1873-1896",
          "snippet": "void\npccbb_pcmcia_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n#if !rbus\n\tbus_space_tag_t iot = pcihp->iot;\n#endif\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n#if rbus\n\tstruct pccbb_softc *sc =\n\t    (struct pccbb_softc *)((struct pcic_handle *)pch)->ph_parent;\n\trbus_tag_t rb = sc->sc_rbus_iot;\n\n\trbus_space_free(rb, ioh, size, NULL);\n#else\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n#endif\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "pccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));",
            "pccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));",
            "pccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\npccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));\npccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));\npccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nvoid\npccbb_pcmcia_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n#if !rbus\n\tbus_space_tag_t iot = pcihp->iot;\n#endif\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n#if rbus\n\tstruct pccbb_softc *sc =\n\t    (struct pccbb_softc *)((struct pcic_handle *)pch)->ph_parent;\n\trbus_tag_t rb = sc->sc_rbus_iot;\n\n\trbus_space_free(rb, ioh, size, NULL);\n#else\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_function_disable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "570-622",
          "snippet": "void\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_io_unmap",
          "args": [
            "sc->sc_pf",
            "sc->sc_iowindow"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2057-2081",
          "snippet": "STATIC void\npccbb_pcmcia_io_unmap(pch, win)\n\tpcmcia_chipset_handle_t pch;\n\tint win;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (win >= PCIC_IO_WINS || win < 0) {\n\t\tpanic(\"pccbb_pcmcia_io_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->ioalloc &= ~(1 << win);\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pcic_handle *ph = poll->ph;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pcic_handle *ph = poll->ph;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_io_unmap(pch, win)\n\tpcmcia_chipset_handle_t pch;\n\tint win;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (win >= PCIC_IO_WINS || win < 0) {\n\t\tpanic(\"pccbb_pcmcia_io_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->ioalloc &= ~(1 << win);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdcattach",
          "args": [
            "&sc->wdc_channel"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "wdcattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "469-657",
          "snippet": "void\nwdcattach(chp)\n\tstruct channel_softc *chp;\n{\n\tint channel_flags, ctrl_flags, i;\n#ifndef __OpenBSD__\n\tint error;\n#endif\n\tstruct ata_atapi_attach aa_link;\n\tstruct ataparams params;\n\tstatic int inited = 0;\n\textern int cold;\n\n\tif (!cold)\n\t\tat_poll = AT_WAIT;\n\n#ifndef __OpenBSD__\n\tif ((error = wdc_addref(chp)) != 0) {\n\t\tprintf(\"%s: unable to enable controller\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n#endif\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tif (wdcprobe(chp) == 0) {\n\t\t/* If no drives, abort attach here. */\n#ifndef __OpenBSD__\n\t\twdc_delref(chp);\n#endif\n\t\treturn;\n\t}\n\n\t/* init list only once */\n\tif (inited == 0) {\n\t\tLIST_INIT(&xfer_free_list);\n\t\tinited++;\n\t}\n\tTAILQ_INIT(&chp->ch_queue->sc_xfer);\n\t\n\tfor (i = 0; i < 2; i++) {\n\t\tchp->ch_drive[i].chnl_softc = chp;\n\t\tchp->ch_drive[i].drive = i;\n\t\t/* If controller can't do 16bit flag the drives as 32bit */\n\t\tif ((chp->wdc->cap &\n\t\t    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==\n\t\t    WDC_CAPABILITY_DATA32)\n\t\t\tchp->ch_drive[i].drive_flags |= DRIVE_CAP32;\n\t\tif ((chp->ch_drive[i].drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\n\t\tif (i == 1 && ((chp->ch_drive[0].drive_flags & DRIVE) == 0))\n\t\t\tchp->ch_flags |= WDCF_ONESLAVE;\n\n\t\t/* Issue a IDENTIFY command, to try to detect slave ghost */\n\t\tif (ata_get_params(&chp->ch_drive[i], at_poll, &params) ==\n\t\t    CMD_OK) {\n\t\t\t/* If IDENTIFY succeded, this is not an OLD ctrl */\n\t\t\tchp->ch_drive[0].drive_flags &= ~DRIVE_OLD;\n\t\t\tchp->ch_drive[1].drive_flags &= ~DRIVE_OLD;\n\t\t} else {\n\t\t\tchp->ch_drive[i].drive_flags &=\n\t\t\t    ~(DRIVE_ATA | DRIVE_ATAPI);\n\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: IDENTIFY failed\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\tif ((chp->ch_drive[i].drive_flags & DRIVE_OLD) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Pre-ATA drive ?\n\t\t\t * Test registers writability (Error register not\n\t\t\t * writable, but cyllo is), then try an ATA command.\n\t\t\t */\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(10);\n\t\t\tCHP_WRITE_REG(chp, wdr_features, 0x58);\n\t\t\tCHP_WRITE_REG(chp, wdr_cyl_lo, 0xa5);\n\t\t\tif ((CHP_READ_REG(chp, wdr_error) == 0x58) ||\n\t\t\t    (CHP_READ_REG(chp, wdr_cyl_lo) != 0xa5)) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: register \"\n\t\t\t\t    \"writability failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\t    chp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(100);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: not ready\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_command, WDCC_RECAL);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: WDCC_RECAL failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t}\n\t}\n\tctrl_flags = chp->wdc->sc_dev.dv_cfdata->cf_flags;\n\tchannel_flags = (ctrl_flags >> (NBBY * chp->channel)) & 0xff;\n\n\tWDCDEBUG_PRINT((\"wdcattach: ch_drive_flags 0x%x 0x%x\\n\",\n\t    chp->ch_drive[0].drive_flags, chp->ch_drive[1].drive_flags),\n\t    DEBUG_PROBE);\n\n\t/* If no drives, abort here */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (chp->ch_drive[1].drive_flags & DRIVE) == 0)\n\t\treturn;\n\n\t/*\n\t * Attach an ATAPI bus, if needed.\n\t */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE_ATAPI) ||\n\t    (chp->ch_drive[1].drive_flags & DRIVE_ATAPI)) {\n#if NATAPISCSI > 0\n\t\twdc_atapibus_attach(chp);\n#else\n\t\t/*\n\t\t * Fills in a fake aa_link and call config_found, so that\n\t\t * the config machinery will print\n\t\t * \"atapibus at xxx not configured\"\n\t\t */\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATAPI;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = 0;\n\t\taa_link.aa_bus_private = NULL;\n\t\t(void)config_found(&chp->wdc->sc_dev, (void *)&aa_link,\n\t\t    atapi_print);\n#endif\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif ((chp->ch_drive[i].drive_flags &\n\t\t    (DRIVE_ATA | DRIVE_OLD)) == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATA;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = &chp->ch_drive[i];\n\t\tconfig_found(&chp->wdc->sc_dev, (void *)&aa_link, wdprint);\n\t}\n\n\t/*\n\t * reset drive_flags for unnatached devices, reset state for attached\n\t *  ones\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chp->ch_drive[i].drive_name[0] == 0)\n\t\t\tchp->ch_drive[i].drive_flags = 0;\n\t\telse\n\t\t\tchp->ch_drive[i].state = 0;\n\t}\n\n\t/*\n\t * Reset channel. The probe, with some combinations of ATA/ATAPI\n\t * devices keep it in a mostly working, but strange state (with busy\n\t * led on)\n\t */\n\tif ((chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {\n\t\twdcreset(chp, VERBOSE);\n\t\t/*\n\t\t * Read status registers to avoid spurious interrupts.\n\t\t */\n\t\tfor (i = 1; i >= 0; i--) {\n\t\t\tif (chp->ch_drive[i].drive_flags & DRIVE) {\n\t\t\t\tCHP_WRITE_REG(chp,\n\t\t\t\t    wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\t\tif (wait_for_unbusy(chp, 10000) < 0)\n\t\t\t\t\tprintf(\"%s:%d:%d: device busy\\n\",\n\t\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t\t    chp->channel, i);\n\t\t\t}\n\t\t}\n\t}\n#ifndef __OpenBSD__\n\twdc_delref(chp);\n#endif\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_PROBE  0x10"
          ],
          "globals_used": [
            "int   wdprint",
            "int at_poll = AT_POLL;",
            "struct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nint   wdprint;\nint at_poll = AT_POLL;\nstruct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};\n\nvoid\nwdcattach(chp)\n\tstruct channel_softc *chp;\n{\n\tint channel_flags, ctrl_flags, i;\n#ifndef __OpenBSD__\n\tint error;\n#endif\n\tstruct ata_atapi_attach aa_link;\n\tstruct ataparams params;\n\tstatic int inited = 0;\n\textern int cold;\n\n\tif (!cold)\n\t\tat_poll = AT_WAIT;\n\n#ifndef __OpenBSD__\n\tif ((error = wdc_addref(chp)) != 0) {\n\t\tprintf(\"%s: unable to enable controller\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n#endif\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tif (wdcprobe(chp) == 0) {\n\t\t/* If no drives, abort attach here. */\n#ifndef __OpenBSD__\n\t\twdc_delref(chp);\n#endif\n\t\treturn;\n\t}\n\n\t/* init list only once */\n\tif (inited == 0) {\n\t\tLIST_INIT(&xfer_free_list);\n\t\tinited++;\n\t}\n\tTAILQ_INIT(&chp->ch_queue->sc_xfer);\n\t\n\tfor (i = 0; i < 2; i++) {\n\t\tchp->ch_drive[i].chnl_softc = chp;\n\t\tchp->ch_drive[i].drive = i;\n\t\t/* If controller can't do 16bit flag the drives as 32bit */\n\t\tif ((chp->wdc->cap &\n\t\t    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==\n\t\t    WDC_CAPABILITY_DATA32)\n\t\t\tchp->ch_drive[i].drive_flags |= DRIVE_CAP32;\n\t\tif ((chp->ch_drive[i].drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\n\t\tif (i == 1 && ((chp->ch_drive[0].drive_flags & DRIVE) == 0))\n\t\t\tchp->ch_flags |= WDCF_ONESLAVE;\n\n\t\t/* Issue a IDENTIFY command, to try to detect slave ghost */\n\t\tif (ata_get_params(&chp->ch_drive[i], at_poll, &params) ==\n\t\t    CMD_OK) {\n\t\t\t/* If IDENTIFY succeded, this is not an OLD ctrl */\n\t\t\tchp->ch_drive[0].drive_flags &= ~DRIVE_OLD;\n\t\t\tchp->ch_drive[1].drive_flags &= ~DRIVE_OLD;\n\t\t} else {\n\t\t\tchp->ch_drive[i].drive_flags &=\n\t\t\t    ~(DRIVE_ATA | DRIVE_ATAPI);\n\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: IDENTIFY failed\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\tif ((chp->ch_drive[i].drive_flags & DRIVE_OLD) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Pre-ATA drive ?\n\t\t\t * Test registers writability (Error register not\n\t\t\t * writable, but cyllo is), then try an ATA command.\n\t\t\t */\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(10);\n\t\t\tCHP_WRITE_REG(chp, wdr_features, 0x58);\n\t\t\tCHP_WRITE_REG(chp, wdr_cyl_lo, 0xa5);\n\t\t\tif ((CHP_READ_REG(chp, wdr_error) == 0x58) ||\n\t\t\t    (CHP_READ_REG(chp, wdr_cyl_lo) != 0xa5)) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: register \"\n\t\t\t\t    \"writability failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\t    chp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(100);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: not ready\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_command, WDCC_RECAL);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: WDCC_RECAL failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t}\n\t}\n\tctrl_flags = chp->wdc->sc_dev.dv_cfdata->cf_flags;\n\tchannel_flags = (ctrl_flags >> (NBBY * chp->channel)) & 0xff;\n\n\tWDCDEBUG_PRINT((\"wdcattach: ch_drive_flags 0x%x 0x%x\\n\",\n\t    chp->ch_drive[0].drive_flags, chp->ch_drive[1].drive_flags),\n\t    DEBUG_PROBE);\n\n\t/* If no drives, abort here */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (chp->ch_drive[1].drive_flags & DRIVE) == 0)\n\t\treturn;\n\n\t/*\n\t * Attach an ATAPI bus, if needed.\n\t */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE_ATAPI) ||\n\t    (chp->ch_drive[1].drive_flags & DRIVE_ATAPI)) {\n#if NATAPISCSI > 0\n\t\twdc_atapibus_attach(chp);\n#else\n\t\t/*\n\t\t * Fills in a fake aa_link and call config_found, so that\n\t\t * the config machinery will print\n\t\t * \"atapibus at xxx not configured\"\n\t\t */\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATAPI;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = 0;\n\t\taa_link.aa_bus_private = NULL;\n\t\t(void)config_found(&chp->wdc->sc_dev, (void *)&aa_link,\n\t\t    atapi_print);\n#endif\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif ((chp->ch_drive[i].drive_flags &\n\t\t    (DRIVE_ATA | DRIVE_OLD)) == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATA;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = &chp->ch_drive[i];\n\t\tconfig_found(&chp->wdc->sc_dev, (void *)&aa_link, wdprint);\n\t}\n\n\t/*\n\t * reset drive_flags for unnatached devices, reset state for attached\n\t *  ones\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chp->ch_drive[i].drive_name[0] == 0)\n\t\t\tchp->ch_drive[i].drive_flags = 0;\n\t\telse\n\t\t\tchp->ch_drive[i].state = 0;\n\t}\n\n\t/*\n\t * Reset channel. The probe, with some combinations of ATA/ATAPI\n\t * devices keep it in a mostly working, but strange state (with busy\n\t * led on)\n\t */\n\tif ((chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {\n\t\twdcreset(chp, VERBOSE);\n\t\t/*\n\t\t * Read status registers to avoid spurious interrupts.\n\t\t */\n\t\tfor (i = 1; i >= 0; i--) {\n\t\t\tif (chp->ch_drive[i].drive_flags & DRIVE) {\n\t\t\t\tCHP_WRITE_REG(chp,\n\t\t\t\t    wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\t\tif (wait_for_unbusy(chp, 10000) < 0)\n\t\t\t\t\tprintf(\"%s:%d:%d: device busy\\n\",\n\t\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t\t    chp->channel, i);\n\t\t\t}\n\t\t}\n\t}\n#ifndef __OpenBSD__\n\twdc_delref(chp);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_establish",
          "args": [
            "sc->sc_pf",
            "IPL_BIO",
            "wdcintr",
            "&sc->wdc_channel"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct channel_queue)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_io_map",
          "args": [
            "pa->pf",
            "PCMCIA_WIDTH_AUTO",
            "0",
            "sc->sc_auxpioh.size",
            "&sc->sc_auxpioh",
            "&sc->sc_auxiowindow"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_io_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "624-679",
          "snippet": "int\npcmcia_io_map(pf, width, offset, size, pcihp, windowp)\n\tstruct pcmcia_function *pf;\n\tint width;\n\tbus_addr_t offset;\n\tbus_size_t size;\n\tstruct pcmcia_io_handle *pcihp;\n\tint *windowp;\n{\n\tint reg;\n\n\tif (pcmcia_chip_io_map(pf->sc->pct, pf->sc->pch,\n\t    width, offset, size, pcihp, windowp))\n\t\treturn (1);\n\n\t/*\n\t * XXX In the multifunction multi-iospace-per-function case, this\n\t * needs to cooperate with io_alloc to make sure that the spaces\n\t * don't overlap, and that the ccr's are set correctly.\n\t */\n\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\tif (pf->pf_mfc_iomax == 0) {\n\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tpf->pf_mfc_iomax = pf->pf_mfc_iobase + size;\n\t\t} else {\n\t\t\t/* This makes the assumption that nothing overlaps. */\n\t\t\tif (pf->pf_mfc_iobase > pcihp->addr + offset)\n\t\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tif (pf->pf_mfc_iomax < pcihp->addr + offset + size)\n\t\t\t\tpf->pf_mfc_iomax = pcihp->addr + offset + size;\n\t\t}\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize >= tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\n\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\treg |= PCMCIA_CCR_OPTION_ADDR_DECODE;\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nint\npcmcia_io_map(pf, width, offset, size, pcihp, windowp)\n\tstruct pcmcia_function *pf;\n\tint width;\n\tbus_addr_t offset;\n\tbus_size_t size;\n\tstruct pcmcia_io_handle *pcihp;\n\tint *windowp;\n{\n\tint reg;\n\n\tif (pcmcia_chip_io_map(pf->sc->pct, pf->sc->pch,\n\t    width, offset, size, pcihp, windowp))\n\t\treturn (1);\n\n\t/*\n\t * XXX In the multifunction multi-iospace-per-function case, this\n\t * needs to cooperate with io_alloc to make sure that the spaces\n\t * don't overlap, and that the ccr's are set correctly.\n\t */\n\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\tif (pf->pf_mfc_iomax == 0) {\n\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tpf->pf_mfc_iomax = pf->pf_mfc_iobase + size;\n\t\t} else {\n\t\t\t/* This makes the assumption that nothing overlaps. */\n\t\t\tif (pf->pf_mfc_iobase > pcihp->addr + offset)\n\t\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tif (pf->pf_mfc_iomax < pcihp->addr + offset + size)\n\t\t\t\tpf->pf_mfc_iomax = pcihp->addr + offset + size;\n\t\t}\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize >= tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\n\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\treg |= PCMCIA_CCR_OPTION_ADDR_DECODE;\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_pcmcia_lookup",
          "args": [
            "pa"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_function_enable",
          "args": [
            "pa->pf"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "419-567",
          "snippet": "int\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int (*ih_fct)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\n\nint\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_function_init",
          "args": [
            "pa->pf",
            "cfe"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "392-402",
          "snippet": "void\npcmcia_function_init(pf, cfe)\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_config_entry *cfe;\n{\n\tif (pf->pf_flags & PFF_ENABLED)\n\t\tpanic(\"pcmcia_function_init: function is enabled\");\n\n\t/* Remember which configuration entry we are using. */\n\tpf->cfe = cfe;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_init(pf, cfe)\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_config_entry *cfe;\n{\n\tif (pf->pf_flags & PFF_ENABLED)\n\t\tpanic(\"pcmcia_function_init: function is enabled\");\n\n\t/* Remember which configuration entry we are using. */\n\tpf->cfe = cfe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_subregion",
          "args": [
            "sc->sc_pioh.iot",
            "sc->sc_pioh.ioh",
            "WDC_PCMCIA_AUXREG_OFFSET",
            "WDC_PCMCIA_AUXREG_NPORTS",
            "&sc->sc_auxpioh.ioh"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_io_alloc",
          "args": [
            "pa->pf",
            "cfe->iospace[1].start",
            "cfe->iospace[1].length",
            "0",
            "&sc->sc_auxpioh"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1803-1863",
          "snippet": "STATIC int\npccbb_pcmcia_io_alloc(pch, start, size, align, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_addr_t start;\t       /* start address */\n\tbus_size_t size;\n\tbus_size_t align;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t ioaddr;\n\tint flags = 0;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\tif (align == 0) {\n\t\talign = size;\t       /* XXX: funny??? */\n\t}\n\n\t/* \n\t * Allocate some arbitrary I/O space.\n\t */\n\n\tiot = ((struct pccbb_softc *)(ph->ph_parent))->sc_iot;\n\n#if rbus\n\trb = ((struct pccbb_softc *)(ph->ph_parent))->sc_rbus_iot;\n\t/* XXX: I assume all card decode lower 10 bits by its hardware */\n\tif (rbus_space_alloc(rb, start, size, 0x3ff, align, 0, &ioaddr, &ioh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (start) {\n\t\tioaddr = start;\n\t\tif (bus_space_map(iot, start, size, 0, &ioh)) {\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmcia_io_alloc map port %lx+%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t} else {\n\t\tflags |= PCMCIA_IO_ALLOCATED;\n\t\tif (bus_space_alloc(iot, 0x700 /* ph->sc->sc_iobase */ ,\n\t\t    0x800,\t/* ph->sc->sc_iobase + ph->sc->sc_iosize */\n\t\t    size, align, 0, 0, &ioaddr, &ioh)) {\n\t\t\t/* No room be able to be get. */\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmmcia_io_alloc alloc port 0x%lx+0x%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t}\n#endif\n\n\tpcihp->iot = iot;\n\tpcihp->ioh = ioh;\n\tpcihp->addr = ioaddr;\n\tpcihp->size = size;\n\tpcihp->flags = flags;\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "pccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));",
            "STATIC void",
            "pccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));",
            "STATIC int",
            "pccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pcic_handle *ph = poll->ph;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\npccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));\nSTATIC void;\npccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));\nSTATIC int;\npccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC int\npccbb_pcmcia_io_alloc(pch, start, size, align, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_addr_t start;\t       /* start address */\n\tbus_size_t size;\n\tbus_size_t align;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t ioaddr;\n\tint flags = 0;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\tif (align == 0) {\n\t\talign = size;\t       /* XXX: funny??? */\n\t}\n\n\t/* \n\t * Allocate some arbitrary I/O space.\n\t */\n\n\tiot = ((struct pccbb_softc *)(ph->ph_parent))->sc_iot;\n\n#if rbus\n\trb = ((struct pccbb_softc *)(ph->ph_parent))->sc_rbus_iot;\n\t/* XXX: I assume all card decode lower 10 bits by its hardware */\n\tif (rbus_space_alloc(rb, start, size, 0x3ff, align, 0, &ioaddr, &ioh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (start) {\n\t\tioaddr = start;\n\t\tif (bus_space_map(iot, start, size, 0, &ioh)) {\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmcia_io_alloc map port %lx+%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t} else {\n\t\tflags |= PCMCIA_IO_ALLOCATED;\n\t\tif (bus_space_alloc(iot, 0x700 /* ph->sc->sc_iobase */ ,\n\t\t    0x800,\t/* ph->sc->sc_iobase + ph->sc->sc_iosize */\n\t\t    size, align, 0, 0, &ioaddr, &ioh)) {\n\t\t\t/* No room be able to be get. */\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmmcia_io_alloc alloc port 0x%lx+0x%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t}\n#endif\n\n\tpcihp->iot = iot;\n\tpcihp->ioh = ioh;\n\tpcihp->addr = ioaddr;\n\tpcihp->size = size;\n\tpcihp->flags = flags;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_NEXT",
          "args": [
            "cfe",
            "cfe_list"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&pa->pf->cfe_head"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/wdcvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WDC_PCMCIA_NO_EXTRA_RESETS\t0x02 /* Only reset ctrl once */\n#define WDC_PCMCIA_FORCE_16BIT_IO\t0x01 /* Don't use PCMCIA_WIDTH_AUTO */\n#define WDC_PCMCIA_ATTACH       0x0001\n#define WDC_PCMCIA_AUXREG_NPORTS   2\n#define WDC_PCMCIA_AUXREG_OFFSET   (WDC_PCMCIA_REG_NPORTS + 6)\n\nstatic void wdc_pcmcia_attach;\nstruct wdc_pcmcia_product *\n\twdc_pcmcia_lookup;\nint\twdc_pcmcia_enable;\nstruct wdc_pcmcia_product *\nwdc_pcmcia_lookup(pa)\n\tstruct pcmcia_attach_args *pa;\n\nstatic void\nwdc_pcmcia_attach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tstruct wdc_pcmcia_softc *sc = (void *)self;\n\tstruct pcmcia_attach_args *pa = aux;\n\tstruct pcmcia_config_entry *cfe;\n\tstruct wdc_pcmcia_product *wpp;\n\tint quirks;\n\n\tsc->sc_pf = pa->pf;\n\n\tfor (cfe = SIMPLEQ_FIRST(&pa->pf->cfe_head); cfe != NULL;\n\t    cfe = SIMPLEQ_NEXT(cfe, cfe_list)) {\n\t\tif (cfe->num_iospace != 1 && cfe->num_iospace != 2)\n\t\t\tcontinue;\n\n\t\tif (pcmcia_io_alloc(pa->pf, cfe->iospace[0].start,\n\t\t    cfe->iospace[0].length,\n\t\t    cfe->iospace[0].start == 0 ? cfe->iospace[0].length : 0,\n\t\t    &sc->sc_pioh))\n\t\t\tcontinue;\n\n\t\tif (cfe->num_iospace == 2) {\n\t\t\tif (!pcmcia_io_alloc(pa->pf, cfe->iospace[1].start,\n\t\t\t    cfe->iospace[1].length, 0, &sc->sc_auxpioh))\n\t\t\t\tbreak;\n\t\t} else /* num_iospace == 1 */ {\n\t\t\tsc->sc_auxpioh.iot = sc->sc_pioh.iot;\n\t\t\tif (!bus_space_subregion(sc->sc_pioh.iot,\n\t\t\t    sc->sc_pioh.ioh, WDC_PCMCIA_AUXREG_OFFSET,\n\t\t\t    WDC_PCMCIA_AUXREG_NPORTS, &sc->sc_auxpioh.ioh))\n\t\t\t\tbreak;\n\t\t}\n\t\tpcmcia_io_free(pa->pf, &sc->sc_pioh);\n\t}\n\n\tif (cfe == NULL) {\n\t\tprintf(\": can't handle card info\\n\");\n\t\tgoto no_config_entry;\n\t}\n\n\t/* Enable the card. */\n\tpcmcia_function_init(pa->pf, cfe);\n\tif (pcmcia_function_enable(pa->pf)) {\n\t\tprintf(\": function enable failed\\n\");\n\t\tgoto enable_failed;\n\t}\n\n\t/*\n\t * XXX  DEC Mobile Media CDROM is not yet tested whether it works\n\t * XXX  with PCMCIA_WIDTH_IO16.  HAGIWARA SYS-COM HPC-CF32 doesn't\n\t * XXX  work with PCMCIA_WIDTH_AUTO.\n\t * XXX  CANON FC-8M (SANDISK SDCFB 8M) works for both _AUTO and IO16.\n\t * XXX  So, here is temporary work around.\n\t */\n\twpp = wdc_pcmcia_lookup(pa);\n\tif (wpp != NULL)\n\t\tquirks = wpp->wpp_quirk_flag;\n\telse\n\t\tquirks = 0;\n\n\tif (pcmcia_io_map(pa->pf, quirks & WDC_PCMCIA_FORCE_16BIT_IO ?\n\t    PCMCIA_WIDTH_IO16 : PCMCIA_WIDTH_AUTO, 0,\n\t    sc->sc_pioh.size, &sc->sc_pioh, &sc->sc_iowindow)) {\n\t\tprintf(\": can't map first I/O space\\n\");\n\t\tgoto iomap_failed;\n\t} \n\n\t/*\n\t * Currently, # of iospace is 1 except DIGITAL Mobile Media CD-ROM.\n\t * So whether the work around like above is necessary or not\n\t * is unknown.  XXX.\n\t */\n\tif (cfe->num_iospace <= 1)\n\t\tsc->sc_auxiowindow = -1;\n\telse if (pcmcia_io_map(pa->pf, PCMCIA_WIDTH_AUTO, 0,\n\t    sc->sc_auxpioh.size, &sc->sc_auxpioh, &sc->sc_auxiowindow)) {\n\t\tprintf(\": can't map second I/O space\\n\");\n\t\tgoto iomapaux_failed;\n\t}\n\n\tprintf(\" port 0x%lx/%d\",\n\t    sc->sc_pioh.addr, sc->sc_pioh.size);\n\tif (cfe->num_iospace > 1 && sc->sc_auxpioh.size > 0)\n\t\tprintf(\",0x%lx/%d\",\n\t\t    sc->sc_auxpioh.addr, sc->sc_auxpioh.size);\n\n\tsc->wdc_channel.cmd_iot = sc->sc_pioh.iot;\n\tsc->wdc_channel.cmd_ioh = sc->sc_pioh.ioh;\n\tsc->wdc_channel.ctl_iot = sc->sc_auxpioh.iot;\n\tsc->wdc_channel.ctl_ioh = sc->sc_auxpioh.ioh;\n\tsc->wdc_channel.data32iot = sc->wdc_channel.cmd_iot;\n\tsc->wdc_channel.data32ioh = sc->wdc_channel.cmd_ioh;\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32;\n\tsc->sc_wdcdev.PIO_cap = 0;\n\tsc->wdc_chanptr = &sc->wdc_channel;\n\tsc->sc_wdcdev.channels = &sc->wdc_chanptr;\n\tsc->sc_wdcdev.nchannels = 1;\n\tsc->wdc_channel.channel = 0;\n\tsc->wdc_channel.wdc = &sc->sc_wdcdev;\n\tsc->wdc_channel.ch_queue = malloc(sizeof(struct channel_queue),\n\t    M_DEVBUF, M_NOWAIT);\n\tif (sc->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\"can't allocate memory for command queue\\n\");\n\t\tgoto ch_queue_alloc_failed;\n\t}\n\tif (quirks & WDC_PCMCIA_NO_EXTRA_RESETS)\n\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_NO_EXTRA_RESETS;\n\n#ifdef notyet\n\t/* We can enable and disable the controller. */\n\tsc->sc_wdcdev.sc_atapi_adapter.scsipi_enable = wdc_pcmcia_enable;\n\n\t/*\n\t * Disable the pcmcia function now; wdcattach() will enable\n\t * us again as it adds references to probe for children.\n\t */\n\tpcmcia_function_disable(pa->pf);\n#else\n\t/* Establish the interrupt handler. */\n\tsc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_BIO, wdcintr,\n\t    &sc->wdc_channel);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"couldn't establish interrupt handler\");\n\t}\n#endif\n\n\tprintf(\"\\n\");\n\n\tsc->sc_flags |= WDC_PCMCIA_ATTACH;\n\twdcattach(&sc->wdc_channel);\n\tsc->sc_flags &= ~WDC_PCMCIA_ATTACH;\n\treturn;\n\n ch_queue_alloc_failed:\n        /* Unmap our aux i/o window. */\n        if (sc->sc_auxiowindow != -1)\n                pcmcia_io_unmap(sc->sc_pf, sc->sc_auxiowindow);\n\n iomapaux_failed:\n        /* Unmap our i/o window. */\n        pcmcia_io_unmap(sc->sc_pf, sc->sc_iowindow);\n\n iomap_failed:\n        /* Disable the function */\n        pcmcia_function_disable(sc->sc_pf);\n\n enable_failed:\n        /* Unmap our i/o space. */\n        pcmcia_io_free(sc->sc_pf, &sc->sc_pioh);\n        if (cfe->num_iospace == 2)\n                pcmcia_io_free(sc->sc_pf, &sc->sc_auxpioh);\n\n no_config_entry:\n        sc->sc_iowindow = -1;\n}"
  },
  {
    "function_name": "wdc_pcmcia_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/wdc_pcmcia.c",
    "lines": "221-245",
    "snippet": "static int\nwdc_pcmcia_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pcmcia_attach_args *pa = aux;\n\tstruct pcmcia_softc *sc;\n\tint iftype;\n\n\tif (wdc_pcmcia_lookup(pa) != NULL)\n\t\treturn (1);\n\n\tif (pa->pf->function == PCMCIA_FUNCTION_DISK) {\n\t\tsc = pa->pf->sc;\n\n\t\tpcmcia_chip_socket_enable(sc->pct, sc->pch);\n\t\tiftype = wdc_pcmcia_disk_device_interface(pa->pf);\n\t\tpcmcia_chip_socket_disable(sc->pct, sc->pch);\n\n\t\tif (iftype == PCMCIA_TPLFE_DDI_PCCARD_ATA)\n\t\t\treturn (1);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wdc_pcmcia_match",
      "int\twdc_pcmcia_disk_device_interface",
      "struct wdc_pcmcia_product *\n\twdc_pcmcia_lookup",
      "struct wdc_pcmcia_product *\nwdc_pcmcia_lookup(pa)\n\tstruct pcmcia_attach_args *pa;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_chip_socket_disable",
          "args": [
            "sc->pct",
            "sc->pch"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_pcmcia_disk_device_interface",
          "args": [
            "pa->pf"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_pcmcia_disk_device_interface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/wdc_pcmcia.c",
          "lines": "177-190",
          "snippet": "int\nwdc_pcmcia_disk_device_interface(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct wdc_pcmcia_disk_device_interface_args ddi;\n\n\tddi.ddi_reqfn = pf->number;\n\tddi.ddi_curfn = -1;\n\tif (pcmcia_scan_cis((struct device *)pf->sc,\n\t    wdc_pcmcia_disk_device_interface_callback, &ddi) > 0)\n\t\treturn (ddi.ddi_type);\n\telse\n\t\treturn (-1);\n}",
          "includes": [
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\twdc_pcmcia_disk_device_interface_callback",
            "int\twdc_pcmcia_disk_device_interface"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/wdcvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\twdc_pcmcia_disk_device_interface_callback;\nint\twdc_pcmcia_disk_device_interface;\n\nint\nwdc_pcmcia_disk_device_interface(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct wdc_pcmcia_disk_device_interface_args ddi;\n\n\tddi.ddi_reqfn = pf->number;\n\tddi.ddi_curfn = -1;\n\tif (pcmcia_scan_cis((struct device *)pf->sc,\n\t    wdc_pcmcia_disk_device_interface_callback, &ddi) > 0)\n\t\treturn (ddi.ddi_type);\n\telse\n\t\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_chip_socket_enable",
          "args": [
            "sc->pct",
            "sc->pch"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_pcmcia_lookup",
          "args": [
            "pa"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/wdcvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int wdc_pcmcia_match;\nint\twdc_pcmcia_disk_device_interface;\nstruct wdc_pcmcia_product *\n\twdc_pcmcia_lookup;\nstruct wdc_pcmcia_product *\nwdc_pcmcia_lookup(pa)\n\tstruct pcmcia_attach_args *pa;\n\nstatic int\nwdc_pcmcia_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pcmcia_attach_args *pa = aux;\n\tstruct pcmcia_softc *sc;\n\tint iftype;\n\n\tif (wdc_pcmcia_lookup(pa) != NULL)\n\t\treturn (1);\n\n\tif (pa->pf->function == PCMCIA_FUNCTION_DISK) {\n\t\tsc = pa->pf->sc;\n\n\t\tpcmcia_chip_socket_enable(sc->pct, sc->pch);\n\t\tiftype = wdc_pcmcia_disk_device_interface(pa->pf);\n\t\tpcmcia_chip_socket_disable(sc->pct, sc->pch);\n\n\t\tif (iftype == PCMCIA_TPLFE_DDI_PCCARD_ATA)\n\t\t\treturn (1);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "wdc_pcmcia_disk_device_interface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/wdc_pcmcia.c",
    "lines": "177-190",
    "snippet": "int\nwdc_pcmcia_disk_device_interface(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct wdc_pcmcia_disk_device_interface_args ddi;\n\n\tddi.ddi_reqfn = pf->number;\n\tddi.ddi_curfn = -1;\n\tif (pcmcia_scan_cis((struct device *)pf->sc,\n\t    wdc_pcmcia_disk_device_interface_callback, &ddi) > 0)\n\t\treturn (ddi.ddi_type);\n\telse\n\t\treturn (-1);\n}",
    "includes": [
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twdc_pcmcia_disk_device_interface_callback",
      "int\twdc_pcmcia_disk_device_interface"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_scan_cis",
          "args": [
            "(struct device *)pf->sc",
            "wdc_pcmcia_disk_device_interface_callback",
            "&ddi"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_scan_cis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia_cis.c",
          "lines": "91-433",
          "snippet": "int\npcmcia_scan_cis(dev, fct, arg)\n\tstruct device *dev;\n\tint (*fct) __P((struct pcmcia_tuple *, void *));\n\tvoid *arg;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tpcmcia_chipset_tag_t pct;\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n\tstruct pcmcia_mem_handle pcmh;\n\tstruct pcmcia_tuple tuple;\n\tint longlink_present;\n\tint longlink_common;\n\tu_long longlink_addr;\n\tint mfc_count;\n\tint mfc_index;\n\tstruct {\n\t\tint\tcommon;\n\t\tu_long\taddr;\n\t} mfc[256 / 5];\n\tint ret;\n\n\tret = 0;\n\n\tpct = sc->pct;\n\tpch = sc->pch;\n\n\t/* allocate some memory */\n\n\tif (pcmcia_chip_mem_alloc(pct, pch, PCMCIA_CIS_SIZE, &pcmh)) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: can't alloc memory to read attributes\\n\",\n\t\t    sc->dev.dv_xname);\n#endif\n\t\treturn -1;\n\t}\n\ttuple.memt = pcmh.memt;\n\ttuple.memh = pcmh.memh;\n\n\t/* initialize state for the primary tuple chain */\n\tif (pcmcia_chip_mem_map(pct, pch, PCMCIA_MEM_ATTR, 0,\n\t    PCMCIA_CIS_SIZE, &pcmh, &tuple.ptr, &window)) {\n\t\tpcmcia_chip_mem_free(pct, pch, &pcmh);\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: can't map memory to read attributes\\n\",\n\t\t    sc->dev.dv_xname);\n#endif\n\t\treturn -1;\n\t}\n\tDPRINTF((\"cis mem map %x\\n\", (unsigned int) tuple.memh));\n\n\ttuple.mult = 2;\n\n\tlonglink_present = 1;\n\tlonglink_common = 1;\n\tlonglink_addr = 0;\n\n\tmfc_count = 0;\n\tmfc_index = 0;\n\n\tDPRINTF((\"%s: CIS tuple chain:\\n\", sc->dev.dv_xname));\n\n\twhile (1) {\n\t\twhile (1) {\n\t\t\t/* get the tuple code */\n\n\t\t\ttuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);\n\n\t\t\t/* two special-case tuples */\n\n\t\t\tif (tuple.code == PCMCIA_CISTPL_NULL) {\n\t\t\t\tDPRINTF((\"CISTPL_NONE\\n 00\\n\"));\n\t\t\t\ttuple.ptr++;\n\t\t\t\tcontinue;\n\t\t\t} else if (tuple.code == PCMCIA_CISTPL_END) {\n\t\t\t\tDPRINTF((\"CISTPL_END\\n ff\\n\"));\n\t\t\t\t/* Call the function for the END tuple, since\n\t\t\t\t   the CIS semantics depend on it */\n\t\t\t\tif ((*fct) (&tuple, arg)) {\n\t\t\t\t\tpcmcia_chip_mem_unmap(pct, pch,\n\t\t\t\t\t\t\t      window);\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\ttuple.ptr++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* now all the normal tuples */\n\n\t\t\ttuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);\n\t\t\tswitch (tuple.code) {\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_A:\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_C:\n\t\t\t\tif (tuple.length < 4) {\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_%s too \"\n\t\t\t\t\t    \"short %d\\n\",\n\t\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t\t    tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlonglink_present = 1;\n\t\t\t\tlonglink_common = (tuple.code ==\n\t\t\t\t    PCMCIA_CISTPL_LONGLINK_C) ? 1 : 0;\n\t\t\t\tlonglink_addr = pcmcia_tuple_read_4(&tuple, 0);\n\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_%s %lx\\n\",\n\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t    longlink_addr));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_NO_LINK:\n\t\t\t\tlonglink_present = 0;\n\t\t\t\tDPRINTF((\"CISTPL_NO_LINK\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_CHECKSUM:\n\t\t\t\tif (tuple.length < 5) {\n\t\t\t\t\tDPRINTF((\"CISTPL_CHECKSUM too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t} {\n\t\t\t\t\tint16_t offset;\n\t\t\t\t\tu_long addr, length;\n\t\t\t\t\tu_int cksum, sum;\n\t\t\t\t\tint i;\n\n\t\t\t\t\t*((u_int16_t *) & offset) =\n\t\t\t\t\t    pcmcia_tuple_read_2(&tuple, 0);\n\t\t\t\t\tlength = pcmcia_tuple_read_2(&tuple, 2);\n\t\t\t\t\tcksum = pcmcia_tuple_read_1(&tuple, 4);\n\n\t\t\t\t\taddr = tuple.ptr + offset;\n\n\t\t\t\t\tDPRINTF((\"CISTPL_CHECKSUM addr=%lx \"\n\t\t\t\t\t    \"len=%lx cksum=%x\",\n\t\t\t\t\t    addr, length, cksum));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * XXX do more work to deal with\n\t\t\t\t\t * distant regions\n\t\t\t\t\t */\n\t\t\t\t\tif ((addr >= PCMCIA_CIS_SIZE) ||\n\t\t\t\t\t    ((addr + length) < 0) ||\n\t\t\t\t\t    ((addr + length) >=\n\t\t\t\t\t      PCMCIA_CIS_SIZE)) {\n\t\t\t\t\t\tDPRINTF((\" skipped, \"\n\t\t\t\t\t\t    \"too distant\\n\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsum = 0;\n\t\t\t\t\tfor (i = 0; i < length; i++)\n\t\t\t\t\t\tsum +=\n\t\t\t\t\t\t    bus_space_read_1(tuple.memt,\n\t\t\t\t\t\t    tuple.memh,\n\t\t\t\t\t\t    addr + tuple.mult * i);\n\t\t\t\t\tif (cksum != (sum & 0xff)) {\n\t\t\t\t\t\tDPRINTF((\" failed sum=%x\\n\",\n\t\t\t\t\t\t    sum));\n\t\t\t\t\t\tprintf(\"%s: CIS checksum \"\n\t\t\t\t\t\t    \"failed\\n\",\n\t\t\t\t\t\t    sc->dev.dv_xname);\n#if 0\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * XXX Some working cards have\n\t\t\t\t\t\t * XXX bad checksums!!\n\t\t\t\t\t\t */\n\t\t\t\t\t\tret = -1;\n#endif\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDPRINTF((\" ok\\n\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_MFC:\n\t\t\t\tif (tuple.length < 1) {\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_MFC too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * this is kind of ad hoc, as I don't have\n\t\t\t\t * any real documentation\n\t\t\t\t */\n\t\t\t\t{\n\t\t\t\t\tint i;\n\n\t\t\t\t\tmfc_count =\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0);\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_MFC %d\",\n\t\t\t\t\t    mfc_count));\n\t\t\t\t\tfor (i = 0; i < mfc_count; i++) {\n\t\t\t\t\t\tmfc[i].common =\n\t\t\t\t\t\t    (pcmcia_tuple_read_1(&tuple,\n\t\t\t\t\t\t    1 + 5 * i) ==\n\t\t\t\t\t\t    PCMCIA_MFC_MEM_COMMON) ?\n\t\t\t\t\t\t    1 : 0;\n\t\t\t\t\t\tmfc[i].addr =\n\t\t\t\t\t\t    pcmcia_tuple_read_4(&tuple,\n\t\t\t\t\t\t    1 + 5 * i + 1);\n\t\t\t\t\t\tDPRINTF((\" %s:%lx\",\n\t\t\t\t\t\t    mfc[i].common ? \"common\" :\n\t\t\t\t\t\t    \"attr\", mfc[i].addr));\n\t\t\t\t\t}\n\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * for LONGLINK_MFC, fall through to the\n\t\t\t\t * function.  This tuple has structural and\n\t\t\t\t * semantic content.\n\t\t\t\t */\n\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tif ((*fct) (&tuple, arg)) {\n\t\t\t\t\t\tpcmcia_chip_mem_unmap(pct,\n\t\t\t\t\t\t    pch, window);\n\t\t\t\t\t\tret = 1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\t/* switch */\n#ifdef PCMCIACISDEBUG\n\t\t\t/* print the tuple */\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\tDPRINTF((\" %02x %02x\", tuple.code,\n\t\t\t\t    tuple.length));\n\n\t\t\t\tfor (i = 0; i < tuple.length; i++) {\n\t\t\t\t\tDPRINTF((\" %02x\",\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, i)));\n\t\t\t\t\tif ((i % 16) == 13)\n\t\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t\t}\n\t\t\t\tif ((i % 16) != 14)\n\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t}\n#endif\n\t\t\t/* skip to the next tuple */\n\t\t\ttuple.ptr += 2 + tuple.length;\n\t\t}\n\n\t\t/*\n\t\t * the chain is done.  Clean up and move onto the next one,\n\t\t * if any.  The loop is here in the case that there is an MFC\n\t\t * card with no longlink (which defaults to existing, == 0).\n\t\t * In general, this means that if one pointer fails, it will\n\t\t * try the next one, instead of just bailing.\n\t\t */\n\n\t\twhile (1) {\n\t\t\tpcmcia_chip_mem_unmap(pct, pch, window);\n\n\t\t\tif (longlink_present) {\n\t\t\t\t/*\n\t\t\t\t * if the longlink is to attribute memory,\n\t\t\t\t * then it is unindexed.  That is, if the\n\t\t\t\t * link value is 0x100, then the actual\n\t\t\t\t * memory address is 0x200.  This means that\n\t\t\t\t * we need to multiply by 2 before calling\n\t\t\t\t * mem_map, and then divide the resulting ptr\n\t\t\t\t * by 2 after.\n\t\t\t\t */\n\n\t\t\t\tif (!longlink_common)\n\t\t\t\t\tlonglink_addr *= 2;\n\n\t\t\t\tpcmcia_chip_mem_map(pct, pch, longlink_common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,\n\t\t\t\t    longlink_addr, PCMCIA_CIS_SIZE,\n\t\t\t\t    &pcmh, &tuple.ptr, &window);\n\n\t\t\t\tif (!longlink_common)\n\t\t\t\t\ttuple.ptr /= 2;\n\n\t\t\t\tDPRINTF((\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh));\n\n\t\t\t\ttuple.mult = longlink_common ? 1 : 2;\n\t\t\t\tlonglink_present = 0;\n\t\t\t\tlonglink_common = 1;\n\t\t\t\tlonglink_addr = 0;\n\t\t\t} else if (mfc_count && (mfc_index < mfc_count)) {\n\t\t\t\tif (!mfc[mfc_index].common)\n\t\t\t\t\tmfc[mfc_index].addr *= 2;\n\n\t\t\t\tpcmcia_chip_mem_map(pct, pch,\n\t\t\t\t    mfc[mfc_index].common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,\n\t\t\t\t    mfc[mfc_index].addr, PCMCIA_CIS_SIZE,\n\t\t\t\t    &pcmh, &tuple.ptr, &window);\n\n\t\t\t\tif (!mfc[mfc_index].common)\n\t\t\t\t\ttuple.ptr /= 2;\n\n\t\t\t\tDPRINTF((\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh));\n\n\t\t\t\t/* set parse state, and point at the next one */\n\n\t\t\t\ttuple.mult = mfc[mfc_index].common ? 1 : 2;\n\n\t\t\t\tmfc_index++;\n\t\t\t} else {\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* make sure that the link is valid */\n\t\t\ttuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);\n\t\t\tif (tuple.code != PCMCIA_CISTPL_LINKTARGET) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET expected, \"\n\t\t\t\t    \"code %02x observed\\n\", tuple.code));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);\n\t\t\tif (tuple.length < 3) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET too short %d\\n\",\n\t\t\t\t    tuple.length));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((pcmcia_tuple_read_1(&tuple, 0) != 'C') ||\n\t\t\t    (pcmcia_tuple_read_1(&tuple, 1) != 'I') ||\n\t\t\t    (pcmcia_tuple_read_1(&tuple, 2) != 'S')) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET magic \"\n\t\t\t\t    \"%02x%02x%02x incorrect\\n\",\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 1),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 2)));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttuple.ptr += 2 + tuple.length;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpcmcia_chip_mem_unmap(pct, pch, window);\n\ndone:\n\t/* Last, free the allocated memory block */\n\tpcmcia_chip_mem_free(pct, pch, &pcmh);\n\n\treturn (ret);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tPCMCIA_CIS_SIZE\t\t1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tPCMCIA_CIS_SIZE\t\t1024\n\nint\npcmcia_scan_cis(dev, fct, arg)\n\tstruct device *dev;\n\tint (*fct) __P((struct pcmcia_tuple *, void *));\n\tvoid *arg;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tpcmcia_chipset_tag_t pct;\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n\tstruct pcmcia_mem_handle pcmh;\n\tstruct pcmcia_tuple tuple;\n\tint longlink_present;\n\tint longlink_common;\n\tu_long longlink_addr;\n\tint mfc_count;\n\tint mfc_index;\n\tstruct {\n\t\tint\tcommon;\n\t\tu_long\taddr;\n\t} mfc[256 / 5];\n\tint ret;\n\n\tret = 0;\n\n\tpct = sc->pct;\n\tpch = sc->pch;\n\n\t/* allocate some memory */\n\n\tif (pcmcia_chip_mem_alloc(pct, pch, PCMCIA_CIS_SIZE, &pcmh)) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: can't alloc memory to read attributes\\n\",\n\t\t    sc->dev.dv_xname);\n#endif\n\t\treturn -1;\n\t}\n\ttuple.memt = pcmh.memt;\n\ttuple.memh = pcmh.memh;\n\n\t/* initialize state for the primary tuple chain */\n\tif (pcmcia_chip_mem_map(pct, pch, PCMCIA_MEM_ATTR, 0,\n\t    PCMCIA_CIS_SIZE, &pcmh, &tuple.ptr, &window)) {\n\t\tpcmcia_chip_mem_free(pct, pch, &pcmh);\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: can't map memory to read attributes\\n\",\n\t\t    sc->dev.dv_xname);\n#endif\n\t\treturn -1;\n\t}\n\tDPRINTF((\"cis mem map %x\\n\", (unsigned int) tuple.memh));\n\n\ttuple.mult = 2;\n\n\tlonglink_present = 1;\n\tlonglink_common = 1;\n\tlonglink_addr = 0;\n\n\tmfc_count = 0;\n\tmfc_index = 0;\n\n\tDPRINTF((\"%s: CIS tuple chain:\\n\", sc->dev.dv_xname));\n\n\twhile (1) {\n\t\twhile (1) {\n\t\t\t/* get the tuple code */\n\n\t\t\ttuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);\n\n\t\t\t/* two special-case tuples */\n\n\t\t\tif (tuple.code == PCMCIA_CISTPL_NULL) {\n\t\t\t\tDPRINTF((\"CISTPL_NONE\\n 00\\n\"));\n\t\t\t\ttuple.ptr++;\n\t\t\t\tcontinue;\n\t\t\t} else if (tuple.code == PCMCIA_CISTPL_END) {\n\t\t\t\tDPRINTF((\"CISTPL_END\\n ff\\n\"));\n\t\t\t\t/* Call the function for the END tuple, since\n\t\t\t\t   the CIS semantics depend on it */\n\t\t\t\tif ((*fct) (&tuple, arg)) {\n\t\t\t\t\tpcmcia_chip_mem_unmap(pct, pch,\n\t\t\t\t\t\t\t      window);\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\ttuple.ptr++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* now all the normal tuples */\n\n\t\t\ttuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);\n\t\t\tswitch (tuple.code) {\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_A:\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_C:\n\t\t\t\tif (tuple.length < 4) {\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_%s too \"\n\t\t\t\t\t    \"short %d\\n\",\n\t\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t\t    tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlonglink_present = 1;\n\t\t\t\tlonglink_common = (tuple.code ==\n\t\t\t\t    PCMCIA_CISTPL_LONGLINK_C) ? 1 : 0;\n\t\t\t\tlonglink_addr = pcmcia_tuple_read_4(&tuple, 0);\n\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_%s %lx\\n\",\n\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t    longlink_addr));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_NO_LINK:\n\t\t\t\tlonglink_present = 0;\n\t\t\t\tDPRINTF((\"CISTPL_NO_LINK\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_CHECKSUM:\n\t\t\t\tif (tuple.length < 5) {\n\t\t\t\t\tDPRINTF((\"CISTPL_CHECKSUM too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t} {\n\t\t\t\t\tint16_t offset;\n\t\t\t\t\tu_long addr, length;\n\t\t\t\t\tu_int cksum, sum;\n\t\t\t\t\tint i;\n\n\t\t\t\t\t*((u_int16_t *) & offset) =\n\t\t\t\t\t    pcmcia_tuple_read_2(&tuple, 0);\n\t\t\t\t\tlength = pcmcia_tuple_read_2(&tuple, 2);\n\t\t\t\t\tcksum = pcmcia_tuple_read_1(&tuple, 4);\n\n\t\t\t\t\taddr = tuple.ptr + offset;\n\n\t\t\t\t\tDPRINTF((\"CISTPL_CHECKSUM addr=%lx \"\n\t\t\t\t\t    \"len=%lx cksum=%x\",\n\t\t\t\t\t    addr, length, cksum));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * XXX do more work to deal with\n\t\t\t\t\t * distant regions\n\t\t\t\t\t */\n\t\t\t\t\tif ((addr >= PCMCIA_CIS_SIZE) ||\n\t\t\t\t\t    ((addr + length) < 0) ||\n\t\t\t\t\t    ((addr + length) >=\n\t\t\t\t\t      PCMCIA_CIS_SIZE)) {\n\t\t\t\t\t\tDPRINTF((\" skipped, \"\n\t\t\t\t\t\t    \"too distant\\n\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsum = 0;\n\t\t\t\t\tfor (i = 0; i < length; i++)\n\t\t\t\t\t\tsum +=\n\t\t\t\t\t\t    bus_space_read_1(tuple.memt,\n\t\t\t\t\t\t    tuple.memh,\n\t\t\t\t\t\t    addr + tuple.mult * i);\n\t\t\t\t\tif (cksum != (sum & 0xff)) {\n\t\t\t\t\t\tDPRINTF((\" failed sum=%x\\n\",\n\t\t\t\t\t\t    sum));\n\t\t\t\t\t\tprintf(\"%s: CIS checksum \"\n\t\t\t\t\t\t    \"failed\\n\",\n\t\t\t\t\t\t    sc->dev.dv_xname);\n#if 0\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * XXX Some working cards have\n\t\t\t\t\t\t * XXX bad checksums!!\n\t\t\t\t\t\t */\n\t\t\t\t\t\tret = -1;\n#endif\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDPRINTF((\" ok\\n\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_MFC:\n\t\t\t\tif (tuple.length < 1) {\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_MFC too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * this is kind of ad hoc, as I don't have\n\t\t\t\t * any real documentation\n\t\t\t\t */\n\t\t\t\t{\n\t\t\t\t\tint i;\n\n\t\t\t\t\tmfc_count =\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0);\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_MFC %d\",\n\t\t\t\t\t    mfc_count));\n\t\t\t\t\tfor (i = 0; i < mfc_count; i++) {\n\t\t\t\t\t\tmfc[i].common =\n\t\t\t\t\t\t    (pcmcia_tuple_read_1(&tuple,\n\t\t\t\t\t\t    1 + 5 * i) ==\n\t\t\t\t\t\t    PCMCIA_MFC_MEM_COMMON) ?\n\t\t\t\t\t\t    1 : 0;\n\t\t\t\t\t\tmfc[i].addr =\n\t\t\t\t\t\t    pcmcia_tuple_read_4(&tuple,\n\t\t\t\t\t\t    1 + 5 * i + 1);\n\t\t\t\t\t\tDPRINTF((\" %s:%lx\",\n\t\t\t\t\t\t    mfc[i].common ? \"common\" :\n\t\t\t\t\t\t    \"attr\", mfc[i].addr));\n\t\t\t\t\t}\n\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * for LONGLINK_MFC, fall through to the\n\t\t\t\t * function.  This tuple has structural and\n\t\t\t\t * semantic content.\n\t\t\t\t */\n\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tif ((*fct) (&tuple, arg)) {\n\t\t\t\t\t\tpcmcia_chip_mem_unmap(pct,\n\t\t\t\t\t\t    pch, window);\n\t\t\t\t\t\tret = 1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\t/* switch */\n#ifdef PCMCIACISDEBUG\n\t\t\t/* print the tuple */\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\tDPRINTF((\" %02x %02x\", tuple.code,\n\t\t\t\t    tuple.length));\n\n\t\t\t\tfor (i = 0; i < tuple.length; i++) {\n\t\t\t\t\tDPRINTF((\" %02x\",\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, i)));\n\t\t\t\t\tif ((i % 16) == 13)\n\t\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t\t}\n\t\t\t\tif ((i % 16) != 14)\n\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t}\n#endif\n\t\t\t/* skip to the next tuple */\n\t\t\ttuple.ptr += 2 + tuple.length;\n\t\t}\n\n\t\t/*\n\t\t * the chain is done.  Clean up and move onto the next one,\n\t\t * if any.  The loop is here in the case that there is an MFC\n\t\t * card with no longlink (which defaults to existing, == 0).\n\t\t * In general, this means that if one pointer fails, it will\n\t\t * try the next one, instead of just bailing.\n\t\t */\n\n\t\twhile (1) {\n\t\t\tpcmcia_chip_mem_unmap(pct, pch, window);\n\n\t\t\tif (longlink_present) {\n\t\t\t\t/*\n\t\t\t\t * if the longlink is to attribute memory,\n\t\t\t\t * then it is unindexed.  That is, if the\n\t\t\t\t * link value is 0x100, then the actual\n\t\t\t\t * memory address is 0x200.  This means that\n\t\t\t\t * we need to multiply by 2 before calling\n\t\t\t\t * mem_map, and then divide the resulting ptr\n\t\t\t\t * by 2 after.\n\t\t\t\t */\n\n\t\t\t\tif (!longlink_common)\n\t\t\t\t\tlonglink_addr *= 2;\n\n\t\t\t\tpcmcia_chip_mem_map(pct, pch, longlink_common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,\n\t\t\t\t    longlink_addr, PCMCIA_CIS_SIZE,\n\t\t\t\t    &pcmh, &tuple.ptr, &window);\n\n\t\t\t\tif (!longlink_common)\n\t\t\t\t\ttuple.ptr /= 2;\n\n\t\t\t\tDPRINTF((\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh));\n\n\t\t\t\ttuple.mult = longlink_common ? 1 : 2;\n\t\t\t\tlonglink_present = 0;\n\t\t\t\tlonglink_common = 1;\n\t\t\t\tlonglink_addr = 0;\n\t\t\t} else if (mfc_count && (mfc_index < mfc_count)) {\n\t\t\t\tif (!mfc[mfc_index].common)\n\t\t\t\t\tmfc[mfc_index].addr *= 2;\n\n\t\t\t\tpcmcia_chip_mem_map(pct, pch,\n\t\t\t\t    mfc[mfc_index].common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,\n\t\t\t\t    mfc[mfc_index].addr, PCMCIA_CIS_SIZE,\n\t\t\t\t    &pcmh, &tuple.ptr, &window);\n\n\t\t\t\tif (!mfc[mfc_index].common)\n\t\t\t\t\ttuple.ptr /= 2;\n\n\t\t\t\tDPRINTF((\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh));\n\n\t\t\t\t/* set parse state, and point at the next one */\n\n\t\t\t\ttuple.mult = mfc[mfc_index].common ? 1 : 2;\n\n\t\t\t\tmfc_index++;\n\t\t\t} else {\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* make sure that the link is valid */\n\t\t\ttuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);\n\t\t\tif (tuple.code != PCMCIA_CISTPL_LINKTARGET) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET expected, \"\n\t\t\t\t    \"code %02x observed\\n\", tuple.code));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);\n\t\t\tif (tuple.length < 3) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET too short %d\\n\",\n\t\t\t\t    tuple.length));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((pcmcia_tuple_read_1(&tuple, 0) != 'C') ||\n\t\t\t    (pcmcia_tuple_read_1(&tuple, 1) != 'I') ||\n\t\t\t    (pcmcia_tuple_read_1(&tuple, 2) != 'S')) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET magic \"\n\t\t\t\t    \"%02x%02x%02x incorrect\\n\",\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 1),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 2)));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttuple.ptr += 2 + tuple.length;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpcmcia_chip_mem_unmap(pct, pch, window);\n\ndone:\n\t/* Last, free the allocated memory block */\n\tpcmcia_chip_mem_free(pct, pch, &pcmh);\n\n\treturn (ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/wdcvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\twdc_pcmcia_disk_device_interface_callback;\nint\twdc_pcmcia_disk_device_interface;\n\nint\nwdc_pcmcia_disk_device_interface(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct wdc_pcmcia_disk_device_interface_args ddi;\n\n\tddi.ddi_reqfn = pf->number;\n\tddi.ddi_curfn = -1;\n\tif (pcmcia_scan_cis((struct device *)pf->sc,\n\t    wdc_pcmcia_disk_device_interface_callback, &ddi) > 0)\n\t\treturn (ddi.ddi_type);\n\telse\n\t\treturn (-1);\n}"
  },
  {
    "function_name": "wdc_pcmcia_disk_device_interface_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/wdc_pcmcia.c",
    "lines": "146-175",
    "snippet": "int\nwdc_pcmcia_disk_device_interface_callback(tuple, arg)\n\tstruct pcmcia_tuple *tuple;\n\tvoid *arg;\n{\n\tstruct wdc_pcmcia_disk_device_interface_args *ddi = arg;\n\n\tswitch (tuple->code) {\n\tcase PCMCIA_CISTPL_FUNCID:\n\t\tddi->ddi_curfn++;\n\t\tbreak;\n\n\tcase PCMCIA_CISTPL_FUNCE:\n\t\tif (ddi->ddi_reqfn != ddi->ddi_curfn)\n\t\t\tbreak;\n\n\t\t/* subcode (disk device interface), data (interface type) */\n\t\tif (tuple->length < 2)\n\t\t\tbreak;\n\n\t\t/* check type */\n\t\tif (pcmcia_tuple_read_1(tuple, 0) !=\n\t\t    PCMCIA_TPLFE_TYPE_DISK_DEVICE_INTERFACE)\n\t\t\tbreak;\n\n\t\tddi->ddi_type = pcmcia_tuple_read_1(tuple, 1);\n\t\treturn (1);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twdc_pcmcia_disk_device_interface_callback"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "1"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "0"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/wdcvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\twdc_pcmcia_disk_device_interface_callback;\n\nint\nwdc_pcmcia_disk_device_interface_callback(tuple, arg)\n\tstruct pcmcia_tuple *tuple;\n\tvoid *arg;\n{\n\tstruct wdc_pcmcia_disk_device_interface_args *ddi = arg;\n\n\tswitch (tuple->code) {\n\tcase PCMCIA_CISTPL_FUNCID:\n\t\tddi->ddi_curfn++;\n\t\tbreak;\n\n\tcase PCMCIA_CISTPL_FUNCE:\n\t\tif (ddi->ddi_reqfn != ddi->ddi_curfn)\n\t\t\tbreak;\n\n\t\t/* subcode (disk device interface), data (interface type) */\n\t\tif (tuple->length < 2)\n\t\t\tbreak;\n\n\t\t/* check type */\n\t\tif (pcmcia_tuple_read_1(tuple, 0) !=\n\t\t    PCMCIA_TPLFE_TYPE_DISK_DEVICE_INTERFACE)\n\t\t\tbreak;\n\n\t\tddi->ddi_type = pcmcia_tuple_read_1(tuple, 1);\n\t\treturn (1);\n\t}\n\treturn (0);\n}"
  }
]