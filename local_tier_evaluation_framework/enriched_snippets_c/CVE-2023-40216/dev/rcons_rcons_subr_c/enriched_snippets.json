[
  {
    "function_name": "rcons_insertline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
    "lines": "577-598",
    "snippet": "void\nrcons_insertline(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int fromy, toy;\n\n\t/* Can't insert more lines than can fit */\n\tif (n > rc->rc_maxrow - *rc->rc_row)\n\t\tn = rc->rc_maxrow - *rc->rc_row;\n\n\ttoy = (*rc->rc_row + n) * rc->rc_font->height;\n\tfromy = *rc->rc_row * rc->rc_font->height;\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, toy + rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_emuheight - toy,\n\t    RAS_SRC, rc->rc_sp, rc->rc_xorigin, fromy + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, fromy + rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_font->height * n,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}",
    "includes": [
      "#include \"rcons_subr.h\"",
      "#include <dev/rcons/raster.h>",
      "#include <dev/rcons/rcons.h>",
      "#include \"myfbdevice.h\"",
      "#include <sys/types.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void rcons_bell(struct rconsole *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raster_op",
          "args": [
            "rc->rc_sp",
            "rc->rc_xorigin",
            "fromy + rc->rc_yorigin",
            "rc->rc_emuwidth",
            "rc->rc_font->height * n",
            "rc->rc_ras_blank",
            "(struct raster *) 0",
            "0",
            "0"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "raster_op_nosrc_noclip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "759-860",
          "snippet": "int\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nint\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_insertline(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int fromy, toy;\n\n\t/* Can't insert more lines than can fit */\n\tif (n > rc->rc_maxrow - *rc->rc_row)\n\t\tn = rc->rc_maxrow - *rc->rc_row;\n\n\ttoy = (*rc->rc_row + n) * rc->rc_font->height;\n\tfromy = *rc->rc_row * rc->rc_font->height;\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, toy + rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_emuheight - toy,\n\t    RAS_SRC, rc->rc_sp, rc->rc_xorigin, fromy + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, fromy + rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_font->height * n,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}"
  },
  {
    "function_name": "rcons_insertchar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
    "lines": "552-574",
    "snippet": "void\nrcons_insertchar(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int tox, fromx, y;\n\n\t/* Can't insert more chars than can fit */\n\tif (n > rc->rc_maxcol - *rc->rc_col)\n\t\tn = rc->rc_maxcol - *rc->rc_col;\n\n\ttox = (*rc->rc_col + n) * rc->rc_font->width;\n\tfromx = *rc->rc_col * rc->rc_font->width;\n\ty = *rc->rc_row * rc->rc_font->height;\n\n\traster_op(rc->rc_sp, tox + rc->rc_xorigin, y + rc->rc_yorigin,\n\t    rc->rc_emuwidth - tox, rc->rc_font->height,\n\t    RAS_SRC, rc->rc_sp, fromx + rc->rc_xorigin, y + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp, fromx + rc->rc_xorigin, y + rc->rc_yorigin,\n\t    rc->rc_font->width * n, rc->rc_font->height,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}",
    "includes": [
      "#include \"rcons_subr.h\"",
      "#include <dev/rcons/raster.h>",
      "#include <dev/rcons/rcons.h>",
      "#include \"myfbdevice.h\"",
      "#include <sys/types.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void rcons_bell(struct rconsole *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raster_op",
          "args": [
            "rc->rc_sp",
            "fromx + rc->rc_xorigin",
            "y + rc->rc_yorigin",
            "rc->rc_font->width * n",
            "rc->rc_font->height",
            "rc->rc_ras_blank",
            "(struct raster *) 0",
            "0",
            "0"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "raster_op_nosrc_noclip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "759-860",
          "snippet": "int\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nint\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_insertchar(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int tox, fromx, y;\n\n\t/* Can't insert more chars than can fit */\n\tif (n > rc->rc_maxcol - *rc->rc_col)\n\t\tn = rc->rc_maxcol - *rc->rc_col;\n\n\ttox = (*rc->rc_col + n) * rc->rc_font->width;\n\tfromx = *rc->rc_col * rc->rc_font->width;\n\ty = *rc->rc_row * rc->rc_font->height;\n\n\traster_op(rc->rc_sp, tox + rc->rc_xorigin, y + rc->rc_yorigin,\n\t    rc->rc_emuwidth - tox, rc->rc_font->height,\n\t    RAS_SRC, rc->rc_sp, fromx + rc->rc_xorigin, y + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp, fromx + rc->rc_xorigin, y + rc->rc_yorigin,\n\t    rc->rc_font->width * n, rc->rc_font->height,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}"
  },
  {
    "function_name": "rcons_delline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
    "lines": "526-549",
    "snippet": "void\nrcons_delline(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int fromy, toy, height;\n\n\t/* Can't delete more lines than there are */\n\tif (n > rc->rc_maxrow - *rc->rc_row)\n\t\tn = rc->rc_maxrow - *rc->rc_row;\n\n\tfromy = (*rc->rc_row + n) * rc->rc_font->height;\n\ttoy = *rc->rc_row * rc->rc_font->height;\n\theight = rc->rc_font->height * n;\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, toy + rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_emuheight - fromy, RAS_SRC,\n\t    rc->rc_sp, rc->rc_xorigin, fromy + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_xorigin, rc->rc_emuheight - height + rc->rc_yorigin,\n\t    rc->rc_emuwidth, height,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}",
    "includes": [
      "#include \"rcons_subr.h\"",
      "#include <dev/rcons/raster.h>",
      "#include <dev/rcons/rcons.h>",
      "#include \"myfbdevice.h\"",
      "#include <sys/types.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void rcons_bell(struct rconsole *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raster_op",
          "args": [
            "rc->rc_sp",
            "rc->rc_xorigin",
            "rc->rc_emuheight - height + rc->rc_yorigin",
            "rc->rc_emuwidth",
            "height",
            "rc->rc_ras_blank",
            "(struct raster *) 0",
            "0",
            "0"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "raster_op_nosrc_noclip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "759-860",
          "snippet": "int\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nint\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_delline(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int fromy, toy, height;\n\n\t/* Can't delete more lines than there are */\n\tif (n > rc->rc_maxrow - *rc->rc_row)\n\t\tn = rc->rc_maxrow - *rc->rc_row;\n\n\tfromy = (*rc->rc_row + n) * rc->rc_font->height;\n\ttoy = *rc->rc_row * rc->rc_font->height;\n\theight = rc->rc_font->height * n;\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, toy + rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_emuheight - fromy, RAS_SRC,\n\t    rc->rc_sp, rc->rc_xorigin, fromy + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_xorigin, rc->rc_emuheight - height + rc->rc_yorigin,\n\t    rc->rc_emuwidth, height,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}"
  },
  {
    "function_name": "rcons_delchar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
    "lines": "499-523",
    "snippet": "void\nrcons_delchar(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int tox, fromx, y, width;\n\n\t/* Can't delete more chars than there are */\n\tif (n > rc->rc_maxcol - *rc->rc_col)\n\t\tn = rc->rc_maxcol - *rc->rc_col;\n\n\tfromx = (*rc->rc_col + n) * rc->rc_font->width;\n\ttox = *rc->rc_col * rc->rc_font->width;\n\ty = *rc->rc_row * rc->rc_font->height;\n\twidth = n * rc->rc_font->width;\n\n\traster_op(rc->rc_sp, tox + rc->rc_xorigin, y + rc->rc_yorigin,\n\t    rc->rc_emuwidth - fromx, rc->rc_font->height,\n\t    RAS_SRC, rc->rc_sp, fromx + rc->rc_xorigin, y + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_emuwidth - width + rc->rc_xorigin, y + rc->rc_yorigin,\n\t    width, rc->rc_font->height,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}",
    "includes": [
      "#include \"rcons_subr.h\"",
      "#include <dev/rcons/raster.h>",
      "#include <dev/rcons/rcons.h>",
      "#include \"myfbdevice.h\"",
      "#include <sys/types.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void rcons_bell(struct rconsole *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raster_op",
          "args": [
            "rc->rc_sp",
            "rc->rc_emuwidth - width + rc->rc_xorigin",
            "y + rc->rc_yorigin",
            "width",
            "rc->rc_font->height",
            "rc->rc_ras_blank",
            "(struct raster *) 0",
            "0",
            "0"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "raster_op_nosrc_noclip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "759-860",
          "snippet": "int\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nint\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_delchar(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int tox, fromx, y, width;\n\n\t/* Can't delete more chars than there are */\n\tif (n > rc->rc_maxcol - *rc->rc_col)\n\t\tn = rc->rc_maxcol - *rc->rc_col;\n\n\tfromx = (*rc->rc_col + n) * rc->rc_font->width;\n\ttox = *rc->rc_col * rc->rc_font->width;\n\ty = *rc->rc_row * rc->rc_font->height;\n\twidth = n * rc->rc_font->width;\n\n\traster_op(rc->rc_sp, tox + rc->rc_xorigin, y + rc->rc_yorigin,\n\t    rc->rc_emuwidth - fromx, rc->rc_font->height,\n\t    RAS_SRC, rc->rc_sp, fromx + rc->rc_xorigin, y + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_emuwidth - width + rc->rc_xorigin, y + rc->rc_yorigin,\n\t    width, rc->rc_font->height,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}"
  },
  {
    "function_name": "rcons_scroll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
    "lines": "470-496",
    "snippet": "void\nrcons_scroll(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int ydiv;\n\n\t/* Can't scroll more than the whole screen */\n\tif (n > rc->rc_maxrow)\n\t\tn = rc->rc_maxrow;\n\n\t/* Calculate new row */\n\t*rc->rc_row -= n;\n\tif (*rc->rc_row < 0)\n\t\t*rc->rc_row  = 0;\n\n\t/* Calculate number of pixels to scroll */\n\tydiv = rc->rc_font->height * n;\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_emuheight - ydiv,\n\t    RAS_SRC, rc->rc_sp, rc->rc_xorigin, ydiv + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_xorigin, rc->rc_yorigin + rc->rc_emuheight - ydiv,\n\t    rc->rc_emuwidth, ydiv, rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}",
    "includes": [
      "#include \"rcons_subr.h\"",
      "#include <dev/rcons/raster.h>",
      "#include <dev/rcons/rcons.h>",
      "#include \"myfbdevice.h\"",
      "#include <sys/types.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void rcons_bell(struct rconsole *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raster_op",
          "args": [
            "rc->rc_sp",
            "rc->rc_xorigin",
            "rc->rc_yorigin + rc->rc_emuheight - ydiv",
            "rc->rc_emuwidth",
            "ydiv",
            "rc->rc_ras_blank",
            "(struct raster *) 0",
            "0",
            "0"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "raster_op_nosrc_noclip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "759-860",
          "snippet": "int\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nint\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_scroll(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int ydiv;\n\n\t/* Can't scroll more than the whole screen */\n\tif (n > rc->rc_maxrow)\n\t\tn = rc->rc_maxrow;\n\n\t/* Calculate new row */\n\t*rc->rc_row -= n;\n\tif (*rc->rc_row < 0)\n\t\t*rc->rc_row  = 0;\n\n\t/* Calculate number of pixels to scroll */\n\tydiv = rc->rc_font->height * n;\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_emuheight - ydiv,\n\t    RAS_SRC, rc->rc_sp, rc->rc_xorigin, ydiv + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_xorigin, rc->rc_yorigin + rc->rc_emuheight - ydiv,\n\t    rc->rc_emuwidth, ydiv, rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}"
  },
  {
    "function_name": "rcons_clear2eol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
    "lines": "454-467",
    "snippet": "void\nrcons_clear2eol(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int x;\n\n\tx = *rc->rc_col * rc->rc_font->width;\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_xorigin + x,\n\t    *rc->rc_row * rc->rc_font->height + rc->rc_yorigin,\n\t    rc->rc_emuwidth - x, rc->rc_font->height,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}",
    "includes": [
      "#include \"rcons_subr.h\"",
      "#include <dev/rcons/raster.h>",
      "#include <dev/rcons/rcons.h>",
      "#include \"myfbdevice.h\"",
      "#include <sys/types.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void rcons_bell(struct rconsole *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raster_op",
          "args": [
            "rc->rc_sp",
            "rc->rc_xorigin + x",
            "*rc->rc_row * rc->rc_font->height + rc->rc_yorigin",
            "rc->rc_emuwidth - x",
            "rc->rc_font->height",
            "rc->rc_ras_blank",
            "(struct raster *) 0",
            "0",
            "0"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "raster_op_nosrc_noclip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "759-860",
          "snippet": "int\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nint\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_clear2eol(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int x;\n\n\tx = *rc->rc_col * rc->rc_font->width;\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_xorigin + x,\n\t    *rc->rc_row * rc->rc_font->height + rc->rc_yorigin,\n\t    rc->rc_emuwidth - x, rc->rc_font->height,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}"
  },
  {
    "function_name": "rcons_clear2eop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
    "lines": "431-451",
    "snippet": "void\nrcons_clear2eop(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int y;\n\n\tif (*rc->rc_col == 0 && *rc->rc_row == 0) {\n\t\t/* Clear the entire frame buffer */\n\t\traster_op(rc->rc_sp, 0, 0,\n\t\t    rc->rc_sp->width, rc->rc_sp->height,\n\t\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n\t} else {\n\t\t/* Only clear what needs to be cleared */\n\t\trcons_clear2eol(rc);\n\t\ty = (*rc->rc_row + 1) * rc->rc_font->height;\n\n\t\traster_op(rc->rc_sp, rc->rc_xorigin, rc->rc_yorigin + y,\n\t\t    rc->rc_emuwidth, rc->rc_emuheight - y,\n\t\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n\t}\n}",
    "includes": [
      "#include \"rcons_subr.h\"",
      "#include <dev/rcons/raster.h>",
      "#include <dev/rcons/rcons.h>",
      "#include \"myfbdevice.h\"",
      "#include <sys/types.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void rcons_bell(struct rconsole *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raster_op",
          "args": [
            "rc->rc_sp",
            "rc->rc_xorigin",
            "rc->rc_yorigin + y",
            "rc->rc_emuwidth",
            "rc->rc_emuheight - y",
            "rc->rc_ras_blank",
            "(struct raster *) 0",
            "0",
            "0"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "raster_op_nosrc_noclip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "759-860",
          "snippet": "int\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nint\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "rcons_clear2eol",
          "args": [
            "rc"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_clear2eol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "454-467",
          "snippet": "void\nrcons_clear2eol(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int x;\n\n\tx = *rc->rc_col * rc->rc_font->width;\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_xorigin + x,\n\t    *rc->rc_row * rc->rc_font->height + rc->rc_yorigin,\n\t    rc->rc_emuwidth - x, rc->rc_font->height,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_clear2eol(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int x;\n\n\tx = *rc->rc_col * rc->rc_font->width;\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_xorigin + x,\n\t    *rc->rc_row * rc->rc_font->height + rc->rc_yorigin,\n\t    rc->rc_emuwidth - x, rc->rc_font->height,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_clear2eop(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int y;\n\n\tif (*rc->rc_col == 0 && *rc->rc_row == 0) {\n\t\t/* Clear the entire frame buffer */\n\t\traster_op(rc->rc_sp, 0, 0,\n\t\t    rc->rc_sp->width, rc->rc_sp->height,\n\t\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n\t} else {\n\t\t/* Only clear what needs to be cleared */\n\t\trcons_clear2eol(rc);\n\t\ty = (*rc->rc_row + 1) * rc->rc_font->height;\n\n\t\traster_op(rc->rc_sp, rc->rc_xorigin, rc->rc_yorigin + y,\n\t\t    rc->rc_emuwidth, rc->rc_emuheight - y,\n\t\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n\t}\n}"
  },
  {
    "function_name": "rcons_invert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
    "lines": "414-428",
    "snippet": "void\nrcons_invert(rc, wob)\n\tstruct rconsole *rc;\n\tint wob;\n{\n\tif (((rc->rc_bits & FB_INVERT) != 0) ^ wob) {\n\t\t/* Invert the display */\n\t\traster_op(rc->rc_sp, 0, 0, rc->rc_sp->width, rc->rc_sp->height,\n\t\t    RAS_INVERT, (struct raster *) 0, 0, 0);\n\n\t\t/* Swap things around */\n\t\trc->rc_ras_blank = RAS_NOT(rc->rc_ras_blank);\n\t\trc->rc_bits ^= FB_INVERT;\n\t}\n}",
    "includes": [
      "#include \"rcons_subr.h\"",
      "#include <dev/rcons/raster.h>",
      "#include <dev/rcons/rcons.h>",
      "#include \"myfbdevice.h\"",
      "#include <sys/types.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void rcons_bell(struct rconsole *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RAS_NOT",
          "args": [
            "rc->rc_ras_blank"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raster_op",
          "args": [
            "rc->rc_sp",
            "0",
            "0",
            "rc->rc_sp->width",
            "rc->rc_sp->height",
            "RAS_INVERT",
            "(struct raster *) 0",
            "0",
            "0"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "raster_op_nosrc_noclip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "759-860",
          "snippet": "int\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nint\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_invert(rc, wob)\n\tstruct rconsole *rc;\n\tint wob;\n{\n\tif (((rc->rc_bits & FB_INVERT) != 0) ^ wob) {\n\t\t/* Invert the display */\n\t\traster_op(rc->rc_sp, 0, 0, rc->rc_sp->width, rc->rc_sp->height,\n\t\t    RAS_INVERT, (struct raster *) 0, 0, 0);\n\n\t\t/* Swap things around */\n\t\trc->rc_ras_blank = RAS_NOT(rc->rc_ras_blank);\n\t\trc->rc_bits ^= FB_INVERT;\n\t}\n}"
  },
  {
    "function_name": "rcons_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
    "lines": "393-411",
    "snippet": "void\nrcons_cursor(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int x, y;\n\n\tx = *rc->rc_col * rc->rc_font->width + rc->rc_xorigin;\n\ty = *rc->rc_row * rc->rc_font->height + rc->rc_yorigin;\n\traster_op(rc->rc_sp, x, y,\n#ifdef notdef\n\t    /* XXX This is the right way but too slow */\n\t    rc->rc_font->chars[(int)' '].r->width,\n\t    rc->rc_font->chars[(int)' '].r->height,\n#else\n\t    rc->rc_font->width, rc->rc_font->height,\n#endif\n\t    RAS_INVERT, (struct raster *) 0, 0, 0);\n\trc->rc_bits ^= FB_CURSOR;\n}",
    "includes": [
      "#include \"rcons_subr.h\"",
      "#include <dev/rcons/raster.h>",
      "#include <dev/rcons/rcons.h>",
      "#include \"myfbdevice.h\"",
      "#include <sys/types.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void rcons_bell(struct rconsole *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raster_op",
          "args": [
            "rc->rc_sp",
            "x",
            "y",
            "#ifdef notdef/* XXX This is the right way but too slow */rc->rc_font->chars[(int)' '].r->width",
            "rc->rc_font->chars[(int)' '].r->height",
            "#elserc->rc_font->width",
            "rc->rc_font->height",
            "#endifRAS_INVERT",
            "(struct raster *) 0",
            "0",
            "0"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "raster_op_nosrc_noclip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "759-860",
          "snippet": "int\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nint\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_cursor(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int x, y;\n\n\tx = *rc->rc_col * rc->rc_font->width + rc->rc_xorigin;\n\ty = *rc->rc_row * rc->rc_font->height + rc->rc_yorigin;\n\traster_op(rc->rc_sp, x, y,\n#ifdef notdef\n\t    /* XXX This is the right way but too slow */\n\t    rc->rc_font->chars[(int)' '].r->width,\n\t    rc->rc_font->chars[(int)' '].r->height,\n#else\n\t    rc->rc_font->width, rc->rc_font->height,\n#endif\n\t    RAS_INVERT, (struct raster *) 0, 0, 0);\n\trc->rc_bits ^= FB_CURSOR;\n}"
  },
  {
    "function_name": "rcons_doesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
    "lines": "256-390",
    "snippet": "void\nrcons_doesc(rc, c)\n\tregister struct rconsole *rc;\n\tregister int c;\n{\n\n#ifdef notdef\n\t/* XXX add escape sequence to enable visual (and audible) bell */\n\trc->rc_bits = FB_VISBELL;\n#endif\n\n\tswitch (c) {\n\n\tcase '@':\n\t\t/* Insert Character (ICH) */\n\t\trcons_insertchar(rc, rc->rc_p0);\n\t\tbreak;\n\n\tcase 'A':\n\t\t/* Cursor Up (CUU) */\n\t\t*rc->rc_row -= rc->rc_p0;\n\t\tif (*rc->rc_row < 0)\n\t\t\t*rc->rc_row = 0;\n\t\tbreak;\n\n\tcase 'B':\n\t\t/* Cursor Down (CUD) */\n\t\t*rc->rc_row += rc->rc_p0;\n\t\tif (*rc->rc_row >= rc->rc_maxrow)\n\t\t\t*rc->rc_row = rc->rc_maxrow - 1;\n\t\tbreak;\n\n\tcase 'C':\n\t\t/* Cursor Forward (CUF) */\n\t\t*rc->rc_col += rc->rc_p0;\n\t\tif (*rc->rc_col >= rc->rc_maxcol)\n\t\t\t*rc->rc_col = rc->rc_maxcol - 1;\n\t\tbreak;\n\n\tcase 'D':\n\t\t/* Cursor Backward (CUB) */\n\t\t*rc->rc_col -= rc->rc_p0;\n\t\tif (*rc->rc_col < 0)\n\t\t\t*rc->rc_col = 0;\n\t\tbreak;\n\n\tcase 'E':\n\t\t/* Cursor Next Line (CNL) */\n\t\t*rc->rc_col = 0;\n\t\t*rc->rc_row += rc->rc_p0;\n\t\tif (*rc->rc_row >= rc->rc_maxrow)\n\t\t\t*rc->rc_row = rc->rc_maxrow - 1;\n\t\tbreak;\n\n\tcase 'f':\n\t\t/* Horizontal And Vertical Position (HVP) */\n\tcase 'H':\n\t\t/* Cursor Position (CUP) */\n\t\t*rc->rc_col = rc->rc_p1 - 1;\n\t\tif (*rc->rc_col < 0)\n\t\t\t*rc->rc_col = 0;\n\t\telse if (*rc->rc_col >= rc->rc_maxcol)\n\t\t\t*rc->rc_col = rc->rc_maxcol - 1;\n\n\t\t*rc->rc_row = rc->rc_p0 - 1;\n\t\tif (*rc->rc_row < 0)\n\t\t\t*rc->rc_row = 0;\n\t\telse if (*rc->rc_row >= rc->rc_maxrow)\n\t\t\t*rc->rc_row = rc->rc_maxrow - 1;\n\t\tbreak;\n\n\tcase 'J':\n\t\t/* Erase in Display (ED) */\n\t\trcons_clear2eop(rc);\n\t\tbreak;\n\n\tcase 'K':\n\t\t/* Erase in Line (EL) */\n\t\trcons_clear2eol(rc);\n\t\tbreak;\n\n\tcase 'L':\n\t\t/* Insert Line (IL) */\n\t\trcons_insertline(rc, rc->rc_p0);\n\t\tbreak;\n\n\tcase 'M':\n\t\t/* Delete Line (DL) */\n\t\trcons_delline(rc, rc->rc_p0);\n\t\tbreak;\n\n\tcase 'P':\n\t\t/* Delete Character (DCH) */\n\t\trcons_delchar(rc, rc->rc_p0);\n\t\tbreak;\n\n\tcase 'm':\n\t\t/* Select Graphic Rendition (SGR); */\n\t\t/* (defaults to zero) */\n\t\tif (rc->rc_bits & FB_P0_DEFAULT)\n\t\t\trc->rc_p0 = 0;\n\t\tif (rc->rc_p0)\n\t\t\trc->rc_bits |= FB_STANDOUT;\n\t\telse\n\t\t\trc->rc_bits &= ~FB_STANDOUT;\n\t\tbreak;\n\n\tcase 'p':\n\t\t/* Black On White (SUNBOW) */\n\t\trcons_invert(rc, 0);\n\t\tbreak;\n\n\tcase 'q':\n\t\t/* White On Black (SUNWOB) */\n\t\trcons_invert(rc, 1);\n\t\tbreak;\n\n\tcase 'r':\n\t\t/* Set scrolling (SUNSCRL) */\n\t\t/* (defaults to zero) */\n\t\tif (rc->rc_bits & FB_P0_DEFAULT)\n\t\t\trc->rc_p0 = 0;\n\t\t/* XXX not implemented yet */\n\t\trc->rc_scroll = rc->rc_p0;\n\t\tbreak;\n\n\tcase 's':\n\t\t/* Reset terminal emulator (SUNRESET) */\n\t\trc->rc_bits &= ~FB_STANDOUT;\n\t\trc->rc_scroll = 0;\n\t\tif (rc->rc_bits & FB_INVERT)\n\t\t\trcons_invert(rc, 0);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"rcons_subr.h\"",
      "#include <dev/rcons/raster.h>",
      "#include <dev/rcons/rcons.h>",
      "#include \"myfbdevice.h\"",
      "#include <sys/types.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void rcons_bell(struct rconsole *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcons_invert",
          "args": [
            "rc",
            "0"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_invert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "414-428",
          "snippet": "void\nrcons_invert(rc, wob)\n\tstruct rconsole *rc;\n\tint wob;\n{\n\tif (((rc->rc_bits & FB_INVERT) != 0) ^ wob) {\n\t\t/* Invert the display */\n\t\traster_op(rc->rc_sp, 0, 0, rc->rc_sp->width, rc->rc_sp->height,\n\t\t    RAS_INVERT, (struct raster *) 0, 0, 0);\n\n\t\t/* Swap things around */\n\t\trc->rc_ras_blank = RAS_NOT(rc->rc_ras_blank);\n\t\trc->rc_bits ^= FB_INVERT;\n\t}\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_invert(rc, wob)\n\tstruct rconsole *rc;\n\tint wob;\n{\n\tif (((rc->rc_bits & FB_INVERT) != 0) ^ wob) {\n\t\t/* Invert the display */\n\t\traster_op(rc->rc_sp, 0, 0, rc->rc_sp->width, rc->rc_sp->height,\n\t\t    RAS_INVERT, (struct raster *) 0, 0, 0);\n\n\t\t/* Swap things around */\n\t\trc->rc_ras_blank = RAS_NOT(rc->rc_ras_blank);\n\t\trc->rc_bits ^= FB_INVERT;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcons_delchar",
          "args": [
            "rc",
            "rc->rc_p0"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_delchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "499-523",
          "snippet": "void\nrcons_delchar(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int tox, fromx, y, width;\n\n\t/* Can't delete more chars than there are */\n\tif (n > rc->rc_maxcol - *rc->rc_col)\n\t\tn = rc->rc_maxcol - *rc->rc_col;\n\n\tfromx = (*rc->rc_col + n) * rc->rc_font->width;\n\ttox = *rc->rc_col * rc->rc_font->width;\n\ty = *rc->rc_row * rc->rc_font->height;\n\twidth = n * rc->rc_font->width;\n\n\traster_op(rc->rc_sp, tox + rc->rc_xorigin, y + rc->rc_yorigin,\n\t    rc->rc_emuwidth - fromx, rc->rc_font->height,\n\t    RAS_SRC, rc->rc_sp, fromx + rc->rc_xorigin, y + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_emuwidth - width + rc->rc_xorigin, y + rc->rc_yorigin,\n\t    width, rc->rc_font->height,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_delchar(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int tox, fromx, y, width;\n\n\t/* Can't delete more chars than there are */\n\tif (n > rc->rc_maxcol - *rc->rc_col)\n\t\tn = rc->rc_maxcol - *rc->rc_col;\n\n\tfromx = (*rc->rc_col + n) * rc->rc_font->width;\n\ttox = *rc->rc_col * rc->rc_font->width;\n\ty = *rc->rc_row * rc->rc_font->height;\n\twidth = n * rc->rc_font->width;\n\n\traster_op(rc->rc_sp, tox + rc->rc_xorigin, y + rc->rc_yorigin,\n\t    rc->rc_emuwidth - fromx, rc->rc_font->height,\n\t    RAS_SRC, rc->rc_sp, fromx + rc->rc_xorigin, y + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_emuwidth - width + rc->rc_xorigin, y + rc->rc_yorigin,\n\t    width, rc->rc_font->height,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcons_delline",
          "args": [
            "rc",
            "rc->rc_p0"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_delline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "526-549",
          "snippet": "void\nrcons_delline(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int fromy, toy, height;\n\n\t/* Can't delete more lines than there are */\n\tif (n > rc->rc_maxrow - *rc->rc_row)\n\t\tn = rc->rc_maxrow - *rc->rc_row;\n\n\tfromy = (*rc->rc_row + n) * rc->rc_font->height;\n\ttoy = *rc->rc_row * rc->rc_font->height;\n\theight = rc->rc_font->height * n;\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, toy + rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_emuheight - fromy, RAS_SRC,\n\t    rc->rc_sp, rc->rc_xorigin, fromy + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_xorigin, rc->rc_emuheight - height + rc->rc_yorigin,\n\t    rc->rc_emuwidth, height,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_delline(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int fromy, toy, height;\n\n\t/* Can't delete more lines than there are */\n\tif (n > rc->rc_maxrow - *rc->rc_row)\n\t\tn = rc->rc_maxrow - *rc->rc_row;\n\n\tfromy = (*rc->rc_row + n) * rc->rc_font->height;\n\ttoy = *rc->rc_row * rc->rc_font->height;\n\theight = rc->rc_font->height * n;\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, toy + rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_emuheight - fromy, RAS_SRC,\n\t    rc->rc_sp, rc->rc_xorigin, fromy + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_xorigin, rc->rc_emuheight - height + rc->rc_yorigin,\n\t    rc->rc_emuwidth, height,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcons_insertline",
          "args": [
            "rc",
            "rc->rc_p0"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_insertline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "577-598",
          "snippet": "void\nrcons_insertline(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int fromy, toy;\n\n\t/* Can't insert more lines than can fit */\n\tif (n > rc->rc_maxrow - *rc->rc_row)\n\t\tn = rc->rc_maxrow - *rc->rc_row;\n\n\ttoy = (*rc->rc_row + n) * rc->rc_font->height;\n\tfromy = *rc->rc_row * rc->rc_font->height;\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, toy + rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_emuheight - toy,\n\t    RAS_SRC, rc->rc_sp, rc->rc_xorigin, fromy + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, fromy + rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_font->height * n,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_insertline(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int fromy, toy;\n\n\t/* Can't insert more lines than can fit */\n\tif (n > rc->rc_maxrow - *rc->rc_row)\n\t\tn = rc->rc_maxrow - *rc->rc_row;\n\n\ttoy = (*rc->rc_row + n) * rc->rc_font->height;\n\tfromy = *rc->rc_row * rc->rc_font->height;\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, toy + rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_emuheight - toy,\n\t    RAS_SRC, rc->rc_sp, rc->rc_xorigin, fromy + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, fromy + rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_font->height * n,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcons_clear2eol",
          "args": [
            "rc"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_clear2eol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "454-467",
          "snippet": "void\nrcons_clear2eol(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int x;\n\n\tx = *rc->rc_col * rc->rc_font->width;\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_xorigin + x,\n\t    *rc->rc_row * rc->rc_font->height + rc->rc_yorigin,\n\t    rc->rc_emuwidth - x, rc->rc_font->height,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_clear2eol(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int x;\n\n\tx = *rc->rc_col * rc->rc_font->width;\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_xorigin + x,\n\t    *rc->rc_row * rc->rc_font->height + rc->rc_yorigin,\n\t    rc->rc_emuwidth - x, rc->rc_font->height,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcons_clear2eop",
          "args": [
            "rc"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_clear2eop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "431-451",
          "snippet": "void\nrcons_clear2eop(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int y;\n\n\tif (*rc->rc_col == 0 && *rc->rc_row == 0) {\n\t\t/* Clear the entire frame buffer */\n\t\traster_op(rc->rc_sp, 0, 0,\n\t\t    rc->rc_sp->width, rc->rc_sp->height,\n\t\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n\t} else {\n\t\t/* Only clear what needs to be cleared */\n\t\trcons_clear2eol(rc);\n\t\ty = (*rc->rc_row + 1) * rc->rc_font->height;\n\n\t\traster_op(rc->rc_sp, rc->rc_xorigin, rc->rc_yorigin + y,\n\t\t    rc->rc_emuwidth, rc->rc_emuheight - y,\n\t\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n\t}\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_clear2eop(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int y;\n\n\tif (*rc->rc_col == 0 && *rc->rc_row == 0) {\n\t\t/* Clear the entire frame buffer */\n\t\traster_op(rc->rc_sp, 0, 0,\n\t\t    rc->rc_sp->width, rc->rc_sp->height,\n\t\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n\t} else {\n\t\t/* Only clear what needs to be cleared */\n\t\trcons_clear2eol(rc);\n\t\ty = (*rc->rc_row + 1) * rc->rc_font->height;\n\n\t\traster_op(rc->rc_sp, rc->rc_xorigin, rc->rc_yorigin + y,\n\t\t    rc->rc_emuwidth, rc->rc_emuheight - y,\n\t\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcons_insertchar",
          "args": [
            "rc",
            "rc->rc_p0"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_insertchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "552-574",
          "snippet": "void\nrcons_insertchar(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int tox, fromx, y;\n\n\t/* Can't insert more chars than can fit */\n\tif (n > rc->rc_maxcol - *rc->rc_col)\n\t\tn = rc->rc_maxcol - *rc->rc_col;\n\n\ttox = (*rc->rc_col + n) * rc->rc_font->width;\n\tfromx = *rc->rc_col * rc->rc_font->width;\n\ty = *rc->rc_row * rc->rc_font->height;\n\n\traster_op(rc->rc_sp, tox + rc->rc_xorigin, y + rc->rc_yorigin,\n\t    rc->rc_emuwidth - tox, rc->rc_font->height,\n\t    RAS_SRC, rc->rc_sp, fromx + rc->rc_xorigin, y + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp, fromx + rc->rc_xorigin, y + rc->rc_yorigin,\n\t    rc->rc_font->width * n, rc->rc_font->height,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_insertchar(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int tox, fromx, y;\n\n\t/* Can't insert more chars than can fit */\n\tif (n > rc->rc_maxcol - *rc->rc_col)\n\t\tn = rc->rc_maxcol - *rc->rc_col;\n\n\ttox = (*rc->rc_col + n) * rc->rc_font->width;\n\tfromx = *rc->rc_col * rc->rc_font->width;\n\ty = *rc->rc_row * rc->rc_font->height;\n\n\traster_op(rc->rc_sp, tox + rc->rc_xorigin, y + rc->rc_yorigin,\n\t    rc->rc_emuwidth - tox, rc->rc_font->height,\n\t    RAS_SRC, rc->rc_sp, fromx + rc->rc_xorigin, y + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp, fromx + rc->rc_xorigin, y + rc->rc_yorigin,\n\t    rc->rc_font->width * n, rc->rc_font->height,\n\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_doesc(rc, c)\n\tregister struct rconsole *rc;\n\tregister int c;\n{\n\n#ifdef notdef\n\t/* XXX add escape sequence to enable visual (and audible) bell */\n\trc->rc_bits = FB_VISBELL;\n#endif\n\n\tswitch (c) {\n\n\tcase '@':\n\t\t/* Insert Character (ICH) */\n\t\trcons_insertchar(rc, rc->rc_p0);\n\t\tbreak;\n\n\tcase 'A':\n\t\t/* Cursor Up (CUU) */\n\t\t*rc->rc_row -= rc->rc_p0;\n\t\tif (*rc->rc_row < 0)\n\t\t\t*rc->rc_row = 0;\n\t\tbreak;\n\n\tcase 'B':\n\t\t/* Cursor Down (CUD) */\n\t\t*rc->rc_row += rc->rc_p0;\n\t\tif (*rc->rc_row >= rc->rc_maxrow)\n\t\t\t*rc->rc_row = rc->rc_maxrow - 1;\n\t\tbreak;\n\n\tcase 'C':\n\t\t/* Cursor Forward (CUF) */\n\t\t*rc->rc_col += rc->rc_p0;\n\t\tif (*rc->rc_col >= rc->rc_maxcol)\n\t\t\t*rc->rc_col = rc->rc_maxcol - 1;\n\t\tbreak;\n\n\tcase 'D':\n\t\t/* Cursor Backward (CUB) */\n\t\t*rc->rc_col -= rc->rc_p0;\n\t\tif (*rc->rc_col < 0)\n\t\t\t*rc->rc_col = 0;\n\t\tbreak;\n\n\tcase 'E':\n\t\t/* Cursor Next Line (CNL) */\n\t\t*rc->rc_col = 0;\n\t\t*rc->rc_row += rc->rc_p0;\n\t\tif (*rc->rc_row >= rc->rc_maxrow)\n\t\t\t*rc->rc_row = rc->rc_maxrow - 1;\n\t\tbreak;\n\n\tcase 'f':\n\t\t/* Horizontal And Vertical Position (HVP) */\n\tcase 'H':\n\t\t/* Cursor Position (CUP) */\n\t\t*rc->rc_col = rc->rc_p1 - 1;\n\t\tif (*rc->rc_col < 0)\n\t\t\t*rc->rc_col = 0;\n\t\telse if (*rc->rc_col >= rc->rc_maxcol)\n\t\t\t*rc->rc_col = rc->rc_maxcol - 1;\n\n\t\t*rc->rc_row = rc->rc_p0 - 1;\n\t\tif (*rc->rc_row < 0)\n\t\t\t*rc->rc_row = 0;\n\t\telse if (*rc->rc_row >= rc->rc_maxrow)\n\t\t\t*rc->rc_row = rc->rc_maxrow - 1;\n\t\tbreak;\n\n\tcase 'J':\n\t\t/* Erase in Display (ED) */\n\t\trcons_clear2eop(rc);\n\t\tbreak;\n\n\tcase 'K':\n\t\t/* Erase in Line (EL) */\n\t\trcons_clear2eol(rc);\n\t\tbreak;\n\n\tcase 'L':\n\t\t/* Insert Line (IL) */\n\t\trcons_insertline(rc, rc->rc_p0);\n\t\tbreak;\n\n\tcase 'M':\n\t\t/* Delete Line (DL) */\n\t\trcons_delline(rc, rc->rc_p0);\n\t\tbreak;\n\n\tcase 'P':\n\t\t/* Delete Character (DCH) */\n\t\trcons_delchar(rc, rc->rc_p0);\n\t\tbreak;\n\n\tcase 'm':\n\t\t/* Select Graphic Rendition (SGR); */\n\t\t/* (defaults to zero) */\n\t\tif (rc->rc_bits & FB_P0_DEFAULT)\n\t\t\trc->rc_p0 = 0;\n\t\tif (rc->rc_p0)\n\t\t\trc->rc_bits |= FB_STANDOUT;\n\t\telse\n\t\t\trc->rc_bits &= ~FB_STANDOUT;\n\t\tbreak;\n\n\tcase 'p':\n\t\t/* Black On White (SUNBOW) */\n\t\trcons_invert(rc, 0);\n\t\tbreak;\n\n\tcase 'q':\n\t\t/* White On Black (SUNWOB) */\n\t\trcons_invert(rc, 1);\n\t\tbreak;\n\n\tcase 'r':\n\t\t/* Set scrolling (SUNSCRL) */\n\t\t/* (defaults to zero) */\n\t\tif (rc->rc_bits & FB_P0_DEFAULT)\n\t\t\trc->rc_p0 = 0;\n\t\t/* XXX not implemented yet */\n\t\trc->rc_scroll = rc->rc_p0;\n\t\tbreak;\n\n\tcase 's':\n\t\t/* Reset terminal emulator (SUNRESET) */\n\t\trc->rc_bits &= ~FB_STANDOUT;\n\t\trc->rc_scroll = 0;\n\t\tif (rc->rc_bits & FB_INVERT)\n\t\t\trcons_invert(rc, 0);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "rcons_esc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
    "lines": "211-253",
    "snippet": "void\nrcons_esc(rc, c)\n\tregister struct rconsole *rc;\n\tregister int c;\n{\n\n\tif (c == '[') {\n\t\t/* Parameter 0 */\n\t\trc->rc_bits &= ~FB_P1;\n\t\trc->rc_bits |= FB_P0;\n\t} else if (c == ';') {\n\t\t/* Parameter 1 */\n\t\trc->rc_bits &= ~FB_P0;\n\t\trc->rc_bits |= FB_P1;\n\t} else if (RCONS_ISDIGIT(c)) {\n\t\t/* Add a digit to a parameter */\n\t\tif (rc->rc_bits & FB_P0) {\n\t\t\t/* Parameter 0 */\n\t\t\tif (rc->rc_bits & FB_P0_DEFAULT) {\n\t\t\t\trc->rc_bits &= ~FB_P0_DEFAULT;\n\t\t\t\trc->rc_p0 = 0;\n\t\t\t}\n\t\t\trc->rc_p0 *= 10;\n\t\t\trc->rc_p0 += c - '0';\n\t\t} else if (rc->rc_bits & FB_P1) {\n\t\t\t/* Parameter 1 */\n\t\t\tif (rc->rc_bits & FB_P1_DEFAULT) {\n\t\t\t\trc->rc_bits &= ~FB_P1_DEFAULT;\n\t\t\t\trc->rc_p1 = 0;\n\t\t\t}\n\t\t\trc->rc_p1 *= 10;\n\t\t\trc->rc_p1 += c - '0';\n\t\t}\n\t} else {\n\t\t/* Erase the cursor (if necessary) */\n\t\tif (rc->rc_bits & FB_CURSOR)\n\t\t\trcons_cursor(rc);\n\n\t\t/* Process the completed escape sequence */\n\t\trcons_doesc(rc, c);\n\t\trc->rc_bits &= ~FB_INESC;\n\t}\n}",
    "includes": [
      "#include \"rcons_subr.h\"",
      "#include <dev/rcons/raster.h>",
      "#include <dev/rcons/rcons.h>",
      "#include \"myfbdevice.h\"",
      "#include <sys/types.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void rcons_bell(struct rconsole *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcons_doesc",
          "args": [
            "rc",
            "c"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_doesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "256-390",
          "snippet": "void\nrcons_doesc(rc, c)\n\tregister struct rconsole *rc;\n\tregister int c;\n{\n\n#ifdef notdef\n\t/* XXX add escape sequence to enable visual (and audible) bell */\n\trc->rc_bits = FB_VISBELL;\n#endif\n\n\tswitch (c) {\n\n\tcase '@':\n\t\t/* Insert Character (ICH) */\n\t\trcons_insertchar(rc, rc->rc_p0);\n\t\tbreak;\n\n\tcase 'A':\n\t\t/* Cursor Up (CUU) */\n\t\t*rc->rc_row -= rc->rc_p0;\n\t\tif (*rc->rc_row < 0)\n\t\t\t*rc->rc_row = 0;\n\t\tbreak;\n\n\tcase 'B':\n\t\t/* Cursor Down (CUD) */\n\t\t*rc->rc_row += rc->rc_p0;\n\t\tif (*rc->rc_row >= rc->rc_maxrow)\n\t\t\t*rc->rc_row = rc->rc_maxrow - 1;\n\t\tbreak;\n\n\tcase 'C':\n\t\t/* Cursor Forward (CUF) */\n\t\t*rc->rc_col += rc->rc_p0;\n\t\tif (*rc->rc_col >= rc->rc_maxcol)\n\t\t\t*rc->rc_col = rc->rc_maxcol - 1;\n\t\tbreak;\n\n\tcase 'D':\n\t\t/* Cursor Backward (CUB) */\n\t\t*rc->rc_col -= rc->rc_p0;\n\t\tif (*rc->rc_col < 0)\n\t\t\t*rc->rc_col = 0;\n\t\tbreak;\n\n\tcase 'E':\n\t\t/* Cursor Next Line (CNL) */\n\t\t*rc->rc_col = 0;\n\t\t*rc->rc_row += rc->rc_p0;\n\t\tif (*rc->rc_row >= rc->rc_maxrow)\n\t\t\t*rc->rc_row = rc->rc_maxrow - 1;\n\t\tbreak;\n\n\tcase 'f':\n\t\t/* Horizontal And Vertical Position (HVP) */\n\tcase 'H':\n\t\t/* Cursor Position (CUP) */\n\t\t*rc->rc_col = rc->rc_p1 - 1;\n\t\tif (*rc->rc_col < 0)\n\t\t\t*rc->rc_col = 0;\n\t\telse if (*rc->rc_col >= rc->rc_maxcol)\n\t\t\t*rc->rc_col = rc->rc_maxcol - 1;\n\n\t\t*rc->rc_row = rc->rc_p0 - 1;\n\t\tif (*rc->rc_row < 0)\n\t\t\t*rc->rc_row = 0;\n\t\telse if (*rc->rc_row >= rc->rc_maxrow)\n\t\t\t*rc->rc_row = rc->rc_maxrow - 1;\n\t\tbreak;\n\n\tcase 'J':\n\t\t/* Erase in Display (ED) */\n\t\trcons_clear2eop(rc);\n\t\tbreak;\n\n\tcase 'K':\n\t\t/* Erase in Line (EL) */\n\t\trcons_clear2eol(rc);\n\t\tbreak;\n\n\tcase 'L':\n\t\t/* Insert Line (IL) */\n\t\trcons_insertline(rc, rc->rc_p0);\n\t\tbreak;\n\n\tcase 'M':\n\t\t/* Delete Line (DL) */\n\t\trcons_delline(rc, rc->rc_p0);\n\t\tbreak;\n\n\tcase 'P':\n\t\t/* Delete Character (DCH) */\n\t\trcons_delchar(rc, rc->rc_p0);\n\t\tbreak;\n\n\tcase 'm':\n\t\t/* Select Graphic Rendition (SGR); */\n\t\t/* (defaults to zero) */\n\t\tif (rc->rc_bits & FB_P0_DEFAULT)\n\t\t\trc->rc_p0 = 0;\n\t\tif (rc->rc_p0)\n\t\t\trc->rc_bits |= FB_STANDOUT;\n\t\telse\n\t\t\trc->rc_bits &= ~FB_STANDOUT;\n\t\tbreak;\n\n\tcase 'p':\n\t\t/* Black On White (SUNBOW) */\n\t\trcons_invert(rc, 0);\n\t\tbreak;\n\n\tcase 'q':\n\t\t/* White On Black (SUNWOB) */\n\t\trcons_invert(rc, 1);\n\t\tbreak;\n\n\tcase 'r':\n\t\t/* Set scrolling (SUNSCRL) */\n\t\t/* (defaults to zero) */\n\t\tif (rc->rc_bits & FB_P0_DEFAULT)\n\t\t\trc->rc_p0 = 0;\n\t\t/* XXX not implemented yet */\n\t\trc->rc_scroll = rc->rc_p0;\n\t\tbreak;\n\n\tcase 's':\n\t\t/* Reset terminal emulator (SUNRESET) */\n\t\trc->rc_bits &= ~FB_STANDOUT;\n\t\trc->rc_scroll = 0;\n\t\tif (rc->rc_bits & FB_INVERT)\n\t\t\trcons_invert(rc, 0);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_doesc(rc, c)\n\tregister struct rconsole *rc;\n\tregister int c;\n{\n\n#ifdef notdef\n\t/* XXX add escape sequence to enable visual (and audible) bell */\n\trc->rc_bits = FB_VISBELL;\n#endif\n\n\tswitch (c) {\n\n\tcase '@':\n\t\t/* Insert Character (ICH) */\n\t\trcons_insertchar(rc, rc->rc_p0);\n\t\tbreak;\n\n\tcase 'A':\n\t\t/* Cursor Up (CUU) */\n\t\t*rc->rc_row -= rc->rc_p0;\n\t\tif (*rc->rc_row < 0)\n\t\t\t*rc->rc_row = 0;\n\t\tbreak;\n\n\tcase 'B':\n\t\t/* Cursor Down (CUD) */\n\t\t*rc->rc_row += rc->rc_p0;\n\t\tif (*rc->rc_row >= rc->rc_maxrow)\n\t\t\t*rc->rc_row = rc->rc_maxrow - 1;\n\t\tbreak;\n\n\tcase 'C':\n\t\t/* Cursor Forward (CUF) */\n\t\t*rc->rc_col += rc->rc_p0;\n\t\tif (*rc->rc_col >= rc->rc_maxcol)\n\t\t\t*rc->rc_col = rc->rc_maxcol - 1;\n\t\tbreak;\n\n\tcase 'D':\n\t\t/* Cursor Backward (CUB) */\n\t\t*rc->rc_col -= rc->rc_p0;\n\t\tif (*rc->rc_col < 0)\n\t\t\t*rc->rc_col = 0;\n\t\tbreak;\n\n\tcase 'E':\n\t\t/* Cursor Next Line (CNL) */\n\t\t*rc->rc_col = 0;\n\t\t*rc->rc_row += rc->rc_p0;\n\t\tif (*rc->rc_row >= rc->rc_maxrow)\n\t\t\t*rc->rc_row = rc->rc_maxrow - 1;\n\t\tbreak;\n\n\tcase 'f':\n\t\t/* Horizontal And Vertical Position (HVP) */\n\tcase 'H':\n\t\t/* Cursor Position (CUP) */\n\t\t*rc->rc_col = rc->rc_p1 - 1;\n\t\tif (*rc->rc_col < 0)\n\t\t\t*rc->rc_col = 0;\n\t\telse if (*rc->rc_col >= rc->rc_maxcol)\n\t\t\t*rc->rc_col = rc->rc_maxcol - 1;\n\n\t\t*rc->rc_row = rc->rc_p0 - 1;\n\t\tif (*rc->rc_row < 0)\n\t\t\t*rc->rc_row = 0;\n\t\telse if (*rc->rc_row >= rc->rc_maxrow)\n\t\t\t*rc->rc_row = rc->rc_maxrow - 1;\n\t\tbreak;\n\n\tcase 'J':\n\t\t/* Erase in Display (ED) */\n\t\trcons_clear2eop(rc);\n\t\tbreak;\n\n\tcase 'K':\n\t\t/* Erase in Line (EL) */\n\t\trcons_clear2eol(rc);\n\t\tbreak;\n\n\tcase 'L':\n\t\t/* Insert Line (IL) */\n\t\trcons_insertline(rc, rc->rc_p0);\n\t\tbreak;\n\n\tcase 'M':\n\t\t/* Delete Line (DL) */\n\t\trcons_delline(rc, rc->rc_p0);\n\t\tbreak;\n\n\tcase 'P':\n\t\t/* Delete Character (DCH) */\n\t\trcons_delchar(rc, rc->rc_p0);\n\t\tbreak;\n\n\tcase 'm':\n\t\t/* Select Graphic Rendition (SGR); */\n\t\t/* (defaults to zero) */\n\t\tif (rc->rc_bits & FB_P0_DEFAULT)\n\t\t\trc->rc_p0 = 0;\n\t\tif (rc->rc_p0)\n\t\t\trc->rc_bits |= FB_STANDOUT;\n\t\telse\n\t\t\trc->rc_bits &= ~FB_STANDOUT;\n\t\tbreak;\n\n\tcase 'p':\n\t\t/* Black On White (SUNBOW) */\n\t\trcons_invert(rc, 0);\n\t\tbreak;\n\n\tcase 'q':\n\t\t/* White On Black (SUNWOB) */\n\t\trcons_invert(rc, 1);\n\t\tbreak;\n\n\tcase 'r':\n\t\t/* Set scrolling (SUNSCRL) */\n\t\t/* (defaults to zero) */\n\t\tif (rc->rc_bits & FB_P0_DEFAULT)\n\t\t\trc->rc_p0 = 0;\n\t\t/* XXX not implemented yet */\n\t\trc->rc_scroll = rc->rc_p0;\n\t\tbreak;\n\n\tcase 's':\n\t\t/* Reset terminal emulator (SUNRESET) */\n\t\trc->rc_bits &= ~FB_STANDOUT;\n\t\trc->rc_scroll = 0;\n\t\tif (rc->rc_bits & FB_INVERT)\n\t\t\trcons_invert(rc, 0);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcons_cursor",
          "args": [
            "rc"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "393-411",
          "snippet": "void\nrcons_cursor(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int x, y;\n\n\tx = *rc->rc_col * rc->rc_font->width + rc->rc_xorigin;\n\ty = *rc->rc_row * rc->rc_font->height + rc->rc_yorigin;\n\traster_op(rc->rc_sp, x, y,\n#ifdef notdef\n\t    /* XXX This is the right way but too slow */\n\t    rc->rc_font->chars[(int)' '].r->width,\n\t    rc->rc_font->chars[(int)' '].r->height,\n#else\n\t    rc->rc_font->width, rc->rc_font->height,\n#endif\n\t    RAS_INVERT, (struct raster *) 0, 0, 0);\n\trc->rc_bits ^= FB_CURSOR;\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_cursor(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int x, y;\n\n\tx = *rc->rc_col * rc->rc_font->width + rc->rc_xorigin;\n\ty = *rc->rc_row * rc->rc_font->height + rc->rc_yorigin;\n\traster_op(rc->rc_sp, x, y,\n#ifdef notdef\n\t    /* XXX This is the right way but too slow */\n\t    rc->rc_font->chars[(int)' '].r->width,\n\t    rc->rc_font->chars[(int)' '].r->height,\n#else\n\t    rc->rc_font->width, rc->rc_font->height,\n#endif\n\t    RAS_INVERT, (struct raster *) 0, 0, 0);\n\trc->rc_bits ^= FB_CURSOR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCONS_ISDIGIT",
          "args": [
            "c"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_esc(rc, c)\n\tregister struct rconsole *rc;\n\tregister int c;\n{\n\n\tif (c == '[') {\n\t\t/* Parameter 0 */\n\t\trc->rc_bits &= ~FB_P1;\n\t\trc->rc_bits |= FB_P0;\n\t} else if (c == ';') {\n\t\t/* Parameter 1 */\n\t\trc->rc_bits &= ~FB_P0;\n\t\trc->rc_bits |= FB_P1;\n\t} else if (RCONS_ISDIGIT(c)) {\n\t\t/* Add a digit to a parameter */\n\t\tif (rc->rc_bits & FB_P0) {\n\t\t\t/* Parameter 0 */\n\t\t\tif (rc->rc_bits & FB_P0_DEFAULT) {\n\t\t\t\trc->rc_bits &= ~FB_P0_DEFAULT;\n\t\t\t\trc->rc_p0 = 0;\n\t\t\t}\n\t\t\trc->rc_p0 *= 10;\n\t\t\trc->rc_p0 += c - '0';\n\t\t} else if (rc->rc_bits & FB_P1) {\n\t\t\t/* Parameter 1 */\n\t\t\tif (rc->rc_bits & FB_P1_DEFAULT) {\n\t\t\t\trc->rc_bits &= ~FB_P1_DEFAULT;\n\t\t\t\trc->rc_p1 = 0;\n\t\t\t}\n\t\t\trc->rc_p1 *= 10;\n\t\t\trc->rc_p1 += c - '0';\n\t\t}\n\t} else {\n\t\t/* Erase the cursor (if necessary) */\n\t\tif (rc->rc_bits & FB_CURSOR)\n\t\t\trcons_cursor(rc);\n\n\t\t/* Process the completed escape sequence */\n\t\trcons_doesc(rc, c);\n\t\trc->rc_bits &= ~FB_INESC;\n\t}\n}"
  },
  {
    "function_name": "rcons_pctrl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
    "lines": "165-208",
    "snippet": "void\nrcons_pctrl(rc, c)\n\tregister struct rconsole *rc;\n\tregister int c;\n{\n\n\tswitch (c) {\n\n\tcase '\\r':\t/* Carriage return */\n\t\t*rc->rc_col = 0;\n\t\tbreak;\n\n\tcase '\\b':\t/* Backspace */\n\t\tif (*rc->rc_col > 0)\n\t\t\t(*rc->rc_col)--;\n\t\tbreak;\n\n\tcase '\\013':\t/* Vertical tab */\n\t\tif (*rc->rc_row > 0)\n\t\t\t(*rc->rc_row)--;\n\t\tbreak;\n\n\tcase '\\f':\t/* Formfeed */\n\t\t*rc->rc_row = *rc->rc_col = 0;\n\t\trcons_clear2eop(rc);\n\t\tbreak;\n\n\tcase '\\n':\t/* Linefeed */\n\t\t(*rc->rc_row)++;\n\t\tif (*rc->rc_row >= rc->rc_maxrow)\n\t\t\trcons_scroll(rc, 1);\n\t\tbreak;\n\n\tcase '\\007':\t/* Bell */\n\t\trcons_bell(rc);\n\t\tbreak;\n\n\tcase '\\t':\t/* Horizontal tab */\n\t\t*rc->rc_col = (*rc->rc_col + 8) & ~7;\n\t\tif (*rc->rc_col >= rc->rc_maxcol)\n\t\t\t*rc->rc_col = rc->rc_maxcol - 1;\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"rcons_subr.h\"",
      "#include <dev/rcons/raster.h>",
      "#include <dev/rcons/rcons.h>",
      "#include \"myfbdevice.h\"",
      "#include <sys/types.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void rcons_bell(struct rconsole *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcons_bell",
          "args": [
            "rc"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_belltmr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_kern.c",
          "lines": "145-166",
          "snippet": "static void\nrcons_belltmr(p)\n\tvoid *p;\n{\n\tregister struct rconsole *rc = p;\n\tregister int s = splhigh(), i;\n\n\tif (rc->rc_ringing) {\n\t\trc->rc_ringing = 0;\n\t\ti = --rc->rc_belldepth;\n\t\tsplx(s);\n\t\t(*rc->rc_bell)(0);\n\t\tif (i != 0)\n\t\t\t/* XXX Chris doesn't like the following divide */\n\t\t\ttimeout(rcons_belltmr, rc, hz/30);\n\t} else {\n\t\trc->rc_ringing = 1;\n\t\tsplx(s);\n\t\t(*rc->rc_bell)(1);\n\t\ttimeout(rcons_belltmr, rc, hz/10);\n\t}\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/rcons.h>",
            "#include <dev/rcons/raster.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcons_belltmr(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/rcons.h>\n#include <dev/rcons/raster.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nstatic void rcons_belltmr(void *);\n\nstatic void\nrcons_belltmr(p)\n\tvoid *p;\n{\n\tregister struct rconsole *rc = p;\n\tregister int s = splhigh(), i;\n\n\tif (rc->rc_ringing) {\n\t\trc->rc_ringing = 0;\n\t\ti = --rc->rc_belldepth;\n\t\tsplx(s);\n\t\t(*rc->rc_bell)(0);\n\t\tif (i != 0)\n\t\t\t/* XXX Chris doesn't like the following divide */\n\t\t\ttimeout(rcons_belltmr, rc, hz/30);\n\t} else {\n\t\trc->rc_ringing = 1;\n\t\tsplx(s);\n\t\t(*rc->rc_bell)(1);\n\t\ttimeout(rcons_belltmr, rc, hz/10);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcons_scroll",
          "args": [
            "rc",
            "1"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_scroll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "470-496",
          "snippet": "void\nrcons_scroll(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int ydiv;\n\n\t/* Can't scroll more than the whole screen */\n\tif (n > rc->rc_maxrow)\n\t\tn = rc->rc_maxrow;\n\n\t/* Calculate new row */\n\t*rc->rc_row -= n;\n\tif (*rc->rc_row < 0)\n\t\t*rc->rc_row  = 0;\n\n\t/* Calculate number of pixels to scroll */\n\tydiv = rc->rc_font->height * n;\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_emuheight - ydiv,\n\t    RAS_SRC, rc->rc_sp, rc->rc_xorigin, ydiv + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_xorigin, rc->rc_yorigin + rc->rc_emuheight - ydiv,\n\t    rc->rc_emuwidth, ydiv, rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_scroll(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int ydiv;\n\n\t/* Can't scroll more than the whole screen */\n\tif (n > rc->rc_maxrow)\n\t\tn = rc->rc_maxrow;\n\n\t/* Calculate new row */\n\t*rc->rc_row -= n;\n\tif (*rc->rc_row < 0)\n\t\t*rc->rc_row  = 0;\n\n\t/* Calculate number of pixels to scroll */\n\tydiv = rc->rc_font->height * n;\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_emuheight - ydiv,\n\t    RAS_SRC, rc->rc_sp, rc->rc_xorigin, ydiv + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_xorigin, rc->rc_yorigin + rc->rc_emuheight - ydiv,\n\t    rc->rc_emuwidth, ydiv, rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcons_clear2eop",
          "args": [
            "rc"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_clear2eop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "431-451",
          "snippet": "void\nrcons_clear2eop(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int y;\n\n\tif (*rc->rc_col == 0 && *rc->rc_row == 0) {\n\t\t/* Clear the entire frame buffer */\n\t\traster_op(rc->rc_sp, 0, 0,\n\t\t    rc->rc_sp->width, rc->rc_sp->height,\n\t\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n\t} else {\n\t\t/* Only clear what needs to be cleared */\n\t\trcons_clear2eol(rc);\n\t\ty = (*rc->rc_row + 1) * rc->rc_font->height;\n\n\t\traster_op(rc->rc_sp, rc->rc_xorigin, rc->rc_yorigin + y,\n\t\t    rc->rc_emuwidth, rc->rc_emuheight - y,\n\t\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n\t}\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_clear2eop(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int y;\n\n\tif (*rc->rc_col == 0 && *rc->rc_row == 0) {\n\t\t/* Clear the entire frame buffer */\n\t\traster_op(rc->rc_sp, 0, 0,\n\t\t    rc->rc_sp->width, rc->rc_sp->height,\n\t\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n\t} else {\n\t\t/* Only clear what needs to be cleared */\n\t\trcons_clear2eol(rc);\n\t\ty = (*rc->rc_row + 1) * rc->rc_font->height;\n\n\t\traster_op(rc->rc_sp, rc->rc_xorigin, rc->rc_yorigin + y,\n\t\t    rc->rc_emuwidth, rc->rc_emuheight - y,\n\t\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_pctrl(rc, c)\n\tregister struct rconsole *rc;\n\tregister int c;\n{\n\n\tswitch (c) {\n\n\tcase '\\r':\t/* Carriage return */\n\t\t*rc->rc_col = 0;\n\t\tbreak;\n\n\tcase '\\b':\t/* Backspace */\n\t\tif (*rc->rc_col > 0)\n\t\t\t(*rc->rc_col)--;\n\t\tbreak;\n\n\tcase '\\013':\t/* Vertical tab */\n\t\tif (*rc->rc_row > 0)\n\t\t\t(*rc->rc_row)--;\n\t\tbreak;\n\n\tcase '\\f':\t/* Formfeed */\n\t\t*rc->rc_row = *rc->rc_col = 0;\n\t\trcons_clear2eop(rc);\n\t\tbreak;\n\n\tcase '\\n':\t/* Linefeed */\n\t\t(*rc->rc_row)++;\n\t\tif (*rc->rc_row >= rc->rc_maxrow)\n\t\t\trcons_scroll(rc, 1);\n\t\tbreak;\n\n\tcase '\\007':\t/* Bell */\n\t\trcons_bell(rc);\n\t\tbreak;\n\n\tcase '\\t':\t/* Horizontal tab */\n\t\t*rc->rc_col = (*rc->rc_col + 8) & ~7;\n\t\tif (*rc->rc_col >= rc->rc_maxcol)\n\t\t\t*rc->rc_col = rc->rc_maxcol - 1;\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "rcons_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
    "lines": "139-162",
    "snippet": "void\nrcons_text(rc, str, n)\n\tregister struct rconsole *rc;\n\tregister unsigned char *str;\n\tregister int n;\n{\n\tregister int x, y, op;\n\n\tx = *rc->rc_col * rc->rc_font->width + rc->rc_xorigin;\n\ty = *rc->rc_row * rc->rc_font->height +\n\t    rc->rc_font->ascent + rc->rc_yorigin;\n\top = RAS_SRC;\n\tif (((rc->rc_bits & FB_STANDOUT) != 0) ^\n\t    ((rc->rc_bits & FB_INVERT) != 0))\n\t\top = RAS_NOT(op);\n\traster_textn(rc->rc_sp, x, y, op, rc->rc_font, str, n);\n\t*rc->rc_col += n;\n\tif (*rc->rc_col >= rc->rc_maxcol) {\n\t\t*rc->rc_col = 0;\n\t\t(*rc->rc_row)++;\n\t}\n\tif (*rc->rc_row >= rc->rc_maxrow)\n\t\trcons_scroll(rc, 1);\n}",
    "includes": [
      "#include \"rcons_subr.h\"",
      "#include <dev/rcons/raster.h>",
      "#include <dev/rcons/rcons.h>",
      "#include \"myfbdevice.h\"",
      "#include <sys/types.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void rcons_bell(struct rconsole *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcons_scroll",
          "args": [
            "rc",
            "1"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_scroll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "470-496",
          "snippet": "void\nrcons_scroll(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int ydiv;\n\n\t/* Can't scroll more than the whole screen */\n\tif (n > rc->rc_maxrow)\n\t\tn = rc->rc_maxrow;\n\n\t/* Calculate new row */\n\t*rc->rc_row -= n;\n\tif (*rc->rc_row < 0)\n\t\t*rc->rc_row  = 0;\n\n\t/* Calculate number of pixels to scroll */\n\tydiv = rc->rc_font->height * n;\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_emuheight - ydiv,\n\t    RAS_SRC, rc->rc_sp, rc->rc_xorigin, ydiv + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_xorigin, rc->rc_yorigin + rc->rc_emuheight - ydiv,\n\t    rc->rc_emuwidth, ydiv, rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_scroll(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int ydiv;\n\n\t/* Can't scroll more than the whole screen */\n\tif (n > rc->rc_maxrow)\n\t\tn = rc->rc_maxrow;\n\n\t/* Calculate new row */\n\t*rc->rc_row -= n;\n\tif (*rc->rc_row < 0)\n\t\t*rc->rc_row  = 0;\n\n\t/* Calculate number of pixels to scroll */\n\tydiv = rc->rc_font->height * n;\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_emuheight - ydiv,\n\t    RAS_SRC, rc->rc_sp, rc->rc_xorigin, ydiv + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_xorigin, rc->rc_yorigin + rc->rc_emuheight - ydiv,\n\t    rc->rc_emuwidth, ydiv, rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raster_textn",
          "args": [
            "rc->rc_sp",
            "x",
            "y",
            "op",
            "rc->rc_font",
            "str",
            "n"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "raster_textn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_text.c",
          "lines": "78-224",
          "snippet": "int\nraster_textn( r, x, y, rop, rf, text, n )\n    register struct raster* r;\n    int x, y;\n    int rop;\n    struct raster_font* rf;\n    unsigned char* text;\n    int n;\n    {\n    int clip;\n    int x1, y1;\n    struct raster_char* c;\n    struct raster* charrast;\n    int i;\n    register unsigned char ch;\n    int thisx, thisy;\n    int phase;\n\n    /* Check whether we can avoid clipping. */\n    clip = 0;\n    if ( rf->flags & RASFONT_FIXEDWIDTH &&\n\t rf->flags & RASFONT_NOVERTICALMOVEMENT )\n\t{\n\t/* This font is well-behaved, we can compute the extent cheaply. */\n\tc = &(rf->chars['@']);\n\tcharrast = c->r;\n\tif ( x + c->homex < 0 || y + c->homey < 0 ||\n\t     x + c->homex + n * c->nextx > r->width ||\n\t     y + c->homey + charrast->height > r->height )\n\t    clip = 1;\n\t}\n    else\n\t{\n\t/* Got to step through the string to compute the extent. */\n\tfor ( i = 0, x1 = x, y1 = y;\n\t      i < n;\n\t      ++i, x1 += c->nextx, y1 += c->nexty )\n\t    {\n\t    c = &(rf->chars[text[i]]);\n\t    charrast = c->r;\n\t    if ( charrast != (struct raster*) 0 )\n\t\t{\n\t\tif ( x1 + c->homex < 0 || y1 + c->homey < 0 ||\n\t\t     x1 + c->homex + charrast->width > r->width ||\n\t\t     y1 + c->homey + charrast->height > r->height )\n\t\t    {\n\t\t    clip = 1;\n\t\t    break;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n    /* Now display the text. */\n    for ( i = 0, x1 = x, y1 = y;\n\t  i < n;\n\t  ++i, x1 += c->nextx, y1 += c->nexty )\n\t{\n\tch = text[i];\n\tc = &(rf->chars[ch]);\n\tcharrast = c->r;\n\tif ( charrast != (struct raster*) 0 )\n\t    {\n\t    thisx = x1 + c->homex;\n\t    thisy = y1 + c->homey;\n\n\t    phase = 0;\n#ifdef COLORFONT_CACHE\n\t    if ( r->depth == 8 )\n\t\t{\n\t\t/* Initialize color font cache if necessary. */\n\t\tif ( rf->cache == (struct raster_fontcache*) -1 )\n\t\t    {\n\t\t    int c;\n\n\t\t    rf->cache = (struct raster_fontcache*)\n\t\t\tNEW( sizeof(struct raster_fontcache) );\n\t\t    if ( rf->cache != (struct raster_fontcache*) 0 )\n\t\t\tfor ( c = 0; c < 256; ++c )\n\t\t\t    rf->cache->cr[c] = (struct raster*) 0;\n\t\t    }\n\n\t\tif ( rf->cache != (struct raster_fontcache*) 0 )\n\t\t    {\n\t\t    int color;\n\t\t    struct raster* cr;\n\n\t\t    color = RAS_GETCOLOR( rop );\n\t\t    cr = rf->cache->cr[ch];\n\t\t    /* Is this character cached yet? */\n\t\t    if ( cr != (struct raster*) 0 )\n\t\t\t{\n\t\t\t/* Yes, but is it the right color? */\n\t\t\tif ( rf->cache->color[ch] == color )\n\t\t\t    {\n\t\t\t    /* Yes - switch rasters. */\n\t\t\t    charrast = cr;\n\t\t\t    }\n\t\t\telse\n\t\t\t    {\n\t\t\t    /* No, re-draw it. */\n\t\t\t    if ( raster_op_noclip(\n\t\t\t\t cr, 0, 0, charrast->width,\n\t\t\t\t charrast->height, rop, charrast, 0, 0 ) == 0 )\n\t\t\t\t{\n\t\t\t\trf->cache->color[ch] = color;\n\t\t\t\tcharrast = cr;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    else\n\t\t\t{\n\t\t\t/* It's not cached, so cache it. */\n\t\t\tcr = raster_alloc(\n\t\t\t    charrast->width, charrast->height, 8 );\n\t\t\tif ( cr != (struct raster*) 0 )\n\t\t\t    if ( raster_op_noclip(\n\t\t\t\t cr, 0, 0, charrast->width, charrast->height,\n\t\t\t\t rop, charrast, 0, 0 ) == 0 )\n\t\t\t\t{\n\t\t\t\trf->cache->color[ch] = color;\n\t\t\t\tcharrast = rf->cache->cr[ch] = cr;\n\t\t\t\t}\n\t\t\t}\n\t\t    }\n\t\t}\n#endif /*COLORFONT_CACHE*/\n\n\t    if ( clip )\n\t\t{\n\t\tif ( raster_op(\n\t\t\t r, thisx, thisy, charrast->width, charrast->height,\n\t\t\t rop, charrast, phase, 0 ) < 0 )\n\t\t    return -1;\n\t\t}\n\t    else\n\t\t{\n\t\tif ( raster_op_noclip(\n\t\t\t r, thisx, thisy, charrast->width, charrast->height,\n\t\t\t rop, charrast, phase, 0 ) < 0 )\n\t\t    return -1;\n\t\t}\n\t    }\n\t}\n\n    return 0;\n    }",
          "includes": [
            "#include <malloc.h>",
            "#include \"raster.h\"",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include <sys/malloc.h>",
            "#include <dev/rcons/raster.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include \"raster.h\"\n#include <string.h>\n#include <sys/types.h>\n#include <sys/malloc.h>\n#include <dev/rcons/raster.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nraster_textn( r, x, y, rop, rf, text, n )\n    register struct raster* r;\n    int x, y;\n    int rop;\n    struct raster_font* rf;\n    unsigned char* text;\n    int n;\n    {\n    int clip;\n    int x1, y1;\n    struct raster_char* c;\n    struct raster* charrast;\n    int i;\n    register unsigned char ch;\n    int thisx, thisy;\n    int phase;\n\n    /* Check whether we can avoid clipping. */\n    clip = 0;\n    if ( rf->flags & RASFONT_FIXEDWIDTH &&\n\t rf->flags & RASFONT_NOVERTICALMOVEMENT )\n\t{\n\t/* This font is well-behaved, we can compute the extent cheaply. */\n\tc = &(rf->chars['@']);\n\tcharrast = c->r;\n\tif ( x + c->homex < 0 || y + c->homey < 0 ||\n\t     x + c->homex + n * c->nextx > r->width ||\n\t     y + c->homey + charrast->height > r->height )\n\t    clip = 1;\n\t}\n    else\n\t{\n\t/* Got to step through the string to compute the extent. */\n\tfor ( i = 0, x1 = x, y1 = y;\n\t      i < n;\n\t      ++i, x1 += c->nextx, y1 += c->nexty )\n\t    {\n\t    c = &(rf->chars[text[i]]);\n\t    charrast = c->r;\n\t    if ( charrast != (struct raster*) 0 )\n\t\t{\n\t\tif ( x1 + c->homex < 0 || y1 + c->homey < 0 ||\n\t\t     x1 + c->homex + charrast->width > r->width ||\n\t\t     y1 + c->homey + charrast->height > r->height )\n\t\t    {\n\t\t    clip = 1;\n\t\t    break;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n    /* Now display the text. */\n    for ( i = 0, x1 = x, y1 = y;\n\t  i < n;\n\t  ++i, x1 += c->nextx, y1 += c->nexty )\n\t{\n\tch = text[i];\n\tc = &(rf->chars[ch]);\n\tcharrast = c->r;\n\tif ( charrast != (struct raster*) 0 )\n\t    {\n\t    thisx = x1 + c->homex;\n\t    thisy = y1 + c->homey;\n\n\t    phase = 0;\n#ifdef COLORFONT_CACHE\n\t    if ( r->depth == 8 )\n\t\t{\n\t\t/* Initialize color font cache if necessary. */\n\t\tif ( rf->cache == (struct raster_fontcache*) -1 )\n\t\t    {\n\t\t    int c;\n\n\t\t    rf->cache = (struct raster_fontcache*)\n\t\t\tNEW( sizeof(struct raster_fontcache) );\n\t\t    if ( rf->cache != (struct raster_fontcache*) 0 )\n\t\t\tfor ( c = 0; c < 256; ++c )\n\t\t\t    rf->cache->cr[c] = (struct raster*) 0;\n\t\t    }\n\n\t\tif ( rf->cache != (struct raster_fontcache*) 0 )\n\t\t    {\n\t\t    int color;\n\t\t    struct raster* cr;\n\n\t\t    color = RAS_GETCOLOR( rop );\n\t\t    cr = rf->cache->cr[ch];\n\t\t    /* Is this character cached yet? */\n\t\t    if ( cr != (struct raster*) 0 )\n\t\t\t{\n\t\t\t/* Yes, but is it the right color? */\n\t\t\tif ( rf->cache->color[ch] == color )\n\t\t\t    {\n\t\t\t    /* Yes - switch rasters. */\n\t\t\t    charrast = cr;\n\t\t\t    }\n\t\t\telse\n\t\t\t    {\n\t\t\t    /* No, re-draw it. */\n\t\t\t    if ( raster_op_noclip(\n\t\t\t\t cr, 0, 0, charrast->width,\n\t\t\t\t charrast->height, rop, charrast, 0, 0 ) == 0 )\n\t\t\t\t{\n\t\t\t\trf->cache->color[ch] = color;\n\t\t\t\tcharrast = cr;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    else\n\t\t\t{\n\t\t\t/* It's not cached, so cache it. */\n\t\t\tcr = raster_alloc(\n\t\t\t    charrast->width, charrast->height, 8 );\n\t\t\tif ( cr != (struct raster*) 0 )\n\t\t\t    if ( raster_op_noclip(\n\t\t\t\t cr, 0, 0, charrast->width, charrast->height,\n\t\t\t\t rop, charrast, 0, 0 ) == 0 )\n\t\t\t\t{\n\t\t\t\trf->cache->color[ch] = color;\n\t\t\t\tcharrast = rf->cache->cr[ch] = cr;\n\t\t\t\t}\n\t\t\t}\n\t\t    }\n\t\t}\n#endif /*COLORFONT_CACHE*/\n\n\t    if ( clip )\n\t\t{\n\t\tif ( raster_op(\n\t\t\t r, thisx, thisy, charrast->width, charrast->height,\n\t\t\t rop, charrast, phase, 0 ) < 0 )\n\t\t    return -1;\n\t\t}\n\t    else\n\t\t{\n\t\tif ( raster_op_noclip(\n\t\t\t r, thisx, thisy, charrast->width, charrast->height,\n\t\t\t rop, charrast, phase, 0 ) < 0 )\n\t\t    return -1;\n\t\t}\n\t    }\n\t}\n\n    return 0;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "RAS_NOT",
          "args": [
            "op"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_text(rc, str, n)\n\tregister struct rconsole *rc;\n\tregister unsigned char *str;\n\tregister int n;\n{\n\tregister int x, y, op;\n\n\tx = *rc->rc_col * rc->rc_font->width + rc->rc_xorigin;\n\ty = *rc->rc_row * rc->rc_font->height +\n\t    rc->rc_font->ascent + rc->rc_yorigin;\n\top = RAS_SRC;\n\tif (((rc->rc_bits & FB_STANDOUT) != 0) ^\n\t    ((rc->rc_bits & FB_INVERT) != 0))\n\t\top = RAS_NOT(op);\n\traster_textn(rc->rc_sp, x, y, op, rc->rc_font, str, n);\n\t*rc->rc_col += n;\n\tif (*rc->rc_col >= rc->rc_maxcol) {\n\t\t*rc->rc_col = 0;\n\t\t(*rc->rc_row)++;\n\t}\n\tif (*rc->rc_row >= rc->rc_maxrow)\n\t\trcons_scroll(rc, 1);\n}"
  },
  {
    "function_name": "rcons_puts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
    "lines": "67-136",
    "snippet": "void\nrcons_puts(rc, str, n)\n\tregister struct rconsole *rc;\n\tregister unsigned char *str;\n\tregister int n;\n{\n\tregister int c, i, j;\n\tregister unsigned char *cp;\n\n\t/* Jump scroll */\n\t/* XXX maybe this should be an option? */\n\tif ((rc->rc_bits & FB_INESC) == 0) {\n\t\t/* Count newlines up to an escape sequence */\n\t\ti = 0;\n\t\tj = 0;\n\t\tfor (cp = str; j++ < n && *cp != '\\033'; ++cp) {\n\t\t\tif (*cp == '\\n')\n\t\t\t\t++i;\n\t\t\telse if (*cp == '\\013')\n\t\t\t\t--i;\n\t\t}\n\n\t\t/* Only jump scroll two or more rows */\n\t\tif (*rc->rc_row + i >= rc->rc_maxrow + 1) {\n\t\t\t/* Erase the cursor (if necessary) */\n\t\t\tif (rc->rc_bits & FB_CURSOR)\n\t\t\t\trcons_cursor(rc);\n\n\t\t\trcons_scroll(rc, i);\n\t\t}\n\t}\n\n\t/* Process characters */\n\twhile (--n >= 0) {\n\t\tc = *str;\n\t\tif (c == '\\033') {\n\t\t\t/* Start an escape (perhaps aborting one in progress) */\n\t\t\trc->rc_bits |= FB_INESC | FB_P0_DEFAULT | FB_P1_DEFAULT;\n\t\t\trc->rc_bits &= ~(FB_P0 | FB_P1);\n\n\t\t\t/* Most parameters default to 1 */\n\t\t\trc->rc_p0 = rc->rc_p1 = 1;\n\t\t} else if (rc->rc_bits & FB_INESC) {\n\t\t\trcons_esc(rc, c);\n\t\t} else {\n\t\t\t/* Erase the cursor (if necessary) */\n\t\t\tif (rc->rc_bits & FB_CURSOR)\n\t\t\t\trcons_cursor(rc);\n\n\t\t\t/* Display the character */\n\t\t\tif (RCONS_ISPRINT(c)) {\n\t\t\t\t/* Try to output as much as possible */\n\t\t\t\tj = rc->rc_maxcol - (*rc->rc_col + 1);\n\t\t\t\tif (j > n)\n\t\t\t\t\tj = n;\n\t\t\t\tfor (i = 1; i < j && RCONS_ISPRINT(str[i]); ++i)\n\t\t\t\t\tcontinue;\n\t\t\t\trcons_text(rc, str, i);\n\t\t\t\t--i;\n\t\t\t\tstr += i;\n\t\t\t\tn -= i;\n\t\t\t} else\n\t\t\t\trcons_pctrl(rc, c);\n\t\t}\n\t\t++str;\n\t}\n\t/* Redraw the cursor (if necessary) */\n\tif ((rc->rc_bits & FB_CURSOR) == 0)\n\t\trcons_cursor(rc);\n}",
    "includes": [
      "#include \"rcons_subr.h\"",
      "#include <dev/rcons/raster.h>",
      "#include <dev/rcons/rcons.h>",
      "#include \"myfbdevice.h\"",
      "#include <sys/types.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void rcons_bell(struct rconsole *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcons_cursor",
          "args": [
            "rc"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "393-411",
          "snippet": "void\nrcons_cursor(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int x, y;\n\n\tx = *rc->rc_col * rc->rc_font->width + rc->rc_xorigin;\n\ty = *rc->rc_row * rc->rc_font->height + rc->rc_yorigin;\n\traster_op(rc->rc_sp, x, y,\n#ifdef notdef\n\t    /* XXX This is the right way but too slow */\n\t    rc->rc_font->chars[(int)' '].r->width,\n\t    rc->rc_font->chars[(int)' '].r->height,\n#else\n\t    rc->rc_font->width, rc->rc_font->height,\n#endif\n\t    RAS_INVERT, (struct raster *) 0, 0, 0);\n\trc->rc_bits ^= FB_CURSOR;\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_cursor(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int x, y;\n\n\tx = *rc->rc_col * rc->rc_font->width + rc->rc_xorigin;\n\ty = *rc->rc_row * rc->rc_font->height + rc->rc_yorigin;\n\traster_op(rc->rc_sp, x, y,\n#ifdef notdef\n\t    /* XXX This is the right way but too slow */\n\t    rc->rc_font->chars[(int)' '].r->width,\n\t    rc->rc_font->chars[(int)' '].r->height,\n#else\n\t    rc->rc_font->width, rc->rc_font->height,\n#endif\n\t    RAS_INVERT, (struct raster *) 0, 0, 0);\n\trc->rc_bits ^= FB_CURSOR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcons_pctrl",
          "args": [
            "rc",
            "c"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_pctrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "165-208",
          "snippet": "void\nrcons_pctrl(rc, c)\n\tregister struct rconsole *rc;\n\tregister int c;\n{\n\n\tswitch (c) {\n\n\tcase '\\r':\t/* Carriage return */\n\t\t*rc->rc_col = 0;\n\t\tbreak;\n\n\tcase '\\b':\t/* Backspace */\n\t\tif (*rc->rc_col > 0)\n\t\t\t(*rc->rc_col)--;\n\t\tbreak;\n\n\tcase '\\013':\t/* Vertical tab */\n\t\tif (*rc->rc_row > 0)\n\t\t\t(*rc->rc_row)--;\n\t\tbreak;\n\n\tcase '\\f':\t/* Formfeed */\n\t\t*rc->rc_row = *rc->rc_col = 0;\n\t\trcons_clear2eop(rc);\n\t\tbreak;\n\n\tcase '\\n':\t/* Linefeed */\n\t\t(*rc->rc_row)++;\n\t\tif (*rc->rc_row >= rc->rc_maxrow)\n\t\t\trcons_scroll(rc, 1);\n\t\tbreak;\n\n\tcase '\\007':\t/* Bell */\n\t\trcons_bell(rc);\n\t\tbreak;\n\n\tcase '\\t':\t/* Horizontal tab */\n\t\t*rc->rc_col = (*rc->rc_col + 8) & ~7;\n\t\tif (*rc->rc_col >= rc->rc_maxcol)\n\t\t\t*rc->rc_col = rc->rc_maxcol - 1;\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_pctrl(rc, c)\n\tregister struct rconsole *rc;\n\tregister int c;\n{\n\n\tswitch (c) {\n\n\tcase '\\r':\t/* Carriage return */\n\t\t*rc->rc_col = 0;\n\t\tbreak;\n\n\tcase '\\b':\t/* Backspace */\n\t\tif (*rc->rc_col > 0)\n\t\t\t(*rc->rc_col)--;\n\t\tbreak;\n\n\tcase '\\013':\t/* Vertical tab */\n\t\tif (*rc->rc_row > 0)\n\t\t\t(*rc->rc_row)--;\n\t\tbreak;\n\n\tcase '\\f':\t/* Formfeed */\n\t\t*rc->rc_row = *rc->rc_col = 0;\n\t\trcons_clear2eop(rc);\n\t\tbreak;\n\n\tcase '\\n':\t/* Linefeed */\n\t\t(*rc->rc_row)++;\n\t\tif (*rc->rc_row >= rc->rc_maxrow)\n\t\t\trcons_scroll(rc, 1);\n\t\tbreak;\n\n\tcase '\\007':\t/* Bell */\n\t\trcons_bell(rc);\n\t\tbreak;\n\n\tcase '\\t':\t/* Horizontal tab */\n\t\t*rc->rc_col = (*rc->rc_col + 8) & ~7;\n\t\tif (*rc->rc_col >= rc->rc_maxcol)\n\t\t\t*rc->rc_col = rc->rc_maxcol - 1;\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcons_text",
          "args": [
            "rc",
            "str",
            "i"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "139-162",
          "snippet": "void\nrcons_text(rc, str, n)\n\tregister struct rconsole *rc;\n\tregister unsigned char *str;\n\tregister int n;\n{\n\tregister int x, y, op;\n\n\tx = *rc->rc_col * rc->rc_font->width + rc->rc_xorigin;\n\ty = *rc->rc_row * rc->rc_font->height +\n\t    rc->rc_font->ascent + rc->rc_yorigin;\n\top = RAS_SRC;\n\tif (((rc->rc_bits & FB_STANDOUT) != 0) ^\n\t    ((rc->rc_bits & FB_INVERT) != 0))\n\t\top = RAS_NOT(op);\n\traster_textn(rc->rc_sp, x, y, op, rc->rc_font, str, n);\n\t*rc->rc_col += n;\n\tif (*rc->rc_col >= rc->rc_maxcol) {\n\t\t*rc->rc_col = 0;\n\t\t(*rc->rc_row)++;\n\t}\n\tif (*rc->rc_row >= rc->rc_maxrow)\n\t\trcons_scroll(rc, 1);\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_text(rc, str, n)\n\tregister struct rconsole *rc;\n\tregister unsigned char *str;\n\tregister int n;\n{\n\tregister int x, y, op;\n\n\tx = *rc->rc_col * rc->rc_font->width + rc->rc_xorigin;\n\ty = *rc->rc_row * rc->rc_font->height +\n\t    rc->rc_font->ascent + rc->rc_yorigin;\n\top = RAS_SRC;\n\tif (((rc->rc_bits & FB_STANDOUT) != 0) ^\n\t    ((rc->rc_bits & FB_INVERT) != 0))\n\t\top = RAS_NOT(op);\n\traster_textn(rc->rc_sp, x, y, op, rc->rc_font, str, n);\n\t*rc->rc_col += n;\n\tif (*rc->rc_col >= rc->rc_maxcol) {\n\t\t*rc->rc_col = 0;\n\t\t(*rc->rc_row)++;\n\t}\n\tif (*rc->rc_row >= rc->rc_maxrow)\n\t\trcons_scroll(rc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCONS_ISPRINT",
          "args": [
            "str[i]"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCONS_ISPRINT",
          "args": [
            "c"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcons_esc",
          "args": [
            "rc",
            "c"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_esc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "211-253",
          "snippet": "void\nrcons_esc(rc, c)\n\tregister struct rconsole *rc;\n\tregister int c;\n{\n\n\tif (c == '[') {\n\t\t/* Parameter 0 */\n\t\trc->rc_bits &= ~FB_P1;\n\t\trc->rc_bits |= FB_P0;\n\t} else if (c == ';') {\n\t\t/* Parameter 1 */\n\t\trc->rc_bits &= ~FB_P0;\n\t\trc->rc_bits |= FB_P1;\n\t} else if (RCONS_ISDIGIT(c)) {\n\t\t/* Add a digit to a parameter */\n\t\tif (rc->rc_bits & FB_P0) {\n\t\t\t/* Parameter 0 */\n\t\t\tif (rc->rc_bits & FB_P0_DEFAULT) {\n\t\t\t\trc->rc_bits &= ~FB_P0_DEFAULT;\n\t\t\t\trc->rc_p0 = 0;\n\t\t\t}\n\t\t\trc->rc_p0 *= 10;\n\t\t\trc->rc_p0 += c - '0';\n\t\t} else if (rc->rc_bits & FB_P1) {\n\t\t\t/* Parameter 1 */\n\t\t\tif (rc->rc_bits & FB_P1_DEFAULT) {\n\t\t\t\trc->rc_bits &= ~FB_P1_DEFAULT;\n\t\t\t\trc->rc_p1 = 0;\n\t\t\t}\n\t\t\trc->rc_p1 *= 10;\n\t\t\trc->rc_p1 += c - '0';\n\t\t}\n\t} else {\n\t\t/* Erase the cursor (if necessary) */\n\t\tif (rc->rc_bits & FB_CURSOR)\n\t\t\trcons_cursor(rc);\n\n\t\t/* Process the completed escape sequence */\n\t\trcons_doesc(rc, c);\n\t\trc->rc_bits &= ~FB_INESC;\n\t}\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_esc(rc, c)\n\tregister struct rconsole *rc;\n\tregister int c;\n{\n\n\tif (c == '[') {\n\t\t/* Parameter 0 */\n\t\trc->rc_bits &= ~FB_P1;\n\t\trc->rc_bits |= FB_P0;\n\t} else if (c == ';') {\n\t\t/* Parameter 1 */\n\t\trc->rc_bits &= ~FB_P0;\n\t\trc->rc_bits |= FB_P1;\n\t} else if (RCONS_ISDIGIT(c)) {\n\t\t/* Add a digit to a parameter */\n\t\tif (rc->rc_bits & FB_P0) {\n\t\t\t/* Parameter 0 */\n\t\t\tif (rc->rc_bits & FB_P0_DEFAULT) {\n\t\t\t\trc->rc_bits &= ~FB_P0_DEFAULT;\n\t\t\t\trc->rc_p0 = 0;\n\t\t\t}\n\t\t\trc->rc_p0 *= 10;\n\t\t\trc->rc_p0 += c - '0';\n\t\t} else if (rc->rc_bits & FB_P1) {\n\t\t\t/* Parameter 1 */\n\t\t\tif (rc->rc_bits & FB_P1_DEFAULT) {\n\t\t\t\trc->rc_bits &= ~FB_P1_DEFAULT;\n\t\t\t\trc->rc_p1 = 0;\n\t\t\t}\n\t\t\trc->rc_p1 *= 10;\n\t\t\trc->rc_p1 += c - '0';\n\t\t}\n\t} else {\n\t\t/* Erase the cursor (if necessary) */\n\t\tif (rc->rc_bits & FB_CURSOR)\n\t\t\trcons_cursor(rc);\n\n\t\t/* Process the completed escape sequence */\n\t\trcons_doesc(rc, c);\n\t\trc->rc_bits &= ~FB_INESC;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcons_scroll",
          "args": [
            "rc",
            "i"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_scroll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "470-496",
          "snippet": "void\nrcons_scroll(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int ydiv;\n\n\t/* Can't scroll more than the whole screen */\n\tif (n > rc->rc_maxrow)\n\t\tn = rc->rc_maxrow;\n\n\t/* Calculate new row */\n\t*rc->rc_row -= n;\n\tif (*rc->rc_row < 0)\n\t\t*rc->rc_row  = 0;\n\n\t/* Calculate number of pixels to scroll */\n\tydiv = rc->rc_font->height * n;\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_emuheight - ydiv,\n\t    RAS_SRC, rc->rc_sp, rc->rc_xorigin, ydiv + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_xorigin, rc->rc_yorigin + rc->rc_emuheight - ydiv,\n\t    rc->rc_emuwidth, ydiv, rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_scroll(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int ydiv;\n\n\t/* Can't scroll more than the whole screen */\n\tif (n > rc->rc_maxrow)\n\t\tn = rc->rc_maxrow;\n\n\t/* Calculate new row */\n\t*rc->rc_row -= n;\n\tif (*rc->rc_row < 0)\n\t\t*rc->rc_row  = 0;\n\n\t/* Calculate number of pixels to scroll */\n\tydiv = rc->rc_font->height * n;\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_emuheight - ydiv,\n\t    RAS_SRC, rc->rc_sp, rc->rc_xorigin, ydiv + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_xorigin, rc->rc_yorigin + rc->rc_emuheight - ydiv,\n\t    rc->rc_emuwidth, ydiv, rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_puts(rc, str, n)\n\tregister struct rconsole *rc;\n\tregister unsigned char *str;\n\tregister int n;\n{\n\tregister int c, i, j;\n\tregister unsigned char *cp;\n\n\t/* Jump scroll */\n\t/* XXX maybe this should be an option? */\n\tif ((rc->rc_bits & FB_INESC) == 0) {\n\t\t/* Count newlines up to an escape sequence */\n\t\ti = 0;\n\t\tj = 0;\n\t\tfor (cp = str; j++ < n && *cp != '\\033'; ++cp) {\n\t\t\tif (*cp == '\\n')\n\t\t\t\t++i;\n\t\t\telse if (*cp == '\\013')\n\t\t\t\t--i;\n\t\t}\n\n\t\t/* Only jump scroll two or more rows */\n\t\tif (*rc->rc_row + i >= rc->rc_maxrow + 1) {\n\t\t\t/* Erase the cursor (if necessary) */\n\t\t\tif (rc->rc_bits & FB_CURSOR)\n\t\t\t\trcons_cursor(rc);\n\n\t\t\trcons_scroll(rc, i);\n\t\t}\n\t}\n\n\t/* Process characters */\n\twhile (--n >= 0) {\n\t\tc = *str;\n\t\tif (c == '\\033') {\n\t\t\t/* Start an escape (perhaps aborting one in progress) */\n\t\t\trc->rc_bits |= FB_INESC | FB_P0_DEFAULT | FB_P1_DEFAULT;\n\t\t\trc->rc_bits &= ~(FB_P0 | FB_P1);\n\n\t\t\t/* Most parameters default to 1 */\n\t\t\trc->rc_p0 = rc->rc_p1 = 1;\n\t\t} else if (rc->rc_bits & FB_INESC) {\n\t\t\trcons_esc(rc, c);\n\t\t} else {\n\t\t\t/* Erase the cursor (if necessary) */\n\t\t\tif (rc->rc_bits & FB_CURSOR)\n\t\t\t\trcons_cursor(rc);\n\n\t\t\t/* Display the character */\n\t\t\tif (RCONS_ISPRINT(c)) {\n\t\t\t\t/* Try to output as much as possible */\n\t\t\t\tj = rc->rc_maxcol - (*rc->rc_col + 1);\n\t\t\t\tif (j > n)\n\t\t\t\t\tj = n;\n\t\t\t\tfor (i = 1; i < j && RCONS_ISPRINT(str[i]); ++i)\n\t\t\t\t\tcontinue;\n\t\t\t\trcons_text(rc, str, i);\n\t\t\t\t--i;\n\t\t\t\tstr += i;\n\t\t\t\tn -= i;\n\t\t\t} else\n\t\t\t\trcons_pctrl(rc, c);\n\t\t}\n\t\t++str;\n\t}\n\t/* Redraw the cursor (if necessary) */\n\tif ((rc->rc_bits & FB_CURSOR) == 0)\n\t\trcons_cursor(rc);\n}"
  }
]