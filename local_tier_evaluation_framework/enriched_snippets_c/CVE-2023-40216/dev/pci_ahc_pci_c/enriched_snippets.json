[
  {
    "function_name": "ahc_pci_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
    "lines": "1325-1368",
    "snippet": "int\nahc_pci_intr(ahc)\nstruct ahc_softc *ahc;\n{\n\tpcireg_t status1;\n\tstruct ahc_pci_data *pd = ahc->pci_data;\n        \n\tif ((ahc_inb(ahc, ERROR) & PCIERRSTAT) == 0)\n                return 0;\n\n\tstatus1 = pci_conf_read(pd->pc, pd->tag, PCI_COMMAND_STATUS_REG);\n\n\tif (status1 & DPE) {\n\t\tprintf(\"%s: Data Parity Error Detected during address \"\n\t\t\t\t \"or write data phase\\n\", ahc_name(ahc));\n\t}\n\tif (status1 & SSE) {\n\t\tprintf(\"%s: Signal System Error Detected\\n\", ahc_name(ahc));\n\t}\n\tif (status1 & RMA) {\n\t\tprintf(\"%s: Received a Master Abort\\n\", ahc_name(ahc));\n\t}\n\tif (status1 & RTA) {\n\t\tprintf(\"%s: Received a Target Abort\\n\", ahc_name(ahc));\n\t}\n\tif (status1 & STA) {\n\t\tprintf(\"%s: Signaled a Target Abort\\n\", ahc_name(ahc));\n\t}\n\tif (status1 & DPR) {\n\t\tprintf(\"%s: Data Parity Error has been reported via PERR#\\n\",\n\t\t\t\t ahc_name(ahc));\n\t}\n\tif ((status1 & (DPE|SSE|RMA|RTA|STA|DPR)) == 0) {\n\t\tprintf(\"%s: Latched PCIERR interrupt with \"\n\t\t\t\t \"no status bits set\\n\", ahc_name(ahc)); \n\t}\n\tpci_conf_write(pd->pc, pd->tag, PCI_COMMAND_STATUS_REG, status1);\n\n\tif (status1 & (DPR|RMA|RTA)) {\n\t\tahc_outb(ahc, CLRINT, CLRPARERR);\n\t}\n\n        return 1;\n}",
    "includes": [
      "#include <dev/ic/smc93cx6var.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DPR\tPCI_STATUS_PARITY_ERROR",
      "#define STA\tPCI_STATUS_TARGET_TARGET_ABORT",
      "#define RTA\tPCI_STATUS_MASTER_TARGET_ABORT",
      "#define RMA\tPCI_STATUS_MASTER_ABORT",
      "#define SSE\tPCI_STATUS_SPECIAL_ERROR",
      "#define DPE\tPCI_STATUS_PARITY_DETECT"
    ],
    "globals_used": [
      "int\t    ahc_pci_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRINT",
            "CLRPARERR"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pd->pc",
            "pd->tag",
            "PCI_COMMAND_STATUS_REG",
            "status1"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: Latched PCIERR interrupt with \"\n\t\t\t\t \"no status bits set\\n\"",
            "ahc_name(ahc)"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pd->pc",
            "pd->tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "ERROR"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DPR\tPCI_STATUS_PARITY_ERROR\n#define STA\tPCI_STATUS_TARGET_TARGET_ABORT\n#define RTA\tPCI_STATUS_MASTER_TARGET_ABORT\n#define RMA\tPCI_STATUS_MASTER_ABORT\n#define SSE\tPCI_STATUS_SPECIAL_ERROR\n#define DPE\tPCI_STATUS_PARITY_DETECT\n\nint\t    ahc_pci_intr;\n\nint\nahc_pci_intr(ahc)\nstruct ahc_softc *ahc;\n{\n\tpcireg_t status1;\n\tstruct ahc_pci_data *pd = ahc->pci_data;\n        \n\tif ((ahc_inb(ahc, ERROR) & PCIERRSTAT) == 0)\n                return 0;\n\n\tstatus1 = pci_conf_read(pd->pc, pd->tag, PCI_COMMAND_STATUS_REG);\n\n\tif (status1 & DPE) {\n\t\tprintf(\"%s: Data Parity Error Detected during address \"\n\t\t\t\t \"or write data phase\\n\", ahc_name(ahc));\n\t}\n\tif (status1 & SSE) {\n\t\tprintf(\"%s: Signal System Error Detected\\n\", ahc_name(ahc));\n\t}\n\tif (status1 & RMA) {\n\t\tprintf(\"%s: Received a Master Abort\\n\", ahc_name(ahc));\n\t}\n\tif (status1 & RTA) {\n\t\tprintf(\"%s: Received a Target Abort\\n\", ahc_name(ahc));\n\t}\n\tif (status1 & STA) {\n\t\tprintf(\"%s: Signaled a Target Abort\\n\", ahc_name(ahc));\n\t}\n\tif (status1 & DPR) {\n\t\tprintf(\"%s: Data Parity Error has been reported via PERR#\\n\",\n\t\t\t\t ahc_name(ahc));\n\t}\n\tif ((status1 & (DPE|SSE|RMA|RTA|STA|DPR)) == 0) {\n\t\tprintf(\"%s: Latched PCIERR interrupt with \"\n\t\t\t\t \"no status bits set\\n\", ahc_name(ahc)); \n\t}\n\tpci_conf_write(pd->pc, pd->tag, PCI_COMMAND_STATUS_REG, status1);\n\n\tif (status1 & (DPR|RMA|RTA)) {\n\t\tahc_outb(ahc, CLRINT, CLRPARERR);\n\t}\n\n        return 1;\n}"
  },
  {
    "function_name": "release_seeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
    "lines": "1310-1316",
    "snippet": "static void\nrelease_seeprom(sd)\nstruct seeprom_descriptor *sd;\n{\n\t/* Release access to the memory port and the serial EEPROM. */\n\tSEEPROM_OUTB(sd, 0);\n}",
    "includes": [
      "#include <dev/ic/smc93cx6var.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void release_seeprom"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SEEPROM_OUTB",
          "args": [
            "sd",
            "0"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void release_seeprom;\n\nstatic void\nrelease_seeprom(sd)\nstruct seeprom_descriptor *sd;\n{\n\t/* Release access to the memory port and the serial EEPROM. */\n\tSEEPROM_OUTB(sd, 0);\n}"
  },
  {
    "function_name": "acquire_seeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
    "lines": "1280-1308",
    "snippet": "static int\nacquire_seeprom(ahc, sd)\nstruct ahc_softc *ahc;\nstruct seeprom_descriptor *sd;\n{\n\tint wait;\n\n\tif ((ahc->features & AHC_SPIOCAP) != 0\n\t\t && (ahc_inb(ahc, SPIOCAP) & SEEPROM) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Request access of the memory port.  When access is\n\t * granted, SEERDY will go high.  We use a 1 second\n\t * timeout which should be near 1 second more than\n\t * is needed.  Reason: after the chip reset, there\n\t * should be no contention.\n\t */\n\tSEEPROM_OUTB(sd, sd->sd_MS);\n\twait = 1000;  /* 1 second timeout in msec */\n\twhile (--wait && ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0)) {\n\t\tDELAY(1000);  /* delay 1 msec */\n\t}\n\tif ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0) {\n\t\tSEEPROM_OUTB(sd, 0); \n\t\treturn (0);\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/smc93cx6var.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int acquire_seeprom"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SEEPROM_OUTB",
          "args": [
            "sd",
            "0"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEEPROM_STATUS_INB",
          "args": [
            "sd"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEEPROM_STATUS_INB",
          "args": [
            "sd"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEEPROM_OUTB",
          "args": [
            "sd",
            "sd->sd_MS"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SPIOCAP"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int acquire_seeprom;\n\nstatic int\nacquire_seeprom(ahc, sd)\nstruct ahc_softc *ahc;\nstruct seeprom_descriptor *sd;\n{\n\tint wait;\n\n\tif ((ahc->features & AHC_SPIOCAP) != 0\n\t\t && (ahc_inb(ahc, SPIOCAP) & SEEPROM) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Request access of the memory port.  When access is\n\t * granted, SEERDY will go high.  We use a 1 second\n\t * timeout which should be near 1 second more than\n\t * is needed.  Reason: after the chip reset, there\n\t * should be no contention.\n\t */\n\tSEEPROM_OUTB(sd, sd->sd_MS);\n\twait = 1000;  /* 1 second timeout in msec */\n\twhile (--wait && ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0)) {\n\t\tDELAY(1000);  /* delay 1 msec */\n\t}\n\tif ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0) {\n\t\tSEEPROM_OUTB(sd, 0); \n\t\treturn (0);\n\t}\n\treturn (1);\n}"
  },
  {
    "function_name": "read_brdctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
    "lines": "1257-1278",
    "snippet": "static u_int8_t\nread_brdctl(ahc)\nstruct   ahc_softc *ahc;\n{\n\tu_int8_t brdctl;\n\tu_int8_t value;\n\n\tif ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {\n\t\tbrdctl = BRDRW;\n\t\tif (ahc->channel == 'B')\n\t\t\tbrdctl |= BRDCS;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tbrdctl = BRDRW_ULTRA2;\n\t} else {\n\t\tbrdctl = BRDRW|BRDCS;\n\t}\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tvalue = ahc_inb(ahc, BRDCTL);\n\tahc_outb(ahc, BRDCTL, 0);\n\treturn (value);\n}",
    "includes": [
      "#include <dev/ic/smc93cx6var.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u_int8_t read_brdctl"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "BRDCTL",
            "0"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "BRDCTL"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "20"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "BRDCTL",
            "brdctl"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic u_int8_t read_brdctl;\n\nstatic u_int8_t\nread_brdctl(ahc)\nstruct   ahc_softc *ahc;\n{\n\tu_int8_t brdctl;\n\tu_int8_t value;\n\n\tif ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {\n\t\tbrdctl = BRDRW;\n\t\tif (ahc->channel == 'B')\n\t\t\tbrdctl |= BRDCS;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tbrdctl = BRDRW_ULTRA2;\n\t} else {\n\t\tbrdctl = BRDRW|BRDCS;\n\t}\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tvalue = ahc_inb(ahc, BRDCTL);\n\tahc_outb(ahc, BRDCTL, 0);\n\treturn (value);\n}"
  },
  {
    "function_name": "write_brdctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
    "lines": "1223-1255",
    "snippet": "static void\nwrite_brdctl(ahc, value)\nstruct   ahc_softc *ahc;\nu_int8_t value;\n{\n\tu_int8_t brdctl;\n\n\tif ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {\n\t\tbrdctl = BRDSTB;\n\t\tif (ahc->channel == 'B')\n\t\t\tbrdctl |= BRDCS;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tbrdctl = 0;\n\t} else {\n\t\tbrdctl = BRDSTB|BRDCS;\n\t}\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tbrdctl |= value;\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tbrdctl |= BRDSTB_ULTRA2;\n\telse\n\t\tbrdctl &= ~BRDSTB;\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tbrdctl = 0;\n\telse\n\t\tbrdctl &= ~BRDCS;\n\tahc_outb(ahc, BRDCTL, brdctl);\n}",
    "includes": [
      "#include <dev/ic/smc93cx6var.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void write_brdctl"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "BRDCTL",
            "brdctl"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "20"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "BRDCTL",
            "brdctl"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "20"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "BRDCTL",
            "brdctl"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "20"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "BRDCTL",
            "brdctl"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void write_brdctl;\n\nstatic void\nwrite_brdctl(ahc, value)\nstruct   ahc_softc *ahc;\nu_int8_t value;\n{\n\tu_int8_t brdctl;\n\n\tif ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {\n\t\tbrdctl = BRDSTB;\n\t\tif (ahc->channel == 'B')\n\t\t\tbrdctl |= BRDCS;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tbrdctl = 0;\n\t} else {\n\t\tbrdctl = BRDSTB|BRDCS;\n\t}\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tbrdctl |= value;\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tbrdctl |= BRDSTB_ULTRA2;\n\telse\n\t\tbrdctl &= ~BRDSTB;\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tbrdctl = 0;\n\telse\n\t\tbrdctl &= ~BRDCS;\n\tahc_outb(ahc, BRDCTL, brdctl);\n}"
  },
  {
    "function_name": "aic785X_cable_detect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
    "lines": "1204-1221",
    "snippet": "static void\naic785X_cable_detect(ahc, internal50_present, externalcable_present,\n\t\t     eeprom_present)\nstruct ahc_softc *ahc;\nint *internal50_present;\nint *externalcable_present;\nint *eeprom_present;\n{\n\tu_int8_t brdctl;\n\n\tahc_outb(ahc, BRDCTL, BRDRW|BRDCS);\n\tahc_outb(ahc, BRDCTL, 0);\n\tbrdctl = ahc_inb(ahc, BRDCTL);\n\t*internal50_present = !(brdctl & BRDDAT5);\n\t*externalcable_present = !(brdctl & BRDDAT6);\n\n\t*eeprom_present = (ahc_inb(ahc, SPIOCAP) & EEPROM) != 0;\n}",
    "includes": [
      "#include <dev/ic/smc93cx6var.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void aic785X_cable_detect"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SPIOCAP"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "BRDCTL"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "BRDCTL",
            "0"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "BRDCTL",
            "BRDRW|BRDCS"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void aic785X_cable_detect;\n\nstatic void\naic785X_cable_detect(ahc, internal50_present, externalcable_present,\n\t\t     eeprom_present)\nstruct ahc_softc *ahc;\nint *internal50_present;\nint *externalcable_present;\nint *eeprom_present;\n{\n\tu_int8_t brdctl;\n\n\tahc_outb(ahc, BRDCTL, BRDRW|BRDCS);\n\tahc_outb(ahc, BRDCTL, 0);\n\tbrdctl = ahc_inb(ahc, BRDCTL);\n\t*internal50_present = !(brdctl & BRDDAT5);\n\t*externalcable_present = !(brdctl & BRDDAT6);\n\n\t*eeprom_present = (ahc_inb(ahc, SPIOCAP) & EEPROM) != 0;\n}"
  },
  {
    "function_name": "aic787X_cable_detect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
    "lines": "1159-1202",
    "snippet": "static void\naic787X_cable_detect(ahc, internal50_present, internal68_present,\n\t\t     externalcable_present, eeprom_present)\nstruct ahc_softc *ahc;\nint *internal50_present;\nint *internal68_present;\nint *externalcable_present;\nint *eeprom_present;\n{\n\tu_int8_t brdctl;\n\n\t/*\n\t * First read the status of our cables.\n\t * Set the rom bank to 0 since the\n\t * bank setting serves as a multiplexor\n\t * for the cable detection logic.\n\t * BRDDAT5 controls the bank switch.\n\t */\n\twrite_brdctl(ahc, 0);\n\n\t/*\n\t * Now read the state of the internal\n\t * connectors.  BRDDAT6 is INT50 and\n\t * BRDDAT7 is INT68.\n\t */\n\tbrdctl = read_brdctl(ahc);\n\t*internal50_present = !(brdctl & BRDDAT6);\n\t*internal68_present = !(brdctl & BRDDAT7);\n\n\t/*\n\t * Set the rom bank to 1 and determine\n\t * the other signals.\n\t */\n\twrite_brdctl(ahc, BRDDAT5);\n\n\t/*\n\t * Now read the state of the external\n\t * connectors.  BRDDAT6 is EXT68 and\n\t * BRDDAT7 is EPROMPS.\n\t */\n\tbrdctl = read_brdctl(ahc);\n\t*externalcable_present = !(brdctl & BRDDAT6);\n\t*eeprom_present = brdctl & BRDDAT7;\n}",
    "includes": [
      "#include <dev/ic/smc93cx6var.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void aic787X_cable_detect",
      "static void write_brdctl",
      "static u_int8_t read_brdctl"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_brdctl",
          "args": [
            "ahc"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "read_brdctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
          "lines": "1257-1278",
          "snippet": "static u_int8_t\nread_brdctl(ahc)\nstruct   ahc_softc *ahc;\n{\n\tu_int8_t brdctl;\n\tu_int8_t value;\n\n\tif ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {\n\t\tbrdctl = BRDRW;\n\t\tif (ahc->channel == 'B')\n\t\t\tbrdctl |= BRDCS;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tbrdctl = BRDRW_ULTRA2;\n\t} else {\n\t\tbrdctl = BRDRW|BRDCS;\n\t}\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tvalue = ahc_inb(ahc, BRDCTL);\n\tahc_outb(ahc, BRDCTL, 0);\n\treturn (value);\n}",
          "includes": [
            "#include <dev/ic/smc93cx6var.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int8_t read_brdctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic u_int8_t read_brdctl;\n\nstatic u_int8_t\nread_brdctl(ahc)\nstruct   ahc_softc *ahc;\n{\n\tu_int8_t brdctl;\n\tu_int8_t value;\n\n\tif ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {\n\t\tbrdctl = BRDRW;\n\t\tif (ahc->channel == 'B')\n\t\t\tbrdctl |= BRDCS;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tbrdctl = BRDRW_ULTRA2;\n\t} else {\n\t\tbrdctl = BRDRW|BRDCS;\n\t}\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tvalue = ahc_inb(ahc, BRDCTL);\n\tahc_outb(ahc, BRDCTL, 0);\n\treturn (value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_brdctl",
          "args": [
            "ahc",
            "BRDDAT5"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "write_brdctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
          "lines": "1223-1255",
          "snippet": "static void\nwrite_brdctl(ahc, value)\nstruct   ahc_softc *ahc;\nu_int8_t value;\n{\n\tu_int8_t brdctl;\n\n\tif ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {\n\t\tbrdctl = BRDSTB;\n\t\tif (ahc->channel == 'B')\n\t\t\tbrdctl |= BRDCS;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tbrdctl = 0;\n\t} else {\n\t\tbrdctl = BRDSTB|BRDCS;\n\t}\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tbrdctl |= value;\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tbrdctl |= BRDSTB_ULTRA2;\n\telse\n\t\tbrdctl &= ~BRDSTB;\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tbrdctl = 0;\n\telse\n\t\tbrdctl &= ~BRDCS;\n\tahc_outb(ahc, BRDCTL, brdctl);\n}",
          "includes": [
            "#include <dev/ic/smc93cx6var.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void write_brdctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void write_brdctl;\n\nstatic void\nwrite_brdctl(ahc, value)\nstruct   ahc_softc *ahc;\nu_int8_t value;\n{\n\tu_int8_t brdctl;\n\n\tif ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {\n\t\tbrdctl = BRDSTB;\n\t\tif (ahc->channel == 'B')\n\t\t\tbrdctl |= BRDCS;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tbrdctl = 0;\n\t} else {\n\t\tbrdctl = BRDSTB|BRDCS;\n\t}\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tbrdctl |= value;\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tbrdctl |= BRDSTB_ULTRA2;\n\telse\n\t\tbrdctl &= ~BRDSTB;\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tbrdctl = 0;\n\telse\n\t\tbrdctl &= ~BRDCS;\n\tahc_outb(ahc, BRDCTL, brdctl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void aic787X_cable_detect;\nstatic void write_brdctl;\nstatic u_int8_t read_brdctl;\n\nstatic void\naic787X_cable_detect(ahc, internal50_present, internal68_present,\n\t\t     externalcable_present, eeprom_present)\nstruct ahc_softc *ahc;\nint *internal50_present;\nint *internal68_present;\nint *externalcable_present;\nint *eeprom_present;\n{\n\tu_int8_t brdctl;\n\n\t/*\n\t * First read the status of our cables.\n\t * Set the rom bank to 0 since the\n\t * bank setting serves as a multiplexor\n\t * for the cable detection logic.\n\t * BRDDAT5 controls the bank switch.\n\t */\n\twrite_brdctl(ahc, 0);\n\n\t/*\n\t * Now read the state of the internal\n\t * connectors.  BRDDAT6 is INT50 and\n\t * BRDDAT7 is INT68.\n\t */\n\tbrdctl = read_brdctl(ahc);\n\t*internal50_present = !(brdctl & BRDDAT6);\n\t*internal68_present = !(brdctl & BRDDAT7);\n\n\t/*\n\t * Set the rom bank to 1 and determine\n\t * the other signals.\n\t */\n\twrite_brdctl(ahc, BRDDAT5);\n\n\t/*\n\t * Now read the state of the external\n\t * connectors.  BRDDAT6 is EXT68 and\n\t * BRDDAT7 is EPROMPS.\n\t */\n\tbrdctl = read_brdctl(ahc);\n\t*externalcable_present = !(brdctl & BRDDAT6);\n\t*eeprom_present = brdctl & BRDDAT7;\n}"
  },
  {
    "function_name": "ahc_new_term_detect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
    "lines": "1132-1157",
    "snippet": "static void\nahc_new_term_detect(ahc, enableSEC_low, enableSEC_high, enablePRI_low, \n\t\t    enablePRI_high, eeprom_present)\nstruct ahc_softc *ahc;\nint *enableSEC_low;\nint *enableSEC_high;\nint *enablePRI_low;\nint *enablePRI_high;\nint *eeprom_present;\n{\n\tu_int8_t brdctl;\n\n\t/*\n\t * BRDDAT7 = Eeprom\n\t * BRDDAT6 = Enable Secondary High Byte termination\n\t * BRDDAT5 = Enable Secondary Low Byte termination\n\t * BRDDAT4 = Enable Primary high byte termination\n\t * BRDDAT3 = Enable Primary low byte termination\n\t */\n\tbrdctl = read_brdctl(ahc);\n\t*eeprom_present = brdctl & BRDDAT7;\n\t*enableSEC_high = (brdctl & BRDDAT6);\n\t*enableSEC_low = (brdctl & BRDDAT5);\n\t*enablePRI_high = (brdctl & BRDDAT4);\n\t*enablePRI_low = (brdctl & BRDDAT3);\n}",
    "includes": [
      "#include <dev/ic/smc93cx6var.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ahc_new_term_detect",
      "static u_int8_t read_brdctl"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_brdctl",
          "args": [
            "ahc"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "read_brdctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
          "lines": "1257-1278",
          "snippet": "static u_int8_t\nread_brdctl(ahc)\nstruct   ahc_softc *ahc;\n{\n\tu_int8_t brdctl;\n\tu_int8_t value;\n\n\tif ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {\n\t\tbrdctl = BRDRW;\n\t\tif (ahc->channel == 'B')\n\t\t\tbrdctl |= BRDCS;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tbrdctl = BRDRW_ULTRA2;\n\t} else {\n\t\tbrdctl = BRDRW|BRDCS;\n\t}\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tvalue = ahc_inb(ahc, BRDCTL);\n\tahc_outb(ahc, BRDCTL, 0);\n\treturn (value);\n}",
          "includes": [
            "#include <dev/ic/smc93cx6var.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int8_t read_brdctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic u_int8_t read_brdctl;\n\nstatic u_int8_t\nread_brdctl(ahc)\nstruct   ahc_softc *ahc;\n{\n\tu_int8_t brdctl;\n\tu_int8_t value;\n\n\tif ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {\n\t\tbrdctl = BRDRW;\n\t\tif (ahc->channel == 'B')\n\t\t\tbrdctl |= BRDCS;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tbrdctl = BRDRW_ULTRA2;\n\t} else {\n\t\tbrdctl = BRDRW|BRDCS;\n\t}\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tvalue = ahc_inb(ahc, BRDCTL);\n\tahc_outb(ahc, BRDCTL, 0);\n\treturn (value);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void ahc_new_term_detect;\nstatic u_int8_t read_brdctl;\n\nstatic void\nahc_new_term_detect(ahc, enableSEC_low, enableSEC_high, enablePRI_low, \n\t\t    enablePRI_high, eeprom_present)\nstruct ahc_softc *ahc;\nint *enableSEC_low;\nint *enableSEC_high;\nint *enablePRI_low;\nint *enablePRI_high;\nint *eeprom_present;\n{\n\tu_int8_t brdctl;\n\n\t/*\n\t * BRDDAT7 = Eeprom\n\t * BRDDAT6 = Enable Secondary High Byte termination\n\t * BRDDAT5 = Enable Secondary Low Byte termination\n\t * BRDDAT4 = Enable Primary high byte termination\n\t * BRDDAT3 = Enable Primary low byte termination\n\t */\n\tbrdctl = read_brdctl(ahc);\n\t*eeprom_present = brdctl & BRDDAT7;\n\t*enableSEC_high = (brdctl & BRDDAT6);\n\t*enableSEC_low = (brdctl & BRDDAT5);\n\t*enablePRI_high = (brdctl & BRDDAT4);\n\t*enablePRI_low = (brdctl & BRDDAT3);\n}"
  },
  {
    "function_name": "configure_termination",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
    "lines": "920-1130",
    "snippet": "static void\nconfigure_termination(ahc, sd, adapter_control, sxfrctl1)\nstruct ahc_softc *ahc;\nstruct seeprom_descriptor *sd;\nu_int adapter_control;\nu_int *sxfrctl1;\n{\n\tu_int8_t brddat;\n\n\tbrddat = 0;\n\n\t/*\n\t * Update the settings in sxfrctl1 to match the\n\t * termination settings \n\t */\n\t*sxfrctl1 = 0;\n\n\t/*\n\t * SEECS must be on for the GALS to latch\n\t * the data properly.  Be sure to leave MS\n\t * on or we will release the seeprom.\n\t */\n\tSEEPROM_OUTB(sd, sd->sd_MS | sd->sd_CS);\n\tif ((adapter_control & CFAUTOTERM) != 0\n\t\t || (ahc->features & AHC_NEW_TERMCTL) != 0) {\n\t\tint internal50_present;\n\t\tint internal68_present;\n\t\tint externalcable_present;\n\t\tint eeprom_present;\n\t\tint enableSEC_low;\n\t\tint enableSEC_high;\n\t\tint enablePRI_low;\n\t\tint enablePRI_high;\n\n\t\tenableSEC_low = 0;\n\t\tenableSEC_high = 0;\n\t\tenablePRI_low = 0;\n\t\tenablePRI_high = 0;\n\t\tif ((ahc->features & AHC_NEW_TERMCTL) != 0) {\n\t\t\tahc_new_term_detect(ahc, &enableSEC_low,\n\t\t\t\t\t    &enableSEC_high,\n\t\t\t\t\t    &enablePRI_low,\n\t\t\t\t\t    &enablePRI_high,\n\t\t\t\t\t    &eeprom_present);\n\t\t\tif ((adapter_control & CFSEAUTOTERM) == 0) {\n\t\t\t\tif (bootverbose)\n\t\t\t\t\tprintf(\"%s: Manual SE Termination\\n\",\n\t\t\t\t\t\t\t ahc_name(ahc));\n\t\t\t\tenableSEC_low = (adapter_control & CFSTERM);\n\t\t\t\tenableSEC_high = (adapter_control & CFWSTERM);\n\t\t\t}\n\t\t\tif ((adapter_control & CFAUTOTERM) == 0) {\n\t\t\t\tif (bootverbose)\n\t\t\t\t\tprintf(\"%s: Manual LVD Termination\\n\",\n\t\t\t\t\t       ahc_name(ahc));\n\t\t\t\tenablePRI_low = enablePRI_high =\n\t\t\t\t\t(adapter_control & CFLVDSTERM);\n\t\t\t}\n\t\t\t/* Make the table calculations below happy */\n\t\t\tinternal50_present = 0;\n\t\t\tinternal68_present = 1;\n\t\t\texternalcable_present = 1;\n\t\t} else if ((ahc->features & AHC_SPIOCAP) != 0) {\n\t\t\taic785X_cable_detect(ahc, &internal50_present,\n\t\t\t\t\t     &externalcable_present,\n\t\t\t\t\t     &eeprom_present);\n\t\t} else {\n\t\t\taic787X_cable_detect(ahc, &internal50_present,\n\t\t\t\t\t     &internal68_present,\n\t\t\t\t\t     &externalcable_present,\n\t\t\t\t\t     &eeprom_present);\n\t\t}\n\n\t\tif ((ahc->features & AHC_WIDE) == 0)\n\t\t\tinternal68_present = 0;\n\n\t\tif (bootverbose) {\n\t\t\tif ((ahc->features & AHC_ULTRA2) == 0) {\n\t\t\t\tprintf(\"%s: internal 50 cable %s present, \"\n\t\t\t\t       \"internal 68 cable %s present\\n\",\n\t\t\t\t       ahc_name(ahc),\n\t\t\t\t       internal50_present ? \"is\":\"not\",\n\t\t\t\t       internal68_present ? \"is\":\"not\");\n\n\t\t\t\tprintf(\"%s: external cable %s present\\n\",\n\t\t\t\t       ahc_name(ahc),\n\t\t\t\t       externalcable_present ? \"is\":\"not\");\n\t\t\t}\n\t\t\tprintf(\"%s: BIOS eeprom %s present\\n\",\n\t\t\t       ahc_name(ahc), eeprom_present ? \"is\" : \"not\");\n\t\t}\n\n\t\tif ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0) {\n\t\t\t/*\n\t\t\t * The 50 pin connector is a separate bus,\n\t\t\t * so force it to always be terminated.\n\t\t\t * In the future, perform current sensing\n\t\t\t * to determine if we are in the middle of\n\t\t\t * a properly terminated bus.\n\t\t\t */\n\t\t\tinternal50_present = 0;\n\t\t}\n\n\t\t/*\n\t\t * Now set the termination based on what\n\t\t * we found.\n\t\t * Flash Enable = BRDDAT7\n\t\t * Secondary High Term Enable = BRDDAT6\n\t\t * Secondary Low Term Enable = BRDDAT5 (7890)\n\t\t * Primary High Term Enable = BRDDAT4 (7890)\n\t\t */\n\t\tif ((ahc->features & AHC_ULTRA2) == 0\n\t\t    && (internal50_present != 0)\n\t\t    && (internal68_present != 0)\n\t\t    && (externalcable_present != 0)) {\n\t\t\tprintf(\"%s: Illegal cable configuration!!. \"\n\t\t\t       \"Only two connectors on the \"\n\t\t\t       \"adapter may be used at a \"\n\t\t\t       \"time!\\n\", ahc_name(ahc));\n\t\t}\n\n\t\tif ((ahc->features & AHC_WIDE) != 0\n\t\t\t && ((externalcable_present == 0)\n\t\t\t\t  || (internal68_present == 0)\n\t\t\t\t  || (enableSEC_high != 0))) {\n\t\t\tbrddat |= BRDDAT6;\n\t\t\tif (bootverbose) {\n\t\t\t\tif ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0)\n\t\t\t\t\tprintf(\"%s: 68 pin termination \"\n\t\t\t\t\t       \"Enabled\\n\", ahc_name(ahc));\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%s: %sHigh byte termination \"\n\t\t\t\t\t       \"Enabled\\n\", ahc_name(ahc),\n\t\t\t\t\t       enableSEC_high ? \"Secondary \"\n\t\t\t\t\t       : \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (((internal50_present ? 1 : 0)\n\t\t\t  + (internal68_present ? 1 : 0)\n\t\t\t  + (externalcable_present ? 1 : 0)) <= 1\n\t\t\t || (enableSEC_low != 0)) {\n\t\t\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\t\t\tbrddat |= BRDDAT5;\n\t\t\telse\n\t\t\t\t*sxfrctl1 |= STPWEN;\n\t\t\tif (bootverbose) {\n\t\t\t\tif ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0)\n\t\t\t\t\tprintf(\"%s: 50 pin termination \"\n\t\t\t\t\t       \"Enabled\\n\", ahc_name(ahc));\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%s: %sLow byte termination \"\n\t\t\t\t\t       \"Enabled\\n\", ahc_name(ahc),\n\t\t\t\t\t       enableSEC_low ? \"Secondary \"\n\t\t\t\t\t       : \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (enablePRI_low != 0) {\n\t\t\t*sxfrctl1 |= STPWEN;\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: Primary Low Byte termination \"\n\t\t\t\t       \"Enabled\\n\", ahc_name(ahc));\n\t\t}\n\n\t\t/*\n\t\t * Setup STPWEN before setting up the rest of\n\t\t * the termination per the tech note on the U160 cards.\n\t\t */\n\t\tahc_outb(ahc, SXFRCTL1, *sxfrctl1);\n\n\t\tif (enablePRI_high != 0) {\n\t\t\tbrddat |= BRDDAT4;\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: Primary High Byte \"\n\t\t\t\t       \"termination Enabled\\n\",\n\t\t\t\t       ahc_name(ahc));\n\t\t}\n\n\t\twrite_brdctl(ahc, brddat);\n\n\t} else {\n\t\tif ((adapter_control & CFSTERM) != 0) {\n\t\t\t*sxfrctl1 |= STPWEN;\n\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: %sLow byte termination Enabled\\n\",\n\t\t\t\t       ahc_name(ahc),\n\t\t\t\t       (ahc->features & AHC_ULTRA2)\n\t\t\t\t       ? \"Primary \" : \"\");\n\t\t}\n\n\t\tif ((adapter_control & CFWSTERM) != 0) {\n\t\t\tbrddat |= BRDDAT6;\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: %sHigh byte termination Enabled\\n\",\n\t\t\t\t       ahc_name(ahc),\n\t\t\t\t       (ahc->features & AHC_ULTRA2)\n\t\t\t\t       ? \"Secondary \" : \"\");\n\t\t}\n\n\t\t/*\n\t\t * Setup STPWEN before setting up the rest of\n\t\t * the termination per the tech note on the U160 cards.\n\t\t */\n\t\tahc_outb(ahc, SXFRCTL1, *sxfrctl1);\n\n\t\twrite_brdctl(ahc, brddat);\n\t}\n\tSEEPROM_OUTB(sd, sd->sd_MS); /* Clear CS */\n}",
    "includes": [
      "#include <dev/ic/smc93cx6var.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define bootverbose\t0",
      "#define bootverbose\t1"
    ],
    "globals_used": [
      "static void configure_termination",
      "static void ahc_new_term_detect",
      "static void aic787X_cable_detect",
      "static void aic785X_cable_detect",
      "static void write_brdctl"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SEEPROM_OUTB",
          "args": [
            "sd",
            "sd->sd_MS"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_brdctl",
          "args": [
            "ahc",
            "brddat"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "write_brdctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
          "lines": "1223-1255",
          "snippet": "static void\nwrite_brdctl(ahc, value)\nstruct   ahc_softc *ahc;\nu_int8_t value;\n{\n\tu_int8_t brdctl;\n\n\tif ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {\n\t\tbrdctl = BRDSTB;\n\t\tif (ahc->channel == 'B')\n\t\t\tbrdctl |= BRDCS;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tbrdctl = 0;\n\t} else {\n\t\tbrdctl = BRDSTB|BRDCS;\n\t}\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tbrdctl |= value;\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tbrdctl |= BRDSTB_ULTRA2;\n\telse\n\t\tbrdctl &= ~BRDSTB;\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tbrdctl = 0;\n\telse\n\t\tbrdctl &= ~BRDCS;\n\tahc_outb(ahc, BRDCTL, brdctl);\n}",
          "includes": [
            "#include <dev/ic/smc93cx6var.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void write_brdctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void write_brdctl;\n\nstatic void\nwrite_brdctl(ahc, value)\nstruct   ahc_softc *ahc;\nu_int8_t value;\n{\n\tu_int8_t brdctl;\n\n\tif ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {\n\t\tbrdctl = BRDSTB;\n\t\tif (ahc->channel == 'B')\n\t\t\tbrdctl |= BRDCS;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tbrdctl = 0;\n\t} else {\n\t\tbrdctl = BRDSTB|BRDCS;\n\t}\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tbrdctl |= value;\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tbrdctl |= BRDSTB_ULTRA2;\n\telse\n\t\tbrdctl &= ~BRDSTB;\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tDELAY(20);\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tbrdctl = 0;\n\telse\n\t\tbrdctl &= ~BRDCS;\n\tahc_outb(ahc, BRDCTL, brdctl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SXFRCTL1",
            "*sxfrctl1"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %sHigh byte termination Enabled\\n\"",
            "ahc_name(ahc)",
            "(ahc->features & AHC_ULTRA2)\n\t\t\t\t       ? \"Secondary \" : \"\""
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SXFRCTL1",
            "*sxfrctl1"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aic787X_cable_detect",
          "args": [
            "ahc",
            "&internal50_present",
            "&internal68_present",
            "&externalcable_present",
            "&eeprom_present"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "aic787X_cable_detect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
          "lines": "1159-1202",
          "snippet": "static void\naic787X_cable_detect(ahc, internal50_present, internal68_present,\n\t\t     externalcable_present, eeprom_present)\nstruct ahc_softc *ahc;\nint *internal50_present;\nint *internal68_present;\nint *externalcable_present;\nint *eeprom_present;\n{\n\tu_int8_t brdctl;\n\n\t/*\n\t * First read the status of our cables.\n\t * Set the rom bank to 0 since the\n\t * bank setting serves as a multiplexor\n\t * for the cable detection logic.\n\t * BRDDAT5 controls the bank switch.\n\t */\n\twrite_brdctl(ahc, 0);\n\n\t/*\n\t * Now read the state of the internal\n\t * connectors.  BRDDAT6 is INT50 and\n\t * BRDDAT7 is INT68.\n\t */\n\tbrdctl = read_brdctl(ahc);\n\t*internal50_present = !(brdctl & BRDDAT6);\n\t*internal68_present = !(brdctl & BRDDAT7);\n\n\t/*\n\t * Set the rom bank to 1 and determine\n\t * the other signals.\n\t */\n\twrite_brdctl(ahc, BRDDAT5);\n\n\t/*\n\t * Now read the state of the external\n\t * connectors.  BRDDAT6 is EXT68 and\n\t * BRDDAT7 is EPROMPS.\n\t */\n\tbrdctl = read_brdctl(ahc);\n\t*externalcable_present = !(brdctl & BRDDAT6);\n\t*eeprom_present = brdctl & BRDDAT7;\n}",
          "includes": [
            "#include <dev/ic/smc93cx6var.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void aic787X_cable_detect",
            "static void write_brdctl",
            "static u_int8_t read_brdctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void aic787X_cable_detect;\nstatic void write_brdctl;\nstatic u_int8_t read_brdctl;\n\nstatic void\naic787X_cable_detect(ahc, internal50_present, internal68_present,\n\t\t     externalcable_present, eeprom_present)\nstruct ahc_softc *ahc;\nint *internal50_present;\nint *internal68_present;\nint *externalcable_present;\nint *eeprom_present;\n{\n\tu_int8_t brdctl;\n\n\t/*\n\t * First read the status of our cables.\n\t * Set the rom bank to 0 since the\n\t * bank setting serves as a multiplexor\n\t * for the cable detection logic.\n\t * BRDDAT5 controls the bank switch.\n\t */\n\twrite_brdctl(ahc, 0);\n\n\t/*\n\t * Now read the state of the internal\n\t * connectors.  BRDDAT6 is INT50 and\n\t * BRDDAT7 is INT68.\n\t */\n\tbrdctl = read_brdctl(ahc);\n\t*internal50_present = !(brdctl & BRDDAT6);\n\t*internal68_present = !(brdctl & BRDDAT7);\n\n\t/*\n\t * Set the rom bank to 1 and determine\n\t * the other signals.\n\t */\n\twrite_brdctl(ahc, BRDDAT5);\n\n\t/*\n\t * Now read the state of the external\n\t * connectors.  BRDDAT6 is EXT68 and\n\t * BRDDAT7 is EPROMPS.\n\t */\n\tbrdctl = read_brdctl(ahc);\n\t*externalcable_present = !(brdctl & BRDDAT6);\n\t*eeprom_present = brdctl & BRDDAT7;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aic785X_cable_detect",
          "args": [
            "ahc",
            "&internal50_present",
            "&externalcable_present",
            "&eeprom_present"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "aic785X_cable_detect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
          "lines": "1204-1221",
          "snippet": "static void\naic785X_cable_detect(ahc, internal50_present, externalcable_present,\n\t\t     eeprom_present)\nstruct ahc_softc *ahc;\nint *internal50_present;\nint *externalcable_present;\nint *eeprom_present;\n{\n\tu_int8_t brdctl;\n\n\tahc_outb(ahc, BRDCTL, BRDRW|BRDCS);\n\tahc_outb(ahc, BRDCTL, 0);\n\tbrdctl = ahc_inb(ahc, BRDCTL);\n\t*internal50_present = !(brdctl & BRDDAT5);\n\t*externalcable_present = !(brdctl & BRDDAT6);\n\n\t*eeprom_present = (ahc_inb(ahc, SPIOCAP) & EEPROM) != 0;\n}",
          "includes": [
            "#include <dev/ic/smc93cx6var.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void aic785X_cable_detect"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void aic785X_cable_detect;\n\nstatic void\naic785X_cable_detect(ahc, internal50_present, externalcable_present,\n\t\t     eeprom_present)\nstruct ahc_softc *ahc;\nint *internal50_present;\nint *externalcable_present;\nint *eeprom_present;\n{\n\tu_int8_t brdctl;\n\n\tahc_outb(ahc, BRDCTL, BRDRW|BRDCS);\n\tahc_outb(ahc, BRDCTL, 0);\n\tbrdctl = ahc_inb(ahc, BRDCTL);\n\t*internal50_present = !(brdctl & BRDDAT5);\n\t*externalcable_present = !(brdctl & BRDDAT6);\n\n\t*eeprom_present = (ahc_inb(ahc, SPIOCAP) & EEPROM) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_new_term_detect",
          "args": [
            "ahc",
            "&enableSEC_low",
            "&enableSEC_high",
            "&enablePRI_low",
            "&enablePRI_high",
            "&eeprom_present"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_new_term_detect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
          "lines": "1132-1157",
          "snippet": "static void\nahc_new_term_detect(ahc, enableSEC_low, enableSEC_high, enablePRI_low, \n\t\t    enablePRI_high, eeprom_present)\nstruct ahc_softc *ahc;\nint *enableSEC_low;\nint *enableSEC_high;\nint *enablePRI_low;\nint *enablePRI_high;\nint *eeprom_present;\n{\n\tu_int8_t brdctl;\n\n\t/*\n\t * BRDDAT7 = Eeprom\n\t * BRDDAT6 = Enable Secondary High Byte termination\n\t * BRDDAT5 = Enable Secondary Low Byte termination\n\t * BRDDAT4 = Enable Primary high byte termination\n\t * BRDDAT3 = Enable Primary low byte termination\n\t */\n\tbrdctl = read_brdctl(ahc);\n\t*eeprom_present = brdctl & BRDDAT7;\n\t*enableSEC_high = (brdctl & BRDDAT6);\n\t*enableSEC_low = (brdctl & BRDDAT5);\n\t*enablePRI_high = (brdctl & BRDDAT4);\n\t*enablePRI_low = (brdctl & BRDDAT3);\n}",
          "includes": [
            "#include <dev/ic/smc93cx6var.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ahc_new_term_detect",
            "static u_int8_t read_brdctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void ahc_new_term_detect;\nstatic u_int8_t read_brdctl;\n\nstatic void\nahc_new_term_detect(ahc, enableSEC_low, enableSEC_high, enablePRI_low, \n\t\t    enablePRI_high, eeprom_present)\nstruct ahc_softc *ahc;\nint *enableSEC_low;\nint *enableSEC_high;\nint *enablePRI_low;\nint *enablePRI_high;\nint *eeprom_present;\n{\n\tu_int8_t brdctl;\n\n\t/*\n\t * BRDDAT7 = Eeprom\n\t * BRDDAT6 = Enable Secondary High Byte termination\n\t * BRDDAT5 = Enable Secondary Low Byte termination\n\t * BRDDAT4 = Enable Primary high byte termination\n\t * BRDDAT3 = Enable Primary low byte termination\n\t */\n\tbrdctl = read_brdctl(ahc);\n\t*eeprom_present = brdctl & BRDDAT7;\n\t*enableSEC_high = (brdctl & BRDDAT6);\n\t*enableSEC_low = (brdctl & BRDDAT5);\n\t*enablePRI_high = (brdctl & BRDDAT4);\n\t*enablePRI_low = (brdctl & BRDDAT3);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SEEPROM_OUTB",
          "args": [
            "sd",
            "sd->sd_MS | sd->sd_CS"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define bootverbose\t0\n#define bootverbose\t1\n\nstatic void configure_termination;\nstatic void ahc_new_term_detect;\nstatic void aic787X_cable_detect;\nstatic void aic785X_cable_detect;\nstatic void write_brdctl;\n\nstatic void\nconfigure_termination(ahc, sd, adapter_control, sxfrctl1)\nstruct ahc_softc *ahc;\nstruct seeprom_descriptor *sd;\nu_int adapter_control;\nu_int *sxfrctl1;\n{\n\tu_int8_t brddat;\n\n\tbrddat = 0;\n\n\t/*\n\t * Update the settings in sxfrctl1 to match the\n\t * termination settings \n\t */\n\t*sxfrctl1 = 0;\n\n\t/*\n\t * SEECS must be on for the GALS to latch\n\t * the data properly.  Be sure to leave MS\n\t * on or we will release the seeprom.\n\t */\n\tSEEPROM_OUTB(sd, sd->sd_MS | sd->sd_CS);\n\tif ((adapter_control & CFAUTOTERM) != 0\n\t\t || (ahc->features & AHC_NEW_TERMCTL) != 0) {\n\t\tint internal50_present;\n\t\tint internal68_present;\n\t\tint externalcable_present;\n\t\tint eeprom_present;\n\t\tint enableSEC_low;\n\t\tint enableSEC_high;\n\t\tint enablePRI_low;\n\t\tint enablePRI_high;\n\n\t\tenableSEC_low = 0;\n\t\tenableSEC_high = 0;\n\t\tenablePRI_low = 0;\n\t\tenablePRI_high = 0;\n\t\tif ((ahc->features & AHC_NEW_TERMCTL) != 0) {\n\t\t\tahc_new_term_detect(ahc, &enableSEC_low,\n\t\t\t\t\t    &enableSEC_high,\n\t\t\t\t\t    &enablePRI_low,\n\t\t\t\t\t    &enablePRI_high,\n\t\t\t\t\t    &eeprom_present);\n\t\t\tif ((adapter_control & CFSEAUTOTERM) == 0) {\n\t\t\t\tif (bootverbose)\n\t\t\t\t\tprintf(\"%s: Manual SE Termination\\n\",\n\t\t\t\t\t\t\t ahc_name(ahc));\n\t\t\t\tenableSEC_low = (adapter_control & CFSTERM);\n\t\t\t\tenableSEC_high = (adapter_control & CFWSTERM);\n\t\t\t}\n\t\t\tif ((adapter_control & CFAUTOTERM) == 0) {\n\t\t\t\tif (bootverbose)\n\t\t\t\t\tprintf(\"%s: Manual LVD Termination\\n\",\n\t\t\t\t\t       ahc_name(ahc));\n\t\t\t\tenablePRI_low = enablePRI_high =\n\t\t\t\t\t(adapter_control & CFLVDSTERM);\n\t\t\t}\n\t\t\t/* Make the table calculations below happy */\n\t\t\tinternal50_present = 0;\n\t\t\tinternal68_present = 1;\n\t\t\texternalcable_present = 1;\n\t\t} else if ((ahc->features & AHC_SPIOCAP) != 0) {\n\t\t\taic785X_cable_detect(ahc, &internal50_present,\n\t\t\t\t\t     &externalcable_present,\n\t\t\t\t\t     &eeprom_present);\n\t\t} else {\n\t\t\taic787X_cable_detect(ahc, &internal50_present,\n\t\t\t\t\t     &internal68_present,\n\t\t\t\t\t     &externalcable_present,\n\t\t\t\t\t     &eeprom_present);\n\t\t}\n\n\t\tif ((ahc->features & AHC_WIDE) == 0)\n\t\t\tinternal68_present = 0;\n\n\t\tif (bootverbose) {\n\t\t\tif ((ahc->features & AHC_ULTRA2) == 0) {\n\t\t\t\tprintf(\"%s: internal 50 cable %s present, \"\n\t\t\t\t       \"internal 68 cable %s present\\n\",\n\t\t\t\t       ahc_name(ahc),\n\t\t\t\t       internal50_present ? \"is\":\"not\",\n\t\t\t\t       internal68_present ? \"is\":\"not\");\n\n\t\t\t\tprintf(\"%s: external cable %s present\\n\",\n\t\t\t\t       ahc_name(ahc),\n\t\t\t\t       externalcable_present ? \"is\":\"not\");\n\t\t\t}\n\t\t\tprintf(\"%s: BIOS eeprom %s present\\n\",\n\t\t\t       ahc_name(ahc), eeprom_present ? \"is\" : \"not\");\n\t\t}\n\n\t\tif ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0) {\n\t\t\t/*\n\t\t\t * The 50 pin connector is a separate bus,\n\t\t\t * so force it to always be terminated.\n\t\t\t * In the future, perform current sensing\n\t\t\t * to determine if we are in the middle of\n\t\t\t * a properly terminated bus.\n\t\t\t */\n\t\t\tinternal50_present = 0;\n\t\t}\n\n\t\t/*\n\t\t * Now set the termination based on what\n\t\t * we found.\n\t\t * Flash Enable = BRDDAT7\n\t\t * Secondary High Term Enable = BRDDAT6\n\t\t * Secondary Low Term Enable = BRDDAT5 (7890)\n\t\t * Primary High Term Enable = BRDDAT4 (7890)\n\t\t */\n\t\tif ((ahc->features & AHC_ULTRA2) == 0\n\t\t    && (internal50_present != 0)\n\t\t    && (internal68_present != 0)\n\t\t    && (externalcable_present != 0)) {\n\t\t\tprintf(\"%s: Illegal cable configuration!!. \"\n\t\t\t       \"Only two connectors on the \"\n\t\t\t       \"adapter may be used at a \"\n\t\t\t       \"time!\\n\", ahc_name(ahc));\n\t\t}\n\n\t\tif ((ahc->features & AHC_WIDE) != 0\n\t\t\t && ((externalcable_present == 0)\n\t\t\t\t  || (internal68_present == 0)\n\t\t\t\t  || (enableSEC_high != 0))) {\n\t\t\tbrddat |= BRDDAT6;\n\t\t\tif (bootverbose) {\n\t\t\t\tif ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0)\n\t\t\t\t\tprintf(\"%s: 68 pin termination \"\n\t\t\t\t\t       \"Enabled\\n\", ahc_name(ahc));\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%s: %sHigh byte termination \"\n\t\t\t\t\t       \"Enabled\\n\", ahc_name(ahc),\n\t\t\t\t\t       enableSEC_high ? \"Secondary \"\n\t\t\t\t\t       : \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (((internal50_present ? 1 : 0)\n\t\t\t  + (internal68_present ? 1 : 0)\n\t\t\t  + (externalcable_present ? 1 : 0)) <= 1\n\t\t\t || (enableSEC_low != 0)) {\n\t\t\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\t\t\tbrddat |= BRDDAT5;\n\t\t\telse\n\t\t\t\t*sxfrctl1 |= STPWEN;\n\t\t\tif (bootverbose) {\n\t\t\t\tif ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0)\n\t\t\t\t\tprintf(\"%s: 50 pin termination \"\n\t\t\t\t\t       \"Enabled\\n\", ahc_name(ahc));\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%s: %sLow byte termination \"\n\t\t\t\t\t       \"Enabled\\n\", ahc_name(ahc),\n\t\t\t\t\t       enableSEC_low ? \"Secondary \"\n\t\t\t\t\t       : \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (enablePRI_low != 0) {\n\t\t\t*sxfrctl1 |= STPWEN;\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: Primary Low Byte termination \"\n\t\t\t\t       \"Enabled\\n\", ahc_name(ahc));\n\t\t}\n\n\t\t/*\n\t\t * Setup STPWEN before setting up the rest of\n\t\t * the termination per the tech note on the U160 cards.\n\t\t */\n\t\tahc_outb(ahc, SXFRCTL1, *sxfrctl1);\n\n\t\tif (enablePRI_high != 0) {\n\t\t\tbrddat |= BRDDAT4;\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: Primary High Byte \"\n\t\t\t\t       \"termination Enabled\\n\",\n\t\t\t\t       ahc_name(ahc));\n\t\t}\n\n\t\twrite_brdctl(ahc, brddat);\n\n\t} else {\n\t\tif ((adapter_control & CFSTERM) != 0) {\n\t\t\t*sxfrctl1 |= STPWEN;\n\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: %sLow byte termination Enabled\\n\",\n\t\t\t\t       ahc_name(ahc),\n\t\t\t\t       (ahc->features & AHC_ULTRA2)\n\t\t\t\t       ? \"Primary \" : \"\");\n\t\t}\n\n\t\tif ((adapter_control & CFWSTERM) != 0) {\n\t\t\tbrddat |= BRDDAT6;\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: %sHigh byte termination Enabled\\n\",\n\t\t\t\t       ahc_name(ahc),\n\t\t\t\t       (ahc->features & AHC_ULTRA2)\n\t\t\t\t       ? \"Secondary \" : \"\");\n\t\t}\n\n\t\t/*\n\t\t * Setup STPWEN before setting up the rest of\n\t\t * the termination per the tech note on the U160 cards.\n\t\t */\n\t\tahc_outb(ahc, SXFRCTL1, *sxfrctl1);\n\n\t\twrite_brdctl(ahc, brddat);\n\t}\n\tSEEPROM_OUTB(sd, sd->sd_MS); /* Clear CS */\n}"
  },
  {
    "function_name": "check_extport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
    "lines": "712-918",
    "snippet": "static void\ncheck_extport(ahc, sxfrctl1)\nstruct ahc_softc *ahc;\nu_int *sxfrctl1;\n{\n\tstruct     seeprom_descriptor sd;\n\tstruct     seeprom_config sc;\n\tu_int   scsi_conf;\n\tu_int   adapter_control;\n\tint     have_seeprom;\n\tint     have_autoterm;\n\n\tsd.sd_tag = ahc->sc_iot;\n\tsd.sd_bsh = ahc->sc_ioh;\n\tsd.sd_control_offset = SEECTL;      \n\tsd.sd_status_offset = SEECTL;    \n\tsd.sd_dataout_offset = SEECTL;      \n\n\t/*\n\t * For some multi-channel devices, the c46 is simply too\n\t * small to work.  For the other controller types, we can\n\t * get our information from either SEEPROM type.  Set the\n\t * type to start our probe with accordingly.\n\t */\n\tif (ahc->flags & AHC_LARGE_SEEPROM)\n\t\tsd.sd_chip = C56_66;\n\telse\n\t\tsd.sd_chip = C46;\n\n\tsd.sd_MS = SEEMS;\n\tsd.sd_RDY = SEERDY;\n\tsd.sd_CS = SEECS;\n\tsd.sd_CK = SEECK;\n\tsd.sd_DO = SEEDO;\n\tsd.sd_DI = SEEDI;\n\n\thave_seeprom = acquire_seeprom(ahc, &sd);\n\tif (have_seeprom) {\n\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s: Reading SEEPROM...\", ahc_name(ahc));\n\n\t\tfor (;;) {\n\t\t\tbus_size_t start_addr;\n\n\t\t\tstart_addr = 32 * (ahc->channel - 'A');\n\n\t\t\thave_seeprom = read_seeprom(&sd,\n\t\t\t\t\t\t    (u_int16_t *)&sc,\n\t\t\t\t\t\t    start_addr,\n\t\t\t\t\t\t    sizeof(sc)/2);\n\n\t\t\tif (have_seeprom) {\n\t\t\t\t/* Check checksum */\n\t\t\t\tint i;\n\t\t\t\tint maxaddr;\n\t\t\t\tu_int32_t checksum;\n\t\t\t\tu_int16_t *scarray;\n\n\t\t\t\tmaxaddr = (sizeof(sc)/2) - 1;\n\t\t\t\tchecksum = 0;\n\t\t\t\tscarray = (u_int16_t *)&sc;\n\n\t\t\t\tfor (i = 0; i < maxaddr; i++)\n\t\t\t\t\tchecksum = checksum + scarray[i];\n\t\t\t\tif (checksum == 0\n\t\t\t\t    || (checksum & 0xFFFF) != sc.checksum) {\n\t\t\t\t\tif (bootverbose && sd.sd_chip == C56_66)\n\t\t\t\t\t\tprintf (\"checksum error\\n\");\n\t\t\t\t\thave_seeprom = 0;\n\t\t\t\t} else {\n\t\t\t\t\tif (bootverbose)\n\t\t\t\t\t\tprintf(\"done.\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sd.sd_chip == C56_66)\n\t\t\t\tbreak;\n\t\t\tsd.sd_chip = C56_66;\n\t\t}\n\t}\n\n\tif (!have_seeprom) {\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s: No SEEPROM available.\\n\", ahc_name(ahc));\n\t\tahc->flags |= AHC_USEDEFAULTS;\n\t} else {\n\t\t/*\n\t\t * Put the data we've collected down into SRAM\n\t\t * where ahc_init will find it.\n\t\t */\n\t\tint i;\n\t\tint max_targ = sc.max_targets & CFMAXTARG;\n\t\tu_int16_t discenable;\n\t\tu_int16_t ultraenb;\n\n\t\tdiscenable = 0;\n\t\tultraenb = 0;\n\t\tif ((sc.adapter_control & CFULTRAEN) != 0) {\n\t\t\t/*\n\t\t\t * Determine if this adapter has a \"newstyle\"\n\t\t\t * SEEPROM format.\n\t\t\t */\n\t\t\tfor (i = 0; i < max_targ; i++) {\n\t\t\t\tif ((sc.device_flags[i] & CFSYNCHISULTRA) != 0) {\n\t\t\t\t\tahc->flags |= AHC_NEWEEPROM_FMT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < max_targ; i++) {\n\t\t\tu_int     scsirate;\n\t\t\tu_int16_t target_mask;\n\n\t\t\ttarget_mask = 0x01 << i;\n\t\t\tif (sc.device_flags[i] & CFDISC)\n\t\t\t\tdiscenable |= target_mask;\n\t\t\tif ((ahc->flags & AHC_NEWEEPROM_FMT) != 0) {\n\t\t\t\tif ((sc.device_flags[i] & CFSYNCHISULTRA) != 0)\n\t\t\t\t\tultraenb |= target_mask;\n\t\t\t} else if ((sc.adapter_control & CFULTRAEN) != 0) {\n\t\t\t\tultraenb |= target_mask;\n\t\t\t}\n\t\t\tif ((sc.device_flags[i] & CFXFER) == 0x04\n\t\t\t\t && (ultraenb & target_mask) != 0) {\n\t\t\t\t/* Treat 10MHz as a non-ultra speed */\n\t\t\t\tsc.device_flags[i] &= ~CFXFER;\n\t\t\t\tultraenb &= ~target_mask;\n\t\t\t}\n\t\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\t\tu_int offset;\n\n\t\t\t\tif (sc.device_flags[i] & CFSYNCH)\n\t\t\t\t\toffset = MAX_OFFSET_ULTRA2;\n\t\t\t\telse\n\t\t\t\t\toffset = 0;\n\t\t\t\tahc_outb(ahc, TARG_OFFSET + i, offset);\n\n\t\t\t\tscsirate = (sc.device_flags[i] & CFXFER)\n\t\t\t\t| ((ultraenb & target_mask) ? 0x8 : 0x0);\n\t\t\t\tif (sc.device_flags[i] & CFWIDEB)\n\t\t\t\t\tscsirate |= WIDEXFER;\n\t\t\t} else {\n\t\t\t\tscsirate = (sc.device_flags[i] & CFXFER) << 4;\n\t\t\t\tif (sc.device_flags[i] & CFSYNCH)\n\t\t\t\t\tscsirate |= SOFS;\n\t\t\t\tif (sc.device_flags[i] & CFWIDEB)\n\t\t\t\t\tscsirate |= WIDEXFER;\n\t\t\t}\n\t\t\tahc_outb(ahc, TARG_SCSIRATE + i, scsirate);\n\t\t}\n\t\tahc->our_id = sc.brtime_id & CFSCSIID;\n\n\t\tscsi_conf = (ahc->our_id & 0x7);\n\t\tif (sc.adapter_control & CFSPARITY)\n\t\t\tscsi_conf |= ENSPCHK;\n\t\tif (sc.adapter_control & CFRESETB)\n\t\t\tscsi_conf |= RESET_SCSI;\n\n\t\tif (sc.bios_control & CFEXTEND)\n\t\t\tahc->flags |= AHC_EXTENDED_TRANS_A;\n\t\tif (ahc->features & AHC_ULTRA\n\t\t\t && (ahc->flags & AHC_NEWEEPROM_FMT) == 0) {\n\t\t\t/* Should we enable Ultra mode? */\n\t\t\tif (!(sc.adapter_control & CFULTRAEN))\n\t\t\t\t/* Treat us as a non-ultra card */\n\t\t\t\tultraenb = 0;\n\t\t}\n\t\t/* Set SCSICONF info */\n\t\tahc_outb(ahc, SCSICONF, scsi_conf);\n\t\tahc_outb(ahc, DISC_DSB, ~(discenable & 0xff));\n\t\tahc_outb(ahc, DISC_DSB + 1, ~((discenable >> 8) & 0xff));\n\t\tahc_outb(ahc, ULTRA_ENB, ultraenb & 0xff);\n\t\tahc_outb(ahc, ULTRA_ENB + 1, (ultraenb >> 8) & 0xff);\n\t}\n\n\t/*\n\t * Cards that have the external logic necessary to talk to\n\t * a SEEPROM, are almost certain to have the remaining logic\n\t * necessary for auto-termination control.  This assumption\n\t * hasn't failed yet...\n\t */\n\thave_autoterm = have_seeprom;\n\tif (have_seeprom)\n\t\tadapter_control = sc.adapter_control;\n\telse\n\t\tadapter_control = CFAUTOTERM;\n\n\t/*\n\t * Some low-cost chips have SEEPROM and auto-term control built\n\t * in, instead of using a GAL.  They can tell us directly\n\t * if the termination logic is enabled.\n\t */\n\tif ((ahc->features & AHC_SPIOCAP) != 0) {\n\t\tif ((ahc_inb(ahc, SPIOCAP) & SSPIOCPS) != 0)\n\t\t\thave_autoterm = 1;\n\t\telse\n\t\t\thave_autoterm = 0;\n\t}\n\n\tif (have_autoterm)\n\t\tconfigure_termination(ahc, &sd, adapter_control, sxfrctl1);\n\n\trelease_seeprom(&sd);\n}",
    "includes": [
      "#include <dev/ic/smc93cx6var.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define bootverbose\t0",
      "#define bootverbose\t1"
    ],
    "globals_used": [
      "static void check_extport",
      "static void configure_termination",
      "static int acquire_seeprom",
      "static void release_seeprom"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_seeprom",
          "args": [
            "&sd"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "release_seeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
          "lines": "1310-1316",
          "snippet": "static void\nrelease_seeprom(sd)\nstruct seeprom_descriptor *sd;\n{\n\t/* Release access to the memory port and the serial EEPROM. */\n\tSEEPROM_OUTB(sd, 0);\n}",
          "includes": [
            "#include <dev/ic/smc93cx6var.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_seeprom"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void release_seeprom;\n\nstatic void\nrelease_seeprom(sd)\nstruct seeprom_descriptor *sd;\n{\n\t/* Release access to the memory port and the serial EEPROM. */\n\tSEEPROM_OUTB(sd, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "configure_termination",
          "args": [
            "ahc",
            "&sd",
            "adapter_control",
            "sxfrctl1"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "configure_termination",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
          "lines": "920-1130",
          "snippet": "static void\nconfigure_termination(ahc, sd, adapter_control, sxfrctl1)\nstruct ahc_softc *ahc;\nstruct seeprom_descriptor *sd;\nu_int adapter_control;\nu_int *sxfrctl1;\n{\n\tu_int8_t brddat;\n\n\tbrddat = 0;\n\n\t/*\n\t * Update the settings in sxfrctl1 to match the\n\t * termination settings \n\t */\n\t*sxfrctl1 = 0;\n\n\t/*\n\t * SEECS must be on for the GALS to latch\n\t * the data properly.  Be sure to leave MS\n\t * on or we will release the seeprom.\n\t */\n\tSEEPROM_OUTB(sd, sd->sd_MS | sd->sd_CS);\n\tif ((adapter_control & CFAUTOTERM) != 0\n\t\t || (ahc->features & AHC_NEW_TERMCTL) != 0) {\n\t\tint internal50_present;\n\t\tint internal68_present;\n\t\tint externalcable_present;\n\t\tint eeprom_present;\n\t\tint enableSEC_low;\n\t\tint enableSEC_high;\n\t\tint enablePRI_low;\n\t\tint enablePRI_high;\n\n\t\tenableSEC_low = 0;\n\t\tenableSEC_high = 0;\n\t\tenablePRI_low = 0;\n\t\tenablePRI_high = 0;\n\t\tif ((ahc->features & AHC_NEW_TERMCTL) != 0) {\n\t\t\tahc_new_term_detect(ahc, &enableSEC_low,\n\t\t\t\t\t    &enableSEC_high,\n\t\t\t\t\t    &enablePRI_low,\n\t\t\t\t\t    &enablePRI_high,\n\t\t\t\t\t    &eeprom_present);\n\t\t\tif ((adapter_control & CFSEAUTOTERM) == 0) {\n\t\t\t\tif (bootverbose)\n\t\t\t\t\tprintf(\"%s: Manual SE Termination\\n\",\n\t\t\t\t\t\t\t ahc_name(ahc));\n\t\t\t\tenableSEC_low = (adapter_control & CFSTERM);\n\t\t\t\tenableSEC_high = (adapter_control & CFWSTERM);\n\t\t\t}\n\t\t\tif ((adapter_control & CFAUTOTERM) == 0) {\n\t\t\t\tif (bootverbose)\n\t\t\t\t\tprintf(\"%s: Manual LVD Termination\\n\",\n\t\t\t\t\t       ahc_name(ahc));\n\t\t\t\tenablePRI_low = enablePRI_high =\n\t\t\t\t\t(adapter_control & CFLVDSTERM);\n\t\t\t}\n\t\t\t/* Make the table calculations below happy */\n\t\t\tinternal50_present = 0;\n\t\t\tinternal68_present = 1;\n\t\t\texternalcable_present = 1;\n\t\t} else if ((ahc->features & AHC_SPIOCAP) != 0) {\n\t\t\taic785X_cable_detect(ahc, &internal50_present,\n\t\t\t\t\t     &externalcable_present,\n\t\t\t\t\t     &eeprom_present);\n\t\t} else {\n\t\t\taic787X_cable_detect(ahc, &internal50_present,\n\t\t\t\t\t     &internal68_present,\n\t\t\t\t\t     &externalcable_present,\n\t\t\t\t\t     &eeprom_present);\n\t\t}\n\n\t\tif ((ahc->features & AHC_WIDE) == 0)\n\t\t\tinternal68_present = 0;\n\n\t\tif (bootverbose) {\n\t\t\tif ((ahc->features & AHC_ULTRA2) == 0) {\n\t\t\t\tprintf(\"%s: internal 50 cable %s present, \"\n\t\t\t\t       \"internal 68 cable %s present\\n\",\n\t\t\t\t       ahc_name(ahc),\n\t\t\t\t       internal50_present ? \"is\":\"not\",\n\t\t\t\t       internal68_present ? \"is\":\"not\");\n\n\t\t\t\tprintf(\"%s: external cable %s present\\n\",\n\t\t\t\t       ahc_name(ahc),\n\t\t\t\t       externalcable_present ? \"is\":\"not\");\n\t\t\t}\n\t\t\tprintf(\"%s: BIOS eeprom %s present\\n\",\n\t\t\t       ahc_name(ahc), eeprom_present ? \"is\" : \"not\");\n\t\t}\n\n\t\tif ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0) {\n\t\t\t/*\n\t\t\t * The 50 pin connector is a separate bus,\n\t\t\t * so force it to always be terminated.\n\t\t\t * In the future, perform current sensing\n\t\t\t * to determine if we are in the middle of\n\t\t\t * a properly terminated bus.\n\t\t\t */\n\t\t\tinternal50_present = 0;\n\t\t}\n\n\t\t/*\n\t\t * Now set the termination based on what\n\t\t * we found.\n\t\t * Flash Enable = BRDDAT7\n\t\t * Secondary High Term Enable = BRDDAT6\n\t\t * Secondary Low Term Enable = BRDDAT5 (7890)\n\t\t * Primary High Term Enable = BRDDAT4 (7890)\n\t\t */\n\t\tif ((ahc->features & AHC_ULTRA2) == 0\n\t\t    && (internal50_present != 0)\n\t\t    && (internal68_present != 0)\n\t\t    && (externalcable_present != 0)) {\n\t\t\tprintf(\"%s: Illegal cable configuration!!. \"\n\t\t\t       \"Only two connectors on the \"\n\t\t\t       \"adapter may be used at a \"\n\t\t\t       \"time!\\n\", ahc_name(ahc));\n\t\t}\n\n\t\tif ((ahc->features & AHC_WIDE) != 0\n\t\t\t && ((externalcable_present == 0)\n\t\t\t\t  || (internal68_present == 0)\n\t\t\t\t  || (enableSEC_high != 0))) {\n\t\t\tbrddat |= BRDDAT6;\n\t\t\tif (bootverbose) {\n\t\t\t\tif ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0)\n\t\t\t\t\tprintf(\"%s: 68 pin termination \"\n\t\t\t\t\t       \"Enabled\\n\", ahc_name(ahc));\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%s: %sHigh byte termination \"\n\t\t\t\t\t       \"Enabled\\n\", ahc_name(ahc),\n\t\t\t\t\t       enableSEC_high ? \"Secondary \"\n\t\t\t\t\t       : \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (((internal50_present ? 1 : 0)\n\t\t\t  + (internal68_present ? 1 : 0)\n\t\t\t  + (externalcable_present ? 1 : 0)) <= 1\n\t\t\t || (enableSEC_low != 0)) {\n\t\t\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\t\t\tbrddat |= BRDDAT5;\n\t\t\telse\n\t\t\t\t*sxfrctl1 |= STPWEN;\n\t\t\tif (bootverbose) {\n\t\t\t\tif ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0)\n\t\t\t\t\tprintf(\"%s: 50 pin termination \"\n\t\t\t\t\t       \"Enabled\\n\", ahc_name(ahc));\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%s: %sLow byte termination \"\n\t\t\t\t\t       \"Enabled\\n\", ahc_name(ahc),\n\t\t\t\t\t       enableSEC_low ? \"Secondary \"\n\t\t\t\t\t       : \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (enablePRI_low != 0) {\n\t\t\t*sxfrctl1 |= STPWEN;\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: Primary Low Byte termination \"\n\t\t\t\t       \"Enabled\\n\", ahc_name(ahc));\n\t\t}\n\n\t\t/*\n\t\t * Setup STPWEN before setting up the rest of\n\t\t * the termination per the tech note on the U160 cards.\n\t\t */\n\t\tahc_outb(ahc, SXFRCTL1, *sxfrctl1);\n\n\t\tif (enablePRI_high != 0) {\n\t\t\tbrddat |= BRDDAT4;\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: Primary High Byte \"\n\t\t\t\t       \"termination Enabled\\n\",\n\t\t\t\t       ahc_name(ahc));\n\t\t}\n\n\t\twrite_brdctl(ahc, brddat);\n\n\t} else {\n\t\tif ((adapter_control & CFSTERM) != 0) {\n\t\t\t*sxfrctl1 |= STPWEN;\n\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: %sLow byte termination Enabled\\n\",\n\t\t\t\t       ahc_name(ahc),\n\t\t\t\t       (ahc->features & AHC_ULTRA2)\n\t\t\t\t       ? \"Primary \" : \"\");\n\t\t}\n\n\t\tif ((adapter_control & CFWSTERM) != 0) {\n\t\t\tbrddat |= BRDDAT6;\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: %sHigh byte termination Enabled\\n\",\n\t\t\t\t       ahc_name(ahc),\n\t\t\t\t       (ahc->features & AHC_ULTRA2)\n\t\t\t\t       ? \"Secondary \" : \"\");\n\t\t}\n\n\t\t/*\n\t\t * Setup STPWEN before setting up the rest of\n\t\t * the termination per the tech note on the U160 cards.\n\t\t */\n\t\tahc_outb(ahc, SXFRCTL1, *sxfrctl1);\n\n\t\twrite_brdctl(ahc, brddat);\n\t}\n\tSEEPROM_OUTB(sd, sd->sd_MS); /* Clear CS */\n}",
          "includes": [
            "#include <dev/ic/smc93cx6var.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define bootverbose\t0",
            "#define bootverbose\t1"
          ],
          "globals_used": [
            "static void configure_termination",
            "static void ahc_new_term_detect",
            "static void aic787X_cable_detect",
            "static void aic785X_cable_detect",
            "static void write_brdctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define bootverbose\t0\n#define bootverbose\t1\n\nstatic void configure_termination;\nstatic void ahc_new_term_detect;\nstatic void aic787X_cable_detect;\nstatic void aic785X_cable_detect;\nstatic void write_brdctl;\n\nstatic void\nconfigure_termination(ahc, sd, adapter_control, sxfrctl1)\nstruct ahc_softc *ahc;\nstruct seeprom_descriptor *sd;\nu_int adapter_control;\nu_int *sxfrctl1;\n{\n\tu_int8_t brddat;\n\n\tbrddat = 0;\n\n\t/*\n\t * Update the settings in sxfrctl1 to match the\n\t * termination settings \n\t */\n\t*sxfrctl1 = 0;\n\n\t/*\n\t * SEECS must be on for the GALS to latch\n\t * the data properly.  Be sure to leave MS\n\t * on or we will release the seeprom.\n\t */\n\tSEEPROM_OUTB(sd, sd->sd_MS | sd->sd_CS);\n\tif ((adapter_control & CFAUTOTERM) != 0\n\t\t || (ahc->features & AHC_NEW_TERMCTL) != 0) {\n\t\tint internal50_present;\n\t\tint internal68_present;\n\t\tint externalcable_present;\n\t\tint eeprom_present;\n\t\tint enableSEC_low;\n\t\tint enableSEC_high;\n\t\tint enablePRI_low;\n\t\tint enablePRI_high;\n\n\t\tenableSEC_low = 0;\n\t\tenableSEC_high = 0;\n\t\tenablePRI_low = 0;\n\t\tenablePRI_high = 0;\n\t\tif ((ahc->features & AHC_NEW_TERMCTL) != 0) {\n\t\t\tahc_new_term_detect(ahc, &enableSEC_low,\n\t\t\t\t\t    &enableSEC_high,\n\t\t\t\t\t    &enablePRI_low,\n\t\t\t\t\t    &enablePRI_high,\n\t\t\t\t\t    &eeprom_present);\n\t\t\tif ((adapter_control & CFSEAUTOTERM) == 0) {\n\t\t\t\tif (bootverbose)\n\t\t\t\t\tprintf(\"%s: Manual SE Termination\\n\",\n\t\t\t\t\t\t\t ahc_name(ahc));\n\t\t\t\tenableSEC_low = (adapter_control & CFSTERM);\n\t\t\t\tenableSEC_high = (adapter_control & CFWSTERM);\n\t\t\t}\n\t\t\tif ((adapter_control & CFAUTOTERM) == 0) {\n\t\t\t\tif (bootverbose)\n\t\t\t\t\tprintf(\"%s: Manual LVD Termination\\n\",\n\t\t\t\t\t       ahc_name(ahc));\n\t\t\t\tenablePRI_low = enablePRI_high =\n\t\t\t\t\t(adapter_control & CFLVDSTERM);\n\t\t\t}\n\t\t\t/* Make the table calculations below happy */\n\t\t\tinternal50_present = 0;\n\t\t\tinternal68_present = 1;\n\t\t\texternalcable_present = 1;\n\t\t} else if ((ahc->features & AHC_SPIOCAP) != 0) {\n\t\t\taic785X_cable_detect(ahc, &internal50_present,\n\t\t\t\t\t     &externalcable_present,\n\t\t\t\t\t     &eeprom_present);\n\t\t} else {\n\t\t\taic787X_cable_detect(ahc, &internal50_present,\n\t\t\t\t\t     &internal68_present,\n\t\t\t\t\t     &externalcable_present,\n\t\t\t\t\t     &eeprom_present);\n\t\t}\n\n\t\tif ((ahc->features & AHC_WIDE) == 0)\n\t\t\tinternal68_present = 0;\n\n\t\tif (bootverbose) {\n\t\t\tif ((ahc->features & AHC_ULTRA2) == 0) {\n\t\t\t\tprintf(\"%s: internal 50 cable %s present, \"\n\t\t\t\t       \"internal 68 cable %s present\\n\",\n\t\t\t\t       ahc_name(ahc),\n\t\t\t\t       internal50_present ? \"is\":\"not\",\n\t\t\t\t       internal68_present ? \"is\":\"not\");\n\n\t\t\t\tprintf(\"%s: external cable %s present\\n\",\n\t\t\t\t       ahc_name(ahc),\n\t\t\t\t       externalcable_present ? \"is\":\"not\");\n\t\t\t}\n\t\t\tprintf(\"%s: BIOS eeprom %s present\\n\",\n\t\t\t       ahc_name(ahc), eeprom_present ? \"is\" : \"not\");\n\t\t}\n\n\t\tif ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0) {\n\t\t\t/*\n\t\t\t * The 50 pin connector is a separate bus,\n\t\t\t * so force it to always be terminated.\n\t\t\t * In the future, perform current sensing\n\t\t\t * to determine if we are in the middle of\n\t\t\t * a properly terminated bus.\n\t\t\t */\n\t\t\tinternal50_present = 0;\n\t\t}\n\n\t\t/*\n\t\t * Now set the termination based on what\n\t\t * we found.\n\t\t * Flash Enable = BRDDAT7\n\t\t * Secondary High Term Enable = BRDDAT6\n\t\t * Secondary Low Term Enable = BRDDAT5 (7890)\n\t\t * Primary High Term Enable = BRDDAT4 (7890)\n\t\t */\n\t\tif ((ahc->features & AHC_ULTRA2) == 0\n\t\t    && (internal50_present != 0)\n\t\t    && (internal68_present != 0)\n\t\t    && (externalcable_present != 0)) {\n\t\t\tprintf(\"%s: Illegal cable configuration!!. \"\n\t\t\t       \"Only two connectors on the \"\n\t\t\t       \"adapter may be used at a \"\n\t\t\t       \"time!\\n\", ahc_name(ahc));\n\t\t}\n\n\t\tif ((ahc->features & AHC_WIDE) != 0\n\t\t\t && ((externalcable_present == 0)\n\t\t\t\t  || (internal68_present == 0)\n\t\t\t\t  || (enableSEC_high != 0))) {\n\t\t\tbrddat |= BRDDAT6;\n\t\t\tif (bootverbose) {\n\t\t\t\tif ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0)\n\t\t\t\t\tprintf(\"%s: 68 pin termination \"\n\t\t\t\t\t       \"Enabled\\n\", ahc_name(ahc));\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%s: %sHigh byte termination \"\n\t\t\t\t\t       \"Enabled\\n\", ahc_name(ahc),\n\t\t\t\t\t       enableSEC_high ? \"Secondary \"\n\t\t\t\t\t       : \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (((internal50_present ? 1 : 0)\n\t\t\t  + (internal68_present ? 1 : 0)\n\t\t\t  + (externalcable_present ? 1 : 0)) <= 1\n\t\t\t || (enableSEC_low != 0)) {\n\t\t\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\t\t\tbrddat |= BRDDAT5;\n\t\t\telse\n\t\t\t\t*sxfrctl1 |= STPWEN;\n\t\t\tif (bootverbose) {\n\t\t\t\tif ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0)\n\t\t\t\t\tprintf(\"%s: 50 pin termination \"\n\t\t\t\t\t       \"Enabled\\n\", ahc_name(ahc));\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%s: %sLow byte termination \"\n\t\t\t\t\t       \"Enabled\\n\", ahc_name(ahc),\n\t\t\t\t\t       enableSEC_low ? \"Secondary \"\n\t\t\t\t\t       : \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (enablePRI_low != 0) {\n\t\t\t*sxfrctl1 |= STPWEN;\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: Primary Low Byte termination \"\n\t\t\t\t       \"Enabled\\n\", ahc_name(ahc));\n\t\t}\n\n\t\t/*\n\t\t * Setup STPWEN before setting up the rest of\n\t\t * the termination per the tech note on the U160 cards.\n\t\t */\n\t\tahc_outb(ahc, SXFRCTL1, *sxfrctl1);\n\n\t\tif (enablePRI_high != 0) {\n\t\t\tbrddat |= BRDDAT4;\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: Primary High Byte \"\n\t\t\t\t       \"termination Enabled\\n\",\n\t\t\t\t       ahc_name(ahc));\n\t\t}\n\n\t\twrite_brdctl(ahc, brddat);\n\n\t} else {\n\t\tif ((adapter_control & CFSTERM) != 0) {\n\t\t\t*sxfrctl1 |= STPWEN;\n\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: %sLow byte termination Enabled\\n\",\n\t\t\t\t       ahc_name(ahc),\n\t\t\t\t       (ahc->features & AHC_ULTRA2)\n\t\t\t\t       ? \"Primary \" : \"\");\n\t\t}\n\n\t\tif ((adapter_control & CFWSTERM) != 0) {\n\t\t\tbrddat |= BRDDAT6;\n\t\t\tif (bootverbose)\n\t\t\t\tprintf(\"%s: %sHigh byte termination Enabled\\n\",\n\t\t\t\t       ahc_name(ahc),\n\t\t\t\t       (ahc->features & AHC_ULTRA2)\n\t\t\t\t       ? \"Secondary \" : \"\");\n\t\t}\n\n\t\t/*\n\t\t * Setup STPWEN before setting up the rest of\n\t\t * the termination per the tech note on the U160 cards.\n\t\t */\n\t\tahc_outb(ahc, SXFRCTL1, *sxfrctl1);\n\n\t\twrite_brdctl(ahc, brddat);\n\t}\n\tSEEPROM_OUTB(sd, sd->sd_MS); /* Clear CS */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SPIOCAP"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "ULTRA_ENB + 1",
            "(ultraenb >> 8) & 0xff"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "ULTRA_ENB",
            "ultraenb & 0xff"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "DISC_DSB + 1",
            "~((discenable >> 8) & 0xff)"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "DISC_DSB",
            "~(discenable & 0xff)"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSICONF",
            "scsi_conf"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "TARG_SCSIRATE + i",
            "scsirate"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "TARG_OFFSET + i",
            "offset"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: No SEEPROM available.\\n\"",
            "ahc_name(ahc)"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seeprom",
          "args": [
            "&sd",
            "(u_int16_t *)&sc",
            "start_addr",
            "sizeof(sc)/2"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "read_seeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc93cx6.c",
          "lines": "93-180",
          "snippet": "int\nread_seeprom(sd, buf, start_addr, count)\n\tstruct seeprom_descriptor *sd;\n\tu_int16_t *buf;\n\tbus_size_t start_addr;\n\tbus_size_t count;\n{\n\tint i = 0;\n\tu_int k = 0;\n\tu_int16_t v;\n\tu_int8_t temp;\n\n\t/*\n\t * Read the requested registers of the seeprom.  The loop\n\t * will range from 0 to count-1.\n\t */\n\tfor (k = start_addr; k < count + start_addr; k++) {\n\t\t/* Send chip select for one clock cycle. */\n\t\ttemp = sd->sd_MS ^ sd->sd_CS;\n\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\n\t\t/*\n\t\t * Now we're ready to send the read command followed by the\n\t\t * address of the 16-bit register we want to read.\n\t\t */\n\t\tfor (i = 0; i < seeprom_read.len; i++) {\n\t\t\tif (seeprom_read.bits[i] != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t\tSEEPROM_OUTB(sd, temp);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tif (seeprom_read.bits[i] != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t}\n\t\t/* Send the 6 or 8 bit address (MSB first, LSB last). */\n\t\tfor (i = (sd->sd_chip - 1); i >= 0; i--) {\n\t\t\tif ((k & (1 << i)) != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t\tSEEPROM_OUTB(sd, temp);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tif ((k & (1 << i)) != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t}\n\n\t\t/*\n\t\t * Now read the 16 bit register.  An initial 0 precedes the\n\t\t * register contents which begins with bit 15 (MSB) and ends\n\t\t * with bit 0 (LSB).  The initial 0 will be shifted off the\n\t\t * top of our word as we let the loop run from 0 to 16.\n\t\t */\n\t\tv = 0;\n\t\tfor (i = 16; i >= 0; i--) {\n\t\t\tSEEPROM_OUTB(sd, temp);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tv <<= 1;\n\t\t\tif (SEEPROM_DATA_INB(sd) & sd->sd_DI)\n\t\t\t\tv |= 1;\n\t\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t}\n\n\t\tbuf[k - start_addr] = v;\n\n\t\t/* Reset the chip select for the next command cycle. */\n\t\ttemp = sd->sd_MS;\n\t\tSEEPROM_OUTB(sd, temp);\n\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\tSEEPROM_OUTB(sd, temp);\n\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t}\n#ifdef AHC_DUMP_EEPROM\n\tprintf(\"\\nSerial EEPROM:\\n\\t\");\n\tfor (k = 0; k < count; k = k + 1) {\n\t\tif (((k % 8) == 0) && (k != 0)) {\n\t\t\tprintf (\"\\n\\t\");\n\t\t}\n\t\tprintf (\" 0x%x\", buf[k]);\n\t}\n\tprintf (\"\\n\");\n#endif\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/smc93cx6var.h>",
            "#include <dev/aic7xxx/93cx6.h>",
            "#include <machine/bus.h>",
            "#include <machine/bus_pio.h>",
            "#include <machine/bus_memio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct seeprom_cmd {\n  \tunsigned char len;\n \tunsigned char bits[3];\n} seeprom_read = {3, {1, 1, 0}};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/aic7xxx/93cx6.h>\n#include <machine/bus.h>\n#include <machine/bus_pio.h>\n#include <machine/bus_memio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic struct seeprom_cmd {\n  \tunsigned char len;\n \tunsigned char bits[3];\n} seeprom_read = {3, {1, 1, 0}};\n\nint\nread_seeprom(sd, buf, start_addr, count)\n\tstruct seeprom_descriptor *sd;\n\tu_int16_t *buf;\n\tbus_size_t start_addr;\n\tbus_size_t count;\n{\n\tint i = 0;\n\tu_int k = 0;\n\tu_int16_t v;\n\tu_int8_t temp;\n\n\t/*\n\t * Read the requested registers of the seeprom.  The loop\n\t * will range from 0 to count-1.\n\t */\n\tfor (k = start_addr; k < count + start_addr; k++) {\n\t\t/* Send chip select for one clock cycle. */\n\t\ttemp = sd->sd_MS ^ sd->sd_CS;\n\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\n\t\t/*\n\t\t * Now we're ready to send the read command followed by the\n\t\t * address of the 16-bit register we want to read.\n\t\t */\n\t\tfor (i = 0; i < seeprom_read.len; i++) {\n\t\t\tif (seeprom_read.bits[i] != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t\tSEEPROM_OUTB(sd, temp);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tif (seeprom_read.bits[i] != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t}\n\t\t/* Send the 6 or 8 bit address (MSB first, LSB last). */\n\t\tfor (i = (sd->sd_chip - 1); i >= 0; i--) {\n\t\t\tif ((k & (1 << i)) != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t\tSEEPROM_OUTB(sd, temp);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tif ((k & (1 << i)) != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t}\n\n\t\t/*\n\t\t * Now read the 16 bit register.  An initial 0 precedes the\n\t\t * register contents which begins with bit 15 (MSB) and ends\n\t\t * with bit 0 (LSB).  The initial 0 will be shifted off the\n\t\t * top of our word as we let the loop run from 0 to 16.\n\t\t */\n\t\tv = 0;\n\t\tfor (i = 16; i >= 0; i--) {\n\t\t\tSEEPROM_OUTB(sd, temp);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tv <<= 1;\n\t\t\tif (SEEPROM_DATA_INB(sd) & sd->sd_DI)\n\t\t\t\tv |= 1;\n\t\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t}\n\n\t\tbuf[k - start_addr] = v;\n\n\t\t/* Reset the chip select for the next command cycle. */\n\t\ttemp = sd->sd_MS;\n\t\tSEEPROM_OUTB(sd, temp);\n\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\tSEEPROM_OUTB(sd, temp);\n\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t}\n#ifdef AHC_DUMP_EEPROM\n\tprintf(\"\\nSerial EEPROM:\\n\\t\");\n\tfor (k = 0; k < count; k = k + 1) {\n\t\tif (((k % 8) == 0) && (k != 0)) {\n\t\t\tprintf (\"\\n\\t\");\n\t\t}\n\t\tprintf (\" 0x%x\", buf[k]);\n\t}\n\tprintf (\"\\n\");\n#endif\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acquire_seeprom",
          "args": [
            "ahc",
            "&sd"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "acquire_seeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
          "lines": "1280-1308",
          "snippet": "static int\nacquire_seeprom(ahc, sd)\nstruct ahc_softc *ahc;\nstruct seeprom_descriptor *sd;\n{\n\tint wait;\n\n\tif ((ahc->features & AHC_SPIOCAP) != 0\n\t\t && (ahc_inb(ahc, SPIOCAP) & SEEPROM) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Request access of the memory port.  When access is\n\t * granted, SEERDY will go high.  We use a 1 second\n\t * timeout which should be near 1 second more than\n\t * is needed.  Reason: after the chip reset, there\n\t * should be no contention.\n\t */\n\tSEEPROM_OUTB(sd, sd->sd_MS);\n\twait = 1000;  /* 1 second timeout in msec */\n\twhile (--wait && ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0)) {\n\t\tDELAY(1000);  /* delay 1 msec */\n\t}\n\tif ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0) {\n\t\tSEEPROM_OUTB(sd, 0); \n\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/smc93cx6var.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int acquire_seeprom"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int acquire_seeprom;\n\nstatic int\nacquire_seeprom(ahc, sd)\nstruct ahc_softc *ahc;\nstruct seeprom_descriptor *sd;\n{\n\tint wait;\n\n\tif ((ahc->features & AHC_SPIOCAP) != 0\n\t\t && (ahc_inb(ahc, SPIOCAP) & SEEPROM) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Request access of the memory port.  When access is\n\t * granted, SEERDY will go high.  We use a 1 second\n\t * timeout which should be near 1 second more than\n\t * is needed.  Reason: after the chip reset, there\n\t * should be no contention.\n\t */\n\tSEEPROM_OUTB(sd, sd->sd_MS);\n\twait = 1000;  /* 1 second timeout in msec */\n\twhile (--wait && ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0)) {\n\t\tDELAY(1000);  /* delay 1 msec */\n\t}\n\tif ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0) {\n\t\tSEEPROM_OUTB(sd, 0); \n\t\treturn (0);\n\t}\n\treturn (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define bootverbose\t0\n#define bootverbose\t1\n\nstatic void check_extport;\nstatic void configure_termination;\nstatic int acquire_seeprom;\nstatic void release_seeprom;\n\nstatic void\ncheck_extport(ahc, sxfrctl1)\nstruct ahc_softc *ahc;\nu_int *sxfrctl1;\n{\n\tstruct     seeprom_descriptor sd;\n\tstruct     seeprom_config sc;\n\tu_int   scsi_conf;\n\tu_int   adapter_control;\n\tint     have_seeprom;\n\tint     have_autoterm;\n\n\tsd.sd_tag = ahc->sc_iot;\n\tsd.sd_bsh = ahc->sc_ioh;\n\tsd.sd_control_offset = SEECTL;      \n\tsd.sd_status_offset = SEECTL;    \n\tsd.sd_dataout_offset = SEECTL;      \n\n\t/*\n\t * For some multi-channel devices, the c46 is simply too\n\t * small to work.  For the other controller types, we can\n\t * get our information from either SEEPROM type.  Set the\n\t * type to start our probe with accordingly.\n\t */\n\tif (ahc->flags & AHC_LARGE_SEEPROM)\n\t\tsd.sd_chip = C56_66;\n\telse\n\t\tsd.sd_chip = C46;\n\n\tsd.sd_MS = SEEMS;\n\tsd.sd_RDY = SEERDY;\n\tsd.sd_CS = SEECS;\n\tsd.sd_CK = SEECK;\n\tsd.sd_DO = SEEDO;\n\tsd.sd_DI = SEEDI;\n\n\thave_seeprom = acquire_seeprom(ahc, &sd);\n\tif (have_seeprom) {\n\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s: Reading SEEPROM...\", ahc_name(ahc));\n\n\t\tfor (;;) {\n\t\t\tbus_size_t start_addr;\n\n\t\t\tstart_addr = 32 * (ahc->channel - 'A');\n\n\t\t\thave_seeprom = read_seeprom(&sd,\n\t\t\t\t\t\t    (u_int16_t *)&sc,\n\t\t\t\t\t\t    start_addr,\n\t\t\t\t\t\t    sizeof(sc)/2);\n\n\t\t\tif (have_seeprom) {\n\t\t\t\t/* Check checksum */\n\t\t\t\tint i;\n\t\t\t\tint maxaddr;\n\t\t\t\tu_int32_t checksum;\n\t\t\t\tu_int16_t *scarray;\n\n\t\t\t\tmaxaddr = (sizeof(sc)/2) - 1;\n\t\t\t\tchecksum = 0;\n\t\t\t\tscarray = (u_int16_t *)&sc;\n\n\t\t\t\tfor (i = 0; i < maxaddr; i++)\n\t\t\t\t\tchecksum = checksum + scarray[i];\n\t\t\t\tif (checksum == 0\n\t\t\t\t    || (checksum & 0xFFFF) != sc.checksum) {\n\t\t\t\t\tif (bootverbose && sd.sd_chip == C56_66)\n\t\t\t\t\t\tprintf (\"checksum error\\n\");\n\t\t\t\t\thave_seeprom = 0;\n\t\t\t\t} else {\n\t\t\t\t\tif (bootverbose)\n\t\t\t\t\t\tprintf(\"done.\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sd.sd_chip == C56_66)\n\t\t\t\tbreak;\n\t\t\tsd.sd_chip = C56_66;\n\t\t}\n\t}\n\n\tif (!have_seeprom) {\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s: No SEEPROM available.\\n\", ahc_name(ahc));\n\t\tahc->flags |= AHC_USEDEFAULTS;\n\t} else {\n\t\t/*\n\t\t * Put the data we've collected down into SRAM\n\t\t * where ahc_init will find it.\n\t\t */\n\t\tint i;\n\t\tint max_targ = sc.max_targets & CFMAXTARG;\n\t\tu_int16_t discenable;\n\t\tu_int16_t ultraenb;\n\n\t\tdiscenable = 0;\n\t\tultraenb = 0;\n\t\tif ((sc.adapter_control & CFULTRAEN) != 0) {\n\t\t\t/*\n\t\t\t * Determine if this adapter has a \"newstyle\"\n\t\t\t * SEEPROM format.\n\t\t\t */\n\t\t\tfor (i = 0; i < max_targ; i++) {\n\t\t\t\tif ((sc.device_flags[i] & CFSYNCHISULTRA) != 0) {\n\t\t\t\t\tahc->flags |= AHC_NEWEEPROM_FMT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < max_targ; i++) {\n\t\t\tu_int     scsirate;\n\t\t\tu_int16_t target_mask;\n\n\t\t\ttarget_mask = 0x01 << i;\n\t\t\tif (sc.device_flags[i] & CFDISC)\n\t\t\t\tdiscenable |= target_mask;\n\t\t\tif ((ahc->flags & AHC_NEWEEPROM_FMT) != 0) {\n\t\t\t\tif ((sc.device_flags[i] & CFSYNCHISULTRA) != 0)\n\t\t\t\t\tultraenb |= target_mask;\n\t\t\t} else if ((sc.adapter_control & CFULTRAEN) != 0) {\n\t\t\t\tultraenb |= target_mask;\n\t\t\t}\n\t\t\tif ((sc.device_flags[i] & CFXFER) == 0x04\n\t\t\t\t && (ultraenb & target_mask) != 0) {\n\t\t\t\t/* Treat 10MHz as a non-ultra speed */\n\t\t\t\tsc.device_flags[i] &= ~CFXFER;\n\t\t\t\tultraenb &= ~target_mask;\n\t\t\t}\n\t\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\t\tu_int offset;\n\n\t\t\t\tif (sc.device_flags[i] & CFSYNCH)\n\t\t\t\t\toffset = MAX_OFFSET_ULTRA2;\n\t\t\t\telse\n\t\t\t\t\toffset = 0;\n\t\t\t\tahc_outb(ahc, TARG_OFFSET + i, offset);\n\n\t\t\t\tscsirate = (sc.device_flags[i] & CFXFER)\n\t\t\t\t| ((ultraenb & target_mask) ? 0x8 : 0x0);\n\t\t\t\tif (sc.device_flags[i] & CFWIDEB)\n\t\t\t\t\tscsirate |= WIDEXFER;\n\t\t\t} else {\n\t\t\t\tscsirate = (sc.device_flags[i] & CFXFER) << 4;\n\t\t\t\tif (sc.device_flags[i] & CFSYNCH)\n\t\t\t\t\tscsirate |= SOFS;\n\t\t\t\tif (sc.device_flags[i] & CFWIDEB)\n\t\t\t\t\tscsirate |= WIDEXFER;\n\t\t\t}\n\t\t\tahc_outb(ahc, TARG_SCSIRATE + i, scsirate);\n\t\t}\n\t\tahc->our_id = sc.brtime_id & CFSCSIID;\n\n\t\tscsi_conf = (ahc->our_id & 0x7);\n\t\tif (sc.adapter_control & CFSPARITY)\n\t\t\tscsi_conf |= ENSPCHK;\n\t\tif (sc.adapter_control & CFRESETB)\n\t\t\tscsi_conf |= RESET_SCSI;\n\n\t\tif (sc.bios_control & CFEXTEND)\n\t\t\tahc->flags |= AHC_EXTENDED_TRANS_A;\n\t\tif (ahc->features & AHC_ULTRA\n\t\t\t && (ahc->flags & AHC_NEWEEPROM_FMT) == 0) {\n\t\t\t/* Should we enable Ultra mode? */\n\t\t\tif (!(sc.adapter_control & CFULTRAEN))\n\t\t\t\t/* Treat us as a non-ultra card */\n\t\t\t\tultraenb = 0;\n\t\t}\n\t\t/* Set SCSICONF info */\n\t\tahc_outb(ahc, SCSICONF, scsi_conf);\n\t\tahc_outb(ahc, DISC_DSB, ~(discenable & 0xff));\n\t\tahc_outb(ahc, DISC_DSB + 1, ~((discenable >> 8) & 0xff));\n\t\tahc_outb(ahc, ULTRA_ENB, ultraenb & 0xff);\n\t\tahc_outb(ahc, ULTRA_ENB + 1, (ultraenb >> 8) & 0xff);\n\t}\n\n\t/*\n\t * Cards that have the external logic necessary to talk to\n\t * a SEEPROM, are almost certain to have the remaining logic\n\t * necessary for auto-termination control.  This assumption\n\t * hasn't failed yet...\n\t */\n\thave_autoterm = have_seeprom;\n\tif (have_seeprom)\n\t\tadapter_control = sc.adapter_control;\n\telse\n\t\tadapter_control = CFAUTOTERM;\n\n\t/*\n\t * Some low-cost chips have SEEPROM and auto-term control built\n\t * in, instead of using a GAL.  They can tell us directly\n\t * if the termination logic is enabled.\n\t */\n\tif ((ahc->features & AHC_SPIOCAP) != 0) {\n\t\tif ((ahc_inb(ahc, SPIOCAP) & SSPIOCPS) != 0)\n\t\t\thave_autoterm = 1;\n\t\telse\n\t\t\thave_autoterm = 0;\n\t}\n\n\tif (have_autoterm)\n\t\tconfigure_termination(ahc, &sd, adapter_control, sxfrctl1);\n\n\trelease_seeprom(&sd);\n}"
  },
  {
    "function_name": "ahc_probe_ext_scbram",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
    "lines": "649-706",
    "snippet": "static void\nahc_probe_ext_scbram(ahc)\nstruct ahc_softc *ahc;\n{\n\tint num_scbs;\n\tint test_num_scbs;\n\tint enable;\n\tint pcheck;\n\tint fast;\n\n\tif (ahc_ext_scbram_present(ahc) == 0)\n\t\treturn;\n\n\t/*\n\t * Probe for the best parameters to use.\n\t */\n\tenable = 0;\n\tpcheck = 0;\n\tfast = 0;\n\tahc_ext_scbram_config(ahc,\t/*enable*/1, pcheck, fast);\n\tnum_scbs = ahc_probe_scbs(ahc);\n\tif (num_scbs == 0) {\n\t\t/* The SRAM wasn't really present. */\n\t\tgoto done;\n\t}\n\tenable = 1;\n\n\t/* Now see if we can do parity */\n\tahc_ext_scbram_config(ahc, enable, /*pcheck*/1, fast);\n\tnum_scbs = ahc_probe_scbs(ahc);\n\tif ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0\n\t\t || (ahc_inb(ahc, ERROR) & MPARERR) == 0)\n\t\tpcheck = 1;\n\n\t/* Clear any resulting parity error */\n\tahc_outb(ahc, CLRINT, CLRPARERR);\n\tahc_outb(ahc, CLRINT, CLRBRKADRINT);\n\n\t/* Now see if we can do fast timing */\n\tahc_ext_scbram_config(ahc, enable, pcheck, /*fast*/1);\n\ttest_num_scbs = ahc_probe_scbs(ahc);\n\tif (test_num_scbs == num_scbs\n\t\t && ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0\n\t\t\t  || (ahc_inb(ahc, ERROR) & MPARERR) == 0))\n\t\tfast = 1;\n\n\tdone:\n\t/* Clear any resulting parity error */\n\tahc_outb(ahc, CLRINT, CLRPARERR);\n\tahc_outb(ahc, CLRINT, CLRBRKADRINT);\n\tif (bootverbose && enable) {\n\t\tprintf(\"%s: External SRAM, %dns access%s\\n\",\n\t\t\t\t ahc_name(ahc), fast ? 10 : 20,\n\t\t\t\t pcheck ? \", parity checking enabled\" : \"\");\n\n\t}\n\tahc_ext_scbram_config(ahc, enable, pcheck, fast);\n}",
    "includes": [
      "#include <dev/ic/smc93cx6var.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define bootverbose\t0",
      "#define bootverbose\t1"
    ],
    "globals_used": [
      "static int  ahc_ext_scbram_present",
      "static void ahc_ext_scbram_config",
      "static void ahc_probe_ext_scbram",
      "int ahc_probe_scbs"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_ext_scbram_config",
          "args": [
            "ahc",
            "enable",
            "pcheck",
            "fast"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_ext_scbram_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
          "lines": "595-642",
          "snippet": "static void\nahc_ext_scbram_config(ahc, enable, pcheck, fast)\nstruct ahc_softc *ahc;\nint enable;\nint pcheck;\nint fast;\n{\n\tpcireg_t devconfig;\n\tstruct ahc_pci_data *pd = ahc->pci_data;\n\n\tif (ahc->features & AHC_MULTI_FUNC) {\n\t\tu_char channel; \n\t\t/*\n\t\t * Set the SCB Base addr (highest address bit)\n\t\t * depending on which channel we are.\n\t\t */\n\t\tchannel = pd->function == 1 ? 1 : 0;\n\t\tahc_outb(ahc, SCBBADDR, channel);\n\t}\n\n\tdevconfig = pci_conf_read(pd->pc, pd->tag, DEVCONFIG);\n\t\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tu_int dscommand0;\n\n\t\tdscommand0 = ahc_inb(ahc, DSCOMMAND0);\n\t\tif (enable)\n\t\t\tdscommand0 &= ~INTSCBRAMSEL;\n\t\telse\n\t\t\tdscommand0 |= INTSCBRAMSEL;\n\t\tahc_outb(ahc, DSCOMMAND0, dscommand0);\n\t} else {\n\t\tif (fast)\n\t\t\tdevconfig &= ~EXTSCBTIME;\n\t\telse\n\t\t\tdevconfig |= EXTSCBTIME;\n\t\tif (enable)\n\t\t\tdevconfig &= ~SCBRAMSEL;\n\t\telse\n\t\t\tdevconfig |= SCBRAMSEL;\n\t}\n\tif (pcheck)\n\t\tdevconfig |= EXTSCBPEN;\n\telse\n\t\tdevconfig &= ~EXTSCBPEN;\n\n\tpci_conf_write(pd->pc, pd->tag, DEVCONFIG, devconfig);\n}",
          "includes": [
            "#include <dev/ic/smc93cx6var.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\t\tEXTSCBPEN\t0x00000010UL\t/* aic7870 & aic7890 only */",
            "#define\t\tEXTSCBTIME\t0x00000020UL\t/* aic7870 only */",
            "#define\t\tSCBRAMSEL\t0x00000080UL",
            "#define\tDEVCONFIG\t\t0x40"
          ],
          "globals_used": [
            "static void ahc_ext_scbram_config"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\t\tEXTSCBPEN\t0x00000010UL\t/* aic7870 & aic7890 only */\n#define\t\tEXTSCBTIME\t0x00000020UL\t/* aic7870 only */\n#define\t\tSCBRAMSEL\t0x00000080UL\n#define\tDEVCONFIG\t\t0x40\n\nstatic void ahc_ext_scbram_config;\n\nstatic void\nahc_ext_scbram_config(ahc, enable, pcheck, fast)\nstruct ahc_softc *ahc;\nint enable;\nint pcheck;\nint fast;\n{\n\tpcireg_t devconfig;\n\tstruct ahc_pci_data *pd = ahc->pci_data;\n\n\tif (ahc->features & AHC_MULTI_FUNC) {\n\t\tu_char channel; \n\t\t/*\n\t\t * Set the SCB Base addr (highest address bit)\n\t\t * depending on which channel we are.\n\t\t */\n\t\tchannel = pd->function == 1 ? 1 : 0;\n\t\tahc_outb(ahc, SCBBADDR, channel);\n\t}\n\n\tdevconfig = pci_conf_read(pd->pc, pd->tag, DEVCONFIG);\n\t\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tu_int dscommand0;\n\n\t\tdscommand0 = ahc_inb(ahc, DSCOMMAND0);\n\t\tif (enable)\n\t\t\tdscommand0 &= ~INTSCBRAMSEL;\n\t\telse\n\t\t\tdscommand0 |= INTSCBRAMSEL;\n\t\tahc_outb(ahc, DSCOMMAND0, dscommand0);\n\t} else {\n\t\tif (fast)\n\t\t\tdevconfig &= ~EXTSCBTIME;\n\t\telse\n\t\t\tdevconfig |= EXTSCBTIME;\n\t\tif (enable)\n\t\t\tdevconfig &= ~SCBRAMSEL;\n\t\telse\n\t\t\tdevconfig |= SCBRAMSEL;\n\t}\n\tif (pcheck)\n\t\tdevconfig |= EXTSCBPEN;\n\telse\n\t\tdevconfig &= ~EXTSCBPEN;\n\n\tpci_conf_write(pd->pc, pd->tag, DEVCONFIG, devconfig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: External SRAM, %dns access%s\\n\"",
            "ahc_name(ahc)",
            "fast ? 10 : 20",
            "pcheck ? \", parity checking enabled\" : \"\""
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRINT",
            "CLRBRKADRINT"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRINT",
            "CLRPARERR"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "ERROR"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "INTSTAT"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_probe_scbs",
          "args": [
            "ahc"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_probe_scbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "3542-3559",
          "snippet": "int\nahc_probe_scbs(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tint i;\n\n\tfor (i = 0; i < AHC_SCB_MAX; i++) {\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tahc_outb(ahc, SCB_CONTROL, i);\n\t\tif (ahc_inb(ahc, SCB_CONTROL) != i)\n\t\t\tbreak;\n\t\tahc_outb(ahc, SCBPTR, 0);\n\t\tif (ahc_inb(ahc, SCB_CONTROL) != 0)\n\t\t\tbreak;\n\t}\n\t\n\treturn (i);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nint\nahc_probe_scbs(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tint i;\n\n\tfor (i = 0; i < AHC_SCB_MAX; i++) {\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tahc_outb(ahc, SCB_CONTROL, i);\n\t\tif (ahc_inb(ahc, SCB_CONTROL) != i)\n\t\t\tbreak;\n\t\tahc_outb(ahc, SCBPTR, 0);\n\t\tif (ahc_inb(ahc, SCB_CONTROL) != 0)\n\t\t\tbreak;\n\t}\n\t\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRINT",
            "CLRBRKADRINT"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRINT",
            "CLRPARERR"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "ERROR"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "INTSTAT"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_ext_scbram_present",
          "args": [
            "ahc"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_ext_scbram_present",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
          "lines": "568-590",
          "snippet": "static int\nahc_ext_scbram_present(ahc)\nstruct ahc_softc *ahc;\n{\n\tint ramps;\n\tint single_user;\n\tpcireg_t devconfig;\n\tstruct ahc_pci_data *pd = ahc->pci_data;\n\n\tdevconfig = pci_conf_read(pd->pc, pd->tag, DEVCONFIG);\n\tsingle_user = (devconfig & MPORTMODE) != 0;\n\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tramps = (ahc_inb(ahc, DSCOMMAND0) & RAMPS) != 0;\n\telse if ((ahc->chip & AHC_CHIPID_MASK) >= AHC_AIC7870)\n\t\tramps = (devconfig & RAMPSM) != 0;\n\telse\n\t\tramps\t= 0;\n\n\tif (ramps && single_user)\n\t\treturn (1);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/smc93cx6var.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\t\tRAMPSM\t\t0x00000200UL\t/* aic7870 only */",
            "#define\t\tMPORTMODE\t0x00000400UL\t/* aic7870 only */",
            "#define\tDEVCONFIG\t\t0x40"
          ],
          "globals_used": [
            "static int  ahc_ext_scbram_present"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\t\tRAMPSM\t\t0x00000200UL\t/* aic7870 only */\n#define\t\tMPORTMODE\t0x00000400UL\t/* aic7870 only */\n#define\tDEVCONFIG\t\t0x40\n\nstatic int  ahc_ext_scbram_present;\n\nstatic int\nahc_ext_scbram_present(ahc)\nstruct ahc_softc *ahc;\n{\n\tint ramps;\n\tint single_user;\n\tpcireg_t devconfig;\n\tstruct ahc_pci_data *pd = ahc->pci_data;\n\n\tdevconfig = pci_conf_read(pd->pc, pd->tag, DEVCONFIG);\n\tsingle_user = (devconfig & MPORTMODE) != 0;\n\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tramps = (ahc_inb(ahc, DSCOMMAND0) & RAMPS) != 0;\n\telse if ((ahc->chip & AHC_CHIPID_MASK) >= AHC_AIC7870)\n\t\tramps = (devconfig & RAMPSM) != 0;\n\telse\n\t\tramps\t= 0;\n\n\tif (ramps && single_user)\n\t\treturn (1);\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define bootverbose\t0\n#define bootverbose\t1\n\nstatic int  ahc_ext_scbram_present;\nstatic void ahc_ext_scbram_config;\nstatic void ahc_probe_ext_scbram;\nint ahc_probe_scbs;\n\nstatic void\nahc_probe_ext_scbram(ahc)\nstruct ahc_softc *ahc;\n{\n\tint num_scbs;\n\tint test_num_scbs;\n\tint enable;\n\tint pcheck;\n\tint fast;\n\n\tif (ahc_ext_scbram_present(ahc) == 0)\n\t\treturn;\n\n\t/*\n\t * Probe for the best parameters to use.\n\t */\n\tenable = 0;\n\tpcheck = 0;\n\tfast = 0;\n\tahc_ext_scbram_config(ahc,\t/*enable*/1, pcheck, fast);\n\tnum_scbs = ahc_probe_scbs(ahc);\n\tif (num_scbs == 0) {\n\t\t/* The SRAM wasn't really present. */\n\t\tgoto done;\n\t}\n\tenable = 1;\n\n\t/* Now see if we can do parity */\n\tahc_ext_scbram_config(ahc, enable, /*pcheck*/1, fast);\n\tnum_scbs = ahc_probe_scbs(ahc);\n\tif ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0\n\t\t || (ahc_inb(ahc, ERROR) & MPARERR) == 0)\n\t\tpcheck = 1;\n\n\t/* Clear any resulting parity error */\n\tahc_outb(ahc, CLRINT, CLRPARERR);\n\tahc_outb(ahc, CLRINT, CLRBRKADRINT);\n\n\t/* Now see if we can do fast timing */\n\tahc_ext_scbram_config(ahc, enable, pcheck, /*fast*/1);\n\ttest_num_scbs = ahc_probe_scbs(ahc);\n\tif (test_num_scbs == num_scbs\n\t\t && ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0\n\t\t\t  || (ahc_inb(ahc, ERROR) & MPARERR) == 0))\n\t\tfast = 1;\n\n\tdone:\n\t/* Clear any resulting parity error */\n\tahc_outb(ahc, CLRINT, CLRPARERR);\n\tahc_outb(ahc, CLRINT, CLRBRKADRINT);\n\tif (bootverbose && enable) {\n\t\tprintf(\"%s: External SRAM, %dns access%s\\n\",\n\t\t\t\t ahc_name(ahc), fast ? 10 : 20,\n\t\t\t\t pcheck ? \", parity checking enabled\" : \"\");\n\n\t}\n\tahc_ext_scbram_config(ahc, enable, pcheck, fast);\n}"
  },
  {
    "function_name": "ahc_ext_scbram_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
    "lines": "595-642",
    "snippet": "static void\nahc_ext_scbram_config(ahc, enable, pcheck, fast)\nstruct ahc_softc *ahc;\nint enable;\nint pcheck;\nint fast;\n{\n\tpcireg_t devconfig;\n\tstruct ahc_pci_data *pd = ahc->pci_data;\n\n\tif (ahc->features & AHC_MULTI_FUNC) {\n\t\tu_char channel; \n\t\t/*\n\t\t * Set the SCB Base addr (highest address bit)\n\t\t * depending on which channel we are.\n\t\t */\n\t\tchannel = pd->function == 1 ? 1 : 0;\n\t\tahc_outb(ahc, SCBBADDR, channel);\n\t}\n\n\tdevconfig = pci_conf_read(pd->pc, pd->tag, DEVCONFIG);\n\t\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tu_int dscommand0;\n\n\t\tdscommand0 = ahc_inb(ahc, DSCOMMAND0);\n\t\tif (enable)\n\t\t\tdscommand0 &= ~INTSCBRAMSEL;\n\t\telse\n\t\t\tdscommand0 |= INTSCBRAMSEL;\n\t\tahc_outb(ahc, DSCOMMAND0, dscommand0);\n\t} else {\n\t\tif (fast)\n\t\t\tdevconfig &= ~EXTSCBTIME;\n\t\telse\n\t\t\tdevconfig |= EXTSCBTIME;\n\t\tif (enable)\n\t\t\tdevconfig &= ~SCBRAMSEL;\n\t\telse\n\t\t\tdevconfig |= SCBRAMSEL;\n\t}\n\tif (pcheck)\n\t\tdevconfig |= EXTSCBPEN;\n\telse\n\t\tdevconfig &= ~EXTSCBPEN;\n\n\tpci_conf_write(pd->pc, pd->tag, DEVCONFIG, devconfig);\n}",
    "includes": [
      "#include <dev/ic/smc93cx6var.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\t\tEXTSCBPEN\t0x00000010UL\t/* aic7870 & aic7890 only */",
      "#define\t\tEXTSCBTIME\t0x00000020UL\t/* aic7870 only */",
      "#define\t\tSCBRAMSEL\t0x00000080UL",
      "#define\tDEVCONFIG\t\t0x40"
    ],
    "globals_used": [
      "static void ahc_ext_scbram_config"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pd->pc",
            "pd->tag",
            "DEVCONFIG",
            "devconfig"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "DSCOMMAND0",
            "dscommand0"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "DSCOMMAND0"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pd->pc",
            "pd->tag",
            "DEVCONFIG"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBBADDR",
            "channel"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\t\tEXTSCBPEN\t0x00000010UL\t/* aic7870 & aic7890 only */\n#define\t\tEXTSCBTIME\t0x00000020UL\t/* aic7870 only */\n#define\t\tSCBRAMSEL\t0x00000080UL\n#define\tDEVCONFIG\t\t0x40\n\nstatic void ahc_ext_scbram_config;\n\nstatic void\nahc_ext_scbram_config(ahc, enable, pcheck, fast)\nstruct ahc_softc *ahc;\nint enable;\nint pcheck;\nint fast;\n{\n\tpcireg_t devconfig;\n\tstruct ahc_pci_data *pd = ahc->pci_data;\n\n\tif (ahc->features & AHC_MULTI_FUNC) {\n\t\tu_char channel; \n\t\t/*\n\t\t * Set the SCB Base addr (highest address bit)\n\t\t * depending on which channel we are.\n\t\t */\n\t\tchannel = pd->function == 1 ? 1 : 0;\n\t\tahc_outb(ahc, SCBBADDR, channel);\n\t}\n\n\tdevconfig = pci_conf_read(pd->pc, pd->tag, DEVCONFIG);\n\t\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tu_int dscommand0;\n\n\t\tdscommand0 = ahc_inb(ahc, DSCOMMAND0);\n\t\tif (enable)\n\t\t\tdscommand0 &= ~INTSCBRAMSEL;\n\t\telse\n\t\t\tdscommand0 |= INTSCBRAMSEL;\n\t\tahc_outb(ahc, DSCOMMAND0, dscommand0);\n\t} else {\n\t\tif (fast)\n\t\t\tdevconfig &= ~EXTSCBTIME;\n\t\telse\n\t\t\tdevconfig |= EXTSCBTIME;\n\t\tif (enable)\n\t\t\tdevconfig &= ~SCBRAMSEL;\n\t\telse\n\t\t\tdevconfig |= SCBRAMSEL;\n\t}\n\tif (pcheck)\n\t\tdevconfig |= EXTSCBPEN;\n\telse\n\t\tdevconfig &= ~EXTSCBPEN;\n\n\tpci_conf_write(pd->pc, pd->tag, DEVCONFIG, devconfig);\n}"
  },
  {
    "function_name": "ahc_ext_scbram_present",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
    "lines": "568-590",
    "snippet": "static int\nahc_ext_scbram_present(ahc)\nstruct ahc_softc *ahc;\n{\n\tint ramps;\n\tint single_user;\n\tpcireg_t devconfig;\n\tstruct ahc_pci_data *pd = ahc->pci_data;\n\n\tdevconfig = pci_conf_read(pd->pc, pd->tag, DEVCONFIG);\n\tsingle_user = (devconfig & MPORTMODE) != 0;\n\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tramps = (ahc_inb(ahc, DSCOMMAND0) & RAMPS) != 0;\n\telse if ((ahc->chip & AHC_CHIPID_MASK) >= AHC_AIC7870)\n\t\tramps = (devconfig & RAMPSM) != 0;\n\telse\n\t\tramps\t= 0;\n\n\tif (ramps && single_user)\n\t\treturn (1);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/smc93cx6var.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\t\tRAMPSM\t\t0x00000200UL\t/* aic7870 only */",
      "#define\t\tMPORTMODE\t0x00000400UL\t/* aic7870 only */",
      "#define\tDEVCONFIG\t\t0x40"
    ],
    "globals_used": [
      "static int  ahc_ext_scbram_present"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "DSCOMMAND0"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pd->pc",
            "pd->tag",
            "DEVCONFIG"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\t\tRAMPSM\t\t0x00000200UL\t/* aic7870 only */\n#define\t\tMPORTMODE\t0x00000400UL\t/* aic7870 only */\n#define\tDEVCONFIG\t\t0x40\n\nstatic int  ahc_ext_scbram_present;\n\nstatic int\nahc_ext_scbram_present(ahc)\nstruct ahc_softc *ahc;\n{\n\tint ramps;\n\tint single_user;\n\tpcireg_t devconfig;\n\tstruct ahc_pci_data *pd = ahc->pci_data;\n\n\tdevconfig = pci_conf_read(pd->pc, pd->tag, DEVCONFIG);\n\tsingle_user = (devconfig & MPORTMODE) != 0;\n\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tramps = (ahc_inb(ahc, DSCOMMAND0) & RAMPS) != 0;\n\telse if ((ahc->chip & AHC_CHIPID_MASK) >= AHC_AIC7870)\n\t\tramps = (devconfig & RAMPSM) != 0;\n\telse\n\t\tramps\t= 0;\n\n\tif (ramps && single_user)\n\t\treturn (1);\n\treturn (0);\n}"
  },
  {
    "function_name": "ahc_pci_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
    "lines": "198-562",
    "snippet": "void\nahc_pci_attach(parent, self, aux)\nstruct device *parent, *self;\nvoid *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\tstruct ahc_softc *ahc = (void *)self;\n\tbus_space_tag_t  iot;\n\tbus_space_handle_t ioh;\n#ifdef AHC_ALLOW_MEMIO\n\tbus_space_tag_t memt;\n\tbus_space_handle_t memh;\n\tint\tmemh_valid;\n#endif\n\tpci_intr_handle_t ih;\n\tpcireg_t\t   command;\n\tconst char *intrstr;\n\tunsigned opri = 0;\n\tahc_chip ahc_c = AHC_PCI; /* we are a PCI controller */\n\tahc_flag ahc_flags = AHC_FNONE;\n\tahc_feature ahc_f = AHC_FENONE;\n\tint\tioh_valid;\n\n\tu_char ultra_enb = 0;\n\tu_char our_id = 0;\n\tu_char channel = 'A';\n\tu_int    sxfrctl1;\n\tu_int    scsiseq;\n\t/* So we can access PCI configuration space after init */\n\tstruct ahc_pci_data *pd;\n\n\tahc->sc_dmat = pa->pa_dmat;\n\t\n\tcommand = pci_conf_read(pa->pa_pc, pa->pa_tag,\n\t\t\t\tPCI_COMMAND_STATUS_REG);\n\n\tswitch (PCI_VENDOR(pa->pa_id)) {\n\tcase PCI_VENDOR_ADP:\n\t\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\t\tcase PCI_PRODUCT_ADP_7895:\n\t\t\t{\n\t\t\t\tpcireg_t devconfig;\n\t\t\t\tchannel = pa->pa_function == 1 ? 'B' : 'A';\n\t\t\t\tahc_c |= AHC_AIC7895;\n\t\t\t\t/* The 'C' revision of the aic7895 \n\t\t\t\t   has a few additional features */\n\t\t\t\tif (PCI_REVISION(pa->pa_class) >= 4)\n\t\t\t\t\tahc_f = AHC_AIC7895C_FE;\n\t\t\t\telse\n\t\t\t\t\tahc_f = AHC_AIC7895_FE;\n\t\t\t\tahc_flags |= AHC_NEWEEPROM_FMT;\n\t\t\t\tdevconfig = pci_conf_read(pa->pa_pc, \n\t\t\t\t\t\t\t  pa->pa_tag,\n\t\t\t\t\t\t\t  DEVCONFIG);\n\t\t\t\tdevconfig &= ~SCBSIZE32;\n\t\t\t\tpci_conf_write(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t       DEVCONFIG, devconfig);\n\t\t\t}\n\t\t\tbreak;\n\t   case PCI_PRODUCT_ADP_3940U:\n\t\tcase PCI_PRODUCT_ADP_3940:\n\t\t\tif (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADP_3940U) {\n\t\t\t\tahc_c |= AHC_AIC7880;\n\t\t\t\tahc_f = AHC_AIC7880_FE;\n\t\t\t} else {\n\t\t\t\tahc_c |= AHC_AIC7870;\n\t\t\t\tahc_f = AHC_AIC7870_FE;\n\t\t\t}\n\t\t\taic3940_count++;\n\t\t\tif (!(aic3940_count & 0x01))\n\t\t\t\t/* Even count implies second channel */\n\t\t\t\tchannel = 'B';\n\t\t\tbreak;\n\t\tcase PCI_PRODUCT_ADP_2940UWPro:\n\t\t\tahc_c |= AHC_AIC7880;\n\t\t\tahc_f = AHC_AIC7880_FE;\n\t\t\tahc_f |= AHC_INT50_SPEEDFLEX;\n\t\tcase PCI_PRODUCT_ADP_2944U:\n\t\tcase PCI_PRODUCT_ADP_2940U:\n\t\t\tahc_c |= AHC_AIC7880;\n\t\t\tahc_f = AHC_AIC7880_FE;\n\t\t\tbreak;\n\t\tcase PCI_PRODUCT_ADP_2944:\n\t\tcase PCI_PRODUCT_ADP_2940:\n\t\t\tahc_c |= AHC_AIC7870;\n\t\t\tahc_f = AHC_AIC7870_FE;\n\t\t\tbreak;\n\t\tcase PCI_PRODUCT_ADP_2940AU:\n\t\t\tahc_c |= AHC_AIC7860;\n\t\t\tahc_f = AHC_AIC7860_FE;\n\t\t\tbreak;\n\t\tcase PCI_PRODUCT_ADP_398XU:\t/* XXX */\n\t\tcase PCI_PRODUCT_ADP_AIC7880:\n\t\t\tahc_c |= AHC_AIC7880;\n\t\t\tahc_f = AHC_AIC7880_FE;\n\t\t\tbreak;\n\t\tcase PCI_PRODUCT_ADP_AIC7870:\n\t\t\tahc_c |= AHC_AIC7870;\n\t\t\tahc_f = AHC_AIC7870_FE;\n\t\t\tbreak;\n\t\tcase PCI_PRODUCT_ADP_AIC7860:\n\t\t\tahc_c |= AHC_AIC7860;\n\t\t\tahc_f = AHC_AIC7860_FE;\n\t\t\tbreak;\n\t\tcase PCI_PRODUCT_ADP_AIC7855:\n\t\tcase PCI_PRODUCT_ADP_AIC7850:\n\t\t\tahc_c |= AHC_AIC7850;\n\t\t\tahc_f = AHC_AIC7850_FE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* TTT */\n\t\t\tbreak;\n\t}\n\t\tbreak;\n\tcase PCI_VENDOR_ADP2:\n\t\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\t\tcase PCI_PRODUCT_ADP2_AIC7890:\n\t\tcase PCI_PRODUCT_ADP2_2940U2:\n\t\tcase PCI_PRODUCT_ADP2_2930U2:\n\t\t\tahc_c |= AHC_AIC7890;\n\t\t\tahc_f = AHC_AIC7890_FE;\n\t\t\tahc_flags |= AHC_NEWEEPROM_FMT;\n\t\t\tbreak;\n\t\tcase PCI_PRODUCT_ADP2_AIC7892:\n\t\tcase PCI_PRODUCT_ADP2_29160:\n\t\tcase PCI_PRODUCT_ADP2_19160B:\n\t\t\tahc_c |= AHC_AIC7892;\n\t\t\tahc_f = AHC_AIC7892_FE;\n\t\t\tahc_flags |= AHC_NEWEEPROM_FMT;\n\t\t\tbreak;\n\t\tcase PCI_PRODUCT_ADP2_3950U2B:\n\t\tcase PCI_PRODUCT_ADP2_3950U2D:\n\t\tcase PCI_PRODUCT_ADP2_AIC7896:\n\t\t\t{\n\t\t\t\tpcireg_t devconfig;\n\t\t\t\tchannel = pa->pa_function == 1 ? 'B' : 'A';\n\t\t\t\tahc_c |= AHC_AIC7896;\n\t\t\t\tahc_f = AHC_AIC7896_FE;\n\t\t\t\tahc_flags |= AHC_NEWEEPROM_FMT;\n\t\t\t\tdevconfig = pci_conf_read(pa->pa_pc, \n\t\t\t\t\t\t\t  pa->pa_tag, \n\t\t\t\t\t\t\t  DEVCONFIG);\n\t\t\t\t/* turn off 64 bit for now XXX smurph */\n\t\t\t\tdevconfig &= ~PCI64;\n\t\t\t\tpci_conf_write(pa->pa_pc, pa->pa_tag, \n\t\t\t\t\t       DEVCONFIG, devconfig);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PCI_PRODUCT_ADP2_AIC7899:\n\t\tcase PCI_PRODUCT_ADP2_3960D:\n\t\t\tahc_c |= AHC_AIC7899;\n\t\t\tahc_f = AHC_AIC7899_FE;\n\t\t\tahc_flags |= AHC_NEWEEPROM_FMT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* TTT */\n\t\t}\n\t}\n\t\n#ifdef AHC_ALLOW_MEMIO\n\tmemh_valid = (pci_mapreg_map(pa, AHC_PCI_MEMADDR,\n\t    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,\n\t    &memt, &memh, NULL, NULL) == 0);\n#endif\n\tioh_valid = (pci_mapreg_map(pa, AHC_PCI_IOADDR,\n\t    PCI_MAPREG_TYPE_IO, 0, &iot, &ioh, NULL, NULL) == 0);\n\n\tif (ioh_valid) {\n\t\t/* do nothing */\n#ifdef AHC_ALLOW_MEMIO\n\t} else if (memh_valid) {\n\t\t/* do nothing */\n#endif\n\t} else {\n\t\t/* error out */\n\t\tprintf(\": unable to map registers\\n\");\n\t\treturn;\n\t}\n\t\n\t/* Ensure busmastering is enabled */\n\tcommand |= PCI_COMMAND_MASTER_ENABLE;\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);\n\n\tpd = malloc(sizeof (struct ahc_pci_data), M_DEVBUF, M_NOWAIT);\n\tif (pd == NULL) {\n\t\tprintf(\": error allocating pci data\\n\");\n\t\treturn;\n\t}\n\n\tpd->pc = pa->pa_pc;\n\tpd->tag = pa->pa_tag;\n\tpd->function = pa->pa_function;\n\n\t/* setup the PCI stuff */\n\tahc->pci_data = pd;\n\tahc->pci_intr_func = ahc_pci_intr;\n\n\n\t/* On all PCI adapters, we allow SCB paging */\n\tahc_flags |= AHC_PAGESCBS;\n\n\tahc_construct(ahc, pa->pa_iot, ioh, ahc_c, ahc_flags, ahc_f, channel);\n\t/* Now we can use the ahc_inb and ahc_outb macros */\n\n\t/* setup the PCI error interrupt handler */\n\tahc->pci_intr_func = &ahc_pci_intr;\n\t\n\t/* Remeber how the card was setup in case there is no SEEPROM */\n\tahc_outb(ahc, HCNTRL, ahc->pause);\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tour_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;\n\telse\n\t\tour_id = ahc_inb(ahc, SCSIID) & OID;\n\tsxfrctl1 = ahc_inb(ahc, SXFRCTL1) & STPWEN;\n\tscsiseq = ahc_inb(ahc, SCSISEQ);\n\t\n\tif (ahc_reset(ahc) != 0) {\n\t\t/* Failed */\n\t\tahc_free(ahc);\n\t\treturn;\n\t}\n\t\n\tif (ahc->features & AHC_ULTRA)\n\t\tultra_enb = bus_space_read_1(pa->pa_iot, ioh, SXFRCTL0) &\n\t\t\t\t\t\tFAST20;\n\t\n\tif ((ahc->features & AHC_DT) != 0) {\n\t\tu_int optionmode;\n\t\tu_int sfunct;\n\n\t\t/* Perform ALT-Mode Setup */\n\t\tsfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;\n\t\tahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);\n\t\toptionmode = ahc_inb(ahc, OPTIONMODE);\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s: OptionMode = %x\\n\", ahc_name(ahc), optionmode);\n\t\tahc_outb(ahc, OPTIONMODE, OPTIONMODE_DEFAULTS);\n\t\t/* Send CRC info in target mode every 4K */\n\t\tahc_outb(ahc, TARGCRCCNT, 0);\n\t\tahc_outb(ahc, TARGCRCCNT + 1, 0x10);\n\t\tahc_outb(ahc, SFUNCT, sfunct);\n\n\t\t/* Normal mode setup */\n\t\tahc_outb(ahc, CRCCONTROL1, CRCVALCHKEN|CRCENDCHKEN|CRCREQCHKEN\n\t\t\t\t\t|TARGCRCENDEN|TARGCRCCNTEN);\n\t}\n\n\tif (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,\n\t\t\t pa->pa_intrline, &ih)) {\n\t\tprintf(\"%s: couldn't map interrupt\\n\", ahc->sc_dev.dv_xname);\n\t\tahc_free(ahc);\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pa->pa_pc, ih);\n\tahc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO, ahc_intr, ahc,\n                                        ahc->sc_dev.dv_xname);\n\n\tif (ahc->sc_ih == NULL) {\n\t\tprintf(\": couldn't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\tahc_free(ahc);\n\t\treturn;\n\t}\n\tif (intrstr != NULL)\n\t\tprintf(\": %s\\n\", intrstr);\n\n\t/*\n\t * Protect ourself from spurrious interrupts during\n\t * intialization.\n\t */\n\topri = splbio();\n\n\t/*\n\t * Do aic7880/aic7870/aic7860/aic7850 specific initialization\n\t */\n\t{\n\t\tu_int8_t sblkctl;\n\t\tu_int dscommand0;\n\n\t\tdscommand0 = ahc_inb(ahc, DSCOMMAND0);\n\t\tdscommand0 |= MPARCKEN;\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\n\t\t\t/*\n\t\t\t * DPARCKEN doesn't work correctly on\n\t\t\t * some MBs so don't use it.\n\t\t\t */\n\t\t\tdscommand0 &= ~(USCBSIZE32|DPARCKEN);\n\t\t\tdscommand0 |= CACHETHEN;\n\t\t}\n\n\t\tahc_outb(ahc, DSCOMMAND0, dscommand0);\n\n\t\t/* See if we have an SEEPROM and perform auto-term */\n\t\tcheck_extport(ahc, &sxfrctl1);\n\n\t\t/*\n\t\t * Take the LED out of diagnostic mode\n\t\t */\n\t\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\t\tahc_outb(ahc, SBLKCTL, (sblkctl & ~(DIAGLEDEN|DIAGLEDON)));\n\n\t\t/*\n\t\t * I don't know where this is set in the SEEPROM or by the\n\t\t * BIOS, so we default to 100% on Ultra or slower controllers\n\t\t * and 75% on ULTRA2 controllers.\n\t\t */\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\tahc_outb(ahc, DFF_THRSH, RD_DFTHRSH_75|WR_DFTHRSH_75);\n\t\t} else {\n\t\t\tahc_outb(ahc, DSPCISTATUS, DFTHRSH_100);\n\t\t}\n\n\t\tif (ahc->flags & AHC_USEDEFAULTS) {\n\t\t\t/*\n\t\t\t * PCI Adapter default setup\n\t\t\t * Should only be used if the adapter does not have\n\t\t\t * an SEEPROM.\n\t\t\t */\n\t\t\t/* See if someone else set us up already */\n\t\t\tif (scsiseq != 0) {\n\t\t\t\tprintf(\"%s: Using left over BIOS settings\\n\",\n\t\t\t\t\t\t ahc_name(ahc));\n\t\t\t\tahc->flags &= ~AHC_USEDEFAULTS;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Assume only one connector and always turn\n\t\t\t\t * on termination.\n\t\t\t\t */\n\t\t\t\tour_id = 0x07;\n\t\t\t\tsxfrctl1 = STPWEN;\n\t\t\t}\n\t\t\tahc_outb(ahc, SCSICONF, our_id|ENSPCHK|RESET_SCSI);\n\n\t\t\tahc->our_id = our_id;\n\t\t}\n\t}\n\n\t/*\n\t * Take a look to see if we have external SRAM.\n\t * We currently do not attempt to use SRAM that is\n\t * shared among multiple controllers.\n\t */\n\tahc_probe_ext_scbram(ahc);\n\n\tprintf(\"%s: \", ahc_name(ahc));\n\n\t/*\n\t * Record our termination setting for the\n\t * generic initialization routine.\n\t */\n\tif ((sxfrctl1 & STPWEN) != 0)\n\t\tahc->flags |= AHC_TERM_ENB_A;\n\n\tif (ahc_init(ahc)) {\n\t\tahc_free(ahc);\n\t\tsplx(opri);\n\t\treturn; /* XXX PCI code should take return status */\n\t}\n\tsplx(opri);\n\n\tahc_attach(ahc);\n}",
    "includes": [
      "#include <dev/ic/smc93cx6var.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\t\tPCI64\t\t0x00000080UL\t/* aic7891 & aic7897 only */",
      "#define\t\tSCBSIZE32\t0x00010000UL\t/* aic789X only */",
      "#define\tDEVCONFIG\t\t0x40",
      "#define bootverbose\t0",
      "#define bootverbose\t1",
      "#define AHC_PCI_MEMADDR\t(PCI_MAPREG_START + 4)\t/* Mem I/O Address */",
      "#define AHC_PCI_IOADDR\tPCI_MAPREG_START\t/* I/O Address */"
    ],
    "globals_used": [
      "int\t    ahc_pci_intr",
      "static void ahc_probe_ext_scbram",
      "static void check_extport",
      "static u_char aic3940_count;",
      "void ahc_pci_attach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_attach",
          "args": [
            "ahc"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1481-1536",
          "snippet": "int\nahc_attach(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/*\n\t * Initialize the software queue.\n\t */\n\tLIST_INIT(&ahc->sc_xxxq);\n\n#ifdef AHC_BROKEN_CACHE\n\tif (cpu_class == CPUCLASS_386)\t/* doesn't have \"wbinvd\" instruction */\n\t\tahc_broken_cache = 0;\n#endif\n\t/*\n\t * fill in the prototype scsi_links.\n\t */\n\tahc->sc_link.adapter_target = ahc->our_id;\n\tif (ahc->features & AHC_WIDE)\n\t\tahc->sc_link.adapter_buswidth = 16;\n\tahc->sc_link.adapter_softc = ahc;\n\tahc->sc_link.adapter = &ahc_switch;\n\tahc->sc_link.openings = 2;\n\tahc->sc_link.device = &ahc_dev;\n\tahc->sc_link.flags = SCSIDEBUG_LEVEL;\n\t\n\tif (ahc->features & AHC_TWIN) {\n\t\t/* Configure the second scsi bus */\n\t\tahc->sc_link_b = ahc->sc_link;\n\t\tahc->sc_link_b.adapter_target = ahc->our_id_b;\n\t\tif (ahc->features & AHC_WIDE)\n\t\t\tahc->sc_link.adapter_buswidth = 16;\n\t}\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n\tif ((ahc->flags & AHC_CHANNEL_B_PRIMARY) == 0) {\n\t\t/* make IS_SCSIBUS_B() == false, while probing channel A */\n\t\tahc->sc_link_b.scsibus = 0xff;\n\n\t\tconfig_found((void *)ahc, &ahc->sc_link, scsiprint);\n\t\tif (ahc->features & AHC_TWIN)\n\t\t\tconfig_found((void *)ahc, &ahc->sc_link_b, scsiprint);\n\t} else {\n\t\t/*\n\t\t * if implementation of IS_SCSIBUS_B() is changed to use\n\t\t * ahc->sc_link.scsibus, then \"ahc->sc_link.scsibus = 0xff;\"\n\t\t * is needed, here.\n\t\t */\n\n\t\t/* assert(ahc->features & AHC_TWIN); */\n\t\tconfig_found((void *)ahc, &ahc->sc_link_b, scsiprint);\n\t\tconfig_found((void *)ahc, &ahc->sc_link, scsiprint);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static struct scsi_adapter ahc_switch =\n{\n\tahc_scsi_cmd,\n\tahcminphys,\n\t0,\n\t0,\n};",
            "static struct scsi_device ahc_dev =\n{\n\tNULL, /* Use default error handler */\n\tNULL, /* have a queue, served by this */\n\tNULL, /* have no async handler */\n\tNULL, /* Use default 'done' routine */\n};",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "u_int our_id;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic struct scsi_adapter ahc_switch =\n{\n\tahc_scsi_cmd,\n\tahcminphys,\n\t0,\n\t0,\n};\nstatic struct scsi_device ahc_dev =\n{\n\tNULL, /* Use default error handler */\n\tNULL, /* have a queue, served by this */\n\tNULL, /* have no async handler */\n\tNULL, /* Use default 'done' routine */\n};\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nu_int our_id;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nint\nahc_attach(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/*\n\t * Initialize the software queue.\n\t */\n\tLIST_INIT(&ahc->sc_xxxq);\n\n#ifdef AHC_BROKEN_CACHE\n\tif (cpu_class == CPUCLASS_386)\t/* doesn't have \"wbinvd\" instruction */\n\t\tahc_broken_cache = 0;\n#endif\n\t/*\n\t * fill in the prototype scsi_links.\n\t */\n\tahc->sc_link.adapter_target = ahc->our_id;\n\tif (ahc->features & AHC_WIDE)\n\t\tahc->sc_link.adapter_buswidth = 16;\n\tahc->sc_link.adapter_softc = ahc;\n\tahc->sc_link.adapter = &ahc_switch;\n\tahc->sc_link.openings = 2;\n\tahc->sc_link.device = &ahc_dev;\n\tahc->sc_link.flags = SCSIDEBUG_LEVEL;\n\t\n\tif (ahc->features & AHC_TWIN) {\n\t\t/* Configure the second scsi bus */\n\t\tahc->sc_link_b = ahc->sc_link;\n\t\tahc->sc_link_b.adapter_target = ahc->our_id_b;\n\t\tif (ahc->features & AHC_WIDE)\n\t\t\tahc->sc_link.adapter_buswidth = 16;\n\t}\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n\tif ((ahc->flags & AHC_CHANNEL_B_PRIMARY) == 0) {\n\t\t/* make IS_SCSIBUS_B() == false, while probing channel A */\n\t\tahc->sc_link_b.scsibus = 0xff;\n\n\t\tconfig_found((void *)ahc, &ahc->sc_link, scsiprint);\n\t\tif (ahc->features & AHC_TWIN)\n\t\t\tconfig_found((void *)ahc, &ahc->sc_link_b, scsiprint);\n\t} else {\n\t\t/*\n\t\t * if implementation of IS_SCSIBUS_B() is changed to use\n\t\t * ahc->sc_link.scsibus, then \"ahc->sc_link.scsibus = 0xff;\"\n\t\t * is needed, here.\n\t\t */\n\n\t\t/* assert(ahc->features & AHC_TWIN); */\n\t\tconfig_found((void *)ahc, &ahc->sc_link_b, scsiprint);\n\t\tconfig_found((void *)ahc, &ahc->sc_link, scsiprint);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "opri"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "opri"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_free",
          "args": [
            "ahc"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_freeze_devq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "4434-4450",
          "snippet": "STATIC void\nahc_freeze_devq(ahc, sc_link)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_link *sc_link;\n{\n\tint\ttarget;\n\tchar\tchannel;\n\tint\tlun;\n\n\ttarget = sc_link->target;\n\tlun = sc_link->lun;\n\tchannel = SIM_CHANNEL(ahc, sc_link);\n\t\n\tahc_search_qinfifo(ahc, target, channel, lun,\n\t\t\t   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,\n\t\t\t   SCB_REQUEUE, SEARCH_COMPLETE);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_freeze_devq(ahc, sc_link)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_link *sc_link;\n{\n\tint\ttarget;\n\tchar\tchannel;\n\tint\tlun;\n\n\ttarget = sc_link->target;\n\tlun = sc_link->lun;\n\tchannel = SIM_CHANNEL(ahc, sc_link);\n\t\n\tahc_search_qinfifo(ahc, target, channel, lun,\n\t\t\t   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,\n\t\t\t   SCB_REQUEUE, SEARCH_COMPLETE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_init",
          "args": [
            "ahc"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "3564-3953",
          "snippet": "int\nahc_init(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tint\t  max_targ = 15;\n\tint\t  i;\n\tint\t  term;\n\tu_int\t  scsi_conf;\n\tu_int\t  scsiseq_template;\n\tu_int\t  ultraenb;\n\tu_int\t  discenable;\n\tu_int\t  tagenable;\n\tsize_t\t  driver_data_size;\n\tu_int32_t physaddr;\n\tstruct scb_data *scb_data = NULL;\n\n#ifdef AHC_PRINT_SRAM\n\tprintf(\"Scratch Ram:\");\n\tfor (i = 0x20; i < 0x5f; i++) {\n\t\tif (((i % 8) == 0) && (i != 0)) {\n\t\t\tprintf (\"\\n              \");\n\t\t}\n\t\tprintf (\" 0x%x\", ahc_inb(ahc, i));\n\t}\n\tif ((ahc->features & AHC_MORE_SRAM) != 0) {\n\t\tfor (i = 0x70; i < 0x7f; i++) {\n\t\t\tif (((i % 8) == 0) && (i != 0)) {\n\t\t\t\tprintf (\"\\n              \");\n\t\t\t}\n\t\t\tprintf (\" 0x%x\", ahc_inb(ahc, i));\n\t\t}\n\t}\n\tprintf (\"\\n\");\n#endif\n\n\tif (ahc->scb_data == NULL) {\n\t\tscb_data = malloc(sizeof (struct scb_data), M_DEVBUF, M_NOWAIT);\n\t\tif (scb_data == NULL) {\n\t\t\tprintf(\"%s: cannot malloc scb_data!\\n\", ahc_name(ahc));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\tbzero(scb_data, sizeof(struct scb_data));\n\t\tahc->scb_data = scb_data;\n\t}\n\t/*\n\t * Assume we have a board at this stage and it has been reset.\n\t */\n\tif ((ahc->flags & AHC_USEDEFAULTS) != 0)\n\t\tahc->our_id = ahc->our_id_b = 7;\n\t\n\t/*\n\t * Default to allowing initiator operations.\n\t */\n\tahc->flags |= AHC_INITIATORMODE;\n\t\n\t/*\n\t * DMA tag for our command fifos and other data in system memory\n\t * the card's sequencer must be able to access.  For initiator\n\t * roles, we need to allocate space for the qinfifo, qoutfifo,\n\t * and untagged_scb arrays each of which are composed of 256\n\t * 1 byte elements.  When providing for the target mode role,\n\t * we additionally must provide space for the incoming target\n\t * command fifo.\n\t */\n\tdriver_data_size = 3 * 256 * sizeof(u_int8_t);\n\n\tif (ahc_createdmamem(ahc, driver_data_size, \n\t    &ahc->shared_data_dmamap, (caddr_t *)&ahc->qoutfifo,\n\t    &ahc->shared_data_busaddr, &ahc->shared_data_seg,\n\t    &ahc->shared_data_nseg, \"shared data\") < 0)\n\t\treturn (ENOMEM);\n\n\tahc->init_level++;\n\n\t/* Allocate SCB data now that sc_dmat is initialized */\n\tif (ahc->scb_data->maxhscbs == 0)\n\t\tif (ahcinitscbdata(ahc) != 0)\n\t\t\treturn (ENOMEM);\n\n\tahc->qinfifo = &ahc->qoutfifo[256];\n\tahc->untagged_scbs = &ahc->qinfifo[256];\n\t/* There are no untagged SCBs active yet. */\n\tfor (i = 0; i < 256; i++)\n\t\tahc->untagged_scbs[i] = SCB_LIST_NULL;\n\n\t/* All of our queues are empty */\n\tfor (i = 0; i < 256; i++)\n\t\tahc->qoutfifo[i] = SCB_LIST_NULL;\n\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap,\n\t\t\tBUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\n\t\n\t/*\n\t * Allocate a tstate to house information for our\n\t * initiator presence on the bus as well as the user\n\t * data for any target mode initiator.\n\t */\n\tif (ahc_alloc_tstate(ahc, ahc->our_id, 'A') == NULL) {\n\t\tprintf(\"%s: unable to allocate tmode_tstate.  \"\n\t\t       \"Failing attach\\n\", ahc_name(ahc));\n\t\treturn (-1);\n\t}\n\n\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\tif (ahc_alloc_tstate(ahc, ahc->our_id_b, 'B') == NULL) {\n\t\t\tprintf(\"%s: unable to allocate tmode_tstate.  \"\n\t\t\t       \"Failing attach\\n\", ahc_name(ahc));\n\t\t\treturn (-1);\n\t\t}\n \t\tprintf(\"Twin Channel, A SCSI Id=%d, B SCSI Id=%d, primary %c, \",\n\t\t       ahc->our_id, ahc->our_id_b,\n\t\t       ahc->flags & AHC_CHANNEL_B_PRIMARY? 'B': 'A');\n\t} else {\n\t\tif ((ahc->features & AHC_WIDE) != 0) {\n\t\t\tprintf(\"Wide \");\n\t\t} else {\n\t\t\tprintf(\"Single \");\n\t\t}\n\t\tprintf(\"Channel %c, SCSI Id=%d, \", ahc->channel, ahc->our_id);\n\t}\n\n\tahc_outb(ahc, SEQ_FLAGS, 0);\n\n\tif (ahc->scb_data->maxhscbs < AHC_SCB_MAX) {\n\t\tahc->flags |= AHC_PAGESCBS;\n\t\tprintf(\"%d/%d SCBs\\n\", ahc->scb_data->maxhscbs, AHC_SCB_MAX);\n\t} else {\n\t\tahc->flags &= ~AHC_PAGESCBS;\n\t\tprintf(\"%d SCBs\\n\", ahc->scb_data->maxhscbs);\n\t}\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWMISC) {\n\t\tprintf(\"%s: hardware scb %d bytes; kernel scb %d bytes; \"\n\t\t       \"ahc_dma %d bytes\\n\",\n\t\t\tahc_name(ahc),\n\t\t        sizeof(struct hardware_scb),\n\t\t\tsizeof(struct scb),\n\t\t\tsizeof(struct ahc_dma_seg));\n\t}\n#endif /* AHC_DEBUG */\n\n\t/* Set the SCSI Id,SXFRCTL0,SXFRCTL1, and SIMODE1, for both channels*/\n\tif (ahc->features & AHC_TWIN) {\n\n\t\t/*\n\t\t * The device is gated to channel B after a chip reset,\n\t\t * so set those values first\n\t\t */\n\t\tterm = (ahc->flags & AHC_TERM_ENB_B) != 0 ? STPWEN : 0;\n\t\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\t\tahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id_b);\n\t\telse\n\t\t\tahc_outb(ahc, SCSIID, ahc->our_id_b);\n\t\tscsi_conf = ahc_inb(ahc, SCSICONF + 1);\n\t\tahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))\n\t\t\t\t\t|term|ENSTIMER|ACTNEGEN);\n\t\tahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);\n\t\tahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);\n\n\t\tif ((scsi_conf & RESET_SCSI) != 0\n\t\t && (ahc->flags & AHC_INITIATORMODE) != 0)\n\t\t\tahc->flags |= AHC_RESET_BUS_B;\n\n\t\t/* Select Channel A */\n\t\tahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);\n\t}\n\tterm = (ahc->flags & AHC_TERM_ENB_A) != 0 ? STPWEN : 0;\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id);\n\telse\n\t\tahc_outb(ahc, SCSIID, ahc->our_id);\n\tscsi_conf = ahc_inb(ahc, SCSICONF);\n\tahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))\n\t\t\t\t|term\n\t\t\t\t|ENSTIMER|ACTNEGEN);\n\tahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);\n\tahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);\n\n\tif ((scsi_conf & RESET_SCSI) != 0\n\t && (ahc->flags & AHC_INITIATORMODE) != 0)\n\t\tahc->flags |= AHC_RESET_BUS_A;\n\n\t/*\n\t * Look at the information that board initialization or\n\t * the board bios has left us.\n\t */\n\tultraenb = 0;\t\n\ttagenable = ALL_TARGETS_MASK;\n\n\t/* Grab the disconnection disable table and invert it for our needs */\n\tif (ahc->flags & AHC_USEDEFAULTS) {\n\t\tprintf(\"%s: Host Adapter Bios disabled.  Using default SCSI \"\n\t\t\t\"device parameters\\n\", ahc_name(ahc));\n\t\tahc->flags |= AHC_EXTENDED_TRANS_A|AHC_EXTENDED_TRANS_B|\n\t\t\t      AHC_TERM_ENB_A|AHC_TERM_ENB_B;\n\t\tdiscenable = ALL_TARGETS_MASK;\n\t\tif ((ahc->features & AHC_ULTRA) != 0)\n\t\t\tultraenb = ALL_TARGETS_MASK;\n\t} else {\n\t\tdiscenable = ~((ahc_inb(ahc, DISC_DSB + 1) << 8)\n\t\t\t   | ahc_inb(ahc, DISC_DSB));\n\t\tif ((ahc->features & (AHC_ULTRA|AHC_ULTRA2)) != 0)\n\t\t\tultraenb = (ahc_inb(ahc, ULTRA_ENB + 1) << 8)\n\t\t\t\t      | ahc_inb(ahc, ULTRA_ENB);\n\t}\n\n\tif ((ahc->features & (AHC_WIDE|AHC_TWIN)) == 0)\n\t\tmax_targ = 7;\n\n\tfor (i = 0; i <= max_targ; i++) {\n\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\tstruct tmode_tstate *tstate;\n\t\tu_int our_id;\n\t\tu_int target_id;\n\t\tchar channel;\n\n\t\tchannel = 'A';\n\t\tour_id = ahc->our_id;\n\t\ttarget_id = i;\n\t\tif (i > 7 && (ahc->features & AHC_TWIN) != 0) {\n\t\t\tchannel = 'B';\n\t\t\tour_id = ahc->our_id_b;\n\t\t\ttarget_id = i % 8;\n\t\t}\n\t\ttinfo = ahc_fetch_transinfo(ahc, channel, our_id,\n\t\t\t\t\t    target_id, &tstate);\n\t\t/* Default to async narrow across the board */\n\t\tbzero(tinfo, sizeof(*tinfo));\n\t\tif (ahc->flags & AHC_USEDEFAULTS) {\n\t\t\tif ((ahc->features & AHC_WIDE) != 0)\n\t\t\t\ttinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;\n\n\t\t\t/*\n\t\t\t * These will be truncated when we determine the\n\t\t\t * connection type we have with the target.\n\t\t\t */\n\t\t\ttinfo->user.period = ahc_syncrates->period;\n\t\t\ttinfo->user.offset = ~0;\n\t\t} else {\n\t\t\tu_int scsirate;\n\t\t\tu_int16_t mask;\n\n\t\t\t/* Take the settings leftover in scratch RAM. */\n\t\t\tscsirate = ahc_inb(ahc, TARG_SCSIRATE + i);\n\t\t\tmask = (0x01 << i);\n\t\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\t\tu_int offset;\n\t\t\t\tu_int maxsync;\n\n\t\t\t\tif ((scsirate & SOFS) == 0x0F) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Haven't negotiated yet,\n\t\t\t\t\t * so the format is different.\n\t\t\t\t\t */\n\t\t\t\t\tscsirate = (scsirate & SXFR) >> 4\n\t\t\t\t\t\t | (ultraenb & mask)\n\t\t\t\t\t\t  ? 0x08 : 0x0\n\t\t\t\t\t\t | (scsirate & WIDEXFER);\n\t\t\t\t\toffset = MAX_OFFSET_ULTRA2;\n\t\t\t\t} else\n\t\t\t\t\toffset = ahc_inb(ahc, TARG_OFFSET + i);\n\t\t\t\tmaxsync = AHC_SYNCRATE_ULTRA2;\n\t\t\t\tif ((ahc->features & AHC_DT) != 0)\n\t\t\t\t\tmaxsync = AHC_SYNCRATE_DT;\n\t\t\t\ttinfo->user.period =\n\t\t\t\t    ahc_find_period(ahc, scsirate, maxsync);\n\t\t\t\tif (offset == 0)\n\t\t\t\t\ttinfo->user.period = 0;\n\t\t\t\telse\n\t\t\t\t\ttinfo->user.offset = ~0;\n\t\t\t} else if ((scsirate & SOFS) != 0) {\n\t\t\t\ttinfo->user.period = \n\t\t\t\t    ahc_find_period(ahc, scsirate,\n\t\t\t\t\t\t    (ultraenb & mask)\n\t\t\t\t\t\t   ? AHC_SYNCRATE_ULTRA\n\t\t\t\t\t\t   : AHC_SYNCRATE_FAST);\n\t\t\t\tif (tinfo->user.period != 0)\n\t\t\t\t\ttinfo->user.offset = ~0;\n\t\t\t}\n\t\t\tif ((scsirate & WIDEXFER) != 0\n\t\t\t && (ahc->features & AHC_WIDE) != 0)\n\t\t\t\ttinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;\n\t\t}\n\t\ttinfo->goal = tinfo->user; /* force negotiation */\n\t\ttstate->ultraenb = ultraenb;\n\t\ttstate->discenable = discenable;\n\t\ttstate->tagenable = 0; /* Wait until the XPT says its okay */\n\t}\n\tahc->user_discenable = discenable;\n\tahc->user_tagenable = tagenable;\n\n\t/*\n\t * Tell the sequencer where it can find our arrays in memory.\n\t */\n\tphysaddr = ahc->scb_data->hscb_busaddr;\n\tahc_outb(ahc, HSCB_ADDR, physaddr & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 1, (physaddr >> 8) & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 2, (physaddr >> 16) & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 3, (physaddr >> 24) & 0xFF);\n\n\tphysaddr = ahc->shared_data_busaddr;\n\tahc_outb(ahc, SCBID_ADDR, physaddr & 0xFF);\n\tahc_outb(ahc, SCBID_ADDR + 1, (physaddr >> 8) & 0xFF);\n\tahc_outb(ahc, SCBID_ADDR + 2, (physaddr >> 16) & 0xFF);\n\tahc_outb(ahc, SCBID_ADDR + 3, (physaddr >> 24) & 0xFF);\n\n\t/* Target mode incomding command fifo */\n\tphysaddr += 3 * 256 * sizeof(u_int8_t);\n\tahc_outb(ahc, TMODE_CMDADDR, physaddr & 0xFF);\n\tahc_outb(ahc, TMODE_CMDADDR + 1, (physaddr >> 8) & 0xFF);\n\tahc_outb(ahc, TMODE_CMDADDR + 2, (physaddr >> 16) & 0xFF);\n\tahc_outb(ahc, TMODE_CMDADDR + 3, (physaddr >> 24) & 0xFF);\n\n\t/*\n\t * Initialize the group code to command length table.\n\t * This overrides the values in TARG_SCSIRATE, so only\n\t * setup the table after we have processed that information.\n\t */\n\tahc_outb(ahc, CMDSIZE_TABLE, 5);\n\tahc_outb(ahc, CMDSIZE_TABLE + 1, 9);\n\tahc_outb(ahc, CMDSIZE_TABLE + 2, 9);\n\tahc_outb(ahc, CMDSIZE_TABLE + 3, 0);\n\tahc_outb(ahc, CMDSIZE_TABLE + 4, 15);\n\tahc_outb(ahc, CMDSIZE_TABLE + 5, 11);\n\tahc_outb(ahc, CMDSIZE_TABLE + 6, 0);\n\tahc_outb(ahc, CMDSIZE_TABLE + 7, 0);\n\t\t\n\t/* Tell the sequencer of our initial queue positions */\n\tahc_outb(ahc, KERNEL_QINPOS, 0);\n\tahc_outb(ahc, QINPOS, 0);\n\tahc_outb(ahc, QOUTPOS, 0);\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWMISC)\n\t\tprintf(\"NEEDSDTR == 0x%x\\nNEEDWDTR == 0x%x\\n\"\n\t\t       \"DISCENABLE == 0x%x\\nULTRAENB == 0x%x\\n\",\n\t\t       ahc->needsdtr_orig, ahc->needwdtr_orig,\n\t\t       discenable, ultraenb);\n#endif\n\n\t/* Don't have any special messages to send to targets */\n\tahc_outb(ahc, TARGET_MSG_REQUEST, 0);\n\tahc_outb(ahc, TARGET_MSG_REQUEST + 1, 0);\n\n\t/*\n\t * Use the built in queue management registers\n\t * if they are available.\n\t */\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, QOFF_CTLSTA, SCB_QSIZE_256);\n\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t\tahc_outb(ahc, SNSCB_QOFF, 0);\n\t\tahc_outb(ahc, HNSCB_QOFF, 0);\n\t}\n\n\n\t/* We don't have any waiting selections */\n\tahc_outb(ahc, WAITING_SCBH, SCB_LIST_NULL);\n\n\t/* Our disconnection list is empty too */\n\tahc_outb(ahc, DISCONNECTED_SCBH, SCB_LIST_NULL);\n\n\t/* Message out buffer starts empty */\n\tahc_outb(ahc, MSG_OUT, MSG_NOOP);\n\n\t/*\n\t * Setup the allowed SCSI Sequences based on operational mode.\n\t * If we are a target, we'll enalbe select in operations once\n\t * we've had a lun enabled.\n\t */\n\tscsiseq_template = ENSELO|ENAUTOATNO|ENAUTOATNP;\n\tif ((ahc->flags & AHC_INITIATORMODE) != 0)\n\t\tscsiseq_template |= ENRSELI;\n\tahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq_template);\n\n\t/*\n\t * Load the Sequencer program and Enable the adapter\n\t * in \"fast\" mode.\n         */\n\tif (bootverbose)\n\t\tprintf(\"%s: Downloading Sequencer Program...\",\n\t\t       ahc_name(ahc));\n\n\tahc_loadseq(ahc);\n\n\t/* We have to wait until after any system dumps... */\n\tshutdownhook_establish(ahc_shutdown, ahc);\n\treturn (0);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define AHC_SYNCRATE_FAST\t6",
            "#define AHC_SYNCRATE_ULTRA\t3",
            "#define AHC_SYNCRATE_ULTRA2\t1",
            "#define AHC_SYNCRATE_DT\t\t0",
            "#define bootverbose\t0",
            "#define bootverbose\t1",
            "#define ALL_TARGETS_MASK 0xFFFF"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahc_poll __P((struct ahc_softc *ahc, int wait));",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC struct",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC u_int",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "ahc_find_period __P((struct ahc_softc *ahc, u_int scsirate,\n\t\t\t\t  u_int maxsync));",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "ahc_calc_residual __P((struct scb *scb));",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "int    ahc_createdmamem",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "u_int our_id;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "static struct ahc_syncrate ahc_syncrates[] = {\n      /* ultra2    fast/ultra  period     rate */\n\t{ 0x42,      0x000,      9,      \"80.0\" },\n\t{ 0x03,      0x000,     10,      \"40.0\" },\n\t{ 0x04,      0x000,     11,      \"33.0\" },\n\t{ 0x05,      0x100,     12,      \"20.0\" },\n\t{ 0x06,      0x110,     15,      \"16.0\" },\n\t{ 0x07,      0x120,     18,      \"13.4\" },\n\t{ 0x08,      0x000,     25,      \"10.0\" },\n\t{ 0x19,      0x010,     31,      \"8.0\"  },\n\t{ 0x1a,      0x020,     37,      \"6.67\" },\n\t{ 0x1b,      0x030,     43,      \"5.7\"  },\n\t{ 0x1c,      0x040,     50,      \"5.0\"  },\n\t{ 0x00,      0x050,     56,      \"4.4\"  },\n\t{ 0x00,      0x060,     62,      \"4.0\"  },\n\t{ 0x00,      0x070,     68,      \"3.6\"  },\n\t{ 0x00,      0x000,      0,      NULL   }\n};",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "u_int maxsync;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define AHC_SYNCRATE_FAST\t6\n#define AHC_SYNCRATE_ULTRA\t3\n#define AHC_SYNCRATE_ULTRA2\t1\n#define AHC_SYNCRATE_DT\t\t0\n#define bootverbose\t0\n#define bootverbose\t1\n#define ALL_TARGETS_MASK 0xFFFF\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_poll __P((struct ahc_softc *ahc, int wait));\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nahcallocscbs __P((struct ahc_softc *ahc));\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC struct;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC u_int;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nahc_find_period __P((struct ahc_softc *ahc, u_int scsirate,\n\t\t\t\t  u_int maxsync));\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nahc_calc_residual __P((struct scb *scb));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nint    ahc_createdmamem;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nu_int our_id;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nstatic struct ahc_syncrate ahc_syncrates[] = {\n      /* ultra2    fast/ultra  period     rate */\n\t{ 0x42,      0x000,      9,      \"80.0\" },\n\t{ 0x03,      0x000,     10,      \"40.0\" },\n\t{ 0x04,      0x000,     11,      \"33.0\" },\n\t{ 0x05,      0x100,     12,      \"20.0\" },\n\t{ 0x06,      0x110,     15,      \"16.0\" },\n\t{ 0x07,      0x120,     18,      \"13.4\" },\n\t{ 0x08,      0x000,     25,      \"10.0\" },\n\t{ 0x19,      0x010,     31,      \"8.0\"  },\n\t{ 0x1a,      0x020,     37,      \"6.67\" },\n\t{ 0x1b,      0x030,     43,      \"5.7\"  },\n\t{ 0x1c,      0x040,     50,      \"5.0\"  },\n\t{ 0x00,      0x050,     56,      \"4.4\"  },\n\t{ 0x00,      0x060,     62,      \"4.0\"  },\n\t{ 0x00,      0x070,     68,      \"3.6\"  },\n\t{ 0x00,      0x000,      0,      NULL   }\n};\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nu_int maxsync;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nint\nahc_init(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tint\t  max_targ = 15;\n\tint\t  i;\n\tint\t  term;\n\tu_int\t  scsi_conf;\n\tu_int\t  scsiseq_template;\n\tu_int\t  ultraenb;\n\tu_int\t  discenable;\n\tu_int\t  tagenable;\n\tsize_t\t  driver_data_size;\n\tu_int32_t physaddr;\n\tstruct scb_data *scb_data = NULL;\n\n#ifdef AHC_PRINT_SRAM\n\tprintf(\"Scratch Ram:\");\n\tfor (i = 0x20; i < 0x5f; i++) {\n\t\tif (((i % 8) == 0) && (i != 0)) {\n\t\t\tprintf (\"\\n              \");\n\t\t}\n\t\tprintf (\" 0x%x\", ahc_inb(ahc, i));\n\t}\n\tif ((ahc->features & AHC_MORE_SRAM) != 0) {\n\t\tfor (i = 0x70; i < 0x7f; i++) {\n\t\t\tif (((i % 8) == 0) && (i != 0)) {\n\t\t\t\tprintf (\"\\n              \");\n\t\t\t}\n\t\t\tprintf (\" 0x%x\", ahc_inb(ahc, i));\n\t\t}\n\t}\n\tprintf (\"\\n\");\n#endif\n\n\tif (ahc->scb_data == NULL) {\n\t\tscb_data = malloc(sizeof (struct scb_data), M_DEVBUF, M_NOWAIT);\n\t\tif (scb_data == NULL) {\n\t\t\tprintf(\"%s: cannot malloc scb_data!\\n\", ahc_name(ahc));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\tbzero(scb_data, sizeof(struct scb_data));\n\t\tahc->scb_data = scb_data;\n\t}\n\t/*\n\t * Assume we have a board at this stage and it has been reset.\n\t */\n\tif ((ahc->flags & AHC_USEDEFAULTS) != 0)\n\t\tahc->our_id = ahc->our_id_b = 7;\n\t\n\t/*\n\t * Default to allowing initiator operations.\n\t */\n\tahc->flags |= AHC_INITIATORMODE;\n\t\n\t/*\n\t * DMA tag for our command fifos and other data in system memory\n\t * the card's sequencer must be able to access.  For initiator\n\t * roles, we need to allocate space for the qinfifo, qoutfifo,\n\t * and untagged_scb arrays each of which are composed of 256\n\t * 1 byte elements.  When providing for the target mode role,\n\t * we additionally must provide space for the incoming target\n\t * command fifo.\n\t */\n\tdriver_data_size = 3 * 256 * sizeof(u_int8_t);\n\n\tif (ahc_createdmamem(ahc, driver_data_size, \n\t    &ahc->shared_data_dmamap, (caddr_t *)&ahc->qoutfifo,\n\t    &ahc->shared_data_busaddr, &ahc->shared_data_seg,\n\t    &ahc->shared_data_nseg, \"shared data\") < 0)\n\t\treturn (ENOMEM);\n\n\tahc->init_level++;\n\n\t/* Allocate SCB data now that sc_dmat is initialized */\n\tif (ahc->scb_data->maxhscbs == 0)\n\t\tif (ahcinitscbdata(ahc) != 0)\n\t\t\treturn (ENOMEM);\n\n\tahc->qinfifo = &ahc->qoutfifo[256];\n\tahc->untagged_scbs = &ahc->qinfifo[256];\n\t/* There are no untagged SCBs active yet. */\n\tfor (i = 0; i < 256; i++)\n\t\tahc->untagged_scbs[i] = SCB_LIST_NULL;\n\n\t/* All of our queues are empty */\n\tfor (i = 0; i < 256; i++)\n\t\tahc->qoutfifo[i] = SCB_LIST_NULL;\n\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap,\n\t\t\tBUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\n\t\n\t/*\n\t * Allocate a tstate to house information for our\n\t * initiator presence on the bus as well as the user\n\t * data for any target mode initiator.\n\t */\n\tif (ahc_alloc_tstate(ahc, ahc->our_id, 'A') == NULL) {\n\t\tprintf(\"%s: unable to allocate tmode_tstate.  \"\n\t\t       \"Failing attach\\n\", ahc_name(ahc));\n\t\treturn (-1);\n\t}\n\n\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\tif (ahc_alloc_tstate(ahc, ahc->our_id_b, 'B') == NULL) {\n\t\t\tprintf(\"%s: unable to allocate tmode_tstate.  \"\n\t\t\t       \"Failing attach\\n\", ahc_name(ahc));\n\t\t\treturn (-1);\n\t\t}\n \t\tprintf(\"Twin Channel, A SCSI Id=%d, B SCSI Id=%d, primary %c, \",\n\t\t       ahc->our_id, ahc->our_id_b,\n\t\t       ahc->flags & AHC_CHANNEL_B_PRIMARY? 'B': 'A');\n\t} else {\n\t\tif ((ahc->features & AHC_WIDE) != 0) {\n\t\t\tprintf(\"Wide \");\n\t\t} else {\n\t\t\tprintf(\"Single \");\n\t\t}\n\t\tprintf(\"Channel %c, SCSI Id=%d, \", ahc->channel, ahc->our_id);\n\t}\n\n\tahc_outb(ahc, SEQ_FLAGS, 0);\n\n\tif (ahc->scb_data->maxhscbs < AHC_SCB_MAX) {\n\t\tahc->flags |= AHC_PAGESCBS;\n\t\tprintf(\"%d/%d SCBs\\n\", ahc->scb_data->maxhscbs, AHC_SCB_MAX);\n\t} else {\n\t\tahc->flags &= ~AHC_PAGESCBS;\n\t\tprintf(\"%d SCBs\\n\", ahc->scb_data->maxhscbs);\n\t}\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWMISC) {\n\t\tprintf(\"%s: hardware scb %d bytes; kernel scb %d bytes; \"\n\t\t       \"ahc_dma %d bytes\\n\",\n\t\t\tahc_name(ahc),\n\t\t        sizeof(struct hardware_scb),\n\t\t\tsizeof(struct scb),\n\t\t\tsizeof(struct ahc_dma_seg));\n\t}\n#endif /* AHC_DEBUG */\n\n\t/* Set the SCSI Id,SXFRCTL0,SXFRCTL1, and SIMODE1, for both channels*/\n\tif (ahc->features & AHC_TWIN) {\n\n\t\t/*\n\t\t * The device is gated to channel B after a chip reset,\n\t\t * so set those values first\n\t\t */\n\t\tterm = (ahc->flags & AHC_TERM_ENB_B) != 0 ? STPWEN : 0;\n\t\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\t\tahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id_b);\n\t\telse\n\t\t\tahc_outb(ahc, SCSIID, ahc->our_id_b);\n\t\tscsi_conf = ahc_inb(ahc, SCSICONF + 1);\n\t\tahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))\n\t\t\t\t\t|term|ENSTIMER|ACTNEGEN);\n\t\tahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);\n\t\tahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);\n\n\t\tif ((scsi_conf & RESET_SCSI) != 0\n\t\t && (ahc->flags & AHC_INITIATORMODE) != 0)\n\t\t\tahc->flags |= AHC_RESET_BUS_B;\n\n\t\t/* Select Channel A */\n\t\tahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);\n\t}\n\tterm = (ahc->flags & AHC_TERM_ENB_A) != 0 ? STPWEN : 0;\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id);\n\telse\n\t\tahc_outb(ahc, SCSIID, ahc->our_id);\n\tscsi_conf = ahc_inb(ahc, SCSICONF);\n\tahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))\n\t\t\t\t|term\n\t\t\t\t|ENSTIMER|ACTNEGEN);\n\tahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);\n\tahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);\n\n\tif ((scsi_conf & RESET_SCSI) != 0\n\t && (ahc->flags & AHC_INITIATORMODE) != 0)\n\t\tahc->flags |= AHC_RESET_BUS_A;\n\n\t/*\n\t * Look at the information that board initialization or\n\t * the board bios has left us.\n\t */\n\tultraenb = 0;\t\n\ttagenable = ALL_TARGETS_MASK;\n\n\t/* Grab the disconnection disable table and invert it for our needs */\n\tif (ahc->flags & AHC_USEDEFAULTS) {\n\t\tprintf(\"%s: Host Adapter Bios disabled.  Using default SCSI \"\n\t\t\t\"device parameters\\n\", ahc_name(ahc));\n\t\tahc->flags |= AHC_EXTENDED_TRANS_A|AHC_EXTENDED_TRANS_B|\n\t\t\t      AHC_TERM_ENB_A|AHC_TERM_ENB_B;\n\t\tdiscenable = ALL_TARGETS_MASK;\n\t\tif ((ahc->features & AHC_ULTRA) != 0)\n\t\t\tultraenb = ALL_TARGETS_MASK;\n\t} else {\n\t\tdiscenable = ~((ahc_inb(ahc, DISC_DSB + 1) << 8)\n\t\t\t   | ahc_inb(ahc, DISC_DSB));\n\t\tif ((ahc->features & (AHC_ULTRA|AHC_ULTRA2)) != 0)\n\t\t\tultraenb = (ahc_inb(ahc, ULTRA_ENB + 1) << 8)\n\t\t\t\t      | ahc_inb(ahc, ULTRA_ENB);\n\t}\n\n\tif ((ahc->features & (AHC_WIDE|AHC_TWIN)) == 0)\n\t\tmax_targ = 7;\n\n\tfor (i = 0; i <= max_targ; i++) {\n\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\tstruct tmode_tstate *tstate;\n\t\tu_int our_id;\n\t\tu_int target_id;\n\t\tchar channel;\n\n\t\tchannel = 'A';\n\t\tour_id = ahc->our_id;\n\t\ttarget_id = i;\n\t\tif (i > 7 && (ahc->features & AHC_TWIN) != 0) {\n\t\t\tchannel = 'B';\n\t\t\tour_id = ahc->our_id_b;\n\t\t\ttarget_id = i % 8;\n\t\t}\n\t\ttinfo = ahc_fetch_transinfo(ahc, channel, our_id,\n\t\t\t\t\t    target_id, &tstate);\n\t\t/* Default to async narrow across the board */\n\t\tbzero(tinfo, sizeof(*tinfo));\n\t\tif (ahc->flags & AHC_USEDEFAULTS) {\n\t\t\tif ((ahc->features & AHC_WIDE) != 0)\n\t\t\t\ttinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;\n\n\t\t\t/*\n\t\t\t * These will be truncated when we determine the\n\t\t\t * connection type we have with the target.\n\t\t\t */\n\t\t\ttinfo->user.period = ahc_syncrates->period;\n\t\t\ttinfo->user.offset = ~0;\n\t\t} else {\n\t\t\tu_int scsirate;\n\t\t\tu_int16_t mask;\n\n\t\t\t/* Take the settings leftover in scratch RAM. */\n\t\t\tscsirate = ahc_inb(ahc, TARG_SCSIRATE + i);\n\t\t\tmask = (0x01 << i);\n\t\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\t\tu_int offset;\n\t\t\t\tu_int maxsync;\n\n\t\t\t\tif ((scsirate & SOFS) == 0x0F) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Haven't negotiated yet,\n\t\t\t\t\t * so the format is different.\n\t\t\t\t\t */\n\t\t\t\t\tscsirate = (scsirate & SXFR) >> 4\n\t\t\t\t\t\t | (ultraenb & mask)\n\t\t\t\t\t\t  ? 0x08 : 0x0\n\t\t\t\t\t\t | (scsirate & WIDEXFER);\n\t\t\t\t\toffset = MAX_OFFSET_ULTRA2;\n\t\t\t\t} else\n\t\t\t\t\toffset = ahc_inb(ahc, TARG_OFFSET + i);\n\t\t\t\tmaxsync = AHC_SYNCRATE_ULTRA2;\n\t\t\t\tif ((ahc->features & AHC_DT) != 0)\n\t\t\t\t\tmaxsync = AHC_SYNCRATE_DT;\n\t\t\t\ttinfo->user.period =\n\t\t\t\t    ahc_find_period(ahc, scsirate, maxsync);\n\t\t\t\tif (offset == 0)\n\t\t\t\t\ttinfo->user.period = 0;\n\t\t\t\telse\n\t\t\t\t\ttinfo->user.offset = ~0;\n\t\t\t} else if ((scsirate & SOFS) != 0) {\n\t\t\t\ttinfo->user.period = \n\t\t\t\t    ahc_find_period(ahc, scsirate,\n\t\t\t\t\t\t    (ultraenb & mask)\n\t\t\t\t\t\t   ? AHC_SYNCRATE_ULTRA\n\t\t\t\t\t\t   : AHC_SYNCRATE_FAST);\n\t\t\t\tif (tinfo->user.period != 0)\n\t\t\t\t\ttinfo->user.offset = ~0;\n\t\t\t}\n\t\t\tif ((scsirate & WIDEXFER) != 0\n\t\t\t && (ahc->features & AHC_WIDE) != 0)\n\t\t\t\ttinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;\n\t\t}\n\t\ttinfo->goal = tinfo->user; /* force negotiation */\n\t\ttstate->ultraenb = ultraenb;\n\t\ttstate->discenable = discenable;\n\t\ttstate->tagenable = 0; /* Wait until the XPT says its okay */\n\t}\n\tahc->user_discenable = discenable;\n\tahc->user_tagenable = tagenable;\n\n\t/*\n\t * Tell the sequencer where it can find our arrays in memory.\n\t */\n\tphysaddr = ahc->scb_data->hscb_busaddr;\n\tahc_outb(ahc, HSCB_ADDR, physaddr & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 1, (physaddr >> 8) & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 2, (physaddr >> 16) & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 3, (physaddr >> 24) & 0xFF);\n\n\tphysaddr = ahc->shared_data_busaddr;\n\tahc_outb(ahc, SCBID_ADDR, physaddr & 0xFF);\n\tahc_outb(ahc, SCBID_ADDR + 1, (physaddr >> 8) & 0xFF);\n\tahc_outb(ahc, SCBID_ADDR + 2, (physaddr >> 16) & 0xFF);\n\tahc_outb(ahc, SCBID_ADDR + 3, (physaddr >> 24) & 0xFF);\n\n\t/* Target mode incomding command fifo */\n\tphysaddr += 3 * 256 * sizeof(u_int8_t);\n\tahc_outb(ahc, TMODE_CMDADDR, physaddr & 0xFF);\n\tahc_outb(ahc, TMODE_CMDADDR + 1, (physaddr >> 8) & 0xFF);\n\tahc_outb(ahc, TMODE_CMDADDR + 2, (physaddr >> 16) & 0xFF);\n\tahc_outb(ahc, TMODE_CMDADDR + 3, (physaddr >> 24) & 0xFF);\n\n\t/*\n\t * Initialize the group code to command length table.\n\t * This overrides the values in TARG_SCSIRATE, so only\n\t * setup the table after we have processed that information.\n\t */\n\tahc_outb(ahc, CMDSIZE_TABLE, 5);\n\tahc_outb(ahc, CMDSIZE_TABLE + 1, 9);\n\tahc_outb(ahc, CMDSIZE_TABLE + 2, 9);\n\tahc_outb(ahc, CMDSIZE_TABLE + 3, 0);\n\tahc_outb(ahc, CMDSIZE_TABLE + 4, 15);\n\tahc_outb(ahc, CMDSIZE_TABLE + 5, 11);\n\tahc_outb(ahc, CMDSIZE_TABLE + 6, 0);\n\tahc_outb(ahc, CMDSIZE_TABLE + 7, 0);\n\t\t\n\t/* Tell the sequencer of our initial queue positions */\n\tahc_outb(ahc, KERNEL_QINPOS, 0);\n\tahc_outb(ahc, QINPOS, 0);\n\tahc_outb(ahc, QOUTPOS, 0);\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWMISC)\n\t\tprintf(\"NEEDSDTR == 0x%x\\nNEEDWDTR == 0x%x\\n\"\n\t\t       \"DISCENABLE == 0x%x\\nULTRAENB == 0x%x\\n\",\n\t\t       ahc->needsdtr_orig, ahc->needwdtr_orig,\n\t\t       discenable, ultraenb);\n#endif\n\n\t/* Don't have any special messages to send to targets */\n\tahc_outb(ahc, TARGET_MSG_REQUEST, 0);\n\tahc_outb(ahc, TARGET_MSG_REQUEST + 1, 0);\n\n\t/*\n\t * Use the built in queue management registers\n\t * if they are available.\n\t */\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, QOFF_CTLSTA, SCB_QSIZE_256);\n\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t\tahc_outb(ahc, SNSCB_QOFF, 0);\n\t\tahc_outb(ahc, HNSCB_QOFF, 0);\n\t}\n\n\n\t/* We don't have any waiting selections */\n\tahc_outb(ahc, WAITING_SCBH, SCB_LIST_NULL);\n\n\t/* Our disconnection list is empty too */\n\tahc_outb(ahc, DISCONNECTED_SCBH, SCB_LIST_NULL);\n\n\t/* Message out buffer starts empty */\n\tahc_outb(ahc, MSG_OUT, MSG_NOOP);\n\n\t/*\n\t * Setup the allowed SCSI Sequences based on operational mode.\n\t * If we are a target, we'll enalbe select in operations once\n\t * we've had a lun enabled.\n\t */\n\tscsiseq_template = ENSELO|ENAUTOATNO|ENAUTOATNP;\n\tif ((ahc->flags & AHC_INITIATORMODE) != 0)\n\t\tscsiseq_template |= ENRSELI;\n\tahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq_template);\n\n\t/*\n\t * Load the Sequencer program and Enable the adapter\n\t * in \"fast\" mode.\n         */\n\tif (bootverbose)\n\t\tprintf(\"%s: Downloading Sequencer Program...\",\n\t\t       ahc_name(ahc));\n\n\tahc_loadseq(ahc);\n\n\t/* We have to wait until after any system dumps... */\n\tshutdownhook_establish(ahc_shutdown, ahc);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: \"",
            "ahc_name(ahc)"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_probe_ext_scbram",
          "args": [
            "ahc"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_probe_ext_scbram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
          "lines": "649-706",
          "snippet": "static void\nahc_probe_ext_scbram(ahc)\nstruct ahc_softc *ahc;\n{\n\tint num_scbs;\n\tint test_num_scbs;\n\tint enable;\n\tint pcheck;\n\tint fast;\n\n\tif (ahc_ext_scbram_present(ahc) == 0)\n\t\treturn;\n\n\t/*\n\t * Probe for the best parameters to use.\n\t */\n\tenable = 0;\n\tpcheck = 0;\n\tfast = 0;\n\tahc_ext_scbram_config(ahc,\t/*enable*/1, pcheck, fast);\n\tnum_scbs = ahc_probe_scbs(ahc);\n\tif (num_scbs == 0) {\n\t\t/* The SRAM wasn't really present. */\n\t\tgoto done;\n\t}\n\tenable = 1;\n\n\t/* Now see if we can do parity */\n\tahc_ext_scbram_config(ahc, enable, /*pcheck*/1, fast);\n\tnum_scbs = ahc_probe_scbs(ahc);\n\tif ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0\n\t\t || (ahc_inb(ahc, ERROR) & MPARERR) == 0)\n\t\tpcheck = 1;\n\n\t/* Clear any resulting parity error */\n\tahc_outb(ahc, CLRINT, CLRPARERR);\n\tahc_outb(ahc, CLRINT, CLRBRKADRINT);\n\n\t/* Now see if we can do fast timing */\n\tahc_ext_scbram_config(ahc, enable, pcheck, /*fast*/1);\n\ttest_num_scbs = ahc_probe_scbs(ahc);\n\tif (test_num_scbs == num_scbs\n\t\t && ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0\n\t\t\t  || (ahc_inb(ahc, ERROR) & MPARERR) == 0))\n\t\tfast = 1;\n\n\tdone:\n\t/* Clear any resulting parity error */\n\tahc_outb(ahc, CLRINT, CLRPARERR);\n\tahc_outb(ahc, CLRINT, CLRBRKADRINT);\n\tif (bootverbose && enable) {\n\t\tprintf(\"%s: External SRAM, %dns access%s\\n\",\n\t\t\t\t ahc_name(ahc), fast ? 10 : 20,\n\t\t\t\t pcheck ? \", parity checking enabled\" : \"\");\n\n\t}\n\tahc_ext_scbram_config(ahc, enable, pcheck, fast);\n}",
          "includes": [
            "#include <dev/ic/smc93cx6var.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define bootverbose\t0",
            "#define bootverbose\t1"
          ],
          "globals_used": [
            "static int  ahc_ext_scbram_present",
            "static void ahc_ext_scbram_config",
            "static void ahc_probe_ext_scbram",
            "int ahc_probe_scbs"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define bootverbose\t0\n#define bootverbose\t1\n\nstatic int  ahc_ext_scbram_present;\nstatic void ahc_ext_scbram_config;\nstatic void ahc_probe_ext_scbram;\nint ahc_probe_scbs;\n\nstatic void\nahc_probe_ext_scbram(ahc)\nstruct ahc_softc *ahc;\n{\n\tint num_scbs;\n\tint test_num_scbs;\n\tint enable;\n\tint pcheck;\n\tint fast;\n\n\tif (ahc_ext_scbram_present(ahc) == 0)\n\t\treturn;\n\n\t/*\n\t * Probe for the best parameters to use.\n\t */\n\tenable = 0;\n\tpcheck = 0;\n\tfast = 0;\n\tahc_ext_scbram_config(ahc,\t/*enable*/1, pcheck, fast);\n\tnum_scbs = ahc_probe_scbs(ahc);\n\tif (num_scbs == 0) {\n\t\t/* The SRAM wasn't really present. */\n\t\tgoto done;\n\t}\n\tenable = 1;\n\n\t/* Now see if we can do parity */\n\tahc_ext_scbram_config(ahc, enable, /*pcheck*/1, fast);\n\tnum_scbs = ahc_probe_scbs(ahc);\n\tif ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0\n\t\t || (ahc_inb(ahc, ERROR) & MPARERR) == 0)\n\t\tpcheck = 1;\n\n\t/* Clear any resulting parity error */\n\tahc_outb(ahc, CLRINT, CLRPARERR);\n\tahc_outb(ahc, CLRINT, CLRBRKADRINT);\n\n\t/* Now see if we can do fast timing */\n\tahc_ext_scbram_config(ahc, enable, pcheck, /*fast*/1);\n\ttest_num_scbs = ahc_probe_scbs(ahc);\n\tif (test_num_scbs == num_scbs\n\t\t && ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0\n\t\t\t  || (ahc_inb(ahc, ERROR) & MPARERR) == 0))\n\t\tfast = 1;\n\n\tdone:\n\t/* Clear any resulting parity error */\n\tahc_outb(ahc, CLRINT, CLRPARERR);\n\tahc_outb(ahc, CLRINT, CLRBRKADRINT);\n\tif (bootverbose && enable) {\n\t\tprintf(\"%s: External SRAM, %dns access%s\\n\",\n\t\t\t\t ahc_name(ahc), fast ? 10 : 20,\n\t\t\t\t pcheck ? \", parity checking enabled\" : \"\");\n\n\t}\n\tahc_ext_scbram_config(ahc, enable, pcheck, fast);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSICONF",
            "our_id|ENSPCHK|RESET_SCSI"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "DSPCISTATUS",
            "DFTHRSH_100"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "DFF_THRSH",
            "RD_DFTHRSH_75|WR_DFTHRSH_75"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SBLKCTL",
            "(sblkctl & ~(DIAGLEDEN|DIAGLEDON))"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SBLKCTL"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_extport",
          "args": [
            "ahc",
            "&sxfrctl1"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "check_extport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
          "lines": "712-918",
          "snippet": "static void\ncheck_extport(ahc, sxfrctl1)\nstruct ahc_softc *ahc;\nu_int *sxfrctl1;\n{\n\tstruct     seeprom_descriptor sd;\n\tstruct     seeprom_config sc;\n\tu_int   scsi_conf;\n\tu_int   adapter_control;\n\tint     have_seeprom;\n\tint     have_autoterm;\n\n\tsd.sd_tag = ahc->sc_iot;\n\tsd.sd_bsh = ahc->sc_ioh;\n\tsd.sd_control_offset = SEECTL;      \n\tsd.sd_status_offset = SEECTL;    \n\tsd.sd_dataout_offset = SEECTL;      \n\n\t/*\n\t * For some multi-channel devices, the c46 is simply too\n\t * small to work.  For the other controller types, we can\n\t * get our information from either SEEPROM type.  Set the\n\t * type to start our probe with accordingly.\n\t */\n\tif (ahc->flags & AHC_LARGE_SEEPROM)\n\t\tsd.sd_chip = C56_66;\n\telse\n\t\tsd.sd_chip = C46;\n\n\tsd.sd_MS = SEEMS;\n\tsd.sd_RDY = SEERDY;\n\tsd.sd_CS = SEECS;\n\tsd.sd_CK = SEECK;\n\tsd.sd_DO = SEEDO;\n\tsd.sd_DI = SEEDI;\n\n\thave_seeprom = acquire_seeprom(ahc, &sd);\n\tif (have_seeprom) {\n\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s: Reading SEEPROM...\", ahc_name(ahc));\n\n\t\tfor (;;) {\n\t\t\tbus_size_t start_addr;\n\n\t\t\tstart_addr = 32 * (ahc->channel - 'A');\n\n\t\t\thave_seeprom = read_seeprom(&sd,\n\t\t\t\t\t\t    (u_int16_t *)&sc,\n\t\t\t\t\t\t    start_addr,\n\t\t\t\t\t\t    sizeof(sc)/2);\n\n\t\t\tif (have_seeprom) {\n\t\t\t\t/* Check checksum */\n\t\t\t\tint i;\n\t\t\t\tint maxaddr;\n\t\t\t\tu_int32_t checksum;\n\t\t\t\tu_int16_t *scarray;\n\n\t\t\t\tmaxaddr = (sizeof(sc)/2) - 1;\n\t\t\t\tchecksum = 0;\n\t\t\t\tscarray = (u_int16_t *)&sc;\n\n\t\t\t\tfor (i = 0; i < maxaddr; i++)\n\t\t\t\t\tchecksum = checksum + scarray[i];\n\t\t\t\tif (checksum == 0\n\t\t\t\t    || (checksum & 0xFFFF) != sc.checksum) {\n\t\t\t\t\tif (bootverbose && sd.sd_chip == C56_66)\n\t\t\t\t\t\tprintf (\"checksum error\\n\");\n\t\t\t\t\thave_seeprom = 0;\n\t\t\t\t} else {\n\t\t\t\t\tif (bootverbose)\n\t\t\t\t\t\tprintf(\"done.\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sd.sd_chip == C56_66)\n\t\t\t\tbreak;\n\t\t\tsd.sd_chip = C56_66;\n\t\t}\n\t}\n\n\tif (!have_seeprom) {\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s: No SEEPROM available.\\n\", ahc_name(ahc));\n\t\tahc->flags |= AHC_USEDEFAULTS;\n\t} else {\n\t\t/*\n\t\t * Put the data we've collected down into SRAM\n\t\t * where ahc_init will find it.\n\t\t */\n\t\tint i;\n\t\tint max_targ = sc.max_targets & CFMAXTARG;\n\t\tu_int16_t discenable;\n\t\tu_int16_t ultraenb;\n\n\t\tdiscenable = 0;\n\t\tultraenb = 0;\n\t\tif ((sc.adapter_control & CFULTRAEN) != 0) {\n\t\t\t/*\n\t\t\t * Determine if this adapter has a \"newstyle\"\n\t\t\t * SEEPROM format.\n\t\t\t */\n\t\t\tfor (i = 0; i < max_targ; i++) {\n\t\t\t\tif ((sc.device_flags[i] & CFSYNCHISULTRA) != 0) {\n\t\t\t\t\tahc->flags |= AHC_NEWEEPROM_FMT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < max_targ; i++) {\n\t\t\tu_int     scsirate;\n\t\t\tu_int16_t target_mask;\n\n\t\t\ttarget_mask = 0x01 << i;\n\t\t\tif (sc.device_flags[i] & CFDISC)\n\t\t\t\tdiscenable |= target_mask;\n\t\t\tif ((ahc->flags & AHC_NEWEEPROM_FMT) != 0) {\n\t\t\t\tif ((sc.device_flags[i] & CFSYNCHISULTRA) != 0)\n\t\t\t\t\tultraenb |= target_mask;\n\t\t\t} else if ((sc.adapter_control & CFULTRAEN) != 0) {\n\t\t\t\tultraenb |= target_mask;\n\t\t\t}\n\t\t\tif ((sc.device_flags[i] & CFXFER) == 0x04\n\t\t\t\t && (ultraenb & target_mask) != 0) {\n\t\t\t\t/* Treat 10MHz as a non-ultra speed */\n\t\t\t\tsc.device_flags[i] &= ~CFXFER;\n\t\t\t\tultraenb &= ~target_mask;\n\t\t\t}\n\t\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\t\tu_int offset;\n\n\t\t\t\tif (sc.device_flags[i] & CFSYNCH)\n\t\t\t\t\toffset = MAX_OFFSET_ULTRA2;\n\t\t\t\telse\n\t\t\t\t\toffset = 0;\n\t\t\t\tahc_outb(ahc, TARG_OFFSET + i, offset);\n\n\t\t\t\tscsirate = (sc.device_flags[i] & CFXFER)\n\t\t\t\t| ((ultraenb & target_mask) ? 0x8 : 0x0);\n\t\t\t\tif (sc.device_flags[i] & CFWIDEB)\n\t\t\t\t\tscsirate |= WIDEXFER;\n\t\t\t} else {\n\t\t\t\tscsirate = (sc.device_flags[i] & CFXFER) << 4;\n\t\t\t\tif (sc.device_flags[i] & CFSYNCH)\n\t\t\t\t\tscsirate |= SOFS;\n\t\t\t\tif (sc.device_flags[i] & CFWIDEB)\n\t\t\t\t\tscsirate |= WIDEXFER;\n\t\t\t}\n\t\t\tahc_outb(ahc, TARG_SCSIRATE + i, scsirate);\n\t\t}\n\t\tahc->our_id = sc.brtime_id & CFSCSIID;\n\n\t\tscsi_conf = (ahc->our_id & 0x7);\n\t\tif (sc.adapter_control & CFSPARITY)\n\t\t\tscsi_conf |= ENSPCHK;\n\t\tif (sc.adapter_control & CFRESETB)\n\t\t\tscsi_conf |= RESET_SCSI;\n\n\t\tif (sc.bios_control & CFEXTEND)\n\t\t\tahc->flags |= AHC_EXTENDED_TRANS_A;\n\t\tif (ahc->features & AHC_ULTRA\n\t\t\t && (ahc->flags & AHC_NEWEEPROM_FMT) == 0) {\n\t\t\t/* Should we enable Ultra mode? */\n\t\t\tif (!(sc.adapter_control & CFULTRAEN))\n\t\t\t\t/* Treat us as a non-ultra card */\n\t\t\t\tultraenb = 0;\n\t\t}\n\t\t/* Set SCSICONF info */\n\t\tahc_outb(ahc, SCSICONF, scsi_conf);\n\t\tahc_outb(ahc, DISC_DSB, ~(discenable & 0xff));\n\t\tahc_outb(ahc, DISC_DSB + 1, ~((discenable >> 8) & 0xff));\n\t\tahc_outb(ahc, ULTRA_ENB, ultraenb & 0xff);\n\t\tahc_outb(ahc, ULTRA_ENB + 1, (ultraenb >> 8) & 0xff);\n\t}\n\n\t/*\n\t * Cards that have the external logic necessary to talk to\n\t * a SEEPROM, are almost certain to have the remaining logic\n\t * necessary for auto-termination control.  This assumption\n\t * hasn't failed yet...\n\t */\n\thave_autoterm = have_seeprom;\n\tif (have_seeprom)\n\t\tadapter_control = sc.adapter_control;\n\telse\n\t\tadapter_control = CFAUTOTERM;\n\n\t/*\n\t * Some low-cost chips have SEEPROM and auto-term control built\n\t * in, instead of using a GAL.  They can tell us directly\n\t * if the termination logic is enabled.\n\t */\n\tif ((ahc->features & AHC_SPIOCAP) != 0) {\n\t\tif ((ahc_inb(ahc, SPIOCAP) & SSPIOCPS) != 0)\n\t\t\thave_autoterm = 1;\n\t\telse\n\t\t\thave_autoterm = 0;\n\t}\n\n\tif (have_autoterm)\n\t\tconfigure_termination(ahc, &sd, adapter_control, sxfrctl1);\n\n\trelease_seeprom(&sd);\n}",
          "includes": [
            "#include <dev/ic/smc93cx6var.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define bootverbose\t0",
            "#define bootverbose\t1"
          ],
          "globals_used": [
            "static void check_extport",
            "static void configure_termination",
            "static int acquire_seeprom",
            "static void release_seeprom"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define bootverbose\t0\n#define bootverbose\t1\n\nstatic void check_extport;\nstatic void configure_termination;\nstatic int acquire_seeprom;\nstatic void release_seeprom;\n\nstatic void\ncheck_extport(ahc, sxfrctl1)\nstruct ahc_softc *ahc;\nu_int *sxfrctl1;\n{\n\tstruct     seeprom_descriptor sd;\n\tstruct     seeprom_config sc;\n\tu_int   scsi_conf;\n\tu_int   adapter_control;\n\tint     have_seeprom;\n\tint     have_autoterm;\n\n\tsd.sd_tag = ahc->sc_iot;\n\tsd.sd_bsh = ahc->sc_ioh;\n\tsd.sd_control_offset = SEECTL;      \n\tsd.sd_status_offset = SEECTL;    \n\tsd.sd_dataout_offset = SEECTL;      \n\n\t/*\n\t * For some multi-channel devices, the c46 is simply too\n\t * small to work.  For the other controller types, we can\n\t * get our information from either SEEPROM type.  Set the\n\t * type to start our probe with accordingly.\n\t */\n\tif (ahc->flags & AHC_LARGE_SEEPROM)\n\t\tsd.sd_chip = C56_66;\n\telse\n\t\tsd.sd_chip = C46;\n\n\tsd.sd_MS = SEEMS;\n\tsd.sd_RDY = SEERDY;\n\tsd.sd_CS = SEECS;\n\tsd.sd_CK = SEECK;\n\tsd.sd_DO = SEEDO;\n\tsd.sd_DI = SEEDI;\n\n\thave_seeprom = acquire_seeprom(ahc, &sd);\n\tif (have_seeprom) {\n\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s: Reading SEEPROM...\", ahc_name(ahc));\n\n\t\tfor (;;) {\n\t\t\tbus_size_t start_addr;\n\n\t\t\tstart_addr = 32 * (ahc->channel - 'A');\n\n\t\t\thave_seeprom = read_seeprom(&sd,\n\t\t\t\t\t\t    (u_int16_t *)&sc,\n\t\t\t\t\t\t    start_addr,\n\t\t\t\t\t\t    sizeof(sc)/2);\n\n\t\t\tif (have_seeprom) {\n\t\t\t\t/* Check checksum */\n\t\t\t\tint i;\n\t\t\t\tint maxaddr;\n\t\t\t\tu_int32_t checksum;\n\t\t\t\tu_int16_t *scarray;\n\n\t\t\t\tmaxaddr = (sizeof(sc)/2) - 1;\n\t\t\t\tchecksum = 0;\n\t\t\t\tscarray = (u_int16_t *)&sc;\n\n\t\t\t\tfor (i = 0; i < maxaddr; i++)\n\t\t\t\t\tchecksum = checksum + scarray[i];\n\t\t\t\tif (checksum == 0\n\t\t\t\t    || (checksum & 0xFFFF) != sc.checksum) {\n\t\t\t\t\tif (bootverbose && sd.sd_chip == C56_66)\n\t\t\t\t\t\tprintf (\"checksum error\\n\");\n\t\t\t\t\thave_seeprom = 0;\n\t\t\t\t} else {\n\t\t\t\t\tif (bootverbose)\n\t\t\t\t\t\tprintf(\"done.\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sd.sd_chip == C56_66)\n\t\t\t\tbreak;\n\t\t\tsd.sd_chip = C56_66;\n\t\t}\n\t}\n\n\tif (!have_seeprom) {\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s: No SEEPROM available.\\n\", ahc_name(ahc));\n\t\tahc->flags |= AHC_USEDEFAULTS;\n\t} else {\n\t\t/*\n\t\t * Put the data we've collected down into SRAM\n\t\t * where ahc_init will find it.\n\t\t */\n\t\tint i;\n\t\tint max_targ = sc.max_targets & CFMAXTARG;\n\t\tu_int16_t discenable;\n\t\tu_int16_t ultraenb;\n\n\t\tdiscenable = 0;\n\t\tultraenb = 0;\n\t\tif ((sc.adapter_control & CFULTRAEN) != 0) {\n\t\t\t/*\n\t\t\t * Determine if this adapter has a \"newstyle\"\n\t\t\t * SEEPROM format.\n\t\t\t */\n\t\t\tfor (i = 0; i < max_targ; i++) {\n\t\t\t\tif ((sc.device_flags[i] & CFSYNCHISULTRA) != 0) {\n\t\t\t\t\tahc->flags |= AHC_NEWEEPROM_FMT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < max_targ; i++) {\n\t\t\tu_int     scsirate;\n\t\t\tu_int16_t target_mask;\n\n\t\t\ttarget_mask = 0x01 << i;\n\t\t\tif (sc.device_flags[i] & CFDISC)\n\t\t\t\tdiscenable |= target_mask;\n\t\t\tif ((ahc->flags & AHC_NEWEEPROM_FMT) != 0) {\n\t\t\t\tif ((sc.device_flags[i] & CFSYNCHISULTRA) != 0)\n\t\t\t\t\tultraenb |= target_mask;\n\t\t\t} else if ((sc.adapter_control & CFULTRAEN) != 0) {\n\t\t\t\tultraenb |= target_mask;\n\t\t\t}\n\t\t\tif ((sc.device_flags[i] & CFXFER) == 0x04\n\t\t\t\t && (ultraenb & target_mask) != 0) {\n\t\t\t\t/* Treat 10MHz as a non-ultra speed */\n\t\t\t\tsc.device_flags[i] &= ~CFXFER;\n\t\t\t\tultraenb &= ~target_mask;\n\t\t\t}\n\t\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\t\tu_int offset;\n\n\t\t\t\tif (sc.device_flags[i] & CFSYNCH)\n\t\t\t\t\toffset = MAX_OFFSET_ULTRA2;\n\t\t\t\telse\n\t\t\t\t\toffset = 0;\n\t\t\t\tahc_outb(ahc, TARG_OFFSET + i, offset);\n\n\t\t\t\tscsirate = (sc.device_flags[i] & CFXFER)\n\t\t\t\t| ((ultraenb & target_mask) ? 0x8 : 0x0);\n\t\t\t\tif (sc.device_flags[i] & CFWIDEB)\n\t\t\t\t\tscsirate |= WIDEXFER;\n\t\t\t} else {\n\t\t\t\tscsirate = (sc.device_flags[i] & CFXFER) << 4;\n\t\t\t\tif (sc.device_flags[i] & CFSYNCH)\n\t\t\t\t\tscsirate |= SOFS;\n\t\t\t\tif (sc.device_flags[i] & CFWIDEB)\n\t\t\t\t\tscsirate |= WIDEXFER;\n\t\t\t}\n\t\t\tahc_outb(ahc, TARG_SCSIRATE + i, scsirate);\n\t\t}\n\t\tahc->our_id = sc.brtime_id & CFSCSIID;\n\n\t\tscsi_conf = (ahc->our_id & 0x7);\n\t\tif (sc.adapter_control & CFSPARITY)\n\t\t\tscsi_conf |= ENSPCHK;\n\t\tif (sc.adapter_control & CFRESETB)\n\t\t\tscsi_conf |= RESET_SCSI;\n\n\t\tif (sc.bios_control & CFEXTEND)\n\t\t\tahc->flags |= AHC_EXTENDED_TRANS_A;\n\t\tif (ahc->features & AHC_ULTRA\n\t\t\t && (ahc->flags & AHC_NEWEEPROM_FMT) == 0) {\n\t\t\t/* Should we enable Ultra mode? */\n\t\t\tif (!(sc.adapter_control & CFULTRAEN))\n\t\t\t\t/* Treat us as a non-ultra card */\n\t\t\t\tultraenb = 0;\n\t\t}\n\t\t/* Set SCSICONF info */\n\t\tahc_outb(ahc, SCSICONF, scsi_conf);\n\t\tahc_outb(ahc, DISC_DSB, ~(discenable & 0xff));\n\t\tahc_outb(ahc, DISC_DSB + 1, ~((discenable >> 8) & 0xff));\n\t\tahc_outb(ahc, ULTRA_ENB, ultraenb & 0xff);\n\t\tahc_outb(ahc, ULTRA_ENB + 1, (ultraenb >> 8) & 0xff);\n\t}\n\n\t/*\n\t * Cards that have the external logic necessary to talk to\n\t * a SEEPROM, are almost certain to have the remaining logic\n\t * necessary for auto-termination control.  This assumption\n\t * hasn't failed yet...\n\t */\n\thave_autoterm = have_seeprom;\n\tif (have_seeprom)\n\t\tadapter_control = sc.adapter_control;\n\telse\n\t\tadapter_control = CFAUTOTERM;\n\n\t/*\n\t * Some low-cost chips have SEEPROM and auto-term control built\n\t * in, instead of using a GAL.  They can tell us directly\n\t * if the termination logic is enabled.\n\t */\n\tif ((ahc->features & AHC_SPIOCAP) != 0) {\n\t\tif ((ahc_inb(ahc, SPIOCAP) & SSPIOCPS) != 0)\n\t\t\thave_autoterm = 1;\n\t\telse\n\t\t\thave_autoterm = 0;\n\t}\n\n\tif (have_autoterm)\n\t\tconfigure_termination(ahc, &sd, adapter_control, sxfrctl1);\n\n\trelease_seeprom(&sd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "DSCOMMAND0",
            "dscommand0"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "DSCOMMAND0"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pa->pa_pc",
            "ih",
            "IPL_BIO",
            "ahc_intr",
            "ahc",
            "ahc->sc_dev.dv_xname"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pa->pa_pc",
            "ih"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pa->pa_pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&ih"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CRCCONTROL1",
            "CRCVALCHKEN|CRCENDCHKEN|CRCREQCHKEN\n\t\t\t\t\t|TARGCRCENDEN|TARGCRCCNTEN"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SFUNCT",
            "sfunct"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "TARGCRCCNT + 1",
            "0x10"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "TARGCRCCNT",
            "0"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "OPTIONMODE",
            "OPTIONMODE_DEFAULTS"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "OPTIONMODE"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SFUNCT",
            "sfunct | ALT_MODE"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SFUNCT"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "pa->pa_iot",
            "ioh",
            "SXFRCTL0"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_reset",
          "args": [
            "ahc"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_reset_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5412-5527",
          "snippet": "STATIC int\nahc_reset_channel(ahc, channel, initiate_reset)\n\tstruct ahc_softc *ahc;\n\tchar channel;\n\tint initiate_reset;\n{\n\tu_int\tinitiator, target, max_scsiid;\n\tu_int\tsblkctl;\n\tu_int\tour_id;\n\tint\tfound;\n\tint\trestart_needed;\n\tchar\tcur_channel;\n\n\tahc->pending_device = NULL;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Run our command complete fifos to ensure that we perform\n\t * completion processing on any commands that 'completed'\n\t * before the reset occurred.\n\t */\n\tahc_run_qoutfifo(ahc);\n\n\t/*\n\t * Reset the bus if we are initiating this reset\n\t */\n\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\tcur_channel = 'A';\n\tif ((ahc->features & AHC_TWIN) != 0\n\t && ((sblkctl & SELBUSB) != 0))\n\t    cur_channel = 'B';\n\tif (cur_channel != channel) {\n\t\t/* Case 1: Command for another bus is active\n\t\t * Stealthily reset the other bus without\n\t\t * upsetting the current bus.\n\t\t */\n\t\tahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl);\n\t\trestart_needed = FALSE;\n\t} else {\n\t\t/* Case 2: A command from this bus is active or we're idle */\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\n\t\t/*\n\t\t * Since we are going to restart the sequencer, avoid\n\t\t * a race in the sequencer that could cause corruption\n\t\t * of our Q pointers by starting over from index 0.\n\t\t */\n\t\tahc->qoutfifonext = 0;\n\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0)\n\t\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t\telse\n\t\t\tahc_outb(ahc, QOUTPOS, 0);\n\t\trestart_needed = TRUE;\n\t}\n\n\t/*\n\t * Clean up all the state information for the\n\t * pending transactions on this bus.\n\t */\n\tfound = ahc_abort_scbs(ahc, ALL_TARGETS, channel,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL,\n\t\t\t       ROLE_UNKNOWN, XS_RESET);\n\tif (channel == 'B') {\n\t\tour_id = ahc->our_id_b;\n\t} else {\n\t\tour_id = ahc->our_id;\n\t}\n\n\tmax_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;\n\t\n\t/*\n\t * Revert to async/narrow transfers until we renegotiate.\n\t */\n\tfor (target = 0; target <= max_scsiid; target++) {\n\n\t\tif (ahc->enabled_targets[target] == NULL)\n\t\t\tcontinue;\n\t\tfor (initiator = 0; initiator <= max_scsiid; initiator++) {\n\t\t\tstruct ahc_devinfo devinfo;\n\n\t\t\tahc_compile_devinfo(&devinfo, target, initiator,\n\t\t\t\t\t    ALL_LUNS,\n\t\t\t\t\t    channel, ROLE_UNKNOWN);\n\t\t\tahc_set_width(ahc, &devinfo,\n\t\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t\t      AHC_TRANS_CUR,\n\t\t\t\t      /*paused*/TRUE,\n\t\t\t\t      /*done*/FALSE);\n\t\t\tahc_set_syncrate(ahc, &devinfo,\n\t\t\t\t\t /*syncrate*/NULL, /*period*/0,\n\t\t\t\t\t /*offset*/0, AHC_TRANS_CUR,\n\t\t\t\t\t /*paused*/TRUE,\n\t\t\t\t\t /*done*/FALSE);\n\t\t}\n\t}\n\n\tif (restart_needed)\n\t\trestart_sequencer(ahc);\n\telse\n\t\tunpause_sequencer(ahc);\n\treturn found;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_reset_channel __P((struct ahc_softc *ahc, char channel,\n\t\t\t\t       int initiate_reset));",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "static __inline void pause_sequencer",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "u_int our_id;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_reset_channel __P((struct ahc_softc *ahc, char channel,\n\t\t\t\t       int initiate_reset));\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nu_int our_id;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_reset_channel(ahc, channel, initiate_reset)\n\tstruct ahc_softc *ahc;\n\tchar channel;\n\tint initiate_reset;\n{\n\tu_int\tinitiator, target, max_scsiid;\n\tu_int\tsblkctl;\n\tu_int\tour_id;\n\tint\tfound;\n\tint\trestart_needed;\n\tchar\tcur_channel;\n\n\tahc->pending_device = NULL;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Run our command complete fifos to ensure that we perform\n\t * completion processing on any commands that 'completed'\n\t * before the reset occurred.\n\t */\n\tahc_run_qoutfifo(ahc);\n\n\t/*\n\t * Reset the bus if we are initiating this reset\n\t */\n\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\tcur_channel = 'A';\n\tif ((ahc->features & AHC_TWIN) != 0\n\t && ((sblkctl & SELBUSB) != 0))\n\t    cur_channel = 'B';\n\tif (cur_channel != channel) {\n\t\t/* Case 1: Command for another bus is active\n\t\t * Stealthily reset the other bus without\n\t\t * upsetting the current bus.\n\t\t */\n\t\tahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl);\n\t\trestart_needed = FALSE;\n\t} else {\n\t\t/* Case 2: A command from this bus is active or we're idle */\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\n\t\t/*\n\t\t * Since we are going to restart the sequencer, avoid\n\t\t * a race in the sequencer that could cause corruption\n\t\t * of our Q pointers by starting over from index 0.\n\t\t */\n\t\tahc->qoutfifonext = 0;\n\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0)\n\t\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t\telse\n\t\t\tahc_outb(ahc, QOUTPOS, 0);\n\t\trestart_needed = TRUE;\n\t}\n\n\t/*\n\t * Clean up all the state information for the\n\t * pending transactions on this bus.\n\t */\n\tfound = ahc_abort_scbs(ahc, ALL_TARGETS, channel,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL,\n\t\t\t       ROLE_UNKNOWN, XS_RESET);\n\tif (channel == 'B') {\n\t\tour_id = ahc->our_id_b;\n\t} else {\n\t\tour_id = ahc->our_id;\n\t}\n\n\tmax_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;\n\t\n\t/*\n\t * Revert to async/narrow transfers until we renegotiate.\n\t */\n\tfor (target = 0; target <= max_scsiid; target++) {\n\n\t\tif (ahc->enabled_targets[target] == NULL)\n\t\t\tcontinue;\n\t\tfor (initiator = 0; initiator <= max_scsiid; initiator++) {\n\t\t\tstruct ahc_devinfo devinfo;\n\n\t\t\tahc_compile_devinfo(&devinfo, target, initiator,\n\t\t\t\t\t    ALL_LUNS,\n\t\t\t\t\t    channel, ROLE_UNKNOWN);\n\t\t\tahc_set_width(ahc, &devinfo,\n\t\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t\t      AHC_TRANS_CUR,\n\t\t\t\t      /*paused*/TRUE,\n\t\t\t\t      /*done*/FALSE);\n\t\t\tahc_set_syncrate(ahc, &devinfo,\n\t\t\t\t\t /*syncrate*/NULL, /*period*/0,\n\t\t\t\t\t /*offset*/0, AHC_TRANS_CUR,\n\t\t\t\t\t /*paused*/TRUE,\n\t\t\t\t\t /*done*/FALSE);\n\t\t}\n\t}\n\n\tif (restart_needed)\n\t\trestart_sequencer(ahc);\n\telse\n\t\tunpause_sequencer(ahc);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSISEQ"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SXFRCTL1"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSIID"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSIID_ULTRA2"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "HCNTRL",
            "ahc->pause"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_construct",
          "args": [
            "ahc",
            "pa->pa_iot",
            "ioh",
            "ahc_c",
            "ahc_flags",
            "ahc_f",
            "channel"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_construct_wdtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5565-5575",
          "snippet": "STATIC void\nahc_construct_wdtr(ahc, bus_width)\n\tstruct ahc_softc *ahc;\n\tu_int bus_width;\n{\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR_LEN;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR;\n\tahc->msgout_buf[ahc->msgout_index++] = bus_width;\n\tahc->msgout_len += 4;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_construct_wdtr __P((struct ahc_softc *ahc, u_int bus_width));",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_construct_wdtr __P((struct ahc_softc *ahc, u_int bus_width));\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_construct_wdtr(ahc, bus_width)\n\tstruct ahc_softc *ahc;\n\tu_int bus_width;\n{\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR_LEN;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR;\n\tahc->msgout_buf[ahc->msgout_index++] = bus_width;\n\tahc->msgout_len += 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (struct ahc_pci_data)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG",
            "command"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_mapreg_map",
          "args": [
            "pa",
            "AHC_PCI_IOADDR",
            "PCI_MAPREG_TYPE_IO",
            "0",
            "&iot",
            "&ioh",
            "NULL",
            "NULL"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mapreg_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "230-275",
          "snippet": "int\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find",
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\nstatic int nbsd_pci_mem_find;\n\nint\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "DEVCONFIG",
            "devconfig"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "DEVCONFIG"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "DEVCONFIG",
            "devconfig"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "DEVCONFIG"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_REVISION",
          "args": [
            "pa->pa_class"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\t\tPCI64\t\t0x00000080UL\t/* aic7891 & aic7897 only */\n#define\t\tSCBSIZE32\t0x00010000UL\t/* aic789X only */\n#define\tDEVCONFIG\t\t0x40\n#define bootverbose\t0\n#define bootverbose\t1\n#define AHC_PCI_MEMADDR\t(PCI_MAPREG_START + 4)\t/* Mem I/O Address */\n#define AHC_PCI_IOADDR\tPCI_MAPREG_START\t/* I/O Address */\n\nint\t    ahc_pci_intr;\nstatic void ahc_probe_ext_scbram;\nstatic void check_extport;\nstatic u_char aic3940_count;\nvoid ahc_pci_attach;\n\nvoid\nahc_pci_attach(parent, self, aux)\nstruct device *parent, *self;\nvoid *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\tstruct ahc_softc *ahc = (void *)self;\n\tbus_space_tag_t  iot;\n\tbus_space_handle_t ioh;\n#ifdef AHC_ALLOW_MEMIO\n\tbus_space_tag_t memt;\n\tbus_space_handle_t memh;\n\tint\tmemh_valid;\n#endif\n\tpci_intr_handle_t ih;\n\tpcireg_t\t   command;\n\tconst char *intrstr;\n\tunsigned opri = 0;\n\tahc_chip ahc_c = AHC_PCI; /* we are a PCI controller */\n\tahc_flag ahc_flags = AHC_FNONE;\n\tahc_feature ahc_f = AHC_FENONE;\n\tint\tioh_valid;\n\n\tu_char ultra_enb = 0;\n\tu_char our_id = 0;\n\tu_char channel = 'A';\n\tu_int    sxfrctl1;\n\tu_int    scsiseq;\n\t/* So we can access PCI configuration space after init */\n\tstruct ahc_pci_data *pd;\n\n\tahc->sc_dmat = pa->pa_dmat;\n\t\n\tcommand = pci_conf_read(pa->pa_pc, pa->pa_tag,\n\t\t\t\tPCI_COMMAND_STATUS_REG);\n\n\tswitch (PCI_VENDOR(pa->pa_id)) {\n\tcase PCI_VENDOR_ADP:\n\t\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\t\tcase PCI_PRODUCT_ADP_7895:\n\t\t\t{\n\t\t\t\tpcireg_t devconfig;\n\t\t\t\tchannel = pa->pa_function == 1 ? 'B' : 'A';\n\t\t\t\tahc_c |= AHC_AIC7895;\n\t\t\t\t/* The 'C' revision of the aic7895 \n\t\t\t\t   has a few additional features */\n\t\t\t\tif (PCI_REVISION(pa->pa_class) >= 4)\n\t\t\t\t\tahc_f = AHC_AIC7895C_FE;\n\t\t\t\telse\n\t\t\t\t\tahc_f = AHC_AIC7895_FE;\n\t\t\t\tahc_flags |= AHC_NEWEEPROM_FMT;\n\t\t\t\tdevconfig = pci_conf_read(pa->pa_pc, \n\t\t\t\t\t\t\t  pa->pa_tag,\n\t\t\t\t\t\t\t  DEVCONFIG);\n\t\t\t\tdevconfig &= ~SCBSIZE32;\n\t\t\t\tpci_conf_write(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t       DEVCONFIG, devconfig);\n\t\t\t}\n\t\t\tbreak;\n\t   case PCI_PRODUCT_ADP_3940U:\n\t\tcase PCI_PRODUCT_ADP_3940:\n\t\t\tif (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADP_3940U) {\n\t\t\t\tahc_c |= AHC_AIC7880;\n\t\t\t\tahc_f = AHC_AIC7880_FE;\n\t\t\t} else {\n\t\t\t\tahc_c |= AHC_AIC7870;\n\t\t\t\tahc_f = AHC_AIC7870_FE;\n\t\t\t}\n\t\t\taic3940_count++;\n\t\t\tif (!(aic3940_count & 0x01))\n\t\t\t\t/* Even count implies second channel */\n\t\t\t\tchannel = 'B';\n\t\t\tbreak;\n\t\tcase PCI_PRODUCT_ADP_2940UWPro:\n\t\t\tahc_c |= AHC_AIC7880;\n\t\t\tahc_f = AHC_AIC7880_FE;\n\t\t\tahc_f |= AHC_INT50_SPEEDFLEX;\n\t\tcase PCI_PRODUCT_ADP_2944U:\n\t\tcase PCI_PRODUCT_ADP_2940U:\n\t\t\tahc_c |= AHC_AIC7880;\n\t\t\tahc_f = AHC_AIC7880_FE;\n\t\t\tbreak;\n\t\tcase PCI_PRODUCT_ADP_2944:\n\t\tcase PCI_PRODUCT_ADP_2940:\n\t\t\tahc_c |= AHC_AIC7870;\n\t\t\tahc_f = AHC_AIC7870_FE;\n\t\t\tbreak;\n\t\tcase PCI_PRODUCT_ADP_2940AU:\n\t\t\tahc_c |= AHC_AIC7860;\n\t\t\tahc_f = AHC_AIC7860_FE;\n\t\t\tbreak;\n\t\tcase PCI_PRODUCT_ADP_398XU:\t/* XXX */\n\t\tcase PCI_PRODUCT_ADP_AIC7880:\n\t\t\tahc_c |= AHC_AIC7880;\n\t\t\tahc_f = AHC_AIC7880_FE;\n\t\t\tbreak;\n\t\tcase PCI_PRODUCT_ADP_AIC7870:\n\t\t\tahc_c |= AHC_AIC7870;\n\t\t\tahc_f = AHC_AIC7870_FE;\n\t\t\tbreak;\n\t\tcase PCI_PRODUCT_ADP_AIC7860:\n\t\t\tahc_c |= AHC_AIC7860;\n\t\t\tahc_f = AHC_AIC7860_FE;\n\t\t\tbreak;\n\t\tcase PCI_PRODUCT_ADP_AIC7855:\n\t\tcase PCI_PRODUCT_ADP_AIC7850:\n\t\t\tahc_c |= AHC_AIC7850;\n\t\t\tahc_f = AHC_AIC7850_FE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* TTT */\n\t\t\tbreak;\n\t}\n\t\tbreak;\n\tcase PCI_VENDOR_ADP2:\n\t\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\t\tcase PCI_PRODUCT_ADP2_AIC7890:\n\t\tcase PCI_PRODUCT_ADP2_2940U2:\n\t\tcase PCI_PRODUCT_ADP2_2930U2:\n\t\t\tahc_c |= AHC_AIC7890;\n\t\t\tahc_f = AHC_AIC7890_FE;\n\t\t\tahc_flags |= AHC_NEWEEPROM_FMT;\n\t\t\tbreak;\n\t\tcase PCI_PRODUCT_ADP2_AIC7892:\n\t\tcase PCI_PRODUCT_ADP2_29160:\n\t\tcase PCI_PRODUCT_ADP2_19160B:\n\t\t\tahc_c |= AHC_AIC7892;\n\t\t\tahc_f = AHC_AIC7892_FE;\n\t\t\tahc_flags |= AHC_NEWEEPROM_FMT;\n\t\t\tbreak;\n\t\tcase PCI_PRODUCT_ADP2_3950U2B:\n\t\tcase PCI_PRODUCT_ADP2_3950U2D:\n\t\tcase PCI_PRODUCT_ADP2_AIC7896:\n\t\t\t{\n\t\t\t\tpcireg_t devconfig;\n\t\t\t\tchannel = pa->pa_function == 1 ? 'B' : 'A';\n\t\t\t\tahc_c |= AHC_AIC7896;\n\t\t\t\tahc_f = AHC_AIC7896_FE;\n\t\t\t\tahc_flags |= AHC_NEWEEPROM_FMT;\n\t\t\t\tdevconfig = pci_conf_read(pa->pa_pc, \n\t\t\t\t\t\t\t  pa->pa_tag, \n\t\t\t\t\t\t\t  DEVCONFIG);\n\t\t\t\t/* turn off 64 bit for now XXX smurph */\n\t\t\t\tdevconfig &= ~PCI64;\n\t\t\t\tpci_conf_write(pa->pa_pc, pa->pa_tag, \n\t\t\t\t\t       DEVCONFIG, devconfig);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PCI_PRODUCT_ADP2_AIC7899:\n\t\tcase PCI_PRODUCT_ADP2_3960D:\n\t\t\tahc_c |= AHC_AIC7899;\n\t\t\tahc_f = AHC_AIC7899_FE;\n\t\t\tahc_flags |= AHC_NEWEEPROM_FMT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* TTT */\n\t\t}\n\t}\n\t\n#ifdef AHC_ALLOW_MEMIO\n\tmemh_valid = (pci_mapreg_map(pa, AHC_PCI_MEMADDR,\n\t    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,\n\t    &memt, &memh, NULL, NULL) == 0);\n#endif\n\tioh_valid = (pci_mapreg_map(pa, AHC_PCI_IOADDR,\n\t    PCI_MAPREG_TYPE_IO, 0, &iot, &ioh, NULL, NULL) == 0);\n\n\tif (ioh_valid) {\n\t\t/* do nothing */\n#ifdef AHC_ALLOW_MEMIO\n\t} else if (memh_valid) {\n\t\t/* do nothing */\n#endif\n\t} else {\n\t\t/* error out */\n\t\tprintf(\": unable to map registers\\n\");\n\t\treturn;\n\t}\n\t\n\t/* Ensure busmastering is enabled */\n\tcommand |= PCI_COMMAND_MASTER_ENABLE;\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);\n\n\tpd = malloc(sizeof (struct ahc_pci_data), M_DEVBUF, M_NOWAIT);\n\tif (pd == NULL) {\n\t\tprintf(\": error allocating pci data\\n\");\n\t\treturn;\n\t}\n\n\tpd->pc = pa->pa_pc;\n\tpd->tag = pa->pa_tag;\n\tpd->function = pa->pa_function;\n\n\t/* setup the PCI stuff */\n\tahc->pci_data = pd;\n\tahc->pci_intr_func = ahc_pci_intr;\n\n\n\t/* On all PCI adapters, we allow SCB paging */\n\tahc_flags |= AHC_PAGESCBS;\n\n\tahc_construct(ahc, pa->pa_iot, ioh, ahc_c, ahc_flags, ahc_f, channel);\n\t/* Now we can use the ahc_inb and ahc_outb macros */\n\n\t/* setup the PCI error interrupt handler */\n\tahc->pci_intr_func = &ahc_pci_intr;\n\t\n\t/* Remeber how the card was setup in case there is no SEEPROM */\n\tahc_outb(ahc, HCNTRL, ahc->pause);\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tour_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;\n\telse\n\t\tour_id = ahc_inb(ahc, SCSIID) & OID;\n\tsxfrctl1 = ahc_inb(ahc, SXFRCTL1) & STPWEN;\n\tscsiseq = ahc_inb(ahc, SCSISEQ);\n\t\n\tif (ahc_reset(ahc) != 0) {\n\t\t/* Failed */\n\t\tahc_free(ahc);\n\t\treturn;\n\t}\n\t\n\tif (ahc->features & AHC_ULTRA)\n\t\tultra_enb = bus_space_read_1(pa->pa_iot, ioh, SXFRCTL0) &\n\t\t\t\t\t\tFAST20;\n\t\n\tif ((ahc->features & AHC_DT) != 0) {\n\t\tu_int optionmode;\n\t\tu_int sfunct;\n\n\t\t/* Perform ALT-Mode Setup */\n\t\tsfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;\n\t\tahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);\n\t\toptionmode = ahc_inb(ahc, OPTIONMODE);\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s: OptionMode = %x\\n\", ahc_name(ahc), optionmode);\n\t\tahc_outb(ahc, OPTIONMODE, OPTIONMODE_DEFAULTS);\n\t\t/* Send CRC info in target mode every 4K */\n\t\tahc_outb(ahc, TARGCRCCNT, 0);\n\t\tahc_outb(ahc, TARGCRCCNT + 1, 0x10);\n\t\tahc_outb(ahc, SFUNCT, sfunct);\n\n\t\t/* Normal mode setup */\n\t\tahc_outb(ahc, CRCCONTROL1, CRCVALCHKEN|CRCENDCHKEN|CRCREQCHKEN\n\t\t\t\t\t|TARGCRCENDEN|TARGCRCCNTEN);\n\t}\n\n\tif (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,\n\t\t\t pa->pa_intrline, &ih)) {\n\t\tprintf(\"%s: couldn't map interrupt\\n\", ahc->sc_dev.dv_xname);\n\t\tahc_free(ahc);\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pa->pa_pc, ih);\n\tahc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO, ahc_intr, ahc,\n                                        ahc->sc_dev.dv_xname);\n\n\tif (ahc->sc_ih == NULL) {\n\t\tprintf(\": couldn't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\tahc_free(ahc);\n\t\treturn;\n\t}\n\tif (intrstr != NULL)\n\t\tprintf(\": %s\\n\", intrstr);\n\n\t/*\n\t * Protect ourself from spurrious interrupts during\n\t * intialization.\n\t */\n\topri = splbio();\n\n\t/*\n\t * Do aic7880/aic7870/aic7860/aic7850 specific initialization\n\t */\n\t{\n\t\tu_int8_t sblkctl;\n\t\tu_int dscommand0;\n\n\t\tdscommand0 = ahc_inb(ahc, DSCOMMAND0);\n\t\tdscommand0 |= MPARCKEN;\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\n\t\t\t/*\n\t\t\t * DPARCKEN doesn't work correctly on\n\t\t\t * some MBs so don't use it.\n\t\t\t */\n\t\t\tdscommand0 &= ~(USCBSIZE32|DPARCKEN);\n\t\t\tdscommand0 |= CACHETHEN;\n\t\t}\n\n\t\tahc_outb(ahc, DSCOMMAND0, dscommand0);\n\n\t\t/* See if we have an SEEPROM and perform auto-term */\n\t\tcheck_extport(ahc, &sxfrctl1);\n\n\t\t/*\n\t\t * Take the LED out of diagnostic mode\n\t\t */\n\t\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\t\tahc_outb(ahc, SBLKCTL, (sblkctl & ~(DIAGLEDEN|DIAGLEDON)));\n\n\t\t/*\n\t\t * I don't know where this is set in the SEEPROM or by the\n\t\t * BIOS, so we default to 100% on Ultra or slower controllers\n\t\t * and 75% on ULTRA2 controllers.\n\t\t */\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\tahc_outb(ahc, DFF_THRSH, RD_DFTHRSH_75|WR_DFTHRSH_75);\n\t\t} else {\n\t\t\tahc_outb(ahc, DSPCISTATUS, DFTHRSH_100);\n\t\t}\n\n\t\tif (ahc->flags & AHC_USEDEFAULTS) {\n\t\t\t/*\n\t\t\t * PCI Adapter default setup\n\t\t\t * Should only be used if the adapter does not have\n\t\t\t * an SEEPROM.\n\t\t\t */\n\t\t\t/* See if someone else set us up already */\n\t\t\tif (scsiseq != 0) {\n\t\t\t\tprintf(\"%s: Using left over BIOS settings\\n\",\n\t\t\t\t\t\t ahc_name(ahc));\n\t\t\t\tahc->flags &= ~AHC_USEDEFAULTS;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Assume only one connector and always turn\n\t\t\t\t * on termination.\n\t\t\t\t */\n\t\t\t\tour_id = 0x07;\n\t\t\t\tsxfrctl1 = STPWEN;\n\t\t\t}\n\t\t\tahc_outb(ahc, SCSICONF, our_id|ENSPCHK|RESET_SCSI);\n\n\t\t\tahc->our_id = our_id;\n\t\t}\n\t}\n\n\t/*\n\t * Take a look to see if we have external SRAM.\n\t * We currently do not attempt to use SRAM that is\n\t * shared among multiple controllers.\n\t */\n\tahc_probe_ext_scbram(ahc);\n\n\tprintf(\"%s: \", ahc_name(ahc));\n\n\t/*\n\t * Record our termination setting for the\n\t * generic initialization routine.\n\t */\n\tif ((sxfrctl1 & STPWEN) != 0)\n\t\tahc->flags |= AHC_TERM_ENB_A;\n\n\tif (ahc_init(ahc)) {\n\t\tahc_free(ahc);\n\t\tsplx(opri);\n\t\treturn; /* XXX PCI code should take return status */\n\t}\n\tsplx(opri);\n\n\tahc_attach(ahc);\n}"
  },
  {
    "function_name": "ahc_pci_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ahc_pci.c",
    "lines": "146-196",
    "snippet": "int\nahc_pci_probe(parent, match, aux)\nstruct device *parent;\nvoid *match, *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\n\tswitch (PCI_VENDOR(pa->pa_id)) {\n\tcase PCI_VENDOR_ADP:\n\t\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\t\tcase PCI_PRODUCT_ADP_AIC7810:\n\t\tcase PCI_PRODUCT_ADP_AIC7850:\n\t\tcase PCI_PRODUCT_ADP_AIC7855:\n\t\tcase PCI_PRODUCT_ADP_AIC5900:\n\t\tcase PCI_PRODUCT_ADP_AIC5905:\n\t\tcase PCI_PRODUCT_ADP_AIC7860:\n\t\tcase PCI_PRODUCT_ADP_2940AU:\n\t\tcase PCI_PRODUCT_ADP_AIC7870:\n\t\tcase PCI_PRODUCT_ADP_2940:\n\t\tcase PCI_PRODUCT_ADP_3940:\n\t\tcase PCI_PRODUCT_ADP_3985:\n\t\tcase PCI_PRODUCT_ADP_2944:\n\t\tcase PCI_PRODUCT_ADP_AIC7880:\n\t\tcase PCI_PRODUCT_ADP_2940U:\n\t\tcase PCI_PRODUCT_ADP_3940U:\n\t\tcase PCI_PRODUCT_ADP_398XU:\n\t\tcase PCI_PRODUCT_ADP_2944U:\n\t\tcase PCI_PRODUCT_ADP_2940UWPro:\n\t\tcase PCI_PRODUCT_ADP_7895:\n\t\t\treturn (1);\n\t\t}\n\t\t\tbreak;\n\tcase PCI_VENDOR_ADP2:\n\t\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\t\tcase PCI_PRODUCT_ADP2_AIC7890:\n\t\tcase PCI_PRODUCT_ADP2_2940U2:\n\t\tcase PCI_PRODUCT_ADP2_2930U2:\n\t\tcase PCI_PRODUCT_ADP2_AIC7892:\n\t\tcase PCI_PRODUCT_ADP2_29160:\n\t\tcase PCI_PRODUCT_ADP2_19160B:\n\t\tcase PCI_PRODUCT_ADP2_3950U2B:\n\t\tcase PCI_PRODUCT_ADP2_3950U2D:\n\t\tcase PCI_PRODUCT_ADP2_AIC7896:\n\t\tcase PCI_PRODUCT_ADP2_AIC7899:\n\t\tcase PCI_PRODUCT_ADP2_3960D:\n\t\t\treturn (1);\n\t\t}\n\t\tbreak;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/smc93cx6var.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ahc_pci_probe"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc93cx6var.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint ahc_pci_probe;\n\nint\nahc_pci_probe(parent, match, aux)\nstruct device *parent;\nvoid *match, *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\n\tswitch (PCI_VENDOR(pa->pa_id)) {\n\tcase PCI_VENDOR_ADP:\n\t\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\t\tcase PCI_PRODUCT_ADP_AIC7810:\n\t\tcase PCI_PRODUCT_ADP_AIC7850:\n\t\tcase PCI_PRODUCT_ADP_AIC7855:\n\t\tcase PCI_PRODUCT_ADP_AIC5900:\n\t\tcase PCI_PRODUCT_ADP_AIC5905:\n\t\tcase PCI_PRODUCT_ADP_AIC7860:\n\t\tcase PCI_PRODUCT_ADP_2940AU:\n\t\tcase PCI_PRODUCT_ADP_AIC7870:\n\t\tcase PCI_PRODUCT_ADP_2940:\n\t\tcase PCI_PRODUCT_ADP_3940:\n\t\tcase PCI_PRODUCT_ADP_3985:\n\t\tcase PCI_PRODUCT_ADP_2944:\n\t\tcase PCI_PRODUCT_ADP_AIC7880:\n\t\tcase PCI_PRODUCT_ADP_2940U:\n\t\tcase PCI_PRODUCT_ADP_3940U:\n\t\tcase PCI_PRODUCT_ADP_398XU:\n\t\tcase PCI_PRODUCT_ADP_2944U:\n\t\tcase PCI_PRODUCT_ADP_2940UWPro:\n\t\tcase PCI_PRODUCT_ADP_7895:\n\t\t\treturn (1);\n\t\t}\n\t\t\tbreak;\n\tcase PCI_VENDOR_ADP2:\n\t\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\t\tcase PCI_PRODUCT_ADP2_AIC7890:\n\t\tcase PCI_PRODUCT_ADP2_2940U2:\n\t\tcase PCI_PRODUCT_ADP2_2930U2:\n\t\tcase PCI_PRODUCT_ADP2_AIC7892:\n\t\tcase PCI_PRODUCT_ADP2_29160:\n\t\tcase PCI_PRODUCT_ADP2_19160B:\n\t\tcase PCI_PRODUCT_ADP2_3950U2B:\n\t\tcase PCI_PRODUCT_ADP2_3950U2D:\n\t\tcase PCI_PRODUCT_ADP2_AIC7896:\n\t\tcase PCI_PRODUCT_ADP2_AIC7899:\n\t\tcase PCI_PRODUCT_ADP2_3960D:\n\t\t\treturn (1);\n\t\t}\n\t\tbreak;\n\t}\n\treturn (0);\n}"
  }
]