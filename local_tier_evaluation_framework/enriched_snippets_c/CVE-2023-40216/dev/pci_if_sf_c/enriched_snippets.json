[
  {
    "function_name": "sf_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "1386-1392",
    "snippet": "void sf_shutdown(v)\n\tvoid\t\t\t*v;\n{\n\tstruct sf_softc\t\t*sc = (struct sf_softc *)v;\n\t\n\tsf_stop(sc);\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sf_shutdown",
      "void sf_stop"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sf_stop",
          "args": [
            "sc"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "sf_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "1272-1312",
          "snippet": "void sf_stop(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tuntimeout(sf_stats_update, sc);\n\n\tcsr_write_4(sc, SF_GEN_ETH_CTL, 0);\n\tcsr_write_4(sc, SF_CQ_CONSIDX, 0);\n\tcsr_write_4(sc, SF_CQ_PRODIDX, 0);\n\tcsr_write_4(sc, SF_RXDQ_ADDR_Q1, 0);\n\tcsr_write_4(sc, SF_RXDQ_CTL_1, 0);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1, 0);\n\tcsr_write_4(sc, SF_TXCQ_CTL, 0);\n\tcsr_write_4(sc, SF_TXDQ_ADDR_HIPRIO, 0);\n\tcsr_write_4(sc, SF_TXDQ_CTL, 0);\n\tsf_reset(sc);\n\n\tsc->sf_link = 0;\n\n\tfor (i = 0; i < SF_RX_DLIST_CNT; i++) {\n\t\tif (sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf != NULL) {\n\t\t\tm_freem(sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf);\n\t\t\tsc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < SF_TX_DLIST_CNT; i++) {\n\t\tif (sc->sf_ldata->sf_tx_dlist[i].sf_mbuf != NULL) {\n\t\t\tm_freem(sc->sf_ldata->sf_tx_dlist[i].sf_mbuf);\n\t\t\tsc->sf_ldata->sf_tx_dlist[i].sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sf_stats_update",
            "void sf_stop",
            "void sf_reset",
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_stats_update;\nvoid sf_stop;\nvoid sf_reset;\nvoid csr_write_4;\n\nvoid sf_stop(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tuntimeout(sf_stats_update, sc);\n\n\tcsr_write_4(sc, SF_GEN_ETH_CTL, 0);\n\tcsr_write_4(sc, SF_CQ_CONSIDX, 0);\n\tcsr_write_4(sc, SF_CQ_PRODIDX, 0);\n\tcsr_write_4(sc, SF_RXDQ_ADDR_Q1, 0);\n\tcsr_write_4(sc, SF_RXDQ_CTL_1, 0);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1, 0);\n\tcsr_write_4(sc, SF_TXCQ_CTL, 0);\n\tcsr_write_4(sc, SF_TXDQ_ADDR_HIPRIO, 0);\n\tcsr_write_4(sc, SF_TXDQ_CTL, 0);\n\tsf_reset(sc);\n\n\tsc->sf_link = 0;\n\n\tfor (i = 0; i < SF_RX_DLIST_CNT; i++) {\n\t\tif (sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf != NULL) {\n\t\t\tm_freem(sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf);\n\t\t\tsc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < SF_TX_DLIST_CNT; i++) {\n\t\tif (sc->sf_ldata->sf_tx_dlist[i].sf_mbuf != NULL) {\n\t\t\tm_freem(sc->sf_ldata->sf_tx_dlist[i].sf_mbuf);\n\t\t\tsc->sf_ldata->sf_tx_dlist[i].sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_shutdown;\nvoid sf_stop;\n\nvoid sf_shutdown(v)\n\tvoid\t\t\t*v;\n{\n\tstruct sf_softc\t\t*sc = (struct sf_softc *)v;\n\t\n\tsf_stop(sc);\n}"
  },
  {
    "function_name": "sf_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "1366-1384",
    "snippet": "void sf_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct sf_softc\t\t*sc;\n\n\tsc = ifp->if_softc;\n\n\tifp->if_oerrors++;\n\tprintf(\"sf%d: watchdog timeout\\n\", sc->sf_unit);\n\n\tsf_stop(sc);\n\tsf_reset(sc);\n\tsf_init(sc);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\tsf_start(ifp);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sf_start",
      "void sf_init",
      "void sf_stop",
      "void sf_watchdog",
      "void sf_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sf_start",
          "args": [
            "ifp"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "sf_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "1214-1270",
          "snippet": "void sf_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct sf_softc\t\t*sc;\n\tstruct sf_tx_bufdesc_type0 *cur_tx = NULL;\n\tstruct mbuf\t\t*m_head = NULL;\n\tint\t\t\ti, txprod;\n\n\tsc = ifp->if_softc;\n\n\tif (!sc->sf_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\ttxprod = csr_read_4(sc, SF_TXDQ_PRODIDX);\n\ti = SF_IDX_HI(txprod) >> 4;\n\n\twhile(sc->sf_ldata->sf_tx_dlist[i].sf_mbuf == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\tcur_tx = &sc->sf_ldata->sf_tx_dlist[i];\n\t\tif (sf_encap(sc, cur_tx, m_head)) {\n\t\t\tm_freem(m_head);\n\t\t\tcontinue;\n\t\t}\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->sf_mbuf);\n#endif\n\n\t\tSF_INC(i, SF_TX_DLIST_CNT);\n\t\tsc->sf_tx_cnt++;\n\t\tif (sc->sf_tx_cnt == (SF_TX_DLIST_CNT - 2))\n\t\t\tbreak;\n\t}\n\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\t/* Transmit */\n\tcsr_write_4(sc, SF_TXDQ_PRODIDX,\n\t    (txprod & ~SF_TXDQ_PRODIDX_HIPRIO) |\n\t    ((i << 20) & 0xFFFF0000));\n\n\tifp->if_timer = 5;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int sf_encap",
            "void sf_start",
            "u_int32_t csr_read_4",
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_encap;\nvoid sf_start;\nu_int32_t csr_read_4;\nvoid csr_write_4;\n\nvoid sf_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct sf_softc\t\t*sc;\n\tstruct sf_tx_bufdesc_type0 *cur_tx = NULL;\n\tstruct mbuf\t\t*m_head = NULL;\n\tint\t\t\ti, txprod;\n\n\tsc = ifp->if_softc;\n\n\tif (!sc->sf_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\ttxprod = csr_read_4(sc, SF_TXDQ_PRODIDX);\n\ti = SF_IDX_HI(txprod) >> 4;\n\n\twhile(sc->sf_ldata->sf_tx_dlist[i].sf_mbuf == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\tcur_tx = &sc->sf_ldata->sf_tx_dlist[i];\n\t\tif (sf_encap(sc, cur_tx, m_head)) {\n\t\t\tm_freem(m_head);\n\t\t\tcontinue;\n\t\t}\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->sf_mbuf);\n#endif\n\n\t\tSF_INC(i, SF_TX_DLIST_CNT);\n\t\tsc->sf_tx_cnt++;\n\t\tif (sc->sf_tx_cnt == (SF_TX_DLIST_CNT - 2))\n\t\t\tbreak;\n\t}\n\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\t/* Transmit */\n\tcsr_write_4(sc, SF_TXDQ_PRODIDX,\n\t    (txprod & ~SF_TXDQ_PRODIDX_HIPRIO) |\n\t    ((i << 20) & 0xFFFF0000));\n\n\tifp->if_timer = 5;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sf_init",
          "args": [
            "sc"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "sf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "1044-1149",
          "snippet": "void sf_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct sf_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ti, s;\n\n\ts = splimp();\n\n\tmii = &sc->sc_mii;\n\n\tsf_stop(sc);\n\tsf_reset(sc);\n\n\t/* Init all the receive filter registers */\n\tfor (i = SF_RXFILT_PERFECT_BASE;\n\t    i < (SF_RXFILT_HASH_MAX + 1); i += 4)\n\t\tcsr_write_4(sc, i, 0);\n\n\t/* Empty stats counter registers. */\n\tfor (i = 0; i < sizeof(struct sf_stats)/sizeof(u_int32_t); i++)\n\t\tcsr_write_4(sc, SF_STATS_BASE +\n\t\t    (i + sizeof(u_int32_t)), 0);\n\n\t/* Init our MAC address */\n\tcsr_write_4(sc, SF_PAR0, *(u_int32_t *)(&sc->arpcom.ac_enaddr[0]));\n\tcsr_write_4(sc, SF_PAR1, *(u_int32_t *)(&sc->arpcom.ac_enaddr[4]));\n\tsf_setperf(sc, 0, (caddr_t)&sc->arpcom.ac_enaddr);\n\n\tif (sf_init_rx_ring(sc) == ENOBUFS) {\n\t\tprintf(\"sf%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc->sf_unit);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\tsf_init_tx_ring(sc);\n\n\tcsr_write_4(sc, SF_RXFILT, SF_PERFMODE_NORMAL|SF_HASHMODE_WITHVLAN);\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);\n\t} else {\n\t\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);\n\t}\n\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_BROAD);\n\t} else {\n\t\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_BROAD);\n\t}\n\n\t/* Init the completion queue indexes */\n\tcsr_write_4(sc, SF_CQ_CONSIDX, 0);\n\tcsr_write_4(sc, SF_CQ_PRODIDX, 0);\n\n\t/* Init the RX completion queue */\n\tcsr_write_4(sc, SF_RXCQ_CTL_1,\n\t    vtophys(sc->sf_ldata->sf_rx_clist) & SF_RXCQ_ADDR);\n\tSF_SETBIT(sc, SF_RXCQ_CTL_1, SF_RXCQTYPE_3);\n\n\t/* Init RX DMA control. */\n\tSF_SETBIT(sc, SF_RXDMA_CTL, SF_RXDMA_REPORTBADPKTS);\n\n\t/* Init the RX buffer descriptor queue. */\n\tcsr_write_4(sc, SF_RXDQ_ADDR_Q1,\n\t    vtophys(sc->sf_ldata->sf_rx_dlist_big));\n\tcsr_write_4(sc, SF_RXDQ_CTL_1, (MCLBYTES << 16) | SF_DESCSPACE_16BYTES);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1, SF_RX_DLIST_CNT - 1);\n\n\t/* Init the TX completion queue */\n\tcsr_write_4(sc, SF_TXCQ_CTL,\n\t    vtophys(sc->sf_ldata->sf_tx_clist) & SF_RXCQ_ADDR);\n\n\t/* Init the TX buffer descriptor queue. */\n\tcsr_write_4(sc, SF_TXDQ_ADDR_HIPRIO,\n\t\tvtophys(sc->sf_ldata->sf_tx_dlist));\n\tSF_SETBIT(sc, SF_TX_FRAMCTL, SF_TXFRMCTL_CPLAFTERTX);\n\tcsr_write_4(sc, SF_TXDQ_CTL,\n\t    SF_TXBUFDESC_TYPE0|SF_TXMINSPACE_128BYTES|SF_TXSKIPLEN_8BYTES);\n\tSF_SETBIT(sc, SF_TXDQ_CTL, SF_TXDQCTL_NODMACMP);\n\n\t/* Enable autopadding of short TX frames. */\n\tSF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_AUTOPAD);\n\n\t/* Enable interrupts. */\n\tcsr_write_4(sc, SF_IMR, SF_INTRS);\n\tSF_SETBIT(sc, SF_PCI_DEVCFG, SF_PCIDEVCFG_INTR_ENB);\n\n\t/* Enable the RX and TX engines. */\n\tSF_SETBIT(sc, SF_GEN_ETH_CTL, SF_ETHCTL_RX_ENB|SF_ETHCTL_RXDMA_ENB);\n\tSF_SETBIT(sc, SF_GEN_ETH_CTL, SF_ETHCTL_TX_ENB|SF_ETHCTL_TXDMA_ENB);\n\n\tsf_ifmedia_upd(ifp);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\ttimeout(sf_stats_update, sc, hz);\n\n\tsplx(s);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sf_stats_update",
            "void sf_init",
            "void sf_stop",
            "int sf_ifmedia_upd",
            "void sf_reset",
            "int sf_init_rx_ring",
            "void sf_init_tx_ring",
            "int sf_setperf",
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_stats_update;\nvoid sf_init;\nvoid sf_stop;\nint sf_ifmedia_upd;\nvoid sf_reset;\nint sf_init_rx_ring;\nvoid sf_init_tx_ring;\nint sf_setperf;\nvoid csr_write_4;\n\nvoid sf_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct sf_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ti, s;\n\n\ts = splimp();\n\n\tmii = &sc->sc_mii;\n\n\tsf_stop(sc);\n\tsf_reset(sc);\n\n\t/* Init all the receive filter registers */\n\tfor (i = SF_RXFILT_PERFECT_BASE;\n\t    i < (SF_RXFILT_HASH_MAX + 1); i += 4)\n\t\tcsr_write_4(sc, i, 0);\n\n\t/* Empty stats counter registers. */\n\tfor (i = 0; i < sizeof(struct sf_stats)/sizeof(u_int32_t); i++)\n\t\tcsr_write_4(sc, SF_STATS_BASE +\n\t\t    (i + sizeof(u_int32_t)), 0);\n\n\t/* Init our MAC address */\n\tcsr_write_4(sc, SF_PAR0, *(u_int32_t *)(&sc->arpcom.ac_enaddr[0]));\n\tcsr_write_4(sc, SF_PAR1, *(u_int32_t *)(&sc->arpcom.ac_enaddr[4]));\n\tsf_setperf(sc, 0, (caddr_t)&sc->arpcom.ac_enaddr);\n\n\tif (sf_init_rx_ring(sc) == ENOBUFS) {\n\t\tprintf(\"sf%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc->sf_unit);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\tsf_init_tx_ring(sc);\n\n\tcsr_write_4(sc, SF_RXFILT, SF_PERFMODE_NORMAL|SF_HASHMODE_WITHVLAN);\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);\n\t} else {\n\t\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);\n\t}\n\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_BROAD);\n\t} else {\n\t\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_BROAD);\n\t}\n\n\t/* Init the completion queue indexes */\n\tcsr_write_4(sc, SF_CQ_CONSIDX, 0);\n\tcsr_write_4(sc, SF_CQ_PRODIDX, 0);\n\n\t/* Init the RX completion queue */\n\tcsr_write_4(sc, SF_RXCQ_CTL_1,\n\t    vtophys(sc->sf_ldata->sf_rx_clist) & SF_RXCQ_ADDR);\n\tSF_SETBIT(sc, SF_RXCQ_CTL_1, SF_RXCQTYPE_3);\n\n\t/* Init RX DMA control. */\n\tSF_SETBIT(sc, SF_RXDMA_CTL, SF_RXDMA_REPORTBADPKTS);\n\n\t/* Init the RX buffer descriptor queue. */\n\tcsr_write_4(sc, SF_RXDQ_ADDR_Q1,\n\t    vtophys(sc->sf_ldata->sf_rx_dlist_big));\n\tcsr_write_4(sc, SF_RXDQ_CTL_1, (MCLBYTES << 16) | SF_DESCSPACE_16BYTES);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1, SF_RX_DLIST_CNT - 1);\n\n\t/* Init the TX completion queue */\n\tcsr_write_4(sc, SF_TXCQ_CTL,\n\t    vtophys(sc->sf_ldata->sf_tx_clist) & SF_RXCQ_ADDR);\n\n\t/* Init the TX buffer descriptor queue. */\n\tcsr_write_4(sc, SF_TXDQ_ADDR_HIPRIO,\n\t\tvtophys(sc->sf_ldata->sf_tx_dlist));\n\tSF_SETBIT(sc, SF_TX_FRAMCTL, SF_TXFRMCTL_CPLAFTERTX);\n\tcsr_write_4(sc, SF_TXDQ_CTL,\n\t    SF_TXBUFDESC_TYPE0|SF_TXMINSPACE_128BYTES|SF_TXSKIPLEN_8BYTES);\n\tSF_SETBIT(sc, SF_TXDQ_CTL, SF_TXDQCTL_NODMACMP);\n\n\t/* Enable autopadding of short TX frames. */\n\tSF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_AUTOPAD);\n\n\t/* Enable interrupts. */\n\tcsr_write_4(sc, SF_IMR, SF_INTRS);\n\tSF_SETBIT(sc, SF_PCI_DEVCFG, SF_PCIDEVCFG_INTR_ENB);\n\n\t/* Enable the RX and TX engines. */\n\tSF_SETBIT(sc, SF_GEN_ETH_CTL, SF_ETHCTL_RX_ENB|SF_ETHCTL_RXDMA_ENB);\n\tSF_SETBIT(sc, SF_GEN_ETH_CTL, SF_ETHCTL_TX_ENB|SF_ETHCTL_TXDMA_ENB);\n\n\tsf_ifmedia_upd(ifp);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\ttimeout(sf_stats_update, sc, hz);\n\n\tsplx(s);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sf_reset",
          "args": [
            "sc"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "sf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "552-576",
          "snippet": "void sf_reset(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tcsr_write_4(sc, SF_GEN_ETH_CTL, 0);\n\tSF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);\n\tDELAY(1000);\n\tSF_CLRBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);\n\n\tSF_SETBIT(sc, SF_PCI_DEVCFG, SF_PCIDEVCFG_RESET);\n\n\tfor (i = 0; i < SF_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(csr_read_4(sc, SF_PCI_DEVCFG) & SF_PCIDEVCFG_RESET))\n\t\t\tbreak;\n\t}\n\n\tif (i == SF_TIMEOUT)\n\t\tprintf(\"sf%d: reset never completed!\\n\", sc->sf_unit);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sf_reset",
            "u_int32_t csr_read_4",
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_reset;\nu_int32_t csr_read_4;\nvoid csr_write_4;\n\nvoid sf_reset(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tcsr_write_4(sc, SF_GEN_ETH_CTL, 0);\n\tSF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);\n\tDELAY(1000);\n\tSF_CLRBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);\n\n\tSF_SETBIT(sc, SF_PCI_DEVCFG, SF_PCIDEVCFG_RESET);\n\n\tfor (i = 0; i < SF_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(csr_read_4(sc, SF_PCI_DEVCFG) & SF_PCIDEVCFG_RESET))\n\t\t\tbreak;\n\t}\n\n\tif (i == SF_TIMEOUT)\n\t\tprintf(\"sf%d: reset never completed!\\n\", sc->sf_unit);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sf_stop",
          "args": [
            "sc"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "sf_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "1272-1312",
          "snippet": "void sf_stop(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tuntimeout(sf_stats_update, sc);\n\n\tcsr_write_4(sc, SF_GEN_ETH_CTL, 0);\n\tcsr_write_4(sc, SF_CQ_CONSIDX, 0);\n\tcsr_write_4(sc, SF_CQ_PRODIDX, 0);\n\tcsr_write_4(sc, SF_RXDQ_ADDR_Q1, 0);\n\tcsr_write_4(sc, SF_RXDQ_CTL_1, 0);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1, 0);\n\tcsr_write_4(sc, SF_TXCQ_CTL, 0);\n\tcsr_write_4(sc, SF_TXDQ_ADDR_HIPRIO, 0);\n\tcsr_write_4(sc, SF_TXDQ_CTL, 0);\n\tsf_reset(sc);\n\n\tsc->sf_link = 0;\n\n\tfor (i = 0; i < SF_RX_DLIST_CNT; i++) {\n\t\tif (sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf != NULL) {\n\t\t\tm_freem(sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf);\n\t\t\tsc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < SF_TX_DLIST_CNT; i++) {\n\t\tif (sc->sf_ldata->sf_tx_dlist[i].sf_mbuf != NULL) {\n\t\t\tm_freem(sc->sf_ldata->sf_tx_dlist[i].sf_mbuf);\n\t\t\tsc->sf_ldata->sf_tx_dlist[i].sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sf_stats_update",
            "void sf_stop",
            "void sf_reset",
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_stats_update;\nvoid sf_stop;\nvoid sf_reset;\nvoid csr_write_4;\n\nvoid sf_stop(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tuntimeout(sf_stats_update, sc);\n\n\tcsr_write_4(sc, SF_GEN_ETH_CTL, 0);\n\tcsr_write_4(sc, SF_CQ_CONSIDX, 0);\n\tcsr_write_4(sc, SF_CQ_PRODIDX, 0);\n\tcsr_write_4(sc, SF_RXDQ_ADDR_Q1, 0);\n\tcsr_write_4(sc, SF_RXDQ_CTL_1, 0);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1, 0);\n\tcsr_write_4(sc, SF_TXCQ_CTL, 0);\n\tcsr_write_4(sc, SF_TXDQ_ADDR_HIPRIO, 0);\n\tcsr_write_4(sc, SF_TXDQ_CTL, 0);\n\tsf_reset(sc);\n\n\tsc->sf_link = 0;\n\n\tfor (i = 0; i < SF_RX_DLIST_CNT; i++) {\n\t\tif (sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf != NULL) {\n\t\t\tm_freem(sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf);\n\t\t\tsc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < SF_TX_DLIST_CNT; i++) {\n\t\tif (sc->sf_ldata->sf_tx_dlist[i].sf_mbuf != NULL) {\n\t\t\tm_freem(sc->sf_ldata->sf_tx_dlist[i].sf_mbuf);\n\t\t\tsc->sf_ldata->sf_tx_dlist[i].sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"sf%d: watchdog timeout\\n\"",
            "sc->sf_unit"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_start;\nvoid sf_init;\nvoid sf_stop;\nvoid sf_watchdog;\nvoid sf_reset;\n\nvoid sf_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct sf_softc\t\t*sc;\n\n\tsc = ifp->if_softc;\n\n\tifp->if_oerrors++;\n\tprintf(\"sf%d: watchdog timeout\\n\", sc->sf_unit);\n\n\tsf_stop(sc);\n\tsf_reset(sc);\n\tsf_init(sc);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\tsf_start(ifp);\n\n\treturn;\n}"
  },
  {
    "function_name": "sf_stats_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "1321-1364",
    "snippet": "void sf_stats_update(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct sf_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tstruct mii_data\t\t*mii;\n\tstruct sf_stats\t\tstats;\n\tu_int32_t\t\t*ptr;\n\tint\t\t\ti, s;\n\n\ts = splimp();\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\tmii = &sc->sc_mii;\n\n\tptr = (u_int32_t *)&stats;\n\tfor (i = 0; i < sizeof(stats)/sizeof(u_int32_t); i++)\n\t\tptr[i] = csr_read_4(sc, SF_STATS_BASE +\n\t\t    (i + sizeof(u_int32_t)));\n\n\tfor (i = 0; i < sizeof(stats)/sizeof(u_int32_t); i++)\n\t\tcsr_write_4(sc, SF_STATS_BASE +\n\t\t    (i + sizeof(u_int32_t)), 0);\n\n\tifp->if_collisions += stats.sf_tx_single_colls +\n\t    stats.sf_tx_multi_colls + stats.sf_tx_excess_colls;\n\n\tmii_tick(mii);\n\tif (!sc->sf_link) {\n\t\tmii_pollstat(mii);\n\t\tif (mii->mii_media_status & IFM_ACTIVE &&\n\t\t    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE)\n\t\t\tsc->sf_link++;\n\t\tif (ifp->if_snd.ifq_head != NULL)\n\t\t\tsf_start(ifp);\n\t}\n\n\ttimeout(sf_stats_update, sc, hz);\n\n\tsplx(s);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sf_stats_update",
      "void sf_start",
      "u_int32_t csr_read_4",
      "void csr_write_4"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "sf_stats_update",
            "sc",
            "hz"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sf_start",
          "args": [
            "ifp"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "sf_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "1214-1270",
          "snippet": "void sf_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct sf_softc\t\t*sc;\n\tstruct sf_tx_bufdesc_type0 *cur_tx = NULL;\n\tstruct mbuf\t\t*m_head = NULL;\n\tint\t\t\ti, txprod;\n\n\tsc = ifp->if_softc;\n\n\tif (!sc->sf_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\ttxprod = csr_read_4(sc, SF_TXDQ_PRODIDX);\n\ti = SF_IDX_HI(txprod) >> 4;\n\n\twhile(sc->sf_ldata->sf_tx_dlist[i].sf_mbuf == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\tcur_tx = &sc->sf_ldata->sf_tx_dlist[i];\n\t\tif (sf_encap(sc, cur_tx, m_head)) {\n\t\t\tm_freem(m_head);\n\t\t\tcontinue;\n\t\t}\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->sf_mbuf);\n#endif\n\n\t\tSF_INC(i, SF_TX_DLIST_CNT);\n\t\tsc->sf_tx_cnt++;\n\t\tif (sc->sf_tx_cnt == (SF_TX_DLIST_CNT - 2))\n\t\t\tbreak;\n\t}\n\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\t/* Transmit */\n\tcsr_write_4(sc, SF_TXDQ_PRODIDX,\n\t    (txprod & ~SF_TXDQ_PRODIDX_HIPRIO) |\n\t    ((i << 20) & 0xFFFF0000));\n\n\tifp->if_timer = 5;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int sf_encap",
            "void sf_start",
            "u_int32_t csr_read_4",
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_encap;\nvoid sf_start;\nu_int32_t csr_read_4;\nvoid csr_write_4;\n\nvoid sf_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct sf_softc\t\t*sc;\n\tstruct sf_tx_bufdesc_type0 *cur_tx = NULL;\n\tstruct mbuf\t\t*m_head = NULL;\n\tint\t\t\ti, txprod;\n\n\tsc = ifp->if_softc;\n\n\tif (!sc->sf_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\ttxprod = csr_read_4(sc, SF_TXDQ_PRODIDX);\n\ti = SF_IDX_HI(txprod) >> 4;\n\n\twhile(sc->sf_ldata->sf_tx_dlist[i].sf_mbuf == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\tcur_tx = &sc->sf_ldata->sf_tx_dlist[i];\n\t\tif (sf_encap(sc, cur_tx, m_head)) {\n\t\t\tm_freem(m_head);\n\t\t\tcontinue;\n\t\t}\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->sf_mbuf);\n#endif\n\n\t\tSF_INC(i, SF_TX_DLIST_CNT);\n\t\tsc->sf_tx_cnt++;\n\t\tif (sc->sf_tx_cnt == (SF_TX_DLIST_CNT - 2))\n\t\t\tbreak;\n\t}\n\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\t/* Transmit */\n\tcsr_write_4(sc, SF_TXDQ_PRODIDX,\n\t    (txprod & ~SF_TXDQ_PRODIDX_HIPRIO) |\n\t    ((i << 20) & 0xFFFF0000));\n\n\tifp->if_timer = 5;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "mii->mii_media_active"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mii_pollstat",
          "args": [
            "mii"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "mii_pollstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "206-218",
          "snippet": "void\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mii_tick",
          "args": [
            "mii"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "mii_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "192-201",
          "snippet": "void\nmii_tick(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_TICK);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_tick(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_TICK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "csr_write_4",
          "args": [
            "sc",
            "SF_STATS_BASE +\n\t\t    (i + sizeof(u_int32_t))",
            "0"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "csr_write_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "199-211",
          "snippet": "void csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nvoid csr_write_4;\n\nvoid csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "csr_read_4",
          "args": [
            "sc",
            "SF_STATS_BASE +\n\t\t    (i + sizeof(u_int32_t))"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "csr_read_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "171-185",
          "snippet": "u_int32_t csr_read_4(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int32_t\t\tval;\n\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tval = CSR_READ_4(sc, SF_INDIRECTIO_DATA);\n#else\n\tval = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));\n#endif\n\n\treturn(val);\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "u_int32_t csr_read_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nu_int32_t csr_read_4;\n\nu_int32_t csr_read_4(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int32_t\t\tval;\n\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tval = CSR_READ_4(sc, SF_INDIRECTIO_DATA);\n#else\n\tval = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));\n#endif\n\n\treturn(val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_stats_update;\nvoid sf_start;\nu_int32_t csr_read_4;\nvoid csr_write_4;\n\nvoid sf_stats_update(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct sf_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tstruct mii_data\t\t*mii;\n\tstruct sf_stats\t\tstats;\n\tu_int32_t\t\t*ptr;\n\tint\t\t\ti, s;\n\n\ts = splimp();\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\tmii = &sc->sc_mii;\n\n\tptr = (u_int32_t *)&stats;\n\tfor (i = 0; i < sizeof(stats)/sizeof(u_int32_t); i++)\n\t\tptr[i] = csr_read_4(sc, SF_STATS_BASE +\n\t\t    (i + sizeof(u_int32_t)));\n\n\tfor (i = 0; i < sizeof(stats)/sizeof(u_int32_t); i++)\n\t\tcsr_write_4(sc, SF_STATS_BASE +\n\t\t    (i + sizeof(u_int32_t)), 0);\n\n\tifp->if_collisions += stats.sf_tx_single_colls +\n\t    stats.sf_tx_multi_colls + stats.sf_tx_excess_colls;\n\n\tmii_tick(mii);\n\tif (!sc->sf_link) {\n\t\tmii_pollstat(mii);\n\t\tif (mii->mii_media_status & IFM_ACTIVE &&\n\t\t    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE)\n\t\t\tsc->sf_link++;\n\t\tif (ifp->if_snd.ifq_head != NULL)\n\t\t\tsf_start(ifp);\n\t}\n\n\ttimeout(sf_stats_update, sc, hz);\n\n\tsplx(s);\n\n\treturn;\n}"
  },
  {
    "function_name": "sf_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "1272-1312",
    "snippet": "void sf_stop(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tuntimeout(sf_stats_update, sc);\n\n\tcsr_write_4(sc, SF_GEN_ETH_CTL, 0);\n\tcsr_write_4(sc, SF_CQ_CONSIDX, 0);\n\tcsr_write_4(sc, SF_CQ_PRODIDX, 0);\n\tcsr_write_4(sc, SF_RXDQ_ADDR_Q1, 0);\n\tcsr_write_4(sc, SF_RXDQ_CTL_1, 0);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1, 0);\n\tcsr_write_4(sc, SF_TXCQ_CTL, 0);\n\tcsr_write_4(sc, SF_TXDQ_ADDR_HIPRIO, 0);\n\tcsr_write_4(sc, SF_TXDQ_CTL, 0);\n\tsf_reset(sc);\n\n\tsc->sf_link = 0;\n\n\tfor (i = 0; i < SF_RX_DLIST_CNT; i++) {\n\t\tif (sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf != NULL) {\n\t\t\tm_freem(sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf);\n\t\t\tsc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < SF_TX_DLIST_CNT; i++) {\n\t\tif (sc->sf_ldata->sf_tx_dlist[i].sf_mbuf != NULL) {\n\t\t\tm_freem(sc->sf_ldata->sf_tx_dlist[i].sf_mbuf);\n\t\t\tsc->sf_ldata->sf_tx_dlist[i].sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sf_stats_update",
      "void sf_stop",
      "void sf_reset",
      "void csr_write_4"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->sf_ldata->sf_tx_dlist[i].sf_mbuf"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sf_reset",
          "args": [
            "sc"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "sf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "552-576",
          "snippet": "void sf_reset(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tcsr_write_4(sc, SF_GEN_ETH_CTL, 0);\n\tSF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);\n\tDELAY(1000);\n\tSF_CLRBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);\n\n\tSF_SETBIT(sc, SF_PCI_DEVCFG, SF_PCIDEVCFG_RESET);\n\n\tfor (i = 0; i < SF_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(csr_read_4(sc, SF_PCI_DEVCFG) & SF_PCIDEVCFG_RESET))\n\t\t\tbreak;\n\t}\n\n\tif (i == SF_TIMEOUT)\n\t\tprintf(\"sf%d: reset never completed!\\n\", sc->sf_unit);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sf_reset",
            "u_int32_t csr_read_4",
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_reset;\nu_int32_t csr_read_4;\nvoid csr_write_4;\n\nvoid sf_reset(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tcsr_write_4(sc, SF_GEN_ETH_CTL, 0);\n\tSF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);\n\tDELAY(1000);\n\tSF_CLRBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);\n\n\tSF_SETBIT(sc, SF_PCI_DEVCFG, SF_PCIDEVCFG_RESET);\n\n\tfor (i = 0; i < SF_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(csr_read_4(sc, SF_PCI_DEVCFG) & SF_PCIDEVCFG_RESET))\n\t\t\tbreak;\n\t}\n\n\tif (i == SF_TIMEOUT)\n\t\tprintf(\"sf%d: reset never completed!\\n\", sc->sf_unit);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "csr_write_4",
          "args": [
            "sc",
            "SF_TXDQ_CTL",
            "0"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "csr_write_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "199-211",
          "snippet": "void csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nvoid csr_write_4;\n\nvoid csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "sf_stats_update",
            "sc"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_stats_update;\nvoid sf_stop;\nvoid sf_reset;\nvoid csr_write_4;\n\nvoid sf_stop(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tuntimeout(sf_stats_update, sc);\n\n\tcsr_write_4(sc, SF_GEN_ETH_CTL, 0);\n\tcsr_write_4(sc, SF_CQ_CONSIDX, 0);\n\tcsr_write_4(sc, SF_CQ_PRODIDX, 0);\n\tcsr_write_4(sc, SF_RXDQ_ADDR_Q1, 0);\n\tcsr_write_4(sc, SF_RXDQ_CTL_1, 0);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1, 0);\n\tcsr_write_4(sc, SF_TXCQ_CTL, 0);\n\tcsr_write_4(sc, SF_TXDQ_ADDR_HIPRIO, 0);\n\tcsr_write_4(sc, SF_TXDQ_CTL, 0);\n\tsf_reset(sc);\n\n\tsc->sf_link = 0;\n\n\tfor (i = 0; i < SF_RX_DLIST_CNT; i++) {\n\t\tif (sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf != NULL) {\n\t\t\tm_freem(sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf);\n\t\t\tsc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < SF_TX_DLIST_CNT; i++) {\n\t\tif (sc->sf_ldata->sf_tx_dlist[i].sf_mbuf != NULL) {\n\t\t\tm_freem(sc->sf_ldata->sf_tx_dlist[i].sf_mbuf);\n\t\t\tsc->sf_ldata->sf_tx_dlist[i].sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}"
  },
  {
    "function_name": "sf_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "1214-1270",
    "snippet": "void sf_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct sf_softc\t\t*sc;\n\tstruct sf_tx_bufdesc_type0 *cur_tx = NULL;\n\tstruct mbuf\t\t*m_head = NULL;\n\tint\t\t\ti, txprod;\n\n\tsc = ifp->if_softc;\n\n\tif (!sc->sf_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\ttxprod = csr_read_4(sc, SF_TXDQ_PRODIDX);\n\ti = SF_IDX_HI(txprod) >> 4;\n\n\twhile(sc->sf_ldata->sf_tx_dlist[i].sf_mbuf == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\tcur_tx = &sc->sf_ldata->sf_tx_dlist[i];\n\t\tif (sf_encap(sc, cur_tx, m_head)) {\n\t\t\tm_freem(m_head);\n\t\t\tcontinue;\n\t\t}\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->sf_mbuf);\n#endif\n\n\t\tSF_INC(i, SF_TX_DLIST_CNT);\n\t\tsc->sf_tx_cnt++;\n\t\tif (sc->sf_tx_cnt == (SF_TX_DLIST_CNT - 2))\n\t\t\tbreak;\n\t}\n\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\t/* Transmit */\n\tcsr_write_4(sc, SF_TXDQ_PRODIDX,\n\t    (txprod & ~SF_TXDQ_PRODIDX_HIPRIO) |\n\t    ((i << 20) & 0xFFFF0000));\n\n\tifp->if_timer = 5;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sf_encap",
      "void sf_start",
      "u_int32_t csr_read_4",
      "void csr_write_4"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "csr_write_4",
          "args": [
            "sc",
            "SF_TXDQ_PRODIDX",
            "(txprod & ~SF_TXDQ_PRODIDX_HIPRIO) |\n\t    ((i << 20) & 0xFFFF0000)"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "csr_write_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "199-211",
          "snippet": "void csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nvoid csr_write_4;\n\nvoid csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SF_INC",
          "args": [
            "i",
            "SF_TX_DLIST_CNT"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "cur_tx->sf_mbuf"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_head"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sf_encap",
          "args": [
            "sc",
            "cur_tx",
            "m_head"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "sf_encap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "1151-1212",
          "snippet": "int sf_encap(sc, c, m_head)\n\tstruct sf_softc\t\t*sc;\n\tstruct sf_tx_bufdesc_type0 *c;\n\tstruct mbuf\t\t*m_head;\n{\n\tint\t\t\tfrag = 0;\n\tstruct sf_frag\t\t*f = NULL;\n\tstruct mbuf\t\t*m;\n\n\tm = m_head;\n\n\tfor (m = m_head, frag = 0; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (frag == SF_MAXFRAGS)\n\t\t\t\tbreak;\n\t\t\tf = &c->sf_frags[frag];\n\t\t\tif (frag == 0)\n\t\t\t\tf->sf_pktlen = m_head->m_pkthdr.len;\n\t\t\tf->sf_fraglen = m->m_len;\n\t\t\tf->sf_addr = vtophys(mtod(m, vm_offset_t));\n\t\t\tfrag++;\n\t\t}\n\t}\n\n\tif (m != NULL) {\n\t\tstruct mbuf\t\t*m_new = NULL;\n\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"sf%d: no memory for tx list\", sc->sf_unit);\n\t\t\treturn(1);\n\t\t}\n\n\t\tif (m_head->m_pkthdr.len > MHLEN) {\n\t\t\tMCLGET(m_new, M_DONTWAIT);\n\t\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\t\tm_freem(m_new);\n\t\t\t\tprintf(\"sf%d: no memory for tx list\",\n\t\t\t\t    sc->sf_unit);\n\t\t\t\treturn(1);\n\t\t\t}\n\t\t}\n\t\tm_copydata(m_head, 0, m_head->m_pkthdr.len,\n\t\t    mtod(m_new, caddr_t));\n\t\tm_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;\n\t\tm_freem(m_head);\n\t\tm_head = m_new;\n\t\tf = &c->sf_frags[0];\n\t\tf->sf_fraglen = f->sf_pktlen = m_head->m_pkthdr.len;\n\t\tf->sf_addr = vtophys(mtod(m_head, caddr_t));\n\t\tfrag = 1;\n\t}\n\n\tc->sf_mbuf = m_head;\n\tc->sf_id = SF_TX_BUFDESC_ID;\n\tc->sf_fragcnt = frag;\n\tc->sf_intr = 1;\n\tc->sf_caltcp = 0;\n\tc->sf_crcen = 1;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int sf_intr",
            "int sf_encap"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_intr;\nint sf_encap;\n\nint sf_encap(sc, c, m_head)\n\tstruct sf_softc\t\t*sc;\n\tstruct sf_tx_bufdesc_type0 *c;\n\tstruct mbuf\t\t*m_head;\n{\n\tint\t\t\tfrag = 0;\n\tstruct sf_frag\t\t*f = NULL;\n\tstruct mbuf\t\t*m;\n\n\tm = m_head;\n\n\tfor (m = m_head, frag = 0; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (frag == SF_MAXFRAGS)\n\t\t\t\tbreak;\n\t\t\tf = &c->sf_frags[frag];\n\t\t\tif (frag == 0)\n\t\t\t\tf->sf_pktlen = m_head->m_pkthdr.len;\n\t\t\tf->sf_fraglen = m->m_len;\n\t\t\tf->sf_addr = vtophys(mtod(m, vm_offset_t));\n\t\t\tfrag++;\n\t\t}\n\t}\n\n\tif (m != NULL) {\n\t\tstruct mbuf\t\t*m_new = NULL;\n\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"sf%d: no memory for tx list\", sc->sf_unit);\n\t\t\treturn(1);\n\t\t}\n\n\t\tif (m_head->m_pkthdr.len > MHLEN) {\n\t\t\tMCLGET(m_new, M_DONTWAIT);\n\t\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\t\tm_freem(m_new);\n\t\t\t\tprintf(\"sf%d: no memory for tx list\",\n\t\t\t\t    sc->sf_unit);\n\t\t\t\treturn(1);\n\t\t\t}\n\t\t}\n\t\tm_copydata(m_head, 0, m_head->m_pkthdr.len,\n\t\t    mtod(m_new, caddr_t));\n\t\tm_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;\n\t\tm_freem(m_head);\n\t\tm_head = m_new;\n\t\tf = &c->sf_frags[0];\n\t\tf->sf_fraglen = f->sf_pktlen = m_head->m_pkthdr.len;\n\t\tf->sf_addr = vtophys(mtod(m_head, caddr_t));\n\t\tfrag = 1;\n\t}\n\n\tc->sf_mbuf = m_head;\n\tc->sf_id = SF_TX_BUFDESC_ID;\n\tc->sf_fragcnt = frag;\n\tc->sf_intr = 1;\n\tc->sf_caltcp = 0;\n\tc->sf_crcen = 1;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m_head"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_IDX_HI",
          "args": [
            "txprod"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csr_read_4",
          "args": [
            "sc",
            "SF_TXDQ_PRODIDX"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "csr_read_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "171-185",
          "snippet": "u_int32_t csr_read_4(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int32_t\t\tval;\n\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tval = CSR_READ_4(sc, SF_INDIRECTIO_DATA);\n#else\n\tval = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));\n#endif\n\n\treturn(val);\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "u_int32_t csr_read_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nu_int32_t csr_read_4;\n\nu_int32_t csr_read_4(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int32_t\t\tval;\n\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tval = CSR_READ_4(sc, SF_INDIRECTIO_DATA);\n#else\n\tval = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));\n#endif\n\n\treturn(val);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_encap;\nvoid sf_start;\nu_int32_t csr_read_4;\nvoid csr_write_4;\n\nvoid sf_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct sf_softc\t\t*sc;\n\tstruct sf_tx_bufdesc_type0 *cur_tx = NULL;\n\tstruct mbuf\t\t*m_head = NULL;\n\tint\t\t\ti, txprod;\n\n\tsc = ifp->if_softc;\n\n\tif (!sc->sf_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\ttxprod = csr_read_4(sc, SF_TXDQ_PRODIDX);\n\ti = SF_IDX_HI(txprod) >> 4;\n\n\twhile(sc->sf_ldata->sf_tx_dlist[i].sf_mbuf == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\tcur_tx = &sc->sf_ldata->sf_tx_dlist[i];\n\t\tif (sf_encap(sc, cur_tx, m_head)) {\n\t\t\tm_freem(m_head);\n\t\t\tcontinue;\n\t\t}\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->sf_mbuf);\n#endif\n\n\t\tSF_INC(i, SF_TX_DLIST_CNT);\n\t\tsc->sf_tx_cnt++;\n\t\tif (sc->sf_tx_cnt == (SF_TX_DLIST_CNT - 2))\n\t\t\tbreak;\n\t}\n\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\t/* Transmit */\n\tcsr_write_4(sc, SF_TXDQ_PRODIDX,\n\t    (txprod & ~SF_TXDQ_PRODIDX_HIPRIO) |\n\t    ((i << 20) & 0xFFFF0000));\n\n\tifp->if_timer = 5;\n\n\treturn;\n}"
  },
  {
    "function_name": "sf_encap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "1151-1212",
    "snippet": "int sf_encap(sc, c, m_head)\n\tstruct sf_softc\t\t*sc;\n\tstruct sf_tx_bufdesc_type0 *c;\n\tstruct mbuf\t\t*m_head;\n{\n\tint\t\t\tfrag = 0;\n\tstruct sf_frag\t\t*f = NULL;\n\tstruct mbuf\t\t*m;\n\n\tm = m_head;\n\n\tfor (m = m_head, frag = 0; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (frag == SF_MAXFRAGS)\n\t\t\t\tbreak;\n\t\t\tf = &c->sf_frags[frag];\n\t\t\tif (frag == 0)\n\t\t\t\tf->sf_pktlen = m_head->m_pkthdr.len;\n\t\t\tf->sf_fraglen = m->m_len;\n\t\t\tf->sf_addr = vtophys(mtod(m, vm_offset_t));\n\t\t\tfrag++;\n\t\t}\n\t}\n\n\tif (m != NULL) {\n\t\tstruct mbuf\t\t*m_new = NULL;\n\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"sf%d: no memory for tx list\", sc->sf_unit);\n\t\t\treturn(1);\n\t\t}\n\n\t\tif (m_head->m_pkthdr.len > MHLEN) {\n\t\t\tMCLGET(m_new, M_DONTWAIT);\n\t\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\t\tm_freem(m_new);\n\t\t\t\tprintf(\"sf%d: no memory for tx list\",\n\t\t\t\t    sc->sf_unit);\n\t\t\t\treturn(1);\n\t\t\t}\n\t\t}\n\t\tm_copydata(m_head, 0, m_head->m_pkthdr.len,\n\t\t    mtod(m_new, caddr_t));\n\t\tm_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;\n\t\tm_freem(m_head);\n\t\tm_head = m_new;\n\t\tf = &c->sf_frags[0];\n\t\tf->sf_fraglen = f->sf_pktlen = m_head->m_pkthdr.len;\n\t\tf->sf_addr = vtophys(mtod(m_head, caddr_t));\n\t\tfrag = 1;\n\t}\n\n\tc->sf_mbuf = m_head;\n\tc->sf_id = SF_TX_BUFDESC_ID;\n\tc->sf_fragcnt = frag;\n\tc->sf_intr = 1;\n\tc->sf_caltcp = 0;\n\tc->sf_crcen = 1;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sf_intr",
      "int sf_encap"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m_head, caddr_t)"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m_head",
            "caddr_t"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_head"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "m_head",
            "0",
            "m_head->m_pkthdr.len",
            "mtod(m_new, caddr_t)"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m_new",
            "caddr_t"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"sf%d: no memory for tx list\"",
            "sc->sf_unit"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_new"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m_new",
            "M_DONTWAIT"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m_new",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m, vm_offset_t)"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "vm_offset_t"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_intr;\nint sf_encap;\n\nint sf_encap(sc, c, m_head)\n\tstruct sf_softc\t\t*sc;\n\tstruct sf_tx_bufdesc_type0 *c;\n\tstruct mbuf\t\t*m_head;\n{\n\tint\t\t\tfrag = 0;\n\tstruct sf_frag\t\t*f = NULL;\n\tstruct mbuf\t\t*m;\n\n\tm = m_head;\n\n\tfor (m = m_head, frag = 0; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (frag == SF_MAXFRAGS)\n\t\t\t\tbreak;\n\t\t\tf = &c->sf_frags[frag];\n\t\t\tif (frag == 0)\n\t\t\t\tf->sf_pktlen = m_head->m_pkthdr.len;\n\t\t\tf->sf_fraglen = m->m_len;\n\t\t\tf->sf_addr = vtophys(mtod(m, vm_offset_t));\n\t\t\tfrag++;\n\t\t}\n\t}\n\n\tif (m != NULL) {\n\t\tstruct mbuf\t\t*m_new = NULL;\n\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"sf%d: no memory for tx list\", sc->sf_unit);\n\t\t\treturn(1);\n\t\t}\n\n\t\tif (m_head->m_pkthdr.len > MHLEN) {\n\t\t\tMCLGET(m_new, M_DONTWAIT);\n\t\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\t\tm_freem(m_new);\n\t\t\t\tprintf(\"sf%d: no memory for tx list\",\n\t\t\t\t    sc->sf_unit);\n\t\t\t\treturn(1);\n\t\t\t}\n\t\t}\n\t\tm_copydata(m_head, 0, m_head->m_pkthdr.len,\n\t\t    mtod(m_new, caddr_t));\n\t\tm_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;\n\t\tm_freem(m_head);\n\t\tm_head = m_new;\n\t\tf = &c->sf_frags[0];\n\t\tf->sf_fraglen = f->sf_pktlen = m_head->m_pkthdr.len;\n\t\tf->sf_addr = vtophys(mtod(m_head, caddr_t));\n\t\tfrag = 1;\n\t}\n\n\tc->sf_mbuf = m_head;\n\tc->sf_id = SF_TX_BUFDESC_ID;\n\tc->sf_fragcnt = frag;\n\tc->sf_intr = 1;\n\tc->sf_caltcp = 0;\n\tc->sf_crcen = 1;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "sf_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "1044-1149",
    "snippet": "void sf_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct sf_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ti, s;\n\n\ts = splimp();\n\n\tmii = &sc->sc_mii;\n\n\tsf_stop(sc);\n\tsf_reset(sc);\n\n\t/* Init all the receive filter registers */\n\tfor (i = SF_RXFILT_PERFECT_BASE;\n\t    i < (SF_RXFILT_HASH_MAX + 1); i += 4)\n\t\tcsr_write_4(sc, i, 0);\n\n\t/* Empty stats counter registers. */\n\tfor (i = 0; i < sizeof(struct sf_stats)/sizeof(u_int32_t); i++)\n\t\tcsr_write_4(sc, SF_STATS_BASE +\n\t\t    (i + sizeof(u_int32_t)), 0);\n\n\t/* Init our MAC address */\n\tcsr_write_4(sc, SF_PAR0, *(u_int32_t *)(&sc->arpcom.ac_enaddr[0]));\n\tcsr_write_4(sc, SF_PAR1, *(u_int32_t *)(&sc->arpcom.ac_enaddr[4]));\n\tsf_setperf(sc, 0, (caddr_t)&sc->arpcom.ac_enaddr);\n\n\tif (sf_init_rx_ring(sc) == ENOBUFS) {\n\t\tprintf(\"sf%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc->sf_unit);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\tsf_init_tx_ring(sc);\n\n\tcsr_write_4(sc, SF_RXFILT, SF_PERFMODE_NORMAL|SF_HASHMODE_WITHVLAN);\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);\n\t} else {\n\t\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);\n\t}\n\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_BROAD);\n\t} else {\n\t\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_BROAD);\n\t}\n\n\t/* Init the completion queue indexes */\n\tcsr_write_4(sc, SF_CQ_CONSIDX, 0);\n\tcsr_write_4(sc, SF_CQ_PRODIDX, 0);\n\n\t/* Init the RX completion queue */\n\tcsr_write_4(sc, SF_RXCQ_CTL_1,\n\t    vtophys(sc->sf_ldata->sf_rx_clist) & SF_RXCQ_ADDR);\n\tSF_SETBIT(sc, SF_RXCQ_CTL_1, SF_RXCQTYPE_3);\n\n\t/* Init RX DMA control. */\n\tSF_SETBIT(sc, SF_RXDMA_CTL, SF_RXDMA_REPORTBADPKTS);\n\n\t/* Init the RX buffer descriptor queue. */\n\tcsr_write_4(sc, SF_RXDQ_ADDR_Q1,\n\t    vtophys(sc->sf_ldata->sf_rx_dlist_big));\n\tcsr_write_4(sc, SF_RXDQ_CTL_1, (MCLBYTES << 16) | SF_DESCSPACE_16BYTES);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1, SF_RX_DLIST_CNT - 1);\n\n\t/* Init the TX completion queue */\n\tcsr_write_4(sc, SF_TXCQ_CTL,\n\t    vtophys(sc->sf_ldata->sf_tx_clist) & SF_RXCQ_ADDR);\n\n\t/* Init the TX buffer descriptor queue. */\n\tcsr_write_4(sc, SF_TXDQ_ADDR_HIPRIO,\n\t\tvtophys(sc->sf_ldata->sf_tx_dlist));\n\tSF_SETBIT(sc, SF_TX_FRAMCTL, SF_TXFRMCTL_CPLAFTERTX);\n\tcsr_write_4(sc, SF_TXDQ_CTL,\n\t    SF_TXBUFDESC_TYPE0|SF_TXMINSPACE_128BYTES|SF_TXSKIPLEN_8BYTES);\n\tSF_SETBIT(sc, SF_TXDQ_CTL, SF_TXDQCTL_NODMACMP);\n\n\t/* Enable autopadding of short TX frames. */\n\tSF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_AUTOPAD);\n\n\t/* Enable interrupts. */\n\tcsr_write_4(sc, SF_IMR, SF_INTRS);\n\tSF_SETBIT(sc, SF_PCI_DEVCFG, SF_PCIDEVCFG_INTR_ENB);\n\n\t/* Enable the RX and TX engines. */\n\tSF_SETBIT(sc, SF_GEN_ETH_CTL, SF_ETHCTL_RX_ENB|SF_ETHCTL_RXDMA_ENB);\n\tSF_SETBIT(sc, SF_GEN_ETH_CTL, SF_ETHCTL_TX_ENB|SF_ETHCTL_TXDMA_ENB);\n\n\tsf_ifmedia_upd(ifp);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\ttimeout(sf_stats_update, sc, hz);\n\n\tsplx(s);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sf_stats_update",
      "void sf_init",
      "void sf_stop",
      "int sf_ifmedia_upd",
      "void sf_reset",
      "int sf_init_rx_ring",
      "void sf_init_tx_ring",
      "int sf_setperf",
      "void csr_write_4"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "sf_stats_update",
            "sc",
            "hz"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sf_ifmedia_upd",
          "args": [
            "ifp"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "sf_ifmedia_upd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "432-450",
          "snippet": "int sf_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct sf_softc\t\t*sc;\n\tstruct mii_data\t\t*mii;\n\n\tsc = ifp->if_softc;\n\tmii = &sc->sc_mii;\n\tsc->sf_link = 0;\n\tif (mii->mii_instance) {\n\t\tstruct mii_softc\t*miisc;\n\t\tfor (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;\n\t\t    miisc = LIST_NEXT(miisc, mii_list))\n\t\t\tmii_phy_reset(miisc);\n\t}\n\tmii_mediachg(mii);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int sf_ifmedia_upd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_ifmedia_upd;\n\nint sf_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct sf_softc\t\t*sc;\n\tstruct mii_data\t\t*mii;\n\n\tsc = ifp->if_softc;\n\tmii = &sc->sc_mii;\n\tsc->sf_link = 0;\n\tif (mii->mii_instance) {\n\t\tstruct mii_softc\t*miisc;\n\t\tfor (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;\n\t\t    miisc = LIST_NEXT(miisc, mii_list))\n\t\t\tmii_phy_reset(miisc);\n\t}\n\tmii_mediachg(mii);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SF_SETBIT",
          "args": [
            "sc",
            "SF_GEN_ETH_CTL",
            "SF_ETHCTL_TX_ENB|SF_ETHCTL_TXDMA_ENB"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_SETBIT",
          "args": [
            "sc",
            "SF_GEN_ETH_CTL",
            "SF_ETHCTL_RX_ENB|SF_ETHCTL_RXDMA_ENB"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_SETBIT",
          "args": [
            "sc",
            "SF_PCI_DEVCFG",
            "SF_PCIDEVCFG_INTR_ENB"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csr_write_4",
          "args": [
            "sc",
            "SF_IMR",
            "SF_INTRS"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "csr_write_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "199-211",
          "snippet": "void csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nvoid csr_write_4;\n\nvoid csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SF_SETBIT",
          "args": [
            "sc",
            "SF_MACCFG_1",
            "SF_MACCFG1_AUTOPAD"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_SETBIT",
          "args": [
            "sc",
            "SF_TXDQ_CTL",
            "SF_TXDQCTL_NODMACMP"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_SETBIT",
          "args": [
            "sc",
            "SF_TX_FRAMCTL",
            "SF_TXFRMCTL_CPLAFTERTX"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->sf_ldata->sf_tx_dlist"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->sf_ldata->sf_tx_clist"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->sf_ldata->sf_rx_dlist_big"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_SETBIT",
          "args": [
            "sc",
            "SF_RXDMA_CTL",
            "SF_RXDMA_REPORTBADPKTS"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_SETBIT",
          "args": [
            "sc",
            "SF_RXCQ_CTL_1",
            "SF_RXCQTYPE_3"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->sf_ldata->sf_rx_clist"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_CLRBIT",
          "args": [
            "sc",
            "SF_RXFILT",
            "SF_RXFILT_BROAD"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_SETBIT",
          "args": [
            "sc",
            "SF_RXFILT",
            "SF_RXFILT_BROAD"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_CLRBIT",
          "args": [
            "sc",
            "SF_RXFILT",
            "SF_RXFILT_PROMISC"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_SETBIT",
          "args": [
            "sc",
            "SF_RXFILT",
            "SF_RXFILT_PROMISC"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sf_init_tx_ring",
          "args": [
            "sc"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "sf_init_tx_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "797-819",
          "snippet": "void sf_init_tx_ring(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tstruct sf_list_data\t*ld;\n\tint\t\t\ti;\n\n\tld = sc->sf_ldata;\n\n\tbzero((char *)ld->sf_tx_dlist,\n\t    sizeof(struct sf_tx_bufdesc_type0) * SF_TX_DLIST_CNT);\n\tbzero((char *)ld->sf_tx_clist,\n\t    sizeof(struct sf_tx_cmpdesc_type0) * SF_TX_CLIST_CNT);\n\n\tfor (i = 0; i < SF_TX_DLIST_CNT; i++)\n\t\tld->sf_tx_dlist[i].sf_id = SF_TX_BUFDESC_ID;\n\tfor (i = 0; i < SF_TX_CLIST_CNT; i++)\n\t\tld->sf_tx_clist[i].sf_type = SF_TXCMPTYPE_TX;\n\n\tld->sf_tx_dlist[SF_TX_DLIST_CNT - 1].sf_end = 1;\n\tsc->sf_tx_cnt = 0;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sf_init_tx_ring"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_init_tx_ring;\n\nvoid sf_init_tx_ring(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tstruct sf_list_data\t*ld;\n\tint\t\t\ti;\n\n\tld = sc->sf_ldata;\n\n\tbzero((char *)ld->sf_tx_dlist,\n\t    sizeof(struct sf_tx_bufdesc_type0) * SF_TX_DLIST_CNT);\n\tbzero((char *)ld->sf_tx_clist,\n\t    sizeof(struct sf_tx_cmpdesc_type0) * SF_TX_CLIST_CNT);\n\n\tfor (i = 0; i < SF_TX_DLIST_CNT; i++)\n\t\tld->sf_tx_dlist[i].sf_id = SF_TX_BUFDESC_ID;\n\tfor (i = 0; i < SF_TX_CLIST_CNT; i++)\n\t\tld->sf_tx_clist[i].sf_type = SF_TXCMPTYPE_TX;\n\n\tld->sf_tx_dlist[SF_TX_DLIST_CNT - 1].sf_end = 1;\n\tsc->sf_tx_cnt = 0;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"sf%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\"",
            "sc->sf_unit"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sf_init_rx_ring",
          "args": [
            "sc"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "sf_init_rx_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "776-795",
          "snippet": "int sf_init_rx_ring(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tstruct sf_list_data\t*ld;\n\tint\t\t\ti;\n\n\tld = sc->sf_ldata;\n\n\tbzero((char *)ld->sf_rx_dlist_big,\n\t    sizeof(struct sf_rx_bufdesc_type0) * SF_RX_DLIST_CNT);\n\tbzero((char *)ld->sf_rx_clist,\n\t    sizeof(struct sf_rx_cmpdesc_type3) * SF_RX_CLIST_CNT);\n\n\tfor (i = 0; i < SF_RX_DLIST_CNT; i++) {\n\t\tif (sf_newbuf(sc, &ld->sf_rx_dlist_big[i], NULL) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t}\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int sf_init_rx_ring",
            "int sf_newbuf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_init_rx_ring;\nint sf_newbuf;\n\nint sf_init_rx_ring(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tstruct sf_list_data\t*ld;\n\tint\t\t\ti;\n\n\tld = sc->sf_ldata;\n\n\tbzero((char *)ld->sf_rx_dlist_big,\n\t    sizeof(struct sf_rx_bufdesc_type0) * SF_RX_DLIST_CNT);\n\tbzero((char *)ld->sf_rx_clist,\n\t    sizeof(struct sf_rx_cmpdesc_type3) * SF_RX_CLIST_CNT);\n\n\tfor (i = 0; i < SF_RX_DLIST_CNT; i++) {\n\t\tif (sf_newbuf(sc, &ld->sf_rx_dlist_big[i], NULL) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t}\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sf_setperf",
          "args": [
            "sc",
            "0",
            "(caddr_t)&sc->arpcom.ac_enaddr"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "sf_setperf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "243-266",
          "snippet": "int sf_setperf(sc, idx, mac)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\tidx;\n\tcaddr_t\t\t\tmac;\n{\n\tu_int16_t\t\t*p;\n\n\tif (idx < 0 || idx > SF_RXFILT_PERFECT_CNT)\n\t\treturn(EINVAL);\n\n\tif (mac == NULL)\n\t\treturn(EINVAL);\n\n\tp = (u_int16_t *)mac;\n\n\tcsr_write_4(sc, SF_RXFILT_PERFECT_BASE +\n\t    (idx * SF_RXFILT_PERFECT_SKIP), htons(p[2]));\n\tcsr_write_4(sc, SF_RXFILT_PERFECT_BASE +\n\t    (idx * SF_RXFILT_PERFECT_SKIP) + 4, htons(p[1]));\n\tcsr_write_4(sc, SF_RXFILT_PERFECT_BASE +\n\t    (idx * SF_RXFILT_PERFECT_SKIP) + 8, htons(p[0]));\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int sf_setperf",
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_setperf;\nvoid csr_write_4;\n\nint sf_setperf(sc, idx, mac)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\tidx;\n\tcaddr_t\t\t\tmac;\n{\n\tu_int16_t\t\t*p;\n\n\tif (idx < 0 || idx > SF_RXFILT_PERFECT_CNT)\n\t\treturn(EINVAL);\n\n\tif (mac == NULL)\n\t\treturn(EINVAL);\n\n\tp = (u_int16_t *)mac;\n\n\tcsr_write_4(sc, SF_RXFILT_PERFECT_BASE +\n\t    (idx * SF_RXFILT_PERFECT_SKIP), htons(p[2]));\n\tcsr_write_4(sc, SF_RXFILT_PERFECT_BASE +\n\t    (idx * SF_RXFILT_PERFECT_SKIP) + 4, htons(p[1]));\n\tcsr_write_4(sc, SF_RXFILT_PERFECT_BASE +\n\t    (idx * SF_RXFILT_PERFECT_SKIP) + 8, htons(p[0]));\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sf_reset",
          "args": [
            "sc"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "sf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "552-576",
          "snippet": "void sf_reset(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tcsr_write_4(sc, SF_GEN_ETH_CTL, 0);\n\tSF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);\n\tDELAY(1000);\n\tSF_CLRBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);\n\n\tSF_SETBIT(sc, SF_PCI_DEVCFG, SF_PCIDEVCFG_RESET);\n\n\tfor (i = 0; i < SF_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(csr_read_4(sc, SF_PCI_DEVCFG) & SF_PCIDEVCFG_RESET))\n\t\t\tbreak;\n\t}\n\n\tif (i == SF_TIMEOUT)\n\t\tprintf(\"sf%d: reset never completed!\\n\", sc->sf_unit);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sf_reset",
            "u_int32_t csr_read_4",
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_reset;\nu_int32_t csr_read_4;\nvoid csr_write_4;\n\nvoid sf_reset(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tcsr_write_4(sc, SF_GEN_ETH_CTL, 0);\n\tSF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);\n\tDELAY(1000);\n\tSF_CLRBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);\n\n\tSF_SETBIT(sc, SF_PCI_DEVCFG, SF_PCIDEVCFG_RESET);\n\n\tfor (i = 0; i < SF_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(csr_read_4(sc, SF_PCI_DEVCFG) & SF_PCIDEVCFG_RESET))\n\t\t\tbreak;\n\t}\n\n\tif (i == SF_TIMEOUT)\n\t\tprintf(\"sf%d: reset never completed!\\n\", sc->sf_unit);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sf_stop",
          "args": [
            "sc"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "sf_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "1272-1312",
          "snippet": "void sf_stop(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tuntimeout(sf_stats_update, sc);\n\n\tcsr_write_4(sc, SF_GEN_ETH_CTL, 0);\n\tcsr_write_4(sc, SF_CQ_CONSIDX, 0);\n\tcsr_write_4(sc, SF_CQ_PRODIDX, 0);\n\tcsr_write_4(sc, SF_RXDQ_ADDR_Q1, 0);\n\tcsr_write_4(sc, SF_RXDQ_CTL_1, 0);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1, 0);\n\tcsr_write_4(sc, SF_TXCQ_CTL, 0);\n\tcsr_write_4(sc, SF_TXDQ_ADDR_HIPRIO, 0);\n\tcsr_write_4(sc, SF_TXDQ_CTL, 0);\n\tsf_reset(sc);\n\n\tsc->sf_link = 0;\n\n\tfor (i = 0; i < SF_RX_DLIST_CNT; i++) {\n\t\tif (sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf != NULL) {\n\t\t\tm_freem(sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf);\n\t\t\tsc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < SF_TX_DLIST_CNT; i++) {\n\t\tif (sc->sf_ldata->sf_tx_dlist[i].sf_mbuf != NULL) {\n\t\t\tm_freem(sc->sf_ldata->sf_tx_dlist[i].sf_mbuf);\n\t\t\tsc->sf_ldata->sf_tx_dlist[i].sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sf_stats_update",
            "void sf_stop",
            "void sf_reset",
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_stats_update;\nvoid sf_stop;\nvoid sf_reset;\nvoid csr_write_4;\n\nvoid sf_stop(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tuntimeout(sf_stats_update, sc);\n\n\tcsr_write_4(sc, SF_GEN_ETH_CTL, 0);\n\tcsr_write_4(sc, SF_CQ_CONSIDX, 0);\n\tcsr_write_4(sc, SF_CQ_PRODIDX, 0);\n\tcsr_write_4(sc, SF_RXDQ_ADDR_Q1, 0);\n\tcsr_write_4(sc, SF_RXDQ_CTL_1, 0);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1, 0);\n\tcsr_write_4(sc, SF_TXCQ_CTL, 0);\n\tcsr_write_4(sc, SF_TXDQ_ADDR_HIPRIO, 0);\n\tcsr_write_4(sc, SF_TXDQ_CTL, 0);\n\tsf_reset(sc);\n\n\tsc->sf_link = 0;\n\n\tfor (i = 0; i < SF_RX_DLIST_CNT; i++) {\n\t\tif (sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf != NULL) {\n\t\t\tm_freem(sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf);\n\t\t\tsc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < SF_TX_DLIST_CNT; i++) {\n\t\tif (sc->sf_ldata->sf_tx_dlist[i].sf_mbuf != NULL) {\n\t\t\tm_freem(sc->sf_ldata->sf_tx_dlist[i].sf_mbuf);\n\t\t\tsc->sf_ldata->sf_tx_dlist[i].sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_stats_update;\nvoid sf_init;\nvoid sf_stop;\nint sf_ifmedia_upd;\nvoid sf_reset;\nint sf_init_rx_ring;\nvoid sf_init_tx_ring;\nint sf_setperf;\nvoid csr_write_4;\n\nvoid sf_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct sf_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ti, s;\n\n\ts = splimp();\n\n\tmii = &sc->sc_mii;\n\n\tsf_stop(sc);\n\tsf_reset(sc);\n\n\t/* Init all the receive filter registers */\n\tfor (i = SF_RXFILT_PERFECT_BASE;\n\t    i < (SF_RXFILT_HASH_MAX + 1); i += 4)\n\t\tcsr_write_4(sc, i, 0);\n\n\t/* Empty stats counter registers. */\n\tfor (i = 0; i < sizeof(struct sf_stats)/sizeof(u_int32_t); i++)\n\t\tcsr_write_4(sc, SF_STATS_BASE +\n\t\t    (i + sizeof(u_int32_t)), 0);\n\n\t/* Init our MAC address */\n\tcsr_write_4(sc, SF_PAR0, *(u_int32_t *)(&sc->arpcom.ac_enaddr[0]));\n\tcsr_write_4(sc, SF_PAR1, *(u_int32_t *)(&sc->arpcom.ac_enaddr[4]));\n\tsf_setperf(sc, 0, (caddr_t)&sc->arpcom.ac_enaddr);\n\n\tif (sf_init_rx_ring(sc) == ENOBUFS) {\n\t\tprintf(\"sf%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc->sf_unit);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\tsf_init_tx_ring(sc);\n\n\tcsr_write_4(sc, SF_RXFILT, SF_PERFMODE_NORMAL|SF_HASHMODE_WITHVLAN);\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);\n\t} else {\n\t\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);\n\t}\n\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_BROAD);\n\t} else {\n\t\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_BROAD);\n\t}\n\n\t/* Init the completion queue indexes */\n\tcsr_write_4(sc, SF_CQ_CONSIDX, 0);\n\tcsr_write_4(sc, SF_CQ_PRODIDX, 0);\n\n\t/* Init the RX completion queue */\n\tcsr_write_4(sc, SF_RXCQ_CTL_1,\n\t    vtophys(sc->sf_ldata->sf_rx_clist) & SF_RXCQ_ADDR);\n\tSF_SETBIT(sc, SF_RXCQ_CTL_1, SF_RXCQTYPE_3);\n\n\t/* Init RX DMA control. */\n\tSF_SETBIT(sc, SF_RXDMA_CTL, SF_RXDMA_REPORTBADPKTS);\n\n\t/* Init the RX buffer descriptor queue. */\n\tcsr_write_4(sc, SF_RXDQ_ADDR_Q1,\n\t    vtophys(sc->sf_ldata->sf_rx_dlist_big));\n\tcsr_write_4(sc, SF_RXDQ_CTL_1, (MCLBYTES << 16) | SF_DESCSPACE_16BYTES);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1, SF_RX_DLIST_CNT - 1);\n\n\t/* Init the TX completion queue */\n\tcsr_write_4(sc, SF_TXCQ_CTL,\n\t    vtophys(sc->sf_ldata->sf_tx_clist) & SF_RXCQ_ADDR);\n\n\t/* Init the TX buffer descriptor queue. */\n\tcsr_write_4(sc, SF_TXDQ_ADDR_HIPRIO,\n\t\tvtophys(sc->sf_ldata->sf_tx_dlist));\n\tSF_SETBIT(sc, SF_TX_FRAMCTL, SF_TXFRMCTL_CPLAFTERTX);\n\tcsr_write_4(sc, SF_TXDQ_CTL,\n\t    SF_TXBUFDESC_TYPE0|SF_TXMINSPACE_128BYTES|SF_TXSKIPLEN_8BYTES);\n\tSF_SETBIT(sc, SF_TXDQ_CTL, SF_TXDQCTL_NODMACMP);\n\n\t/* Enable autopadding of short TX frames. */\n\tSF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_AUTOPAD);\n\n\t/* Enable interrupts. */\n\tcsr_write_4(sc, SF_IMR, SF_INTRS);\n\tSF_SETBIT(sc, SF_PCI_DEVCFG, SF_PCIDEVCFG_INTR_ENB);\n\n\t/* Enable the RX and TX engines. */\n\tSF_SETBIT(sc, SF_GEN_ETH_CTL, SF_ETHCTL_RX_ENB|SF_ETHCTL_RXDMA_ENB);\n\tSF_SETBIT(sc, SF_GEN_ETH_CTL, SF_ETHCTL_TX_ENB|SF_ETHCTL_TXDMA_ENB);\n\n\tsf_ifmedia_upd(ifp);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\ttimeout(sf_stats_update, sc, hz);\n\n\tsplx(s);\n\n\treturn;\n}"
  },
  {
    "function_name": "sf_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "993-1042",
    "snippet": "int sf_intr(arg)\n\tvoid\t\t\t*arg;\n{\n\tstruct sf_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\tstatus;\n\tint\t\t\tclaimed = 0;\n\n\tsc = arg;\n\tifp = &sc->arpcom.ac_if;\n\n\tif (!(csr_read_4(sc, SF_ISR_SHADOW) & SF_ISR_PCIINT_ASSERTED))\n\t\treturn claimed;\n\n\t/* Disable interrupts. */\n\tcsr_write_4(sc, SF_IMR, 0x00000000);\n\n\tfor (;;) {\n\t\tstatus = csr_read_4(sc, SF_ISR);\n\t\tif (status)\n\t\t\tcsr_write_4(sc, SF_ISR, status);\n\n\t\tif (!(status & SF_INTRS))\n\t\t\tbreak;\n\n\t\tclaimed = 1;\n\n\t\tif (status & SF_ISR_RXDQ1_DMADONE)\n\t\t\tsf_rxeof(sc);\n\n\t\tif (status & SF_ISR_TX_TXDONE)\n\t\t\tsf_txeof(sc);\n\n\t\tif (status & SF_ISR_ABNORMALINTR) {\n\t\t\tif (status & SF_ISR_STATSOFLOW) {\n\t\t\t\tuntimeout(sf_stats_update, sc);\n\t\t\t\tsf_stats_update(sc);\n\t\t\t} else\n\t\t\t\tsf_init(sc);\n\t\t}\n\t}\n\n\t/* Re-enable interrupts. */\n\tcsr_write_4(sc, SF_IMR, SF_INTRS);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\tsf_start(ifp);\n\n\treturn claimed;\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sf_intr",
      "void sf_stats_update",
      "void sf_rxeof",
      "void sf_txeof",
      "void sf_start",
      "void sf_init",
      "u_int32_t csr_read_4",
      "void csr_write_4"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sf_start",
          "args": [
            "ifp"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "sf_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "1214-1270",
          "snippet": "void sf_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct sf_softc\t\t*sc;\n\tstruct sf_tx_bufdesc_type0 *cur_tx = NULL;\n\tstruct mbuf\t\t*m_head = NULL;\n\tint\t\t\ti, txprod;\n\n\tsc = ifp->if_softc;\n\n\tif (!sc->sf_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\ttxprod = csr_read_4(sc, SF_TXDQ_PRODIDX);\n\ti = SF_IDX_HI(txprod) >> 4;\n\n\twhile(sc->sf_ldata->sf_tx_dlist[i].sf_mbuf == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\tcur_tx = &sc->sf_ldata->sf_tx_dlist[i];\n\t\tif (sf_encap(sc, cur_tx, m_head)) {\n\t\t\tm_freem(m_head);\n\t\t\tcontinue;\n\t\t}\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->sf_mbuf);\n#endif\n\n\t\tSF_INC(i, SF_TX_DLIST_CNT);\n\t\tsc->sf_tx_cnt++;\n\t\tif (sc->sf_tx_cnt == (SF_TX_DLIST_CNT - 2))\n\t\t\tbreak;\n\t}\n\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\t/* Transmit */\n\tcsr_write_4(sc, SF_TXDQ_PRODIDX,\n\t    (txprod & ~SF_TXDQ_PRODIDX_HIPRIO) |\n\t    ((i << 20) & 0xFFFF0000));\n\n\tifp->if_timer = 5;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int sf_encap",
            "void sf_start",
            "u_int32_t csr_read_4",
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_encap;\nvoid sf_start;\nu_int32_t csr_read_4;\nvoid csr_write_4;\n\nvoid sf_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct sf_softc\t\t*sc;\n\tstruct sf_tx_bufdesc_type0 *cur_tx = NULL;\n\tstruct mbuf\t\t*m_head = NULL;\n\tint\t\t\ti, txprod;\n\n\tsc = ifp->if_softc;\n\n\tif (!sc->sf_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\ttxprod = csr_read_4(sc, SF_TXDQ_PRODIDX);\n\ti = SF_IDX_HI(txprod) >> 4;\n\n\twhile(sc->sf_ldata->sf_tx_dlist[i].sf_mbuf == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\tcur_tx = &sc->sf_ldata->sf_tx_dlist[i];\n\t\tif (sf_encap(sc, cur_tx, m_head)) {\n\t\t\tm_freem(m_head);\n\t\t\tcontinue;\n\t\t}\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->sf_mbuf);\n#endif\n\n\t\tSF_INC(i, SF_TX_DLIST_CNT);\n\t\tsc->sf_tx_cnt++;\n\t\tif (sc->sf_tx_cnt == (SF_TX_DLIST_CNT - 2))\n\t\t\tbreak;\n\t}\n\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\t/* Transmit */\n\tcsr_write_4(sc, SF_TXDQ_PRODIDX,\n\t    (txprod & ~SF_TXDQ_PRODIDX_HIPRIO) |\n\t    ((i << 20) & 0xFFFF0000));\n\n\tifp->if_timer = 5;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "csr_write_4",
          "args": [
            "sc",
            "SF_IMR",
            "SF_INTRS"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "csr_write_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "199-211",
          "snippet": "void csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nvoid csr_write_4;\n\nvoid csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sf_init",
          "args": [
            "sc"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "sf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "1044-1149",
          "snippet": "void sf_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct sf_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ti, s;\n\n\ts = splimp();\n\n\tmii = &sc->sc_mii;\n\n\tsf_stop(sc);\n\tsf_reset(sc);\n\n\t/* Init all the receive filter registers */\n\tfor (i = SF_RXFILT_PERFECT_BASE;\n\t    i < (SF_RXFILT_HASH_MAX + 1); i += 4)\n\t\tcsr_write_4(sc, i, 0);\n\n\t/* Empty stats counter registers. */\n\tfor (i = 0; i < sizeof(struct sf_stats)/sizeof(u_int32_t); i++)\n\t\tcsr_write_4(sc, SF_STATS_BASE +\n\t\t    (i + sizeof(u_int32_t)), 0);\n\n\t/* Init our MAC address */\n\tcsr_write_4(sc, SF_PAR0, *(u_int32_t *)(&sc->arpcom.ac_enaddr[0]));\n\tcsr_write_4(sc, SF_PAR1, *(u_int32_t *)(&sc->arpcom.ac_enaddr[4]));\n\tsf_setperf(sc, 0, (caddr_t)&sc->arpcom.ac_enaddr);\n\n\tif (sf_init_rx_ring(sc) == ENOBUFS) {\n\t\tprintf(\"sf%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc->sf_unit);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\tsf_init_tx_ring(sc);\n\n\tcsr_write_4(sc, SF_RXFILT, SF_PERFMODE_NORMAL|SF_HASHMODE_WITHVLAN);\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);\n\t} else {\n\t\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);\n\t}\n\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_BROAD);\n\t} else {\n\t\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_BROAD);\n\t}\n\n\t/* Init the completion queue indexes */\n\tcsr_write_4(sc, SF_CQ_CONSIDX, 0);\n\tcsr_write_4(sc, SF_CQ_PRODIDX, 0);\n\n\t/* Init the RX completion queue */\n\tcsr_write_4(sc, SF_RXCQ_CTL_1,\n\t    vtophys(sc->sf_ldata->sf_rx_clist) & SF_RXCQ_ADDR);\n\tSF_SETBIT(sc, SF_RXCQ_CTL_1, SF_RXCQTYPE_3);\n\n\t/* Init RX DMA control. */\n\tSF_SETBIT(sc, SF_RXDMA_CTL, SF_RXDMA_REPORTBADPKTS);\n\n\t/* Init the RX buffer descriptor queue. */\n\tcsr_write_4(sc, SF_RXDQ_ADDR_Q1,\n\t    vtophys(sc->sf_ldata->sf_rx_dlist_big));\n\tcsr_write_4(sc, SF_RXDQ_CTL_1, (MCLBYTES << 16) | SF_DESCSPACE_16BYTES);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1, SF_RX_DLIST_CNT - 1);\n\n\t/* Init the TX completion queue */\n\tcsr_write_4(sc, SF_TXCQ_CTL,\n\t    vtophys(sc->sf_ldata->sf_tx_clist) & SF_RXCQ_ADDR);\n\n\t/* Init the TX buffer descriptor queue. */\n\tcsr_write_4(sc, SF_TXDQ_ADDR_HIPRIO,\n\t\tvtophys(sc->sf_ldata->sf_tx_dlist));\n\tSF_SETBIT(sc, SF_TX_FRAMCTL, SF_TXFRMCTL_CPLAFTERTX);\n\tcsr_write_4(sc, SF_TXDQ_CTL,\n\t    SF_TXBUFDESC_TYPE0|SF_TXMINSPACE_128BYTES|SF_TXSKIPLEN_8BYTES);\n\tSF_SETBIT(sc, SF_TXDQ_CTL, SF_TXDQCTL_NODMACMP);\n\n\t/* Enable autopadding of short TX frames. */\n\tSF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_AUTOPAD);\n\n\t/* Enable interrupts. */\n\tcsr_write_4(sc, SF_IMR, SF_INTRS);\n\tSF_SETBIT(sc, SF_PCI_DEVCFG, SF_PCIDEVCFG_INTR_ENB);\n\n\t/* Enable the RX and TX engines. */\n\tSF_SETBIT(sc, SF_GEN_ETH_CTL, SF_ETHCTL_RX_ENB|SF_ETHCTL_RXDMA_ENB);\n\tSF_SETBIT(sc, SF_GEN_ETH_CTL, SF_ETHCTL_TX_ENB|SF_ETHCTL_TXDMA_ENB);\n\n\tsf_ifmedia_upd(ifp);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\ttimeout(sf_stats_update, sc, hz);\n\n\tsplx(s);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sf_stats_update",
            "void sf_init",
            "void sf_stop",
            "int sf_ifmedia_upd",
            "void sf_reset",
            "int sf_init_rx_ring",
            "void sf_init_tx_ring",
            "int sf_setperf",
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_stats_update;\nvoid sf_init;\nvoid sf_stop;\nint sf_ifmedia_upd;\nvoid sf_reset;\nint sf_init_rx_ring;\nvoid sf_init_tx_ring;\nint sf_setperf;\nvoid csr_write_4;\n\nvoid sf_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct sf_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ti, s;\n\n\ts = splimp();\n\n\tmii = &sc->sc_mii;\n\n\tsf_stop(sc);\n\tsf_reset(sc);\n\n\t/* Init all the receive filter registers */\n\tfor (i = SF_RXFILT_PERFECT_BASE;\n\t    i < (SF_RXFILT_HASH_MAX + 1); i += 4)\n\t\tcsr_write_4(sc, i, 0);\n\n\t/* Empty stats counter registers. */\n\tfor (i = 0; i < sizeof(struct sf_stats)/sizeof(u_int32_t); i++)\n\t\tcsr_write_4(sc, SF_STATS_BASE +\n\t\t    (i + sizeof(u_int32_t)), 0);\n\n\t/* Init our MAC address */\n\tcsr_write_4(sc, SF_PAR0, *(u_int32_t *)(&sc->arpcom.ac_enaddr[0]));\n\tcsr_write_4(sc, SF_PAR1, *(u_int32_t *)(&sc->arpcom.ac_enaddr[4]));\n\tsf_setperf(sc, 0, (caddr_t)&sc->arpcom.ac_enaddr);\n\n\tif (sf_init_rx_ring(sc) == ENOBUFS) {\n\t\tprintf(\"sf%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc->sf_unit);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\tsf_init_tx_ring(sc);\n\n\tcsr_write_4(sc, SF_RXFILT, SF_PERFMODE_NORMAL|SF_HASHMODE_WITHVLAN);\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);\n\t} else {\n\t\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);\n\t}\n\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_BROAD);\n\t} else {\n\t\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_BROAD);\n\t}\n\n\t/* Init the completion queue indexes */\n\tcsr_write_4(sc, SF_CQ_CONSIDX, 0);\n\tcsr_write_4(sc, SF_CQ_PRODIDX, 0);\n\n\t/* Init the RX completion queue */\n\tcsr_write_4(sc, SF_RXCQ_CTL_1,\n\t    vtophys(sc->sf_ldata->sf_rx_clist) & SF_RXCQ_ADDR);\n\tSF_SETBIT(sc, SF_RXCQ_CTL_1, SF_RXCQTYPE_3);\n\n\t/* Init RX DMA control. */\n\tSF_SETBIT(sc, SF_RXDMA_CTL, SF_RXDMA_REPORTBADPKTS);\n\n\t/* Init the RX buffer descriptor queue. */\n\tcsr_write_4(sc, SF_RXDQ_ADDR_Q1,\n\t    vtophys(sc->sf_ldata->sf_rx_dlist_big));\n\tcsr_write_4(sc, SF_RXDQ_CTL_1, (MCLBYTES << 16) | SF_DESCSPACE_16BYTES);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1, SF_RX_DLIST_CNT - 1);\n\n\t/* Init the TX completion queue */\n\tcsr_write_4(sc, SF_TXCQ_CTL,\n\t    vtophys(sc->sf_ldata->sf_tx_clist) & SF_RXCQ_ADDR);\n\n\t/* Init the TX buffer descriptor queue. */\n\tcsr_write_4(sc, SF_TXDQ_ADDR_HIPRIO,\n\t\tvtophys(sc->sf_ldata->sf_tx_dlist));\n\tSF_SETBIT(sc, SF_TX_FRAMCTL, SF_TXFRMCTL_CPLAFTERTX);\n\tcsr_write_4(sc, SF_TXDQ_CTL,\n\t    SF_TXBUFDESC_TYPE0|SF_TXMINSPACE_128BYTES|SF_TXSKIPLEN_8BYTES);\n\tSF_SETBIT(sc, SF_TXDQ_CTL, SF_TXDQCTL_NODMACMP);\n\n\t/* Enable autopadding of short TX frames. */\n\tSF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_AUTOPAD);\n\n\t/* Enable interrupts. */\n\tcsr_write_4(sc, SF_IMR, SF_INTRS);\n\tSF_SETBIT(sc, SF_PCI_DEVCFG, SF_PCIDEVCFG_INTR_ENB);\n\n\t/* Enable the RX and TX engines. */\n\tSF_SETBIT(sc, SF_GEN_ETH_CTL, SF_ETHCTL_RX_ENB|SF_ETHCTL_RXDMA_ENB);\n\tSF_SETBIT(sc, SF_GEN_ETH_CTL, SF_ETHCTL_TX_ENB|SF_ETHCTL_TXDMA_ENB);\n\n\tsf_ifmedia_upd(ifp);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\ttimeout(sf_stats_update, sc, hz);\n\n\tsplx(s);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sf_stats_update",
          "args": [
            "sc"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "sf_stats_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "1321-1364",
          "snippet": "void sf_stats_update(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct sf_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tstruct mii_data\t\t*mii;\n\tstruct sf_stats\t\tstats;\n\tu_int32_t\t\t*ptr;\n\tint\t\t\ti, s;\n\n\ts = splimp();\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\tmii = &sc->sc_mii;\n\n\tptr = (u_int32_t *)&stats;\n\tfor (i = 0; i < sizeof(stats)/sizeof(u_int32_t); i++)\n\t\tptr[i] = csr_read_4(sc, SF_STATS_BASE +\n\t\t    (i + sizeof(u_int32_t)));\n\n\tfor (i = 0; i < sizeof(stats)/sizeof(u_int32_t); i++)\n\t\tcsr_write_4(sc, SF_STATS_BASE +\n\t\t    (i + sizeof(u_int32_t)), 0);\n\n\tifp->if_collisions += stats.sf_tx_single_colls +\n\t    stats.sf_tx_multi_colls + stats.sf_tx_excess_colls;\n\n\tmii_tick(mii);\n\tif (!sc->sf_link) {\n\t\tmii_pollstat(mii);\n\t\tif (mii->mii_media_status & IFM_ACTIVE &&\n\t\t    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE)\n\t\t\tsc->sf_link++;\n\t\tif (ifp->if_snd.ifq_head != NULL)\n\t\t\tsf_start(ifp);\n\t}\n\n\ttimeout(sf_stats_update, sc, hz);\n\n\tsplx(s);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sf_stats_update",
            "void sf_start",
            "u_int32_t csr_read_4",
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_stats_update;\nvoid sf_start;\nu_int32_t csr_read_4;\nvoid csr_write_4;\n\nvoid sf_stats_update(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct sf_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tstruct mii_data\t\t*mii;\n\tstruct sf_stats\t\tstats;\n\tu_int32_t\t\t*ptr;\n\tint\t\t\ti, s;\n\n\ts = splimp();\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\tmii = &sc->sc_mii;\n\n\tptr = (u_int32_t *)&stats;\n\tfor (i = 0; i < sizeof(stats)/sizeof(u_int32_t); i++)\n\t\tptr[i] = csr_read_4(sc, SF_STATS_BASE +\n\t\t    (i + sizeof(u_int32_t)));\n\n\tfor (i = 0; i < sizeof(stats)/sizeof(u_int32_t); i++)\n\t\tcsr_write_4(sc, SF_STATS_BASE +\n\t\t    (i + sizeof(u_int32_t)), 0);\n\n\tifp->if_collisions += stats.sf_tx_single_colls +\n\t    stats.sf_tx_multi_colls + stats.sf_tx_excess_colls;\n\n\tmii_tick(mii);\n\tif (!sc->sf_link) {\n\t\tmii_pollstat(mii);\n\t\tif (mii->mii_media_status & IFM_ACTIVE &&\n\t\t    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE)\n\t\t\tsc->sf_link++;\n\t\tif (ifp->if_snd.ifq_head != NULL)\n\t\t\tsf_start(ifp);\n\t}\n\n\ttimeout(sf_stats_update, sc, hz);\n\n\tsplx(s);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "sf_stats_update",
            "sc"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sf_txeof",
          "args": [
            "sc"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "sf_txeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "952-991",
          "snippet": "void sf_txeof(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tint\t\t\ttxcons, cmpprodidx, cmpconsidx;\n\tstruct sf_tx_cmpdesc_type1 *cur_cmp;\n\tstruct sf_tx_bufdesc_type0 *cur_tx;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\ttxcons = csr_read_4(sc, SF_CQ_CONSIDX);\n\tcmpprodidx = SF_IDX_HI(csr_read_4(sc, SF_CQ_PRODIDX));\n\tcmpconsidx = SF_IDX_HI(txcons);\n\n\twhile (cmpconsidx != cmpprodidx) {\n\t\tcur_cmp = &sc->sf_ldata->sf_tx_clist[cmpconsidx];\n\t\tcur_tx = &sc->sf_ldata->sf_tx_dlist[cur_cmp->sf_index >> 7];\n\t\tSF_INC(cmpconsidx, SF_TX_CLIST_CNT);\n\n\t\tif (cur_cmp->sf_txstat & SF_TXSTAT_TX_OK)\n\t\t\tifp->if_opackets++;\n\t\telse\n\t\t\tifp->if_oerrors++;\n\n\t\tsc->sf_tx_cnt--;\n\t\tif (cur_tx->sf_mbuf != NULL) {\n\t\t\tm_freem(cur_tx->sf_mbuf);\n\t\t\tcur_tx->sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tcsr_write_4(sc, SF_CQ_CONSIDX,\n\t    (txcons & ~SF_CQ_CONSIDX_TXQ) |\n\t    ((cmpconsidx << 16) & 0xFFFF0000));\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sf_txeof",
            "u_int32_t csr_read_4",
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_txeof;\nu_int32_t csr_read_4;\nvoid csr_write_4;\n\nvoid sf_txeof(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tint\t\t\ttxcons, cmpprodidx, cmpconsidx;\n\tstruct sf_tx_cmpdesc_type1 *cur_cmp;\n\tstruct sf_tx_bufdesc_type0 *cur_tx;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\ttxcons = csr_read_4(sc, SF_CQ_CONSIDX);\n\tcmpprodidx = SF_IDX_HI(csr_read_4(sc, SF_CQ_PRODIDX));\n\tcmpconsidx = SF_IDX_HI(txcons);\n\n\twhile (cmpconsidx != cmpprodidx) {\n\t\tcur_cmp = &sc->sf_ldata->sf_tx_clist[cmpconsidx];\n\t\tcur_tx = &sc->sf_ldata->sf_tx_dlist[cur_cmp->sf_index >> 7];\n\t\tSF_INC(cmpconsidx, SF_TX_CLIST_CNT);\n\n\t\tif (cur_cmp->sf_txstat & SF_TXSTAT_TX_OK)\n\t\t\tifp->if_opackets++;\n\t\telse\n\t\t\tifp->if_oerrors++;\n\n\t\tsc->sf_tx_cnt--;\n\t\tif (cur_tx->sf_mbuf != NULL) {\n\t\t\tm_freem(cur_tx->sf_mbuf);\n\t\t\tcur_tx->sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tcsr_write_4(sc, SF_CQ_CONSIDX,\n\t    (txcons & ~SF_CQ_CONSIDX_TXQ) |\n\t    ((cmpconsidx << 16) & 0xFFFF0000));\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sf_rxeof",
          "args": [
            "sc"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "sf_rxeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "878-942",
          "snippet": "void sf_rxeof(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tstruct ether_header\t*eh;\n\tstruct mbuf\t\t*m;\n\tstruct ifnet\t\t*ifp;\n\tstruct sf_rx_bufdesc_type0\t*desc;\n\tstruct sf_rx_cmpdesc_type3\t*cur_rx;\n\tu_int32_t\t\trxcons, rxprod;\n\tint\t\t\tcmpprodidx, cmpconsidx, bufprodidx;\n\n\tifp = &sc->arpcom.ac_if;\n\n\trxcons = csr_read_4(sc, SF_CQ_CONSIDX);\n\trxprod = csr_read_4(sc, SF_RXDQ_PTR_Q1);\n\tcmpprodidx = SF_IDX_LO(csr_read_4(sc, SF_CQ_PRODIDX));\n\tcmpconsidx = SF_IDX_LO(rxcons);\n\tbufprodidx = SF_IDX_LO(rxprod);\n\n\twhile (cmpconsidx != cmpprodidx) {\n\t\tstruct mbuf\t\t*m0;\n\n\t\tcur_rx = &sc->sf_ldata->sf_rx_clist[cmpconsidx];\n\t\tdesc = &sc->sf_ldata->sf_rx_dlist_big[cur_rx->sf_endidx];\n\t\tm = desc->sf_mbuf;\n\t\tSF_INC(cmpconsidx, SF_RX_CLIST_CNT);\n\t\tSF_INC(bufprodidx, SF_RX_DLIST_CNT);\n\n\t\tif (!(cur_rx->sf_status1 & SF_RXSTAT1_OK)) {\n\t\t\tifp->if_ierrors++;\n\t\t\tsf_newbuf(sc, desc, m);\n\t\t\tcontinue;\n\t\t}\n\n\t\tm0 = m_devget(mtod(m, char *) - ETHER_ALIGN,\n\t\t    cur_rx->sf_len + ETHER_ALIGN, 0, ifp, NULL);\n\t\tsf_newbuf(sc, desc, m);\n\t\tif (m0 == NULL) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcontinue;\n\t\t}\n\t\tm_adj(m0, ETHER_ALIGN);\n\t\tm = m0;\n\n\t\teh = mtod(m, struct ether_header *);\n\t\tifp->if_ipackets++;\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\n\t}\n\n\tcsr_write_4(sc, SF_CQ_CONSIDX,\n\t    (rxcons & ~SF_CQ_CONSIDX_RXQ1) | cmpconsidx);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1,\n\t    (rxprod & ~SF_RXDQ_PRODIDX) | bufprodidx);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sf_rxeof",
            "int sf_newbuf",
            "u_int32_t csr_read_4",
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_rxeof;\nint sf_newbuf;\nu_int32_t csr_read_4;\nvoid csr_write_4;\n\nvoid sf_rxeof(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tstruct ether_header\t*eh;\n\tstruct mbuf\t\t*m;\n\tstruct ifnet\t\t*ifp;\n\tstruct sf_rx_bufdesc_type0\t*desc;\n\tstruct sf_rx_cmpdesc_type3\t*cur_rx;\n\tu_int32_t\t\trxcons, rxprod;\n\tint\t\t\tcmpprodidx, cmpconsidx, bufprodidx;\n\n\tifp = &sc->arpcom.ac_if;\n\n\trxcons = csr_read_4(sc, SF_CQ_CONSIDX);\n\trxprod = csr_read_4(sc, SF_RXDQ_PTR_Q1);\n\tcmpprodidx = SF_IDX_LO(csr_read_4(sc, SF_CQ_PRODIDX));\n\tcmpconsidx = SF_IDX_LO(rxcons);\n\tbufprodidx = SF_IDX_LO(rxprod);\n\n\twhile (cmpconsidx != cmpprodidx) {\n\t\tstruct mbuf\t\t*m0;\n\n\t\tcur_rx = &sc->sf_ldata->sf_rx_clist[cmpconsidx];\n\t\tdesc = &sc->sf_ldata->sf_rx_dlist_big[cur_rx->sf_endidx];\n\t\tm = desc->sf_mbuf;\n\t\tSF_INC(cmpconsidx, SF_RX_CLIST_CNT);\n\t\tSF_INC(bufprodidx, SF_RX_DLIST_CNT);\n\n\t\tif (!(cur_rx->sf_status1 & SF_RXSTAT1_OK)) {\n\t\t\tifp->if_ierrors++;\n\t\t\tsf_newbuf(sc, desc, m);\n\t\t\tcontinue;\n\t\t}\n\n\t\tm0 = m_devget(mtod(m, char *) - ETHER_ALIGN,\n\t\t    cur_rx->sf_len + ETHER_ALIGN, 0, ifp, NULL);\n\t\tsf_newbuf(sc, desc, m);\n\t\tif (m0 == NULL) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcontinue;\n\t\t}\n\t\tm_adj(m0, ETHER_ALIGN);\n\t\tm = m0;\n\n\t\teh = mtod(m, struct ether_header *);\n\t\tifp->if_ipackets++;\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\n\t}\n\n\tcsr_write_4(sc, SF_CQ_CONSIDX,\n\t    (rxcons & ~SF_CQ_CONSIDX_RXQ1) | cmpconsidx);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1,\n\t    (rxprod & ~SF_RXDQ_PRODIDX) | bufprodidx);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "csr_read_4",
          "args": [
            "sc",
            "SF_ISR"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "csr_read_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "171-185",
          "snippet": "u_int32_t csr_read_4(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int32_t\t\tval;\n\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tval = CSR_READ_4(sc, SF_INDIRECTIO_DATA);\n#else\n\tval = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));\n#endif\n\n\treturn(val);\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "u_int32_t csr_read_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nu_int32_t csr_read_4;\n\nu_int32_t csr_read_4(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int32_t\t\tval;\n\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tval = CSR_READ_4(sc, SF_INDIRECTIO_DATA);\n#else\n\tval = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));\n#endif\n\n\treturn(val);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_intr;\nvoid sf_stats_update;\nvoid sf_rxeof;\nvoid sf_txeof;\nvoid sf_start;\nvoid sf_init;\nu_int32_t csr_read_4;\nvoid csr_write_4;\n\nint sf_intr(arg)\n\tvoid\t\t\t*arg;\n{\n\tstruct sf_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\tstatus;\n\tint\t\t\tclaimed = 0;\n\n\tsc = arg;\n\tifp = &sc->arpcom.ac_if;\n\n\tif (!(csr_read_4(sc, SF_ISR_SHADOW) & SF_ISR_PCIINT_ASSERTED))\n\t\treturn claimed;\n\n\t/* Disable interrupts. */\n\tcsr_write_4(sc, SF_IMR, 0x00000000);\n\n\tfor (;;) {\n\t\tstatus = csr_read_4(sc, SF_ISR);\n\t\tif (status)\n\t\t\tcsr_write_4(sc, SF_ISR, status);\n\n\t\tif (!(status & SF_INTRS))\n\t\t\tbreak;\n\n\t\tclaimed = 1;\n\n\t\tif (status & SF_ISR_RXDQ1_DMADONE)\n\t\t\tsf_rxeof(sc);\n\n\t\tif (status & SF_ISR_TX_TXDONE)\n\t\t\tsf_txeof(sc);\n\n\t\tif (status & SF_ISR_ABNORMALINTR) {\n\t\t\tif (status & SF_ISR_STATSOFLOW) {\n\t\t\t\tuntimeout(sf_stats_update, sc);\n\t\t\t\tsf_stats_update(sc);\n\t\t\t} else\n\t\t\t\tsf_init(sc);\n\t\t}\n\t}\n\n\t/* Re-enable interrupts. */\n\tcsr_write_4(sc, SF_IMR, SF_INTRS);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\tsf_start(ifp);\n\n\treturn claimed;\n}"
  },
  {
    "function_name": "sf_txeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "952-991",
    "snippet": "void sf_txeof(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tint\t\t\ttxcons, cmpprodidx, cmpconsidx;\n\tstruct sf_tx_cmpdesc_type1 *cur_cmp;\n\tstruct sf_tx_bufdesc_type0 *cur_tx;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\ttxcons = csr_read_4(sc, SF_CQ_CONSIDX);\n\tcmpprodidx = SF_IDX_HI(csr_read_4(sc, SF_CQ_PRODIDX));\n\tcmpconsidx = SF_IDX_HI(txcons);\n\n\twhile (cmpconsidx != cmpprodidx) {\n\t\tcur_cmp = &sc->sf_ldata->sf_tx_clist[cmpconsidx];\n\t\tcur_tx = &sc->sf_ldata->sf_tx_dlist[cur_cmp->sf_index >> 7];\n\t\tSF_INC(cmpconsidx, SF_TX_CLIST_CNT);\n\n\t\tif (cur_cmp->sf_txstat & SF_TXSTAT_TX_OK)\n\t\t\tifp->if_opackets++;\n\t\telse\n\t\t\tifp->if_oerrors++;\n\n\t\tsc->sf_tx_cnt--;\n\t\tif (cur_tx->sf_mbuf != NULL) {\n\t\t\tm_freem(cur_tx->sf_mbuf);\n\t\t\tcur_tx->sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tcsr_write_4(sc, SF_CQ_CONSIDX,\n\t    (txcons & ~SF_CQ_CONSIDX_TXQ) |\n\t    ((cmpconsidx << 16) & 0xFFFF0000));\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sf_txeof",
      "u_int32_t csr_read_4",
      "void csr_write_4"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "csr_write_4",
          "args": [
            "sc",
            "SF_CQ_CONSIDX",
            "(txcons & ~SF_CQ_CONSIDX_TXQ) |\n\t    ((cmpconsidx << 16) & 0xFFFF0000)"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "csr_write_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "199-211",
          "snippet": "void csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nvoid csr_write_4;\n\nvoid csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "cur_tx->sf_mbuf"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_INC",
          "args": [
            "cmpconsidx",
            "SF_TX_CLIST_CNT"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_IDX_HI",
          "args": [
            "txcons"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_IDX_HI",
          "args": [
            "csr_read_4(sc, SF_CQ_PRODIDX)"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csr_read_4",
          "args": [
            "sc",
            "SF_CQ_PRODIDX"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "csr_read_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "171-185",
          "snippet": "u_int32_t csr_read_4(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int32_t\t\tval;\n\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tval = CSR_READ_4(sc, SF_INDIRECTIO_DATA);\n#else\n\tval = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));\n#endif\n\n\treturn(val);\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "u_int32_t csr_read_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nu_int32_t csr_read_4;\n\nu_int32_t csr_read_4(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int32_t\t\tval;\n\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tval = CSR_READ_4(sc, SF_INDIRECTIO_DATA);\n#else\n\tval = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));\n#endif\n\n\treturn(val);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_txeof;\nu_int32_t csr_read_4;\nvoid csr_write_4;\n\nvoid sf_txeof(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tint\t\t\ttxcons, cmpprodidx, cmpconsidx;\n\tstruct sf_tx_cmpdesc_type1 *cur_cmp;\n\tstruct sf_tx_bufdesc_type0 *cur_tx;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\ttxcons = csr_read_4(sc, SF_CQ_CONSIDX);\n\tcmpprodidx = SF_IDX_HI(csr_read_4(sc, SF_CQ_PRODIDX));\n\tcmpconsidx = SF_IDX_HI(txcons);\n\n\twhile (cmpconsidx != cmpprodidx) {\n\t\tcur_cmp = &sc->sf_ldata->sf_tx_clist[cmpconsidx];\n\t\tcur_tx = &sc->sf_ldata->sf_tx_dlist[cur_cmp->sf_index >> 7];\n\t\tSF_INC(cmpconsidx, SF_TX_CLIST_CNT);\n\n\t\tif (cur_cmp->sf_txstat & SF_TXSTAT_TX_OK)\n\t\t\tifp->if_opackets++;\n\t\telse\n\t\t\tifp->if_oerrors++;\n\n\t\tsc->sf_tx_cnt--;\n\t\tif (cur_tx->sf_mbuf != NULL) {\n\t\t\tm_freem(cur_tx->sf_mbuf);\n\t\t\tcur_tx->sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tcsr_write_4(sc, SF_CQ_CONSIDX,\n\t    (txcons & ~SF_CQ_CONSIDX_TXQ) |\n\t    ((cmpconsidx << 16) & 0xFFFF0000));\n\n\treturn;\n}"
  },
  {
    "function_name": "sf_rxeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "878-942",
    "snippet": "void sf_rxeof(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tstruct ether_header\t*eh;\n\tstruct mbuf\t\t*m;\n\tstruct ifnet\t\t*ifp;\n\tstruct sf_rx_bufdesc_type0\t*desc;\n\tstruct sf_rx_cmpdesc_type3\t*cur_rx;\n\tu_int32_t\t\trxcons, rxprod;\n\tint\t\t\tcmpprodidx, cmpconsidx, bufprodidx;\n\n\tifp = &sc->arpcom.ac_if;\n\n\trxcons = csr_read_4(sc, SF_CQ_CONSIDX);\n\trxprod = csr_read_4(sc, SF_RXDQ_PTR_Q1);\n\tcmpprodidx = SF_IDX_LO(csr_read_4(sc, SF_CQ_PRODIDX));\n\tcmpconsidx = SF_IDX_LO(rxcons);\n\tbufprodidx = SF_IDX_LO(rxprod);\n\n\twhile (cmpconsidx != cmpprodidx) {\n\t\tstruct mbuf\t\t*m0;\n\n\t\tcur_rx = &sc->sf_ldata->sf_rx_clist[cmpconsidx];\n\t\tdesc = &sc->sf_ldata->sf_rx_dlist_big[cur_rx->sf_endidx];\n\t\tm = desc->sf_mbuf;\n\t\tSF_INC(cmpconsidx, SF_RX_CLIST_CNT);\n\t\tSF_INC(bufprodidx, SF_RX_DLIST_CNT);\n\n\t\tif (!(cur_rx->sf_status1 & SF_RXSTAT1_OK)) {\n\t\t\tifp->if_ierrors++;\n\t\t\tsf_newbuf(sc, desc, m);\n\t\t\tcontinue;\n\t\t}\n\n\t\tm0 = m_devget(mtod(m, char *) - ETHER_ALIGN,\n\t\t    cur_rx->sf_len + ETHER_ALIGN, 0, ifp, NULL);\n\t\tsf_newbuf(sc, desc, m);\n\t\tif (m0 == NULL) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcontinue;\n\t\t}\n\t\tm_adj(m0, ETHER_ALIGN);\n\t\tm = m0;\n\n\t\teh = mtod(m, struct ether_header *);\n\t\tifp->if_ipackets++;\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\n\t}\n\n\tcsr_write_4(sc, SF_CQ_CONSIDX,\n\t    (rxcons & ~SF_CQ_CONSIDX_RXQ1) | cmpconsidx);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1,\n\t    (rxprod & ~SF_RXDQ_PRODIDX) | bufprodidx);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sf_rxeof",
      "int sf_newbuf",
      "u_int32_t csr_read_4",
      "void csr_write_4"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "csr_write_4",
          "args": [
            "sc",
            "SF_RXDQ_PTR_Q1",
            "(rxprod & ~SF_RXDQ_PRODIDX) | bufprodidx"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "csr_write_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "199-211",
          "snippet": "void csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nvoid csr_write_4;\n\nvoid csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "sizeof(struct ether_header)"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m0",
            "ETHER_ALIGN"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sf_newbuf",
          "args": [
            "sc",
            "desc",
            "m"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "sf_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "821-857",
          "snippet": "int sf_newbuf(sc, c, m)\n\tstruct sf_softc\t\t*sc;\n\tstruct sf_rx_bufdesc_type0\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"sf%d: no memory for rx list -- \"\n\t\t\t    \"packet dropped!\\n\", sc->sf_unit);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"sf%d: no memory for rx list -- \"\n\t\t\t    \"packet dropped!\\n\", sc->sf_unit);\n\t\t\tm_freem(m_new);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, sizeof(u_int64_t));\n\n\tc->sf_mbuf = m_new;\n\tc->sf_addrlo = SF_RX_HOSTADDR(vtophys(mtod(m_new, caddr_t)));\n\tc->sf_valid = 1;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int sf_newbuf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_newbuf;\n\nint sf_newbuf(sc, c, m)\n\tstruct sf_softc\t\t*sc;\n\tstruct sf_rx_bufdesc_type0\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"sf%d: no memory for rx list -- \"\n\t\t\t    \"packet dropped!\\n\", sc->sf_unit);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"sf%d: no memory for rx list -- \"\n\t\t\t    \"packet dropped!\\n\", sc->sf_unit);\n\t\t\tm_freem(m_new);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, sizeof(u_int64_t));\n\n\tc->sf_mbuf = m_new;\n\tc->sf_addrlo = SF_RX_HOSTADDR(vtophys(mtod(m_new, caddr_t)));\n\tc->sf_valid = 1;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_devget",
          "args": [
            "mtod(m, char *) - ETHER_ALIGN",
            "cur_rx->sf_len + ETHER_ALIGN",
            "0",
            "ifp",
            "NULL"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "char*"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_INC",
          "args": [
            "bufprodidx",
            "SF_RX_DLIST_CNT"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_INC",
          "args": [
            "cmpconsidx",
            "SF_RX_CLIST_CNT"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_IDX_LO",
          "args": [
            "rxprod"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_IDX_LO",
          "args": [
            "rxcons"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_IDX_LO",
          "args": [
            "csr_read_4(sc, SF_CQ_PRODIDX)"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csr_read_4",
          "args": [
            "sc",
            "SF_CQ_PRODIDX"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "csr_read_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "171-185",
          "snippet": "u_int32_t csr_read_4(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int32_t\t\tval;\n\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tval = CSR_READ_4(sc, SF_INDIRECTIO_DATA);\n#else\n\tval = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));\n#endif\n\n\treturn(val);\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "u_int32_t csr_read_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nu_int32_t csr_read_4;\n\nu_int32_t csr_read_4(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int32_t\t\tval;\n\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tval = CSR_READ_4(sc, SF_INDIRECTIO_DATA);\n#else\n\tval = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));\n#endif\n\n\treturn(val);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_rxeof;\nint sf_newbuf;\nu_int32_t csr_read_4;\nvoid csr_write_4;\n\nvoid sf_rxeof(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tstruct ether_header\t*eh;\n\tstruct mbuf\t\t*m;\n\tstruct ifnet\t\t*ifp;\n\tstruct sf_rx_bufdesc_type0\t*desc;\n\tstruct sf_rx_cmpdesc_type3\t*cur_rx;\n\tu_int32_t\t\trxcons, rxprod;\n\tint\t\t\tcmpprodidx, cmpconsidx, bufprodidx;\n\n\tifp = &sc->arpcom.ac_if;\n\n\trxcons = csr_read_4(sc, SF_CQ_CONSIDX);\n\trxprod = csr_read_4(sc, SF_RXDQ_PTR_Q1);\n\tcmpprodidx = SF_IDX_LO(csr_read_4(sc, SF_CQ_PRODIDX));\n\tcmpconsidx = SF_IDX_LO(rxcons);\n\tbufprodidx = SF_IDX_LO(rxprod);\n\n\twhile (cmpconsidx != cmpprodidx) {\n\t\tstruct mbuf\t\t*m0;\n\n\t\tcur_rx = &sc->sf_ldata->sf_rx_clist[cmpconsidx];\n\t\tdesc = &sc->sf_ldata->sf_rx_dlist_big[cur_rx->sf_endidx];\n\t\tm = desc->sf_mbuf;\n\t\tSF_INC(cmpconsidx, SF_RX_CLIST_CNT);\n\t\tSF_INC(bufprodidx, SF_RX_DLIST_CNT);\n\n\t\tif (!(cur_rx->sf_status1 & SF_RXSTAT1_OK)) {\n\t\t\tifp->if_ierrors++;\n\t\t\tsf_newbuf(sc, desc, m);\n\t\t\tcontinue;\n\t\t}\n\n\t\tm0 = m_devget(mtod(m, char *) - ETHER_ALIGN,\n\t\t    cur_rx->sf_len + ETHER_ALIGN, 0, ifp, NULL);\n\t\tsf_newbuf(sc, desc, m);\n\t\tif (m0 == NULL) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcontinue;\n\t\t}\n\t\tm_adj(m0, ETHER_ALIGN);\n\t\tm = m0;\n\n\t\teh = mtod(m, struct ether_header *);\n\t\tifp->if_ipackets++;\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\n\t}\n\n\tcsr_write_4(sc, SF_CQ_CONSIDX,\n\t    (rxcons & ~SF_CQ_CONSIDX_RXQ1) | cmpconsidx);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1,\n\t    (rxprod & ~SF_RXDQ_PRODIDX) | bufprodidx);\n\n\treturn;\n}"
  },
  {
    "function_name": "sf_newbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "821-857",
    "snippet": "int sf_newbuf(sc, c, m)\n\tstruct sf_softc\t\t*sc;\n\tstruct sf_rx_bufdesc_type0\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"sf%d: no memory for rx list -- \"\n\t\t\t    \"packet dropped!\\n\", sc->sf_unit);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"sf%d: no memory for rx list -- \"\n\t\t\t    \"packet dropped!\\n\", sc->sf_unit);\n\t\t\tm_freem(m_new);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, sizeof(u_int64_t));\n\n\tc->sf_mbuf = m_new;\n\tc->sf_addrlo = SF_RX_HOSTADDR(vtophys(mtod(m_new, caddr_t)));\n\tc->sf_valid = 1;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sf_newbuf"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SF_RX_HOSTADDR",
          "args": [
            "vtophys(mtod(m_new, caddr_t))"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m_new, caddr_t)"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m_new",
            "caddr_t"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m_new",
            "sizeof(u_int64_t)"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_new"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"sf%d: no memory for rx list -- \"\n\t\t\t    \"packet dropped!\\n\"",
            "sc->sf_unit"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m_new",
            "M_DONTWAIT"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m_new",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_newbuf;\n\nint sf_newbuf(sc, c, m)\n\tstruct sf_softc\t\t*sc;\n\tstruct sf_rx_bufdesc_type0\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"sf%d: no memory for rx list -- \"\n\t\t\t    \"packet dropped!\\n\", sc->sf_unit);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"sf%d: no memory for rx list -- \"\n\t\t\t    \"packet dropped!\\n\", sc->sf_unit);\n\t\t\tm_freem(m_new);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, sizeof(u_int64_t));\n\n\tc->sf_mbuf = m_new;\n\tc->sf_addrlo = SF_RX_HOSTADDR(vtophys(mtod(m_new, caddr_t)));\n\tc->sf_valid = 1;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "sf_init_tx_ring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "797-819",
    "snippet": "void sf_init_tx_ring(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tstruct sf_list_data\t*ld;\n\tint\t\t\ti;\n\n\tld = sc->sf_ldata;\n\n\tbzero((char *)ld->sf_tx_dlist,\n\t    sizeof(struct sf_tx_bufdesc_type0) * SF_TX_DLIST_CNT);\n\tbzero((char *)ld->sf_tx_clist,\n\t    sizeof(struct sf_tx_cmpdesc_type0) * SF_TX_CLIST_CNT);\n\n\tfor (i = 0; i < SF_TX_DLIST_CNT; i++)\n\t\tld->sf_tx_dlist[i].sf_id = SF_TX_BUFDESC_ID;\n\tfor (i = 0; i < SF_TX_CLIST_CNT; i++)\n\t\tld->sf_tx_clist[i].sf_type = SF_TXCMPTYPE_TX;\n\n\tld->sf_tx_dlist[SF_TX_DLIST_CNT - 1].sf_end = 1;\n\tsc->sf_tx_cnt = 0;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sf_init_tx_ring"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)ld->sf_tx_clist",
            "sizeof(struct sf_tx_cmpdesc_type0) * SF_TX_CLIST_CNT"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)ld->sf_tx_dlist",
            "sizeof(struct sf_tx_bufdesc_type0) * SF_TX_DLIST_CNT"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_init_tx_ring;\n\nvoid sf_init_tx_ring(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tstruct sf_list_data\t*ld;\n\tint\t\t\ti;\n\n\tld = sc->sf_ldata;\n\n\tbzero((char *)ld->sf_tx_dlist,\n\t    sizeof(struct sf_tx_bufdesc_type0) * SF_TX_DLIST_CNT);\n\tbzero((char *)ld->sf_tx_clist,\n\t    sizeof(struct sf_tx_cmpdesc_type0) * SF_TX_CLIST_CNT);\n\n\tfor (i = 0; i < SF_TX_DLIST_CNT; i++)\n\t\tld->sf_tx_dlist[i].sf_id = SF_TX_BUFDESC_ID;\n\tfor (i = 0; i < SF_TX_CLIST_CNT; i++)\n\t\tld->sf_tx_clist[i].sf_type = SF_TXCMPTYPE_TX;\n\n\tld->sf_tx_dlist[SF_TX_DLIST_CNT - 1].sf_end = 1;\n\tsc->sf_tx_cnt = 0;\n\n\treturn;\n}"
  },
  {
    "function_name": "sf_init_rx_ring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "776-795",
    "snippet": "int sf_init_rx_ring(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tstruct sf_list_data\t*ld;\n\tint\t\t\ti;\n\n\tld = sc->sf_ldata;\n\n\tbzero((char *)ld->sf_rx_dlist_big,\n\t    sizeof(struct sf_rx_bufdesc_type0) * SF_RX_DLIST_CNT);\n\tbzero((char *)ld->sf_rx_clist,\n\t    sizeof(struct sf_rx_cmpdesc_type3) * SF_RX_CLIST_CNT);\n\n\tfor (i = 0; i < SF_RX_DLIST_CNT; i++) {\n\t\tif (sf_newbuf(sc, &ld->sf_rx_dlist_big[i], NULL) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t}\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sf_init_rx_ring",
      "int sf_newbuf"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sf_newbuf",
          "args": [
            "sc",
            "&ld->sf_rx_dlist_big[i]",
            "NULL"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "sf_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "821-857",
          "snippet": "int sf_newbuf(sc, c, m)\n\tstruct sf_softc\t\t*sc;\n\tstruct sf_rx_bufdesc_type0\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"sf%d: no memory for rx list -- \"\n\t\t\t    \"packet dropped!\\n\", sc->sf_unit);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"sf%d: no memory for rx list -- \"\n\t\t\t    \"packet dropped!\\n\", sc->sf_unit);\n\t\t\tm_freem(m_new);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, sizeof(u_int64_t));\n\n\tc->sf_mbuf = m_new;\n\tc->sf_addrlo = SF_RX_HOSTADDR(vtophys(mtod(m_new, caddr_t)));\n\tc->sf_valid = 1;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int sf_newbuf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_newbuf;\n\nint sf_newbuf(sc, c, m)\n\tstruct sf_softc\t\t*sc;\n\tstruct sf_rx_bufdesc_type0\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"sf%d: no memory for rx list -- \"\n\t\t\t    \"packet dropped!\\n\", sc->sf_unit);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"sf%d: no memory for rx list -- \"\n\t\t\t    \"packet dropped!\\n\", sc->sf_unit);\n\t\t\tm_freem(m_new);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, sizeof(u_int64_t));\n\n\tc->sf_mbuf = m_new;\n\tc->sf_addrlo = SF_RX_HOSTADDR(vtophys(mtod(m_new, caddr_t)));\n\tc->sf_valid = 1;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)ld->sf_rx_clist",
            "sizeof(struct sf_rx_cmpdesc_type3) * SF_RX_CLIST_CNT"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)ld->sf_rx_dlist_big",
            "sizeof(struct sf_rx_bufdesc_type0) * SF_RX_DLIST_CNT"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_init_rx_ring;\nint sf_newbuf;\n\nint sf_init_rx_ring(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tstruct sf_list_data\t*ld;\n\tint\t\t\ti;\n\n\tld = sc->sf_ldata;\n\n\tbzero((char *)ld->sf_rx_dlist_big,\n\t    sizeof(struct sf_rx_bufdesc_type0) * SF_RX_DLIST_CNT);\n\tbzero((char *)ld->sf_rx_clist,\n\t    sizeof(struct sf_rx_cmpdesc_type3) * SF_RX_CLIST_CNT);\n\n\tfor (i = 0; i < SF_RX_DLIST_CNT; i++) {\n\t\tif (sf_newbuf(sc, &ld->sf_rx_dlist_big[i], NULL) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t}\n\n\treturn(0);\n}"
  },
  {
    "function_name": "sf_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "606-774",
    "snippet": "void sf_attach(parent, self, aux)\n\tstruct device\t\t*parent, *self;\n\tvoid\t\t\t*aux;\n{\n\tint\t\t\ts, i;\n\tconst char\t\t*intrstr = NULL;\n\tu_int32_t\t\tcommand;\n\tstruct sf_softc\t\t*sc = (struct sf_softc *)self;\n\tstruct pci_attach_args\t*pa = aux;\n\tpci_chipset_tag_t\tpc = pa->pa_pc;\n\tpci_intr_handle_t\tih;\n\tstruct ifnet\t\t*ifp;\n\tbus_addr_t\t\tiobase;\n\tbus_size_t\t\tiosize;\n\n\ts = splimp();\n\tsc->sf_unit = sc->sc_dev.dv_unit;\n\n\t/*\n\t * Handle power management nonsense.\n\t */\n\tcommand = pci_conf_read(pc, pa->pa_tag, SF_PCI_CAPID) & 0x000000FF;\n\tif (command == 0x01) {\n\n\t\tcommand = pci_conf_read(pc, pa->pa_tag, SF_PCI_PWRMGMTCTRL);\n\t\tif (command & SF_PSTATE_MASK) {\n\t\t\tu_int32_t\t\tiobase, membase, irq;\n\n\t\t\t/* Save important PCI config data. */\n\t\t\tiobase = pci_conf_read(pc, pa->pa_tag, SF_PCI_LOIO);\n\t\t\tmembase = pci_conf_read(pc, pa->pa_tag, SF_PCI_LOMEM);\n\t\t\tirq = pci_conf_read(pc, pa->pa_tag, SF_PCI_INTLINE);\n\n\t\t\t/* Reset the power state. */\n\t\t\tprintf(\"sf%d: chip is in D%d power mode \"\n\t\t\t\"-- setting to D0\\n\", sc->sf_unit, command & SF_PSTATE_MASK);\n\t\t\tcommand &= 0xFFFFFFFC;\n\t\t\tpci_conf_write(pc, pa->pa_tag, SF_PCI_PWRMGMTCTRL, command);\n\n\t\t\t/* Restore PCI config data. */\n\t\t\tpci_conf_write(pc, pa->pa_tag, SF_PCI_LOIO, iobase);\n\t\t\tpci_conf_write(pc, pa->pa_tag, SF_PCI_LOMEM, membase);\n\t\t\tpci_conf_write(pc, pa->pa_tag, SF_PCI_INTLINE, irq);\n\t\t}\n\t}\n\n\t/*\n\t * Map control/status registers.\n\t */\n\tcommand = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\tcommand |= PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |\n\t    PCI_COMMAND_MASTER_ENABLE;\n\tpci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);\n\tcommand = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\n#ifdef SF_USEIOSPACE\n\tif (!(command & PCI_COMMAND_IO_ENABLE)) {\n\t\tprintf(\": failed to enable I/O ports\\n\");\n\t\tgoto fail;\n\t}\n\tif (pci_io_find(pc, pa->pa_tag, SF_PCI_LOIO, &iobase, &iosize)) {\n\t\tprintf(\": can't find I/O space\\n\");\n\t\tgoto fail;\n\t}\n\tif (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->sf_bhandle)) {\n\t\tprintf(\": can't map I/O space\\n\");\n\t\tgoto fail;\n\t}\n\tsc->sf_btag = pa->pa_iot;\n#else\n\tif (!(command & PCI_COMMAND_MEM_ENABLE)) {\n\t\tprintf(\": failed to enable memory mapping\\n\");\n\t\tgoto fail;\n\t}\n\tif (pci_mem_find(pc, pa->pa_tag, SF_PCI_LOMEM, &iobase, &iosize, NULL)){\n\t\tprintf(\": can't find mem space\\n\");\n\t\tgoto fail;\n\t}\n\tif (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->sf_bhandle)) {\n\t\tprintf(\": can't map mem space\\n\");\n\t\tgoto fail;\n\t}\n\tsc->sf_btag = pa->pa_memt;\n#endif\n\n\t/* Allocate interrupt */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin, pa->pa_intrline,\n\t    &ih)) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\tgoto fail;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, sf_intr, sc,\n\t    self->dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\": couldn't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\tgoto fail;\n\t}\n\tprintf(\": %s\", intrstr);\n\n\t/* Reset the adapter. */\n\tsf_reset(sc);\n\n\t/*\n\t * Get station address from the EEPROM.\n\t */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tsc->arpcom.ac_enaddr[i] =\n\t\t    sf_read_eeprom(sc, SF_EE_NODEADDR + ETHER_ADDR_LEN - i);\n\n\tprintf(\" address %s\\n\", ether_sprintf(sc->arpcom.ac_enaddr));\n\n\t/* Allocate the descriptor queues. */\n\tsc->sf_ldata_ptr = malloc(sizeof(struct sf_list_data) + 8,\n\t\t\t\tM_DEVBUF, M_NOWAIT);\n\tif (sc->sf_ldata_ptr == NULL) {\n\t\tprintf(\"%s: no memory for list buffers!\\n\", sc->sf_unit);\n\t\tgoto fail;\n\t}\n\n\tsc->sf_ldata = (struct sf_list_data *)sc->sf_ldata_ptr;\n\tbzero(sc->sf_ldata, sizeof(struct sf_list_data));\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_softc = sc;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = sf_ioctl;\n\tifp->if_output = ether_output;\n\tifp->if_start = sf_start;\n\tifp->if_watchdog = sf_watchdog;\n\tifp->if_baudrate = 10000000;\n\tifp->if_snd.ifq_maxlen = SF_TX_DLIST_CNT - 1;\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\n\t/*\n\t * Initialize our media structures and probe the MII.\n\t */\n\tsc->sc_mii.mii_ifp = ifp;\n\tsc->sc_mii.mii_readreg = sf_miibus_readreg;\n\tsc->sc_mii.mii_writereg = sf_miibus_writereg;\n\tsc->sc_mii.mii_statchg = sf_miibus_statchg;\n\tifmedia_init(&sc->sc_mii.mii_media, 0, sf_ifmedia_upd, sf_ifmedia_sts);\n\tmii_phy_probe(self, &sc->sc_mii, 0xffffffff);\n\tif (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {\n\t\tifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE, 0, NULL);\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);\n\t} else\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);\n\n\t/*\n\t * Call MI attach routines.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\t  sizeof(struct ether_header));\n#endif\n\tshutdownhook_establish(sf_shutdown, sc);\n\nfail:\n\tsplx(s);\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define SF_USEIOSPACE"
    ],
    "globals_used": [
      "void sf_attach",
      "int sf_intr",
      "void sf_shutdown",
      "void sf_start",
      "int sf_ioctl",
      "void sf_watchdog",
      "int sf_ifmedia_upd",
      "void sf_ifmedia_sts",
      "void sf_reset",
      "u_int8_t sf_read_eeprom",
      "int sf_miibus_readreg",
      "void sf_miibus_writereg",
      "void sf_miibus_statchg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "sf_shutdown",
            "sc"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&sc->arpcom.ac_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER|IFM_AUTO"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER|IFM_NONE"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER|IFM_NONE",
            "0",
            "NULL"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->sc_mii.mii_phys"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mii_phy_probe",
          "args": [
            "self",
            "&sc->sc_mii",
            "0xffffffff"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "mii_phy_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "68-122",
          "snippet": "void\nmii_phy_probe(parent, mii, capmask)\n\tstruct device *parent;\n\tstruct mii_data *mii;\n\tint capmask;\n{\n\tstruct mii_attach_args ma;\n\tstruct mii_softc *child;\n\n\tLIST_INIT(&mii->mii_phys);\n\n\tfor (ma.mii_phyno = 0; ma.mii_phyno < MII_NPHY; ma.mii_phyno++) {\n\t\t/*\n\t\t * Check to see if there is a PHY at this address.  If\n\t\t * the register contains garbage, assume no.\n\t\t */\n\t\tma.mii_id1 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR1);\n\t\tma.mii_id2 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR2);\n\t\tif ((ma.mii_id1 == 0 || ma.mii_id1 == 0xffff) &&\n\t\t    (ma.mii_id2 == 0 || ma.mii_id2 == 0xffff)) {\n\t\t\t/*\n\t\t\t * ARGH!!  3Com internal PHYs report 0/0 in their\n\t\t\t * ID registers!  If we spot this, check to see\n\t\t\t * if the BMSR has reasonable data in it.\n\t\t\t * And if that wasn't enough there are PHYs\n\t\t\t * reporting 0xffff/0xffff too.\n\t\t\t */\n\t\t\tif ((MII_OUI(ma.mii_id1, ma.mii_id2) == 0 &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0) ||\n\t\t\t    (MII_OUI(ma.mii_id1, ma.mii_id2) == 0x3fffff &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0x3f)) {\n\t\t\t\tint bmsr = (*mii->mii_readreg)(parent,\n\t\t\t\t    ma.mii_phyno, MII_BMSR);\n\t\t\t\tif (bmsr == 0 || bmsr == 0xffff ||\n\t\t\t\t    (bmsr & BMSR_MEDIAMASK) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tma.mii_data = mii;\n\t\tma.mii_capmask = capmask;\n\n\t\tif ((child = (struct mii_softc *)config_found_sm(parent, &ma,\n\t\t    mii_print, mii_submatch)) != NULL) {\n\t\t\t/*\n\t\t\t * Link it up in the parent's MII data.\n\t\t\t */\n\t\t\tLIST_INSERT_HEAD(&mii->mii_phys, child, mii_list);\n\t\t\tmii->mii_instance++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tmii_print",
            "int\tmii_submatch"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\tmii_print;\nint\tmii_submatch;\n\nvoid\nmii_phy_probe(parent, mii, capmask)\n\tstruct device *parent;\n\tstruct mii_data *mii;\n\tint capmask;\n{\n\tstruct mii_attach_args ma;\n\tstruct mii_softc *child;\n\n\tLIST_INIT(&mii->mii_phys);\n\n\tfor (ma.mii_phyno = 0; ma.mii_phyno < MII_NPHY; ma.mii_phyno++) {\n\t\t/*\n\t\t * Check to see if there is a PHY at this address.  If\n\t\t * the register contains garbage, assume no.\n\t\t */\n\t\tma.mii_id1 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR1);\n\t\tma.mii_id2 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR2);\n\t\tif ((ma.mii_id1 == 0 || ma.mii_id1 == 0xffff) &&\n\t\t    (ma.mii_id2 == 0 || ma.mii_id2 == 0xffff)) {\n\t\t\t/*\n\t\t\t * ARGH!!  3Com internal PHYs report 0/0 in their\n\t\t\t * ID registers!  If we spot this, check to see\n\t\t\t * if the BMSR has reasonable data in it.\n\t\t\t * And if that wasn't enough there are PHYs\n\t\t\t * reporting 0xffff/0xffff too.\n\t\t\t */\n\t\t\tif ((MII_OUI(ma.mii_id1, ma.mii_id2) == 0 &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0) ||\n\t\t\t    (MII_OUI(ma.mii_id1, ma.mii_id2) == 0x3fffff &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0x3f)) {\n\t\t\t\tint bmsr = (*mii->mii_readreg)(parent,\n\t\t\t\t    ma.mii_phyno, MII_BMSR);\n\t\t\t\tif (bmsr == 0 || bmsr == 0xffff ||\n\t\t\t\t    (bmsr & BMSR_MEDIAMASK) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tma.mii_data = mii;\n\t\tma.mii_capmask = capmask;\n\n\t\tif ((child = (struct mii_softc *)config_found_sm(parent, &ma,\n\t\t    mii_print, mii_submatch)) != NULL) {\n\t\t\t/*\n\t\t\t * Link it up in the parent's MII data.\n\t\t\t */\n\t\t\tLIST_INSERT_HEAD(&mii->mii_phys, child, mii_list);\n\t\t\tmii->mii_instance++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->sc_mii.mii_media",
            "0",
            "sf_ifmedia_upd",
            "sf_ifmedia_sts"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->sf_ldata",
            "sizeof(struct sf_list_data)"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: no memory for list buffers!\\n\"",
            "sc->sf_unit"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct sf_list_data) + 8",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->arpcom.ac_enaddr"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sf_read_eeprom",
          "args": [
            "sc",
            "SF_EE_NODEADDR + ETHER_ADDR_LEN - i"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "sf_read_eeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "187-197",
          "snippet": "u_int8_t sf_read_eeprom(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int8_t\t\tval;\n\n\tval = (csr_read_4(sc, SF_EEADDR_BASE +\n\t    (reg & 0xFFFFFFFC)) >> (8 * (reg & 3))) & 0xFF;\n\n\treturn(val);\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t sf_read_eeprom",
            "u_int32_t csr_read_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t sf_read_eeprom;\nu_int32_t csr_read_4;\n\nu_int8_t sf_read_eeprom(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int8_t\t\tval;\n\n\tval = (csr_read_4(sc, SF_EEADDR_BASE +\n\t    (reg & 0xFFFFFFFC)) >> (8 * (reg & 3))) & 0xFF;\n\n\treturn(val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sf_reset",
          "args": [
            "sc"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "sf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "552-576",
          "snippet": "void sf_reset(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tcsr_write_4(sc, SF_GEN_ETH_CTL, 0);\n\tSF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);\n\tDELAY(1000);\n\tSF_CLRBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);\n\n\tSF_SETBIT(sc, SF_PCI_DEVCFG, SF_PCIDEVCFG_RESET);\n\n\tfor (i = 0; i < SF_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(csr_read_4(sc, SF_PCI_DEVCFG) & SF_PCIDEVCFG_RESET))\n\t\t\tbreak;\n\t}\n\n\tif (i == SF_TIMEOUT)\n\t\tprintf(\"sf%d: reset never completed!\\n\", sc->sf_unit);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sf_reset",
            "u_int32_t csr_read_4",
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_reset;\nu_int32_t csr_read_4;\nvoid csr_write_4;\n\nvoid sf_reset(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tcsr_write_4(sc, SF_GEN_ETH_CTL, 0);\n\tSF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);\n\tDELAY(1000);\n\tSF_CLRBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);\n\n\tSF_SETBIT(sc, SF_PCI_DEVCFG, SF_PCIDEVCFG_RESET);\n\n\tfor (i = 0; i < SF_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(csr_read_4(sc, SF_PCI_DEVCFG) & SF_PCIDEVCFG_RESET))\n\t\t\tbreak;\n\t}\n\n\tif (i == SF_TIMEOUT)\n\t\tprintf(\"sf%d: reset never completed!\\n\", sc->sf_unit);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pc",
            "ih",
            "IPL_NET",
            "sf_intr",
            "sc",
            "self->dv_xname"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pc",
            "ih"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&ih"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "pa->pa_memt",
            "iobase",
            "iosize",
            "0",
            "&sc->sf_bhandle"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_mem_find",
          "args": [
            "pc",
            "pa->pa_tag",
            "SF_PCI_LOMEM",
            "&iobase",
            "&iosize",
            "NULL"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mem_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "197-208",
          "snippet": "int\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_mem_find;\n\nint\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "pa->pa_iot",
            "iobase",
            "iosize",
            "0",
            "&sc->sf_bhandle"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_io_find",
          "args": [
            "pc",
            "pa->pa_tag",
            "SF_PCI_LOIO",
            "&iobase",
            "&iosize"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "pci_io_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "186-195",
          "snippet": "int\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\n\nint\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG",
            "command"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "pa->pa_tag",
            "SF_PCI_INTLINE",
            "irq"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "pa->pa_tag",
            "SF_PCI_LOMEM",
            "membase"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "pa->pa_tag",
            "SF_PCI_LOIO",
            "iobase"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "pa->pa_tag",
            "SF_PCI_PWRMGMTCTRL",
            "command"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "SF_PCI_INTLINE"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "SF_PCI_LOMEM"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "SF_PCI_LOIO"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "SF_PCI_PWRMGMTCTRL"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "SF_PCI_CAPID"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nvoid sf_attach;\nint sf_intr;\nvoid sf_shutdown;\nvoid sf_start;\nint sf_ioctl;\nvoid sf_watchdog;\nint sf_ifmedia_upd;\nvoid sf_ifmedia_sts;\nvoid sf_reset;\nu_int8_t sf_read_eeprom;\nint sf_miibus_readreg;\nvoid sf_miibus_writereg;\nvoid sf_miibus_statchg;\n\nvoid sf_attach(parent, self, aux)\n\tstruct device\t\t*parent, *self;\n\tvoid\t\t\t*aux;\n{\n\tint\t\t\ts, i;\n\tconst char\t\t*intrstr = NULL;\n\tu_int32_t\t\tcommand;\n\tstruct sf_softc\t\t*sc = (struct sf_softc *)self;\n\tstruct pci_attach_args\t*pa = aux;\n\tpci_chipset_tag_t\tpc = pa->pa_pc;\n\tpci_intr_handle_t\tih;\n\tstruct ifnet\t\t*ifp;\n\tbus_addr_t\t\tiobase;\n\tbus_size_t\t\tiosize;\n\n\ts = splimp();\n\tsc->sf_unit = sc->sc_dev.dv_unit;\n\n\t/*\n\t * Handle power management nonsense.\n\t */\n\tcommand = pci_conf_read(pc, pa->pa_tag, SF_PCI_CAPID) & 0x000000FF;\n\tif (command == 0x01) {\n\n\t\tcommand = pci_conf_read(pc, pa->pa_tag, SF_PCI_PWRMGMTCTRL);\n\t\tif (command & SF_PSTATE_MASK) {\n\t\t\tu_int32_t\t\tiobase, membase, irq;\n\n\t\t\t/* Save important PCI config data. */\n\t\t\tiobase = pci_conf_read(pc, pa->pa_tag, SF_PCI_LOIO);\n\t\t\tmembase = pci_conf_read(pc, pa->pa_tag, SF_PCI_LOMEM);\n\t\t\tirq = pci_conf_read(pc, pa->pa_tag, SF_PCI_INTLINE);\n\n\t\t\t/* Reset the power state. */\n\t\t\tprintf(\"sf%d: chip is in D%d power mode \"\n\t\t\t\"-- setting to D0\\n\", sc->sf_unit, command & SF_PSTATE_MASK);\n\t\t\tcommand &= 0xFFFFFFFC;\n\t\t\tpci_conf_write(pc, pa->pa_tag, SF_PCI_PWRMGMTCTRL, command);\n\n\t\t\t/* Restore PCI config data. */\n\t\t\tpci_conf_write(pc, pa->pa_tag, SF_PCI_LOIO, iobase);\n\t\t\tpci_conf_write(pc, pa->pa_tag, SF_PCI_LOMEM, membase);\n\t\t\tpci_conf_write(pc, pa->pa_tag, SF_PCI_INTLINE, irq);\n\t\t}\n\t}\n\n\t/*\n\t * Map control/status registers.\n\t */\n\tcommand = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\tcommand |= PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |\n\t    PCI_COMMAND_MASTER_ENABLE;\n\tpci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);\n\tcommand = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\n#ifdef SF_USEIOSPACE\n\tif (!(command & PCI_COMMAND_IO_ENABLE)) {\n\t\tprintf(\": failed to enable I/O ports\\n\");\n\t\tgoto fail;\n\t}\n\tif (pci_io_find(pc, pa->pa_tag, SF_PCI_LOIO, &iobase, &iosize)) {\n\t\tprintf(\": can't find I/O space\\n\");\n\t\tgoto fail;\n\t}\n\tif (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->sf_bhandle)) {\n\t\tprintf(\": can't map I/O space\\n\");\n\t\tgoto fail;\n\t}\n\tsc->sf_btag = pa->pa_iot;\n#else\n\tif (!(command & PCI_COMMAND_MEM_ENABLE)) {\n\t\tprintf(\": failed to enable memory mapping\\n\");\n\t\tgoto fail;\n\t}\n\tif (pci_mem_find(pc, pa->pa_tag, SF_PCI_LOMEM, &iobase, &iosize, NULL)){\n\t\tprintf(\": can't find mem space\\n\");\n\t\tgoto fail;\n\t}\n\tif (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->sf_bhandle)) {\n\t\tprintf(\": can't map mem space\\n\");\n\t\tgoto fail;\n\t}\n\tsc->sf_btag = pa->pa_memt;\n#endif\n\n\t/* Allocate interrupt */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin, pa->pa_intrline,\n\t    &ih)) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\tgoto fail;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, sf_intr, sc,\n\t    self->dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\": couldn't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\tgoto fail;\n\t}\n\tprintf(\": %s\", intrstr);\n\n\t/* Reset the adapter. */\n\tsf_reset(sc);\n\n\t/*\n\t * Get station address from the EEPROM.\n\t */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tsc->arpcom.ac_enaddr[i] =\n\t\t    sf_read_eeprom(sc, SF_EE_NODEADDR + ETHER_ADDR_LEN - i);\n\n\tprintf(\" address %s\\n\", ether_sprintf(sc->arpcom.ac_enaddr));\n\n\t/* Allocate the descriptor queues. */\n\tsc->sf_ldata_ptr = malloc(sizeof(struct sf_list_data) + 8,\n\t\t\t\tM_DEVBUF, M_NOWAIT);\n\tif (sc->sf_ldata_ptr == NULL) {\n\t\tprintf(\"%s: no memory for list buffers!\\n\", sc->sf_unit);\n\t\tgoto fail;\n\t}\n\n\tsc->sf_ldata = (struct sf_list_data *)sc->sf_ldata_ptr;\n\tbzero(sc->sf_ldata, sizeof(struct sf_list_data));\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_softc = sc;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = sf_ioctl;\n\tifp->if_output = ether_output;\n\tifp->if_start = sf_start;\n\tifp->if_watchdog = sf_watchdog;\n\tifp->if_baudrate = 10000000;\n\tifp->if_snd.ifq_maxlen = SF_TX_DLIST_CNT - 1;\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\n\t/*\n\t * Initialize our media structures and probe the MII.\n\t */\n\tsc->sc_mii.mii_ifp = ifp;\n\tsc->sc_mii.mii_readreg = sf_miibus_readreg;\n\tsc->sc_mii.mii_writereg = sf_miibus_writereg;\n\tsc->sc_mii.mii_statchg = sf_miibus_statchg;\n\tifmedia_init(&sc->sc_mii.mii_media, 0, sf_ifmedia_upd, sf_ifmedia_sts);\n\tmii_phy_probe(self, &sc->sc_mii, 0xffffffff);\n\tif (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {\n\t\tifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE, 0, NULL);\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);\n\t} else\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);\n\n\t/*\n\t * Call MI attach routines.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\t  sizeof(struct ether_header));\n#endif\n\tshutdownhook_establish(sf_shutdown, sc);\n\nfail:\n\tsplx(s);\n\treturn;\n}"
  },
  {
    "function_name": "sf_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "584-600",
    "snippet": "int sf_probe(parent, match, aux)\n\tstruct device\t\t*parent;\n\tvoid\t\t\t*match;\n\tvoid\t\t\t*aux;\n{\n\tstruct pci_attach_args\t*pa = (struct pci_attach_args *)aux;\n\n\tif (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_ADP)\n\t\treturn(0);\n\n\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\tcase PCI_PRODUCT_ADP_AIC6915:\n\t\treturn(1);\n\t}\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sf_probe"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_probe;\n\nint sf_probe(parent, match, aux)\n\tstruct device\t\t*parent;\n\tvoid\t\t\t*match;\n\tvoid\t\t\t*aux;\n{\n\tstruct pci_attach_args\t*pa = (struct pci_attach_args *)aux;\n\n\tif (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_ADP)\n\t\treturn(0);\n\n\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\tcase PCI_PRODUCT_ADP_AIC6915:\n\t\treturn(1);\n\t}\n\n\treturn(0);\n}"
  },
  {
    "function_name": "sf_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "552-576",
    "snippet": "void sf_reset(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tcsr_write_4(sc, SF_GEN_ETH_CTL, 0);\n\tSF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);\n\tDELAY(1000);\n\tSF_CLRBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);\n\n\tSF_SETBIT(sc, SF_PCI_DEVCFG, SF_PCIDEVCFG_RESET);\n\n\tfor (i = 0; i < SF_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(csr_read_4(sc, SF_PCI_DEVCFG) & SF_PCIDEVCFG_RESET))\n\t\t\tbreak;\n\t}\n\n\tif (i == SF_TIMEOUT)\n\t\tprintf(\"sf%d: reset never completed!\\n\", sc->sf_unit);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sf_reset",
      "u_int32_t csr_read_4",
      "void csr_write_4"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"sf%d: reset never completed!\\n\"",
            "sc->sf_unit"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "csr_read_4",
          "args": [
            "sc",
            "SF_PCI_DEVCFG"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "csr_read_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "171-185",
          "snippet": "u_int32_t csr_read_4(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int32_t\t\tval;\n\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tval = CSR_READ_4(sc, SF_INDIRECTIO_DATA);\n#else\n\tval = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));\n#endif\n\n\treturn(val);\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "u_int32_t csr_read_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nu_int32_t csr_read_4;\n\nu_int32_t csr_read_4(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int32_t\t\tval;\n\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tval = CSR_READ_4(sc, SF_INDIRECTIO_DATA);\n#else\n\tval = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));\n#endif\n\n\treturn(val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_SETBIT",
          "args": [
            "sc",
            "SF_PCI_DEVCFG",
            "SF_PCIDEVCFG_RESET"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_CLRBIT",
          "args": [
            "sc",
            "SF_MACCFG_1",
            "SF_MACCFG1_SOFTRESET"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_SETBIT",
          "args": [
            "sc",
            "SF_MACCFG_1",
            "SF_MACCFG1_SOFTRESET"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csr_write_4",
          "args": [
            "sc",
            "SF_GEN_ETH_CTL",
            "0"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "csr_write_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "199-211",
          "snippet": "void csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nvoid csr_write_4;\n\nvoid csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_reset;\nu_int32_t csr_read_4;\nvoid csr_write_4;\n\nvoid sf_reset(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tcsr_write_4(sc, SF_GEN_ETH_CTL, 0);\n\tSF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);\n\tDELAY(1000);\n\tSF_CLRBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);\n\n\tSF_SETBIT(sc, SF_PCI_DEVCFG, SF_PCIDEVCFG_RESET);\n\n\tfor (i = 0; i < SF_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(csr_read_4(sc, SF_PCI_DEVCFG) & SF_PCIDEVCFG_RESET))\n\t\t\tbreak;\n\t}\n\n\tif (i == SF_TIMEOUT)\n\t\tprintf(\"sf%d: reset never completed!\\n\", sc->sf_unit);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\treturn;\n}"
  },
  {
    "function_name": "sf_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "472-550",
    "snippet": "int sf_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tstruct sf_softc\t\t*sc = ifp->if_softc;\n\tstruct ifreq\t\t*ifr = (struct ifreq *) data;\n\tstruct ifaddr\t\t*ifa = (struct ifaddr *)data;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ts, error = 0;\n\n\ts = splimp();\n\n\tif ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n\t\tcase AF_INET:\n\t\t\tsf_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsf_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    ifp->if_flags & IFF_PROMISC &&\n\t\t\t    !(sc->sf_if_flags & IFF_PROMISC)) {\n\t\t\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);\n\t\t\t} else if (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    sc->sf_if_flags & IFF_PROMISC) {\n\t\t\t\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);\n\t\t\t} else if (!(ifp->if_flags & IFF_RUNNING))\n\t\t\t\tsf_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\tsf_stop(sc);\n\t\t}\n\t\tsc->sf_if_flags = ifp->if_flags;\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->arpcom) :\n\t\t    ether_delmulti(ifr, &sc->arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware\n\t\t\t * filter accordingly.\n\t\t\t */\n\t\t\tsf_setmulti(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\tmii = &sc->sc_mii;\n\t\terror = ifmedia_ioctl(ifp, ifr, &mii->mii_media, command);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\t(void)splx(s);\n\n\treturn(error);\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sf_ioctl",
      "void sf_init",
      "void sf_stop",
      "void sf_setmulti"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&mii->mii_media",
            "command"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sf_setmulti",
          "args": [
            "sc"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "sf_setmulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "376-427",
          "snippet": "void sf_setmulti(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tu_int8_t\t\tdummy[] = { 0, 0, 0, 0, 0, 0 };\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* First zot all the existing filters. */\n\tfor (i = 1; i < SF_RXFILT_PERFECT_CNT; i++)\n\t\tsf_setperf(sc, i, (char *)&dummy);\n\tfor (i = SF_RXFILT_HASH_BASE;\n\t    i < (SF_RXFILT_HASH_MAX + 1); i += 4)\n\t\tcsr_write_4(sc, i, 0);\n\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_ALLMULTI);\n\n\t/* Now program new ones. */\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_ALLMULTI);\n\t} else {\n\t\ti = 1;\n\t\t/* First find the tail of the list. */\n\t\tETHER_FIRST_MULTI(step, ac, enm);\n\n\t\t/* Now traverse the list backwards. */\n\t\twhile (enm != NULL) {\n\t\t\t/* if (enm->enm_addrlo->sa_family != AF_LINK)\n\t\t\t\tcontinue; */\n\t\t\t/*\n\t\t\t * Program the first 15 multicast groups\n\t\t\t * into the perfect filter. For all others,\n\t\t\t * use the hash table.\n\t\t\t */\n\t\t\tif (i < SF_RXFILT_PERFECT_CNT) {\n\t\t\t\tsf_setperf(sc, i,\n\t\t\tLLADDR((struct sockaddr_dl *)enm->enm_addrlo));\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsf_sethash(sc,\n\t\t\t    LLADDR((struct sockaddr_dl *)enm->enm_addrlo), 0);\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sf_setmulti",
            "int sf_setperf",
            "int sf_sethash",
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_setmulti;\nint sf_setperf;\nint sf_sethash;\nvoid csr_write_4;\n\nvoid sf_setmulti(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tu_int8_t\t\tdummy[] = { 0, 0, 0, 0, 0, 0 };\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* First zot all the existing filters. */\n\tfor (i = 1; i < SF_RXFILT_PERFECT_CNT; i++)\n\t\tsf_setperf(sc, i, (char *)&dummy);\n\tfor (i = SF_RXFILT_HASH_BASE;\n\t    i < (SF_RXFILT_HASH_MAX + 1); i += 4)\n\t\tcsr_write_4(sc, i, 0);\n\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_ALLMULTI);\n\n\t/* Now program new ones. */\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_ALLMULTI);\n\t} else {\n\t\ti = 1;\n\t\t/* First find the tail of the list. */\n\t\tETHER_FIRST_MULTI(step, ac, enm);\n\n\t\t/* Now traverse the list backwards. */\n\t\twhile (enm != NULL) {\n\t\t\t/* if (enm->enm_addrlo->sa_family != AF_LINK)\n\t\t\t\tcontinue; */\n\t\t\t/*\n\t\t\t * Program the first 15 multicast groups\n\t\t\t * into the perfect filter. For all others,\n\t\t\t * use the hash table.\n\t\t\t */\n\t\t\tif (i < SF_RXFILT_PERFECT_CNT) {\n\t\t\t\tsf_setperf(sc, i,\n\t\t\tLLADDR((struct sockaddr_dl *)enm->enm_addrlo));\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsf_sethash(sc,\n\t\t\t    LLADDR((struct sockaddr_dl *)enm->enm_addrlo), 0);\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc->arpcom"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc->arpcom"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sf_stop",
          "args": [
            "sc"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "sf_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "1272-1312",
          "snippet": "void sf_stop(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tuntimeout(sf_stats_update, sc);\n\n\tcsr_write_4(sc, SF_GEN_ETH_CTL, 0);\n\tcsr_write_4(sc, SF_CQ_CONSIDX, 0);\n\tcsr_write_4(sc, SF_CQ_PRODIDX, 0);\n\tcsr_write_4(sc, SF_RXDQ_ADDR_Q1, 0);\n\tcsr_write_4(sc, SF_RXDQ_CTL_1, 0);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1, 0);\n\tcsr_write_4(sc, SF_TXCQ_CTL, 0);\n\tcsr_write_4(sc, SF_TXDQ_ADDR_HIPRIO, 0);\n\tcsr_write_4(sc, SF_TXDQ_CTL, 0);\n\tsf_reset(sc);\n\n\tsc->sf_link = 0;\n\n\tfor (i = 0; i < SF_RX_DLIST_CNT; i++) {\n\t\tif (sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf != NULL) {\n\t\t\tm_freem(sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf);\n\t\t\tsc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < SF_TX_DLIST_CNT; i++) {\n\t\tif (sc->sf_ldata->sf_tx_dlist[i].sf_mbuf != NULL) {\n\t\t\tm_freem(sc->sf_ldata->sf_tx_dlist[i].sf_mbuf);\n\t\t\tsc->sf_ldata->sf_tx_dlist[i].sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sf_stats_update",
            "void sf_stop",
            "void sf_reset",
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_stats_update;\nvoid sf_stop;\nvoid sf_reset;\nvoid csr_write_4;\n\nvoid sf_stop(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tuntimeout(sf_stats_update, sc);\n\n\tcsr_write_4(sc, SF_GEN_ETH_CTL, 0);\n\tcsr_write_4(sc, SF_CQ_CONSIDX, 0);\n\tcsr_write_4(sc, SF_CQ_PRODIDX, 0);\n\tcsr_write_4(sc, SF_RXDQ_ADDR_Q1, 0);\n\tcsr_write_4(sc, SF_RXDQ_CTL_1, 0);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1, 0);\n\tcsr_write_4(sc, SF_TXCQ_CTL, 0);\n\tcsr_write_4(sc, SF_TXDQ_ADDR_HIPRIO, 0);\n\tcsr_write_4(sc, SF_TXDQ_CTL, 0);\n\tsf_reset(sc);\n\n\tsc->sf_link = 0;\n\n\tfor (i = 0; i < SF_RX_DLIST_CNT; i++) {\n\t\tif (sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf != NULL) {\n\t\t\tm_freem(sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf);\n\t\t\tsc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < SF_TX_DLIST_CNT; i++) {\n\t\tif (sc->sf_ldata->sf_tx_dlist[i].sf_mbuf != NULL) {\n\t\t\tm_freem(sc->sf_ldata->sf_tx_dlist[i].sf_mbuf);\n\t\t\tsc->sf_ldata->sf_tx_dlist[i].sf_mbuf = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sf_init",
          "args": [
            "sc"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "sf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "1044-1149",
          "snippet": "void sf_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct sf_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ti, s;\n\n\ts = splimp();\n\n\tmii = &sc->sc_mii;\n\n\tsf_stop(sc);\n\tsf_reset(sc);\n\n\t/* Init all the receive filter registers */\n\tfor (i = SF_RXFILT_PERFECT_BASE;\n\t    i < (SF_RXFILT_HASH_MAX + 1); i += 4)\n\t\tcsr_write_4(sc, i, 0);\n\n\t/* Empty stats counter registers. */\n\tfor (i = 0; i < sizeof(struct sf_stats)/sizeof(u_int32_t); i++)\n\t\tcsr_write_4(sc, SF_STATS_BASE +\n\t\t    (i + sizeof(u_int32_t)), 0);\n\n\t/* Init our MAC address */\n\tcsr_write_4(sc, SF_PAR0, *(u_int32_t *)(&sc->arpcom.ac_enaddr[0]));\n\tcsr_write_4(sc, SF_PAR1, *(u_int32_t *)(&sc->arpcom.ac_enaddr[4]));\n\tsf_setperf(sc, 0, (caddr_t)&sc->arpcom.ac_enaddr);\n\n\tif (sf_init_rx_ring(sc) == ENOBUFS) {\n\t\tprintf(\"sf%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc->sf_unit);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\tsf_init_tx_ring(sc);\n\n\tcsr_write_4(sc, SF_RXFILT, SF_PERFMODE_NORMAL|SF_HASHMODE_WITHVLAN);\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);\n\t} else {\n\t\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);\n\t}\n\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_BROAD);\n\t} else {\n\t\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_BROAD);\n\t}\n\n\t/* Init the completion queue indexes */\n\tcsr_write_4(sc, SF_CQ_CONSIDX, 0);\n\tcsr_write_4(sc, SF_CQ_PRODIDX, 0);\n\n\t/* Init the RX completion queue */\n\tcsr_write_4(sc, SF_RXCQ_CTL_1,\n\t    vtophys(sc->sf_ldata->sf_rx_clist) & SF_RXCQ_ADDR);\n\tSF_SETBIT(sc, SF_RXCQ_CTL_1, SF_RXCQTYPE_3);\n\n\t/* Init RX DMA control. */\n\tSF_SETBIT(sc, SF_RXDMA_CTL, SF_RXDMA_REPORTBADPKTS);\n\n\t/* Init the RX buffer descriptor queue. */\n\tcsr_write_4(sc, SF_RXDQ_ADDR_Q1,\n\t    vtophys(sc->sf_ldata->sf_rx_dlist_big));\n\tcsr_write_4(sc, SF_RXDQ_CTL_1, (MCLBYTES << 16) | SF_DESCSPACE_16BYTES);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1, SF_RX_DLIST_CNT - 1);\n\n\t/* Init the TX completion queue */\n\tcsr_write_4(sc, SF_TXCQ_CTL,\n\t    vtophys(sc->sf_ldata->sf_tx_clist) & SF_RXCQ_ADDR);\n\n\t/* Init the TX buffer descriptor queue. */\n\tcsr_write_4(sc, SF_TXDQ_ADDR_HIPRIO,\n\t\tvtophys(sc->sf_ldata->sf_tx_dlist));\n\tSF_SETBIT(sc, SF_TX_FRAMCTL, SF_TXFRMCTL_CPLAFTERTX);\n\tcsr_write_4(sc, SF_TXDQ_CTL,\n\t    SF_TXBUFDESC_TYPE0|SF_TXMINSPACE_128BYTES|SF_TXSKIPLEN_8BYTES);\n\tSF_SETBIT(sc, SF_TXDQ_CTL, SF_TXDQCTL_NODMACMP);\n\n\t/* Enable autopadding of short TX frames. */\n\tSF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_AUTOPAD);\n\n\t/* Enable interrupts. */\n\tcsr_write_4(sc, SF_IMR, SF_INTRS);\n\tSF_SETBIT(sc, SF_PCI_DEVCFG, SF_PCIDEVCFG_INTR_ENB);\n\n\t/* Enable the RX and TX engines. */\n\tSF_SETBIT(sc, SF_GEN_ETH_CTL, SF_ETHCTL_RX_ENB|SF_ETHCTL_RXDMA_ENB);\n\tSF_SETBIT(sc, SF_GEN_ETH_CTL, SF_ETHCTL_TX_ENB|SF_ETHCTL_TXDMA_ENB);\n\n\tsf_ifmedia_upd(ifp);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\ttimeout(sf_stats_update, sc, hz);\n\n\tsplx(s);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sf_stats_update",
            "void sf_init",
            "void sf_stop",
            "int sf_ifmedia_upd",
            "void sf_reset",
            "int sf_init_rx_ring",
            "void sf_init_tx_ring",
            "int sf_setperf",
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_stats_update;\nvoid sf_init;\nvoid sf_stop;\nint sf_ifmedia_upd;\nvoid sf_reset;\nint sf_init_rx_ring;\nvoid sf_init_tx_ring;\nint sf_setperf;\nvoid csr_write_4;\n\nvoid sf_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct sf_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ti, s;\n\n\ts = splimp();\n\n\tmii = &sc->sc_mii;\n\n\tsf_stop(sc);\n\tsf_reset(sc);\n\n\t/* Init all the receive filter registers */\n\tfor (i = SF_RXFILT_PERFECT_BASE;\n\t    i < (SF_RXFILT_HASH_MAX + 1); i += 4)\n\t\tcsr_write_4(sc, i, 0);\n\n\t/* Empty stats counter registers. */\n\tfor (i = 0; i < sizeof(struct sf_stats)/sizeof(u_int32_t); i++)\n\t\tcsr_write_4(sc, SF_STATS_BASE +\n\t\t    (i + sizeof(u_int32_t)), 0);\n\n\t/* Init our MAC address */\n\tcsr_write_4(sc, SF_PAR0, *(u_int32_t *)(&sc->arpcom.ac_enaddr[0]));\n\tcsr_write_4(sc, SF_PAR1, *(u_int32_t *)(&sc->arpcom.ac_enaddr[4]));\n\tsf_setperf(sc, 0, (caddr_t)&sc->arpcom.ac_enaddr);\n\n\tif (sf_init_rx_ring(sc) == ENOBUFS) {\n\t\tprintf(\"sf%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc->sf_unit);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\tsf_init_tx_ring(sc);\n\n\tcsr_write_4(sc, SF_RXFILT, SF_PERFMODE_NORMAL|SF_HASHMODE_WITHVLAN);\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);\n\t} else {\n\t\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);\n\t}\n\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_BROAD);\n\t} else {\n\t\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_BROAD);\n\t}\n\n\t/* Init the completion queue indexes */\n\tcsr_write_4(sc, SF_CQ_CONSIDX, 0);\n\tcsr_write_4(sc, SF_CQ_PRODIDX, 0);\n\n\t/* Init the RX completion queue */\n\tcsr_write_4(sc, SF_RXCQ_CTL_1,\n\t    vtophys(sc->sf_ldata->sf_rx_clist) & SF_RXCQ_ADDR);\n\tSF_SETBIT(sc, SF_RXCQ_CTL_1, SF_RXCQTYPE_3);\n\n\t/* Init RX DMA control. */\n\tSF_SETBIT(sc, SF_RXDMA_CTL, SF_RXDMA_REPORTBADPKTS);\n\n\t/* Init the RX buffer descriptor queue. */\n\tcsr_write_4(sc, SF_RXDQ_ADDR_Q1,\n\t    vtophys(sc->sf_ldata->sf_rx_dlist_big));\n\tcsr_write_4(sc, SF_RXDQ_CTL_1, (MCLBYTES << 16) | SF_DESCSPACE_16BYTES);\n\tcsr_write_4(sc, SF_RXDQ_PTR_Q1, SF_RX_DLIST_CNT - 1);\n\n\t/* Init the TX completion queue */\n\tcsr_write_4(sc, SF_TXCQ_CTL,\n\t    vtophys(sc->sf_ldata->sf_tx_clist) & SF_RXCQ_ADDR);\n\n\t/* Init the TX buffer descriptor queue. */\n\tcsr_write_4(sc, SF_TXDQ_ADDR_HIPRIO,\n\t\tvtophys(sc->sf_ldata->sf_tx_dlist));\n\tSF_SETBIT(sc, SF_TX_FRAMCTL, SF_TXFRMCTL_CPLAFTERTX);\n\tcsr_write_4(sc, SF_TXDQ_CTL,\n\t    SF_TXBUFDESC_TYPE0|SF_TXMINSPACE_128BYTES|SF_TXSKIPLEN_8BYTES);\n\tSF_SETBIT(sc, SF_TXDQ_CTL, SF_TXDQCTL_NODMACMP);\n\n\t/* Enable autopadding of short TX frames. */\n\tSF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_AUTOPAD);\n\n\t/* Enable interrupts. */\n\tcsr_write_4(sc, SF_IMR, SF_INTRS);\n\tSF_SETBIT(sc, SF_PCI_DEVCFG, SF_PCIDEVCFG_INTR_ENB);\n\n\t/* Enable the RX and TX engines. */\n\tSF_SETBIT(sc, SF_GEN_ETH_CTL, SF_ETHCTL_RX_ENB|SF_ETHCTL_RXDMA_ENB);\n\tSF_SETBIT(sc, SF_GEN_ETH_CTL, SF_ETHCTL_TX_ENB|SF_ETHCTL_TXDMA_ENB);\n\n\tsf_ifmedia_upd(ifp);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\ttimeout(sf_stats_update, sc, hz);\n\n\tsplx(s);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SF_CLRBIT",
          "args": [
            "sc",
            "SF_RXFILT",
            "SF_RXFILT_PROMISC"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_SETBIT",
          "args": [
            "sc",
            "SF_RXFILT",
            "SF_RXFILT_PROMISC"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->arpcom",
            "ifa"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "&sc->arpcom",
            "command",
            "data"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "wx_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "303-356",
          "snippet": "static int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_init",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_init;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_ioctl;\nvoid sf_init;\nvoid sf_stop;\nvoid sf_setmulti;\n\nint sf_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tstruct sf_softc\t\t*sc = ifp->if_softc;\n\tstruct ifreq\t\t*ifr = (struct ifreq *) data;\n\tstruct ifaddr\t\t*ifa = (struct ifaddr *)data;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ts, error = 0;\n\n\ts = splimp();\n\n\tif ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n\t\tcase AF_INET:\n\t\t\tsf_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsf_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    ifp->if_flags & IFF_PROMISC &&\n\t\t\t    !(sc->sf_if_flags & IFF_PROMISC)) {\n\t\t\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);\n\t\t\t} else if (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    sc->sf_if_flags & IFF_PROMISC) {\n\t\t\t\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);\n\t\t\t} else if (!(ifp->if_flags & IFF_RUNNING))\n\t\t\t\tsf_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\tsf_stop(sc);\n\t\t}\n\t\tsc->sf_if_flags = ifp->if_flags;\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->arpcom) :\n\t\t    ether_delmulti(ifr, &sc->arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware\n\t\t\t * filter accordingly.\n\t\t\t */\n\t\t\tsf_setmulti(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\tmii = &sc->sc_mii;\n\t\terror = ifmedia_ioctl(ifp, ifr, &mii->mii_media, command);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\t(void)splx(s);\n\n\treturn(error);\n}"
  },
  {
    "function_name": "sf_ifmedia_sts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "455-470",
    "snippet": "void sf_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct sf_softc\t\t*sc;\n\tstruct mii_data\t\t*mii;\n\n\tsc = ifp->if_softc;\n\tmii = &sc->sc_mii;\n\n\tmii_pollstat(mii);\n\tifmr->ifm_active = mii->mii_media_active;\n\tifmr->ifm_status = mii->mii_media_status;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sf_ifmedia_sts"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mii_pollstat",
          "args": [
            "mii"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "mii_pollstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "206-218",
          "snippet": "void\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_ifmedia_sts;\n\nvoid sf_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct sf_softc\t\t*sc;\n\tstruct mii_data\t\t*mii;\n\n\tsc = ifp->if_softc;\n\tmii = &sc->sc_mii;\n\n\tmii_pollstat(mii);\n\tifmr->ifm_active = mii->mii_media_active;\n\tifmr->ifm_status = mii->mii_media_status;\n\n\treturn;\n}"
  },
  {
    "function_name": "sf_ifmedia_upd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "432-450",
    "snippet": "int sf_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct sf_softc\t\t*sc;\n\tstruct mii_data\t\t*mii;\n\n\tsc = ifp->if_softc;\n\tmii = &sc->sc_mii;\n\tsc->sf_link = 0;\n\tif (mii->mii_instance) {\n\t\tstruct mii_softc\t*miisc;\n\t\tfor (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;\n\t\t    miisc = LIST_NEXT(miisc, mii_list))\n\t\t\tmii_phy_reset(miisc);\n\t}\n\tmii_mediachg(mii);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sf_ifmedia_upd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mii_mediachg",
          "args": [
            "mii"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "mii_mediachg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "170-187",
          "snippet": "int\nmii_mediachg(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\tint rv;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list)) {\n\t\trv = (*child->mii_service)(child, mii, MII_MEDIACHG);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\nmii_mediachg(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\tint rv;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list)) {\n\t\trv = (*child->mii_service)(child, mii, MII_MEDIACHG);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mii_phy_reset",
          "args": [
            "miisc"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "mii_phy_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii_physubr.c",
          "lines": "160-182",
          "snippet": "void\nmii_phy_reset(mii)\n\tstruct mii_softc *mii;\n{\n\tint reg, i;\n\n\tif (mii->mii_flags & MIIF_NOISOLATE)\n\t\treg = BMCR_RESET;\n\telse\n\t\treg = BMCR_RESET | BMCR_ISO;\n\tPHY_WRITE(mii, MII_BMCR, reg);\n\n\t/* Wait 100ms for it to complete. */\n\tfor (i = 0; i < 100; i++) {\n\t\treg = PHY_READ(mii, MII_BMCR); \n\t\tif ((reg & BMCR_RESET) == 0)\n\t\t\tbreak;\n\t\tdelay(1000);\n\t}\n\n\tif (mii->mii_inst != 0 && ((mii->mii_flags & MIIF_NOISOLATE) == 0))\n\t\tPHY_WRITE(mii, MII_BMCR, reg | BMCR_ISO);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_phy_reset(mii)\n\tstruct mii_softc *mii;\n{\n\tint reg, i;\n\n\tif (mii->mii_flags & MIIF_NOISOLATE)\n\t\treg = BMCR_RESET;\n\telse\n\t\treg = BMCR_RESET | BMCR_ISO;\n\tPHY_WRITE(mii, MII_BMCR, reg);\n\n\t/* Wait 100ms for it to complete. */\n\tfor (i = 0; i < 100; i++) {\n\t\treg = PHY_READ(mii, MII_BMCR); \n\t\tif ((reg & BMCR_RESET) == 0)\n\t\t\tbreak;\n\t\tdelay(1000);\n\t}\n\n\tif (mii->mii_inst != 0 && ((mii->mii_flags & MIIF_NOISOLATE) == 0))\n\t\tPHY_WRITE(mii, MII_BMCR, reg | BMCR_ISO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "miisc",
            "mii_list"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&mii->mii_phys"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_ifmedia_upd;\n\nint sf_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct sf_softc\t\t*sc;\n\tstruct mii_data\t\t*mii;\n\n\tsc = ifp->if_softc;\n\tmii = &sc->sc_mii;\n\tsc->sf_link = 0;\n\tif (mii->mii_instance) {\n\t\tstruct mii_softc\t*miisc;\n\t\tfor (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;\n\t\t    miisc = LIST_NEXT(miisc, mii_list))\n\t\t\tmii_phy_reset(miisc);\n\t}\n\tmii_mediachg(mii);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "sf_setmulti",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "376-427",
    "snippet": "void sf_setmulti(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tu_int8_t\t\tdummy[] = { 0, 0, 0, 0, 0, 0 };\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* First zot all the existing filters. */\n\tfor (i = 1; i < SF_RXFILT_PERFECT_CNT; i++)\n\t\tsf_setperf(sc, i, (char *)&dummy);\n\tfor (i = SF_RXFILT_HASH_BASE;\n\t    i < (SF_RXFILT_HASH_MAX + 1); i += 4)\n\t\tcsr_write_4(sc, i, 0);\n\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_ALLMULTI);\n\n\t/* Now program new ones. */\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_ALLMULTI);\n\t} else {\n\t\ti = 1;\n\t\t/* First find the tail of the list. */\n\t\tETHER_FIRST_MULTI(step, ac, enm);\n\n\t\t/* Now traverse the list backwards. */\n\t\twhile (enm != NULL) {\n\t\t\t/* if (enm->enm_addrlo->sa_family != AF_LINK)\n\t\t\t\tcontinue; */\n\t\t\t/*\n\t\t\t * Program the first 15 multicast groups\n\t\t\t * into the perfect filter. For all others,\n\t\t\t * use the hash table.\n\t\t\t */\n\t\t\tif (i < SF_RXFILT_PERFECT_CNT) {\n\t\t\t\tsf_setperf(sc, i,\n\t\t\tLLADDR((struct sockaddr_dl *)enm->enm_addrlo));\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsf_sethash(sc,\n\t\t\t    LLADDR((struct sockaddr_dl *)enm->enm_addrlo), 0);\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sf_setmulti",
      "int sf_setperf",
      "int sf_sethash",
      "void csr_write_4"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sf_sethash",
          "args": [
            "sc",
            "LLADDR((struct sockaddr_dl *)enm->enm_addrlo)",
            "0"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "sf_sethash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "273-294",
          "snippet": "int sf_sethash(sc, mac, prio)\n\tstruct sf_softc\t\t*sc;\n\tcaddr_t\t\t\tmac;\n\tint\t\t\tprio;\n{\n\tu_int32_t\t\th = 0;\n\n\tif (mac == NULL)\n\t\treturn(EINVAL);\n\n\th = sf_calchash(mac);\n\n\tif (prio) {\n\t\tSF_SETBIT(sc, SF_RXFILT_HASH_BASE + SF_RXFILT_HASH_PRIOOFF +\n\t\t    (SF_RXFILT_HASH_SKIP * (h >> 4)), (1 << (h & 0xF)));\n\t} else {\n\t\tSF_SETBIT(sc, SF_RXFILT_HASH_BASE + SF_RXFILT_HASH_ADDROFF +\n\t\t    (SF_RXFILT_HASH_SKIP * (h >> 4)), (1 << (h & 0xF)));\n\t}\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int sf_sethash",
            "u_int32_t sf_calchash"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_sethash;\nu_int32_t sf_calchash;\n\nint sf_sethash(sc, mac, prio)\n\tstruct sf_softc\t\t*sc;\n\tcaddr_t\t\t\tmac;\n\tint\t\t\tprio;\n{\n\tu_int32_t\t\th = 0;\n\n\tif (mac == NULL)\n\t\treturn(EINVAL);\n\n\th = sf_calchash(mac);\n\n\tif (prio) {\n\t\tSF_SETBIT(sc, SF_RXFILT_HASH_BASE + SF_RXFILT_HASH_PRIOOFF +\n\t\t    (SF_RXFILT_HASH_SKIP * (h >> 4)), (1 << (h & 0xF)));\n\t} else {\n\t\tSF_SETBIT(sc, SF_RXFILT_HASH_BASE + SF_RXFILT_HASH_ADDROFF +\n\t\t    (SF_RXFILT_HASH_SKIP * (h >> 4)), (1 << (h & 0xF)));\n\t}\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "(struct sockaddr_dl *)enm->enm_addrlo"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sf_setperf",
          "args": [
            "sc",
            "i",
            "LLADDR((struct sockaddr_dl *)enm->enm_addrlo)"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "sf_setperf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "243-266",
          "snippet": "int sf_setperf(sc, idx, mac)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\tidx;\n\tcaddr_t\t\t\tmac;\n{\n\tu_int16_t\t\t*p;\n\n\tif (idx < 0 || idx > SF_RXFILT_PERFECT_CNT)\n\t\treturn(EINVAL);\n\n\tif (mac == NULL)\n\t\treturn(EINVAL);\n\n\tp = (u_int16_t *)mac;\n\n\tcsr_write_4(sc, SF_RXFILT_PERFECT_BASE +\n\t    (idx * SF_RXFILT_PERFECT_SKIP), htons(p[2]));\n\tcsr_write_4(sc, SF_RXFILT_PERFECT_BASE +\n\t    (idx * SF_RXFILT_PERFECT_SKIP) + 4, htons(p[1]));\n\tcsr_write_4(sc, SF_RXFILT_PERFECT_BASE +\n\t    (idx * SF_RXFILT_PERFECT_SKIP) + 8, htons(p[0]));\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int sf_setperf",
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_setperf;\nvoid csr_write_4;\n\nint sf_setperf(sc, idx, mac)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\tidx;\n\tcaddr_t\t\t\tmac;\n{\n\tu_int16_t\t\t*p;\n\n\tif (idx < 0 || idx > SF_RXFILT_PERFECT_CNT)\n\t\treturn(EINVAL);\n\n\tif (mac == NULL)\n\t\treturn(EINVAL);\n\n\tp = (u_int16_t *)mac;\n\n\tcsr_write_4(sc, SF_RXFILT_PERFECT_BASE +\n\t    (idx * SF_RXFILT_PERFECT_SKIP), htons(p[2]));\n\tcsr_write_4(sc, SF_RXFILT_PERFECT_BASE +\n\t    (idx * SF_RXFILT_PERFECT_SKIP) + 4, htons(p[1]));\n\tcsr_write_4(sc, SF_RXFILT_PERFECT_BASE +\n\t    (idx * SF_RXFILT_PERFECT_SKIP) + 8, htons(p[0]));\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "(struct sockaddr_dl *)enm->enm_addrlo"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "ac",
            "enm"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_SETBIT",
          "args": [
            "sc",
            "SF_RXFILT",
            "SF_RXFILT_ALLMULTI"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_CLRBIT",
          "args": [
            "sc",
            "SF_RXFILT",
            "SF_RXFILT_ALLMULTI"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csr_write_4",
          "args": [
            "sc",
            "i",
            "0"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "csr_write_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "199-211",
          "snippet": "void csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nvoid csr_write_4;\n\nvoid csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_setmulti;\nint sf_setperf;\nint sf_sethash;\nvoid csr_write_4;\n\nvoid sf_setmulti(sc)\n\tstruct sf_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tu_int8_t\t\tdummy[] = { 0, 0, 0, 0, 0, 0 };\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* First zot all the existing filters. */\n\tfor (i = 1; i < SF_RXFILT_PERFECT_CNT; i++)\n\t\tsf_setperf(sc, i, (char *)&dummy);\n\tfor (i = SF_RXFILT_HASH_BASE;\n\t    i < (SF_RXFILT_HASH_MAX + 1); i += 4)\n\t\tcsr_write_4(sc, i, 0);\n\tSF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_ALLMULTI);\n\n\t/* Now program new ones. */\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tSF_SETBIT(sc, SF_RXFILT, SF_RXFILT_ALLMULTI);\n\t} else {\n\t\ti = 1;\n\t\t/* First find the tail of the list. */\n\t\tETHER_FIRST_MULTI(step, ac, enm);\n\n\t\t/* Now traverse the list backwards. */\n\t\twhile (enm != NULL) {\n\t\t\t/* if (enm->enm_addrlo->sa_family != AF_LINK)\n\t\t\t\tcontinue; */\n\t\t\t/*\n\t\t\t * Program the first 15 multicast groups\n\t\t\t * into the perfect filter. For all others,\n\t\t\t * use the hash table.\n\t\t\t */\n\t\t\tif (i < SF_RXFILT_PERFECT_CNT) {\n\t\t\t\tsf_setperf(sc, i,\n\t\t\tLLADDR((struct sockaddr_dl *)enm->enm_addrlo));\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsf_sethash(sc,\n\t\t\t    LLADDR((struct sockaddr_dl *)enm->enm_addrlo), 0);\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "sf_miibus_statchg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "357-374",
    "snippet": "void sf_miibus_statchg(self)\n\tstruct device\t\t*self;\n{\n\tstruct sf_softc\t\t*sc = (struct sf_softc *)self;\n\tstruct mii_data\t\t*mii;\n\n\tmii = &sc->sc_mii;\n\n\tif ((mii->mii_media_active & IFM_GMASK) == IFM_FDX) {\n\t\tSF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_FULLDUPLEX);\n\t\tcsr_write_4(sc, SF_BKTOBKIPG, SF_IPGT_FDX);\n\t} else {\n\t\tSF_CLRBIT(sc, SF_MACCFG_1, SF_MACCFG1_FULLDUPLEX);\n\t\tcsr_write_4(sc, SF_BKTOBKIPG, SF_IPGT_HDX);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sf_miibus_statchg",
      "void csr_write_4"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "csr_write_4",
          "args": [
            "sc",
            "SF_BKTOBKIPG",
            "SF_IPGT_HDX"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "csr_write_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "199-211",
          "snippet": "void csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nvoid csr_write_4;\n\nvoid csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SF_CLRBIT",
          "args": [
            "sc",
            "SF_MACCFG_1",
            "SF_MACCFG1_FULLDUPLEX"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_SETBIT",
          "args": [
            "sc",
            "SF_MACCFG_1",
            "SF_MACCFG1_FULLDUPLEX"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_miibus_statchg;\nvoid csr_write_4;\n\nvoid sf_miibus_statchg(self)\n\tstruct device\t\t*self;\n{\n\tstruct sf_softc\t\t*sc = (struct sf_softc *)self;\n\tstruct mii_data\t\t*mii;\n\n\tmii = &sc->sc_mii;\n\n\tif ((mii->mii_media_active & IFM_GMASK) == IFM_FDX) {\n\t\tSF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_FULLDUPLEX);\n\t\tcsr_write_4(sc, SF_BKTOBKIPG, SF_IPGT_FDX);\n\t} else {\n\t\tSF_CLRBIT(sc, SF_MACCFG_1, SF_MACCFG1_FULLDUPLEX);\n\t\tcsr_write_4(sc, SF_BKTOBKIPG, SF_IPGT_HDX);\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "sf_miibus_writereg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "338-355",
    "snippet": "void sf_miibus_writereg(self, phy, reg, val)\n\tstruct device\t\t*self;\n\tint phy, reg, val;\n{\n\tstruct sf_softc\t\t*sc = (struct sf_softc *)self;\n\tint\t\t\ti;\n\tint\t\t\tbusy;\n\n\tcsr_write_4(sc, SF_PHY_REG(phy, reg), val);\n\n\tfor (i = 0; i < SF_TIMEOUT; i++) {\n\t\tbusy = csr_read_4(sc, SF_PHY_REG(phy, reg));\n\t\tif (!(busy & SF_MII_BUSY))\n\t\t\tbreak;\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sf_miibus_writereg",
      "u_int32_t csr_read_4",
      "void csr_write_4"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "csr_read_4",
          "args": [
            "sc",
            "SF_PHY_REG(phy, reg)"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "csr_read_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "171-185",
          "snippet": "u_int32_t csr_read_4(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int32_t\t\tval;\n\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tval = CSR_READ_4(sc, SF_INDIRECTIO_DATA);\n#else\n\tval = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));\n#endif\n\n\treturn(val);\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "u_int32_t csr_read_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nu_int32_t csr_read_4;\n\nu_int32_t csr_read_4(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int32_t\t\tval;\n\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tval = CSR_READ_4(sc, SF_INDIRECTIO_DATA);\n#else\n\tval = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));\n#endif\n\n\treturn(val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SF_PHY_REG",
          "args": [
            "phy",
            "reg"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csr_write_4",
          "args": [
            "sc",
            "SF_PHY_REG(phy, reg)",
            "val"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "csr_write_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "199-211",
          "snippet": "void csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nvoid csr_write_4;\n\nvoid csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SF_PHY_REG",
          "args": [
            "phy",
            "reg"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sf_miibus_writereg;\nu_int32_t csr_read_4;\nvoid csr_write_4;\n\nvoid sf_miibus_writereg(self, phy, reg, val)\n\tstruct device\t\t*self;\n\tint phy, reg, val;\n{\n\tstruct sf_softc\t\t*sc = (struct sf_softc *)self;\n\tint\t\t\ti;\n\tint\t\t\tbusy;\n\n\tcsr_write_4(sc, SF_PHY_REG(phy, reg), val);\n\n\tfor (i = 0; i < SF_TIMEOUT; i++) {\n\t\tbusy = csr_read_4(sc, SF_PHY_REG(phy, reg));\n\t\tif (!(busy & SF_MII_BUSY))\n\t\t\tbreak;\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "sf_miibus_readreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "315-336",
    "snippet": "int sf_miibus_readreg(self, phy, reg)\n\tstruct device\t\t*self;\n\tint\t\t\tphy, reg;\n{\n\tstruct sf_softc\t\t*sc = (struct sf_softc *)self;\n\tint\t\t\ti;\n\tu_int32_t\t\tval = 0;\n\n\tfor (i = 0; i < SF_TIMEOUT; i++) {\n\t\tval = csr_read_4(sc, SF_PHY_REG(phy, reg));\n\t\tif (val & SF_MII_DATAVALID)\n\t\t\tbreak;\n\t}\n\n\tif (i == SF_TIMEOUT)\n\t\treturn(0);\n\n\tif ((val & 0x0000FFFF) == 0xFFFF)\n\t\treturn(0);\n\n\treturn(val & 0x0000FFFF);\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sf_miibus_readreg",
      "u_int32_t csr_read_4"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "csr_read_4",
          "args": [
            "sc",
            "SF_PHY_REG(phy, reg)"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "csr_read_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "171-185",
          "snippet": "u_int32_t csr_read_4(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int32_t\t\tval;\n\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tval = CSR_READ_4(sc, SF_INDIRECTIO_DATA);\n#else\n\tval = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));\n#endif\n\n\treturn(val);\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "u_int32_t csr_read_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nu_int32_t csr_read_4;\n\nu_int32_t csr_read_4(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int32_t\t\tval;\n\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tval = CSR_READ_4(sc, SF_INDIRECTIO_DATA);\n#else\n\tval = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));\n#endif\n\n\treturn(val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SF_PHY_REG",
          "args": [
            "phy",
            "reg"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_miibus_readreg;\nu_int32_t csr_read_4;\n\nint sf_miibus_readreg(self, phy, reg)\n\tstruct device\t\t*self;\n\tint\t\t\tphy, reg;\n{\n\tstruct sf_softc\t\t*sc = (struct sf_softc *)self;\n\tint\t\t\ti;\n\tu_int32_t\t\tval = 0;\n\n\tfor (i = 0; i < SF_TIMEOUT; i++) {\n\t\tval = csr_read_4(sc, SF_PHY_REG(phy, reg));\n\t\tif (val & SF_MII_DATAVALID)\n\t\t\tbreak;\n\t}\n\n\tif (i == SF_TIMEOUT)\n\t\treturn(0);\n\n\tif ((val & 0x0000FFFF) == 0xFFFF)\n\t\treturn(0);\n\n\treturn(val & 0x0000FFFF);\n}"
  },
  {
    "function_name": "sf_setvlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "300-312",
    "snippet": "int sf_setvlan(sc, idx, vlan)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\tidx;\n\tu_int32_t\t\tvlan;\n{\n\tif (idx < 0 || idx >> SF_RXFILT_HASH_CNT)\n\t\treturn(EINVAL);\n\n\tcsr_write_4(sc, SF_RXFILT_HASH_BASE +\n\t    (idx * SF_RXFILT_HASH_SKIP) + SF_RXFILT_HASH_VLANOFF, vlan);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void csr_write_4"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "csr_write_4",
          "args": [
            "sc",
            "SF_RXFILT_HASH_BASE +\n\t    (idx * SF_RXFILT_HASH_SKIP) + SF_RXFILT_HASH_VLANOFF",
            "vlan"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "csr_write_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "199-211",
          "snippet": "void csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nvoid csr_write_4;\n\nvoid csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid csr_write_4;\n\nint sf_setvlan(sc, idx, vlan)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\tidx;\n\tu_int32_t\t\tvlan;\n{\n\tif (idx < 0 || idx >> SF_RXFILT_HASH_CNT)\n\t\treturn(EINVAL);\n\n\tcsr_write_4(sc, SF_RXFILT_HASH_BASE +\n\t    (idx * SF_RXFILT_HASH_SKIP) + SF_RXFILT_HASH_VLANOFF, vlan);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "sf_sethash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "273-294",
    "snippet": "int sf_sethash(sc, mac, prio)\n\tstruct sf_softc\t\t*sc;\n\tcaddr_t\t\t\tmac;\n\tint\t\t\tprio;\n{\n\tu_int32_t\t\th = 0;\n\n\tif (mac == NULL)\n\t\treturn(EINVAL);\n\n\th = sf_calchash(mac);\n\n\tif (prio) {\n\t\tSF_SETBIT(sc, SF_RXFILT_HASH_BASE + SF_RXFILT_HASH_PRIOOFF +\n\t\t    (SF_RXFILT_HASH_SKIP * (h >> 4)), (1 << (h & 0xF)));\n\t} else {\n\t\tSF_SETBIT(sc, SF_RXFILT_HASH_BASE + SF_RXFILT_HASH_ADDROFF +\n\t\t    (SF_RXFILT_HASH_SKIP * (h >> 4)), (1 << (h & 0xF)));\n\t}\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sf_sethash",
      "u_int32_t sf_calchash"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SF_SETBIT",
          "args": [
            "sc",
            "SF_RXFILT_HASH_BASE + SF_RXFILT_HASH_ADDROFF +\n\t\t    (SF_RXFILT_HASH_SKIP * (h >> 4))",
            "(1 << (h & 0xF))"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF_SETBIT",
          "args": [
            "sc",
            "SF_RXFILT_HASH_BASE + SF_RXFILT_HASH_PRIOOFF +\n\t\t    (SF_RXFILT_HASH_SKIP * (h >> 4))",
            "(1 << (h & 0xF))"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sf_calchash",
          "args": [
            "mac"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "sf_calchash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "213-236",
          "snippet": "u_int32_t sf_calchash(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn(crc >> 23 & 0x1FF);\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int32_t sf_calchash"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t sf_calchash;\n\nu_int32_t sf_calchash(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn(crc >> 23 & 0x1FF);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_sethash;\nu_int32_t sf_calchash;\n\nint sf_sethash(sc, mac, prio)\n\tstruct sf_softc\t\t*sc;\n\tcaddr_t\t\t\tmac;\n\tint\t\t\tprio;\n{\n\tu_int32_t\t\th = 0;\n\n\tif (mac == NULL)\n\t\treturn(EINVAL);\n\n\th = sf_calchash(mac);\n\n\tif (prio) {\n\t\tSF_SETBIT(sc, SF_RXFILT_HASH_BASE + SF_RXFILT_HASH_PRIOOFF +\n\t\t    (SF_RXFILT_HASH_SKIP * (h >> 4)), (1 << (h & 0xF)));\n\t} else {\n\t\tSF_SETBIT(sc, SF_RXFILT_HASH_BASE + SF_RXFILT_HASH_ADDROFF +\n\t\t    (SF_RXFILT_HASH_SKIP * (h >> 4)), (1 << (h & 0xF)));\n\t}\n\n\treturn(0);\n}"
  },
  {
    "function_name": "sf_setperf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "243-266",
    "snippet": "int sf_setperf(sc, idx, mac)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\tidx;\n\tcaddr_t\t\t\tmac;\n{\n\tu_int16_t\t\t*p;\n\n\tif (idx < 0 || idx > SF_RXFILT_PERFECT_CNT)\n\t\treturn(EINVAL);\n\n\tif (mac == NULL)\n\t\treturn(EINVAL);\n\n\tp = (u_int16_t *)mac;\n\n\tcsr_write_4(sc, SF_RXFILT_PERFECT_BASE +\n\t    (idx * SF_RXFILT_PERFECT_SKIP), htons(p[2]));\n\tcsr_write_4(sc, SF_RXFILT_PERFECT_BASE +\n\t    (idx * SF_RXFILT_PERFECT_SKIP) + 4, htons(p[1]));\n\tcsr_write_4(sc, SF_RXFILT_PERFECT_BASE +\n\t    (idx * SF_RXFILT_PERFECT_SKIP) + 8, htons(p[0]));\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sf_setperf",
      "void csr_write_4"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "csr_write_4",
          "args": [
            "sc",
            "SF_RXFILT_PERFECT_BASE +\n\t    (idx * SF_RXFILT_PERFECT_SKIP) + 8",
            "htons(p[0])"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "csr_write_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "199-211",
          "snippet": "void csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "void csr_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nvoid csr_write_4;\n\nvoid csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "p[0]"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "p[1]"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "p[2]"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sf_setperf;\nvoid csr_write_4;\n\nint sf_setperf(sc, idx, mac)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\tidx;\n\tcaddr_t\t\t\tmac;\n{\n\tu_int16_t\t\t*p;\n\n\tif (idx < 0 || idx > SF_RXFILT_PERFECT_CNT)\n\t\treturn(EINVAL);\n\n\tif (mac == NULL)\n\t\treturn(EINVAL);\n\n\tp = (u_int16_t *)mac;\n\n\tcsr_write_4(sc, SF_RXFILT_PERFECT_BASE +\n\t    (idx * SF_RXFILT_PERFECT_SKIP), htons(p[2]));\n\tcsr_write_4(sc, SF_RXFILT_PERFECT_BASE +\n\t    (idx * SF_RXFILT_PERFECT_SKIP) + 4, htons(p[1]));\n\tcsr_write_4(sc, SF_RXFILT_PERFECT_BASE +\n\t    (idx * SF_RXFILT_PERFECT_SKIP) + 8, htons(p[0]));\n\n\treturn(0);\n}"
  },
  {
    "function_name": "sf_calchash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "213-236",
    "snippet": "u_int32_t sf_calchash(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn(crc >> 23 & 0x1FF);\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int32_t sf_calchash"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t sf_calchash;\n\nu_int32_t sf_calchash(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn(crc >> 23 & 0x1FF);\n}"
  },
  {
    "function_name": "csr_write_4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "199-211",
    "snippet": "void csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define SF_USEIOSPACE"
    ],
    "globals_used": [
      "void csr_write_4"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "(reg + SF_RMAP_INTREG_BASE)",
            "val"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SF_INDIRECTIO_DATA",
            "val"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SF_INDIRECTIO_ADDR",
            "reg + SF_RMAP_INTREG_BASE"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nvoid csr_write_4;\n\nvoid csr_write_4(sc, reg, val)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);\n#else\n\tCSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);\n#endif\n\treturn;\n}"
  },
  {
    "function_name": "sf_read_eeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "187-197",
    "snippet": "u_int8_t sf_read_eeprom(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int8_t\t\tval;\n\n\tval = (csr_read_4(sc, SF_EEADDR_BASE +\n\t    (reg & 0xFFFFFFFC)) >> (8 * (reg & 3))) & 0xFF;\n\n\treturn(val);\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int8_t sf_read_eeprom",
      "u_int32_t csr_read_4"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "csr_read_4",
          "args": [
            "sc",
            "SF_EEADDR_BASE +\n\t    (reg & 0xFFFFFFFC)"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "csr_read_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
          "lines": "171-185",
          "snippet": "u_int32_t csr_read_4(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int32_t\t\tval;\n\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tval = CSR_READ_4(sc, SF_INDIRECTIO_DATA);\n#else\n\tval = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));\n#endif\n\n\treturn(val);\n}",
          "includes": [
            "#include <dev/pci/if_sfreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <sys/device.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SF_USEIOSPACE"
          ],
          "globals_used": [
            "u_int32_t csr_read_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nu_int32_t csr_read_4;\n\nu_int32_t csr_read_4(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int32_t\t\tval;\n\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tval = CSR_READ_4(sc, SF_INDIRECTIO_DATA);\n#else\n\tval = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));\n#endif\n\n\treturn(val);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t sf_read_eeprom;\nu_int32_t csr_read_4;\n\nu_int8_t sf_read_eeprom(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int8_t\t\tval;\n\n\tval = (csr_read_4(sc, SF_EEADDR_BASE +\n\t    (reg & 0xFFFFFFFC)) >> (8 * (reg & 3))) & 0xFF;\n\n\treturn(val);\n}"
  },
  {
    "function_name": "csr_read_4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sf.c",
    "lines": "171-185",
    "snippet": "u_int32_t csr_read_4(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int32_t\t\tval;\n\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tval = CSR_READ_4(sc, SF_INDIRECTIO_DATA);\n#else\n\tval = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));\n#endif\n\n\treturn(val);\n}",
    "includes": [
      "#include <dev/pci/if_sfreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <sys/device.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define SF_USEIOSPACE"
    ],
    "globals_used": [
      "u_int32_t csr_read_4"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "(reg + SF_RMAP_INTREG_BASE)"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "SF_INDIRECTIO_DATA"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SF_INDIRECTIO_ADDR",
            "reg + SF_RMAP_INTREG_BASE"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_sfreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <sys/device.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SF_USEIOSPACE\n\nu_int32_t csr_read_4;\n\nu_int32_t csr_read_4(sc, reg)\n\tstruct sf_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tu_int32_t\t\tval;\n\n#ifdef SF_USEIOSPACE\n\tCSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);\n\tval = CSR_READ_4(sc, SF_INDIRECTIO_DATA);\n#else\n\tval = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));\n#endif\n\n\treturn(val);\n}"
  }
]