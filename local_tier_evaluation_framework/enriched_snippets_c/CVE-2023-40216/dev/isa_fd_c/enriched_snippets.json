[
  {
    "function_name": "fdformat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
    "lines": "1037-1096",
    "snippet": "int\nfdformat(dev, finfo, p)\n        dev_t dev;\n        struct fd_formb *finfo;\n        struct proc *p;\n{\n        int rv = 0, s;\n\tstruct fd_softc *fd = fd_cd.cd_devs[FDUNIT(dev)];\n\tstruct fd_type *type = fd->sc_type;\n        struct buf *bp;\n\tint fd_bsize = 128 << fd->sc_type->secsize;\n\n        /* set up a buffer header for fdstrategy() */\n        bp = (struct buf *)malloc(sizeof(struct buf), M_TEMP, M_NOWAIT);\n        if(bp == 0)\n                return ENOBUFS;\n        bzero((void *)bp, sizeof(struct buf));\n        bp->b_flags = B_BUSY | B_PHYS | B_FORMAT;\n        bp->b_proc = p;\n        bp->b_dev = dev;\n\n        /*\n         * calculate a fake blkno, so fdstrategy() would initiate a\n         * seek to the requested cylinder\n         */\n        bp->b_blkno = (finfo->cyl * (type->sectrac * type->heads)\n                + finfo->head * type->sectrac) * fd_bsize / DEV_BSIZE;\n\n        bp->b_bcount = sizeof(struct fd_idfield_data) * finfo->fd_formb_nsecs;\n        bp->b_data = (caddr_t)finfo;\n        \n#ifdef DEBUG\n\tprintf(\"fdformat: blkno %x count %x\\n\", bp->b_blkno, bp->b_bcount);\n#endif\n\n        /* now do the format */\n        fdstrategy(bp);\n\n        /* ...and wait for it to complete */\n        s = splbio();\n        while(!(bp->b_flags & B_DONE))\n        {\n                rv = tsleep((caddr_t)bp, PRIBIO, \"fdform\", 0);\n                if(rv == EWOULDBLOCK)\n\t\t    /*break*/;\n        }\n        splx(s);\n        \n        if(rv == EWOULDBLOCK) {\n                /* timed out */\n                rv = EIO;\n\t\t/* XXX what to do to the buf? it will eventually fall\n\t\t   out as finished, but ... ?*/\n\t\t/*biodone(bp);*/\n\t}\n        if(bp->b_flags & B_ERROR)\n                rv = bp->b_error;\n        free(bp, M_TEMP);\n        return rv;\n}",
    "includes": [
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tcyl\tfdc->sc_status[1]",
      "#define B_FORMAT B_XXX"
    ],
    "globals_used": [
      "struct cfdriver fd_cd = {\n\tNULL, \"fd\", DV_DISK\n};",
      "void fdstrategy",
      "int fdformat",
      "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;",
      "dev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "bp",
            "M_TEMP"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "sb_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/sbdsp.c",
          "lines": "2202-2209",
          "snippet": "void\nsb_free(addr, ptr, pool)\n\tvoid *addr;\n\tvoid *ptr;\n\tint pool;\n{\n\tisa_free(ptr, pool);\n}",
          "includes": [
            "#include <dev/isa/sbdspvar.h>",
            "#include <dev/isa/sbreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void *\nsb_malloc(addr, size, pool, flags)\n\tvoid *addr;",
            "int pool;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/sbdspvar.h>\n#include <dev/isa/sbreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nvoid *\nsb_malloc(addr, size, pool, flags)\n\tvoid *addr;\nint pool;\n\nvoid\nsb_free(addr, ptr, pool)\n\tvoid *addr;\n\tvoid *ptr;\n\tint pool;\n{\n\tisa_free(ptr, pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "(caddr_t)bp",
            "PRIBIO",
            "\"fdform\"",
            "0"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdstrategy",
          "args": [
            "bp"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "fdstrategy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
          "lines": "326-396",
          "snippet": "void\nfdstrategy(bp)\n\tregister struct buf *bp;\t/* IO operation to perform */\n{\n\tstruct fd_softc *fd = fd_cd.cd_devs[FDUNIT(bp->b_dev)];\n\tint sz;\n \tint s;\n\tint fd_bsize = 128 << fd->sc_type->secsize;\n\tint bf = fd_bsize / DEV_BSIZE;\n\n\t/* Valid unit, controller, and request? */\n\tif (bp->b_blkno < 0 ||\n\t    (((bp->b_blkno % bf) != 0 ||\n\t      (bp->b_bcount % fd_bsize) != 0) &&\n\t     (bp->b_flags & B_FORMAT) == 0)) {\n\t\tbp->b_error = EINVAL;\n\t\tgoto bad;\n\t}\n\n\t/* If it's a null transfer, return immediately. */\n\tif (bp->b_bcount == 0)\n\t\tgoto done;\n\n\tsz = howmany(bp->b_bcount, DEV_BSIZE);\n\n\tif (bp->b_blkno + sz > fd->sc_type->size * bf) {\n\t\tsz = fd->sc_type->size * bf - bp->b_blkno;\n\t\tif (sz == 0)\n\t\t\t/* If exactly at end of disk, return EOF. */\n\t\t\tgoto done;\n\t\tif (sz < 0) {\n\t\t\t/* If past end of disk, return EINVAL. */\n\t\t\tbp->b_error = EINVAL;\n\t\t\tgoto bad;\n\t\t}\n\t\t/* Otherwise, truncate request. */\n\t\tbp->b_bcount = sz << DEV_BSHIFT;\n\t}\n\n \tbp->b_cylin = bp->b_blkno / (fd_bsize / DEV_BSIZE) / fd->sc_type->seccyl;\n\n#ifdef FD_DEBUG\n\tprintf(\"fdstrategy: b_blkno %d b_bcount %d blkno %d cylin %d sz %d\\n\",\n\t    bp->b_blkno, bp->b_bcount, fd->sc_blkno, bp->b_cylin, sz);\n#endif\n\n\t/* Queue transfer on drive, activate drive and controller if idle. */\n\ts = splbio();\n\tdisksort(&fd->sc_q, bp);\n\tuntimeout(fd_motor_off, fd); /* a good idea */\n\tif (!fd->sc_q.b_active)\n\t\tfdstart(fd);\n#ifdef DIAGNOSTIC\n\telse {\n\t\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\t\tif (fdc->sc_state == DEVIDLE) {\n\t\t\tprintf(\"fdstrategy: controller inactive\\n\");\n\t\t\tfdcstart(fdc);\n\t\t}\n\t}\n#endif\n\tsplx(s);\n\treturn;\n\nbad:\n\tbp->b_flags |= B_ERROR;\ndone:\n\t/* Toss transfer; we're done early. */\n\tbp->b_resid = bp->b_bcount;\n\tbiodone(bp);\n}",
          "includes": [
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define b_cylin b_resid",
            "#define B_FORMAT B_XXX"
          ],
          "globals_used": [
            "struct cfdriver fd_cd = {\n\tNULL, \"fd\", DV_DISK\n};",
            "void fdstrategy",
            "void fdstart",
            "void fd_motor_off",
            "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
            "int nvraminfo, drive;",
            "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define b_cylin b_resid\n#define B_FORMAT B_XXX\n\nstruct cfdriver fd_cd = {\n\tNULL, \"fd\", DV_DISK\n};\nvoid fdstrategy;\nvoid fdstart;\nvoid fd_motor_off;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\nint nvraminfo, drive;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nvoid\nfdstrategy(bp)\n\tregister struct buf *bp;\t/* IO operation to perform */\n{\n\tstruct fd_softc *fd = fd_cd.cd_devs[FDUNIT(bp->b_dev)];\n\tint sz;\n \tint s;\n\tint fd_bsize = 128 << fd->sc_type->secsize;\n\tint bf = fd_bsize / DEV_BSIZE;\n\n\t/* Valid unit, controller, and request? */\n\tif (bp->b_blkno < 0 ||\n\t    (((bp->b_blkno % bf) != 0 ||\n\t      (bp->b_bcount % fd_bsize) != 0) &&\n\t     (bp->b_flags & B_FORMAT) == 0)) {\n\t\tbp->b_error = EINVAL;\n\t\tgoto bad;\n\t}\n\n\t/* If it's a null transfer, return immediately. */\n\tif (bp->b_bcount == 0)\n\t\tgoto done;\n\n\tsz = howmany(bp->b_bcount, DEV_BSIZE);\n\n\tif (bp->b_blkno + sz > fd->sc_type->size * bf) {\n\t\tsz = fd->sc_type->size * bf - bp->b_blkno;\n\t\tif (sz == 0)\n\t\t\t/* If exactly at end of disk, return EOF. */\n\t\t\tgoto done;\n\t\tif (sz < 0) {\n\t\t\t/* If past end of disk, return EINVAL. */\n\t\t\tbp->b_error = EINVAL;\n\t\t\tgoto bad;\n\t\t}\n\t\t/* Otherwise, truncate request. */\n\t\tbp->b_bcount = sz << DEV_BSHIFT;\n\t}\n\n \tbp->b_cylin = bp->b_blkno / (fd_bsize / DEV_BSIZE) / fd->sc_type->seccyl;\n\n#ifdef FD_DEBUG\n\tprintf(\"fdstrategy: b_blkno %d b_bcount %d blkno %d cylin %d sz %d\\n\",\n\t    bp->b_blkno, bp->b_bcount, fd->sc_blkno, bp->b_cylin, sz);\n#endif\n\n\t/* Queue transfer on drive, activate drive and controller if idle. */\n\ts = splbio();\n\tdisksort(&fd->sc_q, bp);\n\tuntimeout(fd_motor_off, fd); /* a good idea */\n\tif (!fd->sc_q.b_active)\n\t\tfdstart(fd);\n#ifdef DIAGNOSTIC\n\telse {\n\t\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\t\tif (fdc->sc_state == DEVIDLE) {\n\t\t\tprintf(\"fdstrategy: controller inactive\\n\");\n\t\t\tfdcstart(fdc);\n\t\t}\n\t}\n#endif\n\tsplx(s);\n\treturn;\n\nbad:\n\tbp->b_flags |= B_ERROR;\ndone:\n\t/* Toss transfer; we're done early. */\n\tbp->b_resid = bp->b_bcount;\n\tbiodone(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"fdformat: blkno %x count %x\\n\"",
            "bp->b_blkno",
            "bp->b_bcount"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(void *)bp",
            "sizeof(struct buf)"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct buf)",
            "M_TEMP",
            "M_NOWAIT"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FDUNIT",
          "args": [
            "dev"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tcyl\tfdc->sc_status[1]\n#define B_FORMAT B_XXX\n\nstruct cfdriver fd_cd = {\n\tNULL, \"fd\", DV_DISK\n};\nvoid fdstrategy;\nint fdformat;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\ndev_t dev;\n\nint\nfdformat(dev, finfo, p)\n        dev_t dev;\n        struct fd_formb *finfo;\n        struct proc *p;\n{\n        int rv = 0, s;\n\tstruct fd_softc *fd = fd_cd.cd_devs[FDUNIT(dev)];\n\tstruct fd_type *type = fd->sc_type;\n        struct buf *bp;\n\tint fd_bsize = 128 << fd->sc_type->secsize;\n\n        /* set up a buffer header for fdstrategy() */\n        bp = (struct buf *)malloc(sizeof(struct buf), M_TEMP, M_NOWAIT);\n        if(bp == 0)\n                return ENOBUFS;\n        bzero((void *)bp, sizeof(struct buf));\n        bp->b_flags = B_BUSY | B_PHYS | B_FORMAT;\n        bp->b_proc = p;\n        bp->b_dev = dev;\n\n        /*\n         * calculate a fake blkno, so fdstrategy() would initiate a\n         * seek to the requested cylinder\n         */\n        bp->b_blkno = (finfo->cyl * (type->sectrac * type->heads)\n                + finfo->head * type->sectrac) * fd_bsize / DEV_BSIZE;\n\n        bp->b_bcount = sizeof(struct fd_idfield_data) * finfo->fd_formb_nsecs;\n        bp->b_data = (caddr_t)finfo;\n        \n#ifdef DEBUG\n\tprintf(\"fdformat: blkno %x count %x\\n\", bp->b_blkno, bp->b_bcount);\n#endif\n\n        /* now do the format */\n        fdstrategy(bp);\n\n        /* ...and wait for it to complete */\n        s = splbio();\n        while(!(bp->b_flags & B_DONE))\n        {\n                rv = tsleep((caddr_t)bp, PRIBIO, \"fdform\", 0);\n                if(rv == EWOULDBLOCK)\n\t\t    /*break*/;\n        }\n        splx(s);\n        \n        if(rv == EWOULDBLOCK) {\n                /* timed out */\n                rv = EIO;\n\t\t/* XXX what to do to the buf? it will eventually fall\n\t\t   out as finished, but ... ?*/\n\t\t/*biodone(bp);*/\n\t}\n        if(bp->b_flags & B_ERROR)\n                rv = bp->b_error;\n        free(bp, M_TEMP);\n        return rv;\n}"
  },
  {
    "function_name": "fdioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
    "lines": "934-1035",
    "snippet": "int\nfdioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct fd_softc *fd = fd_cd.cd_devs[FDUNIT(dev)];\n\tstruct disklabel dl, *lp = &dl;\n\tstruct cpu_disklabel cdl;\n\tchar *errstring;\n\tint error;\n\n\tswitch (cmd) {\n\tcase MTIOCTOP:\n\t\tif (((struct mtop *)addr)->mt_op != MTOFFL)\n\t\t\treturn EIO;\n\t\treturn (0);\n\tcase DIOCGDINFO:\n\t\tbzero(lp, sizeof(*lp));\n\t\tbzero(&cdl, sizeof(struct cpu_disklabel));\n\n\t\tlp->d_secsize = 128 << fd->sc_type->secsize;\n\t\tlp->d_secpercyl = fd->sc_type->seccyl;\n\t\tlp->d_ntracks = fd->sc_type->heads;\n\t\tlp->d_nsectors = fd->sc_type->sectrac;\n\t\tlp->d_ncylinders = fd->sc_type->tracks;\n\n\t\tstrncpy(lp->d_typename, \"floppy disk\", 16);\n\t\tlp->d_type = DTYPE_FLOPPY;\n\t\tstrncpy(lp->d_packname, \"fictitious\", 16);\n\t\tlp->d_secperunit = fd->sc_type->size;\n\t\tlp->d_rpm = 300;\n\t\tlp->d_interleave = 1;\n\t\tlp->d_flags = D_REMOVABLE;\n\n\t\tlp->d_partitions[RAW_PART].p_offset = 0;\n\t\tlp->d_partitions[RAW_PART].p_size =\n\t\t    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);\n\t\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\t\tlp->d_npartitions = RAW_PART + 1;\n\n\t\tlp->d_magic = DISKMAGIC;\n\t\tlp->d_magic2 = DISKMAGIC;\n\t\tlp->d_checksum = dkcksum(lp);\n\n\t\terrstring = readdisklabel(dev, fdstrategy, lp, &cdl, 0);\n\t\tif (errstring) {\n\t\t\t/*printf(\"%s: %s\\n\", fd->sc_dev.dv_xname, errstring); */\n\t\t}\n\n\t\t*(struct disklabel *)addr = *lp;\n\t\treturn 0;\n\n\tcase DIOCWLABEL:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn EBADF;\n\t\t/* XXX do something */\n\t\treturn 0;\n\n\tcase DIOCWDINFO:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn EBADF;\n\n\t\terror = setdisklabel(lp, (struct disklabel *)addr, 0, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = writedisklabel(dev, fdstrategy, lp, NULL);\n\t\treturn error;\n\n        case FD_FORM:\n                if((flag & FWRITE) == 0)\n                        return EBADF;  /* must be opened for writing */\n                else if(((struct fd_formb *)addr)->format_version !=\n                        FD_FORMAT_VERSION)\n                        return EINVAL; /* wrong version of formatting prog */\n                else\n                        return fdformat(dev, (struct fd_formb *)addr, p);\n                break;\n\n        case FD_GTYPE:                  /* get drive type */\n                *(struct fd_type *)addr = *fd->sc_type;\n\t\treturn 0;\n\n        case FD_GOPTS:                  /* get drive options */\n                *(int *)addr = fd->sc_opts;\n                return 0;\n                \n        case FD_SOPTS:                  /* set drive options */\n                fd->sc_opts = *(int *)addr;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn ENOTTY;\n\t}\n\n#ifdef DIAGNOSTIC\n\tpanic(\"fdioctl: impossible\");\n#endif\n}",
    "includes": [
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver fd_cd = {\n\tNULL, \"fd\", DV_DISK\n};",
      "void fdstrategy",
      "int fdformat",
      "int nvraminfo, drive;",
      "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;",
      "dev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"fdioctl: impossible\""
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdformat",
          "args": [
            "dev",
            "(struct fd_formb *)addr",
            "p"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "fdformat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
          "lines": "1037-1096",
          "snippet": "int\nfdformat(dev, finfo, p)\n        dev_t dev;\n        struct fd_formb *finfo;\n        struct proc *p;\n{\n        int rv = 0, s;\n\tstruct fd_softc *fd = fd_cd.cd_devs[FDUNIT(dev)];\n\tstruct fd_type *type = fd->sc_type;\n        struct buf *bp;\n\tint fd_bsize = 128 << fd->sc_type->secsize;\n\n        /* set up a buffer header for fdstrategy() */\n        bp = (struct buf *)malloc(sizeof(struct buf), M_TEMP, M_NOWAIT);\n        if(bp == 0)\n                return ENOBUFS;\n        bzero((void *)bp, sizeof(struct buf));\n        bp->b_flags = B_BUSY | B_PHYS | B_FORMAT;\n        bp->b_proc = p;\n        bp->b_dev = dev;\n\n        /*\n         * calculate a fake blkno, so fdstrategy() would initiate a\n         * seek to the requested cylinder\n         */\n        bp->b_blkno = (finfo->cyl * (type->sectrac * type->heads)\n                + finfo->head * type->sectrac) * fd_bsize / DEV_BSIZE;\n\n        bp->b_bcount = sizeof(struct fd_idfield_data) * finfo->fd_formb_nsecs;\n        bp->b_data = (caddr_t)finfo;\n        \n#ifdef DEBUG\n\tprintf(\"fdformat: blkno %x count %x\\n\", bp->b_blkno, bp->b_bcount);\n#endif\n\n        /* now do the format */\n        fdstrategy(bp);\n\n        /* ...and wait for it to complete */\n        s = splbio();\n        while(!(bp->b_flags & B_DONE))\n        {\n                rv = tsleep((caddr_t)bp, PRIBIO, \"fdform\", 0);\n                if(rv == EWOULDBLOCK)\n\t\t    /*break*/;\n        }\n        splx(s);\n        \n        if(rv == EWOULDBLOCK) {\n                /* timed out */\n                rv = EIO;\n\t\t/* XXX what to do to the buf? it will eventually fall\n\t\t   out as finished, but ... ?*/\n\t\t/*biodone(bp);*/\n\t}\n        if(bp->b_flags & B_ERROR)\n                rv = bp->b_error;\n        free(bp, M_TEMP);\n        return rv;\n}",
          "includes": [
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tcyl\tfdc->sc_status[1]",
            "#define B_FORMAT B_XXX"
          ],
          "globals_used": [
            "struct cfdriver fd_cd = {\n\tNULL, \"fd\", DV_DISK\n};",
            "void fdstrategy",
            "int fdformat",
            "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;",
            "dev_t dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tcyl\tfdc->sc_status[1]\n#define B_FORMAT B_XXX\n\nstruct cfdriver fd_cd = {\n\tNULL, \"fd\", DV_DISK\n};\nvoid fdstrategy;\nint fdformat;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\ndev_t dev;\n\nint\nfdformat(dev, finfo, p)\n        dev_t dev;\n        struct fd_formb *finfo;\n        struct proc *p;\n{\n        int rv = 0, s;\n\tstruct fd_softc *fd = fd_cd.cd_devs[FDUNIT(dev)];\n\tstruct fd_type *type = fd->sc_type;\n        struct buf *bp;\n\tint fd_bsize = 128 << fd->sc_type->secsize;\n\n        /* set up a buffer header for fdstrategy() */\n        bp = (struct buf *)malloc(sizeof(struct buf), M_TEMP, M_NOWAIT);\n        if(bp == 0)\n                return ENOBUFS;\n        bzero((void *)bp, sizeof(struct buf));\n        bp->b_flags = B_BUSY | B_PHYS | B_FORMAT;\n        bp->b_proc = p;\n        bp->b_dev = dev;\n\n        /*\n         * calculate a fake blkno, so fdstrategy() would initiate a\n         * seek to the requested cylinder\n         */\n        bp->b_blkno = (finfo->cyl * (type->sectrac * type->heads)\n                + finfo->head * type->sectrac) * fd_bsize / DEV_BSIZE;\n\n        bp->b_bcount = sizeof(struct fd_idfield_data) * finfo->fd_formb_nsecs;\n        bp->b_data = (caddr_t)finfo;\n        \n#ifdef DEBUG\n\tprintf(\"fdformat: blkno %x count %x\\n\", bp->b_blkno, bp->b_bcount);\n#endif\n\n        /* now do the format */\n        fdstrategy(bp);\n\n        /* ...and wait for it to complete */\n        s = splbio();\n        while(!(bp->b_flags & B_DONE))\n        {\n                rv = tsleep((caddr_t)bp, PRIBIO, \"fdform\", 0);\n                if(rv == EWOULDBLOCK)\n\t\t    /*break*/;\n        }\n        splx(s);\n        \n        if(rv == EWOULDBLOCK) {\n                /* timed out */\n                rv = EIO;\n\t\t/* XXX what to do to the buf? it will eventually fall\n\t\t   out as finished, but ... ?*/\n\t\t/*biodone(bp);*/\n\t}\n        if(bp->b_flags & B_ERROR)\n                rv = bp->b_error;\n        free(bp, M_TEMP);\n        return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "writedisklabel",
          "args": [
            "dev",
            "fdstrategy",
            "lp",
            "NULL"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setdisklabel",
          "args": [
            "lp",
            "(struct disklabel *)addr",
            "0",
            "NULL"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdisklabel",
          "args": [
            "dev",
            "fdstrategy",
            "lp",
            "&cdl",
            "0"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dkcksum",
          "args": [
            "lp"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "lp->d_packname",
            "\"fictitious\"",
            "16"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "lp->d_typename",
            "\"floppy disk\"",
            "16"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&cdl",
            "sizeof(struct cpu_disklabel)"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "lp",
            "sizeof(*lp)"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FDUNIT",
          "args": [
            "dev"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct cfdriver fd_cd = {\n\tNULL, \"fd\", DV_DISK\n};\nvoid fdstrategy;\nint fdformat;\nint nvraminfo, drive;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\ndev_t dev;\n\nint\nfdioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct fd_softc *fd = fd_cd.cd_devs[FDUNIT(dev)];\n\tstruct disklabel dl, *lp = &dl;\n\tstruct cpu_disklabel cdl;\n\tchar *errstring;\n\tint error;\n\n\tswitch (cmd) {\n\tcase MTIOCTOP:\n\t\tif (((struct mtop *)addr)->mt_op != MTOFFL)\n\t\t\treturn EIO;\n\t\treturn (0);\n\tcase DIOCGDINFO:\n\t\tbzero(lp, sizeof(*lp));\n\t\tbzero(&cdl, sizeof(struct cpu_disklabel));\n\n\t\tlp->d_secsize = 128 << fd->sc_type->secsize;\n\t\tlp->d_secpercyl = fd->sc_type->seccyl;\n\t\tlp->d_ntracks = fd->sc_type->heads;\n\t\tlp->d_nsectors = fd->sc_type->sectrac;\n\t\tlp->d_ncylinders = fd->sc_type->tracks;\n\n\t\tstrncpy(lp->d_typename, \"floppy disk\", 16);\n\t\tlp->d_type = DTYPE_FLOPPY;\n\t\tstrncpy(lp->d_packname, \"fictitious\", 16);\n\t\tlp->d_secperunit = fd->sc_type->size;\n\t\tlp->d_rpm = 300;\n\t\tlp->d_interleave = 1;\n\t\tlp->d_flags = D_REMOVABLE;\n\n\t\tlp->d_partitions[RAW_PART].p_offset = 0;\n\t\tlp->d_partitions[RAW_PART].p_size =\n\t\t    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);\n\t\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\t\tlp->d_npartitions = RAW_PART + 1;\n\n\t\tlp->d_magic = DISKMAGIC;\n\t\tlp->d_magic2 = DISKMAGIC;\n\t\tlp->d_checksum = dkcksum(lp);\n\n\t\terrstring = readdisklabel(dev, fdstrategy, lp, &cdl, 0);\n\t\tif (errstring) {\n\t\t\t/*printf(\"%s: %s\\n\", fd->sc_dev.dv_xname, errstring); */\n\t\t}\n\n\t\t*(struct disklabel *)addr = *lp;\n\t\treturn 0;\n\n\tcase DIOCWLABEL:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn EBADF;\n\t\t/* XXX do something */\n\t\treturn 0;\n\n\tcase DIOCWDINFO:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn EBADF;\n\n\t\terror = setdisklabel(lp, (struct disklabel *)addr, 0, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = writedisklabel(dev, fdstrategy, lp, NULL);\n\t\treturn error;\n\n        case FD_FORM:\n                if((flag & FWRITE) == 0)\n                        return EBADF;  /* must be opened for writing */\n                else if(((struct fd_formb *)addr)->format_version !=\n                        FD_FORMAT_VERSION)\n                        return EINVAL; /* wrong version of formatting prog */\n                else\n                        return fdformat(dev, (struct fd_formb *)addr, p);\n                break;\n\n        case FD_GTYPE:                  /* get drive type */\n                *(struct fd_type *)addr = *fd->sc_type;\n\t\treturn 0;\n\n        case FD_GOPTS:                  /* get drive options */\n                *(int *)addr = fd->sc_opts;\n                return 0;\n                \n        case FD_SOPTS:                  /* set drive options */\n                fd->sc_opts = *(int *)addr;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn ENOTTY;\n\t}\n\n#ifdef DIAGNOSTIC\n\tpanic(\"fdioctl: impossible\");\n#endif\n}"
  },
  {
    "function_name": "fdretry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
    "lines": "891-932",
    "snippet": "void\nfdretry(fd)\n\tstruct fd_softc *fd;\n{\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\tstruct buf *bp = fd->sc_q.b_actf;\n\n\tif (fd->sc_opts & FDOPT_NORETRY)\n\t    goto fail;\n\tswitch (fdc->sc_errors) {\n\tcase 0:\n\t\t/* try again */\n\t\tfdc->sc_state = DOSEEK;\n\t\tbreak;\n\n\tcase 1: case 2: case 3:\n\t\t/* didn't work; try recalibrating */\n\t\tfdc->sc_state = DORECAL;\n\t\tbreak;\n\n\tcase 4:\n\t\t/* still no go; reset the bastard */\n\t\tfdc->sc_state = DORESET;\n\t\tbreak;\n\n\tdefault:\n\tfail:\n\t\tdiskerr(bp, \"fd\", \"hard error\", LOG_PRINTF,\n\t\t    fd->sc_skip / (128 << fd->sc_type->secsize),\n\t\t    (struct disklabel *)NULL);\n\t\tprintf(\" (st0 %b st1 %b st2 %b cyl %d head %d sec %d)\\n\",\n\t\t    fdc->sc_status[0], NE7_ST0BITS,\n\t\t    fdc->sc_status[1], NE7_ST1BITS,\n\t\t    fdc->sc_status[2], NE7_ST2BITS,\n\t\t    fdc->sc_status[3], fdc->sc_status[4], fdc->sc_status[5]);\n\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = EIO;\n\t\tfdfinish(fd, bp);\n\t}\n\tfdc->sc_errors++;\n}",
    "includes": [
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tcyl\tfdc->sc_status[1]",
      "#define\tst0\tfdc->sc_status[0]"
    ],
    "globals_used": [
      "void fdfinish",
      "void fdretry",
      "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
      "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdfinish",
          "args": [
            "fd",
            "bp"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "fdfinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
          "lines": "414-444",
          "snippet": "void\nfdfinish(fd, bp)\n\tstruct fd_softc *fd;\n\tstruct buf *bp;\n{\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\n\t/*\n\t * Move this drive to the end of the queue to give others a `fair'\n\t * chance.  We only force a switch if N operations are completed while\n\t * another drive is waiting to be serviced, since there is a long motor\n\t * startup delay whenever we switch.\n\t */\n\tif (fd->sc_drivechain.tqe_next && ++fd->sc_ops >= 8) {\n\t\tfd->sc_ops = 0;\n\t\tTAILQ_REMOVE(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);\n\t\tif (bp->b_actf) {\n\t\t\tTAILQ_INSERT_TAIL(&fdc->sc_link.fdlink.sc_drives, fd,\n\t\t\t\t\t  sc_drivechain);\n\t\t} else\n\t\t\tfd->sc_q.b_active = 0;\n\t}\n\tbp->b_resid = fd->sc_bcount;\n\tfd->sc_skip = 0;\n\tfd->sc_q.b_actf = bp->b_actf;\n\n\tbiodone(bp);\n\t/* turn off motor 5s from now */\n\ttimeout(fd_motor_off, fd, 5 * hz);\n\tfdc->sc_state = DEVIDLE;\n}",
          "includes": [
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void fd_motor_off",
            "void fdfinish",
            "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
            "int nvraminfo, drive;",
            "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid fd_motor_off;\nvoid fdfinish;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\nint nvraminfo, drive;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nvoid\nfdfinish(fd, bp)\n\tstruct fd_softc *fd;\n\tstruct buf *bp;\n{\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\n\t/*\n\t * Move this drive to the end of the queue to give others a `fair'\n\t * chance.  We only force a switch if N operations are completed while\n\t * another drive is waiting to be serviced, since there is a long motor\n\t * startup delay whenever we switch.\n\t */\n\tif (fd->sc_drivechain.tqe_next && ++fd->sc_ops >= 8) {\n\t\tfd->sc_ops = 0;\n\t\tTAILQ_REMOVE(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);\n\t\tif (bp->b_actf) {\n\t\t\tTAILQ_INSERT_TAIL(&fdc->sc_link.fdlink.sc_drives, fd,\n\t\t\t\t\t  sc_drivechain);\n\t\t} else\n\t\t\tfd->sc_q.b_active = 0;\n\t}\n\tbp->b_resid = fd->sc_bcount;\n\tfd->sc_skip = 0;\n\tfd->sc_q.b_actf = bp->b_actf;\n\n\tbiodone(bp);\n\t/* turn off motor 5s from now */\n\ttimeout(fd_motor_off, fd, 5 * hz);\n\tfdc->sc_state = DEVIDLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" (st0 %b st1 %b st2 %b cyl %d head %d sec %d)\\n\"",
            "fdc->sc_status[0]",
            "NE7_ST0BITS",
            "fdc->sc_status[1]",
            "NE7_ST1BITS",
            "fdc->sc_status[2]",
            "NE7_ST2BITS",
            "fdc->sc_status[3]",
            "fdc->sc_status[4]",
            "fdc->sc_status[5]"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "diskerr",
          "args": [
            "bp",
            "\"fd\"",
            "\"hard error\"",
            "LOG_PRINTF",
            "fd->sc_skip / (128 << fd->sc_type->secsize)",
            "(struct disklabel *)NULL"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tcyl\tfdc->sc_status[1]\n#define\tst0\tfdc->sc_status[0]\n\nvoid fdfinish;\nvoid fdretry;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nvoid\nfdretry(fd)\n\tstruct fd_softc *fd;\n{\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\tstruct buf *bp = fd->sc_q.b_actf;\n\n\tif (fd->sc_opts & FDOPT_NORETRY)\n\t    goto fail;\n\tswitch (fdc->sc_errors) {\n\tcase 0:\n\t\t/* try again */\n\t\tfdc->sc_state = DOSEEK;\n\t\tbreak;\n\n\tcase 1: case 2: case 3:\n\t\t/* didn't work; try recalibrating */\n\t\tfdc->sc_state = DORECAL;\n\t\tbreak;\n\n\tcase 4:\n\t\t/* still no go; reset the bastard */\n\t\tfdc->sc_state = DORESET;\n\t\tbreak;\n\n\tdefault:\n\tfail:\n\t\tdiskerr(bp, \"fd\", \"hard error\", LOG_PRINTF,\n\t\t    fd->sc_skip / (128 << fd->sc_type->secsize),\n\t\t    (struct disklabel *)NULL);\n\t\tprintf(\" (st0 %b st1 %b st2 %b cyl %d head %d sec %d)\\n\",\n\t\t    fdc->sc_status[0], NE7_ST0BITS,\n\t\t    fdc->sc_status[1], NE7_ST1BITS,\n\t\t    fdc->sc_status[2], NE7_ST2BITS,\n\t\t    fdc->sc_status[3], fdc->sc_status[4], fdc->sc_status[5]);\n\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = EIO;\n\t\tfdfinish(fd, bp);\n\t}\n\tfdc->sc_errors++;\n}"
  },
  {
    "function_name": "fdtimeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
    "lines": "868-889",
    "snippet": "void\nfdtimeout(arg)\n\tvoid *arg;\n{\n\tstruct fd_softc *fd = arg;\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\tint s;\n\n\ts = splbio();\n#ifdef DEBUG\n\tlog(LOG_ERR,\"fdtimeout: state %d\\n\", fdc->sc_state);\n#endif\n\tfdcstatus(&fd->sc_dev, 0, \"timeout\");\n\n\tif (fd->sc_q.b_actf)\n\t\tfdc->sc_state++;\n\telse\n\t\tfdc->sc_state = DEVIDLE;\n\n\t(void) fdintr(fdc);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int fdintr",
      "void fdtimeout",
      "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
      "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdintr",
          "args": [
            "fdc"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "fdintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
          "lines": "587-866",
          "snippet": "int\nfdintr(fdc)\n\tstruct fdc_softc *fdc;\n{\n#define\tst0\tfdc->sc_status[0]\n#define\tcyl\tfdc->sc_status[1]\n\tstruct fd_softc *fd;\n\tstruct buf *bp;\n\tbus_space_tag_t iot = fdc->sc_iot;\n\tbus_space_handle_t ioh = fdc->sc_ioh;\n\tbus_space_handle_t ioh_ctl = fdc->sc_ioh_ctl;\n\tint read, head, sec, i, nblks;\n\tstruct fd_type *type;\n\tstruct fd_formb *finfo = NULL;\n\tint fd_bsize, bf;\n\nloop:\n\t/* Is there a transfer to this drive?  If not, deactivate drive. */\n\tfd = fdc->sc_link.fdlink.sc_drives.tqh_first;\n\tif (fd == NULL) {\n\t\tfdc->sc_state = DEVIDLE;\n\t\treturn 1;\n\t}\n\tfd_bsize = 128 << fd->sc_type->secsize;\n\tbf = fd_bsize / FDC_BSIZE;\n\n\tbp = fd->sc_q.b_actf;\n\tif (bp == NULL) {\n\t\tfd->sc_ops = 0;\n\t\tTAILQ_REMOVE(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);\n\t\tfd->sc_q.b_active = 0;\n\t\tgoto loop;\n\t}\n\n\tif (bp->b_flags & B_FORMAT)\n\t    finfo = (struct fd_formb *)bp->b_data;\n\n\tswitch (fdc->sc_state) {\n\tcase DEVIDLE:\n\t\tfdc->sc_errors = 0;\n\t\tfd->sc_skip = 0;\n\t\tfd->sc_bcount = bp->b_bcount;\n\t\tfd->sc_blkno = bp->b_blkno / (fd_bsize / DEV_BSIZE);\n\t\tuntimeout(fd_motor_off, fd);\n\t\tif ((fd->sc_flags & FD_MOTOR_WAIT) != 0) {\n\t\t\tfdc->sc_state = MOTORWAIT;\n\t\t\treturn 1;\n\t\t}\n\t\tif ((fd->sc_flags & FD_MOTOR) == 0) {\n\t\t\t/* Turn on the motor, being careful about pairing. */\n\t\t\tstruct fd_softc *ofd =\n\t\t\t\tfdc->sc_link.fdlink.sc_fd[fd->sc_drive ^ 1];\n\t\t\tif (ofd && ofd->sc_flags & FD_MOTOR) {\n\t\t\t\tuntimeout(fd_motor_off, ofd);\n\t\t\t\tofd->sc_flags &= ~(FD_MOTOR | FD_MOTOR_WAIT);\n\t\t\t}\n\t\t\tfd->sc_flags |= FD_MOTOR | FD_MOTOR_WAIT;\n\t\t\tfd_set_motor(fdc, 0);\n\t\t\tfdc->sc_state = MOTORWAIT;\n\t\t\t/* Allow .25s for motor to stabilize. */\n\t\t\ttimeout(fd_motor_on, fd, hz / 4);\n\t\t\treturn 1;\n\t\t}\n\t\t/* Make sure the right drive is selected. */\n\t\tfd_set_motor(fdc, 0);\n\n\t\t/* fall through */\n\tcase DOSEEK:\n\tdoseek:\n\t\tif (fd->sc_cylin == bp->b_cylin)\n\t\t\tgoto doio;\n\n\t\tout_fdc(iot, ioh, NE7CMD_SPECIFY);/* specify command */\n\t\tout_fdc(iot, ioh, fd->sc_type->steprate);\n\t\tout_fdc(iot, ioh, 6);\t\t/* XXX head load time == 6ms */\n\n\t\tout_fdc(iot, ioh, NE7CMD_SEEK);\t/* seek function */\n\t\tout_fdc(iot, ioh, fd->sc_drive);\t/* drive number */\n\t\tout_fdc(iot, ioh, bp->b_cylin * fd->sc_type->step);\n\n\t\tfd->sc_cylin = -1;\n\t\tfdc->sc_state = SEEKWAIT;\n\n\t\tfd->sc_dk.dk_seek++;\n\t\tdisk_busy(&fd->sc_dk);\n\n\t\ttimeout(fdtimeout, fd, 4 * hz);\n\t\treturn 1;\n\n\tcase DOIO:\n\tdoio:\n\t\ttype = fd->sc_type;\n\t\tif (finfo)\n\t\t    fd->sc_skip = (char *)&(finfo->fd_formb_cylno(0)) -\n\t\t\t(char *)finfo;\n\t\tsec = fd->sc_blkno % type->seccyl;\n\t\tnblks = type->seccyl - sec;\n\t\tnblks = min(nblks, fd->sc_bcount / fd_bsize);\n\t\tnblks = min(nblks, FDC_MAXIOSIZE / fd_bsize);\n\t\tfd->sc_nblks = nblks;\n\t\tfd->sc_nbytes = finfo ? bp->b_bcount : nblks * fd_bsize;\n\t\thead = sec / type->sectrac;\n\t\tsec -= head * type->sectrac;\n#ifdef DIAGNOSTIC\n\t\t{int block;\n\t\t block = (fd->sc_cylin * type->heads + head) * type->sectrac + sec;\n\t\t if (block != fd->sc_blkno) {\n\t\t\t printf(\"fdintr: block %d != blkno %d\\n\", block, fd->sc_blkno);\n#ifdef DDB\n\t\t\t Debugger();\n#endif\n\t\t }}\n#endif\n\t\tread = bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE;\n\t\tisadma_start(bp->b_data + fd->sc_skip, fd->sc_nbytes,\n\t\t    fdc->sc_drq, read);\n\t\tbus_space_write_1(iot, ioh_ctl, fdctl, type->rate);\n#ifdef FD_DEBUG\n\t\tprintf(\"fdintr: %s drive %d track %d head %d sec %d nblks %d\\n\",\n\t\t    read ? \"read\" : \"write\", fd->sc_drive, fd->sc_cylin, head,\n\t\t    sec, nblks);\n#endif\n\t\tif (finfo) {\n                        /* formatting */\n\t\t\tif (out_fdc(iot, ioh, NE7CMD_FORMAT) < 0) {\n\t\t\t    fdc->sc_errors = 4;\n\t\t\t    fdretry(fd);\n\t\t\t    goto loop;\n\t\t\t}\n                        out_fdc(iot, ioh, (head << 2) | fd->sc_drive);\n                        out_fdc(iot, ioh, finfo->fd_formb_secshift);\n                        out_fdc(iot, ioh, finfo->fd_formb_nsecs);\n                        out_fdc(iot, ioh, finfo->fd_formb_gaplen);\n                        out_fdc(iot, ioh, finfo->fd_formb_fillbyte);\n\t\t} else {\n\t\t\tif (read)\n\t\t\t\tout_fdc(iot, ioh, NE7CMD_READ);\t/* READ */\n\t\t\telse\n\t\t\t\tout_fdc(iot, ioh, NE7CMD_WRITE);/* WRITE */\n\t\t\tout_fdc(iot, ioh, (head << 2) | fd->sc_drive);\n\t\t\tout_fdc(iot, ioh, fd->sc_cylin);\t/* track */\n\t\t\tout_fdc(iot, ioh, head);\n\t\t\tout_fdc(iot, ioh, sec + 1);\t\t/* sec +1 */\n\t\t\tout_fdc(iot, ioh, type->secsize);\t/* sec size */\n\t\t\tout_fdc(iot, ioh, type->sectrac);\t/* secs/track */\n\t\t\tout_fdc(iot, ioh, type->gap1);\t\t/* gap1 size */\n\t\t\tout_fdc(iot, ioh, type->datalen);\t/* data len */\n\t\t}\n\t\tfdc->sc_state = IOCOMPLETE;\n\n\t\tdisk_busy(&fd->sc_dk);\n\n\t\t/* allow 2 seconds for operation */\n\t\ttimeout(fdtimeout, fd, 2 * hz);\n\t\treturn 1;\t\t\t\t/* will return later */\n\n\tcase SEEKWAIT:\n\t\tuntimeout(fdtimeout, fd);\n\t\tfdc->sc_state = SEEKCOMPLETE;\n\t\t/* allow 1/50 second for heads to settle */\n\t\ttimeout(fdcpseudointr, fdc, hz / 50);\n\t\treturn 1;\n\n\tcase SEEKCOMPLETE:\n\t\tdisk_unbusy(&fd->sc_dk, 0);\t/* no data on seek */\n\n\t\t/* Make sure seek really happened. */\n\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\tif (fdcresult(fdc) != 2 || (st0 & 0xf8) != 0x20 ||\n\t\t    cyl != bp->b_cylin * fd->sc_type->step) {\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 2, \"seek failed\");\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tfd->sc_cylin = bp->b_cylin;\n\t\tgoto doio;\n\n\tcase IOTIMEDOUT:\n\t\tisadma_abort(fdc->sc_drq);\n\tcase SEEKTIMEDOUT:\n\tcase RECALTIMEDOUT:\n\tcase RESETTIMEDOUT:\n\t\tfdretry(fd);\n\t\tgoto loop;\n\n\tcase IOCOMPLETE: /* IO DONE, post-analyze */\n\t\tuntimeout(fdtimeout, fd);\n\n\t\tdisk_unbusy(&fd->sc_dk, (bp->b_bcount - bp->b_resid));\n\n\t\tif (fdcresult(fdc) != 7 || (st0 & 0xf8) != 0) {\n\t\t\tisadma_abort(fdc->sc_drq);\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 7, bp->b_flags & B_READ ?\n\t\t\t    \"read failed\" : \"write failed\");\n\t\t\tprintf(\"blkno %d nblks %d\\n\",\n\t\t\t    fd->sc_blkno, fd->sc_nblks);\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tread = bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE;\n\t\tisadma_done(fdc->sc_drq);\n\t\tif (fdc->sc_errors) {\n\t\t\tdiskerr(bp, \"fd\", \"soft error\", LOG_PRINTF,\n\t\t\t    fd->sc_skip / fd_bsize, (struct disklabel *)NULL);\n\t\t\tprintf(\"\\n\");\n\t\t\tfdc->sc_errors = 0;\n\t\t}\n\t\tfd->sc_blkno += fd->sc_nblks;\n\t\tfd->sc_skip += fd->sc_nbytes;\n\t\tfd->sc_bcount -= fd->sc_nbytes;\n\t\tif (!finfo && fd->sc_bcount > 0) {\n\t\t\tbp->b_cylin = fd->sc_blkno / fd->sc_type->seccyl;\n\t\t\tgoto doseek;\n\t\t}\n\t\tfdfinish(fd, bp);\n\t\tgoto loop;\n\n\tcase DORESET:\n\t\t/* try a reset, keep motor on */\n\t\tfd_set_motor(fdc, 1);\n\t\tdelay(100);\n\t\tfd_set_motor(fdc, 0);\n\t\tfdc->sc_state = RESETCOMPLETE;\n\t\ttimeout(fdtimeout, fd, hz / 2);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RESETCOMPLETE:\n\t\tuntimeout(fdtimeout, fd);\n\t\t/* clear the controller output buffer */\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\t\t(void) fdcresult(fdc);\n\t\t}\n\n\t\t/* fall through */\n\tcase DORECAL:\n\t\tout_fdc(iot, ioh, NE7CMD_RECAL);\t/* recal function */\n\t\tout_fdc(iot, ioh, fd->sc_drive);\n\t\tfdc->sc_state = RECALWAIT;\n\t\ttimeout(fdtimeout, fd, 5 * hz);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RECALWAIT:\n\t\tuntimeout(fdtimeout, fd);\n\t\tfdc->sc_state = RECALCOMPLETE;\n\t\t/* allow 1/30 second for heads to settle */\n\t\ttimeout(fdcpseudointr, fdc, hz / 30);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RECALCOMPLETE:\n\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\tif (fdcresult(fdc) != 2 || (st0 & 0xf8) != 0x20 || cyl != 0) {\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 2, \"recalibrate failed\");\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tfd->sc_cylin = 0;\n\t\tgoto doseek;\n\n\tcase MOTORWAIT:\n\t\tif (fd->sc_flags & FD_MOTOR_WAIT)\n\t\t\treturn 1;\t\t/* time's not up yet */\n\t\tgoto doseek;\n\n\tdefault:\n\t\tfdcstatus(&fd->sc_dev, 0, \"stray interrupt\");\n\t\treturn 1;\n\t}\n#ifdef DIAGNOSTIC\n\tpanic(\"fdintr: impossible\");\n#endif\n#undef\tst0\n#undef\tcyl\n}",
          "includes": [
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tcyl\tfdc->sc_status[1]",
            "#define\tst0\tfdc->sc_status[0]",
            "#define\tFD_MOTOR_WAIT\t0x04\t\t/* motor coming up */",
            "#define\tFD_MOTOR\t0x02\t\t/* motor should be on */",
            "#define b_cylin b_resid",
            "#define B_FORMAT B_XXX"
          ],
          "globals_used": [
            "int fdintr",
            "void fd_set_motor",
            "void fd_motor_off",
            "void fd_motor_on",
            "void fdfinish",
            "void fdretry",
            "void fdtimeout",
            "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
            "int nvraminfo, drive;",
            "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tcyl\tfdc->sc_status[1]\n#define\tst0\tfdc->sc_status[0]\n#define\tFD_MOTOR_WAIT\t0x04\t\t/* motor coming up */\n#define\tFD_MOTOR\t0x02\t\t/* motor should be on */\n#define b_cylin b_resid\n#define B_FORMAT B_XXX\n\nint fdintr;\nvoid fd_set_motor;\nvoid fd_motor_off;\nvoid fd_motor_on;\nvoid fdfinish;\nvoid fdretry;\nvoid fdtimeout;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\nint nvraminfo, drive;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nint\nfdintr(fdc)\n\tstruct fdc_softc *fdc;\n{\n#define\tst0\tfdc->sc_status[0]\n#define\tcyl\tfdc->sc_status[1]\n\tstruct fd_softc *fd;\n\tstruct buf *bp;\n\tbus_space_tag_t iot = fdc->sc_iot;\n\tbus_space_handle_t ioh = fdc->sc_ioh;\n\tbus_space_handle_t ioh_ctl = fdc->sc_ioh_ctl;\n\tint read, head, sec, i, nblks;\n\tstruct fd_type *type;\n\tstruct fd_formb *finfo = NULL;\n\tint fd_bsize, bf;\n\nloop:\n\t/* Is there a transfer to this drive?  If not, deactivate drive. */\n\tfd = fdc->sc_link.fdlink.sc_drives.tqh_first;\n\tif (fd == NULL) {\n\t\tfdc->sc_state = DEVIDLE;\n\t\treturn 1;\n\t}\n\tfd_bsize = 128 << fd->sc_type->secsize;\n\tbf = fd_bsize / FDC_BSIZE;\n\n\tbp = fd->sc_q.b_actf;\n\tif (bp == NULL) {\n\t\tfd->sc_ops = 0;\n\t\tTAILQ_REMOVE(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);\n\t\tfd->sc_q.b_active = 0;\n\t\tgoto loop;\n\t}\n\n\tif (bp->b_flags & B_FORMAT)\n\t    finfo = (struct fd_formb *)bp->b_data;\n\n\tswitch (fdc->sc_state) {\n\tcase DEVIDLE:\n\t\tfdc->sc_errors = 0;\n\t\tfd->sc_skip = 0;\n\t\tfd->sc_bcount = bp->b_bcount;\n\t\tfd->sc_blkno = bp->b_blkno / (fd_bsize / DEV_BSIZE);\n\t\tuntimeout(fd_motor_off, fd);\n\t\tif ((fd->sc_flags & FD_MOTOR_WAIT) != 0) {\n\t\t\tfdc->sc_state = MOTORWAIT;\n\t\t\treturn 1;\n\t\t}\n\t\tif ((fd->sc_flags & FD_MOTOR) == 0) {\n\t\t\t/* Turn on the motor, being careful about pairing. */\n\t\t\tstruct fd_softc *ofd =\n\t\t\t\tfdc->sc_link.fdlink.sc_fd[fd->sc_drive ^ 1];\n\t\t\tif (ofd && ofd->sc_flags & FD_MOTOR) {\n\t\t\t\tuntimeout(fd_motor_off, ofd);\n\t\t\t\tofd->sc_flags &= ~(FD_MOTOR | FD_MOTOR_WAIT);\n\t\t\t}\n\t\t\tfd->sc_flags |= FD_MOTOR | FD_MOTOR_WAIT;\n\t\t\tfd_set_motor(fdc, 0);\n\t\t\tfdc->sc_state = MOTORWAIT;\n\t\t\t/* Allow .25s for motor to stabilize. */\n\t\t\ttimeout(fd_motor_on, fd, hz / 4);\n\t\t\treturn 1;\n\t\t}\n\t\t/* Make sure the right drive is selected. */\n\t\tfd_set_motor(fdc, 0);\n\n\t\t/* fall through */\n\tcase DOSEEK:\n\tdoseek:\n\t\tif (fd->sc_cylin == bp->b_cylin)\n\t\t\tgoto doio;\n\n\t\tout_fdc(iot, ioh, NE7CMD_SPECIFY);/* specify command */\n\t\tout_fdc(iot, ioh, fd->sc_type->steprate);\n\t\tout_fdc(iot, ioh, 6);\t\t/* XXX head load time == 6ms */\n\n\t\tout_fdc(iot, ioh, NE7CMD_SEEK);\t/* seek function */\n\t\tout_fdc(iot, ioh, fd->sc_drive);\t/* drive number */\n\t\tout_fdc(iot, ioh, bp->b_cylin * fd->sc_type->step);\n\n\t\tfd->sc_cylin = -1;\n\t\tfdc->sc_state = SEEKWAIT;\n\n\t\tfd->sc_dk.dk_seek++;\n\t\tdisk_busy(&fd->sc_dk);\n\n\t\ttimeout(fdtimeout, fd, 4 * hz);\n\t\treturn 1;\n\n\tcase DOIO:\n\tdoio:\n\t\ttype = fd->sc_type;\n\t\tif (finfo)\n\t\t    fd->sc_skip = (char *)&(finfo->fd_formb_cylno(0)) -\n\t\t\t(char *)finfo;\n\t\tsec = fd->sc_blkno % type->seccyl;\n\t\tnblks = type->seccyl - sec;\n\t\tnblks = min(nblks, fd->sc_bcount / fd_bsize);\n\t\tnblks = min(nblks, FDC_MAXIOSIZE / fd_bsize);\n\t\tfd->sc_nblks = nblks;\n\t\tfd->sc_nbytes = finfo ? bp->b_bcount : nblks * fd_bsize;\n\t\thead = sec / type->sectrac;\n\t\tsec -= head * type->sectrac;\n#ifdef DIAGNOSTIC\n\t\t{int block;\n\t\t block = (fd->sc_cylin * type->heads + head) * type->sectrac + sec;\n\t\t if (block != fd->sc_blkno) {\n\t\t\t printf(\"fdintr: block %d != blkno %d\\n\", block, fd->sc_blkno);\n#ifdef DDB\n\t\t\t Debugger();\n#endif\n\t\t }}\n#endif\n\t\tread = bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE;\n\t\tisadma_start(bp->b_data + fd->sc_skip, fd->sc_nbytes,\n\t\t    fdc->sc_drq, read);\n\t\tbus_space_write_1(iot, ioh_ctl, fdctl, type->rate);\n#ifdef FD_DEBUG\n\t\tprintf(\"fdintr: %s drive %d track %d head %d sec %d nblks %d\\n\",\n\t\t    read ? \"read\" : \"write\", fd->sc_drive, fd->sc_cylin, head,\n\t\t    sec, nblks);\n#endif\n\t\tif (finfo) {\n                        /* formatting */\n\t\t\tif (out_fdc(iot, ioh, NE7CMD_FORMAT) < 0) {\n\t\t\t    fdc->sc_errors = 4;\n\t\t\t    fdretry(fd);\n\t\t\t    goto loop;\n\t\t\t}\n                        out_fdc(iot, ioh, (head << 2) | fd->sc_drive);\n                        out_fdc(iot, ioh, finfo->fd_formb_secshift);\n                        out_fdc(iot, ioh, finfo->fd_formb_nsecs);\n                        out_fdc(iot, ioh, finfo->fd_formb_gaplen);\n                        out_fdc(iot, ioh, finfo->fd_formb_fillbyte);\n\t\t} else {\n\t\t\tif (read)\n\t\t\t\tout_fdc(iot, ioh, NE7CMD_READ);\t/* READ */\n\t\t\telse\n\t\t\t\tout_fdc(iot, ioh, NE7CMD_WRITE);/* WRITE */\n\t\t\tout_fdc(iot, ioh, (head << 2) | fd->sc_drive);\n\t\t\tout_fdc(iot, ioh, fd->sc_cylin);\t/* track */\n\t\t\tout_fdc(iot, ioh, head);\n\t\t\tout_fdc(iot, ioh, sec + 1);\t\t/* sec +1 */\n\t\t\tout_fdc(iot, ioh, type->secsize);\t/* sec size */\n\t\t\tout_fdc(iot, ioh, type->sectrac);\t/* secs/track */\n\t\t\tout_fdc(iot, ioh, type->gap1);\t\t/* gap1 size */\n\t\t\tout_fdc(iot, ioh, type->datalen);\t/* data len */\n\t\t}\n\t\tfdc->sc_state = IOCOMPLETE;\n\n\t\tdisk_busy(&fd->sc_dk);\n\n\t\t/* allow 2 seconds for operation */\n\t\ttimeout(fdtimeout, fd, 2 * hz);\n\t\treturn 1;\t\t\t\t/* will return later */\n\n\tcase SEEKWAIT:\n\t\tuntimeout(fdtimeout, fd);\n\t\tfdc->sc_state = SEEKCOMPLETE;\n\t\t/* allow 1/50 second for heads to settle */\n\t\ttimeout(fdcpseudointr, fdc, hz / 50);\n\t\treturn 1;\n\n\tcase SEEKCOMPLETE:\n\t\tdisk_unbusy(&fd->sc_dk, 0);\t/* no data on seek */\n\n\t\t/* Make sure seek really happened. */\n\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\tif (fdcresult(fdc) != 2 || (st0 & 0xf8) != 0x20 ||\n\t\t    cyl != bp->b_cylin * fd->sc_type->step) {\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 2, \"seek failed\");\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tfd->sc_cylin = bp->b_cylin;\n\t\tgoto doio;\n\n\tcase IOTIMEDOUT:\n\t\tisadma_abort(fdc->sc_drq);\n\tcase SEEKTIMEDOUT:\n\tcase RECALTIMEDOUT:\n\tcase RESETTIMEDOUT:\n\t\tfdretry(fd);\n\t\tgoto loop;\n\n\tcase IOCOMPLETE: /* IO DONE, post-analyze */\n\t\tuntimeout(fdtimeout, fd);\n\n\t\tdisk_unbusy(&fd->sc_dk, (bp->b_bcount - bp->b_resid));\n\n\t\tif (fdcresult(fdc) != 7 || (st0 & 0xf8) != 0) {\n\t\t\tisadma_abort(fdc->sc_drq);\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 7, bp->b_flags & B_READ ?\n\t\t\t    \"read failed\" : \"write failed\");\n\t\t\tprintf(\"blkno %d nblks %d\\n\",\n\t\t\t    fd->sc_blkno, fd->sc_nblks);\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tread = bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE;\n\t\tisadma_done(fdc->sc_drq);\n\t\tif (fdc->sc_errors) {\n\t\t\tdiskerr(bp, \"fd\", \"soft error\", LOG_PRINTF,\n\t\t\t    fd->sc_skip / fd_bsize, (struct disklabel *)NULL);\n\t\t\tprintf(\"\\n\");\n\t\t\tfdc->sc_errors = 0;\n\t\t}\n\t\tfd->sc_blkno += fd->sc_nblks;\n\t\tfd->sc_skip += fd->sc_nbytes;\n\t\tfd->sc_bcount -= fd->sc_nbytes;\n\t\tif (!finfo && fd->sc_bcount > 0) {\n\t\t\tbp->b_cylin = fd->sc_blkno / fd->sc_type->seccyl;\n\t\t\tgoto doseek;\n\t\t}\n\t\tfdfinish(fd, bp);\n\t\tgoto loop;\n\n\tcase DORESET:\n\t\t/* try a reset, keep motor on */\n\t\tfd_set_motor(fdc, 1);\n\t\tdelay(100);\n\t\tfd_set_motor(fdc, 0);\n\t\tfdc->sc_state = RESETCOMPLETE;\n\t\ttimeout(fdtimeout, fd, hz / 2);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RESETCOMPLETE:\n\t\tuntimeout(fdtimeout, fd);\n\t\t/* clear the controller output buffer */\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\t\t(void) fdcresult(fdc);\n\t\t}\n\n\t\t/* fall through */\n\tcase DORECAL:\n\t\tout_fdc(iot, ioh, NE7CMD_RECAL);\t/* recal function */\n\t\tout_fdc(iot, ioh, fd->sc_drive);\n\t\tfdc->sc_state = RECALWAIT;\n\t\ttimeout(fdtimeout, fd, 5 * hz);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RECALWAIT:\n\t\tuntimeout(fdtimeout, fd);\n\t\tfdc->sc_state = RECALCOMPLETE;\n\t\t/* allow 1/30 second for heads to settle */\n\t\ttimeout(fdcpseudointr, fdc, hz / 30);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RECALCOMPLETE:\n\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\tif (fdcresult(fdc) != 2 || (st0 & 0xf8) != 0x20 || cyl != 0) {\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 2, \"recalibrate failed\");\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tfd->sc_cylin = 0;\n\t\tgoto doseek;\n\n\tcase MOTORWAIT:\n\t\tif (fd->sc_flags & FD_MOTOR_WAIT)\n\t\t\treturn 1;\t\t/* time's not up yet */\n\t\tgoto doseek;\n\n\tdefault:\n\t\tfdcstatus(&fd->sc_dev, 0, \"stray interrupt\");\n\t\treturn 1;\n\t}\n#ifdef DIAGNOSTIC\n\tpanic(\"fdintr: impossible\");\n#endif\n#undef\tst0\n#undef\tcyl\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdcstatus",
          "args": [
            "&fd->sc_dev",
            "0",
            "\"timeout\""
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "fdcstatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
          "lines": "282-320",
          "snippet": "void\nfdcstatus(dv, n, s)\n\tstruct device *dv;\n\tint n;\n\tchar *s;\n{\n\tstruct fdc_softc *fdc = (void *)dv->dv_parent;\n\n\tif (n == 0) {\n\t\tout_fdc(fdc->sc_iot, fdc->sc_ioh, NE7CMD_SENSEI);\n\t\t(void) fdcresult(fdc);\n\t\tn = 2;\n\t}\n\n\tprintf(\"%s: %s\", dv->dv_xname, s);\n\n\tswitch (n) {\n\tcase 0:\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tprintf(\" (st0 %b cyl %d)\\n\",\n\t\t    fdc->sc_status[0], NE7_ST0BITS,\n\t\t    fdc->sc_status[1]);\n\t\tbreak;\n\tcase 7:\n\t\tprintf(\" (st0 %b st1 %b st2 %b cyl %d head %d sec %d)\\n\",\n\t\t    fdc->sc_status[0], NE7_ST0BITS,\n\t\t    fdc->sc_status[1], NE7_ST1BITS,\n\t\t    fdc->sc_status[2], NE7_ST2BITS,\n\t\t    fdc->sc_status[3], fdc->sc_status[4], fdc->sc_status[5]);\n\t\tbreak;\n#ifdef DIAGNOSTIC\n\tdefault:\n\t\tprintf(\"\\nfdcstatus: weird size\");\n\t\tbreak;\n#endif\n\t}\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nfdcstatus(dv, n, s)\n\tstruct device *dv;\n\tint n;\n\tchar *s;\n{\n\tstruct fdc_softc *fdc = (void *)dv->dv_parent;\n\n\tif (n == 0) {\n\t\tout_fdc(fdc->sc_iot, fdc->sc_ioh, NE7CMD_SENSEI);\n\t\t(void) fdcresult(fdc);\n\t\tn = 2;\n\t}\n\n\tprintf(\"%s: %s\", dv->dv_xname, s);\n\n\tswitch (n) {\n\tcase 0:\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tprintf(\" (st0 %b cyl %d)\\n\",\n\t\t    fdc->sc_status[0], NE7_ST0BITS,\n\t\t    fdc->sc_status[1]);\n\t\tbreak;\n\tcase 7:\n\t\tprintf(\" (st0 %b st1 %b st2 %b cyl %d head %d sec %d)\\n\",\n\t\t    fdc->sc_status[0], NE7_ST0BITS,\n\t\t    fdc->sc_status[1], NE7_ST1BITS,\n\t\t    fdc->sc_status[2], NE7_ST2BITS,\n\t\t    fdc->sc_status[3], fdc->sc_status[4], fdc->sc_status[5]);\n\t\tbreak;\n#ifdef DIAGNOSTIC\n\tdefault:\n\t\tprintf(\"\\nfdcstatus: weird size\");\n\t\tbreak;\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"fdtimeout: state %d\\n\"",
            "fdc->sc_state"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint fdintr;\nvoid fdtimeout;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nvoid\nfdtimeout(arg)\n\tvoid *arg;\n{\n\tstruct fd_softc *fd = arg;\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\tint s;\n\n\ts = splbio();\n#ifdef DEBUG\n\tlog(LOG_ERR,\"fdtimeout: state %d\\n\", fdc->sc_state);\n#endif\n\tfdcstatus(&fd->sc_dev, 0, \"timeout\");\n\n\tif (fd->sc_q.b_actf)\n\t\tfdc->sc_state++;\n\telse\n\t\tfdc->sc_state = DEVIDLE;\n\n\t(void) fdintr(fdc);\n\tsplx(s);\n}"
  },
  {
    "function_name": "fdintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
    "lines": "587-866",
    "snippet": "int\nfdintr(fdc)\n\tstruct fdc_softc *fdc;\n{\n#define\tst0\tfdc->sc_status[0]\n#define\tcyl\tfdc->sc_status[1]\n\tstruct fd_softc *fd;\n\tstruct buf *bp;\n\tbus_space_tag_t iot = fdc->sc_iot;\n\tbus_space_handle_t ioh = fdc->sc_ioh;\n\tbus_space_handle_t ioh_ctl = fdc->sc_ioh_ctl;\n\tint read, head, sec, i, nblks;\n\tstruct fd_type *type;\n\tstruct fd_formb *finfo = NULL;\n\tint fd_bsize, bf;\n\nloop:\n\t/* Is there a transfer to this drive?  If not, deactivate drive. */\n\tfd = fdc->sc_link.fdlink.sc_drives.tqh_first;\n\tif (fd == NULL) {\n\t\tfdc->sc_state = DEVIDLE;\n\t\treturn 1;\n\t}\n\tfd_bsize = 128 << fd->sc_type->secsize;\n\tbf = fd_bsize / FDC_BSIZE;\n\n\tbp = fd->sc_q.b_actf;\n\tif (bp == NULL) {\n\t\tfd->sc_ops = 0;\n\t\tTAILQ_REMOVE(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);\n\t\tfd->sc_q.b_active = 0;\n\t\tgoto loop;\n\t}\n\n\tif (bp->b_flags & B_FORMAT)\n\t    finfo = (struct fd_formb *)bp->b_data;\n\n\tswitch (fdc->sc_state) {\n\tcase DEVIDLE:\n\t\tfdc->sc_errors = 0;\n\t\tfd->sc_skip = 0;\n\t\tfd->sc_bcount = bp->b_bcount;\n\t\tfd->sc_blkno = bp->b_blkno / (fd_bsize / DEV_BSIZE);\n\t\tuntimeout(fd_motor_off, fd);\n\t\tif ((fd->sc_flags & FD_MOTOR_WAIT) != 0) {\n\t\t\tfdc->sc_state = MOTORWAIT;\n\t\t\treturn 1;\n\t\t}\n\t\tif ((fd->sc_flags & FD_MOTOR) == 0) {\n\t\t\t/* Turn on the motor, being careful about pairing. */\n\t\t\tstruct fd_softc *ofd =\n\t\t\t\tfdc->sc_link.fdlink.sc_fd[fd->sc_drive ^ 1];\n\t\t\tif (ofd && ofd->sc_flags & FD_MOTOR) {\n\t\t\t\tuntimeout(fd_motor_off, ofd);\n\t\t\t\tofd->sc_flags &= ~(FD_MOTOR | FD_MOTOR_WAIT);\n\t\t\t}\n\t\t\tfd->sc_flags |= FD_MOTOR | FD_MOTOR_WAIT;\n\t\t\tfd_set_motor(fdc, 0);\n\t\t\tfdc->sc_state = MOTORWAIT;\n\t\t\t/* Allow .25s for motor to stabilize. */\n\t\t\ttimeout(fd_motor_on, fd, hz / 4);\n\t\t\treturn 1;\n\t\t}\n\t\t/* Make sure the right drive is selected. */\n\t\tfd_set_motor(fdc, 0);\n\n\t\t/* fall through */\n\tcase DOSEEK:\n\tdoseek:\n\t\tif (fd->sc_cylin == bp->b_cylin)\n\t\t\tgoto doio;\n\n\t\tout_fdc(iot, ioh, NE7CMD_SPECIFY);/* specify command */\n\t\tout_fdc(iot, ioh, fd->sc_type->steprate);\n\t\tout_fdc(iot, ioh, 6);\t\t/* XXX head load time == 6ms */\n\n\t\tout_fdc(iot, ioh, NE7CMD_SEEK);\t/* seek function */\n\t\tout_fdc(iot, ioh, fd->sc_drive);\t/* drive number */\n\t\tout_fdc(iot, ioh, bp->b_cylin * fd->sc_type->step);\n\n\t\tfd->sc_cylin = -1;\n\t\tfdc->sc_state = SEEKWAIT;\n\n\t\tfd->sc_dk.dk_seek++;\n\t\tdisk_busy(&fd->sc_dk);\n\n\t\ttimeout(fdtimeout, fd, 4 * hz);\n\t\treturn 1;\n\n\tcase DOIO:\n\tdoio:\n\t\ttype = fd->sc_type;\n\t\tif (finfo)\n\t\t    fd->sc_skip = (char *)&(finfo->fd_formb_cylno(0)) -\n\t\t\t(char *)finfo;\n\t\tsec = fd->sc_blkno % type->seccyl;\n\t\tnblks = type->seccyl - sec;\n\t\tnblks = min(nblks, fd->sc_bcount / fd_bsize);\n\t\tnblks = min(nblks, FDC_MAXIOSIZE / fd_bsize);\n\t\tfd->sc_nblks = nblks;\n\t\tfd->sc_nbytes = finfo ? bp->b_bcount : nblks * fd_bsize;\n\t\thead = sec / type->sectrac;\n\t\tsec -= head * type->sectrac;\n#ifdef DIAGNOSTIC\n\t\t{int block;\n\t\t block = (fd->sc_cylin * type->heads + head) * type->sectrac + sec;\n\t\t if (block != fd->sc_blkno) {\n\t\t\t printf(\"fdintr: block %d != blkno %d\\n\", block, fd->sc_blkno);\n#ifdef DDB\n\t\t\t Debugger();\n#endif\n\t\t }}\n#endif\n\t\tread = bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE;\n\t\tisadma_start(bp->b_data + fd->sc_skip, fd->sc_nbytes,\n\t\t    fdc->sc_drq, read);\n\t\tbus_space_write_1(iot, ioh_ctl, fdctl, type->rate);\n#ifdef FD_DEBUG\n\t\tprintf(\"fdintr: %s drive %d track %d head %d sec %d nblks %d\\n\",\n\t\t    read ? \"read\" : \"write\", fd->sc_drive, fd->sc_cylin, head,\n\t\t    sec, nblks);\n#endif\n\t\tif (finfo) {\n                        /* formatting */\n\t\t\tif (out_fdc(iot, ioh, NE7CMD_FORMAT) < 0) {\n\t\t\t    fdc->sc_errors = 4;\n\t\t\t    fdretry(fd);\n\t\t\t    goto loop;\n\t\t\t}\n                        out_fdc(iot, ioh, (head << 2) | fd->sc_drive);\n                        out_fdc(iot, ioh, finfo->fd_formb_secshift);\n                        out_fdc(iot, ioh, finfo->fd_formb_nsecs);\n                        out_fdc(iot, ioh, finfo->fd_formb_gaplen);\n                        out_fdc(iot, ioh, finfo->fd_formb_fillbyte);\n\t\t} else {\n\t\t\tif (read)\n\t\t\t\tout_fdc(iot, ioh, NE7CMD_READ);\t/* READ */\n\t\t\telse\n\t\t\t\tout_fdc(iot, ioh, NE7CMD_WRITE);/* WRITE */\n\t\t\tout_fdc(iot, ioh, (head << 2) | fd->sc_drive);\n\t\t\tout_fdc(iot, ioh, fd->sc_cylin);\t/* track */\n\t\t\tout_fdc(iot, ioh, head);\n\t\t\tout_fdc(iot, ioh, sec + 1);\t\t/* sec +1 */\n\t\t\tout_fdc(iot, ioh, type->secsize);\t/* sec size */\n\t\t\tout_fdc(iot, ioh, type->sectrac);\t/* secs/track */\n\t\t\tout_fdc(iot, ioh, type->gap1);\t\t/* gap1 size */\n\t\t\tout_fdc(iot, ioh, type->datalen);\t/* data len */\n\t\t}\n\t\tfdc->sc_state = IOCOMPLETE;\n\n\t\tdisk_busy(&fd->sc_dk);\n\n\t\t/* allow 2 seconds for operation */\n\t\ttimeout(fdtimeout, fd, 2 * hz);\n\t\treturn 1;\t\t\t\t/* will return later */\n\n\tcase SEEKWAIT:\n\t\tuntimeout(fdtimeout, fd);\n\t\tfdc->sc_state = SEEKCOMPLETE;\n\t\t/* allow 1/50 second for heads to settle */\n\t\ttimeout(fdcpseudointr, fdc, hz / 50);\n\t\treturn 1;\n\n\tcase SEEKCOMPLETE:\n\t\tdisk_unbusy(&fd->sc_dk, 0);\t/* no data on seek */\n\n\t\t/* Make sure seek really happened. */\n\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\tif (fdcresult(fdc) != 2 || (st0 & 0xf8) != 0x20 ||\n\t\t    cyl != bp->b_cylin * fd->sc_type->step) {\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 2, \"seek failed\");\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tfd->sc_cylin = bp->b_cylin;\n\t\tgoto doio;\n\n\tcase IOTIMEDOUT:\n\t\tisadma_abort(fdc->sc_drq);\n\tcase SEEKTIMEDOUT:\n\tcase RECALTIMEDOUT:\n\tcase RESETTIMEDOUT:\n\t\tfdretry(fd);\n\t\tgoto loop;\n\n\tcase IOCOMPLETE: /* IO DONE, post-analyze */\n\t\tuntimeout(fdtimeout, fd);\n\n\t\tdisk_unbusy(&fd->sc_dk, (bp->b_bcount - bp->b_resid));\n\n\t\tif (fdcresult(fdc) != 7 || (st0 & 0xf8) != 0) {\n\t\t\tisadma_abort(fdc->sc_drq);\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 7, bp->b_flags & B_READ ?\n\t\t\t    \"read failed\" : \"write failed\");\n\t\t\tprintf(\"blkno %d nblks %d\\n\",\n\t\t\t    fd->sc_blkno, fd->sc_nblks);\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tread = bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE;\n\t\tisadma_done(fdc->sc_drq);\n\t\tif (fdc->sc_errors) {\n\t\t\tdiskerr(bp, \"fd\", \"soft error\", LOG_PRINTF,\n\t\t\t    fd->sc_skip / fd_bsize, (struct disklabel *)NULL);\n\t\t\tprintf(\"\\n\");\n\t\t\tfdc->sc_errors = 0;\n\t\t}\n\t\tfd->sc_blkno += fd->sc_nblks;\n\t\tfd->sc_skip += fd->sc_nbytes;\n\t\tfd->sc_bcount -= fd->sc_nbytes;\n\t\tif (!finfo && fd->sc_bcount > 0) {\n\t\t\tbp->b_cylin = fd->sc_blkno / fd->sc_type->seccyl;\n\t\t\tgoto doseek;\n\t\t}\n\t\tfdfinish(fd, bp);\n\t\tgoto loop;\n\n\tcase DORESET:\n\t\t/* try a reset, keep motor on */\n\t\tfd_set_motor(fdc, 1);\n\t\tdelay(100);\n\t\tfd_set_motor(fdc, 0);\n\t\tfdc->sc_state = RESETCOMPLETE;\n\t\ttimeout(fdtimeout, fd, hz / 2);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RESETCOMPLETE:\n\t\tuntimeout(fdtimeout, fd);\n\t\t/* clear the controller output buffer */\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\t\t(void) fdcresult(fdc);\n\t\t}\n\n\t\t/* fall through */\n\tcase DORECAL:\n\t\tout_fdc(iot, ioh, NE7CMD_RECAL);\t/* recal function */\n\t\tout_fdc(iot, ioh, fd->sc_drive);\n\t\tfdc->sc_state = RECALWAIT;\n\t\ttimeout(fdtimeout, fd, 5 * hz);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RECALWAIT:\n\t\tuntimeout(fdtimeout, fd);\n\t\tfdc->sc_state = RECALCOMPLETE;\n\t\t/* allow 1/30 second for heads to settle */\n\t\ttimeout(fdcpseudointr, fdc, hz / 30);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RECALCOMPLETE:\n\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\tif (fdcresult(fdc) != 2 || (st0 & 0xf8) != 0x20 || cyl != 0) {\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 2, \"recalibrate failed\");\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tfd->sc_cylin = 0;\n\t\tgoto doseek;\n\n\tcase MOTORWAIT:\n\t\tif (fd->sc_flags & FD_MOTOR_WAIT)\n\t\t\treturn 1;\t\t/* time's not up yet */\n\t\tgoto doseek;\n\n\tdefault:\n\t\tfdcstatus(&fd->sc_dev, 0, \"stray interrupt\");\n\t\treturn 1;\n\t}\n#ifdef DIAGNOSTIC\n\tpanic(\"fdintr: impossible\");\n#endif\n#undef\tst0\n#undef\tcyl\n}",
    "includes": [
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tcyl\tfdc->sc_status[1]",
      "#define\tst0\tfdc->sc_status[0]",
      "#define\tFD_MOTOR_WAIT\t0x04\t\t/* motor coming up */",
      "#define\tFD_MOTOR\t0x02\t\t/* motor should be on */",
      "#define b_cylin b_resid",
      "#define B_FORMAT B_XXX"
    ],
    "globals_used": [
      "int fdintr",
      "void fd_set_motor",
      "void fd_motor_off",
      "void fd_motor_on",
      "void fdfinish",
      "void fdretry",
      "void fdtimeout",
      "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
      "int nvraminfo, drive;",
      "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"fdintr: impossible\""
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdcstatus",
          "args": [
            "&fd->sc_dev",
            "0",
            "\"stray interrupt\""
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "fdcstatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
          "lines": "282-320",
          "snippet": "void\nfdcstatus(dv, n, s)\n\tstruct device *dv;\n\tint n;\n\tchar *s;\n{\n\tstruct fdc_softc *fdc = (void *)dv->dv_parent;\n\n\tif (n == 0) {\n\t\tout_fdc(fdc->sc_iot, fdc->sc_ioh, NE7CMD_SENSEI);\n\t\t(void) fdcresult(fdc);\n\t\tn = 2;\n\t}\n\n\tprintf(\"%s: %s\", dv->dv_xname, s);\n\n\tswitch (n) {\n\tcase 0:\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tprintf(\" (st0 %b cyl %d)\\n\",\n\t\t    fdc->sc_status[0], NE7_ST0BITS,\n\t\t    fdc->sc_status[1]);\n\t\tbreak;\n\tcase 7:\n\t\tprintf(\" (st0 %b st1 %b st2 %b cyl %d head %d sec %d)\\n\",\n\t\t    fdc->sc_status[0], NE7_ST0BITS,\n\t\t    fdc->sc_status[1], NE7_ST1BITS,\n\t\t    fdc->sc_status[2], NE7_ST2BITS,\n\t\t    fdc->sc_status[3], fdc->sc_status[4], fdc->sc_status[5]);\n\t\tbreak;\n#ifdef DIAGNOSTIC\n\tdefault:\n\t\tprintf(\"\\nfdcstatus: weird size\");\n\t\tbreak;\n#endif\n\t}\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nfdcstatus(dv, n, s)\n\tstruct device *dv;\n\tint n;\n\tchar *s;\n{\n\tstruct fdc_softc *fdc = (void *)dv->dv_parent;\n\n\tif (n == 0) {\n\t\tout_fdc(fdc->sc_iot, fdc->sc_ioh, NE7CMD_SENSEI);\n\t\t(void) fdcresult(fdc);\n\t\tn = 2;\n\t}\n\n\tprintf(\"%s: %s\", dv->dv_xname, s);\n\n\tswitch (n) {\n\tcase 0:\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tprintf(\" (st0 %b cyl %d)\\n\",\n\t\t    fdc->sc_status[0], NE7_ST0BITS,\n\t\t    fdc->sc_status[1]);\n\t\tbreak;\n\tcase 7:\n\t\tprintf(\" (st0 %b st1 %b st2 %b cyl %d head %d sec %d)\\n\",\n\t\t    fdc->sc_status[0], NE7_ST0BITS,\n\t\t    fdc->sc_status[1], NE7_ST1BITS,\n\t\t    fdc->sc_status[2], NE7_ST2BITS,\n\t\t    fdc->sc_status[3], fdc->sc_status[4], fdc->sc_status[5]);\n\t\tbreak;\n#ifdef DIAGNOSTIC\n\tdefault:\n\t\tprintf(\"\\nfdcstatus: weird size\");\n\t\tbreak;\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdretry",
          "args": [
            "fd"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "fdretry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
          "lines": "891-932",
          "snippet": "void\nfdretry(fd)\n\tstruct fd_softc *fd;\n{\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\tstruct buf *bp = fd->sc_q.b_actf;\n\n\tif (fd->sc_opts & FDOPT_NORETRY)\n\t    goto fail;\n\tswitch (fdc->sc_errors) {\n\tcase 0:\n\t\t/* try again */\n\t\tfdc->sc_state = DOSEEK;\n\t\tbreak;\n\n\tcase 1: case 2: case 3:\n\t\t/* didn't work; try recalibrating */\n\t\tfdc->sc_state = DORECAL;\n\t\tbreak;\n\n\tcase 4:\n\t\t/* still no go; reset the bastard */\n\t\tfdc->sc_state = DORESET;\n\t\tbreak;\n\n\tdefault:\n\tfail:\n\t\tdiskerr(bp, \"fd\", \"hard error\", LOG_PRINTF,\n\t\t    fd->sc_skip / (128 << fd->sc_type->secsize),\n\t\t    (struct disklabel *)NULL);\n\t\tprintf(\" (st0 %b st1 %b st2 %b cyl %d head %d sec %d)\\n\",\n\t\t    fdc->sc_status[0], NE7_ST0BITS,\n\t\t    fdc->sc_status[1], NE7_ST1BITS,\n\t\t    fdc->sc_status[2], NE7_ST2BITS,\n\t\t    fdc->sc_status[3], fdc->sc_status[4], fdc->sc_status[5]);\n\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = EIO;\n\t\tfdfinish(fd, bp);\n\t}\n\tfdc->sc_errors++;\n}",
          "includes": [
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tcyl\tfdc->sc_status[1]",
            "#define\tst0\tfdc->sc_status[0]"
          ],
          "globals_used": [
            "void fdfinish",
            "void fdretry",
            "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
            "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tcyl\tfdc->sc_status[1]\n#define\tst0\tfdc->sc_status[0]\n\nvoid fdfinish;\nvoid fdretry;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nvoid\nfdretry(fd)\n\tstruct fd_softc *fd;\n{\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\tstruct buf *bp = fd->sc_q.b_actf;\n\n\tif (fd->sc_opts & FDOPT_NORETRY)\n\t    goto fail;\n\tswitch (fdc->sc_errors) {\n\tcase 0:\n\t\t/* try again */\n\t\tfdc->sc_state = DOSEEK;\n\t\tbreak;\n\n\tcase 1: case 2: case 3:\n\t\t/* didn't work; try recalibrating */\n\t\tfdc->sc_state = DORECAL;\n\t\tbreak;\n\n\tcase 4:\n\t\t/* still no go; reset the bastard */\n\t\tfdc->sc_state = DORESET;\n\t\tbreak;\n\n\tdefault:\n\tfail:\n\t\tdiskerr(bp, \"fd\", \"hard error\", LOG_PRINTF,\n\t\t    fd->sc_skip / (128 << fd->sc_type->secsize),\n\t\t    (struct disklabel *)NULL);\n\t\tprintf(\" (st0 %b st1 %b st2 %b cyl %d head %d sec %d)\\n\",\n\t\t    fdc->sc_status[0], NE7_ST0BITS,\n\t\t    fdc->sc_status[1], NE7_ST1BITS,\n\t\t    fdc->sc_status[2], NE7_ST2BITS,\n\t\t    fdc->sc_status[3], fdc->sc_status[4], fdc->sc_status[5]);\n\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = EIO;\n\t\tfdfinish(fd, bp);\n\t}\n\tfdc->sc_errors++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdcresult",
          "args": [
            "fdc"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "fdcresult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
          "lines": "220-246",
          "snippet": "int\nfdcresult(fdc)\n\tstruct fdc_softc *fdc;\n{\n\tbus_space_tag_t iot = fdc->sc_iot;\n\tbus_space_handle_t ioh = fdc->sc_ioh;\n\tu_char i;\n\tint j = 100000, n = 0;\n\n\tfor (; j; j--) {\n\t\ti = bus_space_read_1(iot, ioh, fdsts) &\n\t\t    (NE7_DIO | NE7_RQM | NE7_CB);\n\t\tif (i == NE7_RQM)\n\t\t\treturn n;\n\t\tif (i == (NE7_DIO | NE7_RQM | NE7_CB)) {\n\t\t\tif (n >= sizeof(fdc->sc_status)) {\n\t\t\t\tlog(LOG_ERR, \"fdcresult: overrun\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfdc->sc_status[n++] =\n\t\t\t    bus_space_read_1(iot, ioh, fddata);\n\t\t}\n\t\tdelay(10);\n\t}\n\tlog(LOG_ERR, \"fdcresult: timeout\\n\");\n\treturn -1;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nfdcresult(fdc)\n\tstruct fdc_softc *fdc;\n{\n\tbus_space_tag_t iot = fdc->sc_iot;\n\tbus_space_handle_t ioh = fdc->sc_ioh;\n\tu_char i;\n\tint j = 100000, n = 0;\n\n\tfor (; j; j--) {\n\t\ti = bus_space_read_1(iot, ioh, fdsts) &\n\t\t    (NE7_DIO | NE7_RQM | NE7_CB);\n\t\tif (i == NE7_RQM)\n\t\t\treturn n;\n\t\tif (i == (NE7_DIO | NE7_RQM | NE7_CB)) {\n\t\t\tif (n >= sizeof(fdc->sc_status)) {\n\t\t\t\tlog(LOG_ERR, \"fdcresult: overrun\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfdc->sc_status[n++] =\n\t\t\t    bus_space_read_1(iot, ioh, fddata);\n\t\t}\n\t\tdelay(10);\n\t}\n\tlog(LOG_ERR, \"fdcresult: timeout\\n\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "out_fdc",
          "args": [
            "iot",
            "ioh",
            "NE7CMD_SENSEI"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "out_fdc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
          "lines": "248-264",
          "snippet": "int\nout_fdc(iot, ioh, x)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tu_char x;\n{\n\tint i = 100000;\n\n\twhile ((bus_space_read_1(iot, ioh, fdsts) & NE7_DIO) && i-- > 0);\n\tif (i <= 0)\n\t\treturn -1;\n\twhile ((bus_space_read_1(iot, ioh, fdsts) & NE7_RQM) == 0 && i-- > 0);\n\tif (i <= 0)\n\t\treturn -1;\n\tbus_space_write_1(iot, ioh, fddata, x);\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nout_fdc(iot, ioh, x)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tu_char x;\n{\n\tint i = 100000;\n\n\twhile ((bus_space_read_1(iot, ioh, fdsts) & NE7_DIO) && i-- > 0);\n\tif (i <= 0)\n\t\treturn -1;\n\twhile ((bus_space_read_1(iot, ioh, fdsts) & NE7_RQM) == 0 && i-- > 0);\n\tif (i <= 0)\n\t\treturn -1;\n\tbus_space_write_1(iot, ioh, fddata, x);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "fdcpseudointr",
            "fdc",
            "hz / 30"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "fdtimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
          "lines": "868-889",
          "snippet": "void\nfdtimeout(arg)\n\tvoid *arg;\n{\n\tstruct fd_softc *fd = arg;\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\tint s;\n\n\ts = splbio();\n#ifdef DEBUG\n\tlog(LOG_ERR,\"fdtimeout: state %d\\n\", fdc->sc_state);\n#endif\n\tfdcstatus(&fd->sc_dev, 0, \"timeout\");\n\n\tif (fd->sc_q.b_actf)\n\t\tfdc->sc_state++;\n\telse\n\t\tfdc->sc_state = DEVIDLE;\n\n\t(void) fdintr(fdc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int fdintr",
            "void fdtimeout",
            "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
            "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint fdintr;\nvoid fdtimeout;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nvoid\nfdtimeout(arg)\n\tvoid *arg;\n{\n\tstruct fd_softc *fd = arg;\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\tint s;\n\n\ts = splbio();\n#ifdef DEBUG\n\tlog(LOG_ERR,\"fdtimeout: state %d\\n\", fdc->sc_state);\n#endif\n\tfdcstatus(&fd->sc_dev, 0, \"timeout\");\n\n\tif (fd->sc_q.b_actf)\n\t\tfdc->sc_state++;\n\telse\n\t\tfdc->sc_state = DEVIDLE;\n\n\t(void) fdintr(fdc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "fdtimeout",
            "fd"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "fdtimeout",
            "fd"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd_set_motor",
          "args": [
            "fdc",
            "0"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "fd_set_motor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
          "lines": "466-486",
          "snippet": "void\nfd_set_motor(fdc, reset)\n\tstruct fdc_softc *fdc;\n\tint reset;\n{\n\tstruct fd_softc *fd;\n\tu_char status;\n\tint n;\n\n\tif ((fd = fdc->sc_link.fdlink.sc_drives.tqh_first) != NULL)\n\t\tstatus = fd->sc_drive;\n\telse\n\t\tstatus = 0;\n\tif (!reset)\n\t\tstatus |= FDO_FRST | FDO_FDMAEN;\n\tfor (n = 0; n < 4; n++)\n\t\tif ((fd = fdc->sc_link.fdlink.sc_fd[n])\n\t\t    && (fd->sc_flags & FD_MOTOR))\n\t\t\tstatus |= FDO_MOEN(n);\n\tbus_space_write_1(fdc->sc_iot, fdc->sc_ioh, fdout, status);\n}",
          "includes": [
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tFD_MOTOR\t0x02\t\t/* motor should be on */"
          ],
          "globals_used": [
            "void fd_set_motor",
            "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
            "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tFD_MOTOR\t0x02\t\t/* motor should be on */\n\nvoid fd_set_motor;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nvoid\nfd_set_motor(fdc, reset)\n\tstruct fdc_softc *fdc;\n\tint reset;\n{\n\tstruct fd_softc *fd;\n\tu_char status;\n\tint n;\n\n\tif ((fd = fdc->sc_link.fdlink.sc_drives.tqh_first) != NULL)\n\t\tstatus = fd->sc_drive;\n\telse\n\t\tstatus = 0;\n\tif (!reset)\n\t\tstatus |= FDO_FRST | FDO_FDMAEN;\n\tfor (n = 0; n < 4; n++)\n\t\tif ((fd = fdc->sc_link.fdlink.sc_fd[n])\n\t\t    && (fd->sc_flags & FD_MOTOR))\n\t\t\tstatus |= FDO_MOEN(n);\n\tbus_space_write_1(fdc->sc_iot, fdc->sc_ioh, fdout, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdfinish",
          "args": [
            "fd",
            "bp"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "fdfinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
          "lines": "414-444",
          "snippet": "void\nfdfinish(fd, bp)\n\tstruct fd_softc *fd;\n\tstruct buf *bp;\n{\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\n\t/*\n\t * Move this drive to the end of the queue to give others a `fair'\n\t * chance.  We only force a switch if N operations are completed while\n\t * another drive is waiting to be serviced, since there is a long motor\n\t * startup delay whenever we switch.\n\t */\n\tif (fd->sc_drivechain.tqe_next && ++fd->sc_ops >= 8) {\n\t\tfd->sc_ops = 0;\n\t\tTAILQ_REMOVE(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);\n\t\tif (bp->b_actf) {\n\t\t\tTAILQ_INSERT_TAIL(&fdc->sc_link.fdlink.sc_drives, fd,\n\t\t\t\t\t  sc_drivechain);\n\t\t} else\n\t\t\tfd->sc_q.b_active = 0;\n\t}\n\tbp->b_resid = fd->sc_bcount;\n\tfd->sc_skip = 0;\n\tfd->sc_q.b_actf = bp->b_actf;\n\n\tbiodone(bp);\n\t/* turn off motor 5s from now */\n\ttimeout(fd_motor_off, fd, 5 * hz);\n\tfdc->sc_state = DEVIDLE;\n}",
          "includes": [
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void fd_motor_off",
            "void fdfinish",
            "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
            "int nvraminfo, drive;",
            "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid fd_motor_off;\nvoid fdfinish;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\nint nvraminfo, drive;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nvoid\nfdfinish(fd, bp)\n\tstruct fd_softc *fd;\n\tstruct buf *bp;\n{\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\n\t/*\n\t * Move this drive to the end of the queue to give others a `fair'\n\t * chance.  We only force a switch if N operations are completed while\n\t * another drive is waiting to be serviced, since there is a long motor\n\t * startup delay whenever we switch.\n\t */\n\tif (fd->sc_drivechain.tqe_next && ++fd->sc_ops >= 8) {\n\t\tfd->sc_ops = 0;\n\t\tTAILQ_REMOVE(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);\n\t\tif (bp->b_actf) {\n\t\t\tTAILQ_INSERT_TAIL(&fdc->sc_link.fdlink.sc_drives, fd,\n\t\t\t\t\t  sc_drivechain);\n\t\t} else\n\t\t\tfd->sc_q.b_active = 0;\n\t}\n\tbp->b_resid = fd->sc_bcount;\n\tfd->sc_skip = 0;\n\tfd->sc_q.b_actf = bp->b_actf;\n\n\tbiodone(bp);\n\t/* turn off motor 5s from now */\n\ttimeout(fd_motor_off, fd, 5 * hz);\n\tfdc->sc_state = DEVIDLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "diskerr",
          "args": [
            "bp",
            "\"fd\"",
            "\"soft error\"",
            "LOG_PRINTF",
            "fd->sc_skip / fd_bsize",
            "(struct disklabel *)NULL"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_done",
          "args": [
            "fdc->sc_drq"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_abort",
          "args": [
            "fdc->sc_drq"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_unbusy",
          "args": [
            "&fd->sc_dk",
            "(bp->b_bcount - bp->b_resid)"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "fdtimeout",
            "fd"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_abort",
          "args": [
            "fdc->sc_drq"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_unbusy",
          "args": [
            "&fd->sc_dk",
            "0"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "fdtimeout",
            "fd"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_busy",
          "args": [
            "&fd->sc_dk"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh_ctl",
            "fdctl",
            "type->rate"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_start",
          "args": [
            "bp->b_data + fd->sc_skip",
            "fd->sc_nbytes",
            "fdc->sc_drq",
            "read"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debugger",
          "args": [],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nblks",
            "FDC_MAXIOSIZE / fd_bsize"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "btminphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1088-1096",
          "snippet": "void\nbtminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((BT_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((BT_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void btminphys"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid btminphys;\n\nvoid\nbtminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((BT_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((BT_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finfo->fd_formb_cylno",
          "args": [
            "0"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_busy",
          "args": [
            "&fd->sc_dk"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "fd_motor_off",
            "ofd"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "fd_motor_off",
            "fd"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&fdc->sc_link.fdlink.sc_drives",
            "fd",
            "sc_drivechain"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tcyl\tfdc->sc_status[1]\n#define\tst0\tfdc->sc_status[0]\n#define\tFD_MOTOR_WAIT\t0x04\t\t/* motor coming up */\n#define\tFD_MOTOR\t0x02\t\t/* motor should be on */\n#define b_cylin b_resid\n#define B_FORMAT B_XXX\n\nint fdintr;\nvoid fd_set_motor;\nvoid fd_motor_off;\nvoid fd_motor_on;\nvoid fdfinish;\nvoid fdretry;\nvoid fdtimeout;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\nint nvraminfo, drive;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nint\nfdintr(fdc)\n\tstruct fdc_softc *fdc;\n{\n#define\tst0\tfdc->sc_status[0]\n#define\tcyl\tfdc->sc_status[1]\n\tstruct fd_softc *fd;\n\tstruct buf *bp;\n\tbus_space_tag_t iot = fdc->sc_iot;\n\tbus_space_handle_t ioh = fdc->sc_ioh;\n\tbus_space_handle_t ioh_ctl = fdc->sc_ioh_ctl;\n\tint read, head, sec, i, nblks;\n\tstruct fd_type *type;\n\tstruct fd_formb *finfo = NULL;\n\tint fd_bsize, bf;\n\nloop:\n\t/* Is there a transfer to this drive?  If not, deactivate drive. */\n\tfd = fdc->sc_link.fdlink.sc_drives.tqh_first;\n\tif (fd == NULL) {\n\t\tfdc->sc_state = DEVIDLE;\n\t\treturn 1;\n\t}\n\tfd_bsize = 128 << fd->sc_type->secsize;\n\tbf = fd_bsize / FDC_BSIZE;\n\n\tbp = fd->sc_q.b_actf;\n\tif (bp == NULL) {\n\t\tfd->sc_ops = 0;\n\t\tTAILQ_REMOVE(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);\n\t\tfd->sc_q.b_active = 0;\n\t\tgoto loop;\n\t}\n\n\tif (bp->b_flags & B_FORMAT)\n\t    finfo = (struct fd_formb *)bp->b_data;\n\n\tswitch (fdc->sc_state) {\n\tcase DEVIDLE:\n\t\tfdc->sc_errors = 0;\n\t\tfd->sc_skip = 0;\n\t\tfd->sc_bcount = bp->b_bcount;\n\t\tfd->sc_blkno = bp->b_blkno / (fd_bsize / DEV_BSIZE);\n\t\tuntimeout(fd_motor_off, fd);\n\t\tif ((fd->sc_flags & FD_MOTOR_WAIT) != 0) {\n\t\t\tfdc->sc_state = MOTORWAIT;\n\t\t\treturn 1;\n\t\t}\n\t\tif ((fd->sc_flags & FD_MOTOR) == 0) {\n\t\t\t/* Turn on the motor, being careful about pairing. */\n\t\t\tstruct fd_softc *ofd =\n\t\t\t\tfdc->sc_link.fdlink.sc_fd[fd->sc_drive ^ 1];\n\t\t\tif (ofd && ofd->sc_flags & FD_MOTOR) {\n\t\t\t\tuntimeout(fd_motor_off, ofd);\n\t\t\t\tofd->sc_flags &= ~(FD_MOTOR | FD_MOTOR_WAIT);\n\t\t\t}\n\t\t\tfd->sc_flags |= FD_MOTOR | FD_MOTOR_WAIT;\n\t\t\tfd_set_motor(fdc, 0);\n\t\t\tfdc->sc_state = MOTORWAIT;\n\t\t\t/* Allow .25s for motor to stabilize. */\n\t\t\ttimeout(fd_motor_on, fd, hz / 4);\n\t\t\treturn 1;\n\t\t}\n\t\t/* Make sure the right drive is selected. */\n\t\tfd_set_motor(fdc, 0);\n\n\t\t/* fall through */\n\tcase DOSEEK:\n\tdoseek:\n\t\tif (fd->sc_cylin == bp->b_cylin)\n\t\t\tgoto doio;\n\n\t\tout_fdc(iot, ioh, NE7CMD_SPECIFY);/* specify command */\n\t\tout_fdc(iot, ioh, fd->sc_type->steprate);\n\t\tout_fdc(iot, ioh, 6);\t\t/* XXX head load time == 6ms */\n\n\t\tout_fdc(iot, ioh, NE7CMD_SEEK);\t/* seek function */\n\t\tout_fdc(iot, ioh, fd->sc_drive);\t/* drive number */\n\t\tout_fdc(iot, ioh, bp->b_cylin * fd->sc_type->step);\n\n\t\tfd->sc_cylin = -1;\n\t\tfdc->sc_state = SEEKWAIT;\n\n\t\tfd->sc_dk.dk_seek++;\n\t\tdisk_busy(&fd->sc_dk);\n\n\t\ttimeout(fdtimeout, fd, 4 * hz);\n\t\treturn 1;\n\n\tcase DOIO:\n\tdoio:\n\t\ttype = fd->sc_type;\n\t\tif (finfo)\n\t\t    fd->sc_skip = (char *)&(finfo->fd_formb_cylno(0)) -\n\t\t\t(char *)finfo;\n\t\tsec = fd->sc_blkno % type->seccyl;\n\t\tnblks = type->seccyl - sec;\n\t\tnblks = min(nblks, fd->sc_bcount / fd_bsize);\n\t\tnblks = min(nblks, FDC_MAXIOSIZE / fd_bsize);\n\t\tfd->sc_nblks = nblks;\n\t\tfd->sc_nbytes = finfo ? bp->b_bcount : nblks * fd_bsize;\n\t\thead = sec / type->sectrac;\n\t\tsec -= head * type->sectrac;\n#ifdef DIAGNOSTIC\n\t\t{int block;\n\t\t block = (fd->sc_cylin * type->heads + head) * type->sectrac + sec;\n\t\t if (block != fd->sc_blkno) {\n\t\t\t printf(\"fdintr: block %d != blkno %d\\n\", block, fd->sc_blkno);\n#ifdef DDB\n\t\t\t Debugger();\n#endif\n\t\t }}\n#endif\n\t\tread = bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE;\n\t\tisadma_start(bp->b_data + fd->sc_skip, fd->sc_nbytes,\n\t\t    fdc->sc_drq, read);\n\t\tbus_space_write_1(iot, ioh_ctl, fdctl, type->rate);\n#ifdef FD_DEBUG\n\t\tprintf(\"fdintr: %s drive %d track %d head %d sec %d nblks %d\\n\",\n\t\t    read ? \"read\" : \"write\", fd->sc_drive, fd->sc_cylin, head,\n\t\t    sec, nblks);\n#endif\n\t\tif (finfo) {\n                        /* formatting */\n\t\t\tif (out_fdc(iot, ioh, NE7CMD_FORMAT) < 0) {\n\t\t\t    fdc->sc_errors = 4;\n\t\t\t    fdretry(fd);\n\t\t\t    goto loop;\n\t\t\t}\n                        out_fdc(iot, ioh, (head << 2) | fd->sc_drive);\n                        out_fdc(iot, ioh, finfo->fd_formb_secshift);\n                        out_fdc(iot, ioh, finfo->fd_formb_nsecs);\n                        out_fdc(iot, ioh, finfo->fd_formb_gaplen);\n                        out_fdc(iot, ioh, finfo->fd_formb_fillbyte);\n\t\t} else {\n\t\t\tif (read)\n\t\t\t\tout_fdc(iot, ioh, NE7CMD_READ);\t/* READ */\n\t\t\telse\n\t\t\t\tout_fdc(iot, ioh, NE7CMD_WRITE);/* WRITE */\n\t\t\tout_fdc(iot, ioh, (head << 2) | fd->sc_drive);\n\t\t\tout_fdc(iot, ioh, fd->sc_cylin);\t/* track */\n\t\t\tout_fdc(iot, ioh, head);\n\t\t\tout_fdc(iot, ioh, sec + 1);\t\t/* sec +1 */\n\t\t\tout_fdc(iot, ioh, type->secsize);\t/* sec size */\n\t\t\tout_fdc(iot, ioh, type->sectrac);\t/* secs/track */\n\t\t\tout_fdc(iot, ioh, type->gap1);\t\t/* gap1 size */\n\t\t\tout_fdc(iot, ioh, type->datalen);\t/* data len */\n\t\t}\n\t\tfdc->sc_state = IOCOMPLETE;\n\n\t\tdisk_busy(&fd->sc_dk);\n\n\t\t/* allow 2 seconds for operation */\n\t\ttimeout(fdtimeout, fd, 2 * hz);\n\t\treturn 1;\t\t\t\t/* will return later */\n\n\tcase SEEKWAIT:\n\t\tuntimeout(fdtimeout, fd);\n\t\tfdc->sc_state = SEEKCOMPLETE;\n\t\t/* allow 1/50 second for heads to settle */\n\t\ttimeout(fdcpseudointr, fdc, hz / 50);\n\t\treturn 1;\n\n\tcase SEEKCOMPLETE:\n\t\tdisk_unbusy(&fd->sc_dk, 0);\t/* no data on seek */\n\n\t\t/* Make sure seek really happened. */\n\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\tif (fdcresult(fdc) != 2 || (st0 & 0xf8) != 0x20 ||\n\t\t    cyl != bp->b_cylin * fd->sc_type->step) {\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 2, \"seek failed\");\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tfd->sc_cylin = bp->b_cylin;\n\t\tgoto doio;\n\n\tcase IOTIMEDOUT:\n\t\tisadma_abort(fdc->sc_drq);\n\tcase SEEKTIMEDOUT:\n\tcase RECALTIMEDOUT:\n\tcase RESETTIMEDOUT:\n\t\tfdretry(fd);\n\t\tgoto loop;\n\n\tcase IOCOMPLETE: /* IO DONE, post-analyze */\n\t\tuntimeout(fdtimeout, fd);\n\n\t\tdisk_unbusy(&fd->sc_dk, (bp->b_bcount - bp->b_resid));\n\n\t\tif (fdcresult(fdc) != 7 || (st0 & 0xf8) != 0) {\n\t\t\tisadma_abort(fdc->sc_drq);\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 7, bp->b_flags & B_READ ?\n\t\t\t    \"read failed\" : \"write failed\");\n\t\t\tprintf(\"blkno %d nblks %d\\n\",\n\t\t\t    fd->sc_blkno, fd->sc_nblks);\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tread = bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE;\n\t\tisadma_done(fdc->sc_drq);\n\t\tif (fdc->sc_errors) {\n\t\t\tdiskerr(bp, \"fd\", \"soft error\", LOG_PRINTF,\n\t\t\t    fd->sc_skip / fd_bsize, (struct disklabel *)NULL);\n\t\t\tprintf(\"\\n\");\n\t\t\tfdc->sc_errors = 0;\n\t\t}\n\t\tfd->sc_blkno += fd->sc_nblks;\n\t\tfd->sc_skip += fd->sc_nbytes;\n\t\tfd->sc_bcount -= fd->sc_nbytes;\n\t\tif (!finfo && fd->sc_bcount > 0) {\n\t\t\tbp->b_cylin = fd->sc_blkno / fd->sc_type->seccyl;\n\t\t\tgoto doseek;\n\t\t}\n\t\tfdfinish(fd, bp);\n\t\tgoto loop;\n\n\tcase DORESET:\n\t\t/* try a reset, keep motor on */\n\t\tfd_set_motor(fdc, 1);\n\t\tdelay(100);\n\t\tfd_set_motor(fdc, 0);\n\t\tfdc->sc_state = RESETCOMPLETE;\n\t\ttimeout(fdtimeout, fd, hz / 2);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RESETCOMPLETE:\n\t\tuntimeout(fdtimeout, fd);\n\t\t/* clear the controller output buffer */\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\t\t(void) fdcresult(fdc);\n\t\t}\n\n\t\t/* fall through */\n\tcase DORECAL:\n\t\tout_fdc(iot, ioh, NE7CMD_RECAL);\t/* recal function */\n\t\tout_fdc(iot, ioh, fd->sc_drive);\n\t\tfdc->sc_state = RECALWAIT;\n\t\ttimeout(fdtimeout, fd, 5 * hz);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RECALWAIT:\n\t\tuntimeout(fdtimeout, fd);\n\t\tfdc->sc_state = RECALCOMPLETE;\n\t\t/* allow 1/30 second for heads to settle */\n\t\ttimeout(fdcpseudointr, fdc, hz / 30);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RECALCOMPLETE:\n\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\tif (fdcresult(fdc) != 2 || (st0 & 0xf8) != 0x20 || cyl != 0) {\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 2, \"recalibrate failed\");\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tfd->sc_cylin = 0;\n\t\tgoto doseek;\n\n\tcase MOTORWAIT:\n\t\tif (fd->sc_flags & FD_MOTOR_WAIT)\n\t\t\treturn 1;\t\t/* time's not up yet */\n\t\tgoto doseek;\n\n\tdefault:\n\t\tfdcstatus(&fd->sc_dev, 0, \"stray interrupt\");\n\t\treturn 1;\n\t}\n#ifdef DIAGNOSTIC\n\tpanic(\"fdintr: impossible\");\n#endif\n#undef\tst0\n#undef\tcyl\n}"
  },
  {
    "function_name": "fddump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
    "lines": "572-582",
    "snippet": "int\nfddump(dev, blkno, va, size)\n\tdev_t dev;\n\tdaddr_t blkno;\n\tcaddr_t va;\n\tsize_t size;\n{\n\n\t/* Not implemented. */\n\treturn ENXIO;\n}",
    "includes": [
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "dev_t dev;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\ndev_t dev;\n\nint\nfddump(dev, blkno, va, size)\n\tdev_t dev;\n\tdaddr_t blkno;\n\tcaddr_t va;\n\tsize_t size;\n{\n\n\t/* Not implemented. */\n\treturn ENXIO;\n}"
  },
  {
    "function_name": "fdsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
    "lines": "563-570",
    "snippet": "int\nfdsize(dev)\n\tdev_t dev;\n{\n\n\t/* Swapping to floppies would not make sense. */\n\treturn -1;\n}",
    "includes": [
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "dev_t dev;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\ndev_t dev;\n\nint\nfdsize(dev)\n\tdev_t dev;\n{\n\n\t/* Swapping to floppies would not make sense. */\n\treturn -1;\n}"
  },
  {
    "function_name": "fdclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
    "lines": "549-561",
    "snippet": "int\nfdclose(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags;\n\tint mode;\n\tstruct proc *p;\n{\n\tstruct fd_softc *fd = fd_cd.cd_devs[FDUNIT(dev)];\n\n\tfd->sc_flags &= ~FD_OPEN;\n\tfd->sc_opts &= ~FDOPT_NORETRY;\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tFD_OPEN\t\t0x01\t\t/* it's open */"
    ],
    "globals_used": [
      "struct cfdriver fd_cd = {\n\tNULL, \"fd\", DV_DISK\n};",
      "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;",
      "dev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FDUNIT",
          "args": [
            "dev"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tFD_OPEN\t\t0x01\t\t/* it's open */\n\nstruct cfdriver fd_cd = {\n\tNULL, \"fd\", DV_DISK\n};\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\ndev_t dev;\n\nint\nfdclose(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags;\n\tint mode;\n\tstruct proc *p;\n{\n\tstruct fd_softc *fd = fd_cd.cd_devs[FDUNIT(dev)];\n\n\tfd->sc_flags &= ~FD_OPEN;\n\tfd->sc_opts &= ~FDOPT_NORETRY;\n\treturn 0;\n}"
  },
  {
    "function_name": "fdopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
    "lines": "517-547",
    "snippet": "int\nfdopen(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags;\n\tint mode;\n\tstruct proc *p;\n{\n \tint unit;\n\tstruct fd_softc *fd;\n\tstruct fd_type *type;\n\n\tunit = FDUNIT(dev);\n\tif (unit >= fd_cd.cd_ndevs)\n\t\treturn ENXIO;\n\tfd = fd_cd.cd_devs[unit];\n\tif (fd == 0)\n\t\treturn ENXIO;\n\ttype = fd_dev_to_type(fd, dev);\n\tif (type == NULL)\n\t\treturn ENXIO;\n\n\tif ((fd->sc_flags & FD_OPEN) != 0 &&\n\t    fd->sc_type != type)\n\t\treturn EBUSY;\n\n\tfd->sc_type = type;\n\tfd->sc_cylin = -1;\n\tfd->sc_flags |= FD_OPEN;\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tFD_OPEN\t\t0x01\t\t/* it's open */"
    ],
    "globals_used": [
      "struct cfdriver fd_cd = {\n\tNULL, \"fd\", DV_DISK\n};",
      "__inline struct fd_type *fd_dev_to_type",
      "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;",
      "dev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fd_dev_to_type",
          "args": [
            "fd",
            "dev"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FDUNIT",
          "args": [
            "dev"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tFD_OPEN\t\t0x01\t\t/* it's open */\n\nstruct cfdriver fd_cd = {\n\tNULL, \"fd\", DV_DISK\n};\n__inline struct fd_type *fd_dev_to_type;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\ndev_t dev;\n\nint\nfdopen(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags;\n\tint mode;\n\tstruct proc *p;\n{\n \tint unit;\n\tstruct fd_softc *fd;\n\tstruct fd_type *type;\n\n\tunit = FDUNIT(dev);\n\tif (unit >= fd_cd.cd_ndevs)\n\t\treturn ENXIO;\n\tfd = fd_cd.cd_devs[unit];\n\tif (fd == 0)\n\t\treturn ENXIO;\n\ttype = fd_dev_to_type(fd, dev);\n\tif (type == NULL)\n\t\treturn ENXIO;\n\n\tif ((fd->sc_flags & FD_OPEN) != 0 &&\n\t    fd->sc_type != type)\n\t\treturn EBUSY;\n\n\tfd->sc_type = type;\n\tfd->sc_cylin = -1;\n\tfd->sc_flags |= FD_OPEN;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fd_motor_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
    "lines": "501-515",
    "snippet": "void\nfd_motor_on(arg)\n\tvoid *arg;\n{\n\tstruct fd_softc *fd = arg;\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\tint s;\n\n\ts = splbio();\n\tfd->sc_flags &= ~FD_MOTOR_WAIT;\n\tif ((fdc->sc_link.fdlink.sc_drives.tqh_first == fd)\n\t    && (fdc->sc_state == MOTORWAIT))\n\t\t(void) fdintr(fdc);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tFD_MOTOR_WAIT\t0x04\t\t/* motor coming up */"
    ],
    "globals_used": [
      "int fdintr",
      "void fd_motor_on",
      "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
      "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdintr",
          "args": [
            "fdc"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "fdintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
          "lines": "587-866",
          "snippet": "int\nfdintr(fdc)\n\tstruct fdc_softc *fdc;\n{\n#define\tst0\tfdc->sc_status[0]\n#define\tcyl\tfdc->sc_status[1]\n\tstruct fd_softc *fd;\n\tstruct buf *bp;\n\tbus_space_tag_t iot = fdc->sc_iot;\n\tbus_space_handle_t ioh = fdc->sc_ioh;\n\tbus_space_handle_t ioh_ctl = fdc->sc_ioh_ctl;\n\tint read, head, sec, i, nblks;\n\tstruct fd_type *type;\n\tstruct fd_formb *finfo = NULL;\n\tint fd_bsize, bf;\n\nloop:\n\t/* Is there a transfer to this drive?  If not, deactivate drive. */\n\tfd = fdc->sc_link.fdlink.sc_drives.tqh_first;\n\tif (fd == NULL) {\n\t\tfdc->sc_state = DEVIDLE;\n\t\treturn 1;\n\t}\n\tfd_bsize = 128 << fd->sc_type->secsize;\n\tbf = fd_bsize / FDC_BSIZE;\n\n\tbp = fd->sc_q.b_actf;\n\tif (bp == NULL) {\n\t\tfd->sc_ops = 0;\n\t\tTAILQ_REMOVE(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);\n\t\tfd->sc_q.b_active = 0;\n\t\tgoto loop;\n\t}\n\n\tif (bp->b_flags & B_FORMAT)\n\t    finfo = (struct fd_formb *)bp->b_data;\n\n\tswitch (fdc->sc_state) {\n\tcase DEVIDLE:\n\t\tfdc->sc_errors = 0;\n\t\tfd->sc_skip = 0;\n\t\tfd->sc_bcount = bp->b_bcount;\n\t\tfd->sc_blkno = bp->b_blkno / (fd_bsize / DEV_BSIZE);\n\t\tuntimeout(fd_motor_off, fd);\n\t\tif ((fd->sc_flags & FD_MOTOR_WAIT) != 0) {\n\t\t\tfdc->sc_state = MOTORWAIT;\n\t\t\treturn 1;\n\t\t}\n\t\tif ((fd->sc_flags & FD_MOTOR) == 0) {\n\t\t\t/* Turn on the motor, being careful about pairing. */\n\t\t\tstruct fd_softc *ofd =\n\t\t\t\tfdc->sc_link.fdlink.sc_fd[fd->sc_drive ^ 1];\n\t\t\tif (ofd && ofd->sc_flags & FD_MOTOR) {\n\t\t\t\tuntimeout(fd_motor_off, ofd);\n\t\t\t\tofd->sc_flags &= ~(FD_MOTOR | FD_MOTOR_WAIT);\n\t\t\t}\n\t\t\tfd->sc_flags |= FD_MOTOR | FD_MOTOR_WAIT;\n\t\t\tfd_set_motor(fdc, 0);\n\t\t\tfdc->sc_state = MOTORWAIT;\n\t\t\t/* Allow .25s for motor to stabilize. */\n\t\t\ttimeout(fd_motor_on, fd, hz / 4);\n\t\t\treturn 1;\n\t\t}\n\t\t/* Make sure the right drive is selected. */\n\t\tfd_set_motor(fdc, 0);\n\n\t\t/* fall through */\n\tcase DOSEEK:\n\tdoseek:\n\t\tif (fd->sc_cylin == bp->b_cylin)\n\t\t\tgoto doio;\n\n\t\tout_fdc(iot, ioh, NE7CMD_SPECIFY);/* specify command */\n\t\tout_fdc(iot, ioh, fd->sc_type->steprate);\n\t\tout_fdc(iot, ioh, 6);\t\t/* XXX head load time == 6ms */\n\n\t\tout_fdc(iot, ioh, NE7CMD_SEEK);\t/* seek function */\n\t\tout_fdc(iot, ioh, fd->sc_drive);\t/* drive number */\n\t\tout_fdc(iot, ioh, bp->b_cylin * fd->sc_type->step);\n\n\t\tfd->sc_cylin = -1;\n\t\tfdc->sc_state = SEEKWAIT;\n\n\t\tfd->sc_dk.dk_seek++;\n\t\tdisk_busy(&fd->sc_dk);\n\n\t\ttimeout(fdtimeout, fd, 4 * hz);\n\t\treturn 1;\n\n\tcase DOIO:\n\tdoio:\n\t\ttype = fd->sc_type;\n\t\tif (finfo)\n\t\t    fd->sc_skip = (char *)&(finfo->fd_formb_cylno(0)) -\n\t\t\t(char *)finfo;\n\t\tsec = fd->sc_blkno % type->seccyl;\n\t\tnblks = type->seccyl - sec;\n\t\tnblks = min(nblks, fd->sc_bcount / fd_bsize);\n\t\tnblks = min(nblks, FDC_MAXIOSIZE / fd_bsize);\n\t\tfd->sc_nblks = nblks;\n\t\tfd->sc_nbytes = finfo ? bp->b_bcount : nblks * fd_bsize;\n\t\thead = sec / type->sectrac;\n\t\tsec -= head * type->sectrac;\n#ifdef DIAGNOSTIC\n\t\t{int block;\n\t\t block = (fd->sc_cylin * type->heads + head) * type->sectrac + sec;\n\t\t if (block != fd->sc_blkno) {\n\t\t\t printf(\"fdintr: block %d != blkno %d\\n\", block, fd->sc_blkno);\n#ifdef DDB\n\t\t\t Debugger();\n#endif\n\t\t }}\n#endif\n\t\tread = bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE;\n\t\tisadma_start(bp->b_data + fd->sc_skip, fd->sc_nbytes,\n\t\t    fdc->sc_drq, read);\n\t\tbus_space_write_1(iot, ioh_ctl, fdctl, type->rate);\n#ifdef FD_DEBUG\n\t\tprintf(\"fdintr: %s drive %d track %d head %d sec %d nblks %d\\n\",\n\t\t    read ? \"read\" : \"write\", fd->sc_drive, fd->sc_cylin, head,\n\t\t    sec, nblks);\n#endif\n\t\tif (finfo) {\n                        /* formatting */\n\t\t\tif (out_fdc(iot, ioh, NE7CMD_FORMAT) < 0) {\n\t\t\t    fdc->sc_errors = 4;\n\t\t\t    fdretry(fd);\n\t\t\t    goto loop;\n\t\t\t}\n                        out_fdc(iot, ioh, (head << 2) | fd->sc_drive);\n                        out_fdc(iot, ioh, finfo->fd_formb_secshift);\n                        out_fdc(iot, ioh, finfo->fd_formb_nsecs);\n                        out_fdc(iot, ioh, finfo->fd_formb_gaplen);\n                        out_fdc(iot, ioh, finfo->fd_formb_fillbyte);\n\t\t} else {\n\t\t\tif (read)\n\t\t\t\tout_fdc(iot, ioh, NE7CMD_READ);\t/* READ */\n\t\t\telse\n\t\t\t\tout_fdc(iot, ioh, NE7CMD_WRITE);/* WRITE */\n\t\t\tout_fdc(iot, ioh, (head << 2) | fd->sc_drive);\n\t\t\tout_fdc(iot, ioh, fd->sc_cylin);\t/* track */\n\t\t\tout_fdc(iot, ioh, head);\n\t\t\tout_fdc(iot, ioh, sec + 1);\t\t/* sec +1 */\n\t\t\tout_fdc(iot, ioh, type->secsize);\t/* sec size */\n\t\t\tout_fdc(iot, ioh, type->sectrac);\t/* secs/track */\n\t\t\tout_fdc(iot, ioh, type->gap1);\t\t/* gap1 size */\n\t\t\tout_fdc(iot, ioh, type->datalen);\t/* data len */\n\t\t}\n\t\tfdc->sc_state = IOCOMPLETE;\n\n\t\tdisk_busy(&fd->sc_dk);\n\n\t\t/* allow 2 seconds for operation */\n\t\ttimeout(fdtimeout, fd, 2 * hz);\n\t\treturn 1;\t\t\t\t/* will return later */\n\n\tcase SEEKWAIT:\n\t\tuntimeout(fdtimeout, fd);\n\t\tfdc->sc_state = SEEKCOMPLETE;\n\t\t/* allow 1/50 second for heads to settle */\n\t\ttimeout(fdcpseudointr, fdc, hz / 50);\n\t\treturn 1;\n\n\tcase SEEKCOMPLETE:\n\t\tdisk_unbusy(&fd->sc_dk, 0);\t/* no data on seek */\n\n\t\t/* Make sure seek really happened. */\n\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\tif (fdcresult(fdc) != 2 || (st0 & 0xf8) != 0x20 ||\n\t\t    cyl != bp->b_cylin * fd->sc_type->step) {\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 2, \"seek failed\");\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tfd->sc_cylin = bp->b_cylin;\n\t\tgoto doio;\n\n\tcase IOTIMEDOUT:\n\t\tisadma_abort(fdc->sc_drq);\n\tcase SEEKTIMEDOUT:\n\tcase RECALTIMEDOUT:\n\tcase RESETTIMEDOUT:\n\t\tfdretry(fd);\n\t\tgoto loop;\n\n\tcase IOCOMPLETE: /* IO DONE, post-analyze */\n\t\tuntimeout(fdtimeout, fd);\n\n\t\tdisk_unbusy(&fd->sc_dk, (bp->b_bcount - bp->b_resid));\n\n\t\tif (fdcresult(fdc) != 7 || (st0 & 0xf8) != 0) {\n\t\t\tisadma_abort(fdc->sc_drq);\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 7, bp->b_flags & B_READ ?\n\t\t\t    \"read failed\" : \"write failed\");\n\t\t\tprintf(\"blkno %d nblks %d\\n\",\n\t\t\t    fd->sc_blkno, fd->sc_nblks);\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tread = bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE;\n\t\tisadma_done(fdc->sc_drq);\n\t\tif (fdc->sc_errors) {\n\t\t\tdiskerr(bp, \"fd\", \"soft error\", LOG_PRINTF,\n\t\t\t    fd->sc_skip / fd_bsize, (struct disklabel *)NULL);\n\t\t\tprintf(\"\\n\");\n\t\t\tfdc->sc_errors = 0;\n\t\t}\n\t\tfd->sc_blkno += fd->sc_nblks;\n\t\tfd->sc_skip += fd->sc_nbytes;\n\t\tfd->sc_bcount -= fd->sc_nbytes;\n\t\tif (!finfo && fd->sc_bcount > 0) {\n\t\t\tbp->b_cylin = fd->sc_blkno / fd->sc_type->seccyl;\n\t\t\tgoto doseek;\n\t\t}\n\t\tfdfinish(fd, bp);\n\t\tgoto loop;\n\n\tcase DORESET:\n\t\t/* try a reset, keep motor on */\n\t\tfd_set_motor(fdc, 1);\n\t\tdelay(100);\n\t\tfd_set_motor(fdc, 0);\n\t\tfdc->sc_state = RESETCOMPLETE;\n\t\ttimeout(fdtimeout, fd, hz / 2);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RESETCOMPLETE:\n\t\tuntimeout(fdtimeout, fd);\n\t\t/* clear the controller output buffer */\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\t\t(void) fdcresult(fdc);\n\t\t}\n\n\t\t/* fall through */\n\tcase DORECAL:\n\t\tout_fdc(iot, ioh, NE7CMD_RECAL);\t/* recal function */\n\t\tout_fdc(iot, ioh, fd->sc_drive);\n\t\tfdc->sc_state = RECALWAIT;\n\t\ttimeout(fdtimeout, fd, 5 * hz);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RECALWAIT:\n\t\tuntimeout(fdtimeout, fd);\n\t\tfdc->sc_state = RECALCOMPLETE;\n\t\t/* allow 1/30 second for heads to settle */\n\t\ttimeout(fdcpseudointr, fdc, hz / 30);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RECALCOMPLETE:\n\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\tif (fdcresult(fdc) != 2 || (st0 & 0xf8) != 0x20 || cyl != 0) {\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 2, \"recalibrate failed\");\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tfd->sc_cylin = 0;\n\t\tgoto doseek;\n\n\tcase MOTORWAIT:\n\t\tif (fd->sc_flags & FD_MOTOR_WAIT)\n\t\t\treturn 1;\t\t/* time's not up yet */\n\t\tgoto doseek;\n\n\tdefault:\n\t\tfdcstatus(&fd->sc_dev, 0, \"stray interrupt\");\n\t\treturn 1;\n\t}\n#ifdef DIAGNOSTIC\n\tpanic(\"fdintr: impossible\");\n#endif\n#undef\tst0\n#undef\tcyl\n}",
          "includes": [
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tcyl\tfdc->sc_status[1]",
            "#define\tst0\tfdc->sc_status[0]",
            "#define\tFD_MOTOR_WAIT\t0x04\t\t/* motor coming up */",
            "#define\tFD_MOTOR\t0x02\t\t/* motor should be on */",
            "#define b_cylin b_resid",
            "#define B_FORMAT B_XXX"
          ],
          "globals_used": [
            "int fdintr",
            "void fd_set_motor",
            "void fd_motor_off",
            "void fd_motor_on",
            "void fdfinish",
            "void fdretry",
            "void fdtimeout",
            "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
            "int nvraminfo, drive;",
            "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tcyl\tfdc->sc_status[1]\n#define\tst0\tfdc->sc_status[0]\n#define\tFD_MOTOR_WAIT\t0x04\t\t/* motor coming up */\n#define\tFD_MOTOR\t0x02\t\t/* motor should be on */\n#define b_cylin b_resid\n#define B_FORMAT B_XXX\n\nint fdintr;\nvoid fd_set_motor;\nvoid fd_motor_off;\nvoid fd_motor_on;\nvoid fdfinish;\nvoid fdretry;\nvoid fdtimeout;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\nint nvraminfo, drive;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nint\nfdintr(fdc)\n\tstruct fdc_softc *fdc;\n{\n#define\tst0\tfdc->sc_status[0]\n#define\tcyl\tfdc->sc_status[1]\n\tstruct fd_softc *fd;\n\tstruct buf *bp;\n\tbus_space_tag_t iot = fdc->sc_iot;\n\tbus_space_handle_t ioh = fdc->sc_ioh;\n\tbus_space_handle_t ioh_ctl = fdc->sc_ioh_ctl;\n\tint read, head, sec, i, nblks;\n\tstruct fd_type *type;\n\tstruct fd_formb *finfo = NULL;\n\tint fd_bsize, bf;\n\nloop:\n\t/* Is there a transfer to this drive?  If not, deactivate drive. */\n\tfd = fdc->sc_link.fdlink.sc_drives.tqh_first;\n\tif (fd == NULL) {\n\t\tfdc->sc_state = DEVIDLE;\n\t\treturn 1;\n\t}\n\tfd_bsize = 128 << fd->sc_type->secsize;\n\tbf = fd_bsize / FDC_BSIZE;\n\n\tbp = fd->sc_q.b_actf;\n\tif (bp == NULL) {\n\t\tfd->sc_ops = 0;\n\t\tTAILQ_REMOVE(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);\n\t\tfd->sc_q.b_active = 0;\n\t\tgoto loop;\n\t}\n\n\tif (bp->b_flags & B_FORMAT)\n\t    finfo = (struct fd_formb *)bp->b_data;\n\n\tswitch (fdc->sc_state) {\n\tcase DEVIDLE:\n\t\tfdc->sc_errors = 0;\n\t\tfd->sc_skip = 0;\n\t\tfd->sc_bcount = bp->b_bcount;\n\t\tfd->sc_blkno = bp->b_blkno / (fd_bsize / DEV_BSIZE);\n\t\tuntimeout(fd_motor_off, fd);\n\t\tif ((fd->sc_flags & FD_MOTOR_WAIT) != 0) {\n\t\t\tfdc->sc_state = MOTORWAIT;\n\t\t\treturn 1;\n\t\t}\n\t\tif ((fd->sc_flags & FD_MOTOR) == 0) {\n\t\t\t/* Turn on the motor, being careful about pairing. */\n\t\t\tstruct fd_softc *ofd =\n\t\t\t\tfdc->sc_link.fdlink.sc_fd[fd->sc_drive ^ 1];\n\t\t\tif (ofd && ofd->sc_flags & FD_MOTOR) {\n\t\t\t\tuntimeout(fd_motor_off, ofd);\n\t\t\t\tofd->sc_flags &= ~(FD_MOTOR | FD_MOTOR_WAIT);\n\t\t\t}\n\t\t\tfd->sc_flags |= FD_MOTOR | FD_MOTOR_WAIT;\n\t\t\tfd_set_motor(fdc, 0);\n\t\t\tfdc->sc_state = MOTORWAIT;\n\t\t\t/* Allow .25s for motor to stabilize. */\n\t\t\ttimeout(fd_motor_on, fd, hz / 4);\n\t\t\treturn 1;\n\t\t}\n\t\t/* Make sure the right drive is selected. */\n\t\tfd_set_motor(fdc, 0);\n\n\t\t/* fall through */\n\tcase DOSEEK:\n\tdoseek:\n\t\tif (fd->sc_cylin == bp->b_cylin)\n\t\t\tgoto doio;\n\n\t\tout_fdc(iot, ioh, NE7CMD_SPECIFY);/* specify command */\n\t\tout_fdc(iot, ioh, fd->sc_type->steprate);\n\t\tout_fdc(iot, ioh, 6);\t\t/* XXX head load time == 6ms */\n\n\t\tout_fdc(iot, ioh, NE7CMD_SEEK);\t/* seek function */\n\t\tout_fdc(iot, ioh, fd->sc_drive);\t/* drive number */\n\t\tout_fdc(iot, ioh, bp->b_cylin * fd->sc_type->step);\n\n\t\tfd->sc_cylin = -1;\n\t\tfdc->sc_state = SEEKWAIT;\n\n\t\tfd->sc_dk.dk_seek++;\n\t\tdisk_busy(&fd->sc_dk);\n\n\t\ttimeout(fdtimeout, fd, 4 * hz);\n\t\treturn 1;\n\n\tcase DOIO:\n\tdoio:\n\t\ttype = fd->sc_type;\n\t\tif (finfo)\n\t\t    fd->sc_skip = (char *)&(finfo->fd_formb_cylno(0)) -\n\t\t\t(char *)finfo;\n\t\tsec = fd->sc_blkno % type->seccyl;\n\t\tnblks = type->seccyl - sec;\n\t\tnblks = min(nblks, fd->sc_bcount / fd_bsize);\n\t\tnblks = min(nblks, FDC_MAXIOSIZE / fd_bsize);\n\t\tfd->sc_nblks = nblks;\n\t\tfd->sc_nbytes = finfo ? bp->b_bcount : nblks * fd_bsize;\n\t\thead = sec / type->sectrac;\n\t\tsec -= head * type->sectrac;\n#ifdef DIAGNOSTIC\n\t\t{int block;\n\t\t block = (fd->sc_cylin * type->heads + head) * type->sectrac + sec;\n\t\t if (block != fd->sc_blkno) {\n\t\t\t printf(\"fdintr: block %d != blkno %d\\n\", block, fd->sc_blkno);\n#ifdef DDB\n\t\t\t Debugger();\n#endif\n\t\t }}\n#endif\n\t\tread = bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE;\n\t\tisadma_start(bp->b_data + fd->sc_skip, fd->sc_nbytes,\n\t\t    fdc->sc_drq, read);\n\t\tbus_space_write_1(iot, ioh_ctl, fdctl, type->rate);\n#ifdef FD_DEBUG\n\t\tprintf(\"fdintr: %s drive %d track %d head %d sec %d nblks %d\\n\",\n\t\t    read ? \"read\" : \"write\", fd->sc_drive, fd->sc_cylin, head,\n\t\t    sec, nblks);\n#endif\n\t\tif (finfo) {\n                        /* formatting */\n\t\t\tif (out_fdc(iot, ioh, NE7CMD_FORMAT) < 0) {\n\t\t\t    fdc->sc_errors = 4;\n\t\t\t    fdretry(fd);\n\t\t\t    goto loop;\n\t\t\t}\n                        out_fdc(iot, ioh, (head << 2) | fd->sc_drive);\n                        out_fdc(iot, ioh, finfo->fd_formb_secshift);\n                        out_fdc(iot, ioh, finfo->fd_formb_nsecs);\n                        out_fdc(iot, ioh, finfo->fd_formb_gaplen);\n                        out_fdc(iot, ioh, finfo->fd_formb_fillbyte);\n\t\t} else {\n\t\t\tif (read)\n\t\t\t\tout_fdc(iot, ioh, NE7CMD_READ);\t/* READ */\n\t\t\telse\n\t\t\t\tout_fdc(iot, ioh, NE7CMD_WRITE);/* WRITE */\n\t\t\tout_fdc(iot, ioh, (head << 2) | fd->sc_drive);\n\t\t\tout_fdc(iot, ioh, fd->sc_cylin);\t/* track */\n\t\t\tout_fdc(iot, ioh, head);\n\t\t\tout_fdc(iot, ioh, sec + 1);\t\t/* sec +1 */\n\t\t\tout_fdc(iot, ioh, type->secsize);\t/* sec size */\n\t\t\tout_fdc(iot, ioh, type->sectrac);\t/* secs/track */\n\t\t\tout_fdc(iot, ioh, type->gap1);\t\t/* gap1 size */\n\t\t\tout_fdc(iot, ioh, type->datalen);\t/* data len */\n\t\t}\n\t\tfdc->sc_state = IOCOMPLETE;\n\n\t\tdisk_busy(&fd->sc_dk);\n\n\t\t/* allow 2 seconds for operation */\n\t\ttimeout(fdtimeout, fd, 2 * hz);\n\t\treturn 1;\t\t\t\t/* will return later */\n\n\tcase SEEKWAIT:\n\t\tuntimeout(fdtimeout, fd);\n\t\tfdc->sc_state = SEEKCOMPLETE;\n\t\t/* allow 1/50 second for heads to settle */\n\t\ttimeout(fdcpseudointr, fdc, hz / 50);\n\t\treturn 1;\n\n\tcase SEEKCOMPLETE:\n\t\tdisk_unbusy(&fd->sc_dk, 0);\t/* no data on seek */\n\n\t\t/* Make sure seek really happened. */\n\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\tif (fdcresult(fdc) != 2 || (st0 & 0xf8) != 0x20 ||\n\t\t    cyl != bp->b_cylin * fd->sc_type->step) {\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 2, \"seek failed\");\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tfd->sc_cylin = bp->b_cylin;\n\t\tgoto doio;\n\n\tcase IOTIMEDOUT:\n\t\tisadma_abort(fdc->sc_drq);\n\tcase SEEKTIMEDOUT:\n\tcase RECALTIMEDOUT:\n\tcase RESETTIMEDOUT:\n\t\tfdretry(fd);\n\t\tgoto loop;\n\n\tcase IOCOMPLETE: /* IO DONE, post-analyze */\n\t\tuntimeout(fdtimeout, fd);\n\n\t\tdisk_unbusy(&fd->sc_dk, (bp->b_bcount - bp->b_resid));\n\n\t\tif (fdcresult(fdc) != 7 || (st0 & 0xf8) != 0) {\n\t\t\tisadma_abort(fdc->sc_drq);\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 7, bp->b_flags & B_READ ?\n\t\t\t    \"read failed\" : \"write failed\");\n\t\t\tprintf(\"blkno %d nblks %d\\n\",\n\t\t\t    fd->sc_blkno, fd->sc_nblks);\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tread = bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE;\n\t\tisadma_done(fdc->sc_drq);\n\t\tif (fdc->sc_errors) {\n\t\t\tdiskerr(bp, \"fd\", \"soft error\", LOG_PRINTF,\n\t\t\t    fd->sc_skip / fd_bsize, (struct disklabel *)NULL);\n\t\t\tprintf(\"\\n\");\n\t\t\tfdc->sc_errors = 0;\n\t\t}\n\t\tfd->sc_blkno += fd->sc_nblks;\n\t\tfd->sc_skip += fd->sc_nbytes;\n\t\tfd->sc_bcount -= fd->sc_nbytes;\n\t\tif (!finfo && fd->sc_bcount > 0) {\n\t\t\tbp->b_cylin = fd->sc_blkno / fd->sc_type->seccyl;\n\t\t\tgoto doseek;\n\t\t}\n\t\tfdfinish(fd, bp);\n\t\tgoto loop;\n\n\tcase DORESET:\n\t\t/* try a reset, keep motor on */\n\t\tfd_set_motor(fdc, 1);\n\t\tdelay(100);\n\t\tfd_set_motor(fdc, 0);\n\t\tfdc->sc_state = RESETCOMPLETE;\n\t\ttimeout(fdtimeout, fd, hz / 2);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RESETCOMPLETE:\n\t\tuntimeout(fdtimeout, fd);\n\t\t/* clear the controller output buffer */\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\t\t(void) fdcresult(fdc);\n\t\t}\n\n\t\t/* fall through */\n\tcase DORECAL:\n\t\tout_fdc(iot, ioh, NE7CMD_RECAL);\t/* recal function */\n\t\tout_fdc(iot, ioh, fd->sc_drive);\n\t\tfdc->sc_state = RECALWAIT;\n\t\ttimeout(fdtimeout, fd, 5 * hz);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RECALWAIT:\n\t\tuntimeout(fdtimeout, fd);\n\t\tfdc->sc_state = RECALCOMPLETE;\n\t\t/* allow 1/30 second for heads to settle */\n\t\ttimeout(fdcpseudointr, fdc, hz / 30);\n\t\treturn 1;\t\t\t/* will return later */\n\n\tcase RECALCOMPLETE:\n\t\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\t\tif (fdcresult(fdc) != 2 || (st0 & 0xf8) != 0x20 || cyl != 0) {\n#ifdef FD_DEBUG\n\t\t\tfdcstatus(&fd->sc_dev, 2, \"recalibrate failed\");\n#endif\n\t\t\tfdretry(fd);\n\t\t\tgoto loop;\n\t\t}\n\t\tfd->sc_cylin = 0;\n\t\tgoto doseek;\n\n\tcase MOTORWAIT:\n\t\tif (fd->sc_flags & FD_MOTOR_WAIT)\n\t\t\treturn 1;\t\t/* time's not up yet */\n\t\tgoto doseek;\n\n\tdefault:\n\t\tfdcstatus(&fd->sc_dev, 0, \"stray interrupt\");\n\t\treturn 1;\n\t}\n#ifdef DIAGNOSTIC\n\tpanic(\"fdintr: impossible\");\n#endif\n#undef\tst0\n#undef\tcyl\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tFD_MOTOR_WAIT\t0x04\t\t/* motor coming up */\n\nint fdintr;\nvoid fd_motor_on;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nvoid\nfd_motor_on(arg)\n\tvoid *arg;\n{\n\tstruct fd_softc *fd = arg;\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\tint s;\n\n\ts = splbio();\n\tfd->sc_flags &= ~FD_MOTOR_WAIT;\n\tif ((fdc->sc_link.fdlink.sc_drives.tqh_first == fd)\n\t    && (fdc->sc_state == MOTORWAIT))\n\t\t(void) fdintr(fdc);\n\tsplx(s);\n}"
  },
  {
    "function_name": "fd_motor_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
    "lines": "488-499",
    "snippet": "void\nfd_motor_off(arg)\n\tvoid *arg;\n{\n\tstruct fd_softc *fd = arg;\n\tint s;\n\n\ts = splbio();\n\tfd->sc_flags &= ~(FD_MOTOR | FD_MOTOR_WAIT);\n\tfd_set_motor((struct fdc_softc *)fd->sc_dev.dv_parent, 0);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tFD_MOTOR_WAIT\t0x04\t\t/* motor coming up */",
      "#define\tFD_MOTOR\t0x02\t\t/* motor should be on */"
    ],
    "globals_used": [
      "void fd_set_motor",
      "void fd_motor_off",
      "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd_set_motor",
          "args": [
            "(struct fdc_softc *)fd->sc_dev.dv_parent",
            "0"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "fd_set_motor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
          "lines": "466-486",
          "snippet": "void\nfd_set_motor(fdc, reset)\n\tstruct fdc_softc *fdc;\n\tint reset;\n{\n\tstruct fd_softc *fd;\n\tu_char status;\n\tint n;\n\n\tif ((fd = fdc->sc_link.fdlink.sc_drives.tqh_first) != NULL)\n\t\tstatus = fd->sc_drive;\n\telse\n\t\tstatus = 0;\n\tif (!reset)\n\t\tstatus |= FDO_FRST | FDO_FDMAEN;\n\tfor (n = 0; n < 4; n++)\n\t\tif ((fd = fdc->sc_link.fdlink.sc_fd[n])\n\t\t    && (fd->sc_flags & FD_MOTOR))\n\t\t\tstatus |= FDO_MOEN(n);\n\tbus_space_write_1(fdc->sc_iot, fdc->sc_ioh, fdout, status);\n}",
          "includes": [
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tFD_MOTOR\t0x02\t\t/* motor should be on */"
          ],
          "globals_used": [
            "void fd_set_motor",
            "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
            "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tFD_MOTOR\t0x02\t\t/* motor should be on */\n\nvoid fd_set_motor;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nvoid\nfd_set_motor(fdc, reset)\n\tstruct fdc_softc *fdc;\n\tint reset;\n{\n\tstruct fd_softc *fd;\n\tu_char status;\n\tint n;\n\n\tif ((fd = fdc->sc_link.fdlink.sc_drives.tqh_first) != NULL)\n\t\tstatus = fd->sc_drive;\n\telse\n\t\tstatus = 0;\n\tif (!reset)\n\t\tstatus |= FDO_FRST | FDO_FDMAEN;\n\tfor (n = 0; n < 4; n++)\n\t\tif ((fd = fdc->sc_link.fdlink.sc_fd[n])\n\t\t    && (fd->sc_flags & FD_MOTOR))\n\t\t\tstatus |= FDO_MOEN(n);\n\tbus_space_write_1(fdc->sc_iot, fdc->sc_ioh, fdout, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tFD_MOTOR_WAIT\t0x04\t\t/* motor coming up */\n#define\tFD_MOTOR\t0x02\t\t/* motor should be on */\n\nvoid fd_set_motor;\nvoid fd_motor_off;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nvoid\nfd_motor_off(arg)\n\tvoid *arg;\n{\n\tstruct fd_softc *fd = arg;\n\tint s;\n\n\ts = splbio();\n\tfd->sc_flags &= ~(FD_MOTOR | FD_MOTOR_WAIT);\n\tfd_set_motor((struct fdc_softc *)fd->sc_dev.dv_parent, 0);\n\tsplx(s);\n}"
  },
  {
    "function_name": "fd_set_motor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
    "lines": "466-486",
    "snippet": "void\nfd_set_motor(fdc, reset)\n\tstruct fdc_softc *fdc;\n\tint reset;\n{\n\tstruct fd_softc *fd;\n\tu_char status;\n\tint n;\n\n\tif ((fd = fdc->sc_link.fdlink.sc_drives.tqh_first) != NULL)\n\t\tstatus = fd->sc_drive;\n\telse\n\t\tstatus = 0;\n\tif (!reset)\n\t\tstatus |= FDO_FRST | FDO_FDMAEN;\n\tfor (n = 0; n < 4; n++)\n\t\tif ((fd = fdc->sc_link.fdlink.sc_fd[n])\n\t\t    && (fd->sc_flags & FD_MOTOR))\n\t\t\tstatus |= FDO_MOEN(n);\n\tbus_space_write_1(fdc->sc_iot, fdc->sc_ioh, fdout, status);\n}",
    "includes": [
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tFD_MOTOR\t0x02\t\t/* motor should be on */"
    ],
    "globals_used": [
      "void fd_set_motor",
      "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
      "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "fdc->sc_iot",
            "fdc->sc_ioh",
            "fdout",
            "status"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FDO_MOEN",
          "args": [
            "n"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tFD_MOTOR\t0x02\t\t/* motor should be on */\n\nvoid fd_set_motor;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nvoid\nfd_set_motor(fdc, reset)\n\tstruct fdc_softc *fdc;\n\tint reset;\n{\n\tstruct fd_softc *fd;\n\tu_char status;\n\tint n;\n\n\tif ((fd = fdc->sc_link.fdlink.sc_drives.tqh_first) != NULL)\n\t\tstatus = fd->sc_drive;\n\telse\n\t\tstatus = 0;\n\tif (!reset)\n\t\tstatus |= FDO_FRST | FDO_FDMAEN;\n\tfor (n = 0; n < 4; n++)\n\t\tif ((fd = fdc->sc_link.fdlink.sc_fd[n])\n\t\t    && (fd->sc_flags & FD_MOTOR))\n\t\t\tstatus |= FDO_MOEN(n);\n\tbus_space_write_1(fdc->sc_iot, fdc->sc_ioh, fdout, status);\n}"
  },
  {
    "function_name": "fdwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
    "lines": "456-464",
    "snippet": "int\nfdwrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\n\treturn (physio(fdstrategy, NULL, dev, B_WRITE, minphys, uio));\n}",
    "includes": [
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void fdstrategy",
      "dev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "physio",
          "args": [
            "fdstrategy",
            "NULL",
            "dev",
            "B_WRITE",
            "minphys",
            "uio"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid fdstrategy;\ndev_t dev;\n\nint\nfdwrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\n\treturn (physio(fdstrategy, NULL, dev, B_WRITE, minphys, uio));\n}"
  },
  {
    "function_name": "fdread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
    "lines": "446-454",
    "snippet": "int\nfdread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\n\treturn (physio(fdstrategy, NULL, dev, B_READ, minphys, uio));\n}",
    "includes": [
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void fdstrategy",
      "dev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "physio",
          "args": [
            "fdstrategy",
            "NULL",
            "dev",
            "B_READ",
            "minphys",
            "uio"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid fdstrategy;\ndev_t dev;\n\nint\nfdread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\n\treturn (physio(fdstrategy, NULL, dev, B_READ, minphys, uio));\n}"
  },
  {
    "function_name": "fdfinish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
    "lines": "414-444",
    "snippet": "void\nfdfinish(fd, bp)\n\tstruct fd_softc *fd;\n\tstruct buf *bp;\n{\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\n\t/*\n\t * Move this drive to the end of the queue to give others a `fair'\n\t * chance.  We only force a switch if N operations are completed while\n\t * another drive is waiting to be serviced, since there is a long motor\n\t * startup delay whenever we switch.\n\t */\n\tif (fd->sc_drivechain.tqe_next && ++fd->sc_ops >= 8) {\n\t\tfd->sc_ops = 0;\n\t\tTAILQ_REMOVE(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);\n\t\tif (bp->b_actf) {\n\t\t\tTAILQ_INSERT_TAIL(&fdc->sc_link.fdlink.sc_drives, fd,\n\t\t\t\t\t  sc_drivechain);\n\t\t} else\n\t\t\tfd->sc_q.b_active = 0;\n\t}\n\tbp->b_resid = fd->sc_bcount;\n\tfd->sc_skip = 0;\n\tfd->sc_q.b_actf = bp->b_actf;\n\n\tbiodone(bp);\n\t/* turn off motor 5s from now */\n\ttimeout(fd_motor_off, fd, 5 * hz);\n\tfdc->sc_state = DEVIDLE;\n}",
    "includes": [
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void fd_motor_off",
      "void fdfinish",
      "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
      "int nvraminfo, drive;",
      "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "fd_motor_off",
            "fd",
            "5 * hz"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "fdtimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
          "lines": "868-889",
          "snippet": "void\nfdtimeout(arg)\n\tvoid *arg;\n{\n\tstruct fd_softc *fd = arg;\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\tint s;\n\n\ts = splbio();\n#ifdef DEBUG\n\tlog(LOG_ERR,\"fdtimeout: state %d\\n\", fdc->sc_state);\n#endif\n\tfdcstatus(&fd->sc_dev, 0, \"timeout\");\n\n\tif (fd->sc_q.b_actf)\n\t\tfdc->sc_state++;\n\telse\n\t\tfdc->sc_state = DEVIDLE;\n\n\t(void) fdintr(fdc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int fdintr",
            "void fdtimeout",
            "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
            "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint fdintr;\nvoid fdtimeout;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nvoid\nfdtimeout(arg)\n\tvoid *arg;\n{\n\tstruct fd_softc *fd = arg;\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\tint s;\n\n\ts = splbio();\n#ifdef DEBUG\n\tlog(LOG_ERR,\"fdtimeout: state %d\\n\", fdc->sc_state);\n#endif\n\tfdcstatus(&fd->sc_dev, 0, \"timeout\");\n\n\tif (fd->sc_q.b_actf)\n\t\tfdc->sc_state++;\n\telse\n\t\tfdc->sc_state = DEVIDLE;\n\n\t(void) fdintr(fdc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&fdc->sc_link.fdlink.sc_drives",
            "fd",
            "sc_drivechain"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&fdc->sc_link.fdlink.sc_drives",
            "fd",
            "sc_drivechain"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid fd_motor_off;\nvoid fdfinish;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\nint nvraminfo, drive;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nvoid\nfdfinish(fd, bp)\n\tstruct fd_softc *fd;\n\tstruct buf *bp;\n{\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\n\t/*\n\t * Move this drive to the end of the queue to give others a `fair'\n\t * chance.  We only force a switch if N operations are completed while\n\t * another drive is waiting to be serviced, since there is a long motor\n\t * startup delay whenever we switch.\n\t */\n\tif (fd->sc_drivechain.tqe_next && ++fd->sc_ops >= 8) {\n\t\tfd->sc_ops = 0;\n\t\tTAILQ_REMOVE(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);\n\t\tif (bp->b_actf) {\n\t\t\tTAILQ_INSERT_TAIL(&fdc->sc_link.fdlink.sc_drives, fd,\n\t\t\t\t\t  sc_drivechain);\n\t\t} else\n\t\t\tfd->sc_q.b_active = 0;\n\t}\n\tbp->b_resid = fd->sc_bcount;\n\tfd->sc_skip = 0;\n\tfd->sc_q.b_actf = bp->b_actf;\n\n\tbiodone(bp);\n\t/* turn off motor 5s from now */\n\ttimeout(fd_motor_off, fd, 5 * hz);\n\tfdc->sc_state = DEVIDLE;\n}"
  },
  {
    "function_name": "fdstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
    "lines": "398-412",
    "snippet": "void\nfdstart(fd)\n\tstruct fd_softc *fd;\n{\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\tint active = (fdc->sc_link.fdlink.sc_drives.tqh_first != NULL);\n\n\t/* Link into controller queue. */\n\tfd->sc_q.b_active = 1;\n\tTAILQ_INSERT_TAIL(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);\n\n\t/* If controller not already active, start it. */\n\tif (!active)\n\t\tfdcstart(fdc);\n}",
    "includes": [
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void fdstart",
      "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
      "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdcstart",
          "args": [
            "fdc"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "fdcstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
          "lines": "266-280",
          "snippet": "void\nfdcstart(fdc)\n\tstruct fdc_softc *fdc;\n{\n\n#ifdef DIAGNOSTIC\n\t/* only got here if controller's drive queue was inactive; should\n\t   be in idle state */\n\tif (fdc->sc_state != DEVIDLE) {\n\t\tprintf(\"fdcstart: not idle\\n\");\n\t\treturn;\n\t}\n#endif\n\t(void) fdcintr(fdc);\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int fdcintr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint fdcintr;\n\nvoid\nfdcstart(fdc)\n\tstruct fdc_softc *fdc;\n{\n\n#ifdef DIAGNOSTIC\n\t/* only got here if controller's drive queue was inactive; should\n\t   be in idle state */\n\tif (fdc->sc_state != DEVIDLE) {\n\t\tprintf(\"fdcstart: not idle\\n\");\n\t\treturn;\n\t}\n#endif\n\t(void) fdcintr(fdc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&fdc->sc_link.fdlink.sc_drives",
            "fd",
            "sc_drivechain"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid fdstart;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nvoid\nfdstart(fd)\n\tstruct fd_softc *fd;\n{\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\tint active = (fdc->sc_link.fdlink.sc_drives.tqh_first != NULL);\n\n\t/* Link into controller queue. */\n\tfd->sc_q.b_active = 1;\n\tTAILQ_INSERT_TAIL(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);\n\n\t/* If controller not already active, start it. */\n\tif (!active)\n\t\tfdcstart(fdc);\n}"
  },
  {
    "function_name": "fdstrategy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
    "lines": "326-396",
    "snippet": "void\nfdstrategy(bp)\n\tregister struct buf *bp;\t/* IO operation to perform */\n{\n\tstruct fd_softc *fd = fd_cd.cd_devs[FDUNIT(bp->b_dev)];\n\tint sz;\n \tint s;\n\tint fd_bsize = 128 << fd->sc_type->secsize;\n\tint bf = fd_bsize / DEV_BSIZE;\n\n\t/* Valid unit, controller, and request? */\n\tif (bp->b_blkno < 0 ||\n\t    (((bp->b_blkno % bf) != 0 ||\n\t      (bp->b_bcount % fd_bsize) != 0) &&\n\t     (bp->b_flags & B_FORMAT) == 0)) {\n\t\tbp->b_error = EINVAL;\n\t\tgoto bad;\n\t}\n\n\t/* If it's a null transfer, return immediately. */\n\tif (bp->b_bcount == 0)\n\t\tgoto done;\n\n\tsz = howmany(bp->b_bcount, DEV_BSIZE);\n\n\tif (bp->b_blkno + sz > fd->sc_type->size * bf) {\n\t\tsz = fd->sc_type->size * bf - bp->b_blkno;\n\t\tif (sz == 0)\n\t\t\t/* If exactly at end of disk, return EOF. */\n\t\t\tgoto done;\n\t\tif (sz < 0) {\n\t\t\t/* If past end of disk, return EINVAL. */\n\t\t\tbp->b_error = EINVAL;\n\t\t\tgoto bad;\n\t\t}\n\t\t/* Otherwise, truncate request. */\n\t\tbp->b_bcount = sz << DEV_BSHIFT;\n\t}\n\n \tbp->b_cylin = bp->b_blkno / (fd_bsize / DEV_BSIZE) / fd->sc_type->seccyl;\n\n#ifdef FD_DEBUG\n\tprintf(\"fdstrategy: b_blkno %d b_bcount %d blkno %d cylin %d sz %d\\n\",\n\t    bp->b_blkno, bp->b_bcount, fd->sc_blkno, bp->b_cylin, sz);\n#endif\n\n\t/* Queue transfer on drive, activate drive and controller if idle. */\n\ts = splbio();\n\tdisksort(&fd->sc_q, bp);\n\tuntimeout(fd_motor_off, fd); /* a good idea */\n\tif (!fd->sc_q.b_active)\n\t\tfdstart(fd);\n#ifdef DIAGNOSTIC\n\telse {\n\t\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\t\tif (fdc->sc_state == DEVIDLE) {\n\t\t\tprintf(\"fdstrategy: controller inactive\\n\");\n\t\t\tfdcstart(fdc);\n\t\t}\n\t}\n#endif\n\tsplx(s);\n\treturn;\n\nbad:\n\tbp->b_flags |= B_ERROR;\ndone:\n\t/* Toss transfer; we're done early. */\n\tbp->b_resid = bp->b_bcount;\n\tbiodone(bp);\n}",
    "includes": [
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define b_cylin b_resid",
      "#define B_FORMAT B_XXX"
    ],
    "globals_used": [
      "struct cfdriver fd_cd = {\n\tNULL, \"fd\", DV_DISK\n};",
      "void fdstrategy",
      "void fdstart",
      "void fd_motor_off",
      "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
      "int nvraminfo, drive;",
      "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdcstart",
          "args": [
            "fdc"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "fdcstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
          "lines": "266-280",
          "snippet": "void\nfdcstart(fdc)\n\tstruct fdc_softc *fdc;\n{\n\n#ifdef DIAGNOSTIC\n\t/* only got here if controller's drive queue was inactive; should\n\t   be in idle state */\n\tif (fdc->sc_state != DEVIDLE) {\n\t\tprintf(\"fdcstart: not idle\\n\");\n\t\treturn;\n\t}\n#endif\n\t(void) fdcintr(fdc);\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int fdcintr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint fdcintr;\n\nvoid\nfdcstart(fdc)\n\tstruct fdc_softc *fdc;\n{\n\n#ifdef DIAGNOSTIC\n\t/* only got here if controller's drive queue was inactive; should\n\t   be in idle state */\n\tif (fdc->sc_state != DEVIDLE) {\n\t\tprintf(\"fdcstart: not idle\\n\");\n\t\treturn;\n\t}\n#endif\n\t(void) fdcintr(fdc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"fdstrategy: controller inactive\\n\""
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdstart",
          "args": [
            "fd"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "fdstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
          "lines": "398-412",
          "snippet": "void\nfdstart(fd)\n\tstruct fd_softc *fd;\n{\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\tint active = (fdc->sc_link.fdlink.sc_drives.tqh_first != NULL);\n\n\t/* Link into controller queue. */\n\tfd->sc_q.b_active = 1;\n\tTAILQ_INSERT_TAIL(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);\n\n\t/* If controller not already active, start it. */\n\tif (!active)\n\t\tfdcstart(fdc);\n}",
          "includes": [
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void fdstart",
            "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
            "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid fdstart;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nvoid\nfdstart(fd)\n\tstruct fd_softc *fd;\n{\n\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\tint active = (fdc->sc_link.fdlink.sc_drives.tqh_first != NULL);\n\n\t/* Link into controller queue. */\n\tfd->sc_q.b_active = 1;\n\tTAILQ_INSERT_TAIL(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);\n\n\t/* If controller not already active, start it. */\n\tif (!active)\n\t\tfdcstart(fdc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "fd_motor_off",
            "fd"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disksort",
          "args": [
            "&fd->sc_q",
            "bp"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "howmany",
          "args": [
            "bp->b_bcount",
            "DEV_BSIZE"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FDUNIT",
          "args": [
            "bp->b_dev"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define b_cylin b_resid\n#define B_FORMAT B_XXX\n\nstruct cfdriver fd_cd = {\n\tNULL, \"fd\", DV_DISK\n};\nvoid fdstrategy;\nvoid fdstart;\nvoid fd_motor_off;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\nint nvraminfo, drive;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nvoid\nfdstrategy(bp)\n\tregister struct buf *bp;\t/* IO operation to perform */\n{\n\tstruct fd_softc *fd = fd_cd.cd_devs[FDUNIT(bp->b_dev)];\n\tint sz;\n \tint s;\n\tint fd_bsize = 128 << fd->sc_type->secsize;\n\tint bf = fd_bsize / DEV_BSIZE;\n\n\t/* Valid unit, controller, and request? */\n\tif (bp->b_blkno < 0 ||\n\t    (((bp->b_blkno % bf) != 0 ||\n\t      (bp->b_bcount % fd_bsize) != 0) &&\n\t     (bp->b_flags & B_FORMAT) == 0)) {\n\t\tbp->b_error = EINVAL;\n\t\tgoto bad;\n\t}\n\n\t/* If it's a null transfer, return immediately. */\n\tif (bp->b_bcount == 0)\n\t\tgoto done;\n\n\tsz = howmany(bp->b_bcount, DEV_BSIZE);\n\n\tif (bp->b_blkno + sz > fd->sc_type->size * bf) {\n\t\tsz = fd->sc_type->size * bf - bp->b_blkno;\n\t\tif (sz == 0)\n\t\t\t/* If exactly at end of disk, return EOF. */\n\t\t\tgoto done;\n\t\tif (sz < 0) {\n\t\t\t/* If past end of disk, return EINVAL. */\n\t\t\tbp->b_error = EINVAL;\n\t\t\tgoto bad;\n\t\t}\n\t\t/* Otherwise, truncate request. */\n\t\tbp->b_bcount = sz << DEV_BSHIFT;\n\t}\n\n \tbp->b_cylin = bp->b_blkno / (fd_bsize / DEV_BSIZE) / fd->sc_type->seccyl;\n\n#ifdef FD_DEBUG\n\tprintf(\"fdstrategy: b_blkno %d b_bcount %d blkno %d cylin %d sz %d\\n\",\n\t    bp->b_blkno, bp->b_bcount, fd->sc_blkno, bp->b_cylin, sz);\n#endif\n\n\t/* Queue transfer on drive, activate drive and controller if idle. */\n\ts = splbio();\n\tdisksort(&fd->sc_q, bp);\n\tuntimeout(fd_motor_off, fd); /* a good idea */\n\tif (!fd->sc_q.b_active)\n\t\tfdstart(fd);\n#ifdef DIAGNOSTIC\n\telse {\n\t\tstruct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;\n\t\tif (fdc->sc_state == DEVIDLE) {\n\t\t\tprintf(\"fdstrategy: controller inactive\\n\");\n\t\t\tfdcstart(fdc);\n\t\t}\n\t}\n#endif\n\tsplx(s);\n\treturn;\n\nbad:\n\tbp->b_flags |= B_ERROR;\ndone:\n\t/* Toss transfer; we're done early. */\n\tbp->b_resid = bp->b_bcount;\n\tbiodone(bp);\n}"
  },
  {
    "function_name": "fdattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
    "lines": "222-279",
    "snippet": "void\nfdattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct fdc_softc *fdc = (void *)parent;\n\tstruct fd_softc *fd = (void *)self;\n\tstruct fdc_attach_args *fa = aux;\n\tstruct fd_type *type = fa->fa_deftype;\n\tint drive = fa->fa_drive;\n\n\tif (!type || (fa->fa_flags & 0x10)) {\n\t\t/* The config has overridden this. */\n\t\tswitch (fa->fa_flags & 0x07) {\n\t\tcase 1:\t/* 2.88MB */\n\t\t\ttype = &fd_types[7];\n\t\t\tbreak;\n\t\tcase 2:\t/* 1.44MB */\n\t\t\ttype = &fd_types[0];\n\t\t\tbreak;\n\t\tcase 3: /* 1.2MB */\n\t\t\ttype = &fd_types[1];\n\t\t\tbreak;\n\t\tcase 4: /* 720K */\n\t\t\ttype = &fd_types[4];\n\t\t\tbreak;\n\t\tcase 5: /* 360K */\n\t\t\ttype = &fd_types[3];\n\t\t\tbreak;\n\t\tcase 6:\t/* 1.2 MB japanese format */\n\t\t\ttype = &fd_types[8];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (type)\n\t\tprintf(\": %s %d cyl, %d head, %d sec\\n\", type->name,\n\t\t    type->tracks, type->heads, type->sectrac);\n\telse\n\t\tprintf(\": density unknown\\n\");\n\n\tfd->sc_cylin = -1;\n\tfd->sc_drive = drive;\n\tfd->sc_deftype = type;\n\tfdc->sc_type[drive] = FDC_TYPE_DISK;\n\tfdc->sc_link.fdlink.sc_fd[drive] = fd;\n\n\t/*\n\t * Initialize and attach the disk structure.\n\t */\n\tfd->sc_dk.dk_name = fd->sc_dev.dv_xname;\n\tfd->sc_dk.dk_driver = &fddkdriver;\n\tdisk_attach(&fd->sc_dk);\n\n\tdk_establish(&fd->sc_dk, &fd->sc_dev);\n\t/* Needed to power off if the motor is on when we halt. */\n\tfd->sc_sdhook = shutdownhook_establish(fd_motor_off, fd);\n}",
    "includes": [
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tcyl\tfdc->sc_status[1]"
    ],
    "globals_used": [
      "struct fd_type fd_types[] = {\n        { 18,2,36,2,0xff,0xcf,0x1b,0x6c,80,2880,1,FDC_500KBPS,\"1.44MB\"    }, /* 1.44MB diskette */\n        { 15,2,30,2,0xff,0xdf,0x1b,0x54,80,2400,1,FDC_500KBPS, \"1.2MB\"    }, /* 1.2 MB AT-diskettes */\n        {  9,2,18,2,0xff,0xdf,0x23,0x50,40, 720,2,FDC_300KBPS, \"360KB/AT\" }, /* 360kB in 1.2MB drive */\n        {  9,2,18,2,0xff,0xdf,0x2a,0x50,40, 720,1,FDC_250KBPS, \"360KB/PC\" }, /* 360kB PC diskettes */\n        {  9,2,18,2,0xff,0xdf,0x2a,0x50,80,1440,1,FDC_250KBPS, \"720KB\"    }, /* 3.5\" 720kB diskette */\n        {  9,2,18,2,0xff,0xdf,0x23,0x50,80,1440,1,FDC_300KBPS, \"720KB/x\"  }, /* 720kB in 1.2MB drive */\n        {  9,2,18,2,0xff,0xdf,0x2a,0x50,40, 720,2,FDC_250KBPS, \"360KB/x\"  }, /* 360kB in 720kB drive */\n\t{ 36,2,72,2,0xff,0xaf,0x1b,0x54,80,5760,1,FDC_500KBPS,\"2.88MB\"    },  /* 2.88MB diskette */\n\t{  8,2,16,3,0xff,0xdf,0x35,0x74,77,1232,1,FDC_500KBPS,\"1.2MB/[1024bytes/sector]\" }\t/* 1.2 MB japanese format */\n};",
      "void fdattach",
      "struct dkdriver fddkdriver = { fdstrategy };",
      "void fd_motor_off",
      "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
      "int nvraminfo, drive;",
      "__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "fd_motor_off",
            "fd"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dk_establish",
          "args": [
            "&fd->sc_dk",
            "&fd->sc_dev"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_attach",
          "args": [
            "&fd->sc_dk"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": density unknown\\n\""
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tcyl\tfdc->sc_status[1]\n\nstruct fd_type fd_types[] = {\n        { 18,2,36,2,0xff,0xcf,0x1b,0x6c,80,2880,1,FDC_500KBPS,\"1.44MB\"    }, /* 1.44MB diskette */\n        { 15,2,30,2,0xff,0xdf,0x1b,0x54,80,2400,1,FDC_500KBPS, \"1.2MB\"    }, /* 1.2 MB AT-diskettes */\n        {  9,2,18,2,0xff,0xdf,0x23,0x50,40, 720,2,FDC_300KBPS, \"360KB/AT\" }, /* 360kB in 1.2MB drive */\n        {  9,2,18,2,0xff,0xdf,0x2a,0x50,40, 720,1,FDC_250KBPS, \"360KB/PC\" }, /* 360kB PC diskettes */\n        {  9,2,18,2,0xff,0xdf,0x2a,0x50,80,1440,1,FDC_250KBPS, \"720KB\"    }, /* 3.5\" 720kB diskette */\n        {  9,2,18,2,0xff,0xdf,0x23,0x50,80,1440,1,FDC_300KBPS, \"720KB/x\"  }, /* 720kB in 1.2MB drive */\n        {  9,2,18,2,0xff,0xdf,0x2a,0x50,40, 720,2,FDC_250KBPS, \"360KB/x\"  }, /* 360kB in 720kB drive */\n\t{ 36,2,72,2,0xff,0xaf,0x1b,0x54,80,5760,1,FDC_500KBPS,\"2.88MB\"    },  /* 2.88MB diskette */\n\t{  8,2,16,3,0xff,0xdf,0x35,0x74,77,1232,1,FDC_500KBPS,\"1.2MB/[1024bytes/sector]\" }\t/* 1.2 MB japanese format */\n};\nvoid fdattach;\nstruct dkdriver fddkdriver = { fdstrategy };\nvoid fd_motor_off;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\nint nvraminfo, drive;\n__inline struct fd_type *\nfd_dev_to_type(fd, dev)\n\tstruct fd_softc *fd;\n\nvoid\nfdattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct fdc_softc *fdc = (void *)parent;\n\tstruct fd_softc *fd = (void *)self;\n\tstruct fdc_attach_args *fa = aux;\n\tstruct fd_type *type = fa->fa_deftype;\n\tint drive = fa->fa_drive;\n\n\tif (!type || (fa->fa_flags & 0x10)) {\n\t\t/* The config has overridden this. */\n\t\tswitch (fa->fa_flags & 0x07) {\n\t\tcase 1:\t/* 2.88MB */\n\t\t\ttype = &fd_types[7];\n\t\t\tbreak;\n\t\tcase 2:\t/* 1.44MB */\n\t\t\ttype = &fd_types[0];\n\t\t\tbreak;\n\t\tcase 3: /* 1.2MB */\n\t\t\ttype = &fd_types[1];\n\t\t\tbreak;\n\t\tcase 4: /* 720K */\n\t\t\ttype = &fd_types[4];\n\t\t\tbreak;\n\t\tcase 5: /* 360K */\n\t\t\ttype = &fd_types[3];\n\t\t\tbreak;\n\t\tcase 6:\t/* 1.2 MB japanese format */\n\t\t\ttype = &fd_types[8];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (type)\n\t\tprintf(\": %s %d cyl, %d head, %d sec\\n\", type->name,\n\t\t    type->tracks, type->heads, type->sectrac);\n\telse\n\t\tprintf(\": density unknown\\n\");\n\n\tfd->sc_cylin = -1;\n\tfd->sc_drive = drive;\n\tfd->sc_deftype = type;\n\tfdc->sc_type[drive] = FDC_TYPE_DISK;\n\tfdc->sc_link.fdlink.sc_fd[drive] = fd;\n\n\t/*\n\t * Initialize and attach the disk structure.\n\t */\n\tfd->sc_dk.dk_name = fd->sc_dev.dv_xname;\n\tfd->sc_dk.dk_driver = &fddkdriver;\n\tdisk_attach(&fd->sc_dk);\n\n\tdk_establish(&fd->sc_dk, &fd->sc_dev);\n\t/* Needed to power off if the motor is on when we halt. */\n\tfd->sc_sdhook = shutdownhook_establish(fd_motor_off, fd);\n}"
  },
  {
    "function_name": "fdprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fd.c",
    "lines": "160-217",
    "snippet": "int\nfdprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct fdc_softc *fdc = (void *)parent;\n\tstruct cfdata *cf = match;\n\tstruct fdc_attach_args *fa = aux;\n\tint drive = fa->fa_drive;\n\tbus_space_tag_t iot = fdc->sc_iot;\n\tbus_space_handle_t ioh = fdc->sc_ioh;\n\tint n;\n\n\tif (cf->cf_loc[0] != -1 && cf->cf_loc[0] != drive)\n\t\treturn 0;\n\t/*\n\t * XXX\n\t * This is to work around some odd interactions between this driver\n\t * and SMC Ethernet cards.\n\t */\n\tif (cf->cf_loc[0] == -1 && drive >= 2)\n\t\treturn 0;\n\n\t/*\n\t * We want to keep the flags config gave us.\n\t */\n\tfa->fa_flags = cf->cf_flags;\n\n\t/* select drive and turn on motor */\n\tbus_space_write_1(iot, ioh, fdout, drive | FDO_FRST | FDO_MOEN(drive));\n\t/* wait for motor to spin up */\n\tdelay(250000);\n\tout_fdc(iot, ioh, NE7CMD_RECAL);\n\tout_fdc(iot, ioh, drive);\n\t/* wait for recalibrate */\n\tdelay(2000000);\n\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\tn = fdcresult(fdc);\n#ifdef FD_DEBUG\n\t{\n\t\tint i;\n\t\tprintf(\"fdprobe: status\");\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\" %x\", fdc->sc_status[i]);\n\t\tprintf(\"\\n\");\n\t}\n#endif\n\n\t/* turn off motor */\n\tdelay(250000);\n\tbus_space_write_1(iot, ioh, fdout, FDO_FRST);\n\n\t/* flags & 0x20 forces the drive to be found even if it won't probe */\n\tif (!(fa->fa_flags & 0x20) && (n != 2 || (fdc->sc_status[0] & 0xf8) != 0x20))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include <dev/isa/fdlink.h>",
      "#include <i386/isa/nvram.h>",
      "#include <dev/isa/fdreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/ioctl_fd.h>",
      "#include <machine/intr.h>",
      "#include <machine/conf.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/queue.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/mtio.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/disk.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int fdprobe",
      "struct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;",
      "int nvraminfo, drive;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "fdout",
            "FDO_FRST"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "250000"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdcresult",
          "args": [
            "fdc"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "fdcresult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
          "lines": "220-246",
          "snippet": "int\nfdcresult(fdc)\n\tstruct fdc_softc *fdc;\n{\n\tbus_space_tag_t iot = fdc->sc_iot;\n\tbus_space_handle_t ioh = fdc->sc_ioh;\n\tu_char i;\n\tint j = 100000, n = 0;\n\n\tfor (; j; j--) {\n\t\ti = bus_space_read_1(iot, ioh, fdsts) &\n\t\t    (NE7_DIO | NE7_RQM | NE7_CB);\n\t\tif (i == NE7_RQM)\n\t\t\treturn n;\n\t\tif (i == (NE7_DIO | NE7_RQM | NE7_CB)) {\n\t\t\tif (n >= sizeof(fdc->sc_status)) {\n\t\t\t\tlog(LOG_ERR, \"fdcresult: overrun\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfdc->sc_status[n++] =\n\t\t\t    bus_space_read_1(iot, ioh, fddata);\n\t\t}\n\t\tdelay(10);\n\t}\n\tlog(LOG_ERR, \"fdcresult: timeout\\n\");\n\treturn -1;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nfdcresult(fdc)\n\tstruct fdc_softc *fdc;\n{\n\tbus_space_tag_t iot = fdc->sc_iot;\n\tbus_space_handle_t ioh = fdc->sc_ioh;\n\tu_char i;\n\tint j = 100000, n = 0;\n\n\tfor (; j; j--) {\n\t\ti = bus_space_read_1(iot, ioh, fdsts) &\n\t\t    (NE7_DIO | NE7_RQM | NE7_CB);\n\t\tif (i == NE7_RQM)\n\t\t\treturn n;\n\t\tif (i == (NE7_DIO | NE7_RQM | NE7_CB)) {\n\t\t\tif (n >= sizeof(fdc->sc_status)) {\n\t\t\t\tlog(LOG_ERR, \"fdcresult: overrun\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfdc->sc_status[n++] =\n\t\t\t    bus_space_read_1(iot, ioh, fddata);\n\t\t}\n\t\tdelay(10);\n\t}\n\tlog(LOG_ERR, \"fdcresult: timeout\\n\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "out_fdc",
          "args": [
            "iot",
            "ioh",
            "NE7CMD_SENSEI"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "out_fdc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/fdc.c",
          "lines": "248-264",
          "snippet": "int\nout_fdc(iot, ioh, x)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tu_char x;\n{\n\tint i = 100000;\n\n\twhile ((bus_space_read_1(iot, ioh, fdsts) & NE7_DIO) && i-- > 0);\n\tif (i <= 0)\n\t\treturn -1;\n\twhile ((bus_space_read_1(iot, ioh, fdsts) & NE7_RQM) == 0 && i-- > 0);\n\tif (i <= 0)\n\t\treturn -1;\n\tbus_space_write_1(iot, ioh, fddata, x);\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include <dev/isa/fdlink.h>",
            "#include <i386/isa/nvram.h>",
            "#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */",
            "#include <dev/isa/fdreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/ioctl_fd.h>",
            "#include <machine/intr.h>",
            "#include <machine/conf.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/queue.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mtio.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/disk.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/ic/mc146818reg.h>\t\t\t/* for NVRAM access */\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nout_fdc(iot, ioh, x)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tu_char x;\n{\n\tint i = 100000;\n\n\twhile ((bus_space_read_1(iot, ioh, fdsts) & NE7_DIO) && i-- > 0);\n\tif (i <= 0)\n\t\treturn -1;\n\twhile ((bus_space_read_1(iot, ioh, fdsts) & NE7_RQM) == 0 && i-- > 0);\n\tif (i <= 0)\n\t\treturn -1;\n\tbus_space_write_1(iot, ioh, fddata, x);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "fdout",
            "drive | FDO_FRST | FDO_MOEN(drive)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FDO_MOEN",
          "args": [
            "drive"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/fdlink.h>\n#include <i386/isa/nvram.h>\n#include <dev/isa/fdreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/ioctl_fd.h>\n#include <machine/intr.h>\n#include <machine/conf.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/queue.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/mtio.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/disk.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint fdprobe;\nstruct fd_type *\nfd_nvtotype(fdc, nvraminfo, drive)\n\tchar *fdc;\nint nvraminfo, drive;\n\nint\nfdprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct fdc_softc *fdc = (void *)parent;\n\tstruct cfdata *cf = match;\n\tstruct fdc_attach_args *fa = aux;\n\tint drive = fa->fa_drive;\n\tbus_space_tag_t iot = fdc->sc_iot;\n\tbus_space_handle_t ioh = fdc->sc_ioh;\n\tint n;\n\n\tif (cf->cf_loc[0] != -1 && cf->cf_loc[0] != drive)\n\t\treturn 0;\n\t/*\n\t * XXX\n\t * This is to work around some odd interactions between this driver\n\t * and SMC Ethernet cards.\n\t */\n\tif (cf->cf_loc[0] == -1 && drive >= 2)\n\t\treturn 0;\n\n\t/*\n\t * We want to keep the flags config gave us.\n\t */\n\tfa->fa_flags = cf->cf_flags;\n\n\t/* select drive and turn on motor */\n\tbus_space_write_1(iot, ioh, fdout, drive | FDO_FRST | FDO_MOEN(drive));\n\t/* wait for motor to spin up */\n\tdelay(250000);\n\tout_fdc(iot, ioh, NE7CMD_RECAL);\n\tout_fdc(iot, ioh, drive);\n\t/* wait for recalibrate */\n\tdelay(2000000);\n\tout_fdc(iot, ioh, NE7CMD_SENSEI);\n\tn = fdcresult(fdc);\n#ifdef FD_DEBUG\n\t{\n\t\tint i;\n\t\tprintf(\"fdprobe: status\");\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\" %x\", fdc->sc_status[i]);\n\t\tprintf(\"\\n\");\n\t}\n#endif\n\n\t/* turn off motor */\n\tdelay(250000);\n\tbus_space_write_1(iot, ioh, fdout, FDO_FRST);\n\n\t/* flags & 0x20 forces the drive to be found even if it won't probe */\n\tif (!(fa->fa_flags & 0x20) && (n != 2 || (fdc->sc_status[0] & 0xf8) != 0x20))\n\t\treturn 0;\n\n\treturn 1;\n}"
  }
]