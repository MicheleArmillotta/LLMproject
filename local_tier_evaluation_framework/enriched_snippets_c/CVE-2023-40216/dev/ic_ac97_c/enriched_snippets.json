[
  {
    "function_name": "ac97_mixer_get_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ac97.c",
    "lines": "694-764",
    "snippet": "int\nac97_mixer_get_port(codec_if, cp)\n\tstruct ac97_codec_if *codec_if;\n\tmixer_ctrl_t *cp;\n{\n\tstruct ac97_softc *as = (struct ac97_softc *)codec_if;\n\tstruct ac97_source_info *si = &as->source_info[cp->dev];\n\tu_int16_t mask;\n\tu_int16_t val;\n\tint error;\n\n\tif (cp->dev < 0 || cp->dev >= as->num_source_info)\n\t\treturn (EINVAL);\n\n\tif (cp->type != si->type)\n\t\treturn (EINVAL);\n\n\terror = as->hostIf->read(as->hostIf->arg, si->reg, &val);\n\tif (error)\n\t\treturn (error);\n\n\tDPRINTFN(5, (\"read(%x) = %x\\n\", si->reg, val));\n\n\tmask = (1 << si->bits) - 1;\n\n\tswitch (cp->type) {\n\tcase AUDIO_MIXER_ENUM:\n\t\tcp->un.ord = (val >> si->ofs) & mask;\n\t\tDPRINTFN(4, (\"AUDIO_MIXER_ENUM: %x %d %x %d\\n\", val, si->ofs, mask, cp->un.ord));\n\t\tbreak;\n\tcase AUDIO_MIXER_VALUE:\n\t{\n\t\tstruct audio_mixer_value *value = si->info;\n\t\tu_int16_t  l, r;\n\n\t\tif ((cp->un.value.num_channels <= 0) ||\n\t\t    (cp->un.value.num_channels > value->num_channels)) \n\t\t\treturn (EINVAL);\n\n\t\tif (value->num_channels == 1) {\n\t\t\tl = r = (val >> si->ofs) & mask;\n\t\t} else {\n\t\t\tl = (val >> si->ofs) & mask;\n\t\t\tr = (val >> (si->ofs + 8)) & mask;\n\t\t}\n\n\t\tl = (l << (8 - si->bits));\n\t\tr = (r << (8 - si->bits));\n\t\tif (!si->polarity) {\n\t\t\tl = 255 - l;\n\t\t\tr = 255 - r;\n\t\t}\n\n\t\t/* The EAP driver averages l and r for stereo\n\t\t   channels that are requested in MONO mode. Does this\n\t\t   make sense? */\n\t\tif (cp->un.value.num_channels == 1) {\n\t\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = l;\n\t\t} else if (cp->un.value.num_channels == 2) {\n\t\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = l;\n\t\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = r;\n\t\t}\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/ac97.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct ac97_source_info {\n\tchar *class;\n\tchar *device;\n\tchar *qualifier;\n\tint  type;\n\n\tvoid *info;\n\tint  info_size;\n\n\tu_int8_t  reg;\n\tu_int8_t  bits:3;\n\tu_int8_t  ofs:4;\n\tu_int8_t  mute:1;\n\tu_int8_t  polarity:1;   /* Does 0 == MAX or MIN */\n\n\tint  prev;\n\tint  next;\t\n\tint  mixer_class;\n} source_info[] = {\n\t{ AudioCinputs ,            NULL,           NULL,    AUDIO_MIXER_CLASS,\n\t},\n\t{ AudioCoutputs,            NULL,           NULL,    AUDIO_MIXER_CLASS,\n\t},\n\t{ AudioCrecord ,            NULL,           NULL,    AUDIO_MIXER_CLASS,\n\t},\n\t/* Stereo master volume*/\n\t{ AudioCoutputs,     AudioNmaster,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_stereo), \n\t  AC97_REG_MASTER_VOLUME, 5, 0, 1,\n\t},\n\t/* Mono volume */\n\t{ AudioCoutputs,       AudioNmono,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_mono),\n\t  AC97_REG_MASTER_VOLUME_MONO, 6, 0, 1,\n\t},\n\t{ AudioCoutputs,       AudioNmono,AudioNsource,   AUDIO_MIXER_ENUM,\n\t  WRAP(ac97_mono_select),\n\t  AC97_REG_GP, 1, 9, 0,\n\t},\n\t/* Headphone volume */\n\t{ AudioCoutputs,  AudioNheadphone,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_stereo),\n\t  AC97_REG_HEADPHONE_VOLUME, 6, 0, 1,\n\t},\n\t/* Tone */\n\t{ AudioCoutputs,           \"tone\",        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_stereo),\n\t  AC97_REG_MASTER_TONE, 4, 0, 0,\n\t},\n\t/* PC Beep Volume */\n\t{ AudioCinputs,     AudioNspeaker,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_mono), \n\t  AC97_REG_PCBEEP_VOLUME, 4, 1, 1,\n\t},\n\t/* Phone */\n\t{ AudioCinputs,           \"phone\",        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_mono), \n\t  AC97_REG_PHONE_VOLUME, 5, 0, 1,\n\t},\n\t/* Mic Volume */\n\t{ AudioCinputs,  AudioNmicrophone,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_mono), \n\t  AC97_REG_MIC_VOLUME, 5, 0, 1,\n\t},\n\t{ AudioCinputs,  AudioNmicrophone, AudioNpreamp,   AUDIO_MIXER_ENUM,\n\t  WRAP(ac97_on_off),\n\t  AC97_REG_MIC_VOLUME, 1, 6, 0,\n\t},\n\t{ AudioCinputs,  AudioNmicrophone, AudioNsource,   AUDIO_MIXER_ENUM,\n\t  WRAP(ac97_mic_select),\n\t  AC97_REG_GP, 1, 8, 0,\n\t},\n\t/* Line in Volume */\n\t{ AudioCinputs,        AudioNline,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_stereo),\n\t  AC97_REG_LINEIN_VOLUME, 5, 0, 1,\n\t},\n\t/* CD Volume */\n\t{ AudioCinputs,          AudioNcd,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_stereo),\n\t  AC97_REG_CD_VOLUME, 5, 0, 1,\n\t},\n\t/* Video Volume */\n\t{ AudioCinputs,           \"video\",        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_stereo),\n\t  AC97_REG_VIDEO_VOLUME, 5, 0, 1,\n\t},\n\t/* AUX volume */\n\t{ AudioCinputs,         AudioNaux,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_stereo),\n\t  AC97_REG_AUX_VOLUME, 5, 0, 1,\n\t},\n\t/* PCM out volume */\n\t{ AudioCinputs,         AudioNdac,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_stereo),\n\t  AC97_REG_PCMOUT_VOLUME, 5, 0, 1,\n\t},\n\t/* Record Source - some logic for this is hard coded - see below */\n\t{ AudioCrecord,      AudioNsource,        NULL,    AUDIO_MIXER_ENUM,\n\t  WRAP(ac97_source),\n\t  AC97_REG_RECORD_SELECT, 3, 0, 0,\n\t},\n\t/* Record Gain */\n\t{ AudioCrecord,      AudioNvolume,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_stereo),\n\t  AC97_REG_RECORD_GAIN, 4, 0, 1,\n\t},\n\t/* Record Gain mic */\n\t{ AudioCrecord,  AudioNmicrophone,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_mono), \n\t  AC97_REG_RECORD_GAIN_MIC, 4, 0, 1, 1,\n\t},\n\t/* */\n\t{ AudioCoutputs,   AudioNloudness,        NULL,    AUDIO_MIXER_ENUM,\n\t  WRAP(ac97_on_off),\n\t  AC97_REG_GP, 1, 12, 0,\n\t},\n\t{ AudioCoutputs,    AudioNspatial,        NULL,    AUDIO_MIXER_ENUM,\n\t  WRAP(ac97_on_off),\n\t  AC97_REG_GP, 1, 13, 0,\n\t},\n\t{ AudioCoutputs,    AudioNspatial,    \"center\",    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_mono), \n\t  AC97_REG_3D_CONTROL, 4, 8, 0, 1,\n\t},\n\t{ AudioCoutputs,    AudioNspatial,     \"depth\",    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_mono), \n\t  AC97_REG_3D_CONTROL, 4, 0, 0, 1,\n\t},\n\n\t/* Missing features: Simulated Stereo, POP, Loopback mode */\n} ;",
      "int ac97_mixer_get_port"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "4",
            "(\"AUDIO_MIXER_ENUM: %x %d %x %d\\n\", val, si->ofs, mask, cp->un.ord)"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"read(%x) = %x\\n\", si->reg, val)"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "as->hostIf->read",
          "args": [
            "as->hostIf->arg",
            "si->reg",
            "&val"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ac97.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct ac97_source_info {\n\tchar *class;\n\tchar *device;\n\tchar *qualifier;\n\tint  type;\n\n\tvoid *info;\n\tint  info_size;\n\n\tu_int8_t  reg;\n\tu_int8_t  bits:3;\n\tu_int8_t  ofs:4;\n\tu_int8_t  mute:1;\n\tu_int8_t  polarity:1;   /* Does 0 == MAX or MIN */\n\n\tint  prev;\n\tint  next;\t\n\tint  mixer_class;\n} source_info[] = {\n\t{ AudioCinputs ,            NULL,           NULL,    AUDIO_MIXER_CLASS,\n\t},\n\t{ AudioCoutputs,            NULL,           NULL,    AUDIO_MIXER_CLASS,\n\t},\n\t{ AudioCrecord ,            NULL,           NULL,    AUDIO_MIXER_CLASS,\n\t},\n\t/* Stereo master volume*/\n\t{ AudioCoutputs,     AudioNmaster,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_stereo), \n\t  AC97_REG_MASTER_VOLUME, 5, 0, 1,\n\t},\n\t/* Mono volume */\n\t{ AudioCoutputs,       AudioNmono,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_mono),\n\t  AC97_REG_MASTER_VOLUME_MONO, 6, 0, 1,\n\t},\n\t{ AudioCoutputs,       AudioNmono,AudioNsource,   AUDIO_MIXER_ENUM,\n\t  WRAP(ac97_mono_select),\n\t  AC97_REG_GP, 1, 9, 0,\n\t},\n\t/* Headphone volume */\n\t{ AudioCoutputs,  AudioNheadphone,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_stereo),\n\t  AC97_REG_HEADPHONE_VOLUME, 6, 0, 1,\n\t},\n\t/* Tone */\n\t{ AudioCoutputs,           \"tone\",        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_stereo),\n\t  AC97_REG_MASTER_TONE, 4, 0, 0,\n\t},\n\t/* PC Beep Volume */\n\t{ AudioCinputs,     AudioNspeaker,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_mono), \n\t  AC97_REG_PCBEEP_VOLUME, 4, 1, 1,\n\t},\n\t/* Phone */\n\t{ AudioCinputs,           \"phone\",        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_mono), \n\t  AC97_REG_PHONE_VOLUME, 5, 0, 1,\n\t},\n\t/* Mic Volume */\n\t{ AudioCinputs,  AudioNmicrophone,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_mono), \n\t  AC97_REG_MIC_VOLUME, 5, 0, 1,\n\t},\n\t{ AudioCinputs,  AudioNmicrophone, AudioNpreamp,   AUDIO_MIXER_ENUM,\n\t  WRAP(ac97_on_off),\n\t  AC97_REG_MIC_VOLUME, 1, 6, 0,\n\t},\n\t{ AudioCinputs,  AudioNmicrophone, AudioNsource,   AUDIO_MIXER_ENUM,\n\t  WRAP(ac97_mic_select),\n\t  AC97_REG_GP, 1, 8, 0,\n\t},\n\t/* Line in Volume */\n\t{ AudioCinputs,        AudioNline,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_stereo),\n\t  AC97_REG_LINEIN_VOLUME, 5, 0, 1,\n\t},\n\t/* CD Volume */\n\t{ AudioCinputs,          AudioNcd,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_stereo),\n\t  AC97_REG_CD_VOLUME, 5, 0, 1,\n\t},\n\t/* Video Volume */\n\t{ AudioCinputs,           \"video\",        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_stereo),\n\t  AC97_REG_VIDEO_VOLUME, 5, 0, 1,\n\t},\n\t/* AUX volume */\n\t{ AudioCinputs,         AudioNaux,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_stereo),\n\t  AC97_REG_AUX_VOLUME, 5, 0, 1,\n\t},\n\t/* PCM out volume */\n\t{ AudioCinputs,         AudioNdac,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_stereo),\n\t  AC97_REG_PCMOUT_VOLUME, 5, 0, 1,\n\t},\n\t/* Record Source - some logic for this is hard coded - see below */\n\t{ AudioCrecord,      AudioNsource,        NULL,    AUDIO_MIXER_ENUM,\n\t  WRAP(ac97_source),\n\t  AC97_REG_RECORD_SELECT, 3, 0, 0,\n\t},\n\t/* Record Gain */\n\t{ AudioCrecord,      AudioNvolume,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_stereo),\n\t  AC97_REG_RECORD_GAIN, 4, 0, 1,\n\t},\n\t/* Record Gain mic */\n\t{ AudioCrecord,  AudioNmicrophone,        NULL,    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_mono), \n\t  AC97_REG_RECORD_GAIN_MIC, 4, 0, 1, 1,\n\t},\n\t/* */\n\t{ AudioCoutputs,   AudioNloudness,        NULL,    AUDIO_MIXER_ENUM,\n\t  WRAP(ac97_on_off),\n\t  AC97_REG_GP, 1, 12, 0,\n\t},\n\t{ AudioCoutputs,    AudioNspatial,        NULL,    AUDIO_MIXER_ENUM,\n\t  WRAP(ac97_on_off),\n\t  AC97_REG_GP, 1, 13, 0,\n\t},\n\t{ AudioCoutputs,    AudioNspatial,    \"center\",    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_mono), \n\t  AC97_REG_3D_CONTROL, 4, 8, 0, 1,\n\t},\n\t{ AudioCoutputs,    AudioNspatial,     \"depth\",    AUDIO_MIXER_VALUE,\n\t  WRAP(ac97_volume_mono), \n\t  AC97_REG_3D_CONTROL, 4, 0, 0, 1,\n\t},\n\n\t/* Missing features: Simulated Stereo, POP, Loopback mode */\n} ;\nint ac97_mixer_get_port;\n\nint\nac97_mixer_get_port(codec_if, cp)\n\tstruct ac97_codec_if *codec_if;\n\tmixer_ctrl_t *cp;\n{\n\tstruct ac97_softc *as = (struct ac97_softc *)codec_if;\n\tstruct ac97_source_info *si = &as->source_info[cp->dev];\n\tu_int16_t mask;\n\tu_int16_t val;\n\tint error;\n\n\tif (cp->dev < 0 || cp->dev >= as->num_source_info)\n\t\treturn (EINVAL);\n\n\tif (cp->type != si->type)\n\t\treturn (EINVAL);\n\n\terror = as->hostIf->read(as->hostIf->arg, si->reg, &val);\n\tif (error)\n\t\treturn (error);\n\n\tDPRINTFN(5, (\"read(%x) = %x\\n\", si->reg, val));\n\n\tmask = (1 << si->bits) - 1;\n\n\tswitch (cp->type) {\n\tcase AUDIO_MIXER_ENUM:\n\t\tcp->un.ord = (val >> si->ofs) & mask;\n\t\tDPRINTFN(4, (\"AUDIO_MIXER_ENUM: %x %d %x %d\\n\", val, si->ofs, mask, cp->un.ord));\n\t\tbreak;\n\tcase AUDIO_MIXER_VALUE:\n\t{\n\t\tstruct audio_mixer_value *value = si->info;\n\t\tu_int16_t  l, r;\n\n\t\tif ((cp->un.value.num_channels <= 0) ||\n\t\t    (cp->un.value.num_channels > value->num_channels)) \n\t\t\treturn (EINVAL);\n\n\t\tif (value->num_channels == 1) {\n\t\t\tl = r = (val >> si->ofs) & mask;\n\t\t} else {\n\t\t\tl = (val >> si->ofs) & mask;\n\t\t\tr = (val >> (si->ofs + 8)) & mask;\n\t\t}\n\n\t\tl = (l << (8 - si->bits));\n\t\tr = (r << (8 - si->bits));\n\t\tif (!si->polarity) {\n\t\t\tl = 255 - l;\n\t\t\tr = 255 - r;\n\t\t}\n\n\t\t/* The EAP driver averages l and r for stereo\n\t\t   channels that are requested in MONO mode. Does this\n\t\t   make sense? */\n\t\tif (cp->un.value.num_channels == 1) {\n\t\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = l;\n\t\t} else if (cp->un.value.num_channels == 2) {\n\t\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = l;\n\t\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = r;\n\t\t}\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "ac97_get_portnum_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ac97.c",
    "lines": "675-692",
    "snippet": "int\nac97_get_portnum_by_name(codec_if, class, device, qualifier)\n\tstruct ac97_codec_if *codec_if;\n\tchar *class, *device, *qualifier;\n{\n\tstruct ac97_softc *as = (struct ac97_softc *)codec_if;\n\tint idx;\n\n\tfor (idx = 0; idx < as->num_source_info; idx++) {\n\t\tstruct ac97_source_info *si = &as->source_info[idx];\n\t\tif (ac97_str_equal(class, si->class) &&\n\t\t    ac97_str_equal(device, si->device) &&\n\t\t    ac97_str_equal(qualifier, si->qualifier))\n\t\t\treturn (idx);\n\t}\n\n\treturn (-1);\n}",
    "includes": [
      "#include <dev/ic/ac97.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ac97_get_portnum_by_name",
      "int ac97_str_equal"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ac97_str_equal",
          "args": [
            "qualifier",
            "si->qualifier"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "ac97_str_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ac97.c",
          "lines": "374-379",
          "snippet": "int\nac97_str_equal(a, b)\n\tchar *a, *b;\n{\n\treturn ((a == b) || (a && b && (!strcmp(a, b))));\n}",
          "includes": [
            "#include <dev/ic/ac97.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ac97_str_equal"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ac97.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint ac97_str_equal;\n\nint\nac97_str_equal(a, b)\n\tchar *a, *b;\n{\n\treturn ((a == b) || (a && b && (!strcmp(a, b))));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/ac97.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint ac97_get_portnum_by_name;\nint ac97_str_equal;\n\nint\nac97_get_portnum_by_name(codec_if, class, device, qualifier)\n\tstruct ac97_codec_if *codec_if;\n\tchar *class, *device, *qualifier;\n{\n\tstruct ac97_softc *as = (struct ac97_softc *)codec_if;\n\tint idx;\n\n\tfor (idx = 0; idx < as->num_source_info; idx++) {\n\t\tstruct ac97_source_info *si = &as->source_info[idx];\n\t\tif (ac97_str_equal(class, si->class) &&\n\t\t    ac97_str_equal(device, si->device) &&\n\t\t    ac97_str_equal(qualifier, si->qualifier))\n\t\t\treturn (idx);\n\t}\n\n\treturn (-1);\n}"
  },
  {
    "function_name": "ac97_mixer_set_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ac97.c",
    "lines": "595-673",
    "snippet": "int\nac97_mixer_set_port(codec_if, cp)\n\tstruct ac97_codec_if *codec_if;\n\tmixer_ctrl_t *cp;\n{\n\tstruct ac97_softc *as = (struct ac97_softc *)codec_if;\n\tstruct ac97_source_info *si = &as->source_info[cp->dev];\n\tu_int16_t mask;\n\tu_int16_t val, newval;\n\tint error;\n\n\tif (cp->dev < 0 || cp->dev >= as->num_source_info)\n\t\treturn (EINVAL);\n\n\tif (cp->type != si->type)\n\t\treturn (EINVAL);\n\n\terror = as->hostIf->read(as->hostIf->arg, si->reg, &val);\n\tif (error)\n\t\treturn (error);\n\n\tDPRINTFN(5, (\"read(%x) = %x\\n\", si->reg, val));\n\n\tmask = (1 << si->bits) - 1;\n\n\tswitch (cp->type) {\n\tcase AUDIO_MIXER_ENUM:\n\t\tif (cp->un.ord > mask || cp->un.ord < 0)\n\t\t\treturn (EINVAL);\n\n\t\tnewval = (cp->un.ord << si->ofs);\n\t\tif (si->reg == AC97_REG_RECORD_SELECT) {\n\t\t\tnewval |= (newval << (8 + si->ofs));\n\t\t\tmask |= (mask << 8);\n\t\t}\n\t\tbreak;\n\tcase AUDIO_MIXER_VALUE:\n\t{\n\t\tstruct audio_mixer_value *value = si->info;\n\t\tu_int16_t  l, r;\n\n\t\tif ((cp->un.value.num_channels <= 0) ||\n\t\t    (cp->un.value.num_channels > value->num_channels)) \n\t\t\treturn (EINVAL);\n\n\t\tif (cp->un.value.num_channels == 1) {\n\t\t\tl = r = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t\t} else {\n\t\t\tl = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\t\tr = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t\t}\n\n\t\tif (!si->polarity) {\n\t\t\tl = 255 - l;\n\t\t\tr = 255 - r;\n\t\t}\n\t\t\n\t\tl = l >> (8 - si->bits);\n\t\tr = r >> (8 - si->bits);\n\n\t\tnewval = ((l & mask) << si->ofs);\n\t\tif (value->num_channels == 2) {\n\t\t\tnewval |= ((r & mask) << (si->ofs + 8));\n\t\t\tmask |= (mask << 8);\n\t\t}\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\tmask = mask << si->ofs;\n\terror = as->hostIf->write(as->hostIf->arg, si->reg, (val & ~mask) | newval);\n\tif (error)\n\t\treturn (error);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/ac97.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define AC97_REG_RECORD_SELECT        0x1a"
    ],
    "globals_used": [
      "int ac97_mixer_set_port"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "as->hostIf->write",
          "args": [
            "as->hostIf->arg",
            "si->reg",
            "(val & ~mask) | newval"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"read(%x) = %x\\n\", si->reg, val)"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "as->hostIf->read",
          "args": [
            "as->hostIf->arg",
            "si->reg",
            "&val"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ac97.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define AC97_REG_RECORD_SELECT        0x1a\n\nint ac97_mixer_set_port;\n\nint\nac97_mixer_set_port(codec_if, cp)\n\tstruct ac97_codec_if *codec_if;\n\tmixer_ctrl_t *cp;\n{\n\tstruct ac97_softc *as = (struct ac97_softc *)codec_if;\n\tstruct ac97_source_info *si = &as->source_info[cp->dev];\n\tu_int16_t mask;\n\tu_int16_t val, newval;\n\tint error;\n\n\tif (cp->dev < 0 || cp->dev >= as->num_source_info)\n\t\treturn (EINVAL);\n\n\tif (cp->type != si->type)\n\t\treturn (EINVAL);\n\n\terror = as->hostIf->read(as->hostIf->arg, si->reg, &val);\n\tif (error)\n\t\treturn (error);\n\n\tDPRINTFN(5, (\"read(%x) = %x\\n\", si->reg, val));\n\n\tmask = (1 << si->bits) - 1;\n\n\tswitch (cp->type) {\n\tcase AUDIO_MIXER_ENUM:\n\t\tif (cp->un.ord > mask || cp->un.ord < 0)\n\t\t\treturn (EINVAL);\n\n\t\tnewval = (cp->un.ord << si->ofs);\n\t\tif (si->reg == AC97_REG_RECORD_SELECT) {\n\t\t\tnewval |= (newval << (8 + si->ofs));\n\t\t\tmask |= (mask << 8);\n\t\t}\n\t\tbreak;\n\tcase AUDIO_MIXER_VALUE:\n\t{\n\t\tstruct audio_mixer_value *value = si->info;\n\t\tu_int16_t  l, r;\n\n\t\tif ((cp->un.value.num_channels <= 0) ||\n\t\t    (cp->un.value.num_channels > value->num_channels)) \n\t\t\treturn (EINVAL);\n\n\t\tif (cp->un.value.num_channels == 1) {\n\t\t\tl = r = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t\t} else {\n\t\t\tl = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\t\tr = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t\t}\n\n\t\tif (!si->polarity) {\n\t\t\tl = 255 - l;\n\t\t\tr = 255 - r;\n\t\t}\n\t\t\n\t\tl = l >> (8 - si->bits);\n\t\tr = r >> (8 - si->bits);\n\n\t\tnewval = ((l & mask) << si->ofs);\n\t\tif (value->num_channels == 2) {\n\t\t\tnewval |= ((r & mask) << (si->ofs + 8));\n\t\t\tmask |= (mask << 8);\n\t\t}\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\tmask = mask << si->ofs;\n\terror = as->hostIf->write(as->hostIf->arg, si->reg, (val & ~mask) | newval);\n\tif (error)\n\t\treturn (error);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "ac97_query_devinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ac97.c",
    "lines": "560-591",
    "snippet": "int \nac97_query_devinfo(codec_if, dip)\n\tstruct ac97_codec_if *codec_if;\n\tmixer_devinfo_t *dip;\n{\n\tstruct ac97_softc *as = (struct ac97_softc *)codec_if;\n\n\tif (dip->index < as->num_source_info) {\n\t\tstruct ac97_source_info *si = &as->source_info[dip->index];\n\t\tchar *name;\n\n\t\tdip->type = si->type;\n\t\tdip->mixer_class = si->mixer_class;\n\t\tdip->prev = si->prev;\n\t\tdip->next = si->next;\n\t\t\n\t\tif (si->qualifier)\n\t\t\tname = si->qualifier;\n\t\telse if (si->device)\n\t\t\tname = si->device;\n\t\telse if (si->class)\n\t\t\tname = si->class;\n\t\t\n\t\tif (name)\n\t\t\tstrcpy(dip->label.name, name);\n\n\t\tbcopy(si->info, &dip->un, si->info_size);\n\t\treturn (0);\n\t}\n\n\treturn (ENXIO);\n}",
    "includes": [
      "#include <dev/ic/ac97.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ac97_query_devinfo"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "si->info",
            "&dip->un",
            "si->info_size"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "name"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ac97.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint ac97_query_devinfo;\n\nint \nac97_query_devinfo(codec_if, dip)\n\tstruct ac97_codec_if *codec_if;\n\tmixer_devinfo_t *dip;\n{\n\tstruct ac97_softc *as = (struct ac97_softc *)codec_if;\n\n\tif (dip->index < as->num_source_info) {\n\t\tstruct ac97_source_info *si = &as->source_info[dip->index];\n\t\tchar *name;\n\n\t\tdip->type = si->type;\n\t\tdip->mixer_class = si->mixer_class;\n\t\tdip->prev = si->prev;\n\t\tdip->next = si->next;\n\t\t\n\t\tif (si->qualifier)\n\t\t\tname = si->qualifier;\n\t\telse if (si->device)\n\t\t\tname = si->device;\n\t\telse if (si->class)\n\t\t\tname = si->class;\n\t\t\n\t\tif (name)\n\t\t\tstrcpy(dip->label.name, name);\n\n\t\tbcopy(si->info, &dip->un, si->info_size);\n\t\treturn (0);\n\t}\n\n\treturn (ENXIO);\n}"
  },
  {
    "function_name": "ac97_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ac97.c",
    "lines": "476-557",
    "snippet": "int \nac97_attach(hostIf)\n\tstruct ac97_host_if *hostIf;\n{\n\tstruct ac97_softc *as;\n\tint error, i, j;\n\tu_int16_t id1, id2, caps;\n\tu_int32_t id;\n\tmixer_ctrl_t ctl;\n\n\tas = malloc(sizeof(struct ac97_softc), M_DEVBUF, M_WAITOK);\n\n\tif (!as) return (ENOMEM);\n\n\tas->codecIf.vtbl = &ac97civ;\n\tas->hostIf = hostIf;\n\n\tif ((error = hostIf->attach(hostIf->arg, &as->codecIf))) {\n\t\tfree (as, M_DEVBUF);\n\t\treturn (error);\n\t}\n\n\thostIf->reset(hostIf->arg);\n\tDELAY(1000);\n\n\thostIf->write(hostIf->arg, AC97_REG_POWER, 0);\n\thostIf->write(hostIf->arg, AC97_REG_RESET, 0);\n\tDELAY(10000);\n\n\tif ((error = hostIf->read(hostIf->arg, AC97_REG_VENDOR_ID1, &id1)))\n\t\treturn (error);\n\n\tif ((error = hostIf->read(hostIf->arg, AC97_REG_VENDOR_ID2, &id2)))\n\t\treturn (error);\n\n\tif ((error = hostIf->read(hostIf->arg, AC97_REG_RESET, &caps)))\n\t\treturn (error);\n\n\tid = (id1 << 16) | id2;\n\n\tprintf(\"ac97: codec id 0x%8x\", id);\n\tfor (i = 0; ac97codecid[i].id; i++) {\n\t\tif (ac97codecid[i].id == id) \n\t\t\tprintf(\" (%s)\", ac97codecid[i].name);\n\t}\n\tprintf(\"\\nac97: codec features \");\n\tfor (i = j = 0; i < 10; i++) {\n\t\tif (caps & (1 << i)) {\n\t\t\tprintf(\"%s%s\", j? \", \" : \"\", ac97feature[i]);\n\t\t\tj++;\n\t\t}\n\t}\n\n\tprintf(\"%s%s\\n\", j? \", \" : \"\", ac97enhancement[(caps >> 10) & 0x1f]);\n\n\tac97_setup_source_info(as);\n\n\t/* Just enable the DAC and master volumes by default */\n\tbzero(&ctl, sizeof(ctl));\n\n\tctl.type = AUDIO_MIXER_ENUM;\n\tctl.un.ord = 0;  /* off */\n\tctl.dev = ac97_get_portnum_by_name(&as->codecIf, AudioCoutputs,\n\t\t\t\t\t   AudioNmaster, AudioNmute);\n\tac97_mixer_set_port(&as->codecIf, &ctl);\n\tctl.dev = ac97_get_portnum_by_name(&as->codecIf, AudioCinputs,\n\t\t\t\t\t   AudioNdac, AudioNmute);\n\t\n\tac97_mixer_set_port(&as->codecIf, &ctl);\n\tctl.dev = ac97_get_portnum_by_name(&as->codecIf, AudioCrecord,\n\t\t\t\t\t   AudioNvolume, AudioNmute);\n\tac97_mixer_set_port(&as->codecIf, &ctl);\n\t\t\n\t\t\n\tctl.dev = ac97_get_portnum_by_name(&as->codecIf, AudioCrecord,\n\t\t\t\t\t   AudioNsource, NULL);\n\tctl.type = AUDIO_MIXER_ENUM;\n\tctl.un.ord = 0;\n\tac97_mixer_set_port(&as->codecIf, &ctl);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/ac97.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define AC97_REG_VENDOR_ID2           0x7e",
      "#define AC97_REG_VENDOR_ID1           0x7c",
      "#define AC97_REG_POWER                0x26",
      "#define AC97_REG_RESET                0x00"
    ],
    "globals_used": [
      "int ac97_mixer_set_port",
      "int ac97_get_portnum_by_name",
      "struct ac97_codec_if_vtbl ac97civ = {\n\tac97_mixer_get_port, \n\tac97_mixer_set_port,\n\tac97_query_devinfo,\n\tac97_get_portnum_by_name\n};",
      "static struct ac97_codecid {\n\tu_int32_t id;\n\tchar *name;\n} ac97codecid[] = {\n\t{ 0x414B4D00, \"Asahi Kasei AK4540\" \t},\n\t{ 0x43525900, \"Cirrus Logic CS4297\" \t},\n\t{ 0x83847600, \"SigmaTel STAC????\" \t},\n\t{ 0x83847604, \"SigmaTel STAC9701/3/4/5\" },\n\t{ 0x83847605, \"SigmaTel STAC9704\" \t},\n\t{ 0x83847608, \"SigmaTel STAC9708\" \t},\n\t{ 0x83847609, \"SigmaTel STAC9721\" \t},\n\t{ 0, \t      NULL\t\t\t}\n};",
      "static char *ac97enhancement[] = {\n\t\"No 3D Stereo\",\n\t\"Analog Devices Phat Stereo\",\n\t\"Creative\"\n\t\"National Semi 3D\",\n\t\"Yamaha Ymersion\",\n\t\"BBE 3D\",\n\t\"Crystal Semi 3D\"\n\t\"Qsound QXpander\",\n\t\"Spatializer 3D\",\n\t\"SRS 3D\",\n\t\"Platform Tech 3D\",\n\t\"AKM 3D\",\n\t\"Aureal\",\n\t\"AZTECH 3D\",\n\t\"Binaura 3D\",\n\t\"ESS Technology\",\n\t\"Harman International VMAx\",\n\t\"Nvidea 3D\",\n\t\"Philips Incredible Sound\",\n\t\"Texas Instruments' 3D\",\n\t\"VLSI Technology 3D\",\n\t\"TriTech 3D\",\n\t\"Realtek 3D\",\n\t\"Samsung 3D\",\n\t\"Wolfson Microelectronics 3D\",\n\t\"Delta Integration 3D\",\n\t\"SigmaTel 3D\",\n\t\"Unknown 3D\",\n\t\"Rockwell 3D\",\n\t\"Unknown 3D\",\n\t\"Unknown 3D\",\n\t\"Unknown 3D\",\n};",
      "static char *ac97feature[] = {\n\t\"mic channel\",\n\t\"reserved\",\n\t\"tone\",\n\t\"simulated stereo\",\n\t\"headphone\",\n\t\"bass boost\",\n\t\"18 bit DAC\",\n\t\"20 bit DAC\",\n\t\"18 bit ADC\",\n\t\"20 bit ADC\"\n};",
      "void ac97_setup_source_info"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ac97_mixer_set_port",
          "args": [
            "&as->codecIf",
            "&ctl"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "ac97_mixer_set_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ac97.c",
          "lines": "595-673",
          "snippet": "int\nac97_mixer_set_port(codec_if, cp)\n\tstruct ac97_codec_if *codec_if;\n\tmixer_ctrl_t *cp;\n{\n\tstruct ac97_softc *as = (struct ac97_softc *)codec_if;\n\tstruct ac97_source_info *si = &as->source_info[cp->dev];\n\tu_int16_t mask;\n\tu_int16_t val, newval;\n\tint error;\n\n\tif (cp->dev < 0 || cp->dev >= as->num_source_info)\n\t\treturn (EINVAL);\n\n\tif (cp->type != si->type)\n\t\treturn (EINVAL);\n\n\terror = as->hostIf->read(as->hostIf->arg, si->reg, &val);\n\tif (error)\n\t\treturn (error);\n\n\tDPRINTFN(5, (\"read(%x) = %x\\n\", si->reg, val));\n\n\tmask = (1 << si->bits) - 1;\n\n\tswitch (cp->type) {\n\tcase AUDIO_MIXER_ENUM:\n\t\tif (cp->un.ord > mask || cp->un.ord < 0)\n\t\t\treturn (EINVAL);\n\n\t\tnewval = (cp->un.ord << si->ofs);\n\t\tif (si->reg == AC97_REG_RECORD_SELECT) {\n\t\t\tnewval |= (newval << (8 + si->ofs));\n\t\t\tmask |= (mask << 8);\n\t\t}\n\t\tbreak;\n\tcase AUDIO_MIXER_VALUE:\n\t{\n\t\tstruct audio_mixer_value *value = si->info;\n\t\tu_int16_t  l, r;\n\n\t\tif ((cp->un.value.num_channels <= 0) ||\n\t\t    (cp->un.value.num_channels > value->num_channels)) \n\t\t\treturn (EINVAL);\n\n\t\tif (cp->un.value.num_channels == 1) {\n\t\t\tl = r = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t\t} else {\n\t\t\tl = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\t\tr = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t\t}\n\n\t\tif (!si->polarity) {\n\t\t\tl = 255 - l;\n\t\t\tr = 255 - r;\n\t\t}\n\t\t\n\t\tl = l >> (8 - si->bits);\n\t\tr = r >> (8 - si->bits);\n\n\t\tnewval = ((l & mask) << si->ofs);\n\t\tif (value->num_channels == 2) {\n\t\t\tnewval |= ((r & mask) << (si->ofs + 8));\n\t\t\tmask |= (mask << 8);\n\t\t}\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\tmask = mask << si->ofs;\n\terror = as->hostIf->write(as->hostIf->arg, si->reg, (val & ~mask) | newval);\n\tif (error)\n\t\treturn (error);\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/ac97.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define AC97_REG_RECORD_SELECT        0x1a"
          ],
          "globals_used": [
            "int ac97_mixer_set_port"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ac97.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define AC97_REG_RECORD_SELECT        0x1a\n\nint ac97_mixer_set_port;\n\nint\nac97_mixer_set_port(codec_if, cp)\n\tstruct ac97_codec_if *codec_if;\n\tmixer_ctrl_t *cp;\n{\n\tstruct ac97_softc *as = (struct ac97_softc *)codec_if;\n\tstruct ac97_source_info *si = &as->source_info[cp->dev];\n\tu_int16_t mask;\n\tu_int16_t val, newval;\n\tint error;\n\n\tif (cp->dev < 0 || cp->dev >= as->num_source_info)\n\t\treturn (EINVAL);\n\n\tif (cp->type != si->type)\n\t\treturn (EINVAL);\n\n\terror = as->hostIf->read(as->hostIf->arg, si->reg, &val);\n\tif (error)\n\t\treturn (error);\n\n\tDPRINTFN(5, (\"read(%x) = %x\\n\", si->reg, val));\n\n\tmask = (1 << si->bits) - 1;\n\n\tswitch (cp->type) {\n\tcase AUDIO_MIXER_ENUM:\n\t\tif (cp->un.ord > mask || cp->un.ord < 0)\n\t\t\treturn (EINVAL);\n\n\t\tnewval = (cp->un.ord << si->ofs);\n\t\tif (si->reg == AC97_REG_RECORD_SELECT) {\n\t\t\tnewval |= (newval << (8 + si->ofs));\n\t\t\tmask |= (mask << 8);\n\t\t}\n\t\tbreak;\n\tcase AUDIO_MIXER_VALUE:\n\t{\n\t\tstruct audio_mixer_value *value = si->info;\n\t\tu_int16_t  l, r;\n\n\t\tif ((cp->un.value.num_channels <= 0) ||\n\t\t    (cp->un.value.num_channels > value->num_channels)) \n\t\t\treturn (EINVAL);\n\n\t\tif (cp->un.value.num_channels == 1) {\n\t\t\tl = r = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t\t} else {\n\t\t\tl = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\t\tr = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t\t}\n\n\t\tif (!si->polarity) {\n\t\t\tl = 255 - l;\n\t\t\tr = 255 - r;\n\t\t}\n\t\t\n\t\tl = l >> (8 - si->bits);\n\t\tr = r >> (8 - si->bits);\n\n\t\tnewval = ((l & mask) << si->ofs);\n\t\tif (value->num_channels == 2) {\n\t\t\tnewval |= ((r & mask) << (si->ofs + 8));\n\t\t\tmask |= (mask << 8);\n\t\t}\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\tmask = mask << si->ofs;\n\terror = as->hostIf->write(as->hostIf->arg, si->reg, (val & ~mask) | newval);\n\tif (error)\n\t\treturn (error);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ac97_get_portnum_by_name",
          "args": [
            "&as->codecIf",
            "AudioCrecord",
            "AudioNsource",
            "NULL"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "ac97_get_portnum_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ac97.c",
          "lines": "675-692",
          "snippet": "int\nac97_get_portnum_by_name(codec_if, class, device, qualifier)\n\tstruct ac97_codec_if *codec_if;\n\tchar *class, *device, *qualifier;\n{\n\tstruct ac97_softc *as = (struct ac97_softc *)codec_if;\n\tint idx;\n\n\tfor (idx = 0; idx < as->num_source_info; idx++) {\n\t\tstruct ac97_source_info *si = &as->source_info[idx];\n\t\tif (ac97_str_equal(class, si->class) &&\n\t\t    ac97_str_equal(device, si->device) &&\n\t\t    ac97_str_equal(qualifier, si->qualifier))\n\t\t\treturn (idx);\n\t}\n\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/ic/ac97.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ac97_get_portnum_by_name",
            "int ac97_str_equal"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ac97.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint ac97_get_portnum_by_name;\nint ac97_str_equal;\n\nint\nac97_get_portnum_by_name(codec_if, class, device, qualifier)\n\tstruct ac97_codec_if *codec_if;\n\tchar *class, *device, *qualifier;\n{\n\tstruct ac97_softc *as = (struct ac97_softc *)codec_if;\n\tint idx;\n\n\tfor (idx = 0; idx < as->num_source_info; idx++) {\n\t\tstruct ac97_source_info *si = &as->source_info[idx];\n\t\tif (ac97_str_equal(class, si->class) &&\n\t\t    ac97_str_equal(device, si->device) &&\n\t\t    ac97_str_equal(qualifier, si->qualifier))\n\t\t\treturn (idx);\n\t}\n\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&ctl",
            "sizeof(ctl)"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ac97_setup_source_info",
          "args": [
            "as"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "ac97_setup_source_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ac97.c",
          "lines": "381-474",
          "snippet": "void\nac97_setup_source_info(as)\n\tstruct ac97_softc *as;\n{\n\tint idx, ouridx;\n\tstruct ac97_source_info *si, *si2; \n\n\tfor (idx = 0, ouridx = 0; idx < SOURCE_INFO_SIZE; idx++) {\n\t\tsi = &as->source_info[ouridx];\n\n\t\tbcopy(&source_info[idx], si, sizeof(*si));\n\n\t\tswitch (si->type) {\n\t\tcase AUDIO_MIXER_CLASS:\n\t\t        si->mixer_class = ouridx;\n\t\t\touridx++;\n\t\t\tbreak;\n\t\tcase AUDIO_MIXER_VALUE:\n\t\t\t/* Todo - Test to see if it works */\n\t\t\touridx++;\n\n\t\t\t/* Add an entry for mute, if necessary */\n\t\t\tif (si->mute) {\n\t\t\t\tsi = &as->source_info[ouridx];\n\t\t\t\tbcopy(&source_info[idx], si, sizeof(*si));\n\t\t\t\tsi->qualifier = AudioNmute;\n\t\t\t\tsi->type = AUDIO_MIXER_ENUM;\n\t\t\t\tsi->info = &ac97_on_off;\n\t\t\t\tsi->info_size = sizeof(ac97_on_off);\n\t\t\t\tsi->bits = 1;\n\t\t\t\tsi->ofs = 15;\n\t\t\t\tsi->mute = 0;\n\t\t\t\tsi->polarity = 0;\n\t\t\t\touridx++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIO_MIXER_ENUM:\n\t\t\t/* Todo - Test to see if it works */\n\t\t\touridx++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (\"ac97: shouldn't get here\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tas->num_source_info = ouridx;\n\n\tfor (idx = 0; idx < as->num_source_info; idx++) {\n\t\tint idx2, previdx;\n\n\t\tsi = &as->source_info[idx];\n\n\t\t/* Find mixer class */\n\t\tfor (idx2 = 0; idx2 < as->num_source_info; idx2++) {\n\t\t\tsi2 = &as->source_info[idx2];\n\n\t\t\tif (si2->type == AUDIO_MIXER_CLASS && \n\t\t\t    ac97_str_equal(si->class,\n\t\t\t\t\t   si2->class)) {\n\t\t\t\tsi->mixer_class = idx2;\n\t\t\t}\n\t\t}\n\n\n\t\t/* Setup prev and next pointers */\n\t\tif (si->prev != 0)\n\t\t\tcontinue;\n\n\t\tif (si->qualifier)\n\t\t\tcontinue;\n\n\t\tsi->prev = AUDIO_MIXER_LAST;\n\t\tprevidx = idx;\n\n\t\tfor (idx2 = 0; idx2 < as->num_source_info; idx2++) {\n\t\t\tif (idx2 == idx)\n\t\t\t\tcontinue;\n\n\t\t\tsi2 = &as->source_info[idx2];\n\n\t\t\tif (!si2->prev &&\n\t\t\t    ac97_str_equal(si->class, si2->class) &&\n\t\t\t    ac97_str_equal(si->device, si2->device)) {\n\t\t\t\tas->source_info[previdx].next = idx2;\n\t\t\t\tas->source_info[idx2].prev = previdx;\n\t\t\t\t\n\t\t\t\tprevidx = idx2;\n\t\t\t}\n\t\t}\n\n\t\tas->source_info[previdx].next = AUDIO_MIXER_LAST;\n\t}\n}",
          "includes": [
            "#include <dev/ic/ac97.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define SOURCE_INFO_SIZE (sizeof(source_info)/sizeof(source_info[0]))"
          ],
          "globals_used": [
            "static struct audio_mixer_enum ac97_on_off = { 2,\n\t\t\t\t\t       { { { AudioNoff } , 0 },\n\t\t\t\t\t         { { AudioNon }  , 1 } }};",
            "int ac97_str_equal",
            "void ac97_setup_source_info"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ac97.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SOURCE_INFO_SIZE (sizeof(source_info)/sizeof(source_info[0]))\n\nstatic struct audio_mixer_enum ac97_on_off = { 2,\n\t\t\t\t\t       { { { AudioNoff } , 0 },\n\t\t\t\t\t         { { AudioNon }  , 1 } }};\nint ac97_str_equal;\nvoid ac97_setup_source_info;\n\nvoid\nac97_setup_source_info(as)\n\tstruct ac97_softc *as;\n{\n\tint idx, ouridx;\n\tstruct ac97_source_info *si, *si2; \n\n\tfor (idx = 0, ouridx = 0; idx < SOURCE_INFO_SIZE; idx++) {\n\t\tsi = &as->source_info[ouridx];\n\n\t\tbcopy(&source_info[idx], si, sizeof(*si));\n\n\t\tswitch (si->type) {\n\t\tcase AUDIO_MIXER_CLASS:\n\t\t        si->mixer_class = ouridx;\n\t\t\touridx++;\n\t\t\tbreak;\n\t\tcase AUDIO_MIXER_VALUE:\n\t\t\t/* Todo - Test to see if it works */\n\t\t\touridx++;\n\n\t\t\t/* Add an entry for mute, if necessary */\n\t\t\tif (si->mute) {\n\t\t\t\tsi = &as->source_info[ouridx];\n\t\t\t\tbcopy(&source_info[idx], si, sizeof(*si));\n\t\t\t\tsi->qualifier = AudioNmute;\n\t\t\t\tsi->type = AUDIO_MIXER_ENUM;\n\t\t\t\tsi->info = &ac97_on_off;\n\t\t\t\tsi->info_size = sizeof(ac97_on_off);\n\t\t\t\tsi->bits = 1;\n\t\t\t\tsi->ofs = 15;\n\t\t\t\tsi->mute = 0;\n\t\t\t\tsi->polarity = 0;\n\t\t\t\touridx++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIO_MIXER_ENUM:\n\t\t\t/* Todo - Test to see if it works */\n\t\t\touridx++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (\"ac97: shouldn't get here\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tas->num_source_info = ouridx;\n\n\tfor (idx = 0; idx < as->num_source_info; idx++) {\n\t\tint idx2, previdx;\n\n\t\tsi = &as->source_info[idx];\n\n\t\t/* Find mixer class */\n\t\tfor (idx2 = 0; idx2 < as->num_source_info; idx2++) {\n\t\t\tsi2 = &as->source_info[idx2];\n\n\t\t\tif (si2->type == AUDIO_MIXER_CLASS && \n\t\t\t    ac97_str_equal(si->class,\n\t\t\t\t\t   si2->class)) {\n\t\t\t\tsi->mixer_class = idx2;\n\t\t\t}\n\t\t}\n\n\n\t\t/* Setup prev and next pointers */\n\t\tif (si->prev != 0)\n\t\t\tcontinue;\n\n\t\tif (si->qualifier)\n\t\t\tcontinue;\n\n\t\tsi->prev = AUDIO_MIXER_LAST;\n\t\tprevidx = idx;\n\n\t\tfor (idx2 = 0; idx2 < as->num_source_info; idx2++) {\n\t\t\tif (idx2 == idx)\n\t\t\t\tcontinue;\n\n\t\t\tsi2 = &as->source_info[idx2];\n\n\t\t\tif (!si2->prev &&\n\t\t\t    ac97_str_equal(si->class, si2->class) &&\n\t\t\t    ac97_str_equal(si->device, si2->device)) {\n\t\t\t\tas->source_info[previdx].next = idx2;\n\t\t\t\tas->source_info[idx2].prev = previdx;\n\t\t\t\t\n\t\t\t\tprevidx = idx2;\n\t\t\t}\n\t\t}\n\n\t\tas->source_info[previdx].next = AUDIO_MIXER_LAST;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s%s\\n\"",
            "j? \", \" : \"\"",
            "ac97enhancement[(caps >> 10) & 0x1f]"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hostIf->read",
          "args": [
            "hostIf->arg",
            "AC97_REG_RESET",
            "&caps"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostIf->read",
          "args": [
            "hostIf->arg",
            "AC97_REG_VENDOR_ID2",
            "&id2"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostIf->read",
          "args": [
            "hostIf->arg",
            "AC97_REG_VENDOR_ID1",
            "&id1"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10000"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostIf->write",
          "args": [
            "hostIf->arg",
            "AC97_REG_RESET",
            "0"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostIf->write",
          "args": [
            "hostIf->arg",
            "AC97_REG_POWER",
            "0"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostIf->reset",
          "args": [
            "hostIf->arg"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "as",
            "M_DEVBUF"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1617-1633",
          "snippet": "void\nwdc_free_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint s;\n\n\tif (wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\t(*wdc->free_hw)(chp);\n\ts = splbio();\n\tchp->ch_flags &= ~WDCF_ACTIVE;\n\tTAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);\n\txfer->c_flags &= ~C_INUSE;\n\tLIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_free_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint s;\n\n\tif (wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\t(*wdc->free_hw)(chp);\n\ts = splbio();\n\tchp->ch_flags &= ~WDCF_ACTIVE;\n\tTAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);\n\txfer->c_flags &= ~C_INUSE;\n\tLIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hostIf->attach",
          "args": [
            "hostIf->arg",
            "&as->codecIf"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct ac97_softc)",
            "M_DEVBUF",
            "M_WAITOK"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/ac97.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define AC97_REG_VENDOR_ID2           0x7e\n#define AC97_REG_VENDOR_ID1           0x7c\n#define AC97_REG_POWER                0x26\n#define AC97_REG_RESET                0x00\n\nint ac97_mixer_set_port;\nint ac97_get_portnum_by_name;\nstruct ac97_codec_if_vtbl ac97civ = {\n\tac97_mixer_get_port, \n\tac97_mixer_set_port,\n\tac97_query_devinfo,\n\tac97_get_portnum_by_name\n};\nstatic struct ac97_codecid {\n\tu_int32_t id;\n\tchar *name;\n} ac97codecid[] = {\n\t{ 0x414B4D00, \"Asahi Kasei AK4540\" \t},\n\t{ 0x43525900, \"Cirrus Logic CS4297\" \t},\n\t{ 0x83847600, \"SigmaTel STAC????\" \t},\n\t{ 0x83847604, \"SigmaTel STAC9701/3/4/5\" },\n\t{ 0x83847605, \"SigmaTel STAC9704\" \t},\n\t{ 0x83847608, \"SigmaTel STAC9708\" \t},\n\t{ 0x83847609, \"SigmaTel STAC9721\" \t},\n\t{ 0, \t      NULL\t\t\t}\n};\nstatic char *ac97enhancement[] = {\n\t\"No 3D Stereo\",\n\t\"Analog Devices Phat Stereo\",\n\t\"Creative\"\n\t\"National Semi 3D\",\n\t\"Yamaha Ymersion\",\n\t\"BBE 3D\",\n\t\"Crystal Semi 3D\"\n\t\"Qsound QXpander\",\n\t\"Spatializer 3D\",\n\t\"SRS 3D\",\n\t\"Platform Tech 3D\",\n\t\"AKM 3D\",\n\t\"Aureal\",\n\t\"AZTECH 3D\",\n\t\"Binaura 3D\",\n\t\"ESS Technology\",\n\t\"Harman International VMAx\",\n\t\"Nvidea 3D\",\n\t\"Philips Incredible Sound\",\n\t\"Texas Instruments' 3D\",\n\t\"VLSI Technology 3D\",\n\t\"TriTech 3D\",\n\t\"Realtek 3D\",\n\t\"Samsung 3D\",\n\t\"Wolfson Microelectronics 3D\",\n\t\"Delta Integration 3D\",\n\t\"SigmaTel 3D\",\n\t\"Unknown 3D\",\n\t\"Rockwell 3D\",\n\t\"Unknown 3D\",\n\t\"Unknown 3D\",\n\t\"Unknown 3D\",\n};\nstatic char *ac97feature[] = {\n\t\"mic channel\",\n\t\"reserved\",\n\t\"tone\",\n\t\"simulated stereo\",\n\t\"headphone\",\n\t\"bass boost\",\n\t\"18 bit DAC\",\n\t\"20 bit DAC\",\n\t\"18 bit ADC\",\n\t\"20 bit ADC\"\n};\nvoid ac97_setup_source_info;\n\nint \nac97_attach(hostIf)\n\tstruct ac97_host_if *hostIf;\n{\n\tstruct ac97_softc *as;\n\tint error, i, j;\n\tu_int16_t id1, id2, caps;\n\tu_int32_t id;\n\tmixer_ctrl_t ctl;\n\n\tas = malloc(sizeof(struct ac97_softc), M_DEVBUF, M_WAITOK);\n\n\tif (!as) return (ENOMEM);\n\n\tas->codecIf.vtbl = &ac97civ;\n\tas->hostIf = hostIf;\n\n\tif ((error = hostIf->attach(hostIf->arg, &as->codecIf))) {\n\t\tfree (as, M_DEVBUF);\n\t\treturn (error);\n\t}\n\n\thostIf->reset(hostIf->arg);\n\tDELAY(1000);\n\n\thostIf->write(hostIf->arg, AC97_REG_POWER, 0);\n\thostIf->write(hostIf->arg, AC97_REG_RESET, 0);\n\tDELAY(10000);\n\n\tif ((error = hostIf->read(hostIf->arg, AC97_REG_VENDOR_ID1, &id1)))\n\t\treturn (error);\n\n\tif ((error = hostIf->read(hostIf->arg, AC97_REG_VENDOR_ID2, &id2)))\n\t\treturn (error);\n\n\tif ((error = hostIf->read(hostIf->arg, AC97_REG_RESET, &caps)))\n\t\treturn (error);\n\n\tid = (id1 << 16) | id2;\n\n\tprintf(\"ac97: codec id 0x%8x\", id);\n\tfor (i = 0; ac97codecid[i].id; i++) {\n\t\tif (ac97codecid[i].id == id) \n\t\t\tprintf(\" (%s)\", ac97codecid[i].name);\n\t}\n\tprintf(\"\\nac97: codec features \");\n\tfor (i = j = 0; i < 10; i++) {\n\t\tif (caps & (1 << i)) {\n\t\t\tprintf(\"%s%s\", j? \", \" : \"\", ac97feature[i]);\n\t\t\tj++;\n\t\t}\n\t}\n\n\tprintf(\"%s%s\\n\", j? \", \" : \"\", ac97enhancement[(caps >> 10) & 0x1f]);\n\n\tac97_setup_source_info(as);\n\n\t/* Just enable the DAC and master volumes by default */\n\tbzero(&ctl, sizeof(ctl));\n\n\tctl.type = AUDIO_MIXER_ENUM;\n\tctl.un.ord = 0;  /* off */\n\tctl.dev = ac97_get_portnum_by_name(&as->codecIf, AudioCoutputs,\n\t\t\t\t\t   AudioNmaster, AudioNmute);\n\tac97_mixer_set_port(&as->codecIf, &ctl);\n\tctl.dev = ac97_get_portnum_by_name(&as->codecIf, AudioCinputs,\n\t\t\t\t\t   AudioNdac, AudioNmute);\n\t\n\tac97_mixer_set_port(&as->codecIf, &ctl);\n\tctl.dev = ac97_get_portnum_by_name(&as->codecIf, AudioCrecord,\n\t\t\t\t\t   AudioNvolume, AudioNmute);\n\tac97_mixer_set_port(&as->codecIf, &ctl);\n\t\t\n\t\t\n\tctl.dev = ac97_get_portnum_by_name(&as->codecIf, AudioCrecord,\n\t\t\t\t\t   AudioNsource, NULL);\n\tctl.type = AUDIO_MIXER_ENUM;\n\tctl.un.ord = 0;\n\tac97_mixer_set_port(&as->codecIf, &ctl);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "ac97_setup_source_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ac97.c",
    "lines": "381-474",
    "snippet": "void\nac97_setup_source_info(as)\n\tstruct ac97_softc *as;\n{\n\tint idx, ouridx;\n\tstruct ac97_source_info *si, *si2; \n\n\tfor (idx = 0, ouridx = 0; idx < SOURCE_INFO_SIZE; idx++) {\n\t\tsi = &as->source_info[ouridx];\n\n\t\tbcopy(&source_info[idx], si, sizeof(*si));\n\n\t\tswitch (si->type) {\n\t\tcase AUDIO_MIXER_CLASS:\n\t\t        si->mixer_class = ouridx;\n\t\t\touridx++;\n\t\t\tbreak;\n\t\tcase AUDIO_MIXER_VALUE:\n\t\t\t/* Todo - Test to see if it works */\n\t\t\touridx++;\n\n\t\t\t/* Add an entry for mute, if necessary */\n\t\t\tif (si->mute) {\n\t\t\t\tsi = &as->source_info[ouridx];\n\t\t\t\tbcopy(&source_info[idx], si, sizeof(*si));\n\t\t\t\tsi->qualifier = AudioNmute;\n\t\t\t\tsi->type = AUDIO_MIXER_ENUM;\n\t\t\t\tsi->info = &ac97_on_off;\n\t\t\t\tsi->info_size = sizeof(ac97_on_off);\n\t\t\t\tsi->bits = 1;\n\t\t\t\tsi->ofs = 15;\n\t\t\t\tsi->mute = 0;\n\t\t\t\tsi->polarity = 0;\n\t\t\t\touridx++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIO_MIXER_ENUM:\n\t\t\t/* Todo - Test to see if it works */\n\t\t\touridx++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (\"ac97: shouldn't get here\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tas->num_source_info = ouridx;\n\n\tfor (idx = 0; idx < as->num_source_info; idx++) {\n\t\tint idx2, previdx;\n\n\t\tsi = &as->source_info[idx];\n\n\t\t/* Find mixer class */\n\t\tfor (idx2 = 0; idx2 < as->num_source_info; idx2++) {\n\t\t\tsi2 = &as->source_info[idx2];\n\n\t\t\tif (si2->type == AUDIO_MIXER_CLASS && \n\t\t\t    ac97_str_equal(si->class,\n\t\t\t\t\t   si2->class)) {\n\t\t\t\tsi->mixer_class = idx2;\n\t\t\t}\n\t\t}\n\n\n\t\t/* Setup prev and next pointers */\n\t\tif (si->prev != 0)\n\t\t\tcontinue;\n\n\t\tif (si->qualifier)\n\t\t\tcontinue;\n\n\t\tsi->prev = AUDIO_MIXER_LAST;\n\t\tprevidx = idx;\n\n\t\tfor (idx2 = 0; idx2 < as->num_source_info; idx2++) {\n\t\t\tif (idx2 == idx)\n\t\t\t\tcontinue;\n\n\t\t\tsi2 = &as->source_info[idx2];\n\n\t\t\tif (!si2->prev &&\n\t\t\t    ac97_str_equal(si->class, si2->class) &&\n\t\t\t    ac97_str_equal(si->device, si2->device)) {\n\t\t\t\tas->source_info[previdx].next = idx2;\n\t\t\t\tas->source_info[idx2].prev = previdx;\n\t\t\t\t\n\t\t\t\tprevidx = idx2;\n\t\t\t}\n\t\t}\n\n\t\tas->source_info[previdx].next = AUDIO_MIXER_LAST;\n\t}\n}",
    "includes": [
      "#include <dev/ic/ac97.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define SOURCE_INFO_SIZE (sizeof(source_info)/sizeof(source_info[0]))"
    ],
    "globals_used": [
      "static struct audio_mixer_enum ac97_on_off = { 2,\n\t\t\t\t\t       { { { AudioNoff } , 0 },\n\t\t\t\t\t         { { AudioNon }  , 1 } }};",
      "int ac97_str_equal",
      "void ac97_setup_source_info"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ac97_str_equal",
          "args": [
            "si->device",
            "si2->device"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "ac97_str_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ac97.c",
          "lines": "374-379",
          "snippet": "int\nac97_str_equal(a, b)\n\tchar *a, *b;\n{\n\treturn ((a == b) || (a && b && (!strcmp(a, b))));\n}",
          "includes": [
            "#include <dev/ic/ac97.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ac97_str_equal"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ac97.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint ac97_str_equal;\n\nint\nac97_str_equal(a, b)\n\tchar *a, *b;\n{\n\treturn ((a == b) || (a && b && (!strcmp(a, b))));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ac97: shouldn't get here\\n\""
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "&source_info[idx]",
            "si",
            "sizeof(*si)"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/ac97.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SOURCE_INFO_SIZE (sizeof(source_info)/sizeof(source_info[0]))\n\nstatic struct audio_mixer_enum ac97_on_off = { 2,\n\t\t\t\t\t       { { { AudioNoff } , 0 },\n\t\t\t\t\t         { { AudioNon }  , 1 } }};\nint ac97_str_equal;\nvoid ac97_setup_source_info;\n\nvoid\nac97_setup_source_info(as)\n\tstruct ac97_softc *as;\n{\n\tint idx, ouridx;\n\tstruct ac97_source_info *si, *si2; \n\n\tfor (idx = 0, ouridx = 0; idx < SOURCE_INFO_SIZE; idx++) {\n\t\tsi = &as->source_info[ouridx];\n\n\t\tbcopy(&source_info[idx], si, sizeof(*si));\n\n\t\tswitch (si->type) {\n\t\tcase AUDIO_MIXER_CLASS:\n\t\t        si->mixer_class = ouridx;\n\t\t\touridx++;\n\t\t\tbreak;\n\t\tcase AUDIO_MIXER_VALUE:\n\t\t\t/* Todo - Test to see if it works */\n\t\t\touridx++;\n\n\t\t\t/* Add an entry for mute, if necessary */\n\t\t\tif (si->mute) {\n\t\t\t\tsi = &as->source_info[ouridx];\n\t\t\t\tbcopy(&source_info[idx], si, sizeof(*si));\n\t\t\t\tsi->qualifier = AudioNmute;\n\t\t\t\tsi->type = AUDIO_MIXER_ENUM;\n\t\t\t\tsi->info = &ac97_on_off;\n\t\t\t\tsi->info_size = sizeof(ac97_on_off);\n\t\t\t\tsi->bits = 1;\n\t\t\t\tsi->ofs = 15;\n\t\t\t\tsi->mute = 0;\n\t\t\t\tsi->polarity = 0;\n\t\t\t\touridx++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIO_MIXER_ENUM:\n\t\t\t/* Todo - Test to see if it works */\n\t\t\touridx++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (\"ac97: shouldn't get here\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tas->num_source_info = ouridx;\n\n\tfor (idx = 0; idx < as->num_source_info; idx++) {\n\t\tint idx2, previdx;\n\n\t\tsi = &as->source_info[idx];\n\n\t\t/* Find mixer class */\n\t\tfor (idx2 = 0; idx2 < as->num_source_info; idx2++) {\n\t\t\tsi2 = &as->source_info[idx2];\n\n\t\t\tif (si2->type == AUDIO_MIXER_CLASS && \n\t\t\t    ac97_str_equal(si->class,\n\t\t\t\t\t   si2->class)) {\n\t\t\t\tsi->mixer_class = idx2;\n\t\t\t}\n\t\t}\n\n\n\t\t/* Setup prev and next pointers */\n\t\tif (si->prev != 0)\n\t\t\tcontinue;\n\n\t\tif (si->qualifier)\n\t\t\tcontinue;\n\n\t\tsi->prev = AUDIO_MIXER_LAST;\n\t\tprevidx = idx;\n\n\t\tfor (idx2 = 0; idx2 < as->num_source_info; idx2++) {\n\t\t\tif (idx2 == idx)\n\t\t\t\tcontinue;\n\n\t\t\tsi2 = &as->source_info[idx2];\n\n\t\t\tif (!si2->prev &&\n\t\t\t    ac97_str_equal(si->class, si2->class) &&\n\t\t\t    ac97_str_equal(si->device, si2->device)) {\n\t\t\t\tas->source_info[previdx].next = idx2;\n\t\t\t\tas->source_info[idx2].prev = previdx;\n\t\t\t\t\n\t\t\t\tprevidx = idx2;\n\t\t\t}\n\t\t}\n\n\t\tas->source_info[previdx].next = AUDIO_MIXER_LAST;\n\t}\n}"
  },
  {
    "function_name": "ac97_str_equal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ac97.c",
    "lines": "374-379",
    "snippet": "int\nac97_str_equal(a, b)\n\tchar *a, *b;\n{\n\treturn ((a == b) || (a && b && (!strcmp(a, b))));\n}",
    "includes": [
      "#include <dev/ic/ac97.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ac97_str_equal"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a",
            "b"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ac97.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint ac97_str_equal;\n\nint\nac97_str_equal(a, b)\n\tchar *a, *b;\n{\n\treturn ((a == b) || (a && b && (!strcmp(a, b))));\n}"
  }
]