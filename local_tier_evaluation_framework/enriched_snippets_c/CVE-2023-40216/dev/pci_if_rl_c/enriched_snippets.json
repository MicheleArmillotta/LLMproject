[
  {
    "function_name": "rl_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "1532-1540",
    "snippet": "void\nrl_tick(v)\n\tvoid *v;\n{\n\tstruct rl_softc *sc = v;\n\n\tmii_tick(&sc->sc_mii);\n\ttimeout(rl_tick, sc, hz);\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rl_tick"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "rl_tick",
            "sc",
            "hz"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mii_tick",
          "args": [
            "&sc->sc_mii"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "mii_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "192-201",
          "snippet": "void\nmii_tick(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_TICK);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_tick(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_TICK);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_tick;\n\nvoid\nrl_tick(v)\n\tvoid *v;\n{\n\tstruct rl_softc *sc = v;\n\n\tmii_tick(&sc->sc_mii);\n\ttimeout(rl_tick, sc, hz);\n}"
  },
  {
    "function_name": "rl_miibus_statchg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "1525-1530",
    "snippet": "void\nrl_miibus_statchg(self)\n\tstruct device *self;\n{\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rl_miibus_statchg"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_miibus_statchg;\n\nvoid\nrl_miibus_statchg(self)\n\tstruct device *self;\n{\n\treturn;\n}"
  },
  {
    "function_name": "rl_miibus_writereg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "1481-1523",
    "snippet": "void\nrl_miibus_writereg(self, phy, reg, val)\n\tstruct device *self;\n\tint phy, reg, val;\n{\n\tstruct rl_softc *sc = (struct rl_softc *)self;\n\tstruct rl_mii_frame frame;\n\tu_int16_t rl8139_reg = 0;\n\n\tif (sc->rl_type == RL_8139) {\n\t\tif (phy)\n\t\t\treturn;\n\n\t\tswitch (reg) {\n\t\tcase MII_BMCR:\n\t\t\trl8139_reg = RL_BMCR;\n\t\t\tbreak;\n\t\tcase MII_BMSR:\n\t\t\trl8139_reg = RL_BMSR;\n\t\t\tbreak;\n\t\tcase MII_ANAR:\n\t\t\trl8139_reg = RL_ANAR;\n\t\t\tbreak;\n\t\tcase MII_ANER:\n\t\t\trl8139_reg = RL_ANER;\n\t\t\tbreak;\n\t\tcase MII_ANLPAR:\n\t\t\trl8139_reg = RL_LPAR;\n\t\t\tbreak;\n\t\tcase MII_PHYIDR1:\n\t\tcase MII_PHYIDR2:\n\t\t\treturn;\n\t\t}\n\t\tCSR_WRITE_2(sc, rl8139_reg, val);\n\t\treturn;\n\t}\n\n\tbzero((char *)&frame, sizeof(frame));\n\tframe.mii_phyaddr = phy;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = val;\n\trl_mii_writereg(sc, &frame);\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int rl_mii_writereg",
      "void rl_miibus_writereg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rl_mii_writereg",
          "args": [
            "sc",
            "&frame"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "rl_mii_writereg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "443-487",
          "snippet": "int rl_mii_writereg(sc, frame)\n\tstruct rl_softc\t\t*sc;\n\tstruct rl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ts;\n\n\ts = splimp();\n\t/*\n\t * Set up frame for TX.\n\t */\n\n\tframe->mii_stdelim = RL_MII_STARTDELIM;\n\tframe->mii_opcode = RL_MII_WRITEOP;\n\tframe->mii_turnaround = RL_MII_TURNAROUND;\n\t\n\t/*\n \t * Turn on data output.\n\t */\n\tMII_SET(RL_MII_DIR);\n\n\trl_mii_sync(sc);\n\n\trl_mii_send(sc, frame->mii_stdelim, 2);\n\trl_mii_send(sc, frame->mii_opcode, 2);\n\trl_mii_send(sc, frame->mii_phyaddr, 5);\n\trl_mii_send(sc, frame->mii_regaddr, 5);\n\trl_mii_send(sc, frame->mii_turnaround, 2);\n\trl_mii_send(sc, frame->mii_data, 16);\n\n\t/* Idle bit. */\n\tMII_SET(RL_MII_CLK);\n\tDELAY(1);\n\tMII_CLR(RL_MII_CLK);\n\tDELAY(1);\n\n\t/*\n\t * Turn off xmit.\n\t */\n\tMII_CLR(RL_MII_DIR);\n\n\tsplx(s);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_mii_sync",
            "void rl_mii_send",
            "int rl_mii_writereg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_mii_sync;\nvoid rl_mii_send;\nint rl_mii_writereg;\n\nint rl_mii_writereg(sc, frame)\n\tstruct rl_softc\t\t*sc;\n\tstruct rl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ts;\n\n\ts = splimp();\n\t/*\n\t * Set up frame for TX.\n\t */\n\n\tframe->mii_stdelim = RL_MII_STARTDELIM;\n\tframe->mii_opcode = RL_MII_WRITEOP;\n\tframe->mii_turnaround = RL_MII_TURNAROUND;\n\t\n\t/*\n \t * Turn on data output.\n\t */\n\tMII_SET(RL_MII_DIR);\n\n\trl_mii_sync(sc);\n\n\trl_mii_send(sc, frame->mii_stdelim, 2);\n\trl_mii_send(sc, frame->mii_opcode, 2);\n\trl_mii_send(sc, frame->mii_phyaddr, 5);\n\trl_mii_send(sc, frame->mii_regaddr, 5);\n\trl_mii_send(sc, frame->mii_turnaround, 2);\n\trl_mii_send(sc, frame->mii_data, 16);\n\n\t/* Idle bit. */\n\tMII_SET(RL_MII_CLK);\n\tDELAY(1);\n\tMII_CLR(RL_MII_CLK);\n\tDELAY(1);\n\n\t/*\n\t * Turn off xmit.\n\t */\n\tMII_CLR(RL_MII_DIR);\n\n\tsplx(s);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&frame",
            "sizeof(frame)"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "rl8139_reg",
            "val"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint rl_mii_writereg;\nvoid rl_miibus_writereg;\n\nvoid\nrl_miibus_writereg(self, phy, reg, val)\n\tstruct device *self;\n\tint phy, reg, val;\n{\n\tstruct rl_softc *sc = (struct rl_softc *)self;\n\tstruct rl_mii_frame frame;\n\tu_int16_t rl8139_reg = 0;\n\n\tif (sc->rl_type == RL_8139) {\n\t\tif (phy)\n\t\t\treturn;\n\n\t\tswitch (reg) {\n\t\tcase MII_BMCR:\n\t\t\trl8139_reg = RL_BMCR;\n\t\t\tbreak;\n\t\tcase MII_BMSR:\n\t\t\trl8139_reg = RL_BMSR;\n\t\t\tbreak;\n\t\tcase MII_ANAR:\n\t\t\trl8139_reg = RL_ANAR;\n\t\t\tbreak;\n\t\tcase MII_ANER:\n\t\t\trl8139_reg = RL_ANER;\n\t\t\tbreak;\n\t\tcase MII_ANLPAR:\n\t\t\trl8139_reg = RL_LPAR;\n\t\t\tbreak;\n\t\tcase MII_PHYIDR1:\n\t\tcase MII_PHYIDR2:\n\t\t\treturn;\n\t\t}\n\t\tCSR_WRITE_2(sc, rl8139_reg, val);\n\t\treturn;\n\t}\n\n\tbzero((char *)&frame, sizeof(frame));\n\tframe.mii_phyaddr = phy;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = val;\n\trl_mii_writereg(sc, &frame);\n}"
  },
  {
    "function_name": "rl_miibus_readreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "1431-1479",
    "snippet": "int\nrl_miibus_readreg(self, phy, reg)\n\tstruct device *self;\n\tint phy, reg;\n{\n\tstruct rl_softc *sc = (struct rl_softc *)self;\n\tstruct rl_mii_frame frame;\n\tu_int16_t rl8139_reg;\n\n\tif (sc->rl_type == RL_8139) {\n\t\t/*\n\t \t* The RTL8139 PHY is mapped into PCI registers, unforunately\n\t \t* it has no phyid, or phyaddr, so assume it is phyaddr 0.\n\t \t*/\n\t\tif (phy != 0)\n\t\t\treturn(0);\n\n\t\tswitch (reg) {\n\t\tcase MII_BMCR:\n\t\t\trl8139_reg = RL_BMCR;\n\t\t\tbreak;\n\t\tcase MII_BMSR:\n\t\t\trl8139_reg = RL_BMSR;\n\t\t\tbreak;\n\t\tcase MII_ANAR:\n\t\t\trl8139_reg = RL_ANAR;\n\t\t\tbreak;\n\t\tcase MII_ANER:\n\t\t\trl8139_reg = RL_ANER;\n\t\t\tbreak;\n\t\tcase MII_ANLPAR:\n\t\t\trl8139_reg = RL_LPAR;\n\t\t\tbreak;\n\t\tcase MII_PHYIDR1:\n\t\tcase MII_PHYIDR2:\n\t\t\treturn (0);\n\t\t\tbreak;\n\t\t}\n\t\treturn (CSR_READ_2(sc, rl8139_reg));\n\t}\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = phy;\n\tframe.mii_regaddr = reg;\n\trl_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int rl_mii_readreg",
      "int rl_miibus_readreg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rl_mii_readreg",
          "args": [
            "sc",
            "&frame"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "rl_mii_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "350-438",
          "snippet": "int rl_mii_readreg(sc, frame)\n\tstruct rl_softc\t\t*sc;\n\tstruct rl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ti, ack, s;\n\n\ts = splimp();\n\n\t/*\n\t * Set up frame for RX.\n\t */\n\tframe->mii_stdelim = RL_MII_STARTDELIM;\n\tframe->mii_opcode = RL_MII_READOP;\n\tframe->mii_turnaround = 0;\n\tframe->mii_data = 0;\n\t\n\tCSR_WRITE_2(sc, RL_MII, 0);\n\n\t/*\n \t * Turn on data xmit.\n\t */\n\tMII_SET(RL_MII_DIR);\n\n\trl_mii_sync(sc);\n\n\t/*\n\t * Send command/address info.\n\t */\n\trl_mii_send(sc, frame->mii_stdelim, 2);\n\trl_mii_send(sc, frame->mii_opcode, 2);\n\trl_mii_send(sc, frame->mii_phyaddr, 5);\n\trl_mii_send(sc, frame->mii_regaddr, 5);\n\n\t/* Idle bit */\n\tMII_CLR((RL_MII_CLK|RL_MII_DATAOUT));\n\tDELAY(1);\n\tMII_SET(RL_MII_CLK);\n\tDELAY(1);\n\n\t/* Turn off xmit. */\n\tMII_CLR(RL_MII_DIR);\n\n\t/* Check for ack */\n\tMII_CLR(RL_MII_CLK);\n\tDELAY(1);\n\tMII_SET(RL_MII_CLK);\n\tDELAY(1);\n\tack = CSR_READ_2(sc, RL_MII) & RL_MII_DATAIN;\n\n\t/*\n\t * Now try reading data bits. If the ack failed, we still\n\t * need to clock through 16 cycles to keep the PHY(s) in sync.\n\t */\n\tif (ack) {\n\t\tfor(i = 0; i < 16; i++) {\n\t\t\tMII_CLR(RL_MII_CLK);\n\t\t\tDELAY(1);\n\t\t\tMII_SET(RL_MII_CLK);\n\t\t\tDELAY(1);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tMII_CLR(RL_MII_CLK);\n\t\tDELAY(1);\n\t\tif (!ack) {\n\t\t\tif (CSR_READ_2(sc, RL_MII) & RL_MII_DATAIN)\n\t\t\t\tframe->mii_data |= i;\n\t\t\tDELAY(1);\n\t\t}\n\t\tMII_SET(RL_MII_CLK);\n\t\tDELAY(1);\n\t}\n\nfail:\n\n\tMII_CLR(RL_MII_CLK);\n\tDELAY(1);\n\tMII_SET(RL_MII_CLK);\n\tDELAY(1);\n\n\tsplx(s);\n\n\tif (ack)\n\t\treturn(1);\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_mii_sync",
            "void rl_mii_send",
            "int rl_mii_readreg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_mii_sync;\nvoid rl_mii_send;\nint rl_mii_readreg;\n\nint rl_mii_readreg(sc, frame)\n\tstruct rl_softc\t\t*sc;\n\tstruct rl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ti, ack, s;\n\n\ts = splimp();\n\n\t/*\n\t * Set up frame for RX.\n\t */\n\tframe->mii_stdelim = RL_MII_STARTDELIM;\n\tframe->mii_opcode = RL_MII_READOP;\n\tframe->mii_turnaround = 0;\n\tframe->mii_data = 0;\n\t\n\tCSR_WRITE_2(sc, RL_MII, 0);\n\n\t/*\n \t * Turn on data xmit.\n\t */\n\tMII_SET(RL_MII_DIR);\n\n\trl_mii_sync(sc);\n\n\t/*\n\t * Send command/address info.\n\t */\n\trl_mii_send(sc, frame->mii_stdelim, 2);\n\trl_mii_send(sc, frame->mii_opcode, 2);\n\trl_mii_send(sc, frame->mii_phyaddr, 5);\n\trl_mii_send(sc, frame->mii_regaddr, 5);\n\n\t/* Idle bit */\n\tMII_CLR((RL_MII_CLK|RL_MII_DATAOUT));\n\tDELAY(1);\n\tMII_SET(RL_MII_CLK);\n\tDELAY(1);\n\n\t/* Turn off xmit. */\n\tMII_CLR(RL_MII_DIR);\n\n\t/* Check for ack */\n\tMII_CLR(RL_MII_CLK);\n\tDELAY(1);\n\tMII_SET(RL_MII_CLK);\n\tDELAY(1);\n\tack = CSR_READ_2(sc, RL_MII) & RL_MII_DATAIN;\n\n\t/*\n\t * Now try reading data bits. If the ack failed, we still\n\t * need to clock through 16 cycles to keep the PHY(s) in sync.\n\t */\n\tif (ack) {\n\t\tfor(i = 0; i < 16; i++) {\n\t\t\tMII_CLR(RL_MII_CLK);\n\t\t\tDELAY(1);\n\t\t\tMII_SET(RL_MII_CLK);\n\t\t\tDELAY(1);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tMII_CLR(RL_MII_CLK);\n\t\tDELAY(1);\n\t\tif (!ack) {\n\t\t\tif (CSR_READ_2(sc, RL_MII) & RL_MII_DATAIN)\n\t\t\t\tframe->mii_data |= i;\n\t\t\tDELAY(1);\n\t\t}\n\t\tMII_SET(RL_MII_CLK);\n\t\tDELAY(1);\n\t}\n\nfail:\n\n\tMII_CLR(RL_MII_CLK);\n\tDELAY(1);\n\tMII_SET(RL_MII_CLK);\n\tDELAY(1);\n\n\tsplx(s);\n\n\tif (ack)\n\t\treturn(1);\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&frame",
            "sizeof(frame)"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "rl8139_reg"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint rl_mii_readreg;\nint rl_miibus_readreg;\n\nint\nrl_miibus_readreg(self, phy, reg)\n\tstruct device *self;\n\tint phy, reg;\n{\n\tstruct rl_softc *sc = (struct rl_softc *)self;\n\tstruct rl_mii_frame frame;\n\tu_int16_t rl8139_reg;\n\n\tif (sc->rl_type == RL_8139) {\n\t\t/*\n\t \t* The RTL8139 PHY is mapped into PCI registers, unforunately\n\t \t* it has no phyid, or phyaddr, so assume it is phyaddr 0.\n\t \t*/\n\t\tif (phy != 0)\n\t\t\treturn(0);\n\n\t\tswitch (reg) {\n\t\tcase MII_BMCR:\n\t\t\trl8139_reg = RL_BMCR;\n\t\t\tbreak;\n\t\tcase MII_BMSR:\n\t\t\trl8139_reg = RL_BMSR;\n\t\t\tbreak;\n\t\tcase MII_ANAR:\n\t\t\trl8139_reg = RL_ANAR;\n\t\t\tbreak;\n\t\tcase MII_ANER:\n\t\t\trl8139_reg = RL_ANER;\n\t\t\tbreak;\n\t\tcase MII_ANLPAR:\n\t\t\trl8139_reg = RL_LPAR;\n\t\t\tbreak;\n\t\tcase MII_PHYIDR1:\n\t\tcase MII_PHYIDR2:\n\t\t\treturn (0);\n\t\t\tbreak;\n\t\t}\n\t\treturn (CSR_READ_2(sc, rl8139_reg));\n\t}\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = phy;\n\tframe.mii_regaddr = reg;\n\trl_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}"
  },
  {
    "function_name": "rl_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "1423-1429",
    "snippet": "void rl_shutdown(arg)\n\tvoid\t\t\t*arg;\n{\n\tstruct rl_softc\t\t*sc = (struct rl_softc *)arg;\n\n\trl_stop(sc);\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rl_shutdown",
      "void rl_stop"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rl_stop",
          "args": [
            "sc"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "rl_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "1189-1217",
          "snippet": "void rl_stop(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tuntimeout(rl_tick, sc);\n\n\tCSR_WRITE_1(sc, RL_COMMAND, 0x00);\n\tCSR_WRITE_2(sc, RL_IMR, 0x0000);\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < RL_TX_LIST_CNT; i++) {\n\t\tif (sc->rl_cdata.rl_tx_chain[i] != NULL) {\n\t\t\tm_freem(sc->rl_cdata.rl_tx_chain[i]);\n\t\t\tsc->rl_cdata.rl_tx_chain[i] = NULL;\n\t\t\tCSR_WRITE_4(sc, RL_TXADDR0 + i, 0x00000000);\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_tick",
            "void rl_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_tick;\nvoid rl_stop;\n\nvoid rl_stop(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tuntimeout(rl_tick, sc);\n\n\tCSR_WRITE_1(sc, RL_COMMAND, 0x00);\n\tCSR_WRITE_2(sc, RL_IMR, 0x0000);\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < RL_TX_LIST_CNT; i++) {\n\t\tif (sc->rl_cdata.rl_tx_chain[i] != NULL) {\n\t\t\tm_freem(sc->rl_cdata.rl_tx_chain[i]);\n\t\t\tsc->rl_cdata.rl_tx_chain[i] = NULL;\n\t\t\tCSR_WRITE_4(sc, RL_TXADDR0 + i, 0x00000000);\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_shutdown;\nvoid rl_stop;\n\nvoid rl_shutdown(arg)\n\tvoid\t\t\t*arg;\n{\n\tstruct rl_softc\t\t*sc = (struct rl_softc *)arg;\n\n\trl_stop(sc);\n}"
  },
  {
    "function_name": "rl_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "1250-1421",
    "snippet": "void\nrl_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct rl_softc *sc = (struct rl_softc *)self;\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr = NULL;\n\tu_int8_t enaddr[ETHER_ADDR_LEN];\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tbus_addr_t iobase;\n\tbus_size_t iosize;\n\tbus_dma_segment_t seg;\n\tbus_dmamap_t dmamap;\n\tint rseg;\n\tu_int32_t command;\n\tu_int16_t rl_did;\n\tcaddr_t kva;\n\n\tcommand = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\n#ifdef RL_USEIOSPACE\n\tif (!(command & PCI_COMMAND_IO_ENABLE)) {\n\t\tprintf(\": failed to enable i/o ports\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Map control/status registers.\n\t */\n\tif (pci_io_find(pc, pa->pa_tag, RL_PCI_LOIO, &iobase, &iosize)) {\n\t\tprintf(\": can't find i/o space\\n\");\n\t\treturn;\n\t}\n\tif (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->rl_bhandle)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\tsc->rl_btag = pa->pa_iot;\n#else\n\tif (!(command & PCI_COMMAND_MEM_ENABLE)) {\n\t\tprintf(\": failed to enable memory mapping\\n\");\n\t\treturn;\n\t}\n\tif (pci_mem_find(pc, pa->pa_tag, RL_PCI_LOMEM, &iobase, &iosize, NULL)){\n\t\tprintf(\": can't find mem space\\n\");\n\t\treturn;\n\t}\n\tif (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->rl_bhandle)) {\n\t\tprintf(\": can't map mem space\\n\");\n\t\treturn;\n\t}\n\tsc->rl_btag = pa->pa_memt;\n#endif\n\n\t/*\n\t * Allocate our interrupt.\n\t */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\treturn;\n\t}\n\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, rl_intr, sc,\n\t    self->dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\": couldn't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf(\": %s\", intrstr);\n\n\trl_reset(sc);\n\n\trl_read_eeprom(sc, (caddr_t)&enaddr, RL_EE_EADDR, 3, 0);\n\tbcopy(enaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\tprintf(\" address %s\\n\", ether_sprintf(sc->arpcom.ac_enaddr));\n\n\trl_read_eeprom(sc, (caddr_t)&rl_did, RL_EE_PCI_DID, 1, 0);\n\n\tif (rl_did == RT_DEVICEID_8139 || rl_did == ACCTON_DEVICEID_5030 ||\n\t    rl_did == DELTA_DEVICEID_8139 || rl_did == ADDTRON_DEVICEID_8139)\n\t\tsc->rl_type = RL_8139;\n\telse if (rl_did == RT_DEVICEID_8129)\n\t\tsc->rl_type = RL_8129;\n\telse {\n\t\tprintf(\"\\n%s: unknown device id: %x\\n\", sc->sc_dev.dv_xname,\n\t\t    rl_did);\n\t\treturn;\n\t}\n\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (bus_dmamem_alloc(sc->sc_dmat, RL_RXBUFLEN + 32, PAGE_SIZE, 0,\n\t    &seg, 1, &rseg, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"\\n%s: can't alloc rx buffers\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\tif (bus_dmamem_map(sc->sc_dmat, &seg, rseg, RL_RXBUFLEN + 32, &kva,\n\t    BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't map dma buffers (%d bytes)\\n\",\n\t\t    sc->sc_dev.dv_xname, RL_RXBUFLEN + 32);\n\t\tbus_dmamem_free(sc->sc_dmat, &seg, rseg);\n\t\treturn;\n\t}\n\tif (bus_dmamap_create(sc->sc_dmat, RL_RXBUFLEN + 32, 1,\n\t    RL_RXBUFLEN + 32, 0, BUS_DMA_NOWAIT, &dmamap)) {\n\t\tprintf(\"%s: can't create dma map\\n\", sc->sc_dev.dv_xname);\n\t\tbus_dmamem_unmap(sc->sc_dmat, kva, RL_RXBUFLEN + 32);\n\t\tbus_dmamem_free(sc->sc_dmat, &seg, rseg);\n\t\treturn;\n\t}\n\tif (bus_dmamap_load(sc->sc_dmat, dmamap, kva, RL_RXBUFLEN + 32,\n\t    NULL, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't load dma map\\n\", sc->sc_dev.dv_xname);\n\t\tbus_dmamap_destroy(sc->sc_dmat, dmamap);\n\t\tbus_dmamem_unmap(sc->sc_dmat, kva, RL_RXBUFLEN + 32);\n\t\tbus_dmamem_free(sc->sc_dmat, &seg, rseg);\n\t\treturn;\n\t}\n\tsc->rl_cdata.rl_rx_buf = kva;\n\tbzero(sc->rl_cdata.rl_rx_buf, RL_RXBUFLEN + 32);\n\n\t/* Leave a few bytes before the start of the RX ring buffer. */\n\tsc->rl_cdata.rl_rx_buf_ptr = sc->rl_cdata.rl_rx_buf;\n\tsc->rl_cdata.rl_rx_buf += sizeof(u_int64_t);\n\n\tifp->if_softc = sc;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = rl_ioctl;\n\tifp->if_output = ether_output;\n\tifp->if_start = rl_start;\n\tifp->if_watchdog = rl_watchdog;\n\tifp->if_baudrate = 10000000;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\n\t/*\n\t * Initialize our media structures and probe the MII.\n\t */\n\tsc->sc_mii.mii_ifp = ifp;\n\tsc->sc_mii.mii_readreg = rl_miibus_readreg;\n\tsc->sc_mii.mii_writereg = rl_miibus_writereg;\n\tsc->sc_mii.mii_statchg = rl_miibus_statchg;\n\tifmedia_init(&sc->sc_mii.mii_media, 0, rl_ifmedia_upd, rl_ifmedia_sts);\n\tmii_phy_probe(self, &sc->sc_mii, 0xffffffff);\n\tif (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {\n\t\tifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE, 0, NULL);\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);\n\t} else\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);\n\n\t/*\n\t * Attach us everywhere\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->arpcom.ac_if.if_bpf, ifp,\n\t    DLT_EN10MB, sizeof(struct ether_header));\n\n#endif\n\tshutdownhook_establish(rl_shutdown, sc);\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define RL_USEIOSPACE"
    ],
    "globals_used": [
      "void rl_attach",
      "int rl_intr",
      "void rl_shutdown",
      "void rl_start",
      "int rl_ioctl",
      "void rl_watchdog",
      "int rl_ifmedia_upd",
      "void rl_ifmedia_sts",
      "void rl_read_eeprom",
      "int rl_miibus_readreg",
      "void rl_miibus_writereg",
      "void rl_miibus_statchg",
      "void rl_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "rl_shutdown",
            "sc"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&sc->arpcom.ac_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER|IFM_AUTO"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER|IFM_NONE"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER|IFM_NONE",
            "0",
            "NULL"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->sc_mii.mii_phys"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mii_phy_probe",
          "args": [
            "self",
            "&sc->sc_mii",
            "0xffffffff"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "mii_phy_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "68-122",
          "snippet": "void\nmii_phy_probe(parent, mii, capmask)\n\tstruct device *parent;\n\tstruct mii_data *mii;\n\tint capmask;\n{\n\tstruct mii_attach_args ma;\n\tstruct mii_softc *child;\n\n\tLIST_INIT(&mii->mii_phys);\n\n\tfor (ma.mii_phyno = 0; ma.mii_phyno < MII_NPHY; ma.mii_phyno++) {\n\t\t/*\n\t\t * Check to see if there is a PHY at this address.  If\n\t\t * the register contains garbage, assume no.\n\t\t */\n\t\tma.mii_id1 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR1);\n\t\tma.mii_id2 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR2);\n\t\tif ((ma.mii_id1 == 0 || ma.mii_id1 == 0xffff) &&\n\t\t    (ma.mii_id2 == 0 || ma.mii_id2 == 0xffff)) {\n\t\t\t/*\n\t\t\t * ARGH!!  3Com internal PHYs report 0/0 in their\n\t\t\t * ID registers!  If we spot this, check to see\n\t\t\t * if the BMSR has reasonable data in it.\n\t\t\t * And if that wasn't enough there are PHYs\n\t\t\t * reporting 0xffff/0xffff too.\n\t\t\t */\n\t\t\tif ((MII_OUI(ma.mii_id1, ma.mii_id2) == 0 &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0) ||\n\t\t\t    (MII_OUI(ma.mii_id1, ma.mii_id2) == 0x3fffff &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0x3f)) {\n\t\t\t\tint bmsr = (*mii->mii_readreg)(parent,\n\t\t\t\t    ma.mii_phyno, MII_BMSR);\n\t\t\t\tif (bmsr == 0 || bmsr == 0xffff ||\n\t\t\t\t    (bmsr & BMSR_MEDIAMASK) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tma.mii_data = mii;\n\t\tma.mii_capmask = capmask;\n\n\t\tif ((child = (struct mii_softc *)config_found_sm(parent, &ma,\n\t\t    mii_print, mii_submatch)) != NULL) {\n\t\t\t/*\n\t\t\t * Link it up in the parent's MII data.\n\t\t\t */\n\t\t\tLIST_INSERT_HEAD(&mii->mii_phys, child, mii_list);\n\t\t\tmii->mii_instance++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tmii_print",
            "int\tmii_submatch"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\tmii_print;\nint\tmii_submatch;\n\nvoid\nmii_phy_probe(parent, mii, capmask)\n\tstruct device *parent;\n\tstruct mii_data *mii;\n\tint capmask;\n{\n\tstruct mii_attach_args ma;\n\tstruct mii_softc *child;\n\n\tLIST_INIT(&mii->mii_phys);\n\n\tfor (ma.mii_phyno = 0; ma.mii_phyno < MII_NPHY; ma.mii_phyno++) {\n\t\t/*\n\t\t * Check to see if there is a PHY at this address.  If\n\t\t * the register contains garbage, assume no.\n\t\t */\n\t\tma.mii_id1 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR1);\n\t\tma.mii_id2 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR2);\n\t\tif ((ma.mii_id1 == 0 || ma.mii_id1 == 0xffff) &&\n\t\t    (ma.mii_id2 == 0 || ma.mii_id2 == 0xffff)) {\n\t\t\t/*\n\t\t\t * ARGH!!  3Com internal PHYs report 0/0 in their\n\t\t\t * ID registers!  If we spot this, check to see\n\t\t\t * if the BMSR has reasonable data in it.\n\t\t\t * And if that wasn't enough there are PHYs\n\t\t\t * reporting 0xffff/0xffff too.\n\t\t\t */\n\t\t\tif ((MII_OUI(ma.mii_id1, ma.mii_id2) == 0 &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0) ||\n\t\t\t    (MII_OUI(ma.mii_id1, ma.mii_id2) == 0x3fffff &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0x3f)) {\n\t\t\t\tint bmsr = (*mii->mii_readreg)(parent,\n\t\t\t\t    ma.mii_phyno, MII_BMSR);\n\t\t\t\tif (bmsr == 0 || bmsr == 0xffff ||\n\t\t\t\t    (bmsr & BMSR_MEDIAMASK) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tma.mii_data = mii;\n\t\tma.mii_capmask = capmask;\n\n\t\tif ((child = (struct mii_softc *)config_found_sm(parent, &ma,\n\t\t    mii_print, mii_submatch)) != NULL) {\n\t\t\t/*\n\t\t\t * Link it up in the parent's MII data.\n\t\t\t */\n\t\t\tLIST_INSERT_HEAD(&mii->mii_phys, child, mii_list);\n\t\t\tmii->mii_instance++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->sc_mii.mii_media",
            "0",
            "rl_ifmedia_upd",
            "rl_ifmedia_sts"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->rl_cdata.rl_rx_buf",
            "RL_RXBUFLEN + 32"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "sc->sc_dmat",
            "&seg",
            "rseg"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "sc->sc_dmat",
            "kva",
            "RL_RXBUFLEN + 32"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_destroy",
          "args": [
            "sc->sc_dmat",
            "dmamap"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: can't load dma map\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "sc->sc_dmat",
            "dmamap",
            "kva",
            "RL_RXBUFLEN + 32",
            "NULL",
            "BUS_DMA_NOWAIT"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "sc->sc_dmat",
            "&seg",
            "rseg"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "sc->sc_dmat",
            "kva",
            "RL_RXBUFLEN + 32"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "sc->sc_dmat",
            "RL_RXBUFLEN + 32",
            "1",
            "RL_RXBUFLEN + 32",
            "0",
            "BUS_DMA_NOWAIT",
            "&dmamap"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "sc->sc_dmat",
            "&seg",
            "rseg"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_map",
          "args": [
            "sc->sc_dmat",
            "&seg",
            "rseg",
            "RL_RXBUFLEN + 32",
            "&kva",
            "BUS_DMA_NOWAIT"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_alloc",
          "args": [
            "sc->sc_dmat",
            "RL_RXBUFLEN + 32",
            "PAGE_SIZE",
            "0",
            "&seg",
            "1",
            "&rseg",
            "BUS_DMA_NOWAIT"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl_read_eeprom",
          "args": [
            "sc",
            "(caddr_t)&rl_did",
            "RL_EE_PCI_DID",
            "1",
            "0"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "rl_read_eeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "265-285",
          "snippet": "void rl_read_eeprom(sc, dest, off, cnt, swap)\n\tstruct rl_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n\tint\t\t\tswap;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\tword = 0, *ptr;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\trl_eeprom_getword(sc, off + i, &word);\n\t\tptr = (u_int16_t *)(dest + (i * 2));\n\t\tif (swap)\n\t\t\t*ptr = ntohs(word);\n\t\telse\n\t\t\t*ptr = word;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_eeprom_getword",
            "void rl_read_eeprom"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_eeprom_getword;\nvoid rl_read_eeprom;\n\nvoid rl_read_eeprom(sc, dest, off, cnt, swap)\n\tstruct rl_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n\tint\t\t\tswap;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\tword = 0, *ptr;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\trl_eeprom_getword(sc, off + i, &word);\n\t\tptr = (u_int16_t *)(dest + (i * 2));\n\t\tif (swap)\n\t\t\t*ptr = ntohs(word);\n\t\telse\n\t\t\t*ptr = word;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->arpcom.ac_enaddr"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl_reset",
          "args": [
            "sc"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "rl_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "573-589",
          "snippet": "void rl_reset(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_RESET);\n\n\tfor (i = 0; i < RL_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_1(sc, RL_COMMAND) & RL_CMD_RESET))\n\t\t\tbreak;\n\t}\n\tif (i == RL_TIMEOUT)\n\t\tprintf(\"%s: reset never completed!\\n\", sc->sc_dev.dv_xname);\n\n        return;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_reset;\n\nvoid rl_reset(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_RESET);\n\n\tfor (i = 0; i < RL_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_1(sc, RL_COMMAND) & RL_CMD_RESET))\n\t\t\tbreak;\n\t}\n\tif (i == RL_TIMEOUT)\n\t\tprintf(\"%s: reset never completed!\\n\", sc->sc_dev.dv_xname);\n\n        return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pc",
            "ih",
            "IPL_NET",
            "rl_intr",
            "sc",
            "self->dv_xname"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pc",
            "ih"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&ih"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "pa->pa_memt",
            "iobase",
            "iosize",
            "0",
            "&sc->rl_bhandle"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_mem_find",
          "args": [
            "pc",
            "pa->pa_tag",
            "RL_PCI_LOMEM",
            "&iobase",
            "&iosize",
            "NULL"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mem_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "197-208",
          "snippet": "int\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_mem_find;\n\nint\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "pa->pa_iot",
            "iobase",
            "iosize",
            "0",
            "&sc->rl_bhandle"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_io_find",
          "args": [
            "pc",
            "pa->pa_tag",
            "RL_PCI_LOIO",
            "&iobase",
            "&iosize"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "pci_io_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "186-195",
          "snippet": "int\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\n\nint\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define RL_USEIOSPACE\n\nvoid rl_attach;\nint rl_intr;\nvoid rl_shutdown;\nvoid rl_start;\nint rl_ioctl;\nvoid rl_watchdog;\nint rl_ifmedia_upd;\nvoid rl_ifmedia_sts;\nvoid rl_read_eeprom;\nint rl_miibus_readreg;\nvoid rl_miibus_writereg;\nvoid rl_miibus_statchg;\nvoid rl_reset;\n\nvoid\nrl_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct rl_softc *sc = (struct rl_softc *)self;\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr = NULL;\n\tu_int8_t enaddr[ETHER_ADDR_LEN];\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tbus_addr_t iobase;\n\tbus_size_t iosize;\n\tbus_dma_segment_t seg;\n\tbus_dmamap_t dmamap;\n\tint rseg;\n\tu_int32_t command;\n\tu_int16_t rl_did;\n\tcaddr_t kva;\n\n\tcommand = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\n#ifdef RL_USEIOSPACE\n\tif (!(command & PCI_COMMAND_IO_ENABLE)) {\n\t\tprintf(\": failed to enable i/o ports\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Map control/status registers.\n\t */\n\tif (pci_io_find(pc, pa->pa_tag, RL_PCI_LOIO, &iobase, &iosize)) {\n\t\tprintf(\": can't find i/o space\\n\");\n\t\treturn;\n\t}\n\tif (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->rl_bhandle)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\tsc->rl_btag = pa->pa_iot;\n#else\n\tif (!(command & PCI_COMMAND_MEM_ENABLE)) {\n\t\tprintf(\": failed to enable memory mapping\\n\");\n\t\treturn;\n\t}\n\tif (pci_mem_find(pc, pa->pa_tag, RL_PCI_LOMEM, &iobase, &iosize, NULL)){\n\t\tprintf(\": can't find mem space\\n\");\n\t\treturn;\n\t}\n\tif (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->rl_bhandle)) {\n\t\tprintf(\": can't map mem space\\n\");\n\t\treturn;\n\t}\n\tsc->rl_btag = pa->pa_memt;\n#endif\n\n\t/*\n\t * Allocate our interrupt.\n\t */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\treturn;\n\t}\n\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, rl_intr, sc,\n\t    self->dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\": couldn't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf(\": %s\", intrstr);\n\n\trl_reset(sc);\n\n\trl_read_eeprom(sc, (caddr_t)&enaddr, RL_EE_EADDR, 3, 0);\n\tbcopy(enaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\tprintf(\" address %s\\n\", ether_sprintf(sc->arpcom.ac_enaddr));\n\n\trl_read_eeprom(sc, (caddr_t)&rl_did, RL_EE_PCI_DID, 1, 0);\n\n\tif (rl_did == RT_DEVICEID_8139 || rl_did == ACCTON_DEVICEID_5030 ||\n\t    rl_did == DELTA_DEVICEID_8139 || rl_did == ADDTRON_DEVICEID_8139)\n\t\tsc->rl_type = RL_8139;\n\telse if (rl_did == RT_DEVICEID_8129)\n\t\tsc->rl_type = RL_8129;\n\telse {\n\t\tprintf(\"\\n%s: unknown device id: %x\\n\", sc->sc_dev.dv_xname,\n\t\t    rl_did);\n\t\treturn;\n\t}\n\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (bus_dmamem_alloc(sc->sc_dmat, RL_RXBUFLEN + 32, PAGE_SIZE, 0,\n\t    &seg, 1, &rseg, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"\\n%s: can't alloc rx buffers\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\tif (bus_dmamem_map(sc->sc_dmat, &seg, rseg, RL_RXBUFLEN + 32, &kva,\n\t    BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't map dma buffers (%d bytes)\\n\",\n\t\t    sc->sc_dev.dv_xname, RL_RXBUFLEN + 32);\n\t\tbus_dmamem_free(sc->sc_dmat, &seg, rseg);\n\t\treturn;\n\t}\n\tif (bus_dmamap_create(sc->sc_dmat, RL_RXBUFLEN + 32, 1,\n\t    RL_RXBUFLEN + 32, 0, BUS_DMA_NOWAIT, &dmamap)) {\n\t\tprintf(\"%s: can't create dma map\\n\", sc->sc_dev.dv_xname);\n\t\tbus_dmamem_unmap(sc->sc_dmat, kva, RL_RXBUFLEN + 32);\n\t\tbus_dmamem_free(sc->sc_dmat, &seg, rseg);\n\t\treturn;\n\t}\n\tif (bus_dmamap_load(sc->sc_dmat, dmamap, kva, RL_RXBUFLEN + 32,\n\t    NULL, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't load dma map\\n\", sc->sc_dev.dv_xname);\n\t\tbus_dmamap_destroy(sc->sc_dmat, dmamap);\n\t\tbus_dmamem_unmap(sc->sc_dmat, kva, RL_RXBUFLEN + 32);\n\t\tbus_dmamem_free(sc->sc_dmat, &seg, rseg);\n\t\treturn;\n\t}\n\tsc->rl_cdata.rl_rx_buf = kva;\n\tbzero(sc->rl_cdata.rl_rx_buf, RL_RXBUFLEN + 32);\n\n\t/* Leave a few bytes before the start of the RX ring buffer. */\n\tsc->rl_cdata.rl_rx_buf_ptr = sc->rl_cdata.rl_rx_buf;\n\tsc->rl_cdata.rl_rx_buf += sizeof(u_int64_t);\n\n\tifp->if_softc = sc;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = rl_ioctl;\n\tifp->if_output = ether_output;\n\tifp->if_start = rl_start;\n\tifp->if_watchdog = rl_watchdog;\n\tifp->if_baudrate = 10000000;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\n\t/*\n\t * Initialize our media structures and probe the MII.\n\t */\n\tsc->sc_mii.mii_ifp = ifp;\n\tsc->sc_mii.mii_readreg = rl_miibus_readreg;\n\tsc->sc_mii.mii_writereg = rl_miibus_writereg;\n\tsc->sc_mii.mii_statchg = rl_miibus_statchg;\n\tifmedia_init(&sc->sc_mii.mii_media, 0, rl_ifmedia_upd, rl_ifmedia_sts);\n\tmii_phy_probe(self, &sc->sc_mii, 0xffffffff);\n\tif (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {\n\t\tifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE, 0, NULL);\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);\n\t} else\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);\n\n\t/*\n\t * Attach us everywhere\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->arpcom.ac_if.if_bpf, ifp,\n\t    DLT_EN10MB, sizeof(struct ether_header));\n\n#endif\n\tshutdownhook_establish(rl_shutdown, sc);\n}"
  },
  {
    "function_name": "rl_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "1219-1248",
    "snippet": "int\nrl_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = (struct pci_attach_args *) aux;\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ACCTON &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ACCTON_5030)\n\t\t\treturn (1);\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ADDTRON &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADDTRON_8139)\n\t\treturn (1);\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_DELTA &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DELTA_8139)\n\t\treturn (1);\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_REALTEK) {\n\t\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\t\tcase PCI_PRODUCT_REALTEK_RT8129:\n\t\tcase PCI_PRODUCT_REALTEK_RT8139:\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int rl_probe"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint rl_probe;\n\nint\nrl_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = (struct pci_attach_args *) aux;\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ACCTON &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ACCTON_5030)\n\t\t\treturn (1);\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ADDTRON &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADDTRON_8139)\n\t\treturn (1);\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_DELTA &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DELTA_8139)\n\t\treturn (1);\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_REALTEK) {\n\t\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\t\tcase PCI_PRODUCT_REALTEK_RT8129:\n\t\tcase PCI_PRODUCT_REALTEK_RT8139:\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rl_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "1189-1217",
    "snippet": "void rl_stop(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tuntimeout(rl_tick, sc);\n\n\tCSR_WRITE_1(sc, RL_COMMAND, 0x00);\n\tCSR_WRITE_2(sc, RL_IMR, 0x0000);\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < RL_TX_LIST_CNT; i++) {\n\t\tif (sc->rl_cdata.rl_tx_chain[i] != NULL) {\n\t\t\tm_freem(sc->rl_cdata.rl_tx_chain[i]);\n\t\t\tsc->rl_cdata.rl_tx_chain[i] = NULL;\n\t\t\tCSR_WRITE_4(sc, RL_TXADDR0 + i, 0x00000000);\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rl_tick",
      "void rl_stop"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_TXADDR0 + i",
            "0x00000000"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->rl_cdata.rl_tx_chain[i]"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "RL_IMR",
            "0x0000"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "RL_COMMAND",
            "0x00"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "rl_tick",
            "sc"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_tick;\nvoid rl_stop;\n\nvoid rl_stop(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tuntimeout(rl_tick, sc);\n\n\tCSR_WRITE_1(sc, RL_COMMAND, 0x00);\n\tCSR_WRITE_2(sc, RL_IMR, 0x0000);\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < RL_TX_LIST_CNT; i++) {\n\t\tif (sc->rl_cdata.rl_tx_chain[i] != NULL) {\n\t\t\tm_freem(sc->rl_cdata.rl_tx_chain[i]);\n\t\t\tsc->rl_cdata.rl_tx_chain[i] = NULL;\n\t\t\tCSR_WRITE_4(sc, RL_TXADDR0 + i, 0x00000000);\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
  },
  {
    "function_name": "rl_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "1169-1183",
    "snippet": "void rl_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct rl_softc\t\t*sc;\n\n\tsc = ifp->if_softc;\n\n\tprintf(\"%s: watchdog timeout\\n\", sc->sc_dev.dv_xname);\n\tifp->if_oerrors++;\n\trl_txeof(sc);\n\trl_rxeof(sc);\n\trl_init(sc);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rl_rxeof",
      "void rl_txeof",
      "void rl_init",
      "void rl_watchdog"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rl_init",
          "args": [
            "sc"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "rl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "979-1071",
          "snippet": "void rl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct rl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int32_t\t\trxcfg = 0;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\trl_stop(sc);\n\n\t/* Init our MAC address */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, RL_IDR0 + i, sc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Init the RX buffer pointer register. */\n\tCSR_WRITE_4(sc, RL_RXADDR, vtophys(sc->rl_cdata.rl_rx_buf));\n\n\t/* Init TX descriptors. */\n\trl_list_tx_init(sc);\n\n\t/*\n\t * Enable transmit and receive.\n\t */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\t/*\n\t * Set the inital TX and RX configuration.\n\t */\n\tCSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);\n\tCSR_WRITE_4(sc, RL_RXCFG, RL_RXCFG_CONFIG);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxcfg = CSR_READ_4(sc, RL_RXCFG);\n\trxcfg |= RL_RXCFG_RX_INDIV;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxcfg |= RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxcfg |= RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\trl_setmulti(sc);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, RL_IMR, RL_INTRS);\n\n\t/* Set initial TX threshold */\n\tsc->rl_txthresh = RL_TX_THRESH_INIT;\n\n\t/* Start RX/TX process. */\n\tCSR_WRITE_4(sc, RL_MISSEDPKT, 0);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\tmii_mediachg(&sc->sc_mii);\n\n\tCSR_WRITE_1(sc, RL_CFG1, RL_CFG1_DRVLOAD|RL_CFG1_FULLDUPLEX);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(rl_tick, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_tick",
            "void rl_init",
            "void rl_stop",
            "void rl_setmulti",
            "int rl_list_tx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_tick;\nvoid rl_init;\nvoid rl_stop;\nvoid rl_setmulti;\nint rl_list_tx_init;\n\nvoid rl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct rl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int32_t\t\trxcfg = 0;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\trl_stop(sc);\n\n\t/* Init our MAC address */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, RL_IDR0 + i, sc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Init the RX buffer pointer register. */\n\tCSR_WRITE_4(sc, RL_RXADDR, vtophys(sc->rl_cdata.rl_rx_buf));\n\n\t/* Init TX descriptors. */\n\trl_list_tx_init(sc);\n\n\t/*\n\t * Enable transmit and receive.\n\t */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\t/*\n\t * Set the inital TX and RX configuration.\n\t */\n\tCSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);\n\tCSR_WRITE_4(sc, RL_RXCFG, RL_RXCFG_CONFIG);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxcfg = CSR_READ_4(sc, RL_RXCFG);\n\trxcfg |= RL_RXCFG_RX_INDIV;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxcfg |= RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxcfg |= RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\trl_setmulti(sc);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, RL_IMR, RL_INTRS);\n\n\t/* Set initial TX threshold */\n\tsc->rl_txthresh = RL_TX_THRESH_INIT;\n\n\t/* Start RX/TX process. */\n\tCSR_WRITE_4(sc, RL_MISSEDPKT, 0);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\tmii_mediachg(&sc->sc_mii);\n\n\tCSR_WRITE_1(sc, RL_CFG1, RL_CFG1_DRVLOAD|RL_CFG1_FULLDUPLEX);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(rl_tick, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rl_rxeof",
          "args": [
            "sc"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "rl_rxeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "640-764",
          "snippet": "void rl_rxeof(sc)\n\tstruct rl_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tint\t\t\ttotal_len = 0;\n\tu_int32_t\t\trxstat;\n\tcaddr_t\t\t\trxbufpos;\n\tint\t\t\twrap = 0;\n\tu_int16_t\t\tcur_rx;\n\tu_int16_t\t\tlimit;\n\tu_int16_t\t\trx_bytes = 0, max_bytes;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tcur_rx = (CSR_READ_2(sc, RL_CURRXADDR) + 16) % RL_RXBUFLEN;\n\n\t/* Do not try to read past this point. */\n\tlimit = CSR_READ_2(sc, RL_CURRXBUF) % RL_RXBUFLEN;\n\n\tif (limit < cur_rx)\n\t\tmax_bytes = (RL_RXBUFLEN - cur_rx) + limit;\n\telse\n\t\tmax_bytes = limit - cur_rx;\n\n\twhile((CSR_READ_1(sc, RL_COMMAND) & RL_CMD_EMPTY_RXBUF) == 0) {\n\t\trxbufpos = sc->rl_cdata.rl_rx_buf + cur_rx;\n\t\trxstat = *(u_int32_t *)rxbufpos;\n\n\t\t/*\n\t\t * Here's a totally undocumented fact for you. When the\n\t\t * RealTek chip is in the process of copying a packet into\n\t\t * RAM for you, the length will be 0xfff0. If you spot a\n\t\t * packet header with this value, you need to stop. The\n\t\t * datasheet makes absolutely no mention of this and\n\t\t * RealTek should be shot for this.\n\t\t */\n\t\tif ((u_int16_t)(rxstat >> 16) == RL_RXSTAT_UNFINISHED)\n\t\t\tbreak;\n\t\n\t\tif (!(rxstat & RL_RXSTAT_RXOK)) {\n\t\t\tifp->if_ierrors++;\n\t\t\trl_init(sc);\n\t\t\treturn;\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\ttotal_len = rxstat >> 16;\n\t\trx_bytes += total_len + 4;\n\n\t\t/*\n\t\t * XXX The RealTek chip includes the CRC with every\n\t\t * received frame, and there's no way to turn this\n\t\t * behavior off (at least, I can't find anything in\n\t \t * the manual that explains how to do it) so we have\n\t\t * to trim off the CRC manually.\n\t\t */\n\t\ttotal_len -= ETHER_CRC_LEN;\n\n\t\t/*\n\t\t * Avoid trying to read more bytes than we know\n\t\t * the chip has prepared for us.\n\t\t */\n\t\tif (rx_bytes > max_bytes)\n\t\t\tbreak;\n\n\t\trxbufpos = sc->rl_cdata.rl_rx_buf +\n\t\t\t((cur_rx + sizeof(u_int32_t)) % RL_RXBUFLEN);\n\n\t\tif (rxbufpos == (sc->rl_cdata.rl_rx_buf + RL_RXBUFLEN))\n\t\t\trxbufpos = sc->rl_cdata.rl_rx_buf;\n\n\t\twrap = (sc->rl_cdata.rl_rx_buf + RL_RXBUFLEN) - rxbufpos;\n\n\t\tif (total_len > wrap) {\n\t\t\tm = m_devget(rxbufpos - RL_ETHER_ALIGN,\n\t\t\t    wrap + RL_ETHER_ALIGN, 0, ifp, NULL);\n\t\t\tif (m == NULL)\n\t\t\t\tifp->if_ierrors++;\n\t\t\telse {\n\t\t\t\tm_adj(m, RL_ETHER_ALIGN);\n\t\t\t\tm_copyback(m, wrap, total_len - wrap,\n\t\t\t\t\tsc->rl_cdata.rl_rx_buf);\n\t\t\t\tm = m_pullup(m, sizeof(struct ether_header));\n\t\t\t\tif (m == NULL)\n\t\t\t\t\tifp->if_ierrors++;\n\t\t\t}\n\t\t\tcur_rx = (total_len - wrap + ETHER_CRC_LEN);\n\t\t} else {\n\t\t\tm = m_devget(rxbufpos - RL_ETHER_ALIGN,\n\t\t\t    total_len + RL_ETHER_ALIGN, 0, ifp, NULL);\n\t\t\tif (m == NULL)\n\t\t\t\tifp->if_ierrors++;\n\t\t\telse\n\t\t\t\tm_adj(m, RL_ETHER_ALIGN);\n\t\t\tcur_rx += total_len + 4 + ETHER_CRC_LEN;\n\t\t}\n\n\t\t/*\n\t\t * Round up to 32-bit boundary.\n\t\t */\n\t\tcur_rx = (cur_rx + 3) & ~3;\n\t\tCSR_WRITE_2(sc, RL_CURRXADDR, cur_rx - 16);\n\n\t\tif (m == NULL)\n\t\t\tcontinue;\n\n\t\teh = mtod(m, struct ether_header *);\n\t\tifp->if_ipackets++;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Handle BPF listeners. Let the BPF user see the packet.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_rxeof",
            "void rl_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_rxeof;\nvoid rl_init;\n\nvoid rl_rxeof(sc)\n\tstruct rl_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tint\t\t\ttotal_len = 0;\n\tu_int32_t\t\trxstat;\n\tcaddr_t\t\t\trxbufpos;\n\tint\t\t\twrap = 0;\n\tu_int16_t\t\tcur_rx;\n\tu_int16_t\t\tlimit;\n\tu_int16_t\t\trx_bytes = 0, max_bytes;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tcur_rx = (CSR_READ_2(sc, RL_CURRXADDR) + 16) % RL_RXBUFLEN;\n\n\t/* Do not try to read past this point. */\n\tlimit = CSR_READ_2(sc, RL_CURRXBUF) % RL_RXBUFLEN;\n\n\tif (limit < cur_rx)\n\t\tmax_bytes = (RL_RXBUFLEN - cur_rx) + limit;\n\telse\n\t\tmax_bytes = limit - cur_rx;\n\n\twhile((CSR_READ_1(sc, RL_COMMAND) & RL_CMD_EMPTY_RXBUF) == 0) {\n\t\trxbufpos = sc->rl_cdata.rl_rx_buf + cur_rx;\n\t\trxstat = *(u_int32_t *)rxbufpos;\n\n\t\t/*\n\t\t * Here's a totally undocumented fact for you. When the\n\t\t * RealTek chip is in the process of copying a packet into\n\t\t * RAM for you, the length will be 0xfff0. If you spot a\n\t\t * packet header with this value, you need to stop. The\n\t\t * datasheet makes absolutely no mention of this and\n\t\t * RealTek should be shot for this.\n\t\t */\n\t\tif ((u_int16_t)(rxstat >> 16) == RL_RXSTAT_UNFINISHED)\n\t\t\tbreak;\n\t\n\t\tif (!(rxstat & RL_RXSTAT_RXOK)) {\n\t\t\tifp->if_ierrors++;\n\t\t\trl_init(sc);\n\t\t\treturn;\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\ttotal_len = rxstat >> 16;\n\t\trx_bytes += total_len + 4;\n\n\t\t/*\n\t\t * XXX The RealTek chip includes the CRC with every\n\t\t * received frame, and there's no way to turn this\n\t\t * behavior off (at least, I can't find anything in\n\t \t * the manual that explains how to do it) so we have\n\t\t * to trim off the CRC manually.\n\t\t */\n\t\ttotal_len -= ETHER_CRC_LEN;\n\n\t\t/*\n\t\t * Avoid trying to read more bytes than we know\n\t\t * the chip has prepared for us.\n\t\t */\n\t\tif (rx_bytes > max_bytes)\n\t\t\tbreak;\n\n\t\trxbufpos = sc->rl_cdata.rl_rx_buf +\n\t\t\t((cur_rx + sizeof(u_int32_t)) % RL_RXBUFLEN);\n\n\t\tif (rxbufpos == (sc->rl_cdata.rl_rx_buf + RL_RXBUFLEN))\n\t\t\trxbufpos = sc->rl_cdata.rl_rx_buf;\n\n\t\twrap = (sc->rl_cdata.rl_rx_buf + RL_RXBUFLEN) - rxbufpos;\n\n\t\tif (total_len > wrap) {\n\t\t\tm = m_devget(rxbufpos - RL_ETHER_ALIGN,\n\t\t\t    wrap + RL_ETHER_ALIGN, 0, ifp, NULL);\n\t\t\tif (m == NULL)\n\t\t\t\tifp->if_ierrors++;\n\t\t\telse {\n\t\t\t\tm_adj(m, RL_ETHER_ALIGN);\n\t\t\t\tm_copyback(m, wrap, total_len - wrap,\n\t\t\t\t\tsc->rl_cdata.rl_rx_buf);\n\t\t\t\tm = m_pullup(m, sizeof(struct ether_header));\n\t\t\t\tif (m == NULL)\n\t\t\t\t\tifp->if_ierrors++;\n\t\t\t}\n\t\t\tcur_rx = (total_len - wrap + ETHER_CRC_LEN);\n\t\t} else {\n\t\t\tm = m_devget(rxbufpos - RL_ETHER_ALIGN,\n\t\t\t    total_len + RL_ETHER_ALIGN, 0, ifp, NULL);\n\t\t\tif (m == NULL)\n\t\t\t\tifp->if_ierrors++;\n\t\t\telse\n\t\t\t\tm_adj(m, RL_ETHER_ALIGN);\n\t\t\tcur_rx += total_len + 4 + ETHER_CRC_LEN;\n\t\t}\n\n\t\t/*\n\t\t * Round up to 32-bit boundary.\n\t\t */\n\t\tcur_rx = (cur_rx + 3) & ~3;\n\t\tCSR_WRITE_2(sc, RL_CURRXADDR, cur_rx - 16);\n\n\t\tif (m == NULL)\n\t\t\tcontinue;\n\n\t\teh = mtod(m, struct ether_header *);\n\t\tifp->if_ipackets++;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Handle BPF listeners. Let the BPF user see the packet.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rl_txeof",
          "args": [
            "sc"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "rl_txeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "770-821",
          "snippet": "void rl_txeof(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\ttxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Clear the timeout timer. */\n\tifp->if_timer = 0;\n\n\t/*\n\t * Go through our tx list and free mbufs for those\n\t * frames that have been uploaded.\n\t */\n\tdo {\n\t\ttxstat = CSR_READ_4(sc, RL_LAST_TXSTAT(sc));\n\t\tif (!(txstat & (RL_TXSTAT_TX_OK|\n\t\t    RL_TXSTAT_TX_UNDERRUN|RL_TXSTAT_TXABRT)))\n\t\t\tbreak;\n\n\t\tifp->if_collisions += (txstat & RL_TXSTAT_COLLCNT) >> 24;\n\n\t\tif (RL_LAST_TXMBUF(sc) != NULL) {\n\t\t\tm_freem(RL_LAST_TXMBUF(sc));\n\t\t\tRL_LAST_TXMBUF(sc) = NULL;\n\t\t}\n\t\tif (txstat & RL_TXSTAT_TX_OK)\n\t\t\tifp->if_opackets++;\n\t\telse {\n\t\t\tint oldthresh;\n\n\t\t\tifp->if_oerrors++;\n\t\t\tif ((txstat & RL_TXSTAT_TXABRT) ||\n\t\t\t    (txstat & RL_TXSTAT_OUTOFWIN))\n\t\t\t\tCSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);\n\t\t\toldthresh = sc->rl_txthresh;\n\t\t\t/* error recovery */\n\t\t\trl_reset(sc);\n\t\t\trl_init(sc);\n\t\t\t/*\n\t\t\t * If there was a transmit underrun,\n\t\t\t * bump the TX threshold.\n\t\t\t */\n\t\t\tif (txstat & RL_TXSTAT_TX_UNDERRUN)\n\t\t\t\tsc->rl_txthresh = oldthresh + 32;\n\t\t\treturn;\n\t\t}\n\t\tRL_INC(sc->rl_cdata.last_tx);\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t} while (sc->rl_cdata.last_tx != sc->rl_cdata.cur_tx);\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_txeof",
            "void rl_init",
            "void rl_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_txeof;\nvoid rl_init;\nvoid rl_reset;\n\nvoid rl_txeof(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\ttxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Clear the timeout timer. */\n\tifp->if_timer = 0;\n\n\t/*\n\t * Go through our tx list and free mbufs for those\n\t * frames that have been uploaded.\n\t */\n\tdo {\n\t\ttxstat = CSR_READ_4(sc, RL_LAST_TXSTAT(sc));\n\t\tif (!(txstat & (RL_TXSTAT_TX_OK|\n\t\t    RL_TXSTAT_TX_UNDERRUN|RL_TXSTAT_TXABRT)))\n\t\t\tbreak;\n\n\t\tifp->if_collisions += (txstat & RL_TXSTAT_COLLCNT) >> 24;\n\n\t\tif (RL_LAST_TXMBUF(sc) != NULL) {\n\t\t\tm_freem(RL_LAST_TXMBUF(sc));\n\t\t\tRL_LAST_TXMBUF(sc) = NULL;\n\t\t}\n\t\tif (txstat & RL_TXSTAT_TX_OK)\n\t\t\tifp->if_opackets++;\n\t\telse {\n\t\t\tint oldthresh;\n\n\t\t\tifp->if_oerrors++;\n\t\t\tif ((txstat & RL_TXSTAT_TXABRT) ||\n\t\t\t    (txstat & RL_TXSTAT_OUTOFWIN))\n\t\t\t\tCSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);\n\t\t\toldthresh = sc->rl_txthresh;\n\t\t\t/* error recovery */\n\t\t\trl_reset(sc);\n\t\t\trl_init(sc);\n\t\t\t/*\n\t\t\t * If there was a transmit underrun,\n\t\t\t * bump the TX threshold.\n\t\t\t */\n\t\t\tif (txstat & RL_TXSTAT_TX_UNDERRUN)\n\t\t\t\tsc->rl_txthresh = oldthresh + 32;\n\t\t\treturn;\n\t\t}\n\t\tRL_INC(sc->rl_cdata.last_tx);\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t} while (sc->rl_cdata.last_tx != sc->rl_cdata.cur_tx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: watchdog timeout\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_rxeof;\nvoid rl_txeof;\nvoid rl_init;\nvoid rl_watchdog;\n\nvoid rl_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct rl_softc\t\t*sc;\n\n\tsc = ifp->if_softc;\n\n\tprintf(\"%s: watchdog timeout\\n\", sc->sc_dev.dv_xname);\n\tifp->if_oerrors++;\n\trl_txeof(sc);\n\trl_rxeof(sc);\n\trl_init(sc);\n\n\treturn;\n}"
  },
  {
    "function_name": "rl_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "1099-1167",
    "snippet": "int rl_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tstruct rl_softc\t\t*sc = ifp->if_softc;\n\tstruct ifreq\t\t*ifr = (struct ifreq *) data;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tint\t\t\ts, error = 0;\n\n\ts = splimp();\n\n\tif ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\trl_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif /* INET */\n\t\tdefault:\n\t\t\trl_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\trl_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\trl_stop(sc);\n\t\t}\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->arpcom) :\n\t\t    ether_delmulti(ifr, &sc->arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware\n\t\t\t * filter accordingly.\n\t\t\t */\n\t\t\trl_setmulti(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, command);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\t(void)splx(s);\n\n\treturn(error);\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int rl_ioctl",
      "void rl_init",
      "void rl_stop",
      "void rl_setmulti"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&sc->sc_mii.mii_media",
            "command"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl_setmulti",
          "args": [
            "sc"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "rl_setmulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "520-571",
          "snippet": "void rl_setmulti(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tu_int32_t\t\trxfilt;\n\tint\t\t\tmcnt = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\trxfilt = CSR_READ_4(sc, RL_RXCFG);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= RL_RXCFG_RX_MULTI;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxfilt);\n\t\tCSR_WRITE_4(sc, RL_MAR0, 0xFFFFFFFF);\n\t\tCSR_WRITE_4(sc, RL_MAR4, 0xFFFFFFFF);\n\t\treturn;\n\t}\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, RL_MAR0, 0);\n\tCSR_WRITE_4(sc, RL_MAR4, 0);\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tmcnt++;\n\t\th = rl_calchash(enm->enm_addrlo);\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t\tmcnt++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (mcnt)\n\t\trxfilt |= RL_RXCFG_RX_MULTI;\n\telse\n\t\trxfilt &= ~RL_RXCFG_RX_MULTI;\n\n\tCSR_WRITE_4(sc, RL_RXCFG, rxfilt);\n\tCSR_WRITE_4(sc, RL_MAR0, hashes[0]);\n\tCSR_WRITE_4(sc, RL_MAR4, hashes[1]);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t rl_calchash",
            "void rl_setmulti"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t rl_calchash;\nvoid rl_setmulti;\n\nvoid rl_setmulti(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tu_int32_t\t\trxfilt;\n\tint\t\t\tmcnt = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\trxfilt = CSR_READ_4(sc, RL_RXCFG);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= RL_RXCFG_RX_MULTI;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxfilt);\n\t\tCSR_WRITE_4(sc, RL_MAR0, 0xFFFFFFFF);\n\t\tCSR_WRITE_4(sc, RL_MAR4, 0xFFFFFFFF);\n\t\treturn;\n\t}\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, RL_MAR0, 0);\n\tCSR_WRITE_4(sc, RL_MAR4, 0);\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tmcnt++;\n\t\th = rl_calchash(enm->enm_addrlo);\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t\tmcnt++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (mcnt)\n\t\trxfilt |= RL_RXCFG_RX_MULTI;\n\telse\n\t\trxfilt &= ~RL_RXCFG_RX_MULTI;\n\n\tCSR_WRITE_4(sc, RL_RXCFG, rxfilt);\n\tCSR_WRITE_4(sc, RL_MAR0, hashes[0]);\n\tCSR_WRITE_4(sc, RL_MAR4, hashes[1]);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc->arpcom"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc->arpcom"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl_stop",
          "args": [
            "sc"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "rl_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "1189-1217",
          "snippet": "void rl_stop(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tuntimeout(rl_tick, sc);\n\n\tCSR_WRITE_1(sc, RL_COMMAND, 0x00);\n\tCSR_WRITE_2(sc, RL_IMR, 0x0000);\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < RL_TX_LIST_CNT; i++) {\n\t\tif (sc->rl_cdata.rl_tx_chain[i] != NULL) {\n\t\t\tm_freem(sc->rl_cdata.rl_tx_chain[i]);\n\t\t\tsc->rl_cdata.rl_tx_chain[i] = NULL;\n\t\t\tCSR_WRITE_4(sc, RL_TXADDR0 + i, 0x00000000);\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_tick",
            "void rl_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_tick;\nvoid rl_stop;\n\nvoid rl_stop(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tuntimeout(rl_tick, sc);\n\n\tCSR_WRITE_1(sc, RL_COMMAND, 0x00);\n\tCSR_WRITE_2(sc, RL_IMR, 0x0000);\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < RL_TX_LIST_CNT; i++) {\n\t\tif (sc->rl_cdata.rl_tx_chain[i] != NULL) {\n\t\t\tm_freem(sc->rl_cdata.rl_tx_chain[i]);\n\t\t\tsc->rl_cdata.rl_tx_chain[i] = NULL;\n\t\t\tCSR_WRITE_4(sc, RL_TXADDR0 + i, 0x00000000);\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rl_init",
          "args": [
            "sc"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "rl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "979-1071",
          "snippet": "void rl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct rl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int32_t\t\trxcfg = 0;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\trl_stop(sc);\n\n\t/* Init our MAC address */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, RL_IDR0 + i, sc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Init the RX buffer pointer register. */\n\tCSR_WRITE_4(sc, RL_RXADDR, vtophys(sc->rl_cdata.rl_rx_buf));\n\n\t/* Init TX descriptors. */\n\trl_list_tx_init(sc);\n\n\t/*\n\t * Enable transmit and receive.\n\t */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\t/*\n\t * Set the inital TX and RX configuration.\n\t */\n\tCSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);\n\tCSR_WRITE_4(sc, RL_RXCFG, RL_RXCFG_CONFIG);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxcfg = CSR_READ_4(sc, RL_RXCFG);\n\trxcfg |= RL_RXCFG_RX_INDIV;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxcfg |= RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxcfg |= RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\trl_setmulti(sc);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, RL_IMR, RL_INTRS);\n\n\t/* Set initial TX threshold */\n\tsc->rl_txthresh = RL_TX_THRESH_INIT;\n\n\t/* Start RX/TX process. */\n\tCSR_WRITE_4(sc, RL_MISSEDPKT, 0);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\tmii_mediachg(&sc->sc_mii);\n\n\tCSR_WRITE_1(sc, RL_CFG1, RL_CFG1_DRVLOAD|RL_CFG1_FULLDUPLEX);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(rl_tick, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_tick",
            "void rl_init",
            "void rl_stop",
            "void rl_setmulti",
            "int rl_list_tx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_tick;\nvoid rl_init;\nvoid rl_stop;\nvoid rl_setmulti;\nint rl_list_tx_init;\n\nvoid rl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct rl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int32_t\t\trxcfg = 0;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\trl_stop(sc);\n\n\t/* Init our MAC address */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, RL_IDR0 + i, sc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Init the RX buffer pointer register. */\n\tCSR_WRITE_4(sc, RL_RXADDR, vtophys(sc->rl_cdata.rl_rx_buf));\n\n\t/* Init TX descriptors. */\n\trl_list_tx_init(sc);\n\n\t/*\n\t * Enable transmit and receive.\n\t */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\t/*\n\t * Set the inital TX and RX configuration.\n\t */\n\tCSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);\n\tCSR_WRITE_4(sc, RL_RXCFG, RL_RXCFG_CONFIG);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxcfg = CSR_READ_4(sc, RL_RXCFG);\n\trxcfg |= RL_RXCFG_RX_INDIV;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxcfg |= RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxcfg |= RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\trl_setmulti(sc);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, RL_IMR, RL_INTRS);\n\n\t/* Set initial TX threshold */\n\tsc->rl_txthresh = RL_TX_THRESH_INIT;\n\n\t/* Start RX/TX process. */\n\tCSR_WRITE_4(sc, RL_MISSEDPKT, 0);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\tmii_mediachg(&sc->sc_mii);\n\n\tCSR_WRITE_1(sc, RL_CFG1, RL_CFG1_DRVLOAD|RL_CFG1_FULLDUPLEX);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(rl_tick, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->arpcom",
            "ifa"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "&sc->arpcom",
            "command",
            "data"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "wx_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "303-356",
          "snippet": "static int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_init",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_init;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint rl_ioctl;\nvoid rl_init;\nvoid rl_stop;\nvoid rl_setmulti;\n\nint rl_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tstruct rl_softc\t\t*sc = ifp->if_softc;\n\tstruct ifreq\t\t*ifr = (struct ifreq *) data;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tint\t\t\ts, error = 0;\n\n\ts = splimp();\n\n\tif ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\trl_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif /* INET */\n\t\tdefault:\n\t\t\trl_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\trl_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\trl_stop(sc);\n\t\t}\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->arpcom) :\n\t\t    ether_delmulti(ifr, &sc->arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware\n\t\t\t * filter accordingly.\n\t\t\t */\n\t\t\trl_setmulti(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, command);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\t(void)splx(s);\n\n\treturn(error);\n}"
  },
  {
    "function_name": "rl_ifmedia_sts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "1088-1097",
    "snippet": "void rl_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct rl_softc *sc = ifp->if_softc;\n\n\tmii_pollstat(&sc->sc_mii);\n\tifmr->ifm_status = sc->sc_mii.mii_media_status;\n\tifmr->ifm_active = sc->sc_mii.mii_media_active;\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rl_ifmedia_sts"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mii_pollstat",
          "args": [
            "&sc->sc_mii"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "mii_pollstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "206-218",
          "snippet": "void\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_ifmedia_sts;\n\nvoid rl_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct rl_softc *sc = ifp->if_softc;\n\n\tmii_pollstat(&sc->sc_mii);\n\tifmr->ifm_status = sc->sc_mii.mii_media_status;\n\tifmr->ifm_active = sc->sc_mii.mii_media_active;\n}"
  },
  {
    "function_name": "rl_ifmedia_upd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "1076-1083",
    "snippet": "int rl_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct rl_softc *sc = (struct rl_softc *)ifp->if_softc;\n\n\tmii_mediachg(&sc->sc_mii);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int rl_ifmedia_upd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mii_mediachg",
          "args": [
            "&sc->sc_mii"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "mii_mediachg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "170-187",
          "snippet": "int\nmii_mediachg(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\tint rv;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list)) {\n\t\trv = (*child->mii_service)(child, mii, MII_MEDIACHG);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\nmii_mediachg(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\tint rv;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list)) {\n\t\trv = (*child->mii_service)(child, mii, MII_MEDIACHG);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t}\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint rl_ifmedia_upd;\n\nint rl_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct rl_softc *sc = (struct rl_softc *)ifp->if_softc;\n\n\tmii_mediachg(&sc->sc_mii);\n\treturn (0);\n}"
  },
  {
    "function_name": "rl_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "979-1071",
    "snippet": "void rl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct rl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int32_t\t\trxcfg = 0;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\trl_stop(sc);\n\n\t/* Init our MAC address */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, RL_IDR0 + i, sc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Init the RX buffer pointer register. */\n\tCSR_WRITE_4(sc, RL_RXADDR, vtophys(sc->rl_cdata.rl_rx_buf));\n\n\t/* Init TX descriptors. */\n\trl_list_tx_init(sc);\n\n\t/*\n\t * Enable transmit and receive.\n\t */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\t/*\n\t * Set the inital TX and RX configuration.\n\t */\n\tCSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);\n\tCSR_WRITE_4(sc, RL_RXCFG, RL_RXCFG_CONFIG);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxcfg = CSR_READ_4(sc, RL_RXCFG);\n\trxcfg |= RL_RXCFG_RX_INDIV;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxcfg |= RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxcfg |= RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\trl_setmulti(sc);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, RL_IMR, RL_INTRS);\n\n\t/* Set initial TX threshold */\n\tsc->rl_txthresh = RL_TX_THRESH_INIT;\n\n\t/* Start RX/TX process. */\n\tCSR_WRITE_4(sc, RL_MISSEDPKT, 0);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\tmii_mediachg(&sc->sc_mii);\n\n\tCSR_WRITE_1(sc, RL_CFG1, RL_CFG1_DRVLOAD|RL_CFG1_FULLDUPLEX);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(rl_tick, sc, hz);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rl_tick",
      "void rl_init",
      "void rl_stop",
      "void rl_setmulti",
      "int rl_list_tx_init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "rl_tick",
            "sc",
            "hz"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "RL_CFG1",
            "RL_CFG1_DRVLOAD|RL_CFG1_FULLDUPLEX"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mii_mediachg",
          "args": [
            "&sc->sc_mii"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "mii_mediachg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "170-187",
          "snippet": "int\nmii_mediachg(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\tint rv;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list)) {\n\t\trv = (*child->mii_service)(child, mii, MII_MEDIACHG);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\nmii_mediachg(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\tint rv;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list)) {\n\t\trv = (*child->mii_service)(child, mii, MII_MEDIACHG);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "RL_COMMAND",
            "RL_CMD_TX_ENB|RL_CMD_RX_ENB"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_MISSEDPKT",
            "0"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "RL_IMR",
            "RL_INTRS"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl_setmulti",
          "args": [
            "sc"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "rl_setmulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "520-571",
          "snippet": "void rl_setmulti(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tu_int32_t\t\trxfilt;\n\tint\t\t\tmcnt = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\trxfilt = CSR_READ_4(sc, RL_RXCFG);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= RL_RXCFG_RX_MULTI;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxfilt);\n\t\tCSR_WRITE_4(sc, RL_MAR0, 0xFFFFFFFF);\n\t\tCSR_WRITE_4(sc, RL_MAR4, 0xFFFFFFFF);\n\t\treturn;\n\t}\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, RL_MAR0, 0);\n\tCSR_WRITE_4(sc, RL_MAR4, 0);\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tmcnt++;\n\t\th = rl_calchash(enm->enm_addrlo);\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t\tmcnt++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (mcnt)\n\t\trxfilt |= RL_RXCFG_RX_MULTI;\n\telse\n\t\trxfilt &= ~RL_RXCFG_RX_MULTI;\n\n\tCSR_WRITE_4(sc, RL_RXCFG, rxfilt);\n\tCSR_WRITE_4(sc, RL_MAR0, hashes[0]);\n\tCSR_WRITE_4(sc, RL_MAR4, hashes[1]);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t rl_calchash",
            "void rl_setmulti"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t rl_calchash;\nvoid rl_setmulti;\n\nvoid rl_setmulti(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tu_int32_t\t\trxfilt;\n\tint\t\t\tmcnt = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\trxfilt = CSR_READ_4(sc, RL_RXCFG);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= RL_RXCFG_RX_MULTI;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxfilt);\n\t\tCSR_WRITE_4(sc, RL_MAR0, 0xFFFFFFFF);\n\t\tCSR_WRITE_4(sc, RL_MAR4, 0xFFFFFFFF);\n\t\treturn;\n\t}\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, RL_MAR0, 0);\n\tCSR_WRITE_4(sc, RL_MAR4, 0);\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tmcnt++;\n\t\th = rl_calchash(enm->enm_addrlo);\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t\tmcnt++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (mcnt)\n\t\trxfilt |= RL_RXCFG_RX_MULTI;\n\telse\n\t\trxfilt &= ~RL_RXCFG_RX_MULTI;\n\n\tCSR_WRITE_4(sc, RL_RXCFG, rxfilt);\n\tCSR_WRITE_4(sc, RL_MAR0, hashes[0]);\n\tCSR_WRITE_4(sc, RL_MAR4, hashes[1]);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_RXCFG",
            "rxcfg"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_RXCFG",
            "rxcfg"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_RXCFG",
            "rxcfg"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_RXCFG",
            "rxcfg"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "RL_RXCFG"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_RXCFG",
            "RL_RXCFG_CONFIG"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_TXCFG",
            "RL_TXCFG_CONFIG"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "RL_COMMAND",
            "RL_CMD_TX_ENB|RL_CMD_RX_ENB"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl_list_tx_init",
          "args": [
            "sc"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "rl_list_tx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "594-611",
          "snippet": "int rl_list_tx_init(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tstruct rl_chain_data\t*cd;\n\tint\t\t\ti;\n\n\tcd = &sc->rl_cdata;\n\tfor (i = 0; i < RL_TX_LIST_CNT; i++) {\n\t\tcd->rl_tx_chain[i] = NULL;\n\t\tCSR_WRITE_4(sc,\n\t\t    RL_TXADDR0 + (i * sizeof(u_int32_t)), 0x0000000);\n\t}\n\n\tsc->rl_cdata.cur_tx = 0;\n\tsc->rl_cdata.last_tx = 0;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int rl_list_tx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint rl_list_tx_init;\n\nint rl_list_tx_init(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tstruct rl_chain_data\t*cd;\n\tint\t\t\ti;\n\n\tcd = &sc->rl_cdata;\n\tfor (i = 0; i < RL_TX_LIST_CNT; i++) {\n\t\tcd->rl_tx_chain[i] = NULL;\n\t\tCSR_WRITE_4(sc,\n\t\t    RL_TXADDR0 + (i * sizeof(u_int32_t)), 0x0000000);\n\t}\n\n\tsc->rl_cdata.cur_tx = 0;\n\tsc->rl_cdata.last_tx = 0;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_RXADDR",
            "vtophys(sc->rl_cdata.rl_rx_buf)"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->rl_cdata.rl_rx_buf"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "RL_IDR0 + i",
            "sc->arpcom.ac_enaddr[i]"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl_stop",
          "args": [
            "sc"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "rl_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "1189-1217",
          "snippet": "void rl_stop(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tuntimeout(rl_tick, sc);\n\n\tCSR_WRITE_1(sc, RL_COMMAND, 0x00);\n\tCSR_WRITE_2(sc, RL_IMR, 0x0000);\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < RL_TX_LIST_CNT; i++) {\n\t\tif (sc->rl_cdata.rl_tx_chain[i] != NULL) {\n\t\t\tm_freem(sc->rl_cdata.rl_tx_chain[i]);\n\t\t\tsc->rl_cdata.rl_tx_chain[i] = NULL;\n\t\t\tCSR_WRITE_4(sc, RL_TXADDR0 + i, 0x00000000);\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_tick",
            "void rl_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_tick;\nvoid rl_stop;\n\nvoid rl_stop(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tuntimeout(rl_tick, sc);\n\n\tCSR_WRITE_1(sc, RL_COMMAND, 0x00);\n\tCSR_WRITE_2(sc, RL_IMR, 0x0000);\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < RL_TX_LIST_CNT; i++) {\n\t\tif (sc->rl_cdata.rl_tx_chain[i] != NULL) {\n\t\t\tm_freem(sc->rl_cdata.rl_tx_chain[i]);\n\t\t\tsc->rl_cdata.rl_tx_chain[i] = NULL;\n\t\t\tCSR_WRITE_4(sc, RL_TXADDR0 + i, 0x00000000);\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_tick;\nvoid rl_init;\nvoid rl_stop;\nvoid rl_setmulti;\nint rl_list_tx_init;\n\nvoid rl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct rl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int32_t\t\trxcfg = 0;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\trl_stop(sc);\n\n\t/* Init our MAC address */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, RL_IDR0 + i, sc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Init the RX buffer pointer register. */\n\tCSR_WRITE_4(sc, RL_RXADDR, vtophys(sc->rl_cdata.rl_rx_buf));\n\n\t/* Init TX descriptors. */\n\trl_list_tx_init(sc);\n\n\t/*\n\t * Enable transmit and receive.\n\t */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\t/*\n\t * Set the inital TX and RX configuration.\n\t */\n\tCSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);\n\tCSR_WRITE_4(sc, RL_RXCFG, RL_RXCFG_CONFIG);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxcfg = CSR_READ_4(sc, RL_RXCFG);\n\trxcfg |= RL_RXCFG_RX_INDIV;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxcfg |= RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxcfg |= RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\trl_setmulti(sc);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, RL_IMR, RL_INTRS);\n\n\t/* Set initial TX threshold */\n\tsc->rl_txthresh = RL_TX_THRESH_INIT;\n\n\t/* Start RX/TX process. */\n\tCSR_WRITE_4(sc, RL_MISSEDPKT, 0);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\tmii_mediachg(&sc->sc_mii);\n\n\tCSR_WRITE_1(sc, RL_CFG1, RL_CFG1_DRVLOAD|RL_CFG1_FULLDUPLEX);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(rl_tick, sc, hz);\n\n\treturn;\n}"
  },
  {
    "function_name": "rl_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "927-977",
    "snippet": "void rl_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct rl_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tsc = ifp->if_softc;\n\n\twhile(RL_CUR_TXMBUF(sc) == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/* Pack the data into the descriptor. */\n\t\trl_encap(sc, m_head);\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, RL_CUR_TXMBUF(sc));\n#endif\n\t\t/*\n\t\t * Transmit the frame.\n\t \t */\n\t\tCSR_WRITE_4(sc, RL_CUR_TXADDR(sc),\n\t\t    vtophys(mtod(RL_CUR_TXMBUF(sc), caddr_t)));\n\t\tCSR_WRITE_4(sc, RL_CUR_TXSTAT(sc),\n\t\t    RL_TXTHRESH(sc->rl_txthresh) |\n\t\t    RL_CUR_TXMBUF(sc)->m_pkthdr.len);\n\n\t\tRL_INC(sc->rl_cdata.cur_tx);\n\t}\n\n\t/*\n\t * We broke out of the loop because all our TX slots are\n\t * full. Mark the NIC as busy until it drains some of the\n\t * packets from the queue.\n\t */\n\tif (RL_CUR_TXMBUF(sc) != NULL)\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int rl_encap",
      "void rl_start"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RL_CUR_TXMBUF",
          "args": [
            "sc"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RL_INC",
          "args": [
            "sc->rl_cdata.cur_tx"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_CUR_TXSTAT(sc)",
            "RL_TXTHRESH(sc->rl_txthresh) |\n\t\t    RL_CUR_TXMBUF(sc)->m_pkthdr.len"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RL_CUR_TXMBUF",
          "args": [
            "sc"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RL_TXTHRESH",
          "args": [
            "sc->rl_txthresh"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RL_CUR_TXSTAT",
          "args": [
            "sc"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_CUR_TXADDR(sc)",
            "vtophys(mtod(RL_CUR_TXMBUF(sc), caddr_t))"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(RL_CUR_TXMBUF(sc), caddr_t)"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "RL_CUR_TXMBUF(sc)",
            "caddr_t"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RL_CUR_TXMBUF",
          "args": [
            "sc"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RL_CUR_TXADDR",
          "args": [
            "sc"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "RL_CUR_TXMBUF(sc)"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RL_CUR_TXMBUF",
          "args": [
            "sc"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl_encap",
          "args": [
            "sc",
            "m_head"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "rl_encap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "875-921",
          "snippet": "int rl_encap(sc, m_head)\n\tstruct rl_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\t/*\n\t * The RealTek is brain damaged and wants longword-aligned\n\t * TX buffers, plus we can only have one fragment buffer\n\t * per packet. We have to copy pretty much all the time.\n\t */\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL)\n\t\treturn(1);\n\tif (m_head->m_pkthdr.len > MHLEN) {\n\t\tMCLGET(m_new, M_DONTWAIT);\n\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tm_freem(m_new);\n\t\t\treturn(1);\n\t\t}\n\t}\n\tm_copydata(m_head, 0, m_head->m_pkthdr.len, mtod(m_new, caddr_t));\n\tm_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;\n\tm_freem(m_head);\n\tm_head = m_new;\n\n\t/* Pad frames to at least 60 bytes. */\n\tif (m_head->m_pkthdr.len < RL_MIN_FRAMELEN) {\n\t\t/*\n\t\t * Make security concious people happy: zero out the\n\t\t * bytes in the pad area, since we don't know what\n\t\t * this mbuf cluster buffer's previous user might\n\t\t * have left in it.\n\t\t */\n\t\tbzero(mtod(m_head, char *) + m_head->m_pkthdr.len,\n\t\t    RL_MIN_FRAMELEN - m_head->m_pkthdr.len);\n\t\tm_head->m_pkthdr.len +=\n\t\t    (RL_MIN_FRAMELEN - m_head->m_pkthdr.len);\n\t\tm_head->m_len = m_head->m_pkthdr.len;\n\t}\n\n\tRL_CUR_TXMBUF(sc) = m_head;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int rl_encap"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint rl_encap;\n\nint rl_encap(sc, m_head)\n\tstruct rl_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\t/*\n\t * The RealTek is brain damaged and wants longword-aligned\n\t * TX buffers, plus we can only have one fragment buffer\n\t * per packet. We have to copy pretty much all the time.\n\t */\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL)\n\t\treturn(1);\n\tif (m_head->m_pkthdr.len > MHLEN) {\n\t\tMCLGET(m_new, M_DONTWAIT);\n\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tm_freem(m_new);\n\t\t\treturn(1);\n\t\t}\n\t}\n\tm_copydata(m_head, 0, m_head->m_pkthdr.len, mtod(m_new, caddr_t));\n\tm_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;\n\tm_freem(m_head);\n\tm_head = m_new;\n\n\t/* Pad frames to at least 60 bytes. */\n\tif (m_head->m_pkthdr.len < RL_MIN_FRAMELEN) {\n\t\t/*\n\t\t * Make security concious people happy: zero out the\n\t\t * bytes in the pad area, since we don't know what\n\t\t * this mbuf cluster buffer's previous user might\n\t\t * have left in it.\n\t\t */\n\t\tbzero(mtod(m_head, char *) + m_head->m_pkthdr.len,\n\t\t    RL_MIN_FRAMELEN - m_head->m_pkthdr.len);\n\t\tm_head->m_pkthdr.len +=\n\t\t    (RL_MIN_FRAMELEN - m_head->m_pkthdr.len);\n\t\tm_head->m_len = m_head->m_pkthdr.len;\n\t}\n\n\tRL_CUR_TXMBUF(sc) = m_head;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m_head"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RL_CUR_TXMBUF",
          "args": [
            "sc"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint rl_encap;\nvoid rl_start;\n\nvoid rl_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct rl_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tsc = ifp->if_softc;\n\n\twhile(RL_CUR_TXMBUF(sc) == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/* Pack the data into the descriptor. */\n\t\trl_encap(sc, m_head);\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, RL_CUR_TXMBUF(sc));\n#endif\n\t\t/*\n\t\t * Transmit the frame.\n\t \t */\n\t\tCSR_WRITE_4(sc, RL_CUR_TXADDR(sc),\n\t\t    vtophys(mtod(RL_CUR_TXMBUF(sc), caddr_t)));\n\t\tCSR_WRITE_4(sc, RL_CUR_TXSTAT(sc),\n\t\t    RL_TXTHRESH(sc->rl_txthresh) |\n\t\t    RL_CUR_TXMBUF(sc)->m_pkthdr.len);\n\n\t\tRL_INC(sc->rl_cdata.cur_tx);\n\t}\n\n\t/*\n\t * We broke out of the loop because all our TX slots are\n\t * full. Mark the NIC as busy until it drains some of the\n\t * packets from the queue.\n\t */\n\tif (RL_CUR_TXMBUF(sc) != NULL)\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}"
  },
  {
    "function_name": "rl_encap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "875-921",
    "snippet": "int rl_encap(sc, m_head)\n\tstruct rl_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\t/*\n\t * The RealTek is brain damaged and wants longword-aligned\n\t * TX buffers, plus we can only have one fragment buffer\n\t * per packet. We have to copy pretty much all the time.\n\t */\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL)\n\t\treturn(1);\n\tif (m_head->m_pkthdr.len > MHLEN) {\n\t\tMCLGET(m_new, M_DONTWAIT);\n\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tm_freem(m_new);\n\t\t\treturn(1);\n\t\t}\n\t}\n\tm_copydata(m_head, 0, m_head->m_pkthdr.len, mtod(m_new, caddr_t));\n\tm_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;\n\tm_freem(m_head);\n\tm_head = m_new;\n\n\t/* Pad frames to at least 60 bytes. */\n\tif (m_head->m_pkthdr.len < RL_MIN_FRAMELEN) {\n\t\t/*\n\t\t * Make security concious people happy: zero out the\n\t\t * bytes in the pad area, since we don't know what\n\t\t * this mbuf cluster buffer's previous user might\n\t\t * have left in it.\n\t\t */\n\t\tbzero(mtod(m_head, char *) + m_head->m_pkthdr.len,\n\t\t    RL_MIN_FRAMELEN - m_head->m_pkthdr.len);\n\t\tm_head->m_pkthdr.len +=\n\t\t    (RL_MIN_FRAMELEN - m_head->m_pkthdr.len);\n\t\tm_head->m_len = m_head->m_pkthdr.len;\n\t}\n\n\tRL_CUR_TXMBUF(sc) = m_head;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int rl_encap"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RL_CUR_TXMBUF",
          "args": [
            "sc"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_head"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "m_head",
            "0",
            "m_head->m_pkthdr.len",
            "mtod(m_new, caddr_t)"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m_new",
            "caddr_t"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_new"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m_new",
            "M_DONTWAIT"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m_new",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint rl_encap;\n\nint rl_encap(sc, m_head)\n\tstruct rl_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\t/*\n\t * The RealTek is brain damaged and wants longword-aligned\n\t * TX buffers, plus we can only have one fragment buffer\n\t * per packet. We have to copy pretty much all the time.\n\t */\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL)\n\t\treturn(1);\n\tif (m_head->m_pkthdr.len > MHLEN) {\n\t\tMCLGET(m_new, M_DONTWAIT);\n\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tm_freem(m_new);\n\t\t\treturn(1);\n\t\t}\n\t}\n\tm_copydata(m_head, 0, m_head->m_pkthdr.len, mtod(m_new, caddr_t));\n\tm_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;\n\tm_freem(m_head);\n\tm_head = m_new;\n\n\t/* Pad frames to at least 60 bytes. */\n\tif (m_head->m_pkthdr.len < RL_MIN_FRAMELEN) {\n\t\t/*\n\t\t * Make security concious people happy: zero out the\n\t\t * bytes in the pad area, since we don't know what\n\t\t * this mbuf cluster buffer's previous user might\n\t\t * have left in it.\n\t\t */\n\t\tbzero(mtod(m_head, char *) + m_head->m_pkthdr.len,\n\t\t    RL_MIN_FRAMELEN - m_head->m_pkthdr.len);\n\t\tm_head->m_pkthdr.len +=\n\t\t    (RL_MIN_FRAMELEN - m_head->m_pkthdr.len);\n\t\tm_head->m_len = m_head->m_pkthdr.len;\n\t}\n\n\tRL_CUR_TXMBUF(sc) = m_head;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "rl_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "823-869",
    "snippet": "int rl_intr(arg)\n\tvoid\t\t\t*arg;\n{\n\tstruct rl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\tclaimed = 0;\n\tu_int16_t\t\tstatus;\n\n\tsc = arg;\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Disable interrupts. */\n\tCSR_WRITE_2(sc, RL_IMR, 0x0000);\n\n\tfor (;;) {\n\n\t\tstatus = CSR_READ_2(sc, RL_ISR);\n\t\tif (status)\n\t\t\tCSR_WRITE_2(sc, RL_ISR, status);\n\n\t\tif ((status & RL_INTRS) == 0)\n\t\t\tbreak;\n\n\t\tif (status & RL_ISR_RX_OK)\n\t\t\trl_rxeof(sc);\n\n\t\tif (status & RL_ISR_RX_ERR)\n\t\t\trl_rxeof(sc);\n\n\t\tif ((status & RL_ISR_TX_OK) || (status & RL_ISR_TX_ERR))\n\t\t\trl_txeof(sc);\n\n\t\tif (status & RL_ISR_SYSTEM_ERR) {\n\t\t\trl_reset(sc);\n\t\t\trl_init(sc);\n\t\t}\n\t\tclaimed = 1;\n\t}\n\n\t/* Re-enable interrupts. */\n\tCSR_WRITE_2(sc, RL_IMR, RL_INTRS);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\trl_start(ifp);\n\n\treturn (claimed);\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int rl_intr",
      "void rl_rxeof",
      "void rl_txeof",
      "void rl_start",
      "void rl_init",
      "void rl_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rl_start",
          "args": [
            "ifp"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "rl_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "927-977",
          "snippet": "void rl_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct rl_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tsc = ifp->if_softc;\n\n\twhile(RL_CUR_TXMBUF(sc) == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/* Pack the data into the descriptor. */\n\t\trl_encap(sc, m_head);\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, RL_CUR_TXMBUF(sc));\n#endif\n\t\t/*\n\t\t * Transmit the frame.\n\t \t */\n\t\tCSR_WRITE_4(sc, RL_CUR_TXADDR(sc),\n\t\t    vtophys(mtod(RL_CUR_TXMBUF(sc), caddr_t)));\n\t\tCSR_WRITE_4(sc, RL_CUR_TXSTAT(sc),\n\t\t    RL_TXTHRESH(sc->rl_txthresh) |\n\t\t    RL_CUR_TXMBUF(sc)->m_pkthdr.len);\n\n\t\tRL_INC(sc->rl_cdata.cur_tx);\n\t}\n\n\t/*\n\t * We broke out of the loop because all our TX slots are\n\t * full. Mark the NIC as busy until it drains some of the\n\t * packets from the queue.\n\t */\n\tif (RL_CUR_TXMBUF(sc) != NULL)\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int rl_encap",
            "void rl_start"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint rl_encap;\nvoid rl_start;\n\nvoid rl_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct rl_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tsc = ifp->if_softc;\n\n\twhile(RL_CUR_TXMBUF(sc) == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/* Pack the data into the descriptor. */\n\t\trl_encap(sc, m_head);\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, RL_CUR_TXMBUF(sc));\n#endif\n\t\t/*\n\t\t * Transmit the frame.\n\t \t */\n\t\tCSR_WRITE_4(sc, RL_CUR_TXADDR(sc),\n\t\t    vtophys(mtod(RL_CUR_TXMBUF(sc), caddr_t)));\n\t\tCSR_WRITE_4(sc, RL_CUR_TXSTAT(sc),\n\t\t    RL_TXTHRESH(sc->rl_txthresh) |\n\t\t    RL_CUR_TXMBUF(sc)->m_pkthdr.len);\n\n\t\tRL_INC(sc->rl_cdata.cur_tx);\n\t}\n\n\t/*\n\t * We broke out of the loop because all our TX slots are\n\t * full. Mark the NIC as busy until it drains some of the\n\t * packets from the queue.\n\t */\n\tif (RL_CUR_TXMBUF(sc) != NULL)\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "RL_IMR",
            "RL_INTRS"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl_init",
          "args": [
            "sc"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "rl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "979-1071",
          "snippet": "void rl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct rl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int32_t\t\trxcfg = 0;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\trl_stop(sc);\n\n\t/* Init our MAC address */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, RL_IDR0 + i, sc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Init the RX buffer pointer register. */\n\tCSR_WRITE_4(sc, RL_RXADDR, vtophys(sc->rl_cdata.rl_rx_buf));\n\n\t/* Init TX descriptors. */\n\trl_list_tx_init(sc);\n\n\t/*\n\t * Enable transmit and receive.\n\t */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\t/*\n\t * Set the inital TX and RX configuration.\n\t */\n\tCSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);\n\tCSR_WRITE_4(sc, RL_RXCFG, RL_RXCFG_CONFIG);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxcfg = CSR_READ_4(sc, RL_RXCFG);\n\trxcfg |= RL_RXCFG_RX_INDIV;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxcfg |= RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxcfg |= RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\trl_setmulti(sc);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, RL_IMR, RL_INTRS);\n\n\t/* Set initial TX threshold */\n\tsc->rl_txthresh = RL_TX_THRESH_INIT;\n\n\t/* Start RX/TX process. */\n\tCSR_WRITE_4(sc, RL_MISSEDPKT, 0);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\tmii_mediachg(&sc->sc_mii);\n\n\tCSR_WRITE_1(sc, RL_CFG1, RL_CFG1_DRVLOAD|RL_CFG1_FULLDUPLEX);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(rl_tick, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_tick",
            "void rl_init",
            "void rl_stop",
            "void rl_setmulti",
            "int rl_list_tx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_tick;\nvoid rl_init;\nvoid rl_stop;\nvoid rl_setmulti;\nint rl_list_tx_init;\n\nvoid rl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct rl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int32_t\t\trxcfg = 0;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\trl_stop(sc);\n\n\t/* Init our MAC address */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, RL_IDR0 + i, sc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Init the RX buffer pointer register. */\n\tCSR_WRITE_4(sc, RL_RXADDR, vtophys(sc->rl_cdata.rl_rx_buf));\n\n\t/* Init TX descriptors. */\n\trl_list_tx_init(sc);\n\n\t/*\n\t * Enable transmit and receive.\n\t */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\t/*\n\t * Set the inital TX and RX configuration.\n\t */\n\tCSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);\n\tCSR_WRITE_4(sc, RL_RXCFG, RL_RXCFG_CONFIG);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxcfg = CSR_READ_4(sc, RL_RXCFG);\n\trxcfg |= RL_RXCFG_RX_INDIV;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxcfg |= RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxcfg |= RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\trl_setmulti(sc);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, RL_IMR, RL_INTRS);\n\n\t/* Set initial TX threshold */\n\tsc->rl_txthresh = RL_TX_THRESH_INIT;\n\n\t/* Start RX/TX process. */\n\tCSR_WRITE_4(sc, RL_MISSEDPKT, 0);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\tmii_mediachg(&sc->sc_mii);\n\n\tCSR_WRITE_1(sc, RL_CFG1, RL_CFG1_DRVLOAD|RL_CFG1_FULLDUPLEX);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(rl_tick, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rl_reset",
          "args": [
            "sc"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "rl_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "573-589",
          "snippet": "void rl_reset(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_RESET);\n\n\tfor (i = 0; i < RL_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_1(sc, RL_COMMAND) & RL_CMD_RESET))\n\t\t\tbreak;\n\t}\n\tif (i == RL_TIMEOUT)\n\t\tprintf(\"%s: reset never completed!\\n\", sc->sc_dev.dv_xname);\n\n        return;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_reset;\n\nvoid rl_reset(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_RESET);\n\n\tfor (i = 0; i < RL_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_1(sc, RL_COMMAND) & RL_CMD_RESET))\n\t\t\tbreak;\n\t}\n\tif (i == RL_TIMEOUT)\n\t\tprintf(\"%s: reset never completed!\\n\", sc->sc_dev.dv_xname);\n\n        return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rl_txeof",
          "args": [
            "sc"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "rl_txeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "770-821",
          "snippet": "void rl_txeof(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\ttxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Clear the timeout timer. */\n\tifp->if_timer = 0;\n\n\t/*\n\t * Go through our tx list and free mbufs for those\n\t * frames that have been uploaded.\n\t */\n\tdo {\n\t\ttxstat = CSR_READ_4(sc, RL_LAST_TXSTAT(sc));\n\t\tif (!(txstat & (RL_TXSTAT_TX_OK|\n\t\t    RL_TXSTAT_TX_UNDERRUN|RL_TXSTAT_TXABRT)))\n\t\t\tbreak;\n\n\t\tifp->if_collisions += (txstat & RL_TXSTAT_COLLCNT) >> 24;\n\n\t\tif (RL_LAST_TXMBUF(sc) != NULL) {\n\t\t\tm_freem(RL_LAST_TXMBUF(sc));\n\t\t\tRL_LAST_TXMBUF(sc) = NULL;\n\t\t}\n\t\tif (txstat & RL_TXSTAT_TX_OK)\n\t\t\tifp->if_opackets++;\n\t\telse {\n\t\t\tint oldthresh;\n\n\t\t\tifp->if_oerrors++;\n\t\t\tif ((txstat & RL_TXSTAT_TXABRT) ||\n\t\t\t    (txstat & RL_TXSTAT_OUTOFWIN))\n\t\t\t\tCSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);\n\t\t\toldthresh = sc->rl_txthresh;\n\t\t\t/* error recovery */\n\t\t\trl_reset(sc);\n\t\t\trl_init(sc);\n\t\t\t/*\n\t\t\t * If there was a transmit underrun,\n\t\t\t * bump the TX threshold.\n\t\t\t */\n\t\t\tif (txstat & RL_TXSTAT_TX_UNDERRUN)\n\t\t\t\tsc->rl_txthresh = oldthresh + 32;\n\t\t\treturn;\n\t\t}\n\t\tRL_INC(sc->rl_cdata.last_tx);\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t} while (sc->rl_cdata.last_tx != sc->rl_cdata.cur_tx);\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_txeof",
            "void rl_init",
            "void rl_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_txeof;\nvoid rl_init;\nvoid rl_reset;\n\nvoid rl_txeof(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\ttxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Clear the timeout timer. */\n\tifp->if_timer = 0;\n\n\t/*\n\t * Go through our tx list and free mbufs for those\n\t * frames that have been uploaded.\n\t */\n\tdo {\n\t\ttxstat = CSR_READ_4(sc, RL_LAST_TXSTAT(sc));\n\t\tif (!(txstat & (RL_TXSTAT_TX_OK|\n\t\t    RL_TXSTAT_TX_UNDERRUN|RL_TXSTAT_TXABRT)))\n\t\t\tbreak;\n\n\t\tifp->if_collisions += (txstat & RL_TXSTAT_COLLCNT) >> 24;\n\n\t\tif (RL_LAST_TXMBUF(sc) != NULL) {\n\t\t\tm_freem(RL_LAST_TXMBUF(sc));\n\t\t\tRL_LAST_TXMBUF(sc) = NULL;\n\t\t}\n\t\tif (txstat & RL_TXSTAT_TX_OK)\n\t\t\tifp->if_opackets++;\n\t\telse {\n\t\t\tint oldthresh;\n\n\t\t\tifp->if_oerrors++;\n\t\t\tif ((txstat & RL_TXSTAT_TXABRT) ||\n\t\t\t    (txstat & RL_TXSTAT_OUTOFWIN))\n\t\t\t\tCSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);\n\t\t\toldthresh = sc->rl_txthresh;\n\t\t\t/* error recovery */\n\t\t\trl_reset(sc);\n\t\t\trl_init(sc);\n\t\t\t/*\n\t\t\t * If there was a transmit underrun,\n\t\t\t * bump the TX threshold.\n\t\t\t */\n\t\t\tif (txstat & RL_TXSTAT_TX_UNDERRUN)\n\t\t\t\tsc->rl_txthresh = oldthresh + 32;\n\t\t\treturn;\n\t\t}\n\t\tRL_INC(sc->rl_cdata.last_tx);\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t} while (sc->rl_cdata.last_tx != sc->rl_cdata.cur_tx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rl_rxeof",
          "args": [
            "sc"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "rl_rxeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "640-764",
          "snippet": "void rl_rxeof(sc)\n\tstruct rl_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tint\t\t\ttotal_len = 0;\n\tu_int32_t\t\trxstat;\n\tcaddr_t\t\t\trxbufpos;\n\tint\t\t\twrap = 0;\n\tu_int16_t\t\tcur_rx;\n\tu_int16_t\t\tlimit;\n\tu_int16_t\t\trx_bytes = 0, max_bytes;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tcur_rx = (CSR_READ_2(sc, RL_CURRXADDR) + 16) % RL_RXBUFLEN;\n\n\t/* Do not try to read past this point. */\n\tlimit = CSR_READ_2(sc, RL_CURRXBUF) % RL_RXBUFLEN;\n\n\tif (limit < cur_rx)\n\t\tmax_bytes = (RL_RXBUFLEN - cur_rx) + limit;\n\telse\n\t\tmax_bytes = limit - cur_rx;\n\n\twhile((CSR_READ_1(sc, RL_COMMAND) & RL_CMD_EMPTY_RXBUF) == 0) {\n\t\trxbufpos = sc->rl_cdata.rl_rx_buf + cur_rx;\n\t\trxstat = *(u_int32_t *)rxbufpos;\n\n\t\t/*\n\t\t * Here's a totally undocumented fact for you. When the\n\t\t * RealTek chip is in the process of copying a packet into\n\t\t * RAM for you, the length will be 0xfff0. If you spot a\n\t\t * packet header with this value, you need to stop. The\n\t\t * datasheet makes absolutely no mention of this and\n\t\t * RealTek should be shot for this.\n\t\t */\n\t\tif ((u_int16_t)(rxstat >> 16) == RL_RXSTAT_UNFINISHED)\n\t\t\tbreak;\n\t\n\t\tif (!(rxstat & RL_RXSTAT_RXOK)) {\n\t\t\tifp->if_ierrors++;\n\t\t\trl_init(sc);\n\t\t\treturn;\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\ttotal_len = rxstat >> 16;\n\t\trx_bytes += total_len + 4;\n\n\t\t/*\n\t\t * XXX The RealTek chip includes the CRC with every\n\t\t * received frame, and there's no way to turn this\n\t\t * behavior off (at least, I can't find anything in\n\t \t * the manual that explains how to do it) so we have\n\t\t * to trim off the CRC manually.\n\t\t */\n\t\ttotal_len -= ETHER_CRC_LEN;\n\n\t\t/*\n\t\t * Avoid trying to read more bytes than we know\n\t\t * the chip has prepared for us.\n\t\t */\n\t\tif (rx_bytes > max_bytes)\n\t\t\tbreak;\n\n\t\trxbufpos = sc->rl_cdata.rl_rx_buf +\n\t\t\t((cur_rx + sizeof(u_int32_t)) % RL_RXBUFLEN);\n\n\t\tif (rxbufpos == (sc->rl_cdata.rl_rx_buf + RL_RXBUFLEN))\n\t\t\trxbufpos = sc->rl_cdata.rl_rx_buf;\n\n\t\twrap = (sc->rl_cdata.rl_rx_buf + RL_RXBUFLEN) - rxbufpos;\n\n\t\tif (total_len > wrap) {\n\t\t\tm = m_devget(rxbufpos - RL_ETHER_ALIGN,\n\t\t\t    wrap + RL_ETHER_ALIGN, 0, ifp, NULL);\n\t\t\tif (m == NULL)\n\t\t\t\tifp->if_ierrors++;\n\t\t\telse {\n\t\t\t\tm_adj(m, RL_ETHER_ALIGN);\n\t\t\t\tm_copyback(m, wrap, total_len - wrap,\n\t\t\t\t\tsc->rl_cdata.rl_rx_buf);\n\t\t\t\tm = m_pullup(m, sizeof(struct ether_header));\n\t\t\t\tif (m == NULL)\n\t\t\t\t\tifp->if_ierrors++;\n\t\t\t}\n\t\t\tcur_rx = (total_len - wrap + ETHER_CRC_LEN);\n\t\t} else {\n\t\t\tm = m_devget(rxbufpos - RL_ETHER_ALIGN,\n\t\t\t    total_len + RL_ETHER_ALIGN, 0, ifp, NULL);\n\t\t\tif (m == NULL)\n\t\t\t\tifp->if_ierrors++;\n\t\t\telse\n\t\t\t\tm_adj(m, RL_ETHER_ALIGN);\n\t\t\tcur_rx += total_len + 4 + ETHER_CRC_LEN;\n\t\t}\n\n\t\t/*\n\t\t * Round up to 32-bit boundary.\n\t\t */\n\t\tcur_rx = (cur_rx + 3) & ~3;\n\t\tCSR_WRITE_2(sc, RL_CURRXADDR, cur_rx - 16);\n\n\t\tif (m == NULL)\n\t\t\tcontinue;\n\n\t\teh = mtod(m, struct ether_header *);\n\t\tifp->if_ipackets++;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Handle BPF listeners. Let the BPF user see the packet.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_rxeof",
            "void rl_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_rxeof;\nvoid rl_init;\n\nvoid rl_rxeof(sc)\n\tstruct rl_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tint\t\t\ttotal_len = 0;\n\tu_int32_t\t\trxstat;\n\tcaddr_t\t\t\trxbufpos;\n\tint\t\t\twrap = 0;\n\tu_int16_t\t\tcur_rx;\n\tu_int16_t\t\tlimit;\n\tu_int16_t\t\trx_bytes = 0, max_bytes;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tcur_rx = (CSR_READ_2(sc, RL_CURRXADDR) + 16) % RL_RXBUFLEN;\n\n\t/* Do not try to read past this point. */\n\tlimit = CSR_READ_2(sc, RL_CURRXBUF) % RL_RXBUFLEN;\n\n\tif (limit < cur_rx)\n\t\tmax_bytes = (RL_RXBUFLEN - cur_rx) + limit;\n\telse\n\t\tmax_bytes = limit - cur_rx;\n\n\twhile((CSR_READ_1(sc, RL_COMMAND) & RL_CMD_EMPTY_RXBUF) == 0) {\n\t\trxbufpos = sc->rl_cdata.rl_rx_buf + cur_rx;\n\t\trxstat = *(u_int32_t *)rxbufpos;\n\n\t\t/*\n\t\t * Here's a totally undocumented fact for you. When the\n\t\t * RealTek chip is in the process of copying a packet into\n\t\t * RAM for you, the length will be 0xfff0. If you spot a\n\t\t * packet header with this value, you need to stop. The\n\t\t * datasheet makes absolutely no mention of this and\n\t\t * RealTek should be shot for this.\n\t\t */\n\t\tif ((u_int16_t)(rxstat >> 16) == RL_RXSTAT_UNFINISHED)\n\t\t\tbreak;\n\t\n\t\tif (!(rxstat & RL_RXSTAT_RXOK)) {\n\t\t\tifp->if_ierrors++;\n\t\t\trl_init(sc);\n\t\t\treturn;\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\ttotal_len = rxstat >> 16;\n\t\trx_bytes += total_len + 4;\n\n\t\t/*\n\t\t * XXX The RealTek chip includes the CRC with every\n\t\t * received frame, and there's no way to turn this\n\t\t * behavior off (at least, I can't find anything in\n\t \t * the manual that explains how to do it) so we have\n\t\t * to trim off the CRC manually.\n\t\t */\n\t\ttotal_len -= ETHER_CRC_LEN;\n\n\t\t/*\n\t\t * Avoid trying to read more bytes than we know\n\t\t * the chip has prepared for us.\n\t\t */\n\t\tif (rx_bytes > max_bytes)\n\t\t\tbreak;\n\n\t\trxbufpos = sc->rl_cdata.rl_rx_buf +\n\t\t\t((cur_rx + sizeof(u_int32_t)) % RL_RXBUFLEN);\n\n\t\tif (rxbufpos == (sc->rl_cdata.rl_rx_buf + RL_RXBUFLEN))\n\t\t\trxbufpos = sc->rl_cdata.rl_rx_buf;\n\n\t\twrap = (sc->rl_cdata.rl_rx_buf + RL_RXBUFLEN) - rxbufpos;\n\n\t\tif (total_len > wrap) {\n\t\t\tm = m_devget(rxbufpos - RL_ETHER_ALIGN,\n\t\t\t    wrap + RL_ETHER_ALIGN, 0, ifp, NULL);\n\t\t\tif (m == NULL)\n\t\t\t\tifp->if_ierrors++;\n\t\t\telse {\n\t\t\t\tm_adj(m, RL_ETHER_ALIGN);\n\t\t\t\tm_copyback(m, wrap, total_len - wrap,\n\t\t\t\t\tsc->rl_cdata.rl_rx_buf);\n\t\t\t\tm = m_pullup(m, sizeof(struct ether_header));\n\t\t\t\tif (m == NULL)\n\t\t\t\t\tifp->if_ierrors++;\n\t\t\t}\n\t\t\tcur_rx = (total_len - wrap + ETHER_CRC_LEN);\n\t\t} else {\n\t\t\tm = m_devget(rxbufpos - RL_ETHER_ALIGN,\n\t\t\t    total_len + RL_ETHER_ALIGN, 0, ifp, NULL);\n\t\t\tif (m == NULL)\n\t\t\t\tifp->if_ierrors++;\n\t\t\telse\n\t\t\t\tm_adj(m, RL_ETHER_ALIGN);\n\t\t\tcur_rx += total_len + 4 + ETHER_CRC_LEN;\n\t\t}\n\n\t\t/*\n\t\t * Round up to 32-bit boundary.\n\t\t */\n\t\tcur_rx = (cur_rx + 3) & ~3;\n\t\tCSR_WRITE_2(sc, RL_CURRXADDR, cur_rx - 16);\n\n\t\tif (m == NULL)\n\t\t\tcontinue;\n\n\t\teh = mtod(m, struct ether_header *);\n\t\tifp->if_ipackets++;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Handle BPF listeners. Let the BPF user see the packet.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "RL_ISR",
            "status"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "RL_ISR"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "RL_IMR",
            "0x0000"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint rl_intr;\nvoid rl_rxeof;\nvoid rl_txeof;\nvoid rl_start;\nvoid rl_init;\nvoid rl_reset;\n\nint rl_intr(arg)\n\tvoid\t\t\t*arg;\n{\n\tstruct rl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\tclaimed = 0;\n\tu_int16_t\t\tstatus;\n\n\tsc = arg;\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Disable interrupts. */\n\tCSR_WRITE_2(sc, RL_IMR, 0x0000);\n\n\tfor (;;) {\n\n\t\tstatus = CSR_READ_2(sc, RL_ISR);\n\t\tif (status)\n\t\t\tCSR_WRITE_2(sc, RL_ISR, status);\n\n\t\tif ((status & RL_INTRS) == 0)\n\t\t\tbreak;\n\n\t\tif (status & RL_ISR_RX_OK)\n\t\t\trl_rxeof(sc);\n\n\t\tif (status & RL_ISR_RX_ERR)\n\t\t\trl_rxeof(sc);\n\n\t\tif ((status & RL_ISR_TX_OK) || (status & RL_ISR_TX_ERR))\n\t\t\trl_txeof(sc);\n\n\t\tif (status & RL_ISR_SYSTEM_ERR) {\n\t\t\trl_reset(sc);\n\t\t\trl_init(sc);\n\t\t}\n\t\tclaimed = 1;\n\t}\n\n\t/* Re-enable interrupts. */\n\tCSR_WRITE_2(sc, RL_IMR, RL_INTRS);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\trl_start(ifp);\n\n\treturn (claimed);\n}"
  },
  {
    "function_name": "rl_txeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "770-821",
    "snippet": "void rl_txeof(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\ttxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Clear the timeout timer. */\n\tifp->if_timer = 0;\n\n\t/*\n\t * Go through our tx list and free mbufs for those\n\t * frames that have been uploaded.\n\t */\n\tdo {\n\t\ttxstat = CSR_READ_4(sc, RL_LAST_TXSTAT(sc));\n\t\tif (!(txstat & (RL_TXSTAT_TX_OK|\n\t\t    RL_TXSTAT_TX_UNDERRUN|RL_TXSTAT_TXABRT)))\n\t\t\tbreak;\n\n\t\tifp->if_collisions += (txstat & RL_TXSTAT_COLLCNT) >> 24;\n\n\t\tif (RL_LAST_TXMBUF(sc) != NULL) {\n\t\t\tm_freem(RL_LAST_TXMBUF(sc));\n\t\t\tRL_LAST_TXMBUF(sc) = NULL;\n\t\t}\n\t\tif (txstat & RL_TXSTAT_TX_OK)\n\t\t\tifp->if_opackets++;\n\t\telse {\n\t\t\tint oldthresh;\n\n\t\t\tifp->if_oerrors++;\n\t\t\tif ((txstat & RL_TXSTAT_TXABRT) ||\n\t\t\t    (txstat & RL_TXSTAT_OUTOFWIN))\n\t\t\t\tCSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);\n\t\t\toldthresh = sc->rl_txthresh;\n\t\t\t/* error recovery */\n\t\t\trl_reset(sc);\n\t\t\trl_init(sc);\n\t\t\t/*\n\t\t\t * If there was a transmit underrun,\n\t\t\t * bump the TX threshold.\n\t\t\t */\n\t\t\tif (txstat & RL_TXSTAT_TX_UNDERRUN)\n\t\t\t\tsc->rl_txthresh = oldthresh + 32;\n\t\t\treturn;\n\t\t}\n\t\tRL_INC(sc->rl_cdata.last_tx);\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t} while (sc->rl_cdata.last_tx != sc->rl_cdata.cur_tx);\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rl_txeof",
      "void rl_init",
      "void rl_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RL_INC",
          "args": [
            "sc->rl_cdata.last_tx"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl_init",
          "args": [
            "sc"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "rl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "979-1071",
          "snippet": "void rl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct rl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int32_t\t\trxcfg = 0;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\trl_stop(sc);\n\n\t/* Init our MAC address */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, RL_IDR0 + i, sc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Init the RX buffer pointer register. */\n\tCSR_WRITE_4(sc, RL_RXADDR, vtophys(sc->rl_cdata.rl_rx_buf));\n\n\t/* Init TX descriptors. */\n\trl_list_tx_init(sc);\n\n\t/*\n\t * Enable transmit and receive.\n\t */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\t/*\n\t * Set the inital TX and RX configuration.\n\t */\n\tCSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);\n\tCSR_WRITE_4(sc, RL_RXCFG, RL_RXCFG_CONFIG);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxcfg = CSR_READ_4(sc, RL_RXCFG);\n\trxcfg |= RL_RXCFG_RX_INDIV;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxcfg |= RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxcfg |= RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\trl_setmulti(sc);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, RL_IMR, RL_INTRS);\n\n\t/* Set initial TX threshold */\n\tsc->rl_txthresh = RL_TX_THRESH_INIT;\n\n\t/* Start RX/TX process. */\n\tCSR_WRITE_4(sc, RL_MISSEDPKT, 0);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\tmii_mediachg(&sc->sc_mii);\n\n\tCSR_WRITE_1(sc, RL_CFG1, RL_CFG1_DRVLOAD|RL_CFG1_FULLDUPLEX);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(rl_tick, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_tick",
            "void rl_init",
            "void rl_stop",
            "void rl_setmulti",
            "int rl_list_tx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_tick;\nvoid rl_init;\nvoid rl_stop;\nvoid rl_setmulti;\nint rl_list_tx_init;\n\nvoid rl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct rl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int32_t\t\trxcfg = 0;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\trl_stop(sc);\n\n\t/* Init our MAC address */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, RL_IDR0 + i, sc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Init the RX buffer pointer register. */\n\tCSR_WRITE_4(sc, RL_RXADDR, vtophys(sc->rl_cdata.rl_rx_buf));\n\n\t/* Init TX descriptors. */\n\trl_list_tx_init(sc);\n\n\t/*\n\t * Enable transmit and receive.\n\t */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\t/*\n\t * Set the inital TX and RX configuration.\n\t */\n\tCSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);\n\tCSR_WRITE_4(sc, RL_RXCFG, RL_RXCFG_CONFIG);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxcfg = CSR_READ_4(sc, RL_RXCFG);\n\trxcfg |= RL_RXCFG_RX_INDIV;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxcfg |= RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxcfg |= RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\trl_setmulti(sc);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, RL_IMR, RL_INTRS);\n\n\t/* Set initial TX threshold */\n\tsc->rl_txthresh = RL_TX_THRESH_INIT;\n\n\t/* Start RX/TX process. */\n\tCSR_WRITE_4(sc, RL_MISSEDPKT, 0);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\tmii_mediachg(&sc->sc_mii);\n\n\tCSR_WRITE_1(sc, RL_CFG1, RL_CFG1_DRVLOAD|RL_CFG1_FULLDUPLEX);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(rl_tick, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rl_reset",
          "args": [
            "sc"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "rl_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "573-589",
          "snippet": "void rl_reset(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_RESET);\n\n\tfor (i = 0; i < RL_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_1(sc, RL_COMMAND) & RL_CMD_RESET))\n\t\t\tbreak;\n\t}\n\tif (i == RL_TIMEOUT)\n\t\tprintf(\"%s: reset never completed!\\n\", sc->sc_dev.dv_xname);\n\n        return;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_reset;\n\nvoid rl_reset(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_RESET);\n\n\tfor (i = 0; i < RL_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_1(sc, RL_COMMAND) & RL_CMD_RESET))\n\t\t\tbreak;\n\t}\n\tif (i == RL_TIMEOUT)\n\t\tprintf(\"%s: reset never completed!\\n\", sc->sc_dev.dv_xname);\n\n        return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_TXCFG",
            "RL_TXCFG_CONFIG"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RL_LAST_TXMBUF",
          "args": [
            "sc"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "RL_LAST_TXMBUF(sc)"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RL_LAST_TXMBUF",
          "args": [
            "sc"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RL_LAST_TXMBUF",
          "args": [
            "sc"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "RL_LAST_TXSTAT(sc)"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RL_LAST_TXSTAT",
          "args": [
            "sc"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_txeof;\nvoid rl_init;\nvoid rl_reset;\n\nvoid rl_txeof(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\ttxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Clear the timeout timer. */\n\tifp->if_timer = 0;\n\n\t/*\n\t * Go through our tx list and free mbufs for those\n\t * frames that have been uploaded.\n\t */\n\tdo {\n\t\ttxstat = CSR_READ_4(sc, RL_LAST_TXSTAT(sc));\n\t\tif (!(txstat & (RL_TXSTAT_TX_OK|\n\t\t    RL_TXSTAT_TX_UNDERRUN|RL_TXSTAT_TXABRT)))\n\t\t\tbreak;\n\n\t\tifp->if_collisions += (txstat & RL_TXSTAT_COLLCNT) >> 24;\n\n\t\tif (RL_LAST_TXMBUF(sc) != NULL) {\n\t\t\tm_freem(RL_LAST_TXMBUF(sc));\n\t\t\tRL_LAST_TXMBUF(sc) = NULL;\n\t\t}\n\t\tif (txstat & RL_TXSTAT_TX_OK)\n\t\t\tifp->if_opackets++;\n\t\telse {\n\t\t\tint oldthresh;\n\n\t\t\tifp->if_oerrors++;\n\t\t\tif ((txstat & RL_TXSTAT_TXABRT) ||\n\t\t\t    (txstat & RL_TXSTAT_OUTOFWIN))\n\t\t\t\tCSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);\n\t\t\toldthresh = sc->rl_txthresh;\n\t\t\t/* error recovery */\n\t\t\trl_reset(sc);\n\t\t\trl_init(sc);\n\t\t\t/*\n\t\t\t * If there was a transmit underrun,\n\t\t\t * bump the TX threshold.\n\t\t\t */\n\t\t\tif (txstat & RL_TXSTAT_TX_UNDERRUN)\n\t\t\t\tsc->rl_txthresh = oldthresh + 32;\n\t\t\treturn;\n\t\t}\n\t\tRL_INC(sc->rl_cdata.last_tx);\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t} while (sc->rl_cdata.last_tx != sc->rl_cdata.cur_tx);\n}"
  },
  {
    "function_name": "rl_rxeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "640-764",
    "snippet": "void rl_rxeof(sc)\n\tstruct rl_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tint\t\t\ttotal_len = 0;\n\tu_int32_t\t\trxstat;\n\tcaddr_t\t\t\trxbufpos;\n\tint\t\t\twrap = 0;\n\tu_int16_t\t\tcur_rx;\n\tu_int16_t\t\tlimit;\n\tu_int16_t\t\trx_bytes = 0, max_bytes;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tcur_rx = (CSR_READ_2(sc, RL_CURRXADDR) + 16) % RL_RXBUFLEN;\n\n\t/* Do not try to read past this point. */\n\tlimit = CSR_READ_2(sc, RL_CURRXBUF) % RL_RXBUFLEN;\n\n\tif (limit < cur_rx)\n\t\tmax_bytes = (RL_RXBUFLEN - cur_rx) + limit;\n\telse\n\t\tmax_bytes = limit - cur_rx;\n\n\twhile((CSR_READ_1(sc, RL_COMMAND) & RL_CMD_EMPTY_RXBUF) == 0) {\n\t\trxbufpos = sc->rl_cdata.rl_rx_buf + cur_rx;\n\t\trxstat = *(u_int32_t *)rxbufpos;\n\n\t\t/*\n\t\t * Here's a totally undocumented fact for you. When the\n\t\t * RealTek chip is in the process of copying a packet into\n\t\t * RAM for you, the length will be 0xfff0. If you spot a\n\t\t * packet header with this value, you need to stop. The\n\t\t * datasheet makes absolutely no mention of this and\n\t\t * RealTek should be shot for this.\n\t\t */\n\t\tif ((u_int16_t)(rxstat >> 16) == RL_RXSTAT_UNFINISHED)\n\t\t\tbreak;\n\t\n\t\tif (!(rxstat & RL_RXSTAT_RXOK)) {\n\t\t\tifp->if_ierrors++;\n\t\t\trl_init(sc);\n\t\t\treturn;\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\ttotal_len = rxstat >> 16;\n\t\trx_bytes += total_len + 4;\n\n\t\t/*\n\t\t * XXX The RealTek chip includes the CRC with every\n\t\t * received frame, and there's no way to turn this\n\t\t * behavior off (at least, I can't find anything in\n\t \t * the manual that explains how to do it) so we have\n\t\t * to trim off the CRC manually.\n\t\t */\n\t\ttotal_len -= ETHER_CRC_LEN;\n\n\t\t/*\n\t\t * Avoid trying to read more bytes than we know\n\t\t * the chip has prepared for us.\n\t\t */\n\t\tif (rx_bytes > max_bytes)\n\t\t\tbreak;\n\n\t\trxbufpos = sc->rl_cdata.rl_rx_buf +\n\t\t\t((cur_rx + sizeof(u_int32_t)) % RL_RXBUFLEN);\n\n\t\tif (rxbufpos == (sc->rl_cdata.rl_rx_buf + RL_RXBUFLEN))\n\t\t\trxbufpos = sc->rl_cdata.rl_rx_buf;\n\n\t\twrap = (sc->rl_cdata.rl_rx_buf + RL_RXBUFLEN) - rxbufpos;\n\n\t\tif (total_len > wrap) {\n\t\t\tm = m_devget(rxbufpos - RL_ETHER_ALIGN,\n\t\t\t    wrap + RL_ETHER_ALIGN, 0, ifp, NULL);\n\t\t\tif (m == NULL)\n\t\t\t\tifp->if_ierrors++;\n\t\t\telse {\n\t\t\t\tm_adj(m, RL_ETHER_ALIGN);\n\t\t\t\tm_copyback(m, wrap, total_len - wrap,\n\t\t\t\t\tsc->rl_cdata.rl_rx_buf);\n\t\t\t\tm = m_pullup(m, sizeof(struct ether_header));\n\t\t\t\tif (m == NULL)\n\t\t\t\t\tifp->if_ierrors++;\n\t\t\t}\n\t\t\tcur_rx = (total_len - wrap + ETHER_CRC_LEN);\n\t\t} else {\n\t\t\tm = m_devget(rxbufpos - RL_ETHER_ALIGN,\n\t\t\t    total_len + RL_ETHER_ALIGN, 0, ifp, NULL);\n\t\t\tif (m == NULL)\n\t\t\t\tifp->if_ierrors++;\n\t\t\telse\n\t\t\t\tm_adj(m, RL_ETHER_ALIGN);\n\t\t\tcur_rx += total_len + 4 + ETHER_CRC_LEN;\n\t\t}\n\n\t\t/*\n\t\t * Round up to 32-bit boundary.\n\t\t */\n\t\tcur_rx = (cur_rx + 3) & ~3;\n\t\tCSR_WRITE_2(sc, RL_CURRXADDR, cur_rx - 16);\n\n\t\tif (m == NULL)\n\t\t\tcontinue;\n\n\t\teh = mtod(m, struct ether_header *);\n\t\tifp->if_ipackets++;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Handle BPF listeners. Let the BPF user see the packet.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rl_rxeof",
      "void rl_init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "sizeof(struct ether_header)"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "RL_CURRXADDR",
            "cur_rx - 16"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "RL_ETHER_ALIGN"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_devget",
          "args": [
            "rxbufpos - RL_ETHER_ALIGN",
            "total_len + RL_ETHER_ALIGN",
            "0",
            "ifp",
            "NULL"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_pullup",
          "args": [
            "m",
            "sizeof(struct ether_header)"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copyback",
          "args": [
            "m",
            "wrap",
            "total_len - wrap",
            "sc->rl_cdata.rl_rx_buf"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "RL_ETHER_ALIGN"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_devget",
          "args": [
            "rxbufpos - RL_ETHER_ALIGN",
            "wrap + RL_ETHER_ALIGN",
            "0",
            "ifp",
            "NULL"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl_init",
          "args": [
            "sc"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "rl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "979-1071",
          "snippet": "void rl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct rl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int32_t\t\trxcfg = 0;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\trl_stop(sc);\n\n\t/* Init our MAC address */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, RL_IDR0 + i, sc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Init the RX buffer pointer register. */\n\tCSR_WRITE_4(sc, RL_RXADDR, vtophys(sc->rl_cdata.rl_rx_buf));\n\n\t/* Init TX descriptors. */\n\trl_list_tx_init(sc);\n\n\t/*\n\t * Enable transmit and receive.\n\t */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\t/*\n\t * Set the inital TX and RX configuration.\n\t */\n\tCSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);\n\tCSR_WRITE_4(sc, RL_RXCFG, RL_RXCFG_CONFIG);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxcfg = CSR_READ_4(sc, RL_RXCFG);\n\trxcfg |= RL_RXCFG_RX_INDIV;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxcfg |= RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxcfg |= RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\trl_setmulti(sc);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, RL_IMR, RL_INTRS);\n\n\t/* Set initial TX threshold */\n\tsc->rl_txthresh = RL_TX_THRESH_INIT;\n\n\t/* Start RX/TX process. */\n\tCSR_WRITE_4(sc, RL_MISSEDPKT, 0);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\tmii_mediachg(&sc->sc_mii);\n\n\tCSR_WRITE_1(sc, RL_CFG1, RL_CFG1_DRVLOAD|RL_CFG1_FULLDUPLEX);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(rl_tick, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_tick",
            "void rl_init",
            "void rl_stop",
            "void rl_setmulti",
            "int rl_list_tx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_tick;\nvoid rl_init;\nvoid rl_stop;\nvoid rl_setmulti;\nint rl_list_tx_init;\n\nvoid rl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct rl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int32_t\t\trxcfg = 0;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\trl_stop(sc);\n\n\t/* Init our MAC address */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, RL_IDR0 + i, sc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Init the RX buffer pointer register. */\n\tCSR_WRITE_4(sc, RL_RXADDR, vtophys(sc->rl_cdata.rl_rx_buf));\n\n\t/* Init TX descriptors. */\n\trl_list_tx_init(sc);\n\n\t/*\n\t * Enable transmit and receive.\n\t */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\t/*\n\t * Set the inital TX and RX configuration.\n\t */\n\tCSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);\n\tCSR_WRITE_4(sc, RL_RXCFG, RL_RXCFG_CONFIG);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxcfg = CSR_READ_4(sc, RL_RXCFG);\n\trxcfg |= RL_RXCFG_RX_INDIV;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxcfg |= RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_ALLPHYS;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxcfg |= RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t} else {\n\t\trxcfg &= ~RL_RXCFG_RX_BROAD;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxcfg);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\trl_setmulti(sc);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, RL_IMR, RL_INTRS);\n\n\t/* Set initial TX threshold */\n\tsc->rl_txthresh = RL_TX_THRESH_INIT;\n\n\t/* Start RX/TX process. */\n\tCSR_WRITE_4(sc, RL_MISSEDPKT, 0);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);\n\n\tmii_mediachg(&sc->sc_mii);\n\n\tCSR_WRITE_1(sc, RL_CFG1, RL_CFG1_DRVLOAD|RL_CFG1_FULLDUPLEX);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(rl_tick, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "rxstat >> 16"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "RL_COMMAND"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "RL_CURRXBUF"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "RL_CURRXADDR"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_rxeof;\nvoid rl_init;\n\nvoid rl_rxeof(sc)\n\tstruct rl_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tint\t\t\ttotal_len = 0;\n\tu_int32_t\t\trxstat;\n\tcaddr_t\t\t\trxbufpos;\n\tint\t\t\twrap = 0;\n\tu_int16_t\t\tcur_rx;\n\tu_int16_t\t\tlimit;\n\tu_int16_t\t\trx_bytes = 0, max_bytes;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tcur_rx = (CSR_READ_2(sc, RL_CURRXADDR) + 16) % RL_RXBUFLEN;\n\n\t/* Do not try to read past this point. */\n\tlimit = CSR_READ_2(sc, RL_CURRXBUF) % RL_RXBUFLEN;\n\n\tif (limit < cur_rx)\n\t\tmax_bytes = (RL_RXBUFLEN - cur_rx) + limit;\n\telse\n\t\tmax_bytes = limit - cur_rx;\n\n\twhile((CSR_READ_1(sc, RL_COMMAND) & RL_CMD_EMPTY_RXBUF) == 0) {\n\t\trxbufpos = sc->rl_cdata.rl_rx_buf + cur_rx;\n\t\trxstat = *(u_int32_t *)rxbufpos;\n\n\t\t/*\n\t\t * Here's a totally undocumented fact for you. When the\n\t\t * RealTek chip is in the process of copying a packet into\n\t\t * RAM for you, the length will be 0xfff0. If you spot a\n\t\t * packet header with this value, you need to stop. The\n\t\t * datasheet makes absolutely no mention of this and\n\t\t * RealTek should be shot for this.\n\t\t */\n\t\tif ((u_int16_t)(rxstat >> 16) == RL_RXSTAT_UNFINISHED)\n\t\t\tbreak;\n\t\n\t\tif (!(rxstat & RL_RXSTAT_RXOK)) {\n\t\t\tifp->if_ierrors++;\n\t\t\trl_init(sc);\n\t\t\treturn;\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\ttotal_len = rxstat >> 16;\n\t\trx_bytes += total_len + 4;\n\n\t\t/*\n\t\t * XXX The RealTek chip includes the CRC with every\n\t\t * received frame, and there's no way to turn this\n\t\t * behavior off (at least, I can't find anything in\n\t \t * the manual that explains how to do it) so we have\n\t\t * to trim off the CRC manually.\n\t\t */\n\t\ttotal_len -= ETHER_CRC_LEN;\n\n\t\t/*\n\t\t * Avoid trying to read more bytes than we know\n\t\t * the chip has prepared for us.\n\t\t */\n\t\tif (rx_bytes > max_bytes)\n\t\t\tbreak;\n\n\t\trxbufpos = sc->rl_cdata.rl_rx_buf +\n\t\t\t((cur_rx + sizeof(u_int32_t)) % RL_RXBUFLEN);\n\n\t\tif (rxbufpos == (sc->rl_cdata.rl_rx_buf + RL_RXBUFLEN))\n\t\t\trxbufpos = sc->rl_cdata.rl_rx_buf;\n\n\t\twrap = (sc->rl_cdata.rl_rx_buf + RL_RXBUFLEN) - rxbufpos;\n\n\t\tif (total_len > wrap) {\n\t\t\tm = m_devget(rxbufpos - RL_ETHER_ALIGN,\n\t\t\t    wrap + RL_ETHER_ALIGN, 0, ifp, NULL);\n\t\t\tif (m == NULL)\n\t\t\t\tifp->if_ierrors++;\n\t\t\telse {\n\t\t\t\tm_adj(m, RL_ETHER_ALIGN);\n\t\t\t\tm_copyback(m, wrap, total_len - wrap,\n\t\t\t\t\tsc->rl_cdata.rl_rx_buf);\n\t\t\t\tm = m_pullup(m, sizeof(struct ether_header));\n\t\t\t\tif (m == NULL)\n\t\t\t\t\tifp->if_ierrors++;\n\t\t\t}\n\t\t\tcur_rx = (total_len - wrap + ETHER_CRC_LEN);\n\t\t} else {\n\t\t\tm = m_devget(rxbufpos - RL_ETHER_ALIGN,\n\t\t\t    total_len + RL_ETHER_ALIGN, 0, ifp, NULL);\n\t\t\tif (m == NULL)\n\t\t\t\tifp->if_ierrors++;\n\t\t\telse\n\t\t\t\tm_adj(m, RL_ETHER_ALIGN);\n\t\t\tcur_rx += total_len + 4 + ETHER_CRC_LEN;\n\t\t}\n\n\t\t/*\n\t\t * Round up to 32-bit boundary.\n\t\t */\n\t\tcur_rx = (cur_rx + 3) & ~3;\n\t\tCSR_WRITE_2(sc, RL_CURRXADDR, cur_rx - 16);\n\n\t\tif (m == NULL)\n\t\t\tcontinue;\n\n\t\teh = mtod(m, struct ether_header *);\n\t\tifp->if_ipackets++;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Handle BPF listeners. Let the BPF user see the packet.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "rl_list_tx_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "594-611",
    "snippet": "int rl_list_tx_init(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tstruct rl_chain_data\t*cd;\n\tint\t\t\ti;\n\n\tcd = &sc->rl_cdata;\n\tfor (i = 0; i < RL_TX_LIST_CNT; i++) {\n\t\tcd->rl_tx_chain[i] = NULL;\n\t\tCSR_WRITE_4(sc,\n\t\t    RL_TXADDR0 + (i * sizeof(u_int32_t)), 0x0000000);\n\t}\n\n\tsc->rl_cdata.cur_tx = 0;\n\tsc->rl_cdata.last_tx = 0;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int rl_list_tx_init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_TXADDR0 + (i * sizeof(u_int32_t))",
            "0x0000000"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint rl_list_tx_init;\n\nint rl_list_tx_init(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tstruct rl_chain_data\t*cd;\n\tint\t\t\ti;\n\n\tcd = &sc->rl_cdata;\n\tfor (i = 0; i < RL_TX_LIST_CNT; i++) {\n\t\tcd->rl_tx_chain[i] = NULL;\n\t\tCSR_WRITE_4(sc,\n\t\t    RL_TXADDR0 + (i * sizeof(u_int32_t)), 0x0000000);\n\t}\n\n\tsc->rl_cdata.cur_tx = 0;\n\tsc->rl_cdata.last_tx = 0;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "rl_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "573-589",
    "snippet": "void rl_reset(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_RESET);\n\n\tfor (i = 0; i < RL_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_1(sc, RL_COMMAND) & RL_CMD_RESET))\n\t\t\tbreak;\n\t}\n\tif (i == RL_TIMEOUT)\n\t\tprintf(\"%s: reset never completed!\\n\", sc->sc_dev.dv_xname);\n\n        return;\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rl_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: reset never completed!\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "RL_COMMAND"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "RL_COMMAND",
            "RL_CMD_RESET"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_reset;\n\nvoid rl_reset(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tCSR_WRITE_1(sc, RL_COMMAND, RL_CMD_RESET);\n\n\tfor (i = 0; i < RL_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_1(sc, RL_COMMAND) & RL_CMD_RESET))\n\t\t\tbreak;\n\t}\n\tif (i == RL_TIMEOUT)\n\t\tprintf(\"%s: reset never completed!\\n\", sc->sc_dev.dv_xname);\n\n        return;\n}"
  },
  {
    "function_name": "rl_setmulti",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "520-571",
    "snippet": "void rl_setmulti(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tu_int32_t\t\trxfilt;\n\tint\t\t\tmcnt = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\trxfilt = CSR_READ_4(sc, RL_RXCFG);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= RL_RXCFG_RX_MULTI;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxfilt);\n\t\tCSR_WRITE_4(sc, RL_MAR0, 0xFFFFFFFF);\n\t\tCSR_WRITE_4(sc, RL_MAR4, 0xFFFFFFFF);\n\t\treturn;\n\t}\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, RL_MAR0, 0);\n\tCSR_WRITE_4(sc, RL_MAR4, 0);\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tmcnt++;\n\t\th = rl_calchash(enm->enm_addrlo);\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t\tmcnt++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (mcnt)\n\t\trxfilt |= RL_RXCFG_RX_MULTI;\n\telse\n\t\trxfilt &= ~RL_RXCFG_RX_MULTI;\n\n\tCSR_WRITE_4(sc, RL_RXCFG, rxfilt);\n\tCSR_WRITE_4(sc, RL_MAR0, hashes[0]);\n\tCSR_WRITE_4(sc, RL_MAR4, hashes[1]);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int8_t rl_calchash",
      "void rl_setmulti"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_MAR4",
            "hashes[1]"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_MAR0",
            "hashes[0]"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_RXCFG",
            "rxfilt"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl_calchash",
          "args": [
            "enm->enm_addrlo"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "rl_calchash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "492-515",
          "snippet": "u_int8_t rl_calchash(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn(crc >> 26);\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t rl_calchash"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t rl_calchash;\n\nu_int8_t rl_calchash(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn(crc >> 26);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "ac",
            "enm"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_MAR4",
            "0"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_MAR0",
            "0"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_MAR4",
            "0xFFFFFFFF"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_MAR0",
            "0xFFFFFFFF"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RL_RXCFG",
            "rxfilt"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "RL_RXCFG"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t rl_calchash;\nvoid rl_setmulti;\n\nvoid rl_setmulti(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tu_int32_t\t\trxfilt;\n\tint\t\t\tmcnt = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\trxfilt = CSR_READ_4(sc, RL_RXCFG);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= RL_RXCFG_RX_MULTI;\n\t\tCSR_WRITE_4(sc, RL_RXCFG, rxfilt);\n\t\tCSR_WRITE_4(sc, RL_MAR0, 0xFFFFFFFF);\n\t\tCSR_WRITE_4(sc, RL_MAR4, 0xFFFFFFFF);\n\t\treturn;\n\t}\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, RL_MAR0, 0);\n\tCSR_WRITE_4(sc, RL_MAR4, 0);\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tmcnt++;\n\t\th = rl_calchash(enm->enm_addrlo);\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t\tmcnt++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (mcnt)\n\t\trxfilt |= RL_RXCFG_RX_MULTI;\n\telse\n\t\trxfilt &= ~RL_RXCFG_RX_MULTI;\n\n\tCSR_WRITE_4(sc, RL_RXCFG, rxfilt);\n\tCSR_WRITE_4(sc, RL_MAR0, hashes[0]);\n\tCSR_WRITE_4(sc, RL_MAR4, hashes[1]);\n\n\treturn;\n}"
  },
  {
    "function_name": "rl_calchash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "492-515",
    "snippet": "u_int8_t rl_calchash(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn(crc >> 26);\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int8_t rl_calchash"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t rl_calchash;\n\nu_int8_t rl_calchash(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn(crc >> 26);\n}"
  },
  {
    "function_name": "rl_mii_writereg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "443-487",
    "snippet": "int rl_mii_writereg(sc, frame)\n\tstruct rl_softc\t\t*sc;\n\tstruct rl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ts;\n\n\ts = splimp();\n\t/*\n\t * Set up frame for TX.\n\t */\n\n\tframe->mii_stdelim = RL_MII_STARTDELIM;\n\tframe->mii_opcode = RL_MII_WRITEOP;\n\tframe->mii_turnaround = RL_MII_TURNAROUND;\n\t\n\t/*\n \t * Turn on data output.\n\t */\n\tMII_SET(RL_MII_DIR);\n\n\trl_mii_sync(sc);\n\n\trl_mii_send(sc, frame->mii_stdelim, 2);\n\trl_mii_send(sc, frame->mii_opcode, 2);\n\trl_mii_send(sc, frame->mii_phyaddr, 5);\n\trl_mii_send(sc, frame->mii_regaddr, 5);\n\trl_mii_send(sc, frame->mii_turnaround, 2);\n\trl_mii_send(sc, frame->mii_data, 16);\n\n\t/* Idle bit. */\n\tMII_SET(RL_MII_CLK);\n\tDELAY(1);\n\tMII_CLR(RL_MII_CLK);\n\tDELAY(1);\n\n\t/*\n\t * Turn off xmit.\n\t */\n\tMII_CLR(RL_MII_DIR);\n\n\tsplx(s);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rl_mii_sync",
      "void rl_mii_send",
      "int rl_mii_writereg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "RL_MII_DIR"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "RL_MII_CLK"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "RL_MII_CLK"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl_mii_send",
          "args": [
            "sc",
            "frame->mii_data",
            "16"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "rl_mii_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "325-345",
          "snippet": "void rl_mii_send(sc, bits, cnt)\n\tstruct rl_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tMII_CLR(RL_MII_CLK);\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n                if (bits & i) {\n\t\t\tMII_SET(RL_MII_DATAOUT);\n                } else {\n\t\t\tMII_CLR(RL_MII_DATAOUT);\n                }\n\t\tDELAY(1);\n\t\tMII_CLR(RL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_SET(RL_MII_CLK);\n\t}\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_mii_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_mii_send;\n\nvoid rl_mii_send(sc, bits, cnt)\n\tstruct rl_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tMII_CLR(RL_MII_CLK);\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n                if (bits & i) {\n\t\t\tMII_SET(RL_MII_DATAOUT);\n                } else {\n\t\t\tMII_CLR(RL_MII_DATAOUT);\n                }\n\t\tDELAY(1);\n\t\tMII_CLR(RL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_SET(RL_MII_CLK);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rl_mii_sync",
          "args": [
            "sc"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "rl_mii_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "305-320",
          "snippet": "void rl_mii_sync(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tMII_SET(RL_MII_DIR|RL_MII_DATAOUT);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tMII_SET(RL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_CLR(RL_MII_CLK);\n\t\tDELAY(1);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_mii_sync"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_mii_sync;\n\nvoid rl_mii_sync(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tMII_SET(RL_MII_DIR|RL_MII_DATAOUT);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tMII_SET(RL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_CLR(RL_MII_CLK);\n\t\tDELAY(1);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "RL_MII_DIR"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_mii_sync;\nvoid rl_mii_send;\nint rl_mii_writereg;\n\nint rl_mii_writereg(sc, frame)\n\tstruct rl_softc\t\t*sc;\n\tstruct rl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ts;\n\n\ts = splimp();\n\t/*\n\t * Set up frame for TX.\n\t */\n\n\tframe->mii_stdelim = RL_MII_STARTDELIM;\n\tframe->mii_opcode = RL_MII_WRITEOP;\n\tframe->mii_turnaround = RL_MII_TURNAROUND;\n\t\n\t/*\n \t * Turn on data output.\n\t */\n\tMII_SET(RL_MII_DIR);\n\n\trl_mii_sync(sc);\n\n\trl_mii_send(sc, frame->mii_stdelim, 2);\n\trl_mii_send(sc, frame->mii_opcode, 2);\n\trl_mii_send(sc, frame->mii_phyaddr, 5);\n\trl_mii_send(sc, frame->mii_regaddr, 5);\n\trl_mii_send(sc, frame->mii_turnaround, 2);\n\trl_mii_send(sc, frame->mii_data, 16);\n\n\t/* Idle bit. */\n\tMII_SET(RL_MII_CLK);\n\tDELAY(1);\n\tMII_CLR(RL_MII_CLK);\n\tDELAY(1);\n\n\t/*\n\t * Turn off xmit.\n\t */\n\tMII_CLR(RL_MII_DIR);\n\n\tsplx(s);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "rl_mii_readreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "350-438",
    "snippet": "int rl_mii_readreg(sc, frame)\n\tstruct rl_softc\t\t*sc;\n\tstruct rl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ti, ack, s;\n\n\ts = splimp();\n\n\t/*\n\t * Set up frame for RX.\n\t */\n\tframe->mii_stdelim = RL_MII_STARTDELIM;\n\tframe->mii_opcode = RL_MII_READOP;\n\tframe->mii_turnaround = 0;\n\tframe->mii_data = 0;\n\t\n\tCSR_WRITE_2(sc, RL_MII, 0);\n\n\t/*\n \t * Turn on data xmit.\n\t */\n\tMII_SET(RL_MII_DIR);\n\n\trl_mii_sync(sc);\n\n\t/*\n\t * Send command/address info.\n\t */\n\trl_mii_send(sc, frame->mii_stdelim, 2);\n\trl_mii_send(sc, frame->mii_opcode, 2);\n\trl_mii_send(sc, frame->mii_phyaddr, 5);\n\trl_mii_send(sc, frame->mii_regaddr, 5);\n\n\t/* Idle bit */\n\tMII_CLR((RL_MII_CLK|RL_MII_DATAOUT));\n\tDELAY(1);\n\tMII_SET(RL_MII_CLK);\n\tDELAY(1);\n\n\t/* Turn off xmit. */\n\tMII_CLR(RL_MII_DIR);\n\n\t/* Check for ack */\n\tMII_CLR(RL_MII_CLK);\n\tDELAY(1);\n\tMII_SET(RL_MII_CLK);\n\tDELAY(1);\n\tack = CSR_READ_2(sc, RL_MII) & RL_MII_DATAIN;\n\n\t/*\n\t * Now try reading data bits. If the ack failed, we still\n\t * need to clock through 16 cycles to keep the PHY(s) in sync.\n\t */\n\tif (ack) {\n\t\tfor(i = 0; i < 16; i++) {\n\t\t\tMII_CLR(RL_MII_CLK);\n\t\t\tDELAY(1);\n\t\t\tMII_SET(RL_MII_CLK);\n\t\t\tDELAY(1);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tMII_CLR(RL_MII_CLK);\n\t\tDELAY(1);\n\t\tif (!ack) {\n\t\t\tif (CSR_READ_2(sc, RL_MII) & RL_MII_DATAIN)\n\t\t\t\tframe->mii_data |= i;\n\t\t\tDELAY(1);\n\t\t}\n\t\tMII_SET(RL_MII_CLK);\n\t\tDELAY(1);\n\t}\n\nfail:\n\n\tMII_CLR(RL_MII_CLK);\n\tDELAY(1);\n\tMII_SET(RL_MII_CLK);\n\tDELAY(1);\n\n\tsplx(s);\n\n\tif (ack)\n\t\treturn(1);\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rl_mii_sync",
      "void rl_mii_send",
      "int rl_mii_readreg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "RL_MII_CLK"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "RL_MII_CLK"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "RL_MII_CLK"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "RL_MII"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "RL_MII_CLK"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "RL_MII_CLK"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "RL_MII_CLK"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "RL_MII"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "RL_MII_CLK"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "RL_MII_CLK"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "RL_MII_DIR"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "RL_MII_CLK"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "(RL_MII_CLK|RL_MII_DATAOUT)"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl_mii_send",
          "args": [
            "sc",
            "frame->mii_regaddr",
            "5"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "rl_mii_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "325-345",
          "snippet": "void rl_mii_send(sc, bits, cnt)\n\tstruct rl_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tMII_CLR(RL_MII_CLK);\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n                if (bits & i) {\n\t\t\tMII_SET(RL_MII_DATAOUT);\n                } else {\n\t\t\tMII_CLR(RL_MII_DATAOUT);\n                }\n\t\tDELAY(1);\n\t\tMII_CLR(RL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_SET(RL_MII_CLK);\n\t}\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_mii_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_mii_send;\n\nvoid rl_mii_send(sc, bits, cnt)\n\tstruct rl_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tMII_CLR(RL_MII_CLK);\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n                if (bits & i) {\n\t\t\tMII_SET(RL_MII_DATAOUT);\n                } else {\n\t\t\tMII_CLR(RL_MII_DATAOUT);\n                }\n\t\tDELAY(1);\n\t\tMII_CLR(RL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_SET(RL_MII_CLK);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rl_mii_sync",
          "args": [
            "sc"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "rl_mii_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "305-320",
          "snippet": "void rl_mii_sync(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tMII_SET(RL_MII_DIR|RL_MII_DATAOUT);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tMII_SET(RL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_CLR(RL_MII_CLK);\n\t\tDELAY(1);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_mii_sync"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_mii_sync;\n\nvoid rl_mii_sync(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tMII_SET(RL_MII_DIR|RL_MII_DATAOUT);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tMII_SET(RL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_CLR(RL_MII_CLK);\n\t\tDELAY(1);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "RL_MII_DIR"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "RL_MII",
            "0"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_mii_sync;\nvoid rl_mii_send;\nint rl_mii_readreg;\n\nint rl_mii_readreg(sc, frame)\n\tstruct rl_softc\t\t*sc;\n\tstruct rl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ti, ack, s;\n\n\ts = splimp();\n\n\t/*\n\t * Set up frame for RX.\n\t */\n\tframe->mii_stdelim = RL_MII_STARTDELIM;\n\tframe->mii_opcode = RL_MII_READOP;\n\tframe->mii_turnaround = 0;\n\tframe->mii_data = 0;\n\t\n\tCSR_WRITE_2(sc, RL_MII, 0);\n\n\t/*\n \t * Turn on data xmit.\n\t */\n\tMII_SET(RL_MII_DIR);\n\n\trl_mii_sync(sc);\n\n\t/*\n\t * Send command/address info.\n\t */\n\trl_mii_send(sc, frame->mii_stdelim, 2);\n\trl_mii_send(sc, frame->mii_opcode, 2);\n\trl_mii_send(sc, frame->mii_phyaddr, 5);\n\trl_mii_send(sc, frame->mii_regaddr, 5);\n\n\t/* Idle bit */\n\tMII_CLR((RL_MII_CLK|RL_MII_DATAOUT));\n\tDELAY(1);\n\tMII_SET(RL_MII_CLK);\n\tDELAY(1);\n\n\t/* Turn off xmit. */\n\tMII_CLR(RL_MII_DIR);\n\n\t/* Check for ack */\n\tMII_CLR(RL_MII_CLK);\n\tDELAY(1);\n\tMII_SET(RL_MII_CLK);\n\tDELAY(1);\n\tack = CSR_READ_2(sc, RL_MII) & RL_MII_DATAIN;\n\n\t/*\n\t * Now try reading data bits. If the ack failed, we still\n\t * need to clock through 16 cycles to keep the PHY(s) in sync.\n\t */\n\tif (ack) {\n\t\tfor(i = 0; i < 16; i++) {\n\t\t\tMII_CLR(RL_MII_CLK);\n\t\t\tDELAY(1);\n\t\t\tMII_SET(RL_MII_CLK);\n\t\t\tDELAY(1);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tMII_CLR(RL_MII_CLK);\n\t\tDELAY(1);\n\t\tif (!ack) {\n\t\t\tif (CSR_READ_2(sc, RL_MII) & RL_MII_DATAIN)\n\t\t\t\tframe->mii_data |= i;\n\t\t\tDELAY(1);\n\t\t}\n\t\tMII_SET(RL_MII_CLK);\n\t\tDELAY(1);\n\t}\n\nfail:\n\n\tMII_CLR(RL_MII_CLK);\n\tDELAY(1);\n\tMII_SET(RL_MII_CLK);\n\tDELAY(1);\n\n\tsplx(s);\n\n\tif (ack)\n\t\treturn(1);\n\treturn(0);\n}"
  },
  {
    "function_name": "rl_mii_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "325-345",
    "snippet": "void rl_mii_send(sc, bits, cnt)\n\tstruct rl_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tMII_CLR(RL_MII_CLK);\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n                if (bits & i) {\n\t\t\tMII_SET(RL_MII_DATAOUT);\n                } else {\n\t\t\tMII_CLR(RL_MII_DATAOUT);\n                }\n\t\tDELAY(1);\n\t\tMII_CLR(RL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_SET(RL_MII_CLK);\n\t}\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rl_mii_send"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "RL_MII_CLK"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "RL_MII_CLK"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "RL_MII_DATAOUT"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "RL_MII_DATAOUT"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "RL_MII_CLK"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_mii_send;\n\nvoid rl_mii_send(sc, bits, cnt)\n\tstruct rl_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tMII_CLR(RL_MII_CLK);\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n                if (bits & i) {\n\t\t\tMII_SET(RL_MII_DATAOUT);\n                } else {\n\t\t\tMII_CLR(RL_MII_DATAOUT);\n                }\n\t\tDELAY(1);\n\t\tMII_CLR(RL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_SET(RL_MII_CLK);\n\t}\n}"
  },
  {
    "function_name": "rl_mii_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "305-320",
    "snippet": "void rl_mii_sync(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tMII_SET(RL_MII_DIR|RL_MII_DATAOUT);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tMII_SET(RL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_CLR(RL_MII_CLK);\n\t\tDELAY(1);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rl_mii_sync"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "RL_MII_CLK"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "RL_MII_CLK"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "RL_MII_DIR|RL_MII_DATAOUT"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_mii_sync;\n\nvoid rl_mii_sync(sc)\n\tstruct rl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tMII_SET(RL_MII_DIR|RL_MII_DATAOUT);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tMII_SET(RL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_CLR(RL_MII_CLK);\n\t\tDELAY(1);\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "rl_read_eeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "265-285",
    "snippet": "void rl_read_eeprom(sc, dest, off, cnt, swap)\n\tstruct rl_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n\tint\t\t\tswap;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\tword = 0, *ptr;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\trl_eeprom_getword(sc, off + i, &word);\n\t\tptr = (u_int16_t *)(dest + (i * 2));\n\t\tif (swap)\n\t\t\t*ptr = ntohs(word);\n\t\telse\n\t\t\t*ptr = word;\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rl_eeprom_getword",
      "void rl_read_eeprom"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "word"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl_eeprom_getword",
          "args": [
            "sc",
            "off + i",
            "&word"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "rl_eeprom_getword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "224-260",
          "snippet": "void rl_eeprom_getword(sc, addr, dest)\n\tstruct rl_softc\t\t*sc;\n\tint\t\t\taddr;\n\tu_int16_t\t\t*dest;\n{\n\tregister int\t\ti;\n\tu_int16_t\t\tword = 0;\n\n\t/* Enter EEPROM access mode. */\n\tCSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_PROGRAM|RL_EE_SEL);\n\n\t/*\n\t * Send address of word we want to read.\n\t */\n\trl_eeprom_putbyte(sc, addr);\n\n\tCSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_PROGRAM|RL_EE_SEL);\n\n\t/*\n\t * Start reading bits from EEPROM.\n\t */\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tEE_SET(RL_EE_CLK);\n\t\tDELAY(100);\n\t\tif (CSR_READ_1(sc, RL_EECMD) & RL_EE_DATAOUT)\n\t\t\tword |= i;\n\t\tEE_CLR(RL_EE_CLK);\n\t\tDELAY(100);\n\t}\n\n\t/* Turn off EEPROM access mode. */\n\tCSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_OFF);\n\n\t*dest = word;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_eeprom_putbyte",
            "void rl_eeprom_getword"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_eeprom_putbyte;\nvoid rl_eeprom_getword;\n\nvoid rl_eeprom_getword(sc, addr, dest)\n\tstruct rl_softc\t\t*sc;\n\tint\t\t\taddr;\n\tu_int16_t\t\t*dest;\n{\n\tregister int\t\ti;\n\tu_int16_t\t\tword = 0;\n\n\t/* Enter EEPROM access mode. */\n\tCSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_PROGRAM|RL_EE_SEL);\n\n\t/*\n\t * Send address of word we want to read.\n\t */\n\trl_eeprom_putbyte(sc, addr);\n\n\tCSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_PROGRAM|RL_EE_SEL);\n\n\t/*\n\t * Start reading bits from EEPROM.\n\t */\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tEE_SET(RL_EE_CLK);\n\t\tDELAY(100);\n\t\tif (CSR_READ_1(sc, RL_EECMD) & RL_EE_DATAOUT)\n\t\t\tword |= i;\n\t\tEE_CLR(RL_EE_CLK);\n\t\tDELAY(100);\n\t}\n\n\t/* Turn off EEPROM access mode. */\n\tCSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_OFF);\n\n\t*dest = word;\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_eeprom_getword;\nvoid rl_read_eeprom;\n\nvoid rl_read_eeprom(sc, dest, off, cnt, swap)\n\tstruct rl_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n\tint\t\t\tswap;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\tword = 0, *ptr;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\trl_eeprom_getword(sc, off + i, &word);\n\t\tptr = (u_int16_t *)(dest + (i * 2));\n\t\tif (swap)\n\t\t\t*ptr = ntohs(word);\n\t\telse\n\t\t\t*ptr = word;\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "rl_eeprom_getword",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "224-260",
    "snippet": "void rl_eeprom_getword(sc, addr, dest)\n\tstruct rl_softc\t\t*sc;\n\tint\t\t\taddr;\n\tu_int16_t\t\t*dest;\n{\n\tregister int\t\ti;\n\tu_int16_t\t\tword = 0;\n\n\t/* Enter EEPROM access mode. */\n\tCSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_PROGRAM|RL_EE_SEL);\n\n\t/*\n\t * Send address of word we want to read.\n\t */\n\trl_eeprom_putbyte(sc, addr);\n\n\tCSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_PROGRAM|RL_EE_SEL);\n\n\t/*\n\t * Start reading bits from EEPROM.\n\t */\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tEE_SET(RL_EE_CLK);\n\t\tDELAY(100);\n\t\tif (CSR_READ_1(sc, RL_EECMD) & RL_EE_DATAOUT)\n\t\t\tword |= i;\n\t\tEE_CLR(RL_EE_CLK);\n\t\tDELAY(100);\n\t}\n\n\t/* Turn off EEPROM access mode. */\n\tCSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_OFF);\n\n\t*dest = word;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rl_eeprom_putbyte",
      "void rl_eeprom_getword"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "RL_EECMD",
            "RL_EEMODE_OFF"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EE_CLR",
          "args": [
            "RL_EE_CLK"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "RL_EECMD"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EE_SET",
          "args": [
            "RL_EE_CLK"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "RL_EECMD",
            "RL_EEMODE_PROGRAM|RL_EE_SEL"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl_eeprom_putbyte",
          "args": [
            "sc",
            "addr"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "rl_eeprom_putbyte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
          "lines": "194-219",
          "snippet": "void rl_eeprom_putbyte(sc, addr)\n\tstruct rl_softc\t\t*sc;\n\tint\t\t\taddr;\n{\n\tregister int\t\td, i;\n\n\td = addr | RL_EECMD_READ;\n\n\t/*\n\t * Feed in each bit and strobe the clock.\n\t */\n\tfor (i = 0x400; i; i >>= 1) {\n\t\tif (d & i) {\n\t\t\tEE_SET(RL_EE_DATAIN);\n\t\t} else {\n\t\t\tEE_CLR(RL_EE_DATAIN);\n\t\t}\n\t\tDELAY(100);\n\t\tEE_SET(RL_EE_CLK);\n\t\tDELAY(150);\n\t\tEE_CLR(RL_EE_CLK);\n\t\tDELAY(100);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_rlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rl_eeprom_putbyte"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_eeprom_putbyte;\n\nvoid rl_eeprom_putbyte(sc, addr)\n\tstruct rl_softc\t\t*sc;\n\tint\t\t\taddr;\n{\n\tregister int\t\td, i;\n\n\td = addr | RL_EECMD_READ;\n\n\t/*\n\t * Feed in each bit and strobe the clock.\n\t */\n\tfor (i = 0x400; i; i >>= 1) {\n\t\tif (d & i) {\n\t\t\tEE_SET(RL_EE_DATAIN);\n\t\t} else {\n\t\t\tEE_CLR(RL_EE_DATAIN);\n\t\t}\n\t\tDELAY(100);\n\t\tEE_SET(RL_EE_CLK);\n\t\tDELAY(150);\n\t\tEE_CLR(RL_EE_CLK);\n\t\tDELAY(100);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "RL_EECMD",
            "RL_EEMODE_PROGRAM|RL_EE_SEL"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_eeprom_putbyte;\nvoid rl_eeprom_getword;\n\nvoid rl_eeprom_getword(sc, addr, dest)\n\tstruct rl_softc\t\t*sc;\n\tint\t\t\taddr;\n\tu_int16_t\t\t*dest;\n{\n\tregister int\t\ti;\n\tu_int16_t\t\tword = 0;\n\n\t/* Enter EEPROM access mode. */\n\tCSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_PROGRAM|RL_EE_SEL);\n\n\t/*\n\t * Send address of word we want to read.\n\t */\n\trl_eeprom_putbyte(sc, addr);\n\n\tCSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_PROGRAM|RL_EE_SEL);\n\n\t/*\n\t * Start reading bits from EEPROM.\n\t */\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tEE_SET(RL_EE_CLK);\n\t\tDELAY(100);\n\t\tif (CSR_READ_1(sc, RL_EECMD) & RL_EE_DATAOUT)\n\t\t\tword |= i;\n\t\tEE_CLR(RL_EE_CLK);\n\t\tDELAY(100);\n\t}\n\n\t/* Turn off EEPROM access mode. */\n\tCSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_OFF);\n\n\t*dest = word;\n\n\treturn;\n}"
  },
  {
    "function_name": "rl_eeprom_putbyte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_rl.c",
    "lines": "194-219",
    "snippet": "void rl_eeprom_putbyte(sc, addr)\n\tstruct rl_softc\t\t*sc;\n\tint\t\t\taddr;\n{\n\tregister int\t\td, i;\n\n\td = addr | RL_EECMD_READ;\n\n\t/*\n\t * Feed in each bit and strobe the clock.\n\t */\n\tfor (i = 0x400; i; i >>= 1) {\n\t\tif (d & i) {\n\t\t\tEE_SET(RL_EE_DATAIN);\n\t\t} else {\n\t\t\tEE_CLR(RL_EE_DATAIN);\n\t\t}\n\t\tDELAY(100);\n\t\tEE_SET(RL_EE_CLK);\n\t\tDELAY(150);\n\t\tEE_CLR(RL_EE_CLK);\n\t\tDELAY(100);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_rlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rl_eeprom_putbyte"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EE_CLR",
          "args": [
            "RL_EE_CLK"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "150"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EE_SET",
          "args": [
            "RL_EE_CLK"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EE_CLR",
          "args": [
            "RL_EE_DATAIN"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EE_SET",
          "args": [
            "RL_EE_DATAIN"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_rlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid rl_eeprom_putbyte;\n\nvoid rl_eeprom_putbyte(sc, addr)\n\tstruct rl_softc\t\t*sc;\n\tint\t\t\taddr;\n{\n\tregister int\t\td, i;\n\n\td = addr | RL_EECMD_READ;\n\n\t/*\n\t * Feed in each bit and strobe the clock.\n\t */\n\tfor (i = 0x400; i; i >>= 1) {\n\t\tif (d & i) {\n\t\t\tEE_SET(RL_EE_DATAIN);\n\t\t} else {\n\t\t\tEE_CLR(RL_EE_DATAIN);\n\t\t}\n\t\tDELAY(100);\n\t\tEE_SET(RL_EE_CLK);\n\t\tDELAY(150);\n\t\tEE_CLR(RL_EE_CLK);\n\t\tDELAY(100);\n\t}\n\n\treturn;\n}"
  }
]