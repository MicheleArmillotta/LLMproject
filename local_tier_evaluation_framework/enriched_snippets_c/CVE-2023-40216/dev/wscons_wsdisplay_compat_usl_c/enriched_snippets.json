[
  {
    "function_name": "wsdisplay_usl_ioctl2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
    "lines": "363-548",
    "snippet": "int\nwsdisplay_usl_ioctl2(sc, scr, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint res;\n\tstruct usl_syncdata *sd;\n\tint req, intarg;\n\tstruct wskbd_bell_data bd;\n\tvoid *arg;\n\n\tswitch (cmd) {\n\t    case VT_SETMODE:\n#define newmode ((struct vt_mode *)data)\n\t\tif (newmode->mode == VT_PROCESS) {\n\t\t\tres = usl_sync_init(scr, &sd, p, newmode->acqsig,\n\t\t\t\t\t    newmode->relsig, newmode->frsig);\n\t\t\tif (res)\n\t\t\t\treturn (res);\n\t\t} else {\n\t\t\tsd = usl_sync_get(scr);\n\t\t\tif (sd)\n\t\t\t\tusl_sync_done(sd);\n\t\t}\n#undef newmode\n\t\treturn (0);\n\t    case VT_GETMODE:\n#define cmode ((struct vt_mode *)data)\n\t\tsd = usl_sync_get(scr);\n\t\tif (sd) {\n\t\t\tcmode->mode = VT_PROCESS;\n\t\t\tcmode->relsig = sd->s_relsig;\n\t\t\tcmode->acqsig = sd->s_acqsig;\n\t\t\tcmode->frsig = sd->s_frsig;\n\t\t} else\n\t\t\tcmode->mode = VT_AUTO;\n#undef cmode\n\t\treturn (0);\n\t    case VT_RELDISP:\n#define d (*(int *)data)\n\t\tsd = usl_sync_get(scr);\n\t\tif (!sd)\n\t\t\treturn (EINVAL);\n\t\tswitch (d) {\n\t\t    case VT_FALSE:\n\t\t    case VT_TRUE:\n\t\t\treturn (usl_detachack(sd, (d == VT_TRUE)));\n\t\t    case VT_ACKACQ:\n\t\t\treturn (usl_attachack(sd, 1));\n\t\t    default:\n\t\t\treturn (EINVAL);\n\t\t}\n#undef d\n\t\treturn (0);\n\n\t    case KDENABIO:\n\t\tif (suser(p->p_ucred, &p->p_acflag) || securelevel > 1)\n\t\t\treturn (EPERM);\n\t\t/* FALLTHRU */\n\t    case KDDISABIO:\n#if defined(__i386__)\n#if defined(COMPAT_10) || defined(COMPAT_11) || defined(COMPAT_FREEBSD)\n\t\t{\n\t\tstruct trapframe *fp = (struct trapframe *)p->p_md.md_regs;\n\t\tif (cmd == KDENABIO)\n\t\t\tfp->tf_eflags |= PSL_IOPL;\n\t\telse\n\t\t\tfp->tf_eflags &= ~PSL_IOPL;\n\t\t}\n#endif\n#endif\n\t\treturn (0);\n\t    case KDSETRAD:\n\t\t/* XXX ignore for now */\n\t\treturn (0);\n\n\t    default:\n\t\treturn (-1);\n\n\t    /*\n\t     * the following are converted to wsdisplay ioctls\n\t     */\n\t    case KDSETMODE:\n\t\treq = WSDISPLAYIO_SMODE;\n#define d (*(int *)data)\n\t\tswitch (d) {\n\t\t    case KD_GRAPHICS:\n\t\t\tintarg = WSDISPLAYIO_MODE_MAPPED;\n\t\t\tbreak;\n\t\t    case KD_TEXT:\n\t\t\tintarg = WSDISPLAYIO_MODE_EMUL;\n\t\t\tbreak;\n\t\t    default:\n\t\t\treturn (EINVAL);\n\t\t}\n#undef d\n\t\targ = &intarg;\n\t\tbreak;\n\t    case KDMKTONE:\n\t\treq = WSKBDIO_COMPLEXBELL;\n#define d (*(int *)data)\n\t\tif (d) {\n#define PCVT_SYSBEEPF\t1193182\n\t\t\tif (d >> 16) {\n\t\t\t\tbd.which = WSKBD_BELL_DOPERIOD;\n\t\t\tbd.period = d >> 16; /* ms */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbd.which = 0;\n\t\t\tif (d & 0xffff) {\n\t\t\t\tbd.which |= WSKBD_BELL_DOPITCH;\n\t\t\t\tbd.pitch = PCVT_SYSBEEPF/(d & 0xffff); /* Hz */\n\t\t\t}\n\t\t} else\n\t\t\tbd.which = 0; /* default */\n#undef d\n\t\targ = &bd;\n\t\tbreak;\n\t    case KDSETLED:\n\t\treq = WSKBDIO_SETLEDS;\n\t\tintarg = 0;\n#define d (*(int *)data)\n\t\tif (d & LED_CAP)\n\t\t\tintarg |= WSKBD_LED_CAPS;\n\t\tif (d & LED_NUM)\n\t\t\tintarg |= WSKBD_LED_NUM;\n\t\tif (d & LED_SCR)\n\t\t\tintarg |= WSKBD_LED_SCROLL;\n#undef d\n\t\targ = &intarg;\n\t\tbreak;\n\t    case KDGETLED:\n\t\treq = WSKBDIO_GETLEDS;\n\t\targ = &intarg;\n\t\tbreak;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t    case KDSKBMODE:\n\t\treq = WSKBDIO_SETMODE;\n\t\tswitch (*(int *)data) {\n\t\t    case K_RAW:\n\t\t\tintarg = WSKBD_RAW;\n\t\t\tbreak;\n\t\t    case K_XLATE:\n\t\t\tintarg = WSKBD_TRANSLATED;\n\t\t\tbreak;\n\t\t    default:\n\t\t\treturn (EINVAL);\n\t\t}\n\t\targ = &intarg;\n\t\tbreak;\n\t    case KDGKBMODE:\n\t\treq = WSKBDIO_GETMODE;\n\t\targ = &intarg;\n\t\tbreak;\n#endif\n\t}\n\n\tres = wsdisplay_internal_ioctl(sc, scr, req, arg, flag, p);\n\tif (res)\n\t\treturn (res);\n\n\tswitch (cmd) {\n\t    case KDGETLED:\n#define d (*(int *)data)\n\t\td = 0;\n\t\tif (intarg & WSKBD_LED_CAPS)\n\t\t\td |= LED_CAP;\n\t\tif (intarg & WSKBD_LED_NUM)\n\t\t\td |= LED_NUM;\n\t\tif (intarg & WSKBD_LED_SCROLL)\n\t\t\td |= LED_SCR;\n#undef d\n\t\tbreak;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t    case KDGKBMODE:\n\t\t*(int *)data = (intarg == WSKBD_RAW ? K_RAW : K_XLATE);\n\t\tbreak;\n#endif\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsdisplay_usl_io.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/errno.h>",
      "#include <sys/malloc.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define d (*(int *)data)",
      "#define d (*(int *)data)",
      "#define PCVT_SYSBEEPF\t1193182",
      "#define d (*(int *)data)",
      "#define d (*(int *)data)",
      "#define d (*(int *)data)",
      "#define cmode ((struct vt_mode *)data)",
      "#define newmode ((struct vt_mode *)data)"
    ],
    "globals_used": [
      "static int usl_sync_init",
      "static void usl_sync_done",
      "static struct usl_syncdata *usl_sync_get",
      "static int usl_detachack",
      "static int usl_attachack",
      "static struct usl_syncdata *\nusl_sync_get(scr)\n\tstruct wsscreen *scr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsdisplay_internal_ioctl",
          "args": [
            "sc",
            "scr",
            "req",
            "arg",
            "flag",
            "p"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_internal_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "936-1012",
          "snippet": "int\nwsdisplay_internal_ioctl(sc, scr, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\tchar namebuf[16];\n\tstruct wsdisplay_font fd;\n\n#if NWSKBD > 0\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\tswitch (cmd) {\n\t\t    case WSKBDIO_SETMODE:\n\t\t\tscr->scr_rawkbd = (*(int *)data == WSKBD_RAW);\n\t\t\treturn (wsdisplay_update_rawkbd(sc, scr));\n\t\t    case WSKBDIO_GETMODE:\n\t\t\t*(int *)data = (scr->scr_rawkbd ?\n\t\t\t\t\tWSKBD_RAW : WSKBD_TRANSLATED);\n\t\t\treturn (0);\n\t\t}\n#endif\n\terror = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, cmd, data, flag, p);\n\t\tif (error >= 0)\n\t\treturn (error);\n#endif /* NWSKBD > 0 */\n\n\tswitch (cmd) {\n\tcase WSDISPLAYIO_GMODE:\n\t\t*(u_int *)data = (scr->scr_flags & SCR_GRAPHICS ?\n\t\t\t\t  WSDISPLAYIO_MODE_MAPPED :\n\t\t\t\t  WSDISPLAYIO_MODE_EMUL);\n\t\treturn (0);\n\n\tcase WSDISPLAYIO_SMODE:\n#define d (*(int *)data)\n\t\tif (d != WSDISPLAYIO_MODE_EMUL &&\n\t\t    d != WSDISPLAYIO_MODE_MAPPED)\n\t\t\treturn (EINVAL);\n\n\t    if (WSSCREEN_HAS_EMULATOR(scr)) {\n\t\t    scr->scr_flags &= ~SCR_GRAPHICS;\n\t\t    if (d == WSDISPLAYIO_MODE_MAPPED)\n\t\t\t    scr->scr_flags |= SCR_GRAPHICS;\n\t    } else if (d == WSDISPLAYIO_MODE_EMUL)\n\t\t    return (EINVAL);\n\t    return (0);\n#undef d\n\n\tcase WSDISPLAYIO_USEFONT:\n#define d ((struct wsdisplay_usefontdata *)data)\n\t\tif (!sc->sc_accessops->load_font)\n\t\t\treturn (EINVAL);\n\t\tif (d->name) {\n\t\t\terror = copyinstr(d->name, namebuf, sizeof(namebuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\tfd.name = namebuf;\n\t\t} else\n\t\t\tfd.name = 0;\n\t\tfd.data = 0;\n\t\terror = (*sc->sc_accessops->load_font)(sc->sc_accesscookie,\n\t\t\t\t\tscr->scr_dconf->emulcookie, &fd);\n\t\tif (!error && WSSCREEN_HAS_EMULATOR(scr))\n\t\t\t(*scr->scr_dconf->wsemul->reset)\n\t\t\t\t(scr->scr_dconf->wsemulcookie, WSEMUL_SYNCFONT);\n\t\treturn (error);\n#undef d\n\t}\n\n\t/* check ioctls for display */\n\treturn ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,\n\t    flag, p));\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define d ((struct wsmux_device *)data)",
            "#define d ((struct wsdisplay_kbddata *)data)",
            "#define d ((struct wsdisplay_font *)data)",
            "#define d ((struct wsdisplay_delscreendata *)data)",
            "#define d ((struct wsdisplay_addscreendata *)data)",
            "#define d ((struct wsdisplay_usefontdata *)data)",
            "#define d (*(int *)data)",
            "#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */"
          ],
          "globals_used": [
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
            "const char *name;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nconst char *name;\n\nint\nwsdisplay_internal_ioctl(sc, scr, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\tchar namebuf[16];\n\tstruct wsdisplay_font fd;\n\n#if NWSKBD > 0\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\tswitch (cmd) {\n\t\t    case WSKBDIO_SETMODE:\n\t\t\tscr->scr_rawkbd = (*(int *)data == WSKBD_RAW);\n\t\t\treturn (wsdisplay_update_rawkbd(sc, scr));\n\t\t    case WSKBDIO_GETMODE:\n\t\t\t*(int *)data = (scr->scr_rawkbd ?\n\t\t\t\t\tWSKBD_RAW : WSKBD_TRANSLATED);\n\t\t\treturn (0);\n\t\t}\n#endif\n\terror = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, cmd, data, flag, p);\n\t\tif (error >= 0)\n\t\treturn (error);\n#endif /* NWSKBD > 0 */\n\n\tswitch (cmd) {\n\tcase WSDISPLAYIO_GMODE:\n\t\t*(u_int *)data = (scr->scr_flags & SCR_GRAPHICS ?\n\t\t\t\t  WSDISPLAYIO_MODE_MAPPED :\n\t\t\t\t  WSDISPLAYIO_MODE_EMUL);\n\t\treturn (0);\n\n\tcase WSDISPLAYIO_SMODE:\n#define d (*(int *)data)\n\t\tif (d != WSDISPLAYIO_MODE_EMUL &&\n\t\t    d != WSDISPLAYIO_MODE_MAPPED)\n\t\t\treturn (EINVAL);\n\n\t    if (WSSCREEN_HAS_EMULATOR(scr)) {\n\t\t    scr->scr_flags &= ~SCR_GRAPHICS;\n\t\t    if (d == WSDISPLAYIO_MODE_MAPPED)\n\t\t\t    scr->scr_flags |= SCR_GRAPHICS;\n\t    } else if (d == WSDISPLAYIO_MODE_EMUL)\n\t\t    return (EINVAL);\n\t    return (0);\n#undef d\n\n\tcase WSDISPLAYIO_USEFONT:\n#define d ((struct wsdisplay_usefontdata *)data)\n\t\tif (!sc->sc_accessops->load_font)\n\t\t\treturn (EINVAL);\n\t\tif (d->name) {\n\t\t\terror = copyinstr(d->name, namebuf, sizeof(namebuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\tfd.name = namebuf;\n\t\t} else\n\t\t\tfd.name = 0;\n\t\tfd.data = 0;\n\t\terror = (*sc->sc_accessops->load_font)(sc->sc_accesscookie,\n\t\t\t\t\tscr->scr_dconf->emulcookie, &fd);\n\t\tif (!error && WSSCREEN_HAS_EMULATOR(scr))\n\t\t\t(*scr->scr_dconf->wsemul->reset)\n\t\t\t\t(scr->scr_dconf->wsemulcookie, WSEMUL_SYNCFONT);\n\t\treturn (error);\n#undef d\n\t}\n\n\t/* check ioctls for display */\n\treturn ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,\n\t    flag, p));\n}"
        }
      },
      {
        "call_info": {
          "callee": "suser",
          "args": [
            "p->p_ucred",
            "&p->p_acflag"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usl_attachack",
          "args": [
            "sd",
            "1"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "usl_attachack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
          "lines": "259-276",
          "snippet": "static int\nusl_attachack(sd, ack)\n\tstruct usl_syncdata *sd;\n\tint ack;\n{\n\tif (!(sd->s_flags & SF_ATTACHPENDING)) {\n\t\tprintf(\"usl_attachack: not attaching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\ttimeout_del(&sd->s_attach_ch);\n\tsd->s_flags &= ~SF_ATTACHPENDING;\n\n\tif (sd->s_callback)\n\t\t(*sd->s_callback)(sd->s_cbarg, (ack ? 0 : EIO), 1);\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsdisplay_usl_io.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/errno.h>",
            "#include <sys/malloc.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define SF_ATTACHPENDING 2"
          ],
          "globals_used": [
            "static int usl_attachack"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SF_ATTACHPENDING 2\n\nstatic int usl_attachack;\n\nstatic int\nusl_attachack(sd, ack)\n\tstruct usl_syncdata *sd;\n\tint ack;\n{\n\tif (!(sd->s_flags & SF_ATTACHPENDING)) {\n\t\tprintf(\"usl_attachack: not attaching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\ttimeout_del(&sd->s_attach_ch);\n\tsd->s_flags &= ~SF_ATTACHPENDING;\n\n\tif (sd->s_callback)\n\t\t(*sd->s_callback)(sd->s_cbarg, (ack ? 0 : EIO), 1);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usl_detachack",
          "args": [
            "sd",
            "(d == VT_TRUE)"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "usl_detachack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
          "lines": "194-211",
          "snippet": "static int\nusl_detachack(sd, ack)\n\tstruct usl_syncdata *sd;\n\tint ack;\n{\n\tif (!(sd->s_flags & SF_DETACHPENDING)) {\n\t\tprintf(\"usl_detachack: not detaching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\ttimeout_del(&sd->s_detach_ch);\n\tsd->s_flags &= ~SF_DETACHPENDING;\n\n\tif (sd->s_callback)\n\t\t(*sd->s_callback)(sd->s_cbarg, (ack ? 0 : EIO), 1);\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsdisplay_usl_io.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/errno.h>",
            "#include <sys/malloc.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define SF_DETACHPENDING 1"
          ],
          "globals_used": [
            "static int usl_detachack"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SF_DETACHPENDING 1\n\nstatic int usl_detachack;\n\nstatic int\nusl_detachack(sd, ack)\n\tstruct usl_syncdata *sd;\n\tint ack;\n{\n\tif (!(sd->s_flags & SF_DETACHPENDING)) {\n\t\tprintf(\"usl_detachack: not detaching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\ttimeout_del(&sd->s_detach_ch);\n\tsd->s_flags &= ~SF_DETACHPENDING;\n\n\tif (sd->s_callback)\n\t\t(*sd->s_callback)(sd->s_cbarg, (ack ? 0 : EIO), 1);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usl_sync_get",
          "args": [
            "scr"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usl_sync_get",
          "args": [
            "scr"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usl_sync_done",
          "args": [
            "sd"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "usl_sync_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
          "lines": "126-140",
          "snippet": "static void\nusl_sync_done(sd)\n\tstruct usl_syncdata *sd;\n{\n\tif (sd->s_flags & SF_DETACHPENDING) {\n\t\ttimeout_del(&sd->s_detach_ch);\n\t\t(*sd->s_callback)(sd->s_cbarg, 0, 0);\n\t}\n\tif (sd->s_flags & SF_ATTACHPENDING) {\n\t\ttimeout_del(&sd->s_attach_ch);\n\t\t(*sd->s_callback)(sd->s_cbarg, ENXIO, 0);\n\t}\n\twsscreen_detach_sync(sd->s_scr);\n\tfree(sd, M_DEVBUF);\n}",
          "includes": [
            "#include <dev/wscons/wsdisplay_usl_io.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/errno.h>",
            "#include <sys/malloc.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define SF_ATTACHPENDING 2",
            "#define SF_DETACHPENDING 1"
          ],
          "globals_used": [
            "static void usl_sync_done"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SF_ATTACHPENDING 2\n#define SF_DETACHPENDING 1\n\nstatic void usl_sync_done;\n\nstatic void\nusl_sync_done(sd)\n\tstruct usl_syncdata *sd;\n{\n\tif (sd->s_flags & SF_DETACHPENDING) {\n\t\ttimeout_del(&sd->s_detach_ch);\n\t\t(*sd->s_callback)(sd->s_cbarg, 0, 0);\n\t}\n\tif (sd->s_flags & SF_ATTACHPENDING) {\n\t\ttimeout_del(&sd->s_attach_ch);\n\t\t(*sd->s_callback)(sd->s_cbarg, ENXIO, 0);\n\t}\n\twsscreen_detach_sync(sd->s_scr);\n\tfree(sd, M_DEVBUF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usl_sync_get",
          "args": [
            "scr"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usl_sync_init",
          "args": [
            "scr",
            "&sd",
            "p",
            "newmode->acqsig",
            "newmode->relsig",
            "newmode->frsig"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "usl_sync_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
          "lines": "95-124",
          "snippet": "static int\nusl_sync_init(scr, sdp, p, acqsig, relsig, frsig)\n\tstruct wsscreen *scr;\n\tstruct usl_syncdata **sdp;\n\tstruct proc *p;\n\tint acqsig, relsig, frsig;\n{\n\tstruct usl_syncdata *sd;\n\tint res;\n\n\tsd = malloc(sizeof(struct usl_syncdata), M_DEVBUF, M_WAITOK);\n\tif (!sd)\n\t\treturn (ENOMEM);\n\tsd->s_scr = scr;\n\tsd->s_proc = p;\n\tsd->s_pid = p->p_pid;\n\tsd->s_flags = 0;\n\tsd->s_acqsig = acqsig;\n\tsd->s_relsig = relsig;\n\tsd->s_frsig = frsig;\n\ttimeout_set(&sd->s_attach_ch, usl_attachtimeout, sd);\n\ttimeout_set(&sd->s_detach_ch, usl_detachtimeout, sd);\n\tres = wsscreen_attach_sync(scr, &usl_syncops, sd);\n\tif (res) {\n\t\tfree(sd, M_DEVBUF);\n\t\treturn (res);\n\t}\n\t*sdp = sd;\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsdisplay_usl_io.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/errno.h>",
            "#include <sys/malloc.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int usl_sync_init",
            "static void usl_detachtimeout",
            "static void usl_attachtimeout",
            "static const struct wscons_syncops usl_syncops = {\n\tusl_detachproc,\n\tusl_attachproc,\n#define _usl_sync_check ((int (*) __P((void *)))usl_sync_check)\n\t_usl_sync_check,\n#define _usl_sync_destroy ((void (*) __P((void *)))usl_sync_done)\n\t_usl_sync_destroy\n};",
            "static struct usl_syncdata *\nusl_sync_get(scr)\n\tstruct wsscreen *scr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int usl_sync_init;\nstatic void usl_detachtimeout;\nstatic void usl_attachtimeout;\nstatic const struct wscons_syncops usl_syncops = {\n\tusl_detachproc,\n\tusl_attachproc,\n#define _usl_sync_check ((int (*) __P((void *)))usl_sync_check)\n\t_usl_sync_check,\n#define _usl_sync_destroy ((void (*) __P((void *)))usl_sync_done)\n\t_usl_sync_destroy\n};\nstatic struct usl_syncdata *\nusl_sync_get(scr)\n\tstruct wsscreen *scr;\n\nstatic int\nusl_sync_init(scr, sdp, p, acqsig, relsig, frsig)\n\tstruct wsscreen *scr;\n\tstruct usl_syncdata **sdp;\n\tstruct proc *p;\n\tint acqsig, relsig, frsig;\n{\n\tstruct usl_syncdata *sd;\n\tint res;\n\n\tsd = malloc(sizeof(struct usl_syncdata), M_DEVBUF, M_WAITOK);\n\tif (!sd)\n\t\treturn (ENOMEM);\n\tsd->s_scr = scr;\n\tsd->s_proc = p;\n\tsd->s_pid = p->p_pid;\n\tsd->s_flags = 0;\n\tsd->s_acqsig = acqsig;\n\tsd->s_relsig = relsig;\n\tsd->s_frsig = frsig;\n\ttimeout_set(&sd->s_attach_ch, usl_attachtimeout, sd);\n\ttimeout_set(&sd->s_detach_ch, usl_detachtimeout, sd);\n\tres = wsscreen_attach_sync(scr, &usl_syncops, sd);\n\tif (res) {\n\t\tfree(sd, M_DEVBUF);\n\t\treturn (res);\n\t}\n\t*sdp = sd;\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define PCVT_SYSBEEPF\t1193182\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define cmode ((struct vt_mode *)data)\n#define newmode ((struct vt_mode *)data)\n\nstatic int usl_sync_init;\nstatic void usl_sync_done;\nstatic struct usl_syncdata *usl_sync_get;\nstatic int usl_detachack;\nstatic int usl_attachack;\nstatic struct usl_syncdata *\nusl_sync_get(scr)\n\tstruct wsscreen *scr;\n\nint\nwsdisplay_usl_ioctl2(sc, scr, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint res;\n\tstruct usl_syncdata *sd;\n\tint req, intarg;\n\tstruct wskbd_bell_data bd;\n\tvoid *arg;\n\n\tswitch (cmd) {\n\t    case VT_SETMODE:\n#define newmode ((struct vt_mode *)data)\n\t\tif (newmode->mode == VT_PROCESS) {\n\t\t\tres = usl_sync_init(scr, &sd, p, newmode->acqsig,\n\t\t\t\t\t    newmode->relsig, newmode->frsig);\n\t\t\tif (res)\n\t\t\t\treturn (res);\n\t\t} else {\n\t\t\tsd = usl_sync_get(scr);\n\t\t\tif (sd)\n\t\t\t\tusl_sync_done(sd);\n\t\t}\n#undef newmode\n\t\treturn (0);\n\t    case VT_GETMODE:\n#define cmode ((struct vt_mode *)data)\n\t\tsd = usl_sync_get(scr);\n\t\tif (sd) {\n\t\t\tcmode->mode = VT_PROCESS;\n\t\t\tcmode->relsig = sd->s_relsig;\n\t\t\tcmode->acqsig = sd->s_acqsig;\n\t\t\tcmode->frsig = sd->s_frsig;\n\t\t} else\n\t\t\tcmode->mode = VT_AUTO;\n#undef cmode\n\t\treturn (0);\n\t    case VT_RELDISP:\n#define d (*(int *)data)\n\t\tsd = usl_sync_get(scr);\n\t\tif (!sd)\n\t\t\treturn (EINVAL);\n\t\tswitch (d) {\n\t\t    case VT_FALSE:\n\t\t    case VT_TRUE:\n\t\t\treturn (usl_detachack(sd, (d == VT_TRUE)));\n\t\t    case VT_ACKACQ:\n\t\t\treturn (usl_attachack(sd, 1));\n\t\t    default:\n\t\t\treturn (EINVAL);\n\t\t}\n#undef d\n\t\treturn (0);\n\n\t    case KDENABIO:\n\t\tif (suser(p->p_ucred, &p->p_acflag) || securelevel > 1)\n\t\t\treturn (EPERM);\n\t\t/* FALLTHRU */\n\t    case KDDISABIO:\n#if defined(__i386__)\n#if defined(COMPAT_10) || defined(COMPAT_11) || defined(COMPAT_FREEBSD)\n\t\t{\n\t\tstruct trapframe *fp = (struct trapframe *)p->p_md.md_regs;\n\t\tif (cmd == KDENABIO)\n\t\t\tfp->tf_eflags |= PSL_IOPL;\n\t\telse\n\t\t\tfp->tf_eflags &= ~PSL_IOPL;\n\t\t}\n#endif\n#endif\n\t\treturn (0);\n\t    case KDSETRAD:\n\t\t/* XXX ignore for now */\n\t\treturn (0);\n\n\t    default:\n\t\treturn (-1);\n\n\t    /*\n\t     * the following are converted to wsdisplay ioctls\n\t     */\n\t    case KDSETMODE:\n\t\treq = WSDISPLAYIO_SMODE;\n#define d (*(int *)data)\n\t\tswitch (d) {\n\t\t    case KD_GRAPHICS:\n\t\t\tintarg = WSDISPLAYIO_MODE_MAPPED;\n\t\t\tbreak;\n\t\t    case KD_TEXT:\n\t\t\tintarg = WSDISPLAYIO_MODE_EMUL;\n\t\t\tbreak;\n\t\t    default:\n\t\t\treturn (EINVAL);\n\t\t}\n#undef d\n\t\targ = &intarg;\n\t\tbreak;\n\t    case KDMKTONE:\n\t\treq = WSKBDIO_COMPLEXBELL;\n#define d (*(int *)data)\n\t\tif (d) {\n#define PCVT_SYSBEEPF\t1193182\n\t\t\tif (d >> 16) {\n\t\t\t\tbd.which = WSKBD_BELL_DOPERIOD;\n\t\t\tbd.period = d >> 16; /* ms */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbd.which = 0;\n\t\t\tif (d & 0xffff) {\n\t\t\t\tbd.which |= WSKBD_BELL_DOPITCH;\n\t\t\t\tbd.pitch = PCVT_SYSBEEPF/(d & 0xffff); /* Hz */\n\t\t\t}\n\t\t} else\n\t\t\tbd.which = 0; /* default */\n#undef d\n\t\targ = &bd;\n\t\tbreak;\n\t    case KDSETLED:\n\t\treq = WSKBDIO_SETLEDS;\n\t\tintarg = 0;\n#define d (*(int *)data)\n\t\tif (d & LED_CAP)\n\t\t\tintarg |= WSKBD_LED_CAPS;\n\t\tif (d & LED_NUM)\n\t\t\tintarg |= WSKBD_LED_NUM;\n\t\tif (d & LED_SCR)\n\t\t\tintarg |= WSKBD_LED_SCROLL;\n#undef d\n\t\targ = &intarg;\n\t\tbreak;\n\t    case KDGETLED:\n\t\treq = WSKBDIO_GETLEDS;\n\t\targ = &intarg;\n\t\tbreak;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t    case KDSKBMODE:\n\t\treq = WSKBDIO_SETMODE;\n\t\tswitch (*(int *)data) {\n\t\t    case K_RAW:\n\t\t\tintarg = WSKBD_RAW;\n\t\t\tbreak;\n\t\t    case K_XLATE:\n\t\t\tintarg = WSKBD_TRANSLATED;\n\t\t\tbreak;\n\t\t    default:\n\t\t\treturn (EINVAL);\n\t\t}\n\t\targ = &intarg;\n\t\tbreak;\n\t    case KDGKBMODE:\n\t\treq = WSKBDIO_GETMODE;\n\t\targ = &intarg;\n\t\tbreak;\n#endif\n\t}\n\n\tres = wsdisplay_internal_ioctl(sc, scr, req, arg, flag, p);\n\tif (res)\n\t\treturn (res);\n\n\tswitch (cmd) {\n\t    case KDGETLED:\n#define d (*(int *)data)\n\t\td = 0;\n\t\tif (intarg & WSKBD_LED_CAPS)\n\t\t\td |= LED_CAP;\n\t\tif (intarg & WSKBD_LED_NUM)\n\t\t\td |= LED_NUM;\n\t\tif (intarg & WSKBD_LED_SCROLL)\n\t\t\td |= LED_SCR;\n#undef d\n\t\tbreak;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t    case KDGKBMODE:\n\t\t*(int *)data = (intarg == WSKBD_RAW ? K_RAW : K_XLATE);\n\t\tbreak;\n#endif\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "wsdisplay_usl_ioctl1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
    "lines": "299-361",
    "snippet": "int\nwsdisplay_usl_ioctl1(sc, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint idx, maxidx;\n\n\tswitch (cmd) {\n\t    case VT_OPENQRY:\n\t\tmaxidx = wsdisplay_maxscreenidx(sc);\n\t\tfor (idx = 0; idx <= maxidx; idx++) {\n\t\t\tif (wsdisplay_screenstate(sc, idx) == 0) {\n\t\t\t\t*(int *)data = idx + 1;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t\treturn (ENXIO);\n\t    case VT_GETACTIVE:\n\t\tidx = wsdisplay_getactivescreen(sc);\n\t\t*(int *)data = idx + 1;\n\t\treturn (0);\n\t    case VT_ACTIVATE:\n\t\tidx = *(int *)data - 1;\n\t\treturn (wsdisplay_switch((struct device *)sc, idx, 1));\n\t    case VT_WAITACTIVE:\n\t\tidx = *(int *)data - 1;\n\t\treturn (wsscreen_switchwait(sc, idx));\n\t    case VT_GETSTATE:\n#define ss ((struct vt_stat *)data)\n\t\tidx = wsdisplay_getactivescreen(sc);\n\t\tss->v_active = idx + 1;\n\t\tss->v_state = 0;\n\t\tmaxidx = wsdisplay_maxscreenidx(sc);\n\t\tfor (idx = 0; idx <= maxidx; idx++)\n\t\t\tif (wsdisplay_screenstate(sc, idx) == EBUSY)\n\t\t\t\tss->v_state |= (1 << (idx + 1));\n#undef s\n\t\treturn (0);\n\n#ifdef WSDISPLAY_COMPAT_PCVT\n\t    case VGAPCVTID:\n#define id ((struct pcvtid *)data)\n\t\tstrcpy(id->name, \"pcvt\");\n\t\tid->rmajor = 3;\n\t\tid->rminor = 32;\n#undef id\n\t\treturn (0);\n#endif\n#ifdef WSDISPLAY_COMPAT_SYSCONS\n\t    case CONS_GETVERS:\n\t\t*(int *)data = 0x200;    /* version 2.0 */\n\t\treturn (0);\n#endif\n\n\t    default:\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsdisplay_usl_io.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/errno.h>",
      "#include <sys/malloc.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define id ((struct pcvtid *)data)",
      "#define ss ((struct vt_stat *)data)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "id->name",
            "\"pcvt\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsdisplay_screenstate",
          "args": [
            "sc",
            "idx"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_screenstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1628-1638",
          "snippet": "int\nwsdisplay_screenstate(sc, idx)\n\tstruct wsdisplay_softc *sc;\n\tint idx;\n{\n\tif (idx >= WSDISPLAY_MAXSCREEN)\n\t\treturn (EINVAL);\n\tif (!sc->sc_scr[idx])\n\t\treturn (ENXIO);\n\treturn ((sc->sc_scr[idx]->scr_flags & SCR_OPEN) ? EBUSY : 0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define WSDISPLAY_MAXSCREEN 8",
            "#define SCR_OPEN 1\t\t/* is it open? */"
          ],
          "globals_used": [
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define WSDISPLAY_MAXSCREEN 8\n#define SCR_OPEN 1\t\t/* is it open? */\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsdisplay_screenstate(sc, idx)\n\tstruct wsdisplay_softc *sc;\n\tint idx;\n{\n\tif (idx >= WSDISPLAY_MAXSCREEN)\n\t\treturn (EINVAL);\n\tif (!sc->sc_scr[idx])\n\t\treturn (ENXIO);\n\treturn ((sc->sc_scr[idx]->scr_flags & SCR_OPEN) ? EBUSY : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsdisplay_maxscreenidx",
          "args": [
            "sc"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_maxscreenidx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1621-1626",
          "snippet": "int\nwsdisplay_maxscreenidx(sc)\n\tstruct wsdisplay_softc *sc;\n{\n\treturn (WSDISPLAY_MAXSCREEN - 1);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define WSDISPLAY_MAXSCREEN 8"
          ],
          "globals_used": [
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define WSDISPLAY_MAXSCREEN 8\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsdisplay_maxscreenidx(sc)\n\tstruct wsdisplay_softc *sc;\n{\n\treturn (WSDISPLAY_MAXSCREEN - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsdisplay_getactivescreen",
          "args": [
            "sc"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_getactivescreen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1640-1645",
          "snippet": "int\nwsdisplay_getactivescreen(sc)\n\tstruct wsdisplay_softc *sc;\n{\n\treturn (sc->sc_focusidx);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsdisplay_getactivescreen(sc)\n\tstruct wsdisplay_softc *sc;\n{\n\treturn (sc->sc_focusidx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsscreen_switchwait",
          "args": [
            "sc",
            "idx"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "wsscreen_switchwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1647-1672",
          "snippet": "int\nwsscreen_switchwait(sc, no)\n\tstruct wsdisplay_softc *sc;\n\tint no;\n{\n\tstruct wsscreen *scr;\n\tint s, res = 0;\n\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN)\n\t\treturn (ENXIO);\n\tscr = sc->sc_scr[no];\n\tif (!scr)\n\t\treturn (ENXIO);\n\n\ts = spltty();\n\tif (scr != sc->sc_focus) {\n\t\tscr->scr_flags |= SCR_WAITACTIVE;\n\t\tres = tsleep(scr, PCATCH, \"wswait\", 0);\n\t\tif (scr != sc->sc_scr[no])\n\t\t\tres = ENXIO; /* disappeared in the meantime */\n\t\telse\n\t\t\tscr->scr_flags &= ~SCR_WAITACTIVE;\n\t}\n\tsplx(s);\n\treturn (res);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define WSDISPLAY_MAXSCREEN 8",
            "#define SCR_WAITACTIVE 2\t/* someone waiting on activation */"
          ],
          "globals_used": [
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define WSDISPLAY_MAXSCREEN 8\n#define SCR_WAITACTIVE 2\t/* someone waiting on activation */\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsscreen_switchwait(sc, no)\n\tstruct wsdisplay_softc *sc;\n\tint no;\n{\n\tstruct wsscreen *scr;\n\tint s, res = 0;\n\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN)\n\t\treturn (ENXIO);\n\tscr = sc->sc_scr[no];\n\tif (!scr)\n\t\treturn (ENXIO);\n\n\ts = spltty();\n\tif (scr != sc->sc_focus) {\n\t\tscr->scr_flags |= SCR_WAITACTIVE;\n\t\tres = tsleep(scr, PCATCH, \"wswait\", 0);\n\t\tif (scr != sc->sc_scr[no])\n\t\t\tres = ENXIO; /* disappeared in the meantime */\n\t\telse\n\t\t\tscr->scr_flags &= ~SCR_WAITACTIVE;\n\t}\n\tsplx(s);\n\treturn (res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsdisplay_switch",
          "args": [
            "(struct device *)sc",
            "idx",
            "1"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_switchtoconsole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1769-1775",
          "snippet": "void\nwsdisplay_switchtoconsole()\n{\n\tif (wsdisplay_console_device != NULL)\n\t\twsdisplay_switch((struct device *)wsdisplay_console_device, \n\t\t    0, 0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct wsdisplay_softc *wsdisplay_console_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic struct wsdisplay_softc *wsdisplay_console_device;\n\nvoid\nwsdisplay_switchtoconsole()\n{\n\tif (wsdisplay_console_device != NULL)\n\t\twsdisplay_switch((struct device *)wsdisplay_console_device, \n\t\t    0, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define id ((struct pcvtid *)data)\n#define ss ((struct vt_stat *)data)\n\nint\nwsdisplay_usl_ioctl1(sc, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint idx, maxidx;\n\n\tswitch (cmd) {\n\t    case VT_OPENQRY:\n\t\tmaxidx = wsdisplay_maxscreenidx(sc);\n\t\tfor (idx = 0; idx <= maxidx; idx++) {\n\t\t\tif (wsdisplay_screenstate(sc, idx) == 0) {\n\t\t\t\t*(int *)data = idx + 1;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t\treturn (ENXIO);\n\t    case VT_GETACTIVE:\n\t\tidx = wsdisplay_getactivescreen(sc);\n\t\t*(int *)data = idx + 1;\n\t\treturn (0);\n\t    case VT_ACTIVATE:\n\t\tidx = *(int *)data - 1;\n\t\treturn (wsdisplay_switch((struct device *)sc, idx, 1));\n\t    case VT_WAITACTIVE:\n\t\tidx = *(int *)data - 1;\n\t\treturn (wsscreen_switchwait(sc, idx));\n\t    case VT_GETSTATE:\n#define ss ((struct vt_stat *)data)\n\t\tidx = wsdisplay_getactivescreen(sc);\n\t\tss->v_active = idx + 1;\n\t\tss->v_state = 0;\n\t\tmaxidx = wsdisplay_maxscreenidx(sc);\n\t\tfor (idx = 0; idx <= maxidx; idx++)\n\t\t\tif (wsdisplay_screenstate(sc, idx) == EBUSY)\n\t\t\t\tss->v_state |= (1 << (idx + 1));\n#undef s\n\t\treturn (0);\n\n#ifdef WSDISPLAY_COMPAT_PCVT\n\t    case VGAPCVTID:\n#define id ((struct pcvtid *)data)\n\t\tstrcpy(id->name, \"pcvt\");\n\t\tid->rmajor = 3;\n\t\tid->rminor = 32;\n#undef id\n\t\treturn (0);\n#endif\n#ifdef WSDISPLAY_COMPAT_SYSCONS\n\t    case CONS_GETVERS:\n\t\t*(int *)data = 0x200;    /* version 2.0 */\n\t\treturn (0);\n#endif\n\n\t    default:\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "usl_attachtimeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
    "lines": "278-297",
    "snippet": "static void\nusl_attachtimeout(arg)\n\tvoid *arg;\n{\n\tstruct usl_syncdata *sd = arg;\n\n\tprintf(\"usl_attachtimeout\\n\");\n\n\tif (!(sd->s_flags & SF_ATTACHPENDING)) {\n\t\tprintf(\"usl_attachtimeout: not attaching\\n\");\n\t\treturn;\n\t}\n\n\tsd->s_flags &= ~SF_ATTACHPENDING;\n\n\tif (sd->s_callback)\n\t\t(*sd->s_callback)(sd->s_cbarg, EIO, 0);\n\n\t(void) usl_sync_check(sd);\n}",
    "includes": [
      "#include <dev/wscons/wsdisplay_usl_io.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/errno.h>",
      "#include <sys/malloc.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define SF_ATTACHPENDING 2"
    ],
    "globals_used": [
      "static int usl_sync_check",
      "static void usl_attachtimeout"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usl_sync_check",
          "args": [
            "sd"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "usl_sync_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
          "lines": "142-151",
          "snippet": "static int\nusl_sync_check(sd)\n\tstruct usl_syncdata *sd;\n{\n\tif (sd->s_proc == pfind(sd->s_pid))\n\t\treturn (1);\n\tprintf(\"usl_sync_check: process %d died\\n\", sd->s_pid);\n\tusl_sync_done(sd);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsdisplay_usl_io.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/errno.h>",
            "#include <sys/malloc.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define d (*(int *)data)",
            "#define d (*(int *)data)",
            "#define d (*(int *)data)",
            "#define d (*(int *)data)",
            "#define d (*(int *)data)"
          ],
          "globals_used": [
            "static void usl_sync_done",
            "static int usl_sync_check"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define d (*(int *)data)\n\nstatic void usl_sync_done;\nstatic int usl_sync_check;\n\nstatic int\nusl_sync_check(sd)\n\tstruct usl_syncdata *sd;\n{\n\tif (sd->s_proc == pfind(sd->s_pid))\n\t\treturn (1);\n\tprintf(\"usl_sync_check: process %d died\\n\", sd->s_pid);\n\tusl_sync_done(sd);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sd->s_cbarg",
            "EIO",
            "0"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"usl_attachtimeout: not attaching\\n\""
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SF_ATTACHPENDING 2\n\nstatic int usl_sync_check;\nstatic void usl_attachtimeout;\n\nstatic void\nusl_attachtimeout(arg)\n\tvoid *arg;\n{\n\tstruct usl_syncdata *sd = arg;\n\n\tprintf(\"usl_attachtimeout\\n\");\n\n\tif (!(sd->s_flags & SF_ATTACHPENDING)) {\n\t\tprintf(\"usl_attachtimeout: not attaching\\n\");\n\t\treturn;\n\t}\n\n\tsd->s_flags &= ~SF_ATTACHPENDING;\n\n\tif (sd->s_callback)\n\t\t(*sd->s_callback)(sd->s_cbarg, EIO, 0);\n\n\t(void) usl_sync_check(sd);\n}"
  },
  {
    "function_name": "usl_attachack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
    "lines": "259-276",
    "snippet": "static int\nusl_attachack(sd, ack)\n\tstruct usl_syncdata *sd;\n\tint ack;\n{\n\tif (!(sd->s_flags & SF_ATTACHPENDING)) {\n\t\tprintf(\"usl_attachack: not attaching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\ttimeout_del(&sd->s_attach_ch);\n\tsd->s_flags &= ~SF_ATTACHPENDING;\n\n\tif (sd->s_callback)\n\t\t(*sd->s_callback)(sd->s_cbarg, (ack ? 0 : EIO), 1);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsdisplay_usl_io.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/errno.h>",
      "#include <sys/malloc.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define SF_ATTACHPENDING 2"
    ],
    "globals_used": [
      "static int usl_attachack"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sd->s_cbarg",
            "(ack ? 0 : EIO)",
            "1"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout_del",
          "args": [
            "&sd->s_attach_ch"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"usl_attachack: not attaching\\n\""
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SF_ATTACHPENDING 2\n\nstatic int usl_attachack;\n\nstatic int\nusl_attachack(sd, ack)\n\tstruct usl_syncdata *sd;\n\tint ack;\n{\n\tif (!(sd->s_flags & SF_ATTACHPENDING)) {\n\t\tprintf(\"usl_attachack: not attaching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\ttimeout_del(&sd->s_attach_ch);\n\tsd->s_flags &= ~SF_ATTACHPENDING;\n\n\tif (sd->s_callback)\n\t\t(*sd->s_callback)(sd->s_cbarg, (ack ? 0 : EIO), 1);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "usl_attachproc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
    "lines": "234-257",
    "snippet": "static int\nusl_attachproc(cookie, waitok, callback, cbarg)\n\tvoid *cookie;\n\tint waitok;\n\tvoid (*callback) __P((void *, int, int));\n\tvoid *cbarg;\n{\n\tstruct usl_syncdata *sd = cookie;\n\n\tif (!usl_sync_check(sd))\n\t\treturn (0);\n\n\t/* we really need a callback */\n\tif (!callback)\n\t\treturn (EINVAL);\n\n\tsd->s_callback = callback;\n\tsd->s_cbarg = cbarg;\n\tsd->s_flags |= SF_ATTACHPENDING;\n\tpsignal(sd->s_proc, sd->s_acqsig);\n\ttimeout_add(&sd->s_attach_ch, wscompat_usl_synctimeout * hz);\n\n\treturn (EAGAIN);\n}",
    "includes": [
      "#include <dev/wscons/wsdisplay_usl_io.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/errno.h>",
      "#include <sys/malloc.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define SF_ATTACHPENDING 2"
    ],
    "globals_used": [
      "static int usl_sync_check",
      "static int usl_attachproc",
      "static int wscompat_usl_synctimeout = WSCOMPAT_USL_SYNCTIMEOUT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout_add",
          "args": [
            "&sd->s_attach_ch",
            "wscompat_usl_synctimeout * hz"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psignal",
          "args": [
            "sd->s_proc",
            "sd->s_acqsig"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usl_sync_check",
          "args": [
            "sd"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "usl_sync_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
          "lines": "142-151",
          "snippet": "static int\nusl_sync_check(sd)\n\tstruct usl_syncdata *sd;\n{\n\tif (sd->s_proc == pfind(sd->s_pid))\n\t\treturn (1);\n\tprintf(\"usl_sync_check: process %d died\\n\", sd->s_pid);\n\tusl_sync_done(sd);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsdisplay_usl_io.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/errno.h>",
            "#include <sys/malloc.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define d (*(int *)data)",
            "#define d (*(int *)data)",
            "#define d (*(int *)data)",
            "#define d (*(int *)data)",
            "#define d (*(int *)data)"
          ],
          "globals_used": [
            "static void usl_sync_done",
            "static int usl_sync_check"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define d (*(int *)data)\n\nstatic void usl_sync_done;\nstatic int usl_sync_check;\n\nstatic int\nusl_sync_check(sd)\n\tstruct usl_syncdata *sd;\n{\n\tif (sd->s_proc == pfind(sd->s_pid))\n\t\treturn (1);\n\tprintf(\"usl_sync_check: process %d died\\n\", sd->s_pid);\n\tusl_sync_done(sd);\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SF_ATTACHPENDING 2\n\nstatic int usl_sync_check;\nstatic int usl_attachproc;\nstatic int wscompat_usl_synctimeout = WSCOMPAT_USL_SYNCTIMEOUT;\n\nstatic int\nusl_attachproc(cookie, waitok, callback, cbarg)\n\tvoid *cookie;\n\tint waitok;\n\tvoid (*callback) __P((void *, int, int));\n\tvoid *cbarg;\n{\n\tstruct usl_syncdata *sd = cookie;\n\n\tif (!usl_sync_check(sd))\n\t\treturn (0);\n\n\t/* we really need a callback */\n\tif (!callback)\n\t\treturn (EINVAL);\n\n\tsd->s_callback = callback;\n\tsd->s_cbarg = cbarg;\n\tsd->s_flags |= SF_ATTACHPENDING;\n\tpsignal(sd->s_proc, sd->s_acqsig);\n\ttimeout_add(&sd->s_attach_ch, wscompat_usl_synctimeout * hz);\n\n\treturn (EAGAIN);\n}"
  },
  {
    "function_name": "usl_detachtimeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
    "lines": "213-232",
    "snippet": "static void\nusl_detachtimeout(arg)\n\tvoid *arg;\n{\n\tstruct usl_syncdata *sd = arg;\n\n\tprintf(\"usl_detachtimeout\\n\");\n\n\tif (!(sd->s_flags & SF_DETACHPENDING)) {\n\t\tprintf(\"usl_detachtimeout: not detaching\\n\");\n\t\treturn;\n\t}\n\n\tsd->s_flags &= ~SF_DETACHPENDING;\n\n\tif (sd->s_callback)\n\t\t(*sd->s_callback)(sd->s_cbarg, EIO, 0);\n\n\t(void) usl_sync_check(sd);\n}",
    "includes": [
      "#include <dev/wscons/wsdisplay_usl_io.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/errno.h>",
      "#include <sys/malloc.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define SF_DETACHPENDING 1"
    ],
    "globals_used": [
      "static int usl_sync_check",
      "static void usl_detachtimeout"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usl_sync_check",
          "args": [
            "sd"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "usl_sync_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
          "lines": "142-151",
          "snippet": "static int\nusl_sync_check(sd)\n\tstruct usl_syncdata *sd;\n{\n\tif (sd->s_proc == pfind(sd->s_pid))\n\t\treturn (1);\n\tprintf(\"usl_sync_check: process %d died\\n\", sd->s_pid);\n\tusl_sync_done(sd);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsdisplay_usl_io.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/errno.h>",
            "#include <sys/malloc.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define d (*(int *)data)",
            "#define d (*(int *)data)",
            "#define d (*(int *)data)",
            "#define d (*(int *)data)",
            "#define d (*(int *)data)"
          ],
          "globals_used": [
            "static void usl_sync_done",
            "static int usl_sync_check"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define d (*(int *)data)\n\nstatic void usl_sync_done;\nstatic int usl_sync_check;\n\nstatic int\nusl_sync_check(sd)\n\tstruct usl_syncdata *sd;\n{\n\tif (sd->s_proc == pfind(sd->s_pid))\n\t\treturn (1);\n\tprintf(\"usl_sync_check: process %d died\\n\", sd->s_pid);\n\tusl_sync_done(sd);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sd->s_cbarg",
            "EIO",
            "0"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"usl_detachtimeout: not detaching\\n\""
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SF_DETACHPENDING 1\n\nstatic int usl_sync_check;\nstatic void usl_detachtimeout;\n\nstatic void\nusl_detachtimeout(arg)\n\tvoid *arg;\n{\n\tstruct usl_syncdata *sd = arg;\n\n\tprintf(\"usl_detachtimeout\\n\");\n\n\tif (!(sd->s_flags & SF_DETACHPENDING)) {\n\t\tprintf(\"usl_detachtimeout: not detaching\\n\");\n\t\treturn;\n\t}\n\n\tsd->s_flags &= ~SF_DETACHPENDING;\n\n\tif (sd->s_callback)\n\t\t(*sd->s_callback)(sd->s_cbarg, EIO, 0);\n\n\t(void) usl_sync_check(sd);\n}"
  },
  {
    "function_name": "usl_detachack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
    "lines": "194-211",
    "snippet": "static int\nusl_detachack(sd, ack)\n\tstruct usl_syncdata *sd;\n\tint ack;\n{\n\tif (!(sd->s_flags & SF_DETACHPENDING)) {\n\t\tprintf(\"usl_detachack: not detaching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\ttimeout_del(&sd->s_detach_ch);\n\tsd->s_flags &= ~SF_DETACHPENDING;\n\n\tif (sd->s_callback)\n\t\t(*sd->s_callback)(sd->s_cbarg, (ack ? 0 : EIO), 1);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsdisplay_usl_io.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/errno.h>",
      "#include <sys/malloc.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define SF_DETACHPENDING 1"
    ],
    "globals_used": [
      "static int usl_detachack"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sd->s_cbarg",
            "(ack ? 0 : EIO)",
            "1"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout_del",
          "args": [
            "&sd->s_detach_ch"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"usl_detachack: not detaching\\n\""
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SF_DETACHPENDING 1\n\nstatic int usl_detachack;\n\nstatic int\nusl_detachack(sd, ack)\n\tstruct usl_syncdata *sd;\n\tint ack;\n{\n\tif (!(sd->s_flags & SF_DETACHPENDING)) {\n\t\tprintf(\"usl_detachack: not detaching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\ttimeout_del(&sd->s_detach_ch);\n\tsd->s_flags &= ~SF_DETACHPENDING;\n\n\tif (sd->s_callback)\n\t\t(*sd->s_callback)(sd->s_cbarg, (ack ? 0 : EIO), 1);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "usl_detachproc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
    "lines": "164-192",
    "snippet": "static int\nusl_detachproc(cookie, waitok, callback, cbarg)\n\tvoid *cookie;\n\tint waitok;\n\tvoid (*callback) __P((void *, int, int));\n\tvoid *cbarg;\n{\n\tstruct usl_syncdata *sd = cookie;\n\n\tif (!usl_sync_check(sd))\n\t\treturn (0);\n\n\t/* we really need a callback */\n\tif (!callback)\n\t\treturn (EINVAL);\n\n\t/*\n\t * Normally, this is called from the controlling process.\n\t * Is is supposed to reply with a VT_RELDISP ioctl(), so\n\t * it is not useful to tsleep() here.\n\t */\n\tsd->s_callback = callback;\n\tsd->s_cbarg = cbarg;\n\tsd->s_flags |= SF_DETACHPENDING;\n\tpsignal(sd->s_proc, sd->s_relsig);\n\ttimeout_set(&sd->s_detach_ch, wscompat_usl_synctimeout * hz);\n\n\treturn (EAGAIN);\n}",
    "includes": [
      "#include <dev/wscons/wsdisplay_usl_io.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/errno.h>",
      "#include <sys/malloc.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define SF_DETACHPENDING 1"
    ],
    "globals_used": [
      "static int usl_sync_check",
      "static int usl_detachproc",
      "static int wscompat_usl_synctimeout = WSCOMPAT_USL_SYNCTIMEOUT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout_set",
          "args": [
            "&sd->s_detach_ch",
            "wscompat_usl_synctimeout * hz"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psignal",
          "args": [
            "sd->s_proc",
            "sd->s_relsig"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usl_sync_check",
          "args": [
            "sd"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "usl_sync_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
          "lines": "142-151",
          "snippet": "static int\nusl_sync_check(sd)\n\tstruct usl_syncdata *sd;\n{\n\tif (sd->s_proc == pfind(sd->s_pid))\n\t\treturn (1);\n\tprintf(\"usl_sync_check: process %d died\\n\", sd->s_pid);\n\tusl_sync_done(sd);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsdisplay_usl_io.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/errno.h>",
            "#include <sys/malloc.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define d (*(int *)data)",
            "#define d (*(int *)data)",
            "#define d (*(int *)data)",
            "#define d (*(int *)data)",
            "#define d (*(int *)data)"
          ],
          "globals_used": [
            "static void usl_sync_done",
            "static int usl_sync_check"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define d (*(int *)data)\n\nstatic void usl_sync_done;\nstatic int usl_sync_check;\n\nstatic int\nusl_sync_check(sd)\n\tstruct usl_syncdata *sd;\n{\n\tif (sd->s_proc == pfind(sd->s_pid))\n\t\treturn (1);\n\tprintf(\"usl_sync_check: process %d died\\n\", sd->s_pid);\n\tusl_sync_done(sd);\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SF_DETACHPENDING 1\n\nstatic int usl_sync_check;\nstatic int usl_detachproc;\nstatic int wscompat_usl_synctimeout = WSCOMPAT_USL_SYNCTIMEOUT;\n\nstatic int\nusl_detachproc(cookie, waitok, callback, cbarg)\n\tvoid *cookie;\n\tint waitok;\n\tvoid (*callback) __P((void *, int, int));\n\tvoid *cbarg;\n{\n\tstruct usl_syncdata *sd = cookie;\n\n\tif (!usl_sync_check(sd))\n\t\treturn (0);\n\n\t/* we really need a callback */\n\tif (!callback)\n\t\treturn (EINVAL);\n\n\t/*\n\t * Normally, this is called from the controlling process.\n\t * Is is supposed to reply with a VT_RELDISP ioctl(), so\n\t * it is not useful to tsleep() here.\n\t */\n\tsd->s_callback = callback;\n\tsd->s_cbarg = cbarg;\n\tsd->s_flags |= SF_DETACHPENDING;\n\tpsignal(sd->s_proc, sd->s_relsig);\n\ttimeout_set(&sd->s_detach_ch, wscompat_usl_synctimeout * hz);\n\n\treturn (EAGAIN);\n}"
  },
  {
    "function_name": "usl_sync_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
    "lines": "142-151",
    "snippet": "static int\nusl_sync_check(sd)\n\tstruct usl_syncdata *sd;\n{\n\tif (sd->s_proc == pfind(sd->s_pid))\n\t\treturn (1);\n\tprintf(\"usl_sync_check: process %d died\\n\", sd->s_pid);\n\tusl_sync_done(sd);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsdisplay_usl_io.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/errno.h>",
      "#include <sys/malloc.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define d (*(int *)data)",
      "#define d (*(int *)data)",
      "#define d (*(int *)data)",
      "#define d (*(int *)data)",
      "#define d (*(int *)data)"
    ],
    "globals_used": [
      "static void usl_sync_done",
      "static int usl_sync_check"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usl_sync_done",
          "args": [
            "sd"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "usl_sync_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
          "lines": "126-140",
          "snippet": "static void\nusl_sync_done(sd)\n\tstruct usl_syncdata *sd;\n{\n\tif (sd->s_flags & SF_DETACHPENDING) {\n\t\ttimeout_del(&sd->s_detach_ch);\n\t\t(*sd->s_callback)(sd->s_cbarg, 0, 0);\n\t}\n\tif (sd->s_flags & SF_ATTACHPENDING) {\n\t\ttimeout_del(&sd->s_attach_ch);\n\t\t(*sd->s_callback)(sd->s_cbarg, ENXIO, 0);\n\t}\n\twsscreen_detach_sync(sd->s_scr);\n\tfree(sd, M_DEVBUF);\n}",
          "includes": [
            "#include <dev/wscons/wsdisplay_usl_io.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/errno.h>",
            "#include <sys/malloc.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define SF_ATTACHPENDING 2",
            "#define SF_DETACHPENDING 1"
          ],
          "globals_used": [
            "static void usl_sync_done"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SF_ATTACHPENDING 2\n#define SF_DETACHPENDING 1\n\nstatic void usl_sync_done;\n\nstatic void\nusl_sync_done(sd)\n\tstruct usl_syncdata *sd;\n{\n\tif (sd->s_flags & SF_DETACHPENDING) {\n\t\ttimeout_del(&sd->s_detach_ch);\n\t\t(*sd->s_callback)(sd->s_cbarg, 0, 0);\n\t}\n\tif (sd->s_flags & SF_ATTACHPENDING) {\n\t\ttimeout_del(&sd->s_attach_ch);\n\t\t(*sd->s_callback)(sd->s_cbarg, ENXIO, 0);\n\t}\n\twsscreen_detach_sync(sd->s_scr);\n\tfree(sd, M_DEVBUF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"usl_sync_check: process %d died\\n\"",
            "sd->s_pid"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfind",
          "args": [
            "sd->s_pid"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define d (*(int *)data)\n\nstatic void usl_sync_done;\nstatic int usl_sync_check;\n\nstatic int\nusl_sync_check(sd)\n\tstruct usl_syncdata *sd;\n{\n\tif (sd->s_proc == pfind(sd->s_pid))\n\t\treturn (1);\n\tprintf(\"usl_sync_check: process %d died\\n\", sd->s_pid);\n\tusl_sync_done(sd);\n\treturn (0);\n}"
  },
  {
    "function_name": "usl_sync_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
    "lines": "126-140",
    "snippet": "static void\nusl_sync_done(sd)\n\tstruct usl_syncdata *sd;\n{\n\tif (sd->s_flags & SF_DETACHPENDING) {\n\t\ttimeout_del(&sd->s_detach_ch);\n\t\t(*sd->s_callback)(sd->s_cbarg, 0, 0);\n\t}\n\tif (sd->s_flags & SF_ATTACHPENDING) {\n\t\ttimeout_del(&sd->s_attach_ch);\n\t\t(*sd->s_callback)(sd->s_cbarg, ENXIO, 0);\n\t}\n\twsscreen_detach_sync(sd->s_scr);\n\tfree(sd, M_DEVBUF);\n}",
    "includes": [
      "#include <dev/wscons/wsdisplay_usl_io.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/errno.h>",
      "#include <sys/malloc.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define SF_ATTACHPENDING 2",
      "#define SF_DETACHPENDING 1"
    ],
    "globals_used": [
      "static void usl_sync_done"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sd",
            "M_DEVBUF"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_pickfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "1057-1070",
          "snippet": "int\nwskbd_pickfree()\n{\n\tint i;\n\tstruct wskbd_softc *sc;\n\n\tfor (i = 0; i < wskbd_cd.cd_ndevs; i++) {\n\t\tif ((sc = wskbd_cd.cd_devs[i]) == NULL)\n\t\t\tcontinue;\n\t\tif (sc->sc_displaydv == NULL)\n\t\t\treturn (i);\n\t}\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};\n\nint\nwskbd_pickfree()\n{\n\tint i;\n\tstruct wskbd_softc *sc;\n\n\tfor (i = 0; i < wskbd_cd.cd_ndevs; i++) {\n\t\tif ((sc = wskbd_cd.cd_devs[i]) == NULL)\n\t\t\tcontinue;\n\t\tif (sc->sc_displaydv == NULL)\n\t\t\treturn (i);\n\t}\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsscreen_detach_sync",
          "args": [
            "sd->s_scr"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "wsscreen_detach_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1596-1604",
          "snippet": "int\nwsscreen_detach_sync(scr)\n\tstruct wsscreen *scr;\n{\n\tif (!scr->scr_syncops)\n\t\treturn (EINVAL);\n\tscr->scr_syncops = 0;\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\nwsscreen_detach_sync(scr)\n\tstruct wsscreen *scr;\n{\n\tif (!scr->scr_syncops)\n\t\treturn (EINVAL);\n\tscr->scr_syncops = 0;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sd->s_cbarg",
            "ENXIO",
            "0"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout_del",
          "args": [
            "&sd->s_attach_ch"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sd->s_cbarg",
            "0",
            "0"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout_del",
          "args": [
            "&sd->s_detach_ch"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SF_ATTACHPENDING 2\n#define SF_DETACHPENDING 1\n\nstatic void usl_sync_done;\n\nstatic void\nusl_sync_done(sd)\n\tstruct usl_syncdata *sd;\n{\n\tif (sd->s_flags & SF_DETACHPENDING) {\n\t\ttimeout_del(&sd->s_detach_ch);\n\t\t(*sd->s_callback)(sd->s_cbarg, 0, 0);\n\t}\n\tif (sd->s_flags & SF_ATTACHPENDING) {\n\t\ttimeout_del(&sd->s_attach_ch);\n\t\t(*sd->s_callback)(sd->s_cbarg, ENXIO, 0);\n\t}\n\twsscreen_detach_sync(sd->s_scr);\n\tfree(sd, M_DEVBUF);\n}"
  },
  {
    "function_name": "usl_sync_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
    "lines": "95-124",
    "snippet": "static int\nusl_sync_init(scr, sdp, p, acqsig, relsig, frsig)\n\tstruct wsscreen *scr;\n\tstruct usl_syncdata **sdp;\n\tstruct proc *p;\n\tint acqsig, relsig, frsig;\n{\n\tstruct usl_syncdata *sd;\n\tint res;\n\n\tsd = malloc(sizeof(struct usl_syncdata), M_DEVBUF, M_WAITOK);\n\tif (!sd)\n\t\treturn (ENOMEM);\n\tsd->s_scr = scr;\n\tsd->s_proc = p;\n\tsd->s_pid = p->p_pid;\n\tsd->s_flags = 0;\n\tsd->s_acqsig = acqsig;\n\tsd->s_relsig = relsig;\n\tsd->s_frsig = frsig;\n\ttimeout_set(&sd->s_attach_ch, usl_attachtimeout, sd);\n\ttimeout_set(&sd->s_detach_ch, usl_detachtimeout, sd);\n\tres = wsscreen_attach_sync(scr, &usl_syncops, sd);\n\tif (res) {\n\t\tfree(sd, M_DEVBUF);\n\t\treturn (res);\n\t}\n\t*sdp = sd;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsdisplay_usl_io.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/errno.h>",
      "#include <sys/malloc.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int usl_sync_init",
      "static void usl_detachtimeout",
      "static void usl_attachtimeout",
      "static const struct wscons_syncops usl_syncops = {\n\tusl_detachproc,\n\tusl_attachproc,\n#define _usl_sync_check ((int (*) __P((void *)))usl_sync_check)\n\t_usl_sync_check,\n#define _usl_sync_destroy ((void (*) __P((void *)))usl_sync_done)\n\t_usl_sync_destroy\n};",
      "static struct usl_syncdata *\nusl_sync_get(scr)\n\tstruct wsscreen *scr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sd",
            "M_DEVBUF"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_pickfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "1057-1070",
          "snippet": "int\nwskbd_pickfree()\n{\n\tint i;\n\tstruct wskbd_softc *sc;\n\n\tfor (i = 0; i < wskbd_cd.cd_ndevs; i++) {\n\t\tif ((sc = wskbd_cd.cd_devs[i]) == NULL)\n\t\t\tcontinue;\n\t\tif (sc->sc_displaydv == NULL)\n\t\t\treturn (i);\n\t}\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};\n\nint\nwskbd_pickfree()\n{\n\tint i;\n\tstruct wskbd_softc *sc;\n\n\tfor (i = 0; i < wskbd_cd.cd_ndevs; i++) {\n\t\tif ((sc = wskbd_cd.cd_devs[i]) == NULL)\n\t\t\tcontinue;\n\t\tif (sc->sc_displaydv == NULL)\n\t\t\treturn (i);\n\t}\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsscreen_attach_sync",
          "args": [
            "scr",
            "&usl_syncops",
            "sd"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "wsscreen_attach_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1577-1594",
          "snippet": "int\nwsscreen_attach_sync(scr, ops, cookie)\n\tstruct wsscreen *scr;\n\tconst struct wscons_syncops *ops;\n\tvoid *cookie;\n{\n\tif (scr->scr_syncops) {\n\t\t/*\n\t\t * The screen is already claimed.\n\t\t * Check if the owner is still alive.\n\t\t */\n\t\tif ((*scr->scr_syncops->check)(scr->scr_synccookie))\n\t\t\treturn (EBUSY);\n\t}\n\tscr->scr_syncops = ops;\n\tscr->scr_synccookie = cookie;\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *cookie;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid *cookie;\n\nint\nwsscreen_attach_sync(scr, ops, cookie)\n\tstruct wsscreen *scr;\n\tconst struct wscons_syncops *ops;\n\tvoid *cookie;\n{\n\tif (scr->scr_syncops) {\n\t\t/*\n\t\t * The screen is already claimed.\n\t\t * Check if the owner is still alive.\n\t\t */\n\t\tif ((*scr->scr_syncops->check)(scr->scr_synccookie))\n\t\t\treturn (EBUSY);\n\t}\n\tscr->scr_syncops = ops;\n\tscr->scr_synccookie = cookie;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout_set",
          "args": [
            "&sd->s_detach_ch",
            "usl_detachtimeout",
            "sd"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout_set",
          "args": [
            "&sd->s_attach_ch",
            "usl_attachtimeout",
            "sd"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct usl_syncdata)",
            "M_DEVBUF",
            "M_WAITOK"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int usl_sync_init;\nstatic void usl_detachtimeout;\nstatic void usl_attachtimeout;\nstatic const struct wscons_syncops usl_syncops = {\n\tusl_detachproc,\n\tusl_attachproc,\n#define _usl_sync_check ((int (*) __P((void *)))usl_sync_check)\n\t_usl_sync_check,\n#define _usl_sync_destroy ((void (*) __P((void *)))usl_sync_done)\n\t_usl_sync_destroy\n};\nstatic struct usl_syncdata *\nusl_sync_get(scr)\n\tstruct wsscreen *scr;\n\nstatic int\nusl_sync_init(scr, sdp, p, acqsig, relsig, frsig)\n\tstruct wsscreen *scr;\n\tstruct usl_syncdata **sdp;\n\tstruct proc *p;\n\tint acqsig, relsig, frsig;\n{\n\tstruct usl_syncdata *sd;\n\tint res;\n\n\tsd = malloc(sizeof(struct usl_syncdata), M_DEVBUF, M_WAITOK);\n\tif (!sd)\n\t\treturn (ENOMEM);\n\tsd->s_scr = scr;\n\tsd->s_proc = p;\n\tsd->s_pid = p->p_pid;\n\tsd->s_flags = 0;\n\tsd->s_acqsig = acqsig;\n\tsd->s_relsig = relsig;\n\tsd->s_frsig = frsig;\n\ttimeout_set(&sd->s_attach_ch, usl_attachtimeout, sd);\n\ttimeout_set(&sd->s_detach_ch, usl_detachtimeout, sd);\n\tres = wsscreen_attach_sync(scr, &usl_syncops, sd);\n\tif (res) {\n\t\tfree(sd, M_DEVBUF);\n\t\treturn (res);\n\t}\n\t*sdp = sd;\n\treturn (0);\n}"
  }
]