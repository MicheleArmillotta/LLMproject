[
  {
    "function_name": "createFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_chaindecluster.c",
    "lines": "260-287",
    "snippet": "void    (**createFunc) (RF_Raid_t *, RF_AccessStripeMap_t *,\n            RF_DagHeader_t *, void *, RF_RaidAccessFlags_t,\n/**INDENT** Warning@258: Extra ) */\n            RF_AllocListElem_t *))\n#endif\n{\n\tRF_ASSERT(RF_IO_IS_R_OR_W(type));\n\tRF_ASSERT(raidPtr->numRow == 1);\n\n\tif (asmap->numDataFailed + asmap->numParityFailed > 1) {\n\t\tRF_ERRORMSG(\"Multiple disks failed in a single group!  Aborting I/O operation.\\n\");\n\t\t*createFunc = NULL;\n\t\treturn;\n\t}\n\t*createFunc = (type == RF_IO_TYPE_READ) ? (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG : (RF_VoidFuncPtr) rf_CreateRaidOneWriteDAG;\n\n\tif (type == RF_IO_TYPE_READ) {\n\t\tif ((raidPtr->status[0] == rf_rs_degraded) || (raidPtr->status[0] == rf_rs_reconstructing))\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateRaidCDegradedReadDAG;\t/* array status is\n\t\t\t\t\t\t\t\t\t\t\t * degraded, implement\n\t\t\t\t\t\t\t\t\t\t\t * workload shifting */\n\t\telse\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateMirrorPartitionReadDAG;\t/* array status not\n\t\t\t\t\t\t\t\t\t\t\t * degraded, so use\n\t\t\t\t\t\t\t\t\t\t\t * mirror partition dag */\n\t} else\n\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateRaidOneWriteDAG;\n}",
    "includes": [
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_chaindecluster.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void \nrf_RAIDCDagSelect(\n    RF_Raid_t * raidPtr,\n    RF_IoType_t type,\n    RF_AccessStripeMap_t * asmap,\n    RF_VoidFuncPtr * createFunc)"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ERRORMSG",
          "args": [
            "\"Multiple disks failed in a single group!  Aborting I/O operation.\\n\""
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->numRow == 1"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "RF_IO_IS_R_OR_W(type)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_IO_IS_R_OR_W",
          "args": [
            "type"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_chaindecluster.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_RAIDCDagSelect(\n    RF_Raid_t * raidPtr,\n    RF_IoType_t type,\n    RF_AccessStripeMap_t * asmap,\n    RF_VoidFuncPtr * createFunc);\n\nvoid    (**createFunc) (RF_Raid_t *, RF_AccessStripeMap_t *,\n            RF_DagHeader_t *, void *, RF_RaidAccessFlags_t,\n/**INDENT** Warning@258: Extra ) */\n            RF_AllocListElem_t *))\n#endif\n{\n\tRF_ASSERT(RF_IO_IS_R_OR_W(type));\n\tRF_ASSERT(raidPtr->numRow == 1);\n\n\tif (asmap->numDataFailed + asmap->numParityFailed > 1) {\n\t\tRF_ERRORMSG(\"Multiple disks failed in a single group!  Aborting I/O operation.\\n\");\n\t\t*createFunc = NULL;\n\t\treturn;\n\t}\n\t*createFunc = (type == RF_IO_TYPE_READ) ? (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG : (RF_VoidFuncPtr) rf_CreateRaidOneWriteDAG;\n\n\tif (type == RF_IO_TYPE_READ) {\n\t\tif ((raidPtr->status[0] == rf_rs_degraded) || (raidPtr->status[0] == rf_rs_reconstructing))\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateRaidCDegradedReadDAG;\t/* array status is\n\t\t\t\t\t\t\t\t\t\t\t * degraded, implement\n\t\t\t\t\t\t\t\t\t\t\t * workload shifting */\n\t\telse\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateMirrorPartitionReadDAG;\t/* array status not\n\t\t\t\t\t\t\t\t\t\t\t * degraded, so use\n\t\t\t\t\t\t\t\t\t\t\t * mirror partition dag */\n\t} else\n\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateRaidOneWriteDAG;\n}"
  },
  {
    "function_name": "rf_MapSIDToPSIDChainDecluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_chaindecluster.c",
    "lines": "234-243",
    "snippet": "void \nrf_MapSIDToPSIDChainDecluster(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t stripeID,\n    RF_StripeNum_t * psID,\n    RF_ReconUnitNum_t * which_ru)\n{\n\t*which_ru = 0;\n\t*psID = stripeID;\n}",
    "includes": [
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_chaindecluster.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_chaindecluster.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_MapSIDToPSIDChainDecluster(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t stripeID,\n    RF_StripeNum_t * psID,\n    RF_ReconUnitNum_t * which_ru)\n{\n\t*which_ru = 0;\n\t*psID = stripeID;\n}"
  },
  {
    "function_name": "rf_IdentifyStripeChainDecluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_chaindecluster.c",
    "lines": "217-232",
    "snippet": "void \nrf_IdentifyStripeChainDecluster(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t addr,\n    RF_RowCol_t ** diskids,\n    RF_RowCol_t * outRow)\n{\n\tRF_ChaindeclusterConfigInfo_t *info = (RF_ChaindeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tRF_StripeNum_t SUID;\n\tRF_RowCol_t col;\n\n\tSUID = addr / raidPtr->Layout.sectorsPerStripeUnit;\n\tcol = SUID % raidPtr->numCol;\n\t*outRow = 0;\n\t*diskids = info->stripeIdentifier[col];\n}",
    "includes": [
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_chaindecluster.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_chaindecluster.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_IdentifyStripeChainDecluster(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t addr,\n    RF_RowCol_t ** diskids,\n    RF_RowCol_t * outRow)\n{\n\tRF_ChaindeclusterConfigInfo_t *info = (RF_ChaindeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tRF_StripeNum_t SUID;\n\tRF_RowCol_t col;\n\n\tSUID = addr / raidPtr->Layout.sectorsPerStripeUnit;\n\tcol = SUID % raidPtr->numCol;\n\t*outRow = 0;\n\t*diskids = info->stripeIdentifier[col];\n}"
  },
  {
    "function_name": "rf_MapParityChainDecluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_chaindecluster.c",
    "lines": "174-215",
    "snippet": "void \nrf_MapParityChainDecluster(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_ChaindeclusterConfigInfo_t *info = (RF_ChaindeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tRF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;\n\tRF_SectorNum_t index_within_region, index_within_disk;\n\tRF_StripeNum_t sparing_region_id;\n\tint     col_before_remap;\n\n\t*row = 0;\n\tif (!remap) {\n\t\t*col = SUID % raidPtr->numCol;\n\t\t*col = (*col + 1) % raidPtr->numCol;\n\t\t*diskSector = info->mirrorStripeOffset * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (SUID / raidPtr->numCol) * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n\t} else {\n\t\t/* remap parity to spare space ... */\n\t\tsparing_region_id = SUID / info->stripeUnitsPerSparingRegion;\n\t\tindex_within_region = SUID % info->stripeUnitsPerSparingRegion;\n\t\tindex_within_disk = index_within_region / raidPtr->numCol;\n\t\t*diskSector = sparing_region_id * (raidPtr->numCol + 1) * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidPtr->numCol) * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n\t\tcol_before_remap = SUID % raidPtr->numCol;\n\t\tif (index_within_disk < col_before_remap)\n\t\t\t*col = index_within_disk;\n\t\telse\n\t\t\tif (index_within_disk == raidPtr->numCol - 2) {\n\t\t\t\t*col = (col_before_remap + 2) % raidPtr->numCol;\n\t\t\t\t*diskSector -= raidPtr->Layout.sectorsPerStripeUnit;\n\t\t\t} else\n\t\t\t\t*col = (index_within_disk + 2) % raidPtr->numCol;\n\t}\n\n}",
    "includes": [
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_chaindecluster.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_chaindecluster.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_MapParityChainDecluster(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_ChaindeclusterConfigInfo_t *info = (RF_ChaindeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tRF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;\n\tRF_SectorNum_t index_within_region, index_within_disk;\n\tRF_StripeNum_t sparing_region_id;\n\tint     col_before_remap;\n\n\t*row = 0;\n\tif (!remap) {\n\t\t*col = SUID % raidPtr->numCol;\n\t\t*col = (*col + 1) % raidPtr->numCol;\n\t\t*diskSector = info->mirrorStripeOffset * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (SUID / raidPtr->numCol) * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n\t} else {\n\t\t/* remap parity to spare space ... */\n\t\tsparing_region_id = SUID / info->stripeUnitsPerSparingRegion;\n\t\tindex_within_region = SUID % info->stripeUnitsPerSparingRegion;\n\t\tindex_within_disk = index_within_region / raidPtr->numCol;\n\t\t*diskSector = sparing_region_id * (raidPtr->numCol + 1) * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidPtr->numCol) * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n\t\tcol_before_remap = SUID % raidPtr->numCol;\n\t\tif (index_within_disk < col_before_remap)\n\t\t\t*col = index_within_disk;\n\t\telse\n\t\t\tif (index_within_disk == raidPtr->numCol - 2) {\n\t\t\t\t*col = (col_before_remap + 2) % raidPtr->numCol;\n\t\t\t\t*diskSector -= raidPtr->Layout.sectorsPerStripeUnit;\n\t\t\t} else\n\t\t\t\t*col = (index_within_disk + 2) % raidPtr->numCol;\n\t}\n\n}"
  },
  {
    "function_name": "rf_MapSectorChainDecluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_chaindecluster.c",
    "lines": "125-167",
    "snippet": "void \nrf_MapSectorChainDecluster(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_ChaindeclusterConfigInfo_t *info = (RF_ChaindeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tRF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;\n\tRF_SectorNum_t index_within_region, index_within_disk;\n\tRF_StripeNum_t sparing_region_id;\n\tint     col_before_remap;\n\n\t*row = 0;\n\tsparing_region_id = SUID / info->stripeUnitsPerSparingRegion;\n\tindex_within_region = SUID % info->stripeUnitsPerSparingRegion;\n\tindex_within_disk = index_within_region / raidPtr->numCol;\n\tcol_before_remap = SUID % raidPtr->numCol;\n\n\tif (!remap) {\n\t\t*col = col_before_remap;\n\t\t*diskSector = (index_within_disk + ((raidPtr->numCol - 1) * sparing_region_id)) *\n\t\t    raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n\t} else {\n\t\t/* remap sector to spare space... */\n\t\t*diskSector = sparing_region_id * (raidPtr->numCol + 1) * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidPtr->numCol - 1) * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n\t\tindex_within_disk = index_within_region / raidPtr->numCol;\n\t\tif (index_within_disk < col_before_remap)\n\t\t\t*col = index_within_disk;\n\t\telse\n\t\t\tif (index_within_disk == raidPtr->numCol - 2) {\n\t\t\t\t*col = (col_before_remap + raidPtr->numCol - 1) % raidPtr->numCol;\n\t\t\t\t*diskSector += raidPtr->Layout.sectorsPerStripeUnit;\n\t\t\t} else\n\t\t\t\t*col = (index_within_disk + 2) % raidPtr->numCol;\n\t}\n\n}",
    "includes": [
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_chaindecluster.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_chaindecluster.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_MapSectorChainDecluster(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_ChaindeclusterConfigInfo_t *info = (RF_ChaindeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tRF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;\n\tRF_SectorNum_t index_within_region, index_within_disk;\n\tRF_StripeNum_t sparing_region_id;\n\tint     col_before_remap;\n\n\t*row = 0;\n\tsparing_region_id = SUID / info->stripeUnitsPerSparingRegion;\n\tindex_within_region = SUID % info->stripeUnitsPerSparingRegion;\n\tindex_within_disk = index_within_region / raidPtr->numCol;\n\tcol_before_remap = SUID % raidPtr->numCol;\n\n\tif (!remap) {\n\t\t*col = col_before_remap;\n\t\t*diskSector = (index_within_disk + ((raidPtr->numCol - 1) * sparing_region_id)) *\n\t\t    raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n\t} else {\n\t\t/* remap sector to spare space... */\n\t\t*diskSector = sparing_region_id * (raidPtr->numCol + 1) * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidPtr->numCol - 1) * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n\t\tindex_within_disk = index_within_region / raidPtr->numCol;\n\t\tif (index_within_disk < col_before_remap)\n\t\t\t*col = index_within_disk;\n\t\telse\n\t\t\tif (index_within_disk == raidPtr->numCol - 2) {\n\t\t\t\t*col = (col_before_remap + raidPtr->numCol - 1) % raidPtr->numCol;\n\t\t\t\t*diskSector += raidPtr->Layout.sectorsPerStripeUnit;\n\t\t\t} else\n\t\t\t\t*col = (index_within_disk + 2) % raidPtr->numCol;\n\t}\n\n}"
  },
  {
    "function_name": "rf_GetNumSpareRUsChainDecluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_chaindecluster.c",
    "lines": "110-121",
    "snippet": "RF_ReconUnitCount_t \nrf_GetNumSpareRUsChainDecluster(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_ChaindeclusterConfigInfo_t *info = (RF_ChaindeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\n\t/*\n         * The layout uses two stripe units per disk as spare within each\n         * sparing region.\n         */\n\treturn (2 * info->numSparingRegions);\n}",
    "includes": [
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_chaindecluster.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_chaindecluster.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nRF_ReconUnitCount_t \nrf_GetNumSpareRUsChainDecluster(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_ChaindeclusterConfigInfo_t *info = (RF_ChaindeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\n\t/*\n         * The layout uses two stripe units per disk as spare within each\n         * sparing region.\n         */\n\treturn (2 * info->numSparingRegions);\n}"
  },
  {
    "function_name": "rf_ConfigureChainDecluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_chaindecluster.c",
    "lines": "57-108",
    "snippet": "int \nrf_ConfigureChainDecluster(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_StripeCount_t num_used_stripeUnitsPerDisk;\n\tRF_ChaindeclusterConfigInfo_t *info;\n\tRF_RowCol_t i;\n\n\t/* create a Chained Declustering configuration structure */\n\tRF_MallocAndAdd(info, sizeof(RF_ChaindeclusterConfigInfo_t), (RF_ChaindeclusterConfigInfo_t *), raidPtr->cleanupList);\n\tif (info == NULL)\n\t\treturn (ENOMEM);\n\tlayoutPtr->layoutSpecificInfo = (void *) info;\n\n\t/* fill in the config structure.  */\n\tinfo->stripeIdentifier = rf_make_2d_array(raidPtr->numCol, 2, raidPtr->cleanupList);\n\tif (info->stripeIdentifier == NULL)\n\t\treturn (ENOMEM);\n\tfor (i = 0; i < raidPtr->numCol; i++) {\n\t\tinfo->stripeIdentifier[i][0] = i % raidPtr->numCol;\n\t\tinfo->stripeIdentifier[i][1] = (i + 1) % raidPtr->numCol;\n\t}\n\n\tRF_ASSERT(raidPtr->numRow == 1);\n\n\t/* fill in the remaining layout parameters */\n\tnum_used_stripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk - (layoutPtr->stripeUnitsPerDisk %\n\t    (2 * raidPtr->numCol - 2));\n\tinfo->numSparingRegions = num_used_stripeUnitsPerDisk / (2 * raidPtr->numCol - 2);\n\tinfo->stripeUnitsPerSparingRegion = raidPtr->numCol * (raidPtr->numCol - 1);\n\tinfo->mirrorStripeOffset = info->numSparingRegions * (raidPtr->numCol - 1);\n\tlayoutPtr->numStripe = info->numSparingRegions * info->stripeUnitsPerSparingRegion;\n\tlayoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;\n\tlayoutPtr->numDataCol = 1;\n\tlayoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;\n\tlayoutPtr->numParityCol = 1;\n\n\tlayoutPtr->dataStripeUnitsPerDisk = num_used_stripeUnitsPerDisk;\n\n\traidPtr->sectorsPerDisk =\n\t    num_used_stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit;\n\n\traidPtr->totalSectors =\n\t    (layoutPtr->numStripe) * layoutPtr->sectorsPerStripeUnit;\n\n\tlayoutPtr->stripeUnitsPerDisk = raidPtr->sectorsPerDisk / layoutPtr->sectorsPerStripeUnit;\n\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_chaindecluster.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->numRow == 1"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_make_2d_array",
          "args": [
            "raidPtr->numCol",
            "2",
            "raidPtr->cleanupList"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MallocAndAdd",
          "args": [
            "info",
            "sizeof(RF_ChaindeclusterConfigInfo_t)",
            "(RF_ChaindeclusterConfigInfo_t *), raidPtr->cleanupList"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_chaindecluster.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_ConfigureChainDecluster(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_StripeCount_t num_used_stripeUnitsPerDisk;\n\tRF_ChaindeclusterConfigInfo_t *info;\n\tRF_RowCol_t i;\n\n\t/* create a Chained Declustering configuration structure */\n\tRF_MallocAndAdd(info, sizeof(RF_ChaindeclusterConfigInfo_t), (RF_ChaindeclusterConfigInfo_t *), raidPtr->cleanupList);\n\tif (info == NULL)\n\t\treturn (ENOMEM);\n\tlayoutPtr->layoutSpecificInfo = (void *) info;\n\n\t/* fill in the config structure.  */\n\tinfo->stripeIdentifier = rf_make_2d_array(raidPtr->numCol, 2, raidPtr->cleanupList);\n\tif (info->stripeIdentifier == NULL)\n\t\treturn (ENOMEM);\n\tfor (i = 0; i < raidPtr->numCol; i++) {\n\t\tinfo->stripeIdentifier[i][0] = i % raidPtr->numCol;\n\t\tinfo->stripeIdentifier[i][1] = (i + 1) % raidPtr->numCol;\n\t}\n\n\tRF_ASSERT(raidPtr->numRow == 1);\n\n\t/* fill in the remaining layout parameters */\n\tnum_used_stripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk - (layoutPtr->stripeUnitsPerDisk %\n\t    (2 * raidPtr->numCol - 2));\n\tinfo->numSparingRegions = num_used_stripeUnitsPerDisk / (2 * raidPtr->numCol - 2);\n\tinfo->stripeUnitsPerSparingRegion = raidPtr->numCol * (raidPtr->numCol - 1);\n\tinfo->mirrorStripeOffset = info->numSparingRegions * (raidPtr->numCol - 1);\n\tlayoutPtr->numStripe = info->numSparingRegions * info->stripeUnitsPerSparingRegion;\n\tlayoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;\n\tlayoutPtr->numDataCol = 1;\n\tlayoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;\n\tlayoutPtr->numParityCol = 1;\n\n\tlayoutPtr->dataStripeUnitsPerDisk = num_used_stripeUnitsPerDisk;\n\n\traidPtr->sectorsPerDisk =\n\t    num_used_stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit;\n\n\traidPtr->totalSectors =\n\t    (layoutPtr->numStripe) * layoutPtr->sectorsPerStripeUnit;\n\n\tlayoutPtr->stripeUnitsPerDisk = raidPtr->sectorsPerDisk / layoutPtr->sectorsPerStripeUnit;\n\n\treturn (0);\n}"
  }
]