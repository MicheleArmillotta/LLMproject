[
  {
    "function_name": "ofnmmatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofbus.c",
    "lines": "217-227",
    "snippet": "int\nofnmmatch(cp1, cp2)\n\tchar *cp1, *cp2;\n{\n\tint i;\n\t\n\tfor (i = 0; *cp2; i++)\n\t\tif (*cp1++ != *cp2++)\n\t\t\treturn 0;\n\treturn i;\n}",
    "includes": [
      "#include \"sd.h\"",
      "#include <dev/ofw/openfirm.h>",
      "#include <machine/autoconf.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sd.h\"\n#include <dev/ofw/openfirm.h>\n#include <machine/autoconf.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\nofnmmatch(cp1, cp2)\n\tchar *cp1, *cp2;\n{\n\tint i;\n\t\n\tfor (i = 0; *cp2; i++)\n\t\tif (*cp1++ != *cp2++)\n\t\t\treturn 0;\n\treturn i;\n}"
  },
  {
    "function_name": "ofbattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofbus.c",
    "lines": "164-212",
    "snippet": "void\nofbattach(parent, dev, aux)\n\tstruct device *parent, *dev;\n\tvoid *aux;\n{\n\tint child;\n\tchar name[5];\n\tstruct ofprobe *ofp = aux;\n\tstruct ofprobe probe;\n\tint units;\n\t\n\tif (!parent)\n\t\tofbprint(aux, 0);\n\t\t\n\tprintf(\"\\n\");\n\n\t/*\n\t * This is a hack to make the probe work on the scsi (and ide) bus.\n\t * YES, I THINK IT IS A BUG IN THE OPENFIRMWARE TO NOT PROBE ALL\n\t * DEVICES ON THESE BUSSES.\n\t */\n\tunits = 1;\n\tif (OF_getprop(ofp->phandle, \"name\", name, sizeof name) > 0) {\n\t\tif (!strcmp(name, \"scsi\")) {\n#if NSD > 0\n\t\t\tunits = 0; /* if sd driver in kernel, dont use ofw */\n#else\n\t\t\tunits = 7; /* What about wide or hostid != 7?\tXXX */\n#endif\n\t\t} else if (!strcmp(name, \"ide\")) {\n#if NSD > 0\n\t\t\tunits = 0; /* if sd? driver in kernel, dont use ofw */\n#else \n\t\t\tunits = 2;\n#endif\n\t\t}\n\t}\n\tfor (child = OF_child(ofp->phandle); child; child = OF_peer(child)) {\n\t\t/*\n\t\t * This is a hack to skip all the entries in the tree\n\t\t * that aren't devices (packages, openfirmware etc.).\n\t\t */\n\t\tif (OF_getprop(child, \"device_type\", name, sizeof name) < 0)\n\t\t\tcontinue;\n\t\tprobe.phandle = child;\n\t\tfor (probe.unit = 0; probe.unit < units; probe.unit++)\n\t\t\tconfig_found(dev, &probe, ofbprint);\n\t}\n}",
    "includes": [
      "#include \"sd.h\"",
      "#include <dev/ofw/openfirm.h>",
      "#include <machine/autoconf.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void ofbattach",
      "static int ofbprint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "dev",
            "&probe",
            "ofbprint"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_getprop",
          "args": [
            "child",
            "\"device_type\"",
            "name",
            "sizeof name"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_peer",
          "args": [
            "child"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_child",
          "args": [
            "ofp->phandle"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"ide\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"scsi\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_getprop",
          "args": [
            "ofp->phandle",
            "\"name\"",
            "name",
            "sizeof name"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ofbprint",
          "args": [
            "aux",
            "0"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "ofbprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofbus.c",
          "lines": "66-91",
          "snippet": "static int\nofbprint(aux, name)\n\tvoid *aux;\n\tconst char *name;\n{\n\tstruct ofprobe *ofp = aux;\n\tchar child[64];\n\tint l;\n\t\n\tif ((l = OF_getprop(ofp->phandle, \"name\", child, sizeof child - 1)) < 0)\n\t\tpanic(\"device without name?\");\n\tif (l >= sizeof child)\n\t\tl = sizeof child - 1;\n\tchild[l] = 0;\n\t\n\tif (name) {\n\t\t/* Dont print anything here, be quiet\n\t\tprintf(\"%s at %s\", child, name);\n\t\treturn UNCONF;\n\t\t*/\n\t\treturn QUIET;\n\t} else {\n\t\tprintf(\" (%s)\", child);\n\treturn QUIET;\n\t}\n}",
          "includes": [
            "#include \"sd.h\"",
            "#include <dev/ofw/openfirm.h>",
            "#include <machine/autoconf.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ofbprint"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sd.h\"\n#include <dev/ofw/openfirm.h>\n#include <machine/autoconf.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nstatic int ofbprint;\n\nstatic int\nofbprint(aux, name)\n\tvoid *aux;\n\tconst char *name;\n{\n\tstruct ofprobe *ofp = aux;\n\tchar child[64];\n\tint l;\n\t\n\tif ((l = OF_getprop(ofp->phandle, \"name\", child, sizeof child - 1)) < 0)\n\t\tpanic(\"device without name?\");\n\tif (l >= sizeof child)\n\t\tl = sizeof child - 1;\n\tchild[l] = 0;\n\t\n\tif (name) {\n\t\t/* Dont print anything here, be quiet\n\t\tprintf(\"%s at %s\", child, name);\n\t\treturn UNCONF;\n\t\t*/\n\t\treturn QUIET;\n\t} else {\n\t\tprintf(\" (%s)\", child);\n\treturn QUIET;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sd.h\"\n#include <dev/ofw/openfirm.h>\n#include <machine/autoconf.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid ofbattach;\nstatic int ofbprint;\n\nvoid\nofbattach(parent, dev, aux)\n\tstruct device *parent, *dev;\n\tvoid *aux;\n{\n\tint child;\n\tchar name[5];\n\tstruct ofprobe *ofp = aux;\n\tstruct ofprobe probe;\n\tint units;\n\t\n\tif (!parent)\n\t\tofbprint(aux, 0);\n\t\t\n\tprintf(\"\\n\");\n\n\t/*\n\t * This is a hack to make the probe work on the scsi (and ide) bus.\n\t * YES, I THINK IT IS A BUG IN THE OPENFIRMWARE TO NOT PROBE ALL\n\t * DEVICES ON THESE BUSSES.\n\t */\n\tunits = 1;\n\tif (OF_getprop(ofp->phandle, \"name\", name, sizeof name) > 0) {\n\t\tif (!strcmp(name, \"scsi\")) {\n#if NSD > 0\n\t\t\tunits = 0; /* if sd driver in kernel, dont use ofw */\n#else\n\t\t\tunits = 7; /* What about wide or hostid != 7?\tXXX */\n#endif\n\t\t} else if (!strcmp(name, \"ide\")) {\n#if NSD > 0\n\t\t\tunits = 0; /* if sd? driver in kernel, dont use ofw */\n#else \n\t\t\tunits = 2;\n#endif\n\t\t}\n\t}\n\tfor (child = OF_child(ofp->phandle); child; child = OF_peer(child)) {\n\t\t/*\n\t\t * This is a hack to skip all the entries in the tree\n\t\t * that aren't devices (packages, openfirmware etc.).\n\t\t */\n\t\tif (OF_getprop(child, \"device_type\", name, sizeof name) < 0)\n\t\t\tcontinue;\n\t\tprobe.phandle = child;\n\t\tfor (probe.unit = 0; probe.unit < units; probe.unit++)\n\t\t\tconfig_found(dev, &probe, ofbprint);\n\t}\n}"
  },
  {
    "function_name": "ofbprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofbus.c",
    "lines": "152-162",
    "snippet": "int\nofbprobe(parent, cf, aux)\n\tstruct device *parent;\n\tvoid *cf, *aux;\n{\n\tstruct ofprobe *ofp = aux;\n\t\n\tif (!OF_child(ofp->phandle))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"sd.h\"",
      "#include <dev/ofw/openfirm.h>",
      "#include <machine/autoconf.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ofbprobe"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OF_child",
          "args": [
            "ofp->phandle"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sd.h\"\n#include <dev/ofw/openfirm.h>\n#include <machine/autoconf.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint ofbprobe;\n\nint\nofbprobe(parent, cf, aux)\n\tstruct device *parent;\n\tvoid *cf, *aux;\n{\n\tstruct ofprobe *ofp = aux;\n\t\n\tif (!OF_child(ofp->phandle))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "ofrattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofbus.c",
    "lines": "106-151",
    "snippet": "void\nofrattach(parent, dev, aux)\n\tstruct device *parent, *dev;\n\tvoid *aux;\n{\n\tint child;\n\tchar name[5];\n\tstruct ofprobe *ofp = aux;\n\tstruct ofprobe probe;\n\tint units;\n\tint node;\n\tchar ofname[64];\n\tint l;\n\t\n        if (!(node = OF_peer(0)))\n                panic(\"No PROM root\");\n        probe.phandle = node;\n\tofp = &probe;\n\n\tofbprint(ofp, 0);\n\tprintf(\"\\n\");\n\n\tif ((l = OF_getprop(ofp->phandle, \"model\", ofname, sizeof ofname - 1)) < 0)\n\t{\n\t\t/* no system name? */\n\t} else {\n\t\tif (l >= sizeof ofname)\n\t\t\tl = sizeof ofname - 1;\n\t\tofname[l] = 0;\n\t\tsystype(ofname);\n\t}\n\tofw_intr_establish();\n\t\t\n\n\tfor (child = OF_child(ofp->phandle); child; child = OF_peer(child)) {\n\t\t/*\n\t\t * This is a hack to skip all the entries in the tree\n\t\t * that aren't devices (packages, openfirmware etc.).\n\t\t */\n\t\tif (OF_getprop(child, \"device_type\", name, sizeof name) < 0)\n\t\t\tcontinue;\n\t\tprobe.phandle = child;\n\t\tprobe.unit = 0;\n\t\tconfig_found(dev, &probe, ofbprint);\n\t}\n}",
    "includes": [
      "#include \"sd.h\"",
      "#include <dev/ofw/openfirm.h>",
      "#include <machine/autoconf.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void ofrattach",
      "static int ofbprint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "dev",
            "&probe",
            "ofbprint"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_getprop",
          "args": [
            "child",
            "\"device_type\"",
            "name",
            "sizeof name"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_peer",
          "args": [
            "child"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_child",
          "args": [
            "ofp->phandle"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ofw_intr_establish",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systype",
          "args": [
            "ofname"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_getprop",
          "args": [
            "ofp->phandle",
            "\"model\"",
            "ofname",
            "sizeof ofname - 1"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ofbprint",
          "args": [
            "ofp",
            "0"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "ofbprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofbus.c",
          "lines": "66-91",
          "snippet": "static int\nofbprint(aux, name)\n\tvoid *aux;\n\tconst char *name;\n{\n\tstruct ofprobe *ofp = aux;\n\tchar child[64];\n\tint l;\n\t\n\tif ((l = OF_getprop(ofp->phandle, \"name\", child, sizeof child - 1)) < 0)\n\t\tpanic(\"device without name?\");\n\tif (l >= sizeof child)\n\t\tl = sizeof child - 1;\n\tchild[l] = 0;\n\t\n\tif (name) {\n\t\t/* Dont print anything here, be quiet\n\t\tprintf(\"%s at %s\", child, name);\n\t\treturn UNCONF;\n\t\t*/\n\t\treturn QUIET;\n\t} else {\n\t\tprintf(\" (%s)\", child);\n\treturn QUIET;\n\t}\n}",
          "includes": [
            "#include \"sd.h\"",
            "#include <dev/ofw/openfirm.h>",
            "#include <machine/autoconf.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ofbprint"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sd.h\"\n#include <dev/ofw/openfirm.h>\n#include <machine/autoconf.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nstatic int ofbprint;\n\nstatic int\nofbprint(aux, name)\n\tvoid *aux;\n\tconst char *name;\n{\n\tstruct ofprobe *ofp = aux;\n\tchar child[64];\n\tint l;\n\t\n\tif ((l = OF_getprop(ofp->phandle, \"name\", child, sizeof child - 1)) < 0)\n\t\tpanic(\"device without name?\");\n\tif (l >= sizeof child)\n\t\tl = sizeof child - 1;\n\tchild[l] = 0;\n\t\n\tif (name) {\n\t\t/* Dont print anything here, be quiet\n\t\tprintf(\"%s at %s\", child, name);\n\t\treturn UNCONF;\n\t\t*/\n\t\treturn QUIET;\n\t} else {\n\t\tprintf(\" (%s)\", child);\n\treturn QUIET;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"No PROM root\""
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_peer",
          "args": [
            "0"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sd.h\"\n#include <dev/ofw/openfirm.h>\n#include <machine/autoconf.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid ofrattach;\nstatic int ofbprint;\n\nvoid\nofrattach(parent, dev, aux)\n\tstruct device *parent, *dev;\n\tvoid *aux;\n{\n\tint child;\n\tchar name[5];\n\tstruct ofprobe *ofp = aux;\n\tstruct ofprobe probe;\n\tint units;\n\tint node;\n\tchar ofname[64];\n\tint l;\n\t\n        if (!(node = OF_peer(0)))\n                panic(\"No PROM root\");\n        probe.phandle = node;\n\tofp = &probe;\n\n\tofbprint(ofp, 0);\n\tprintf(\"\\n\");\n\n\tif ((l = OF_getprop(ofp->phandle, \"model\", ofname, sizeof ofname - 1)) < 0)\n\t{\n\t\t/* no system name? */\n\t} else {\n\t\tif (l >= sizeof ofname)\n\t\t\tl = sizeof ofname - 1;\n\t\tofname[l] = 0;\n\t\tsystype(ofname);\n\t}\n\tofw_intr_establish();\n\t\t\n\n\tfor (child = OF_child(ofp->phandle); child; child = OF_peer(child)) {\n\t\t/*\n\t\t * This is a hack to skip all the entries in the tree\n\t\t * that aren't devices (packages, openfirmware etc.).\n\t\t */\n\t\tif (OF_getprop(child, \"device_type\", name, sizeof name) < 0)\n\t\t\tcontinue;\n\t\tprobe.phandle = child;\n\t\tprobe.unit = 0;\n\t\tconfig_found(dev, &probe, ofbprint);\n\t}\n}"
  },
  {
    "function_name": "ofrprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofbus.c",
    "lines": "93-105",
    "snippet": "int\nofrprobe(parent, cf, aux)\n\tstruct device *parent;\n\tvoid *cf, *aux;\n{\n\tint node;\n\tstruct confargs *ca = aux;\n\t\n\tif (strcmp(ca->ca_name, ofroot_cd.cd_name) != 0)\n\t\treturn (0);\n\n\treturn 1; \n}",
    "includes": [
      "#include \"sd.h\"",
      "#include <dev/ofw/openfirm.h>",
      "#include <machine/autoconf.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ofrprobe",
      "struct cfdriver ofroot_cd = {\n\tNULL, \"ofroot\", DV_DULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ca->ca_name",
            "ofroot_cd.cd_name"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sd.h\"\n#include <dev/ofw/openfirm.h>\n#include <machine/autoconf.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint ofrprobe;\nstruct cfdriver ofroot_cd = {\n\tNULL, \"ofroot\", DV_DULL\n};\n\nint\nofrprobe(parent, cf, aux)\n\tstruct device *parent;\n\tvoid *cf, *aux;\n{\n\tint node;\n\tstruct confargs *ca = aux;\n\t\n\tif (strcmp(ca->ca_name, ofroot_cd.cd_name) != 0)\n\t\treturn (0);\n\n\treturn 1; \n}"
  },
  {
    "function_name": "ofbprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofbus.c",
    "lines": "66-91",
    "snippet": "static int\nofbprint(aux, name)\n\tvoid *aux;\n\tconst char *name;\n{\n\tstruct ofprobe *ofp = aux;\n\tchar child[64];\n\tint l;\n\t\n\tif ((l = OF_getprop(ofp->phandle, \"name\", child, sizeof child - 1)) < 0)\n\t\tpanic(\"device without name?\");\n\tif (l >= sizeof child)\n\t\tl = sizeof child - 1;\n\tchild[l] = 0;\n\t\n\tif (name) {\n\t\t/* Dont print anything here, be quiet\n\t\tprintf(\"%s at %s\", child, name);\n\t\treturn UNCONF;\n\t\t*/\n\t\treturn QUIET;\n\t} else {\n\t\tprintf(\" (%s)\", child);\n\treturn QUIET;\n\t}\n}",
    "includes": [
      "#include \"sd.h\"",
      "#include <dev/ofw/openfirm.h>",
      "#include <machine/autoconf.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ofbprint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" (%s)\"",
            "child"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"device without name?\""
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_getprop",
          "args": [
            "ofp->phandle",
            "\"name\"",
            "child",
            "sizeof child - 1"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sd.h\"\n#include <dev/ofw/openfirm.h>\n#include <machine/autoconf.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nstatic int ofbprint;\n\nstatic int\nofbprint(aux, name)\n\tvoid *aux;\n\tconst char *name;\n{\n\tstruct ofprobe *ofp = aux;\n\tchar child[64];\n\tint l;\n\t\n\tif ((l = OF_getprop(ofp->phandle, \"name\", child, sizeof child - 1)) < 0)\n\t\tpanic(\"device without name?\");\n\tif (l >= sizeof child)\n\t\tl = sizeof child - 1;\n\tchild[l] = 0;\n\t\n\tif (name) {\n\t\t/* Dont print anything here, be quiet\n\t\tprintf(\"%s at %s\", child, name);\n\t\treturn UNCONF;\n\t\t*/\n\t\treturn QUIET;\n\t} else {\n\t\tprintf(\" (%s)\", child);\n\treturn QUIET;\n\t}\n}"
  }
]