[
  {
    "function_name": "dpt_eisa_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/dpt_eisa.c",
    "lines": "146-214",
    "snippet": "void\ndpt_eisa_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct eisa_attach_args *ea;\n\tbus_space_handle_t ioh;\n\teisa_chipset_tag_t ec;\n\teisa_intr_handle_t ih;\n\tstruct dpt_softc *sc;\n\tbus_space_tag_t iot;\n\tconst char *intrstr;\n\tint irq;\n\t\n\tea = aux;\n\tsc = (struct dpt_softc *)self;\n\tiot = ea->ea_iot;\n\tec = ea->ea_ec;\n\t\n\tprintf(\": \");\n\n\tif (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot) +\n\t    DPT_EISA_SLOT_OFFSET, DPT_EISA_IOSIZE, 0, &ioh)) {\n\t\tprintf(\"can't map i/o space\\n\");\n\t\treturn;\n\t}\n\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\tsc->sc_dmat = ea->ea_dmat;\n\n\t/* Map and establish the interrupt. */\n\tif (dpt_eisa_irq(iot, ioh, &irq)) {\n\t\tprintf(\"HBA on invalid IRQ (%d)\\n\", irq);\n\t\treturn;\n\t}\n\n\tif (eisa_intr_map(ec, irq, &ih)) {\n\t\tprintf(\"can't map interrupt (%d)\\n\", irq);\n\t\treturn;\n\t}\n\t\n\tintrstr = eisa_intr_string(ec, ih);\n#ifdef __NetBSD__\n\tsc->sc_ih = eisa_intr_establish(ec, ih, IST_LEVEL, IPL_BIO,\n\t    dpt_intr, sc);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tsc->sc_ih = eisa_intr_establish(ec, ih, IST_LEVEL, IPL_BIO,\n\t    dpt_intr, sc, sc->sc_dv.dv_xname);\n#endif /* __OpenBSD__ */\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"can't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\n\t/* Read the EATA configuration */\n\tif (dpt_readcfg(sc)) {\n\t\tprintf(\"%s: readcfg failed - see dpt(4)\\n\", \n\t\t    sc->sc_dv.dv_xname);\n\t\treturn;\t\n\t}\n\n\t/* Now attach to the bus-independant code */\n\tdpt_init(sc, intrstr);\n}",
    "includes": [
      "#include <dev/ic/dptvar.h>",
      "#include <dev/ic/dptreg.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define DPT_EISA_IOSIZE\t\t\t0x0100",
      "#define DPT_EISA_SLOT_OFFSET\t\t0x0c00"
    ],
    "globals_used": [
      "int\tdpt_eisa_irq",
      "void\tdpt_eisa_attach",
      "void *aux;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dpt_init",
          "args": [
            "sc",
            "intrstr"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "dpt_init_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
          "lines": "706-728",
          "snippet": "int\ndpt_init_ccb(sc, ccb)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n{\n\tint error;\n\t\n\t/* Create the DMA map for this CCB's data */\n\terror = bus_dmamap_create(sc->sc_dmat, DPT_MAX_XFER, DPT_SG_SIZE, \n\t    DPT_MAX_XFER, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t    &ccb->ccb_dmamap_xfer);\n\t\n\tif (error) {\n\t\tprintf(\"%s: can't create ccb dmamap (%d)\\n\", \n\t\t   sc->sc_dv.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\tccb->ccb_flg = 0;\n\tccb->ccb_ccbpa = sc->sc_dmamap_ccb->dm_segs[0].ds_addr +\n\t    CCB_OFF(sc, ccb);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/dptvar.h>",
            "#include <dev/ic/dptreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <machine/bus.h>",
            "#include <machine/bswap.h>",
            "#include <machine/endian.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
            "struct dpt_ccb *ccb;",
            "int s;",
            "struct dpt_softc *sc;",
            "struct dpt_ccb *ccb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nint s;\nstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\n\nint\ndpt_init_ccb(sc, ccb)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n{\n\tint error;\n\t\n\t/* Create the DMA map for this CCB's data */\n\terror = bus_dmamap_create(sc->sc_dmat, DPT_MAX_XFER, DPT_SG_SIZE, \n\t    DPT_MAX_XFER, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t    &ccb->ccb_dmamap_xfer);\n\t\n\tif (error) {\n\t\tprintf(\"%s: can't create ccb dmamap (%d)\\n\", \n\t\t   sc->sc_dv.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\tccb->ccb_flg = 0;\n\tccb->ccb_ccbpa = sc->sc_dmamap_ccb->dm_segs[0].ds_addr +\n\t    CCB_OFF(sc, ccb);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: readcfg failed - see dpt(4)\\n\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dpt_readcfg",
          "args": [
            "sc"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "dpt_readcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
          "lines": "563-668",
          "snippet": "int\ndpt_readcfg(sc)\n\tstruct dpt_softc *sc;\n{\n\tstruct eata_cfg *ec;\n\tint i, j, stat;\n\tu_int16_t *p;\n\n\tec = &sc->sc_ec;\n\n\t/* Older firmware may puke if we talk to it too soon after reset */\n\tdpt_outb(sc, HA_COMMAND, CP_RESET);\n        DELAY(750000);\n\n\tfor (i = 1000; i; i--) {\n\t\tif ((dpt_inb(sc, HA_STATUS) & HA_ST_READY) != 0)\n\t\t\tbreak;\n\t\tDELAY(2000);\n\t}\n\t\n\tif (i == 0) {\n\t\tprintf(\"%s: HBA not ready after reset: %02x\\n\", \n\t\t    sc->sc_dv.dv_xname, dpt_inb(sc, HA_STATUS));\n\t\treturn (-1);\n\t}\n\n\twhile((((stat = dpt_inb(sc, HA_STATUS))\n            != (HA_ST_READY|HA_ST_SEEK_COMPLETE))\n            && (stat != (HA_ST_READY|HA_ST_SEEK_COMPLETE|HA_ST_ERROR))\n            && (stat != (HA_ST_READY|HA_ST_SEEK_COMPLETE|HA_ST_ERROR|HA_ST_DRQ)))\n            || (dpt_wait(sc, HA_ST_BUSY, 0, 2000))) {\n        \t/* RAID drives still spinning up? */\n                if((dpt_inb(sc, HA_ERROR) != 'D')\n                    || (dpt_inb(sc, HA_ERROR + 1) != 'P')\n                    || (dpt_inb(sc, HA_ERROR + 2) != 'T')) {\n                    \tprintf(\"%s: HBA not ready\\n\", sc->sc_dv.dv_xname);\n                        return (-1);\n\t\t}\n        }\n\n\t/* \n\t * Issue the read-config command and wait for the data to appear.\n\t * XXX we shouldn't be doing this with PIO, but it makes it a lot\n\t * easier as no DMA setup is required.\n\t */\n\tdpt_outb(sc, HA_COMMAND, CP_PIO_GETCFG);\n\tmemset(ec, 0, sizeof(*ec));\n\ti = ((int)&((struct eata_cfg *)0)->ec_cfglen + \n\t    sizeof(ec->ec_cfglen)) >> 1;\n\tp = (u_int16_t *)ec;\n\t\n\tif (dpt_wait(sc, 0xFF, HA_ST_DATA_RDY, 2000)) {\n\t\tprintf(\"%s: cfg data didn't appear (status:%02x)\\n\", \n\t\t    sc->sc_dv.dv_xname, dpt_inb(sc, HA_STATUS));\n  \t\treturn (-1);\n  \t}\n\n\t/* Begin reading */\n \twhile (i--)\n\t\t*p++ = dpt_inw(sc, HA_DATA);\n\n        if ((i = ec->ec_cfglen) > (sizeof(struct eata_cfg)\n            - (int)(&(((struct eata_cfg *)0L)->ec_cfglen))\n            - sizeof(ec->ec_cfglen)))\n                i = sizeof(struct eata_cfg)\n                  - (int)(&(((struct eata_cfg *)0L)->ec_cfglen))\n                  - sizeof(ec->ec_cfglen);\n\n        j = i + (int)(&(((struct eata_cfg *)0L)->ec_cfglen)) + \n            sizeof(ec->ec_cfglen);\n        i >>= 1;\n\n\twhile (i--)\n                *p++ = dpt_inw(sc, HA_DATA);\n        \n        /* Flush until we have read 512 bytes. */\n        i = (512 - j + 1) >> 1;\n\twhile (i--)\n \t\tdpt_inw(sc, HA_DATA);\n        \n        /* Defaults for older Firmware */\n\tif (p <= (u_short *)&ec->ec_hba[DPT_MAX_CHANNELS - 1])\n\t\tec->ec_hba[DPT_MAX_CHANNELS - 1] = 7;\n\n        if ((dpt_inb(sc, HA_STATUS) & HA_ST_ERROR) != 0) {\n        \tprintf(\"%s: HBA error\\n\", sc->sc_dv.dv_xname);\n        \treturn (-1);\n        }\n        \n        if (!ec->ec_hbavalid) {\n                printf(\"%s: ec_hba field invalid\\n\", sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (memcmp(ec->ec_eatasig, \"EATA\", 4) != 0) {\n\t        printf(\"%s: EATA signature mismatch\\n\", sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (!ec->ec_dmasupported) {\n\t        printf(\"%s: DMA not supported\\n\", sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/dptvar.h>",
            "#include <dev/ic/dptreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <machine/bus.h>",
            "#include <machine/bswap.h>",
            "#include <machine/endian.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
            "int s;",
            "struct dpt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nint s;\nstruct dpt_softc *sc;\n\nint\ndpt_readcfg(sc)\n\tstruct dpt_softc *sc;\n{\n\tstruct eata_cfg *ec;\n\tint i, j, stat;\n\tu_int16_t *p;\n\n\tec = &sc->sc_ec;\n\n\t/* Older firmware may puke if we talk to it too soon after reset */\n\tdpt_outb(sc, HA_COMMAND, CP_RESET);\n        DELAY(750000);\n\n\tfor (i = 1000; i; i--) {\n\t\tif ((dpt_inb(sc, HA_STATUS) & HA_ST_READY) != 0)\n\t\t\tbreak;\n\t\tDELAY(2000);\n\t}\n\t\n\tif (i == 0) {\n\t\tprintf(\"%s: HBA not ready after reset: %02x\\n\", \n\t\t    sc->sc_dv.dv_xname, dpt_inb(sc, HA_STATUS));\n\t\treturn (-1);\n\t}\n\n\twhile((((stat = dpt_inb(sc, HA_STATUS))\n            != (HA_ST_READY|HA_ST_SEEK_COMPLETE))\n            && (stat != (HA_ST_READY|HA_ST_SEEK_COMPLETE|HA_ST_ERROR))\n            && (stat != (HA_ST_READY|HA_ST_SEEK_COMPLETE|HA_ST_ERROR|HA_ST_DRQ)))\n            || (dpt_wait(sc, HA_ST_BUSY, 0, 2000))) {\n        \t/* RAID drives still spinning up? */\n                if((dpt_inb(sc, HA_ERROR) != 'D')\n                    || (dpt_inb(sc, HA_ERROR + 1) != 'P')\n                    || (dpt_inb(sc, HA_ERROR + 2) != 'T')) {\n                    \tprintf(\"%s: HBA not ready\\n\", sc->sc_dv.dv_xname);\n                        return (-1);\n\t\t}\n        }\n\n\t/* \n\t * Issue the read-config command and wait for the data to appear.\n\t * XXX we shouldn't be doing this with PIO, but it makes it a lot\n\t * easier as no DMA setup is required.\n\t */\n\tdpt_outb(sc, HA_COMMAND, CP_PIO_GETCFG);\n\tmemset(ec, 0, sizeof(*ec));\n\ti = ((int)&((struct eata_cfg *)0)->ec_cfglen + \n\t    sizeof(ec->ec_cfglen)) >> 1;\n\tp = (u_int16_t *)ec;\n\t\n\tif (dpt_wait(sc, 0xFF, HA_ST_DATA_RDY, 2000)) {\n\t\tprintf(\"%s: cfg data didn't appear (status:%02x)\\n\", \n\t\t    sc->sc_dv.dv_xname, dpt_inb(sc, HA_STATUS));\n  \t\treturn (-1);\n  \t}\n\n\t/* Begin reading */\n \twhile (i--)\n\t\t*p++ = dpt_inw(sc, HA_DATA);\n\n        if ((i = ec->ec_cfglen) > (sizeof(struct eata_cfg)\n            - (int)(&(((struct eata_cfg *)0L)->ec_cfglen))\n            - sizeof(ec->ec_cfglen)))\n                i = sizeof(struct eata_cfg)\n                  - (int)(&(((struct eata_cfg *)0L)->ec_cfglen))\n                  - sizeof(ec->ec_cfglen);\n\n        j = i + (int)(&(((struct eata_cfg *)0L)->ec_cfglen)) + \n            sizeof(ec->ec_cfglen);\n        i >>= 1;\n\n\twhile (i--)\n                *p++ = dpt_inw(sc, HA_DATA);\n        \n        /* Flush until we have read 512 bytes. */\n        i = (512 - j + 1) >> 1;\n\twhile (i--)\n \t\tdpt_inw(sc, HA_DATA);\n        \n        /* Defaults for older Firmware */\n\tif (p <= (u_short *)&ec->ec_hba[DPT_MAX_CHANNELS - 1])\n\t\tec->ec_hba[DPT_MAX_CHANNELS - 1] = 7;\n\n        if ((dpt_inb(sc, HA_STATUS) & HA_ST_ERROR) != 0) {\n        \tprintf(\"%s: HBA error\\n\", sc->sc_dv.dv_xname);\n        \treturn (-1);\n        }\n        \n        if (!ec->ec_hbavalid) {\n                printf(\"%s: ec_hba field invalid\\n\", sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (memcmp(ec->ec_eatasig, \"EATA\", 4) != 0) {\n\t        printf(\"%s: EATA signature mismatch\\n\", sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (!ec->ec_dmasupported) {\n\t        printf(\"%s: DMA not supported\\n\", sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eisa_intr_establish",
          "args": [
            "ec",
            "ih",
            "IST_LEVEL",
            "IPL_BIO",
            "dpt_intr",
            "sc",
            "sc->sc_dv.dv_xname"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eisa_intr_establish",
          "args": [
            "ec",
            "ih",
            "IST_LEVEL",
            "IPL_BIO",
            "dpt_intr",
            "sc"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eisa_intr_string",
          "args": [
            "ec",
            "ih"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eisa_intr_map",
          "args": [
            "ec",
            "irq",
            "&ih"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_eisa_irq",
          "args": [
            "iot",
            "ioh",
            "&irq"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "dpt_eisa_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/dpt_eisa.c",
          "lines": "99-121",
          "snippet": "int\ndpt_eisa_irq(iot, ioh, irq)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint *irq;\n{\n\n\tswitch (bus_space_read_1(iot, ioh, DPT_EISA_IOCONF) & 0x38) {\n\tcase 0x08:\n\t\t*irq = 11;\n\t\tbreak;\n\tcase 0x10:\n\t\t*irq = 15;\n\t\tbreak;\n\tcase 0x20:\n\t\t*irq = 14;\n\t\tbreak;\n\tdefault:\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/dptvar.h>",
            "#include <dev/ic/dptreg.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define DPT_EISA_IOCONF\t\t\t0x90"
          ],
          "globals_used": [
            "int\tdpt_eisa_irq"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/cdefs.h>\n\n#define DPT_EISA_IOCONF\t\t\t0x90\n\nint\tdpt_eisa_irq;\n\nint\ndpt_eisa_irq(iot, ioh, irq)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint *irq;\n{\n\n\tswitch (bus_space_read_1(iot, ioh, DPT_EISA_IOCONF) & 0x38) {\n\tcase 0x08:\n\t\t*irq = 11;\n\t\tbreak;\n\tcase 0x10:\n\t\t*irq = 15;\n\t\tbreak;\n\tcase 0x20:\n\t\t*irq = 14;\n\t\tbreak;\n\tdefault:\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "EISA_SLOT_ADDR(ea->ea_slot) +\n\t    DPT_EISA_SLOT_OFFSET",
            "DPT_EISA_IOSIZE",
            "0",
            "&ioh"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EISA_SLOT_ADDR",
          "args": [
            "ea->ea_slot"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/cdefs.h>\n\n#define DPT_EISA_IOSIZE\t\t\t0x0100\n#define DPT_EISA_SLOT_OFFSET\t\t0x0c00\n\nint\tdpt_eisa_irq;\nvoid\tdpt_eisa_attach;\nvoid *aux;\n\nvoid\ndpt_eisa_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct eisa_attach_args *ea;\n\tbus_space_handle_t ioh;\n\teisa_chipset_tag_t ec;\n\teisa_intr_handle_t ih;\n\tstruct dpt_softc *sc;\n\tbus_space_tag_t iot;\n\tconst char *intrstr;\n\tint irq;\n\t\n\tea = aux;\n\tsc = (struct dpt_softc *)self;\n\tiot = ea->ea_iot;\n\tec = ea->ea_ec;\n\t\n\tprintf(\": \");\n\n\tif (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot) +\n\t    DPT_EISA_SLOT_OFFSET, DPT_EISA_IOSIZE, 0, &ioh)) {\n\t\tprintf(\"can't map i/o space\\n\");\n\t\treturn;\n\t}\n\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\tsc->sc_dmat = ea->ea_dmat;\n\n\t/* Map and establish the interrupt. */\n\tif (dpt_eisa_irq(iot, ioh, &irq)) {\n\t\tprintf(\"HBA on invalid IRQ (%d)\\n\", irq);\n\t\treturn;\n\t}\n\n\tif (eisa_intr_map(ec, irq, &ih)) {\n\t\tprintf(\"can't map interrupt (%d)\\n\", irq);\n\t\treturn;\n\t}\n\t\n\tintrstr = eisa_intr_string(ec, ih);\n#ifdef __NetBSD__\n\tsc->sc_ih = eisa_intr_establish(ec, ih, IST_LEVEL, IPL_BIO,\n\t    dpt_intr, sc);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tsc->sc_ih = eisa_intr_establish(ec, ih, IST_LEVEL, IPL_BIO,\n\t    dpt_intr, sc, sc->sc_dv.dv_xname);\n#endif /* __OpenBSD__ */\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"can't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\n\t/* Read the EATA configuration */\n\tif (dpt_readcfg(sc)) {\n\t\tprintf(\"%s: readcfg failed - see dpt(4)\\n\", \n\t\t    sc->sc_dv.dv_xname);\n\t\treturn;\t\n\t}\n\n\t/* Now attach to the bus-independant code */\n\tdpt_init(sc, intrstr);\n}"
  },
  {
    "function_name": "dpt_eisa_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/dpt_eisa.c",
    "lines": "99-121",
    "snippet": "int\ndpt_eisa_irq(iot, ioh, irq)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint *irq;\n{\n\n\tswitch (bus_space_read_1(iot, ioh, DPT_EISA_IOCONF) & 0x38) {\n\tcase 0x08:\n\t\t*irq = 11;\n\t\tbreak;\n\tcase 0x10:\n\t\t*irq = 15;\n\t\tbreak;\n\tcase 0x20:\n\t\t*irq = 14;\n\t\tbreak;\n\tdefault:\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/dptvar.h>",
      "#include <dev/ic/dptreg.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define DPT_EISA_IOCONF\t\t\t0x90"
    ],
    "globals_used": [
      "int\tdpt_eisa_irq"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "DPT_EISA_IOCONF"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/cdefs.h>\n\n#define DPT_EISA_IOCONF\t\t\t0x90\n\nint\tdpt_eisa_irq;\n\nint\ndpt_eisa_irq(iot, ioh, irq)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint *irq;\n{\n\n\tswitch (bus_space_read_1(iot, ioh, DPT_EISA_IOCONF) & 0x38) {\n\tcase 0x08:\n\t\t*irq = 11;\n\t\tbreak;\n\tcase 0x10:\n\t\t*irq = 15;\n\t\tbreak;\n\tcase 0x20:\n\t\t*irq = 14;\n\t\tbreak;\n\tdefault:\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
  }
]