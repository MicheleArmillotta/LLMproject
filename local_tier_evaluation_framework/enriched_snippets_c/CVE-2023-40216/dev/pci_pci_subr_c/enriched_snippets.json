[
  {
    "function_name": "pci_devinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_subr.c",
    "lines": "215-306",
    "snippet": "void\npci_devinfo(id_reg, class_reg, showclass, cp)\n\tpcireg_t id_reg, class_reg;\n\tint showclass;\n\tchar *cp;\n{\n\tpci_vendor_id_t vendor;\n\tpci_product_id_t product;\n\tpci_class_t class;\n\tpci_subclass_t subclass;\n\tpci_interface_t interface;\n\tpci_revision_t revision;\n\tchar *vendor_namep, *product_namep;\n\tstruct pci_class *classp, *subclassp;\n#ifdef PCIVERBOSE\n\tstruct pci_knowndev *kdp;\n\tconst char *unmatched = \"unknown \";\n#else\n\tconst char *unmatched = \"\";\n#endif\n\n\tvendor = PCI_VENDOR(id_reg);\n\tproduct = PCI_PRODUCT(id_reg);\n\n\tclass = PCI_CLASS(class_reg);\n\tsubclass = PCI_SUBCLASS(class_reg);\n\tinterface = PCI_INTERFACE(class_reg);\n\trevision = PCI_REVISION(class_reg);\n\n#ifdef PCIVERBOSE\n\tkdp = pci_knowndevs;\n        while (kdp->vendorname != NULL) {\t/* all have vendor name */\n                if (kdp->vendor == vendor && (kdp->product == product ||\n\t\t    (kdp->flags & PCI_KNOWNDEV_NOPROD) != 0))\n                        break;\n\t\tkdp++;\n\t}\n        if (kdp->vendorname == NULL)\n\t\tvendor_namep = product_namep = NULL;\n\telse {\n\t\tvendor_namep = kdp->vendorname;\n\t\tproduct_namep = (kdp->flags & PCI_KNOWNDEV_NOPROD) == 0 ?\n\t\t    kdp->productname : NULL;\n        }\n#else /* PCIVERBOSE */\n\tvendor_namep = product_namep = NULL;\n#endif /* PCIVERBOSE */\n\n\tclassp = pci_class;\n\twhile (classp->name != NULL) {\n\t\tif (class == classp->val)\n\t\t\tbreak;\n\t\tclassp++;\n\t}\n\n\tsubclassp = (classp->name != NULL) ? classp->subclasses : NULL;\n\twhile (subclassp && subclassp->name != NULL) {\n\t\tif (subclass == subclassp->val)\n\t\t\tbreak;\n\t\tsubclassp++;\n\t}\n\n\tif (vendor_namep == NULL)\n\t\tcp += sprintf(cp, \"%svendor 0x%04x product 0x%04x\",\n\t\t    unmatched, vendor, product);\n\telse if (product_namep != NULL)\n\t\tcp += sprintf(cp, \"\\\"%s %s\\\"\", vendor_namep, product_namep);\n\telse\n\t\tcp += sprintf(cp, \"vendor \\\"%s\\\", unknown product 0x%x\",\n\t\t    vendor_namep, product);\n\tif (showclass && product_namep == NULL) {\n\t\tcp += sprintf(cp, \" (\");\n\t\tif (classp->name == NULL)\n\t\t\tcp += sprintf(cp,\n\t\t\t    \"unknown class 0x%2x, subclass 0x%02x\",\n\t\t\t    class, subclass);\n\t\telse {\n\t\t\tcp += sprintf(cp, \"class %s, \", classp->name);\n\t\t\tif (subclassp == NULL || subclassp->name == NULL)\n\t\t\t\tcp += sprintf(cp, \"unknown subclass 0x%02x\",\n\t\t\t\t    subclass);\n\t\t\telse\n\t\t\t\tcp += sprintf(cp, \"subclass %s\",\n\t\t\t\t    subclassp->name);\n\t\t}\n#if 0 /* not very useful */\n\t\tcp += sprintf(cp, \", interface 0x%02x\", interface);\n#endif\n\t\tcp += sprintf(cp, \", rev 0x%02x)\", revision);\n\t} else\n\t\tcp += sprintf(cp, \" rev 0x%02x\", revision);\n}",
    "includes": [
      "#include <dev/pci/pcidevs_data.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tPCI_KNOWNDEV_NOPROD\t0x01\t\t/* match on vendor only */"
    ],
    "globals_used": [
      "struct pci_class pci_class[] = {\n\t{ \"prehistoric\",\tPCI_CLASS_PREHISTORIC,\n\t    pci_subclass_prehistoric,\t\t\t\t},\n\t{ \"mass storage\",\tPCI_CLASS_MASS_STORAGE,\n\t    pci_subclass_mass_storage,\t\t\t\t},\n\t{ \"network\",\t\tPCI_CLASS_NETWORK,\n\t    pci_subclass_network,\t\t\t\t},\n\t{ \"display\",\t\tPCI_CLASS_DISPLAY,\n\t    pci_subclass_display,\t\t\t\t},\n\t{ \"multimedia\",\t\tPCI_CLASS_MULTIMEDIA,\n\t    pci_subclass_multimedia,\t\t\t\t},\n\t{ \"memory\",\t\tPCI_CLASS_MEMORY,\n\t    pci_subclass_memory,\t\t\t\t},\n\t{ \"bridge\",\t\tPCI_CLASS_BRIDGE,\n\t    pci_subclass_bridge,\t\t\t\t},\n\t{ \"communications\",\tPCI_CLASS_COMMUNICATIONS,\n\t    pci_subclass_communications,\t\t\t},\n\t{ \"system\",\t\tPCI_CLASS_SYSTEM,\n\t    pci_subclass_system,\t\t\t\t},\n\t{ \"input\",\t\tPCI_CLASS_INPUT,\n\t    pci_subclass_input,\t\t\t\t\t},\n\t{ \"dock\",\t\tPCI_CLASS_DOCK,\n\t    pci_subclass_dock,\t\t\t\t\t},\n\t{ \"processor\",\t\tPCI_CLASS_PROCESSOR,\n\t    pci_subclass_processor,\t\t\t\t},\n\t{ \"serial bus\",\t\tPCI_CLASS_SERIALBUS,\n\t    pci_subclass_serialbus,\t\t\t\t},\n\t{ \"undefined\",\t\tPCI_CLASS_UNDEFINED,\n\t    0,\t\t\t\t\t\t\t},\n\t{ 0 },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\" rev 0x%02x\"",
            "revision"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\", rev 0x%02x)\"",
            "revision"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\", interface 0x%02x\"",
            "interface"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\"subclass %s\"",
            "subclassp->name"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\"unknown subclass 0x%02x\"",
            "subclass"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\"class %s, \"",
            "classp->name"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\"unknown class 0x%2x, subclass 0x%02x\"",
            "class",
            "subclass"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\" (\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\"vendor \\\"%s\\\", unknown product 0x%x\"",
            "vendor_namep",
            "product"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\"\\\"%s %s\\\"\"",
            "vendor_namep",
            "product_namep"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\"%svendor 0x%04x product 0x%04x\"",
            "unmatched",
            "vendor",
            "product"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_REVISION",
          "args": [
            "class_reg"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_INTERFACE",
          "args": [
            "class_reg"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_SUBCLASS",
          "args": [
            "class_reg"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CLASS",
          "args": [
            "class_reg"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "id_reg"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "id_reg"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs_data.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tPCI_KNOWNDEV_NOPROD\t0x01\t\t/* match on vendor only */\n\nstruct pci_class pci_class[] = {\n\t{ \"prehistoric\",\tPCI_CLASS_PREHISTORIC,\n\t    pci_subclass_prehistoric,\t\t\t\t},\n\t{ \"mass storage\",\tPCI_CLASS_MASS_STORAGE,\n\t    pci_subclass_mass_storage,\t\t\t\t},\n\t{ \"network\",\t\tPCI_CLASS_NETWORK,\n\t    pci_subclass_network,\t\t\t\t},\n\t{ \"display\",\t\tPCI_CLASS_DISPLAY,\n\t    pci_subclass_display,\t\t\t\t},\n\t{ \"multimedia\",\t\tPCI_CLASS_MULTIMEDIA,\n\t    pci_subclass_multimedia,\t\t\t\t},\n\t{ \"memory\",\t\tPCI_CLASS_MEMORY,\n\t    pci_subclass_memory,\t\t\t\t},\n\t{ \"bridge\",\t\tPCI_CLASS_BRIDGE,\n\t    pci_subclass_bridge,\t\t\t\t},\n\t{ \"communications\",\tPCI_CLASS_COMMUNICATIONS,\n\t    pci_subclass_communications,\t\t\t},\n\t{ \"system\",\t\tPCI_CLASS_SYSTEM,\n\t    pci_subclass_system,\t\t\t\t},\n\t{ \"input\",\t\tPCI_CLASS_INPUT,\n\t    pci_subclass_input,\t\t\t\t\t},\n\t{ \"dock\",\t\tPCI_CLASS_DOCK,\n\t    pci_subclass_dock,\t\t\t\t\t},\n\t{ \"processor\",\t\tPCI_CLASS_PROCESSOR,\n\t    pci_subclass_processor,\t\t\t\t},\n\t{ \"serial bus\",\t\tPCI_CLASS_SERIALBUS,\n\t    pci_subclass_serialbus,\t\t\t\t},\n\t{ \"undefined\",\t\tPCI_CLASS_UNDEFINED,\n\t    0,\t\t\t\t\t\t\t},\n\t{ 0 },\n};\n\nvoid\npci_devinfo(id_reg, class_reg, showclass, cp)\n\tpcireg_t id_reg, class_reg;\n\tint showclass;\n\tchar *cp;\n{\n\tpci_vendor_id_t vendor;\n\tpci_product_id_t product;\n\tpci_class_t class;\n\tpci_subclass_t subclass;\n\tpci_interface_t interface;\n\tpci_revision_t revision;\n\tchar *vendor_namep, *product_namep;\n\tstruct pci_class *classp, *subclassp;\n#ifdef PCIVERBOSE\n\tstruct pci_knowndev *kdp;\n\tconst char *unmatched = \"unknown \";\n#else\n\tconst char *unmatched = \"\";\n#endif\n\n\tvendor = PCI_VENDOR(id_reg);\n\tproduct = PCI_PRODUCT(id_reg);\n\n\tclass = PCI_CLASS(class_reg);\n\tsubclass = PCI_SUBCLASS(class_reg);\n\tinterface = PCI_INTERFACE(class_reg);\n\trevision = PCI_REVISION(class_reg);\n\n#ifdef PCIVERBOSE\n\tkdp = pci_knowndevs;\n        while (kdp->vendorname != NULL) {\t/* all have vendor name */\n                if (kdp->vendor == vendor && (kdp->product == product ||\n\t\t    (kdp->flags & PCI_KNOWNDEV_NOPROD) != 0))\n                        break;\n\t\tkdp++;\n\t}\n        if (kdp->vendorname == NULL)\n\t\tvendor_namep = product_namep = NULL;\n\telse {\n\t\tvendor_namep = kdp->vendorname;\n\t\tproduct_namep = (kdp->flags & PCI_KNOWNDEV_NOPROD) == 0 ?\n\t\t    kdp->productname : NULL;\n        }\n#else /* PCIVERBOSE */\n\tvendor_namep = product_namep = NULL;\n#endif /* PCIVERBOSE */\n\n\tclassp = pci_class;\n\twhile (classp->name != NULL) {\n\t\tif (class == classp->val)\n\t\t\tbreak;\n\t\tclassp++;\n\t}\n\n\tsubclassp = (classp->name != NULL) ? classp->subclasses : NULL;\n\twhile (subclassp && subclassp->name != NULL) {\n\t\tif (subclass == subclassp->val)\n\t\t\tbreak;\n\t\tsubclassp++;\n\t}\n\n\tif (vendor_namep == NULL)\n\t\tcp += sprintf(cp, \"%svendor 0x%04x product 0x%04x\",\n\t\t    unmatched, vendor, product);\n\telse if (product_namep != NULL)\n\t\tcp += sprintf(cp, \"\\\"%s %s\\\"\", vendor_namep, product_namep);\n\telse\n\t\tcp += sprintf(cp, \"vendor \\\"%s\\\", unknown product 0x%x\",\n\t\t    vendor_namep, product);\n\tif (showclass && product_namep == NULL) {\n\t\tcp += sprintf(cp, \" (\");\n\t\tif (classp->name == NULL)\n\t\t\tcp += sprintf(cp,\n\t\t\t    \"unknown class 0x%2x, subclass 0x%02x\",\n\t\t\t    class, subclass);\n\t\telse {\n\t\t\tcp += sprintf(cp, \"class %s, \", classp->name);\n\t\t\tif (subclassp == NULL || subclassp->name == NULL)\n\t\t\t\tcp += sprintf(cp, \"unknown subclass 0x%02x\",\n\t\t\t\t    subclass);\n\t\t\telse\n\t\t\t\tcp += sprintf(cp, \"subclass %s\",\n\t\t\t\t    subclassp->name);\n\t\t}\n#if 0 /* not very useful */\n\t\tcp += sprintf(cp, \", interface 0x%02x\", interface);\n#endif\n\t\tcp += sprintf(cp, \", rev 0x%02x)\", revision);\n\t} else\n\t\tcp += sprintf(cp, \" rev 0x%02x\", revision);\n}"
  }
]