[
  {
    "function_name": "rln_crypt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "1185-1231",
    "snippet": "void\nrln_crypt(userkey, cardkey)\n\tchar *userkey;\t\t/* User's string (max 20 chars). */\n\tu_int8_t *cardkey;\t/* 20 bits (3 bytes) */\n{\n\t/*\n\t * From <http://www.proxim.com/learn/whiteppr/rl2security.shtml> \n\t * \"RangeLAN2 Security Features\":\n\t *\n         *  The Security ID is a unique, 20 character alphanumeric\n         *  string defined and configured by the user. It must be\n         *  identically configured in every radio intended to\n         *  communicate with others in the same network. Once\n         *  configured, the Security ID is reduced to 20 bits by a\n         *  proprietary algorithm confidential to Proxim. It is\n         *  merged with the radio MAC address (a 12 character field\n         *  unique to every radio), scrambled and stored using another\n         *  proprietary, confidential algorithm.\n\t */\n        int32_t key;\n        int8_t ret;\n        int i;\n\tint len;\n\tint32_t multiplicand = 0x80000181;\n\tint64_t res;\n\n\t/* \n\t * This algorithm is `compatible' with Proxim's first\n\t * `proprietary confidential algorithm': i.e., it appears\n\t * to be functionally identical.\n\t */\n\tlen = strlen(s);\n        key = 0x030201;\n        for (i = 0; i < len; i++) {\n\n                key *= userkey[i];\n                res = (int64_t)multiplicand * key;\n                key = key - 0xfffffd * \n\t\t    (((key + (int32_t)(res >> 32)) >> 23) - (key >> 31));\n        }\n\n        cardkey[0] = (key >> 16) & 0xff;\n        cardkey[1] = (key >> 8) & 0xff;\n        cardkey[2] = key & 0xff;\n\n\tcardkey[0] |= 0x03; \t/* Restrict key space by 2 bits. */\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\nrln_crypt(userkey, cardkey)\n\tchar *userkey;\t\t/* User's string (max 20 chars). */\n\tu_int8_t *cardkey;\t/* 20 bits (3 bytes) */\n{\n\t/*\n\t * From <http://www.proxim.com/learn/whiteppr/rl2security.shtml> \n\t * \"RangeLAN2 Security Features\":\n\t *\n         *  The Security ID is a unique, 20 character alphanumeric\n         *  string defined and configured by the user. It must be\n         *  identically configured in every radio intended to\n         *  communicate with others in the same network. Once\n         *  configured, the Security ID is reduced to 20 bits by a\n         *  proprietary algorithm confidential to Proxim. It is\n         *  merged with the radio MAC address (a 12 character field\n         *  unique to every radio), scrambled and stored using another\n         *  proprietary, confidential algorithm.\n\t */\n        int32_t key;\n        int8_t ret;\n        int i;\n\tint len;\n\tint32_t multiplicand = 0x80000181;\n\tint64_t res;\n\n\t/* \n\t * This algorithm is `compatible' with Proxim's first\n\t * `proprietary confidential algorithm': i.e., it appears\n\t * to be functionally identical.\n\t */\n\tlen = strlen(s);\n        key = 0x030201;\n        for (i = 0; i < len; i++) {\n\n                key *= userkey[i];\n                res = (int64_t)multiplicand * key;\n                key = key - 0xfffffd * \n\t\t    (((key + (int32_t)(res >> 32)) >> 23) - (key >> 31));\n        }\n\n        cardkey[0] = (key >> 16) & 0xff;\n        cardkey[1] = (key >> 8) & 0xff;\n        cardkey[2] = key & 0xff;\n\n\tcardkey[0] |= 0x03; \t/* Restrict key space by 2 bits. */\n}"
  },
  {
    "function_name": "rln_standby",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "1174-1183",
    "snippet": "int\nrln_standby(sc)\n\tstruct rln_softc * sc;\n{\n\tstruct rln_mm_standby standby = { RLN_MM_STANDBY };\n\n\tstandby.xxx = 0;\n\tif (rln_msg_txrx(sc, &ito, sizeof ito, NULL, 0))\n\t\treturn (-1);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rln_msg_txrx",
          "args": [
            "sc",
            "&ito",
            "sizeof ito",
            "NULL",
            "0"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "rln_msg_txrx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "686-774",
          "snippet": "int\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_standby(sc)\n\tstruct rln_softc * sc;\n{\n\tstruct rln_mm_standby standby = { RLN_MM_STANDBY };\n\n\tstandby.xxx = 0;\n\tif (rln_msg_txrx(sc, &ito, sizeof ito, NULL, 0))\n\t\treturn (-1);\n}"
  },
  {
    "function_name": "rln_ito",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "1155-1171",
    "snippet": "int\nrln_ito(sc)\n\tstruct rln_softc * sc;\n{\n\tstruct rln_mm_setito ito = { RLN_MM_MULTICAST };\n\tstruct rln_mm_cmd response;\n\n\tito.xxx = 3;\n\tito.timeout = LLDInactivityTimeOut /* enabler, 0 or 1 */;\n\tito.bd_wakeup = LLDBDWakeup /* 0 */;\n\tito.pm_sync = LLDPMSync /* 0 */;\n\tito.sniff_time = ito.timeout ? LLDSniffTime /* 0 */ : 0;\n\n\tif (rln_msg_txrx(sc, &ito, sizeof ito,\n\t    &response, sizeof response))\n\t\treturn (-1);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rln_msg_txrx",
          "args": [
            "sc",
            "&ito",
            "sizeof ito",
            "&response",
            "sizeof response"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "rln_msg_txrx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "686-774",
          "snippet": "int\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_ito(sc)\n\tstruct rln_softc * sc;\n{\n\tstruct rln_mm_setito ito = { RLN_MM_MULTICAST };\n\tstruct rln_mm_cmd response;\n\n\tito.xxx = 3;\n\tito.timeout = LLDInactivityTimeOut /* enabler, 0 or 1 */;\n\tito.bd_wakeup = LLDBDWakeup /* 0 */;\n\tito.pm_sync = LLDPMSync /* 0 */;\n\tito.sniff_time = ito.timeout ? LLDSniffTime /* 0 */ : 0;\n\n\tif (rln_msg_txrx(sc, &ito, sizeof ito,\n\t    &response, sizeof response))\n\t\treturn (-1);\n}"
  },
  {
    "function_name": "rln_lockprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "1142-1152",
    "snippet": "int\nrln_lockprom(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct rln_mm_cmd lock = RLN_MM_EEPROM_PROTECT;\n\tstruct rln_mm_cmd response;\n\n\t/* XXX Always yields an error? */\n\treturn (rln_msg_txrx(sc, &lock, sizeof lock,\n\t    &response, sizeof response));\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rln_msg_txrx",
          "args": [
            "sc",
            "&lock",
            "sizeof lock",
            "&response",
            "sizeof response"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "rln_msg_txrx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "686-774",
          "snippet": "int\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_lockprom(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct rln_mm_cmd lock = RLN_MM_EEPROM_PROTECT;\n\tstruct rln_mm_cmd response;\n\n\t/* XXX Always yields an error? */\n\treturn (rln_msg_txrx(sc, &lock, sizeof lock,\n\t    &response, sizeof response));\n}"
  },
  {
    "function_name": "rln_iosetparam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "1115-1139",
    "snippet": "int\nrln_iosetparam(sc, param)\n\tstruct rln_softc *sc;\n\tstruct rln_param *param;\n{\n\tint error = 0;\n\n\tif (param->rp_roam_config > 2)\n\t\terror = EINVAL;\n\tif (param->rp_security > 0x00ffffff)\n\t\terror = EINVAL;\n\tif (param->rp_station_type > 2)\n\t\terror = EINVAL;\n\tif (param->rp_channel > 15)\n\t\terror = EINVAL;\n\tif (param->rp_subchannel > 15)\n\t\terror = EINVAL;\n\tif (error == 0) {\n\t\t/* Apply immediately. */\n\t\tbcopy(param, &sc->sc_param, sizeof *param);\n\t\tif (rln_sendinit(sc))\n\t\t\terror = EIO;\n\t}\n\treturn (error);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\trln_sendinit",
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rln_sendinit",
          "args": [
            "sc"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "rln_sendinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
          "lines": "958-1026",
          "snippet": "int\nrln_sendinit(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct rln_mm_init init = { RLN_MM_INIT };\n\tstruct rln_mm_initted iresponse;\n#if 0\n\tstruct rln_mm_setmagic magic = { RLN_MM_SETMAGIC };\n\tstruct rln_mm_disablehopping hop = { RLN_MM_DISABLEHOPPING };\n\tstruct rln_mm_cmd response;\n#endif\n\n\tbzero((char*)&init + sizeof init.mm_cmd,\n\t\tsizeof init - sizeof init.mm_cmd);\n\n\tdprintf(\" [setting parameters]\");\n\tinit.opmode = (sc->sc_state & RLN_STATE_PROMISC ?\n\t    RLN_MM_INIT_OPMODE_PROMISC : RLN_MM_INIT_OPMODE_NORMAL);\n\tinit.stationtype = sc->sc_param.rp_station_type;\n\n\t/* Spread-spectrum frequency hopping. */\n\tinit.hop_period = 1;\n\tinit.bfreq = 2;\n\tinit.sfreq = 7;\n\n\t/* Choose channel. */\n\tinit.channel = sc->sc_param.rp_channel;\n\tinit.subchannel = sc->sc_param.rp_subchannel;\n\tinit.domain = sc->sc_param.rp_domain;\n\n\t/* Name of this station when acting as master. */\n\tbcopy(sc->sc_param.rp_master, init.mastername, sizeof init.mastername);\n\n\t/* Security params. */\n\tinit.sec1 = (sc->sc_param.rp_security & 0x0000ff) >> 0;\n\tinit.sec2 = (sc->sc_param.rp_security & 0x00ff00) >> 8;\n\tinit.sec3 = (sc->sc_param.rp_security & 0xff0000) >> 16;\n\n\tinit.sync_to = 1;\n\tbzero(init.syncname, sizeof init.syncname);\n\n\tif (rln_msg_txrx(sc, &init, sizeof init,\n\t    &iresponse, sizeof iresponse))\n\t\treturn (-1);\n#if 0\n\tdprintf(\" [setting magic]\");\n\tmagic.fairness_slot = 3;\t/* lite: 1, norm: 3, off: -1 */\n\tmagic.deferral_slot = 3;\t/* lite: 0, norm: 3, off: -1 */\n\tmagic.regular_mac_retry = 7;\n\tmagic.frag_mac_retry = 10;\n\tmagic.regular_mac_qfsk = 2;\n\tmagic.frag_mac_qfsk = 5;\n\tmagic.xxx1 = 0xff;\n\tmagic.xxx2 = 0xff;\n\tmagic.xxx3 = 0xff;\n\tmagic.xxx4 = 0x00;\n\tif (rln_msg_txrx(sc, &magic, sizeof magic,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\n\tdprintf(\" [disabling freq hopping]\");\n\thop.hopflag = RLN_MM_DISABLEHOPPING_HOPFLAG_DISABLE;\n\tif (rln_msg_txrx(sc, &hop, sizeof hop,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\n#endif\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\trln_sendinit",
            "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\trln_sendinit;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_sendinit(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct rln_mm_init init = { RLN_MM_INIT };\n\tstruct rln_mm_initted iresponse;\n#if 0\n\tstruct rln_mm_setmagic magic = { RLN_MM_SETMAGIC };\n\tstruct rln_mm_disablehopping hop = { RLN_MM_DISABLEHOPPING };\n\tstruct rln_mm_cmd response;\n#endif\n\n\tbzero((char*)&init + sizeof init.mm_cmd,\n\t\tsizeof init - sizeof init.mm_cmd);\n\n\tdprintf(\" [setting parameters]\");\n\tinit.opmode = (sc->sc_state & RLN_STATE_PROMISC ?\n\t    RLN_MM_INIT_OPMODE_PROMISC : RLN_MM_INIT_OPMODE_NORMAL);\n\tinit.stationtype = sc->sc_param.rp_station_type;\n\n\t/* Spread-spectrum frequency hopping. */\n\tinit.hop_period = 1;\n\tinit.bfreq = 2;\n\tinit.sfreq = 7;\n\n\t/* Choose channel. */\n\tinit.channel = sc->sc_param.rp_channel;\n\tinit.subchannel = sc->sc_param.rp_subchannel;\n\tinit.domain = sc->sc_param.rp_domain;\n\n\t/* Name of this station when acting as master. */\n\tbcopy(sc->sc_param.rp_master, init.mastername, sizeof init.mastername);\n\n\t/* Security params. */\n\tinit.sec1 = (sc->sc_param.rp_security & 0x0000ff) >> 0;\n\tinit.sec2 = (sc->sc_param.rp_security & 0x00ff00) >> 8;\n\tinit.sec3 = (sc->sc_param.rp_security & 0xff0000) >> 16;\n\n\tinit.sync_to = 1;\n\tbzero(init.syncname, sizeof init.syncname);\n\n\tif (rln_msg_txrx(sc, &init, sizeof init,\n\t    &iresponse, sizeof iresponse))\n\t\treturn (-1);\n#if 0\n\tdprintf(\" [setting magic]\");\n\tmagic.fairness_slot = 3;\t/* lite: 1, norm: 3, off: -1 */\n\tmagic.deferral_slot = 3;\t/* lite: 0, norm: 3, off: -1 */\n\tmagic.regular_mac_retry = 7;\n\tmagic.frag_mac_retry = 10;\n\tmagic.regular_mac_qfsk = 2;\n\tmagic.frag_mac_qfsk = 5;\n\tmagic.xxx1 = 0xff;\n\tmagic.xxx2 = 0xff;\n\tmagic.xxx3 = 0xff;\n\tmagic.xxx4 = 0x00;\n\tif (rln_msg_txrx(sc, &magic, sizeof magic,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\n\tdprintf(\" [disabling freq hopping]\");\n\thop.hopflag = RLN_MM_DISABLEHOPPING_HOPFLAG_DISABLE;\n\tif (rln_msg_txrx(sc, &hop, sizeof hop,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\n#endif\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "param",
            "&sc->sc_param",
            "sizeof *param"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\trln_sendinit;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_iosetparam(sc, param)\n\tstruct rln_softc *sc;\n\tstruct rln_param *param;\n{\n\tint error = 0;\n\n\tif (param->rp_roam_config > 2)\n\t\terror = EINVAL;\n\tif (param->rp_security > 0x00ffffff)\n\t\terror = EINVAL;\n\tif (param->rp_station_type > 2)\n\t\terror = EINVAL;\n\tif (param->rp_channel > 15)\n\t\terror = EINVAL;\n\tif (param->rp_subchannel > 15)\n\t\terror = EINVAL;\n\tif (error == 0) {\n\t\t/* Apply immediately. */\n\t\tbcopy(param, &sc->sc_param, sizeof *param);\n\t\tif (rln_sendinit(sc))\n\t\t\terror = EIO;\n\t}\n\treturn (error);\n}"
  },
  {
    "function_name": "rln_searchsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "1095-1112",
    "snippet": "int\nrln_searchsync(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct rln_mm_search search = { RLN_MM_SEARCH };\n\tstruct rln_mm_searching response;\n\n\tbzero(search.xxx1, sizeof search.xxx1);\n\tsearch.domain = sc->sc_param.rp_domain;\n\tsearch.roaming = 1;\n\tsearch.xxx3 = 0;\n\tsearch.xxx4 = 1;\n\tsearch.xxx5 = 0;\n\tbzero(search.xxx6, sizeof search.xxx6);\n\n\treturn (rln_msg_txrx(sc, &search, sizeof search,\n\t\t&response, sizeof response));\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rln_msg_txrx",
          "args": [
            "sc",
            "&search",
            "sizeof search",
            "&response",
            "sizeof response"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "rln_msg_txrx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "686-774",
          "snippet": "int\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "search.xxx6",
            "sizeof search.xxx6"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "search.xxx1",
            "sizeof search.xxx1"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_searchsync(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct rln_mm_search search = { RLN_MM_SEARCH };\n\tstruct rln_mm_searching response;\n\n\tbzero(search.xxx1, sizeof search.xxx1);\n\tsearch.domain = sc->sc_param.rp_domain;\n\tsearch.roaming = 1;\n\tsearch.xxx3 = 0;\n\tsearch.xxx4 = 1;\n\tsearch.xxx5 = 0;\n\tbzero(search.xxx6, sizeof search.xxx6);\n\n\treturn (rln_msg_txrx(sc, &search, sizeof search,\n\t\t&response, sizeof response));\n}"
  },
  {
    "function_name": "rln_multicast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "1071-1092",
    "snippet": "int\nrln_multicast(sc, enable)\n\tstruct rln_softc *sc;\n\tint enable;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct rln_mm_multicast mcast = { RLN_MM_MULTICAST };\n\tstruct rln_mm_cmd response;\n\tint ret;\n\n\tmcast.enable = enable;\n\n\tret = rln_msg_txrx(sc, &mcast, sizeof mcast,\n\t    &response, sizeof response);\n\tif (ret == 0) {\n\t\tif (enable)\n\t\t\tifp->if_flags |= IFF_MULTICAST;\n\t\telse\n\t\t\tifp->if_flags &= ~IFF_MULTICAST;\n\t}\n\treturn (ret);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rln_msg_txrx",
          "args": [
            "sc",
            "&mcast",
            "sizeof mcast",
            "&response",
            "sizeof response"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "rln_msg_txrx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "686-774",
          "snippet": "int\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_multicast(sc, enable)\n\tstruct rln_softc *sc;\n\tint enable;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct rln_mm_multicast mcast = { RLN_MM_MULTICAST };\n\tstruct rln_mm_cmd response;\n\tint ret;\n\n\tmcast.enable = enable;\n\n\tret = rln_msg_txrx(sc, &mcast, sizeof mcast,\n\t    &response, sizeof response);\n\tif (ret == 0) {\n\t\tif (enable)\n\t\t\tifp->if_flags |= IFF_MULTICAST;\n\t\telse\n\t\t\tifp->if_flags &= ~IFF_MULTICAST;\n\t}\n\treturn (ret);\n}"
  },
  {
    "function_name": "rln_roam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "1059-1068",
    "snippet": "int\nrln_roam(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct rln_mm_cmd roam = RLN_MM_ROAM;\n\tstruct rln_mm_cmd response;\n\n\treturn (rln_msg_txrx(sc, &roam, sizeof roam,\n\t    &response, sizeof response));\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rln_msg_txrx",
          "args": [
            "sc",
            "&roam",
            "sizeof roam",
            "&response",
            "sizeof response"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "rln_msg_txrx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "686-774",
          "snippet": "int\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_roam(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct rln_mm_cmd roam = RLN_MM_ROAM;\n\tstruct rln_mm_cmd response;\n\n\treturn (rln_msg_txrx(sc, &roam, sizeof roam,\n\t    &response, sizeof response));\n}"
  },
  {
    "function_name": "rln_roamconfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "1030-1056",
    "snippet": "int\nrln_roamconfig(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct rln_mm_setroaming roam = { RLN_MM_SETROAMING };\n\tstruct rln_mm_cmd response;\n\tstatic int retry[3] = { 6, 6, 4 };\n\tstatic int rssi[3] = { 5, 15, 5 };\n\n\tdprintf(\" [roamconfig]\");\n#ifdef DIAGNOSTIC\n\tif (sc->sc_param.rp_roam_config > 2)\n\t\tpanic(\"roamconfig\");\n#endif\n\troam.sync_alarm = 0;\n\troam.retry_thresh = retry[sc->sc_param.rp_roam_config];\n\troam.rssi_threshold = rssi[sc->sc_param.rp_roam_config];\n\troam.xxx1 = 0x5a;\n\troam.sync_rssi_threshold = 0;\n\troam.xxx2 = 0x5a;\n\troam.missed_sync = 0x4;\n\tif (rln_msg_txrx(sc, &roam, sizeof roam,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rln_msg_txrx",
          "args": [
            "sc",
            "&roam",
            "sizeof roam",
            "&response",
            "sizeof response"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "rln_msg_txrx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "686-774",
          "snippet": "int\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"roamconfig\""
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" [roamconfig]\""
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_roamconfig(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct rln_mm_setroaming roam = { RLN_MM_SETROAMING };\n\tstruct rln_mm_cmd response;\n\tstatic int retry[3] = { 6, 6, 4 };\n\tstatic int rssi[3] = { 5, 15, 5 };\n\n\tdprintf(\" [roamconfig]\");\n#ifdef DIAGNOSTIC\n\tif (sc->sc_param.rp_roam_config > 2)\n\t\tpanic(\"roamconfig\");\n#endif\n\troam.sync_alarm = 0;\n\troam.retry_thresh = retry[sc->sc_param.rp_roam_config];\n\troam.rssi_threshold = rssi[sc->sc_param.rp_roam_config];\n\troam.xxx1 = 0x5a;\n\troam.sync_rssi_threshold = 0;\n\troam.xxx2 = 0x5a;\n\troam.missed_sync = 0x4;\n\tif (rln_msg_txrx(sc, &roam, sizeof roam,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "rln_sendinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "958-1026",
    "snippet": "int\nrln_sendinit(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct rln_mm_init init = { RLN_MM_INIT };\n\tstruct rln_mm_initted iresponse;\n#if 0\n\tstruct rln_mm_setmagic magic = { RLN_MM_SETMAGIC };\n\tstruct rln_mm_disablehopping hop = { RLN_MM_DISABLEHOPPING };\n\tstruct rln_mm_cmd response;\n#endif\n\n\tbzero((char*)&init + sizeof init.mm_cmd,\n\t\tsizeof init - sizeof init.mm_cmd);\n\n\tdprintf(\" [setting parameters]\");\n\tinit.opmode = (sc->sc_state & RLN_STATE_PROMISC ?\n\t    RLN_MM_INIT_OPMODE_PROMISC : RLN_MM_INIT_OPMODE_NORMAL);\n\tinit.stationtype = sc->sc_param.rp_station_type;\n\n\t/* Spread-spectrum frequency hopping. */\n\tinit.hop_period = 1;\n\tinit.bfreq = 2;\n\tinit.sfreq = 7;\n\n\t/* Choose channel. */\n\tinit.channel = sc->sc_param.rp_channel;\n\tinit.subchannel = sc->sc_param.rp_subchannel;\n\tinit.domain = sc->sc_param.rp_domain;\n\n\t/* Name of this station when acting as master. */\n\tbcopy(sc->sc_param.rp_master, init.mastername, sizeof init.mastername);\n\n\t/* Security params. */\n\tinit.sec1 = (sc->sc_param.rp_security & 0x0000ff) >> 0;\n\tinit.sec2 = (sc->sc_param.rp_security & 0x00ff00) >> 8;\n\tinit.sec3 = (sc->sc_param.rp_security & 0xff0000) >> 16;\n\n\tinit.sync_to = 1;\n\tbzero(init.syncname, sizeof init.syncname);\n\n\tif (rln_msg_txrx(sc, &init, sizeof init,\n\t    &iresponse, sizeof iresponse))\n\t\treturn (-1);\n#if 0\n\tdprintf(\" [setting magic]\");\n\tmagic.fairness_slot = 3;\t/* lite: 1, norm: 3, off: -1 */\n\tmagic.deferral_slot = 3;\t/* lite: 0, norm: 3, off: -1 */\n\tmagic.regular_mac_retry = 7;\n\tmagic.frag_mac_retry = 10;\n\tmagic.regular_mac_qfsk = 2;\n\tmagic.frag_mac_qfsk = 5;\n\tmagic.xxx1 = 0xff;\n\tmagic.xxx2 = 0xff;\n\tmagic.xxx3 = 0xff;\n\tmagic.xxx4 = 0x00;\n\tif (rln_msg_txrx(sc, &magic, sizeof magic,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\n\tdprintf(\" [disabling freq hopping]\");\n\thop.hopflag = RLN_MM_DISABLEHOPPING_HOPFLAG_DISABLE;\n\tif (rln_msg_txrx(sc, &hop, sizeof hop,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\n#endif\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\trln_sendinit",
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rln_msg_txrx",
          "args": [
            "sc",
            "&hop",
            "sizeof hop",
            "&response",
            "sizeof response"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "rln_msg_txrx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "686-774",
          "snippet": "int\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" [disabling freq hopping]\""
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" [setting magic]\""
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "init.syncname",
            "sizeof init.syncname"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_param.rp_master",
            "init.mastername",
            "sizeof init.mastername"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" [setting parameters]\""
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char*)&init + sizeof init.mm_cmd",
            "sizeof init - sizeof init.mm_cmd"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\trln_sendinit;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_sendinit(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct rln_mm_init init = { RLN_MM_INIT };\n\tstruct rln_mm_initted iresponse;\n#if 0\n\tstruct rln_mm_setmagic magic = { RLN_MM_SETMAGIC };\n\tstruct rln_mm_disablehopping hop = { RLN_MM_DISABLEHOPPING };\n\tstruct rln_mm_cmd response;\n#endif\n\n\tbzero((char*)&init + sizeof init.mm_cmd,\n\t\tsizeof init - sizeof init.mm_cmd);\n\n\tdprintf(\" [setting parameters]\");\n\tinit.opmode = (sc->sc_state & RLN_STATE_PROMISC ?\n\t    RLN_MM_INIT_OPMODE_PROMISC : RLN_MM_INIT_OPMODE_NORMAL);\n\tinit.stationtype = sc->sc_param.rp_station_type;\n\n\t/* Spread-spectrum frequency hopping. */\n\tinit.hop_period = 1;\n\tinit.bfreq = 2;\n\tinit.sfreq = 7;\n\n\t/* Choose channel. */\n\tinit.channel = sc->sc_param.rp_channel;\n\tinit.subchannel = sc->sc_param.rp_subchannel;\n\tinit.domain = sc->sc_param.rp_domain;\n\n\t/* Name of this station when acting as master. */\n\tbcopy(sc->sc_param.rp_master, init.mastername, sizeof init.mastername);\n\n\t/* Security params. */\n\tinit.sec1 = (sc->sc_param.rp_security & 0x0000ff) >> 0;\n\tinit.sec2 = (sc->sc_param.rp_security & 0x00ff00) >> 8;\n\tinit.sec3 = (sc->sc_param.rp_security & 0xff0000) >> 16;\n\n\tinit.sync_to = 1;\n\tbzero(init.syncname, sizeof init.syncname);\n\n\tif (rln_msg_txrx(sc, &init, sizeof init,\n\t    &iresponse, sizeof iresponse))\n\t\treturn (-1);\n#if 0\n\tdprintf(\" [setting magic]\");\n\tmagic.fairness_slot = 3;\t/* lite: 1, norm: 3, off: -1 */\n\tmagic.deferral_slot = 3;\t/* lite: 0, norm: 3, off: -1 */\n\tmagic.regular_mac_retry = 7;\n\tmagic.frag_mac_retry = 10;\n\tmagic.regular_mac_qfsk = 2;\n\tmagic.frag_mac_qfsk = 5;\n\tmagic.xxx1 = 0xff;\n\tmagic.xxx2 = 0xff;\n\tmagic.xxx3 = 0xff;\n\tmagic.xxx4 = 0x00;\n\tif (rln_msg_txrx(sc, &magic, sizeof magic,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\n\tdprintf(\" [disabling freq hopping]\");\n\thop.hopflag = RLN_MM_DISABLEHOPPING_HOPFLAG_DISABLE;\n\tif (rln_msg_txrx(sc, &hop, sizeof hop,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\n#endif\n\treturn (0);\n}"
  },
  {
    "function_name": "rln_getpromvers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "932-955",
    "snippet": "int\nrln_getpromvers(sc, ver, verlen)\n\tstruct rln_softc *sc;\n\tchar *ver;\n\tint verlen;\n{\n\tstruct rln_mm_cmd query = RLN_MM_GETPROMVERSION;\n\tstruct rln_mm_gotpromversion response = { RLN_MM_GOTPROMVERSION };\n\tint i;\n\n#ifdef DIAGNOSTIC\n\tif (verlen != sizeof response.version)\n\t\tpanic(\"rln_getpromvers\");\n#endif\n\n\tif (rln_msg_txrx(sc, &query, sizeof query,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\tbcopy(response.version, ver, verlen);\n\t/* Nul trailing spaces. */\n\tfor (i = verlen - 1; i >= 0 && ver[i] <= ' '; i--)\n\t\tver[i] = '\\0';\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\trln_getpromvers",
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "response.version",
            "ver",
            "verlen"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_msg_txrx",
          "args": [
            "sc",
            "&query",
            "sizeof query",
            "&response",
            "sizeof response"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "rln_msg_txrx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "686-774",
          "snippet": "int\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"rln_getpromvers\""
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\trln_getpromvers;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_getpromvers(sc, ver, verlen)\n\tstruct rln_softc *sc;\n\tchar *ver;\n\tint verlen;\n{\n\tstruct rln_mm_cmd query = RLN_MM_GETPROMVERSION;\n\tstruct rln_mm_gotpromversion response = { RLN_MM_GOTPROMVERSION };\n\tint i;\n\n#ifdef DIAGNOSTIC\n\tif (verlen != sizeof response.version)\n\t\tpanic(\"rln_getpromvers\");\n#endif\n\n\tif (rln_msg_txrx(sc, &query, sizeof query,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\tbcopy(response.version, ver, verlen);\n\t/* Nul trailing spaces. */\n\tfor (i = verlen - 1; i >= 0 && ver[i] <= ' '; i--)\n\t\tver[i] = '\\0';\n\treturn (0);\n}"
  },
  {
    "function_name": "rln_getenaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "916-929",
    "snippet": "int\nrln_getenaddr(sc, enaddr)\n\tstruct rln_softc *sc;\n\tu_int8_t * enaddr;\n{\n\tstruct rln_mm_cmd query = RLN_MM_GETENADDR;\n\tstruct rln_mm_gotenaddr response = { RLN_MM_GETENADDR };\n\n\tif (rln_msg_txrx(sc, &query, sizeof query,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\tbcopy(response.enaddr, enaddr, sizeof response.enaddr);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\trln_getenaddr",
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "response.enaddr",
            "enaddr",
            "sizeof response.enaddr"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_msg_txrx",
          "args": [
            "sc",
            "&query",
            "sizeof query",
            "&response",
            "sizeof response"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "rln_msg_txrx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "686-774",
          "snippet": "int\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\trln_getenaddr;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_getenaddr(sc, enaddr)\n\tstruct rln_softc *sc;\n\tu_int8_t * enaddr;\n{\n\tstruct rln_mm_cmd query = RLN_MM_GETENADDR;\n\tstruct rln_mm_gotenaddr response = { RLN_MM_GETENADDR };\n\n\tif (rln_msg_txrx(sc, &query, sizeof query,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\tbcopy(response.enaddr, enaddr, sizeof response.enaddr);\n\treturn (0);\n}"
  },
  {
    "function_name": "rlnstop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "904-913",
    "snippet": "void\nrlnstop(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tdprintf(\" [stop]\");\n\tifp->if_flags &= ~IFF_RUNNING;\n\trln_enable(sc, 0);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\trlnstop",
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rln_enable",
          "args": [
            "sc",
            "0"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "rln_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "48-67",
          "snippet": "int\nrln_enable(sc, enable)\n\tstruct rln_softc * sc;\n\tint\t\tenable;\n{\n\tint\t\ts;\n\tint\t\twas_enabled;\n\n\ts = splhigh();\n\twas_enabled = (sc->sc_intsel & RLN_INTSEL_ENABLE) ? 1 : 0;\n\tif (enable != was_enabled) {\n\t\tif (enable)\n\t\t\tsc->sc_intsel |= RLN_INTSEL_ENABLE;\n\t\telse\n\t\t\tsc->sc_intsel &=~RLN_INTSEL_ENABLE;\n\t\t_rln_register_write_1(sc, RLN_REG_INTSEL, sc->sc_intsel);\n\t}\n\tsplx(s);\n\treturn (was_enabled);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_enable(sc, enable)\n\tstruct rln_softc * sc;\n\tint\t\tenable;\n{\n\tint\t\ts;\n\tint\t\twas_enabled;\n\n\ts = splhigh();\n\twas_enabled = (sc->sc_intsel & RLN_INTSEL_ENABLE) ? 1 : 0;\n\tif (enable != was_enabled) {\n\t\tif (enable)\n\t\t\tsc->sc_intsel |= RLN_INTSEL_ENABLE;\n\t\telse\n\t\t\tsc->sc_intsel &=~RLN_INTSEL_ENABLE;\n\t\t_rln_register_write_1(sc, RLN_REG_INTSEL, sc->sc_intsel);\n\t}\n\tsplx(s);\n\treturn (was_enabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" [stop]\""
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\trlnstop;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nvoid\nrlnstop(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tdprintf(\" [stop]\");\n\tifp->if_flags &= ~IFF_RUNNING;\n\trln_enable(sc, 0);\n}"
  },
  {
    "function_name": "rlnioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "809-901",
    "snippet": "int\nrlnioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct rln_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tint s, error;\n\tint need_init;\n\n\tprintf(\"%s: ioctl cmd[%c/%d] data=%x\\n\", sc->sc_dev.dv_xname,\n\t\tIOCGROUP(cmd), IOCBASECMD(cmd), data);\n\n\ts = splnet();\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) != 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\t/* Set address. */\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\trlninit(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\trlninit(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tneed_init = 0;\n\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/* Was running, want down: stop. */\n\t\t\trlnstop(sc);\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/* Was not running, want up: start. */\n\t\t\tneed_init = 1;\n\t\t} \n\n\t\tif (ifp->if_flags & IFF_RUNNING) {\n\t\t\tif ((ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    (sc->sc_state & RLN_STATE_PROMISC) == 0) {\n\t\t\t\tsc->sc_state |= RLN_STATE_PROMISC;\n\t\t\t\tneed_init = 1;\n\t\t\t}\n\t\t\telse if ((ifp->if_flags & IFF_PROMISC) == 0 &&\n\t\t\t    (sc->sc_state & RLN_STATE_PROMISC)) {\n\t\t\t\tsc->sc_state &= ~RLN_STATE_PROMISC;\n\t\t\t\tneed_init = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (need_init)\n\t\t\trlninit(sc);\n\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = EOPNOTSUPP;\n\t\tbreak;\n\n#if notyet\n\tcase RLNIOSPARAM:\n\t\terror = rln_iosetparam(sc, (struct rln_param *)&data);\n\t\tbreak;\n\n\tcase RLNIOGPARAM:\n\t\tbcopy(&sc->sc_param, (struct rln_param *)&data, \n\t\t    sizeof sc->sc_param);\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\trlninit",
      "int\trlnioctl",
      "void\trlnstop",
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "&sc->sc_param",
            "(struct rln_param *)&data",
            "sizeof sc->sc_param"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_iosetparam",
          "args": [
            "sc",
            "(struct rln_param *)&data"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "rln_iosetparam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
          "lines": "1115-1139",
          "snippet": "int\nrln_iosetparam(sc, param)\n\tstruct rln_softc *sc;\n\tstruct rln_param *param;\n{\n\tint error = 0;\n\n\tif (param->rp_roam_config > 2)\n\t\terror = EINVAL;\n\tif (param->rp_security > 0x00ffffff)\n\t\terror = EINVAL;\n\tif (param->rp_station_type > 2)\n\t\terror = EINVAL;\n\tif (param->rp_channel > 15)\n\t\terror = EINVAL;\n\tif (param->rp_subchannel > 15)\n\t\terror = EINVAL;\n\tif (error == 0) {\n\t\t/* Apply immediately. */\n\t\tbcopy(param, &sc->sc_param, sizeof *param);\n\t\tif (rln_sendinit(sc))\n\t\t\terror = EIO;\n\t}\n\treturn (error);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\trln_sendinit",
            "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\trln_sendinit;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_iosetparam(sc, param)\n\tstruct rln_softc *sc;\n\tstruct rln_param *param;\n{\n\tint error = 0;\n\n\tif (param->rp_roam_config > 2)\n\t\terror = EINVAL;\n\tif (param->rp_security > 0x00ffffff)\n\t\terror = EINVAL;\n\tif (param->rp_station_type > 2)\n\t\terror = EINVAL;\n\tif (param->rp_channel > 15)\n\t\terror = EINVAL;\n\tif (param->rp_subchannel > 15)\n\t\terror = EINVAL;\n\tif (error == 0) {\n\t\t/* Apply immediately. */\n\t\tbcopy(param, &sc->sc_param, sizeof *param);\n\t\tif (rln_sendinit(sc))\n\t\t\terror = EIO;\n\t}\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rlninit",
          "args": [
            "sc"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "rlninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
          "lines": "152-211",
          "snippet": "void\nrlninit(sc)\n\tstruct rln_softc * sc;\n{\n\t/* LLDInit() */\n\tstruct ifnet * ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\textern int cold;\n\n\ts = splnet();\n\tdprintf(\" [init]\");\n\n\tsc->sc_intsel = 0;\n\tsc->sc_status = 0;\n\tsc->sc_control = 0;\n\tifp->if_flags &= ~IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Do a hard reset. */\n\tif (rln_reset(sc)) {\n\t\tprintf(\"%s: could not reset card\\n\", sc->sc_dev.dv_xname);\n\t\tgoto fail;\n\t}\n\tsc->sc_state = 0;\t/* Also clears RLN_STATE_NEEDINIT. */\n\n\t/* Use this host's name as a master name. */\n\tif (!cold && sc->sc_param.rp_master[0] == '\\0') {\n\t\tbcopy(hostname, sc->sc_param.rp_master, \n\t\t    min(hostnamelen, sizeof sc->sc_param.rp_master));\n\t}\n\n\trln_enable(sc, 1);\n\n\t/* Initialise operational params. */\n\tif (rln_sendinit(sc)) {\n\t\tprintf(\"%s: could not set card parameters\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto fail;\n\t}\n#if 0\n\trln_roamconfig(sc);\n\t/* rln_lockprom(sc); */\n\t/* SendSetITO() */\n\trln_multicast(sc, 1);\n\trln_roam(sc);\n\n\t/* Synchronise with something. */\n\trln_searchsync(sc);\n#endif\n\tifp->if_flags |= IFF_RUNNING;\n\trlnstart(ifp);\n\tsplx(s);\n\n\treturn;\n\n    fail:\n\tifp->if_flags &= ~IFF_UP;\n\tsplx(s);\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\trlninit",
            "void\trlnstart",
            "int\trln_sendinit",
            "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\trlninit;\nvoid\trlnstart;\nint\trln_sendinit;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nvoid\nrlninit(sc)\n\tstruct rln_softc * sc;\n{\n\t/* LLDInit() */\n\tstruct ifnet * ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\textern int cold;\n\n\ts = splnet();\n\tdprintf(\" [init]\");\n\n\tsc->sc_intsel = 0;\n\tsc->sc_status = 0;\n\tsc->sc_control = 0;\n\tifp->if_flags &= ~IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Do a hard reset. */\n\tif (rln_reset(sc)) {\n\t\tprintf(\"%s: could not reset card\\n\", sc->sc_dev.dv_xname);\n\t\tgoto fail;\n\t}\n\tsc->sc_state = 0;\t/* Also clears RLN_STATE_NEEDINIT. */\n\n\t/* Use this host's name as a master name. */\n\tif (!cold && sc->sc_param.rp_master[0] == '\\0') {\n\t\tbcopy(hostname, sc->sc_param.rp_master, \n\t\t    min(hostnamelen, sizeof sc->sc_param.rp_master));\n\t}\n\n\trln_enable(sc, 1);\n\n\t/* Initialise operational params. */\n\tif (rln_sendinit(sc)) {\n\t\tprintf(\"%s: could not set card parameters\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto fail;\n\t}\n#if 0\n\trln_roamconfig(sc);\n\t/* rln_lockprom(sc); */\n\t/* SendSetITO() */\n\trln_multicast(sc, 1);\n\trln_roam(sc);\n\n\t/* Synchronise with something. */\n\trln_searchsync(sc);\n#endif\n\tifp->if_flags |= IFF_RUNNING;\n\trlnstart(ifp);\n\tsplx(s);\n\n\treturn;\n\n    fail:\n\tifp->if_flags &= ~IFF_UP;\n\tsplx(s);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rlnstop",
          "args": [
            "sc"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "rlnstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
          "lines": "904-913",
          "snippet": "void\nrlnstop(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tdprintf(\" [stop]\");\n\tifp->if_flags &= ~IFF_RUNNING;\n\trln_enable(sc, 0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\trlnstop",
            "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\trlnstop;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nvoid\nrlnstop(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tdprintf(\" [stop]\");\n\tifp->if_flags &= ~IFF_RUNNING;\n\trln_enable(sc, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->sc_arpcom",
            "ifa"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "&sc->sc_arpcom",
            "cmd",
            "data"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "301-348",
          "snippet": "int\nfxp_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tfxp_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t /* Set new address. */\n\t\t\t fxp_init(sc);\n\t\t\t break;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tfxp_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fxp_init",
            "int\tfxp_ether_ioctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid fxp_init;\nint\tfxp_ether_ioctl;\n\nint\nfxp_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tfxp_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t /* Set new address. */\n\t\t\t fxp_init(sc);\n\t\t\t break;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tfxp_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: ioctl cmd[%c/%d] data=%x\\n\"",
            "sc->sc_dev.dv_xname",
            "IOCGROUP(cmd)",
            "IOCBASECMD(cmd)",
            "data"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IOCBASECMD",
          "args": [
            "cmd"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOCGROUP",
          "args": [
            "cmd"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\trlninit;\nint\trlnioctl;\nvoid\trlnstop;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrlnioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct rln_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tint s, error;\n\tint need_init;\n\n\tprintf(\"%s: ioctl cmd[%c/%d] data=%x\\n\", sc->sc_dev.dv_xname,\n\t\tIOCGROUP(cmd), IOCBASECMD(cmd), data);\n\n\ts = splnet();\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) != 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\t/* Set address. */\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\trlninit(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\trlninit(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tneed_init = 0;\n\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/* Was running, want down: stop. */\n\t\t\trlnstop(sc);\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/* Was not running, want up: start. */\n\t\t\tneed_init = 1;\n\t\t} \n\n\t\tif (ifp->if_flags & IFF_RUNNING) {\n\t\t\tif ((ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    (sc->sc_state & RLN_STATE_PROMISC) == 0) {\n\t\t\t\tsc->sc_state |= RLN_STATE_PROMISC;\n\t\t\t\tneed_init = 1;\n\t\t\t}\n\t\t\telse if ((ifp->if_flags & IFF_PROMISC) == 0 &&\n\t\t\t    (sc->sc_state & RLN_STATE_PROMISC)) {\n\t\t\t\tsc->sc_state &= ~RLN_STATE_PROMISC;\n\t\t\t\tneed_init = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (need_init)\n\t\t\trlninit(sc);\n\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = EOPNOTSUPP;\n\t\tbreak;\n\n#if notyet\n\tcase RLNIOSPARAM:\n\t\terror = rln_iosetparam(sc, (struct rln_param *)&data);\n\t\tbreak;\n\n\tcase RLNIOGPARAM:\n\t\tbcopy(&sc->sc_param, (struct rln_param *)&data, \n\t\t    sizeof sc->sc_param);\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}"
  },
  {
    "function_name": "rlnread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "493-696",
    "snippet": "void\nrlnread(sc, hdr, len)\n\tstruct rln_softc *sc;\n\tstruct rln_mm_cmd *hdr;\n\tint len;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\tu_int8_t data[1538];\n\tu_int8_t  *buf;\n\tsize_t\t  buflen;\n\tstruct rln_pdata pd = RLN_PDATA_INIT;\n\tstruct rln_mm_synchronised * syncp = (struct rln_mm_synchronised *)data;\n\tint s;\n\n\tdprintf(\" [read]\");\n\n\t/* Were we waiting for this message? */\n\tif (rln_mbox_lock(sc, hdr->cmd_seq, (void **)&buf, &buflen) == 0) {\n#ifdef DIAGNOSTIC\n\t\tif (buflen < sizeof *hdr)\n\t\t\tpanic(\"rlnread buflen\");\n#endif\n\t\tbcopy(hdr, buf, sizeof *hdr);\n\t\tbuf += sizeof *hdr;\n\t\tlen -= sizeof *hdr;\n\t\tbuflen -= sizeof *hdr;\n\t\tif (len) {\n\t\t\tif (len == buflen)\t\t/* Expected size */\n\t\t\t\trln_rx_pdata(sc, buf, len, &pd);\n\t\t\telse if (len < buflen) {\t/* Underfill */\n#ifdef DIAGNOSTIC\n\t\t\t\tprintf(\"%s: underfill %d<%d, cmd %c%d\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tlen, buflen,\n\t\t\t\t\thdr->cmd_letter, hdr->cmd_fn);\n#endif\n\t\t\t\trln_rx_pdata(sc, buf, len, &pd);\n\t\t\t} else {\t\t\t/* Overflow */\n#ifdef DIAGNOSTIC\n\t\t\t\tprintf(\"%s: overflow %d>%d, cmd %c%d\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tlen, buflen,\n\t\t\t\t\thdr->cmd_letter, hdr->cmd_fn);\n#endif\n\t\t\t\trln_rx_pdata(sc, buf, buflen, &pd);\n\t\t\t\t/* Drain the rest somewhere. */\n\t\t\t\trln_rx_pdata(sc, data, len - buflen, &pd);\n\t\t\t}\n\t\t}\n\t\trln_rx_end(sc);\n\n\t\t/* This message can now be handled by the waiter. */\n\t\trln_mbox_unlock(sc, hdr->cmd_seq, len + sizeof *hdr);\n\t\treturn;\n\t} \n\n\t/* Otherwise, handle the message, right here, right now. */\n\n\t/* Check if we can cope with the size of this message. */\n\tif (len > sizeof data) {\n\t\tprintf(\"%s: msg too big (%d)\\n\", sc->sc_dev.dv_xname, len);\n\t\tifp->if_ierrors++;\n\t\trln_rx_end(sc);\n\t\t/* rln_need_reset(sc); */\n\t\treturn;\n\t}\n\n\t/* Check for error results. */\n\tif (hdr->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d len=%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\thdr->cmd_error & ~0x80,\n\t\t\thdr->cmd_letter, hdr->cmd_fn,\n\t\t\tlen);\n\t\tifp->if_ierrors++;\n\t\trln_rx_end(sc);\n\t\trln_need_reset(sc);\n\t\treturn;\n\t}\n\n\t/*\n\t * \"b1\": Receiving a packet is a special case.\n\t * We wish to read the data with pio straight into an \n\t * mbuf to avoid a memory-memory copy.\n\t */\n\tif (hdr->cmd_letter == 'b' && hdr->cmd_fn == 1) {\n\t\tm = rlnget(sc, hdr, len);\n\t\trln_rx_end(sc);\n\t\tif (m == NULL) \n\t\t\treturn;\n\t\tifp->if_ipackets++;\n#ifdef DIAGNOSTIC\n\t\tif (bcmp(mtod(m, u_int8_t *), \"prox\", 4) == 0) {\n\t\t\tprintf(\"%s: proxim special packet received\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t}\n#endif\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\t/* Split the ether header from the mbuf */\n\t\teh = mtod(m, struct ether_header *);\n\t\tm_adj(m, sizeof *eh);\n\n\t\tether_input(ifp, eh, m);\n\t\treturn;\n\t}\n\n\n\t/* Otherwise we read the packet into a buffer on the stack. */\n\tbcopy(hdr, data, sizeof *hdr);\n\tif (len > sizeof *hdr) \n\t\trln_rx_pdata(sc, data + sizeof *hdr, len - sizeof *hdr, &pd);\n\trln_rx_end(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname,\n\t    hdr->cmd_letter, hdr->cmd_fn, hdr->cmd_seq);\n\tRLNDUMPHEX(hdr, sizeof hdr);\n\tprintf(\":\");\n\tRLNDUMPHEX(data + sizeof hdr, len - sizeof hdr);\n\tprintf(\"\\n\");\n#endif\n\n\tswitch (RLN_MM_CMD(hdr->cmd_letter, hdr->cmd_fn)) {\n\tcase RLN_MM_CMD('b', 0):\t\t\t/* b0: Transmit done. */\n#ifdef DIAGNOSTIC\n\t\tif (len != 7)\n\t\t\tprintf(\"%s: 'b0' len %d != 7\\n\",\n\t\t\t    sc->sc_dev.dv_xname, len);\n#endif\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tifp->if_opackets++;\n\t\ts = splnet();\n\t\trlnstart(ifp);\n\t\tsplx(s);\n\t\tbreak;\n\n\tcase RLN_MM_CMD('a', 20):\t\t\t/* a20: Card fault. */\n\t\tprintf(\"%s: hardware fault\\n\", sc->sc_dev.dv_xname);\n\t\tbreak;\n\n\tcase RLN_MM_CMD('a', 4):\t\t\t/* a4: Sync'd. */\n\t\tif (bcmp(syncp->enaddr, sc->sc_arpcom.ac_enaddr,\n\t\t    ETHER_ADDR_LEN) == 0) {\n\t\t\t/* Sync'd to own enaddr. */\n /*\n  * From http://www.proxim.com/support/faq/7400.shtml\n  * 3. RLNSETUP reports that I'm synchronized to my own MAC address. What\n  *    does that mean?\n  *    You are the acting Master for this network. Either you are\n  *    configured as the Master or as an Alternate Master. If you are an\n  *    Alternate Master, you may be out of range or on a different Domain\n  *    and Security ID from the true Master.\n  */\n\n\t\t\tprintf(\"%s: nothing to sync to; now master \",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t}\n\t\telse\n\t\t\tprintf(\"%s: synchronised to \", sc->sc_dev.dv_xname);\n\t\tprintf(\"%.11s (%s) channel %d/%d\\n\",\n\t\t    syncp->mastername,\n\t\t    ether_sprintf(syncp->enaddr),\n\t\t    syncp->channel,\n\t\t    syncp->subchannel);\n\n\t\t/* Record the new circumstances. */\n\t\tsc->sc_param.rp_channel = syncp->channel;\n\t\tsc->sc_param.rp_subchannel = syncp->subchannel;\n\t\tsc->sc_state |= RLN_STATE_SYNC;\n\n\t\t/* Resume sending. */\n\t\ts = splnet();\n\t\trlnstart(ifp);\n\t\tsplx(s);\n\t\tbreak;\n\n\tcase RLN_MM_CMD('a', 5):\t\t\t/* a4: Lost sync. */\n\t\tprintf(\"%s: lost sync\\n\", sc->sc_dev.dv_xname);\n\t\tsc->sc_state &= ~RLN_STATE_SYNC;\n\t\tbreak;\n\n\tcase RLN_MM_CMD('a', 18):\t\t\t/* a18: Roaming. */\n\t\tprintf(\"%s: roaming\\n\", sc->sc_dev.dv_xname);\n\t\tbreak;\n\tdefault:\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: msg `%c%d' seq %d data {\",\n\t\t    sc->sc_dev.dv_xname, \n\t\t    hdr->cmd_letter, hdr->cmd_fn, hdr->cmd_seq);\n\t\tRLNDUMPHEX(hdr, sizeof hdr);\n\t\tprintf(\":\");\n\t\tRLNDUMPHEX(data, len);\n\t\tprintf(\"}\\n\");\n#endif\n\t\tbreak;\n\t}\n\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\trlnstart",
      "struct mbuf * rlnget",
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;",
      "struct rln_mm_cmd *hdr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"}\\n\""
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RLNDUMPHEX",
          "args": [
            "data",
            "len"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RLNDUMPHEX",
          "args": [
            "hdr",
            "sizeof hdr"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RLN_MM_CMD",
          "args": [
            "'a'",
            "18"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RLN_MM_CMD",
          "args": [
            "'a'",
            "5"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlnstart",
          "args": [
            "ifp"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "rlnstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
          "lines": "214-298",
          "snippet": "void\nrlnstart(ifp)\n\tstruct ifnet *\tifp;\n{\n\tstruct rln_softc * sc = (struct rln_softc *)ifp->if_softc;\n\tstruct mbuf *\tm0;\n\tint\t\tlen, pad, ret, s;\n\n\tdprintf(\" start[\");\n\n\tif (sc->sc_state & RLN_STATE_NEEDINIT)\n\t\trlninit(sc);\n\n\t/* Don't transmit if interface is busy or not running. */\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING) {\n\t\tdprintf(\" %s] \", (ifp->if_flags & IFF_OACTIVE) ? \n\t\t    \"busy\" : \"stopped\");\n\t\treturn;\n\t}\n\n\t/* Don't transmit if we are not synchronised. */\n\tif ((sc->sc_state & RLN_STATE_SYNC) == 0) {\n\t\tdprintf(\" nosync]\");\n\t\treturn;\n\t}\n\n\trln_enable(sc, 1);\n\n    startagain:\n\ts = splimp();\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tsplx(s);\n\n\tif (m0 == NULL) {\n\t\tdprintf(\" empty]\");\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/* Tap packet stream here for BPF listeners. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/* We need to use m->m_pkthdr.len, so require the header. */\n\tif ((m0->m_flags & M_PKTHDR) == 0) {\n\t\tprintf(\"%s: no mbuf header\\n\", sc->sc_dev.dv_xname);\n\t\tgoto oerror;\n\t}\n\n\tlen = m0->m_pkthdr.len;\n\n#define PACKETMIN\t(sizeof (struct ether_header) + ETHERMIN)\n#define PACKETMAX\t(sizeof (struct ether_header) + ETHERMTU + 4)\n\n\t/* Packet size has to be an even number between 60 and 1518 octets. */\n\tpad = len & 1;\n\tif (len + pad < PACKETMIN)\n\t\tpad = PACKETMIN - len;\n\n\tif (len + pad > PACKETMAX) {\n\t\tprintf(\"%s: packet too big (%d > %d)\\n\",\n\t\t    sc->sc_dev.dv_xname, len + pad,\n\t\t    PACKETMAX);\n\t\t++ifp->if_oerrors;\n\t\tm_freem(m0);\n\t\tgoto startagain;\n\t}\n\n\tret = rln_transmit(sc, m0, len, pad);\n\tif (ret)\n\t\tgoto oerror;\n\n\tifp->if_flags |= IFF_OACTIVE;\n\tm_freem(m0);\n\n\tdprintf(\" sent]\");\n\treturn;\n\noerror:\n\t++ifp->if_oerrors;\n\tm_freem(m0);\n\trln_need_reset(sc);\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PACKETMAX\t(sizeof (struct ether_header) + ETHERMTU + 4)",
            "#define PACKETMIN\t(sizeof (struct ether_header) + ETHERMIN)"
          ],
          "globals_used": [
            "void\trlninit",
            "void\trlnstart",
            "int\trln_transmit",
            "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PACKETMAX\t(sizeof (struct ether_header) + ETHERMTU + 4)\n#define PACKETMIN\t(sizeof (struct ether_header) + ETHERMIN)\n\nvoid\trlninit;\nvoid\trlnstart;\nint\trln_transmit;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nvoid\nrlnstart(ifp)\n\tstruct ifnet *\tifp;\n{\n\tstruct rln_softc * sc = (struct rln_softc *)ifp->if_softc;\n\tstruct mbuf *\tm0;\n\tint\t\tlen, pad, ret, s;\n\n\tdprintf(\" start[\");\n\n\tif (sc->sc_state & RLN_STATE_NEEDINIT)\n\t\trlninit(sc);\n\n\t/* Don't transmit if interface is busy or not running. */\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING) {\n\t\tdprintf(\" %s] \", (ifp->if_flags & IFF_OACTIVE) ? \n\t\t    \"busy\" : \"stopped\");\n\t\treturn;\n\t}\n\n\t/* Don't transmit if we are not synchronised. */\n\tif ((sc->sc_state & RLN_STATE_SYNC) == 0) {\n\t\tdprintf(\" nosync]\");\n\t\treturn;\n\t}\n\n\trln_enable(sc, 1);\n\n    startagain:\n\ts = splimp();\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tsplx(s);\n\n\tif (m0 == NULL) {\n\t\tdprintf(\" empty]\");\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/* Tap packet stream here for BPF listeners. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/* We need to use m->m_pkthdr.len, so require the header. */\n\tif ((m0->m_flags & M_PKTHDR) == 0) {\n\t\tprintf(\"%s: no mbuf header\\n\", sc->sc_dev.dv_xname);\n\t\tgoto oerror;\n\t}\n\n\tlen = m0->m_pkthdr.len;\n\n#define PACKETMIN\t(sizeof (struct ether_header) + ETHERMIN)\n#define PACKETMAX\t(sizeof (struct ether_header) + ETHERMTU + 4)\n\n\t/* Packet size has to be an even number between 60 and 1518 octets. */\n\tpad = len & 1;\n\tif (len + pad < PACKETMIN)\n\t\tpad = PACKETMIN - len;\n\n\tif (len + pad > PACKETMAX) {\n\t\tprintf(\"%s: packet too big (%d > %d)\\n\",\n\t\t    sc->sc_dev.dv_xname, len + pad,\n\t\t    PACKETMAX);\n\t\t++ifp->if_oerrors;\n\t\tm_freem(m0);\n\t\tgoto startagain;\n\t}\n\n\tret = rln_transmit(sc, m0, len, pad);\n\tif (ret)\n\t\tgoto oerror;\n\n\tifp->if_flags |= IFF_OACTIVE;\n\tm_freem(m0);\n\n\tdprintf(\" sent]\");\n\treturn;\n\noerror:\n\t++ifp->if_oerrors;\n\tm_freem(m0);\n\trln_need_reset(sc);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "syncp->enaddr"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "syncp->enaddr",
            "sc->sc_arpcom.ac_enaddr",
            "ETHER_ADDR_LEN"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RLN_MM_CMD",
          "args": [
            "'a'",
            "4"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RLN_MM_CMD",
          "args": [
            "'a'",
            "20"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RLN_MM_CMD",
          "args": [
            "'b'",
            "0"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RLN_MM_CMD",
          "args": [
            "hdr->cmd_letter",
            "hdr->cmd_fn"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RLNDUMPHEX",
          "args": [
            "data + sizeof hdr",
            "len - sizeof hdr"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RLNDUMPHEX",
          "args": [
            "hdr",
            "sizeof hdr"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_rx_end",
          "args": [
            "sc"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "rln_rx_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "524-535",
          "snippet": "void\nrln_rx_end(sc)\n\tstruct rln_softc * sc;\n{\n\t/* EndOfRx() */\n\n\tdprintf(\" Re[\");\n\trln_status_rx_write(sc, RLN_STATUS_RX_XFR_COMPLETE);\n\trln_status_rx_int(sc);\n\t/* rln_wakeup(sc, 0); */\n\tdprintf(\"]\");\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nrln_rx_end(sc)\n\tstruct rln_softc * sc;\n{\n\t/* EndOfRx() */\n\n\tdprintf(\" Re[\");\n\trln_status_rx_write(sc, RLN_STATUS_RX_XFR_COMPLETE);\n\trln_status_rx_int(sc);\n\t/* rln_wakeup(sc, 0); */\n\tdprintf(\"]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_rx_pdata",
          "args": [
            "sc",
            "data + sizeof *hdr",
            "len - sizeof *hdr",
            "&pd"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "rln_rx_pdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "428-483",
          "snippet": "void\nrln_rx_pdata(sc, buf, len, pd)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tint\t\t\tlen;\n\tstruct rln_pdata *\tpd;\n{\n\tchar *\t\t\tdata = (char *)buf;\n\n\tif (pd->p_nremain) {\n\t\t*data++ = pd->p_data;\n\t\tif (--len == 0)\n\t\t\treturn;\n\t}\n\n\tpd->p_nremain = 0;\n\n\tif (sc->sc_width == 16) {\n\t\t/* Round down to the closest even multiple. */\n\t\trln_data_read_multi_2(sc, data, len / 2);\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D>\"); \n\t\tdprinthex(data, len);\n#endif\n\t\tif (len & 1) {\n\t\t\t/* Read the last octet plus a bit extra. */\n\t\t\tunion {\n\t\t\t\tu_int16_t w;\n\t\t\t\tu_int8_t  b[2];\n\t\t\t} u;\n\n\t\t\tu.w = rln_data_read_2(sc);\n\t\t\tdata[len - 1] = u.b[0];\n\t\t\tpd->p_data = u.b[1];\n\t\t\tpd->p_nremain = 1;\n#ifdef RLNDEBUG_REG\n\t\t\tdprintf(\" D>{%02x%02x}\", u.b[0], u.b[1]); \n#endif\n\t\t}\n\t} else if (sc->sc_width == 8) {\n\t\trln_data_read_multi_1(sc, data, len);\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D>\"); \n\t\tdprinthex(data, len);\n#endif\n\t\tif (len & 1) {\n\t\t\t/* Must read multiples of two. */\n\t\t\tpd->p_data = rln_data_read_1(sc);\n\t\t\tpd->p_nremain = 1;\n#ifdef RLNDEBUG_REG\n\t\t\tdprintf(\" D>{%02x}\", pd->p_data); \n#endif\n\t\t}\n\t}\n\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nrln_rx_pdata(sc, buf, len, pd)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tint\t\t\tlen;\n\tstruct rln_pdata *\tpd;\n{\n\tchar *\t\t\tdata = (char *)buf;\n\n\tif (pd->p_nremain) {\n\t\t*data++ = pd->p_data;\n\t\tif (--len == 0)\n\t\t\treturn;\n\t}\n\n\tpd->p_nremain = 0;\n\n\tif (sc->sc_width == 16) {\n\t\t/* Round down to the closest even multiple. */\n\t\trln_data_read_multi_2(sc, data, len / 2);\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D>\"); \n\t\tdprinthex(data, len);\n#endif\n\t\tif (len & 1) {\n\t\t\t/* Read the last octet plus a bit extra. */\n\t\t\tunion {\n\t\t\t\tu_int16_t w;\n\t\t\t\tu_int8_t  b[2];\n\t\t\t} u;\n\n\t\t\tu.w = rln_data_read_2(sc);\n\t\t\tdata[len - 1] = u.b[0];\n\t\t\tpd->p_data = u.b[1];\n\t\t\tpd->p_nremain = 1;\n#ifdef RLNDEBUG_REG\n\t\t\tdprintf(\" D>{%02x%02x}\", u.b[0], u.b[1]); \n#endif\n\t\t}\n\t} else if (sc->sc_width == 8) {\n\t\trln_data_read_multi_1(sc, data, len);\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D>\"); \n\t\tdprinthex(data, len);\n#endif\n\t\tif (len & 1) {\n\t\t\t/* Must read multiples of two. */\n\t\t\tpd->p_data = rln_data_read_1(sc);\n\t\t\tpd->p_nremain = 1;\n#ifdef RLNDEBUG_REG\n\t\t\tdprintf(\" D>{%02x}\", pd->p_data); \n#endif\n\t\t}\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "hdr",
            "data",
            "sizeof *hdr"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "sizeof *eh"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "mtod(m, u_int8_t *)",
            "\"prox\"",
            "4"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int8_t*"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlnget",
          "args": [
            "sc",
            "hdr",
            "len"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_need_reset",
          "args": [
            "sc"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_mbox_unlock",
          "args": [
            "sc",
            "hdr->cmd_seq",
            "len + sizeof *hdr"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "rln_mbox_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "918-943",
          "snippet": "void\nrln_mbox_unlock(sc, seq, actlen)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\tseq;\n\tsize_t\t\t\tactlen;\n{\n\tint\t\t\ts;\n\tstruct rln_mbox *\tmb = &sc->sc_mbox[seq];\n\n\tdprintf(\" <unlock %d\", seq);\n\n\ts = splhigh();\n#ifdef DIAGNOSTIC\n\tif (seq > RLN_NMBOX)\n\t\tpanic(\"mbox unlock seq\");\n\tif (mb->mb_state != RLNMBOX_FILLING)\n\t\tpanic(\"mbox unlock\");\n#endif\n\tmb->mb_state = RLNMBOX_FILLED;\n\tdprintf(\" filled>\");\n\tmb->mb_actlen = actlen;\n#if defined(RLN_TSLEEP)\n\twakeup(mb);\n#endif\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nrln_mbox_unlock(sc, seq, actlen)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\tseq;\n\tsize_t\t\t\tactlen;\n{\n\tint\t\t\ts;\n\tstruct rln_mbox *\tmb = &sc->sc_mbox[seq];\n\n\tdprintf(\" <unlock %d\", seq);\n\n\ts = splhigh();\n#ifdef DIAGNOSTIC\n\tif (seq > RLN_NMBOX)\n\t\tpanic(\"mbox unlock seq\");\n\tif (mb->mb_state != RLNMBOX_FILLING)\n\t\tpanic(\"mbox unlock\");\n#endif\n\tmb->mb_state = RLNMBOX_FILLED;\n\tdprintf(\" filled>\");\n\tmb->mb_actlen = actlen;\n#if defined(RLN_TSLEEP)\n\twakeup(mb);\n#endif\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"rlnread buflen\""
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_mbox_lock",
          "args": [
            "sc",
            "hdr->cmd_seq",
            "(void **)&buf",
            "&buflen"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "rln_mbox_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "885-915",
          "snippet": "int\nrln_mbox_lock(sc, seq, bufp, lenp)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\tseq;\n\tvoid **\t\t\tbufp;\n\tsize_t *\t\tlenp;\n{\n\tint\t\t\ts;\n\tstruct rln_mbox *\tmb = &sc->sc_mbox[seq];\n\n\tdprintf(\" <lock %d\", seq);\n\n\ts = splhigh();\n#ifdef DIAGNOSTIC\n\tif (seq > RLN_NMBOX)\n\t\tpanic(\"mbox lock\");\n#endif\n\tif (mb->mb_state != RLNMBOX_EMPTY) {\n\t\tsplx(s);\n\t\tdprintf(\" ?>\");\n\t\treturn (-1);\n\t}\n\n\tmb->mb_state = RLNMBOX_FILLING;\n\tdprintf(\" filling>\");\n\t*bufp = mb->mb_buf;\n\t*lenp = mb->mb_len;\n\n\tsplx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_mbox_lock(sc, seq, bufp, lenp)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\tseq;\n\tvoid **\t\t\tbufp;\n\tsize_t *\t\tlenp;\n{\n\tint\t\t\ts;\n\tstruct rln_mbox *\tmb = &sc->sc_mbox[seq];\n\n\tdprintf(\" <lock %d\", seq);\n\n\ts = splhigh();\n#ifdef DIAGNOSTIC\n\tif (seq > RLN_NMBOX)\n\t\tpanic(\"mbox lock\");\n#endif\n\tif (mb->mb_state != RLNMBOX_EMPTY) {\n\t\tsplx(s);\n\t\tdprintf(\" ?>\");\n\t\treturn (-1);\n\t}\n\n\tmb->mb_state = RLNMBOX_FILLING;\n\tdprintf(\" filling>\");\n\t*bufp = mb->mb_buf;\n\t*lenp = mb->mb_len;\n\n\tsplx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" [read]\""
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\trlnstart;\nstruct mbuf * rlnget;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\nstruct rln_mm_cmd *hdr;\n\nvoid\nrlnread(sc, hdr, len)\n\tstruct rln_softc *sc;\n\tstruct rln_mm_cmd *hdr;\n\tint len;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\tu_int8_t data[1538];\n\tu_int8_t  *buf;\n\tsize_t\t  buflen;\n\tstruct rln_pdata pd = RLN_PDATA_INIT;\n\tstruct rln_mm_synchronised * syncp = (struct rln_mm_synchronised *)data;\n\tint s;\n\n\tdprintf(\" [read]\");\n\n\t/* Were we waiting for this message? */\n\tif (rln_mbox_lock(sc, hdr->cmd_seq, (void **)&buf, &buflen) == 0) {\n#ifdef DIAGNOSTIC\n\t\tif (buflen < sizeof *hdr)\n\t\t\tpanic(\"rlnread buflen\");\n#endif\n\t\tbcopy(hdr, buf, sizeof *hdr);\n\t\tbuf += sizeof *hdr;\n\t\tlen -= sizeof *hdr;\n\t\tbuflen -= sizeof *hdr;\n\t\tif (len) {\n\t\t\tif (len == buflen)\t\t/* Expected size */\n\t\t\t\trln_rx_pdata(sc, buf, len, &pd);\n\t\t\telse if (len < buflen) {\t/* Underfill */\n#ifdef DIAGNOSTIC\n\t\t\t\tprintf(\"%s: underfill %d<%d, cmd %c%d\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tlen, buflen,\n\t\t\t\t\thdr->cmd_letter, hdr->cmd_fn);\n#endif\n\t\t\t\trln_rx_pdata(sc, buf, len, &pd);\n\t\t\t} else {\t\t\t/* Overflow */\n#ifdef DIAGNOSTIC\n\t\t\t\tprintf(\"%s: overflow %d>%d, cmd %c%d\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tlen, buflen,\n\t\t\t\t\thdr->cmd_letter, hdr->cmd_fn);\n#endif\n\t\t\t\trln_rx_pdata(sc, buf, buflen, &pd);\n\t\t\t\t/* Drain the rest somewhere. */\n\t\t\t\trln_rx_pdata(sc, data, len - buflen, &pd);\n\t\t\t}\n\t\t}\n\t\trln_rx_end(sc);\n\n\t\t/* This message can now be handled by the waiter. */\n\t\trln_mbox_unlock(sc, hdr->cmd_seq, len + sizeof *hdr);\n\t\treturn;\n\t} \n\n\t/* Otherwise, handle the message, right here, right now. */\n\n\t/* Check if we can cope with the size of this message. */\n\tif (len > sizeof data) {\n\t\tprintf(\"%s: msg too big (%d)\\n\", sc->sc_dev.dv_xname, len);\n\t\tifp->if_ierrors++;\n\t\trln_rx_end(sc);\n\t\t/* rln_need_reset(sc); */\n\t\treturn;\n\t}\n\n\t/* Check for error results. */\n\tif (hdr->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d len=%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\thdr->cmd_error & ~0x80,\n\t\t\thdr->cmd_letter, hdr->cmd_fn,\n\t\t\tlen);\n\t\tifp->if_ierrors++;\n\t\trln_rx_end(sc);\n\t\trln_need_reset(sc);\n\t\treturn;\n\t}\n\n\t/*\n\t * \"b1\": Receiving a packet is a special case.\n\t * We wish to read the data with pio straight into an \n\t * mbuf to avoid a memory-memory copy.\n\t */\n\tif (hdr->cmd_letter == 'b' && hdr->cmd_fn == 1) {\n\t\tm = rlnget(sc, hdr, len);\n\t\trln_rx_end(sc);\n\t\tif (m == NULL) \n\t\t\treturn;\n\t\tifp->if_ipackets++;\n#ifdef DIAGNOSTIC\n\t\tif (bcmp(mtod(m, u_int8_t *), \"prox\", 4) == 0) {\n\t\t\tprintf(\"%s: proxim special packet received\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t}\n#endif\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\t/* Split the ether header from the mbuf */\n\t\teh = mtod(m, struct ether_header *);\n\t\tm_adj(m, sizeof *eh);\n\n\t\tether_input(ifp, eh, m);\n\t\treturn;\n\t}\n\n\n\t/* Otherwise we read the packet into a buffer on the stack. */\n\tbcopy(hdr, data, sizeof *hdr);\n\tif (len > sizeof *hdr) \n\t\trln_rx_pdata(sc, data + sizeof *hdr, len - sizeof *hdr, &pd);\n\trln_rx_end(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname,\n\t    hdr->cmd_letter, hdr->cmd_fn, hdr->cmd_seq);\n\tRLNDUMPHEX(hdr, sizeof hdr);\n\tprintf(\":\");\n\tRLNDUMPHEX(data + sizeof hdr, len - sizeof hdr);\n\tprintf(\"\\n\");\n#endif\n\n\tswitch (RLN_MM_CMD(hdr->cmd_letter, hdr->cmd_fn)) {\n\tcase RLN_MM_CMD('b', 0):\t\t\t/* b0: Transmit done. */\n#ifdef DIAGNOSTIC\n\t\tif (len != 7)\n\t\t\tprintf(\"%s: 'b0' len %d != 7\\n\",\n\t\t\t    sc->sc_dev.dv_xname, len);\n#endif\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tifp->if_opackets++;\n\t\ts = splnet();\n\t\trlnstart(ifp);\n\t\tsplx(s);\n\t\tbreak;\n\n\tcase RLN_MM_CMD('a', 20):\t\t\t/* a20: Card fault. */\n\t\tprintf(\"%s: hardware fault\\n\", sc->sc_dev.dv_xname);\n\t\tbreak;\n\n\tcase RLN_MM_CMD('a', 4):\t\t\t/* a4: Sync'd. */\n\t\tif (bcmp(syncp->enaddr, sc->sc_arpcom.ac_enaddr,\n\t\t    ETHER_ADDR_LEN) == 0) {\n\t\t\t/* Sync'd to own enaddr. */\n /*\n  * From http://www.proxim.com/support/faq/7400.shtml\n  * 3. RLNSETUP reports that I'm synchronized to my own MAC address. What\n  *    does that mean?\n  *    You are the acting Master for this network. Either you are\n  *    configured as the Master or as an Alternate Master. If you are an\n  *    Alternate Master, you may be out of range or on a different Domain\n  *    and Security ID from the true Master.\n  */\n\n\t\t\tprintf(\"%s: nothing to sync to; now master \",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t}\n\t\telse\n\t\t\tprintf(\"%s: synchronised to \", sc->sc_dev.dv_xname);\n\t\tprintf(\"%.11s (%s) channel %d/%d\\n\",\n\t\t    syncp->mastername,\n\t\t    ether_sprintf(syncp->enaddr),\n\t\t    syncp->channel,\n\t\t    syncp->subchannel);\n\n\t\t/* Record the new circumstances. */\n\t\tsc->sc_param.rp_channel = syncp->channel;\n\t\tsc->sc_param.rp_subchannel = syncp->subchannel;\n\t\tsc->sc_state |= RLN_STATE_SYNC;\n\n\t\t/* Resume sending. */\n\t\ts = splnet();\n\t\trlnstart(ifp);\n\t\tsplx(s);\n\t\tbreak;\n\n\tcase RLN_MM_CMD('a', 5):\t\t\t/* a4: Lost sync. */\n\t\tprintf(\"%s: lost sync\\n\", sc->sc_dev.dv_xname);\n\t\tsc->sc_state &= ~RLN_STATE_SYNC;\n\t\tbreak;\n\n\tcase RLN_MM_CMD('a', 18):\t\t\t/* a18: Roaming. */\n\t\tprintf(\"%s: roaming\\n\", sc->sc_dev.dv_xname);\n\t\tbreak;\n\tdefault:\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: msg `%c%d' seq %d data {\",\n\t\t    sc->sc_dev.dv_xname, \n\t\t    hdr->cmd_letter, hdr->cmd_fn, hdr->cmd_seq);\n\t\tRLNDUMPHEX(hdr, sizeof hdr);\n\t\tprintf(\":\");\n\t\tRLNDUMPHEX(data, len);\n\t\tprintf(\"}\\n\");\n#endif\n\t\tbreak;\n\t}\n\n}"
  },
  {
    "function_name": "rlnsoftintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "430-490",
    "snippet": "void\nrlnsoftintr(arg)\n\tvoid * arg;\n{\n\tstruct rln_softc *sc = (struct rln_softc *)arg;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint len;\n\tu_int8_t w;\n\tstruct rln_mm_cmd hdr;\n\tint s;\n\n\ts = splsoftnet();\n\tdprintf(\" si(\");\n\n    again:\n\t/* Save wakeup state. */\n\tw = rln_wakeup(sc, RLN_WAKEUP_SET);\n\n\tif ((len = rln_rx_request(sc, 300)) < 0) {\n\t\t/* Error in transfer. */\n\t\trln_need_reset(sc);\n\t\trln_rx_end(sc);\n\t} else if (len < sizeof hdr) {\n\t\t/* Short message. */\n\t\trln_rx_end(sc);\n\t\tprintf(\"%s: short msg (%d)\\n\", sc->sc_dev.dv_xname, len);\n\t\tifp->if_ierrors++;\n\t} else {\n\t\t/* Valid message: read header and process. */\n\t\trln_rx_data(sc, &hdr, sizeof hdr);\n\t\trlnread(sc, &hdr, len);\n\t}\n\n\t/* Ensure that wakeup state is unchanged if transmitting. */\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\tw |= RLN_WAKEUP_NOCHANGE;\n\trln_wakeup(sc, w);\n\n\t/* Check for more interrupts. */\n\tif ((sc->sc_state & RLN_STATE_NEEDINIT) == 0 && \n\t    rln_status_rx_ready(sc)) {\n\t\tif (rln_status_rx_read(sc) == RLN_STATUS_RX_ERROR) {\n#ifdef DIAGNOSTIC\n\t\t\tprintf(\"%s: protocol error\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\t\tDELAY(100 * 1000);\t/* Woah, baby. */\n\t\t\trln_clear_nak(sc);\n\t\t} else {\n#ifdef DIAGNOSTIC\n\t\t\tprintf(\"%s: intr piggyback\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\trln_eoi(sc);\n\trln_enable(sc, 1);\n\n\tdprintf(\")\");\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\trlnsoftintr",
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;",
      "struct rln_mm_cmd *hdr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\")\""
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_enable",
          "args": [
            "sc",
            "1"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "rln_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "48-67",
          "snippet": "int\nrln_enable(sc, enable)\n\tstruct rln_softc * sc;\n\tint\t\tenable;\n{\n\tint\t\ts;\n\tint\t\twas_enabled;\n\n\ts = splhigh();\n\twas_enabled = (sc->sc_intsel & RLN_INTSEL_ENABLE) ? 1 : 0;\n\tif (enable != was_enabled) {\n\t\tif (enable)\n\t\t\tsc->sc_intsel |= RLN_INTSEL_ENABLE;\n\t\telse\n\t\t\tsc->sc_intsel &=~RLN_INTSEL_ENABLE;\n\t\t_rln_register_write_1(sc, RLN_REG_INTSEL, sc->sc_intsel);\n\t}\n\tsplx(s);\n\treturn (was_enabled);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_enable(sc, enable)\n\tstruct rln_softc * sc;\n\tint\t\tenable;\n{\n\tint\t\ts;\n\tint\t\twas_enabled;\n\n\ts = splhigh();\n\twas_enabled = (sc->sc_intsel & RLN_INTSEL_ENABLE) ? 1 : 0;\n\tif (enable != was_enabled) {\n\t\tif (enable)\n\t\t\tsc->sc_intsel |= RLN_INTSEL_ENABLE;\n\t\telse\n\t\t\tsc->sc_intsel &=~RLN_INTSEL_ENABLE;\n\t\t_rln_register_write_1(sc, RLN_REG_INTSEL, sc->sc_intsel);\n\t}\n\tsplx(s);\n\treturn (was_enabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_eoi",
          "args": [
            "sc"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: intr piggyback\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_clear_nak",
          "args": [
            "sc"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "rln_clear_nak",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "538-546",
          "snippet": "void\nrln_clear_nak(sc)\n\tstruct rln_softc * sc;\n{\n\t/* ClearNAK() */\n\n\trln_status_tx_write(sc, RLN_STATUS_CLRNAK);\n\trln_status_tx_int(sc);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nrln_clear_nak(sc)\n\tstruct rln_softc * sc;\n{\n\t/* ClearNAK() */\n\n\trln_status_tx_write(sc, RLN_STATUS_CLRNAK);\n\trln_status_tx_int(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100 * 1000"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_rx_read",
          "args": [
            "sc"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "rln_status_rx_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnreg.h",
          "lines": "204-214",
          "snippet": "static inline int\nrln_status_rx_ready(sc)\n\tstruct rln_softc *sc;\n{\n\tu_int8_t status;\n\n\tstatus = rln_status_rx_read(sc);\n\treturn (status == RLN_STATUS_RX_LOLEN_AVAIL ||\n\t    status == RLN_STATUS_RX_HILEN_AVAIL ||\n\t    status == RLN_STATUS_RX_ERROR);\n}",
          "includes": [],
          "macros_used": [
            "#define RLN_STATUS_RX_LOLEN_AVAIL\t0x60",
            "#define RLN_STATUS_RX_ERROR\t\t0x50",
            "#define RLN_STATUS_RX_HILEN_AVAIL\t0x10"
          ],
          "globals_used": [
            "static int\trln_status_rx_ready"
          ],
          "called_functions": [],
          "contextual_snippet": "#define RLN_STATUS_RX_LOLEN_AVAIL\t0x60\n#define RLN_STATUS_RX_ERROR\t\t0x50\n#define RLN_STATUS_RX_HILEN_AVAIL\t0x10\n\nstatic int\trln_status_rx_ready;\n\nstatic inline int\nrln_status_rx_ready(sc)\n\tstruct rln_softc *sc;\n{\n\tu_int8_t status;\n\n\tstatus = rln_status_rx_read(sc);\n\treturn (status == RLN_STATUS_RX_LOLEN_AVAIL ||\n\t    status == RLN_STATUS_RX_HILEN_AVAIL ||\n\t    status == RLN_STATUS_RX_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_wakeup",
          "args": [
            "sc",
            "w"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "rln_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "171-214",
          "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rlnread",
          "args": [
            "sc",
            "&hdr",
            "len"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "rlnread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
          "lines": "493-696",
          "snippet": "void\nrlnread(sc, hdr, len)\n\tstruct rln_softc *sc;\n\tstruct rln_mm_cmd *hdr;\n\tint len;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\tu_int8_t data[1538];\n\tu_int8_t  *buf;\n\tsize_t\t  buflen;\n\tstruct rln_pdata pd = RLN_PDATA_INIT;\n\tstruct rln_mm_synchronised * syncp = (struct rln_mm_synchronised *)data;\n\tint s;\n\n\tdprintf(\" [read]\");\n\n\t/* Were we waiting for this message? */\n\tif (rln_mbox_lock(sc, hdr->cmd_seq, (void **)&buf, &buflen) == 0) {\n#ifdef DIAGNOSTIC\n\t\tif (buflen < sizeof *hdr)\n\t\t\tpanic(\"rlnread buflen\");\n#endif\n\t\tbcopy(hdr, buf, sizeof *hdr);\n\t\tbuf += sizeof *hdr;\n\t\tlen -= sizeof *hdr;\n\t\tbuflen -= sizeof *hdr;\n\t\tif (len) {\n\t\t\tif (len == buflen)\t\t/* Expected size */\n\t\t\t\trln_rx_pdata(sc, buf, len, &pd);\n\t\t\telse if (len < buflen) {\t/* Underfill */\n#ifdef DIAGNOSTIC\n\t\t\t\tprintf(\"%s: underfill %d<%d, cmd %c%d\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tlen, buflen,\n\t\t\t\t\thdr->cmd_letter, hdr->cmd_fn);\n#endif\n\t\t\t\trln_rx_pdata(sc, buf, len, &pd);\n\t\t\t} else {\t\t\t/* Overflow */\n#ifdef DIAGNOSTIC\n\t\t\t\tprintf(\"%s: overflow %d>%d, cmd %c%d\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tlen, buflen,\n\t\t\t\t\thdr->cmd_letter, hdr->cmd_fn);\n#endif\n\t\t\t\trln_rx_pdata(sc, buf, buflen, &pd);\n\t\t\t\t/* Drain the rest somewhere. */\n\t\t\t\trln_rx_pdata(sc, data, len - buflen, &pd);\n\t\t\t}\n\t\t}\n\t\trln_rx_end(sc);\n\n\t\t/* This message can now be handled by the waiter. */\n\t\trln_mbox_unlock(sc, hdr->cmd_seq, len + sizeof *hdr);\n\t\treturn;\n\t} \n\n\t/* Otherwise, handle the message, right here, right now. */\n\n\t/* Check if we can cope with the size of this message. */\n\tif (len > sizeof data) {\n\t\tprintf(\"%s: msg too big (%d)\\n\", sc->sc_dev.dv_xname, len);\n\t\tifp->if_ierrors++;\n\t\trln_rx_end(sc);\n\t\t/* rln_need_reset(sc); */\n\t\treturn;\n\t}\n\n\t/* Check for error results. */\n\tif (hdr->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d len=%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\thdr->cmd_error & ~0x80,\n\t\t\thdr->cmd_letter, hdr->cmd_fn,\n\t\t\tlen);\n\t\tifp->if_ierrors++;\n\t\trln_rx_end(sc);\n\t\trln_need_reset(sc);\n\t\treturn;\n\t}\n\n\t/*\n\t * \"b1\": Receiving a packet is a special case.\n\t * We wish to read the data with pio straight into an \n\t * mbuf to avoid a memory-memory copy.\n\t */\n\tif (hdr->cmd_letter == 'b' && hdr->cmd_fn == 1) {\n\t\tm = rlnget(sc, hdr, len);\n\t\trln_rx_end(sc);\n\t\tif (m == NULL) \n\t\t\treturn;\n\t\tifp->if_ipackets++;\n#ifdef DIAGNOSTIC\n\t\tif (bcmp(mtod(m, u_int8_t *), \"prox\", 4) == 0) {\n\t\t\tprintf(\"%s: proxim special packet received\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t}\n#endif\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\t/* Split the ether header from the mbuf */\n\t\teh = mtod(m, struct ether_header *);\n\t\tm_adj(m, sizeof *eh);\n\n\t\tether_input(ifp, eh, m);\n\t\treturn;\n\t}\n\n\n\t/* Otherwise we read the packet into a buffer on the stack. */\n\tbcopy(hdr, data, sizeof *hdr);\n\tif (len > sizeof *hdr) \n\t\trln_rx_pdata(sc, data + sizeof *hdr, len - sizeof *hdr, &pd);\n\trln_rx_end(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname,\n\t    hdr->cmd_letter, hdr->cmd_fn, hdr->cmd_seq);\n\tRLNDUMPHEX(hdr, sizeof hdr);\n\tprintf(\":\");\n\tRLNDUMPHEX(data + sizeof hdr, len - sizeof hdr);\n\tprintf(\"\\n\");\n#endif\n\n\tswitch (RLN_MM_CMD(hdr->cmd_letter, hdr->cmd_fn)) {\n\tcase RLN_MM_CMD('b', 0):\t\t\t/* b0: Transmit done. */\n#ifdef DIAGNOSTIC\n\t\tif (len != 7)\n\t\t\tprintf(\"%s: 'b0' len %d != 7\\n\",\n\t\t\t    sc->sc_dev.dv_xname, len);\n#endif\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tifp->if_opackets++;\n\t\ts = splnet();\n\t\trlnstart(ifp);\n\t\tsplx(s);\n\t\tbreak;\n\n\tcase RLN_MM_CMD('a', 20):\t\t\t/* a20: Card fault. */\n\t\tprintf(\"%s: hardware fault\\n\", sc->sc_dev.dv_xname);\n\t\tbreak;\n\n\tcase RLN_MM_CMD('a', 4):\t\t\t/* a4: Sync'd. */\n\t\tif (bcmp(syncp->enaddr, sc->sc_arpcom.ac_enaddr,\n\t\t    ETHER_ADDR_LEN) == 0) {\n\t\t\t/* Sync'd to own enaddr. */\n /*\n  * From http://www.proxim.com/support/faq/7400.shtml\n  * 3. RLNSETUP reports that I'm synchronized to my own MAC address. What\n  *    does that mean?\n  *    You are the acting Master for this network. Either you are\n  *    configured as the Master or as an Alternate Master. If you are an\n  *    Alternate Master, you may be out of range or on a different Domain\n  *    and Security ID from the true Master.\n  */\n\n\t\t\tprintf(\"%s: nothing to sync to; now master \",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t}\n\t\telse\n\t\t\tprintf(\"%s: synchronised to \", sc->sc_dev.dv_xname);\n\t\tprintf(\"%.11s (%s) channel %d/%d\\n\",\n\t\t    syncp->mastername,\n\t\t    ether_sprintf(syncp->enaddr),\n\t\t    syncp->channel,\n\t\t    syncp->subchannel);\n\n\t\t/* Record the new circumstances. */\n\t\tsc->sc_param.rp_channel = syncp->channel;\n\t\tsc->sc_param.rp_subchannel = syncp->subchannel;\n\t\tsc->sc_state |= RLN_STATE_SYNC;\n\n\t\t/* Resume sending. */\n\t\ts = splnet();\n\t\trlnstart(ifp);\n\t\tsplx(s);\n\t\tbreak;\n\n\tcase RLN_MM_CMD('a', 5):\t\t\t/* a4: Lost sync. */\n\t\tprintf(\"%s: lost sync\\n\", sc->sc_dev.dv_xname);\n\t\tsc->sc_state &= ~RLN_STATE_SYNC;\n\t\tbreak;\n\n\tcase RLN_MM_CMD('a', 18):\t\t\t/* a18: Roaming. */\n\t\tprintf(\"%s: roaming\\n\", sc->sc_dev.dv_xname);\n\t\tbreak;\n\tdefault:\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: msg `%c%d' seq %d data {\",\n\t\t    sc->sc_dev.dv_xname, \n\t\t    hdr->cmd_letter, hdr->cmd_fn, hdr->cmd_seq);\n\t\tRLNDUMPHEX(hdr, sizeof hdr);\n\t\tprintf(\":\");\n\t\tRLNDUMPHEX(data, len);\n\t\tprintf(\"}\\n\");\n#endif\n\t\tbreak;\n\t}\n\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\trlnstart",
            "struct mbuf * rlnget",
            "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;",
            "struct rln_mm_cmd *hdr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\trlnstart;\nstruct mbuf * rlnget;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\nstruct rln_mm_cmd *hdr;\n\nvoid\nrlnread(sc, hdr, len)\n\tstruct rln_softc *sc;\n\tstruct rln_mm_cmd *hdr;\n\tint len;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\tu_int8_t data[1538];\n\tu_int8_t  *buf;\n\tsize_t\t  buflen;\n\tstruct rln_pdata pd = RLN_PDATA_INIT;\n\tstruct rln_mm_synchronised * syncp = (struct rln_mm_synchronised *)data;\n\tint s;\n\n\tdprintf(\" [read]\");\n\n\t/* Were we waiting for this message? */\n\tif (rln_mbox_lock(sc, hdr->cmd_seq, (void **)&buf, &buflen) == 0) {\n#ifdef DIAGNOSTIC\n\t\tif (buflen < sizeof *hdr)\n\t\t\tpanic(\"rlnread buflen\");\n#endif\n\t\tbcopy(hdr, buf, sizeof *hdr);\n\t\tbuf += sizeof *hdr;\n\t\tlen -= sizeof *hdr;\n\t\tbuflen -= sizeof *hdr;\n\t\tif (len) {\n\t\t\tif (len == buflen)\t\t/* Expected size */\n\t\t\t\trln_rx_pdata(sc, buf, len, &pd);\n\t\t\telse if (len < buflen) {\t/* Underfill */\n#ifdef DIAGNOSTIC\n\t\t\t\tprintf(\"%s: underfill %d<%d, cmd %c%d\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tlen, buflen,\n\t\t\t\t\thdr->cmd_letter, hdr->cmd_fn);\n#endif\n\t\t\t\trln_rx_pdata(sc, buf, len, &pd);\n\t\t\t} else {\t\t\t/* Overflow */\n#ifdef DIAGNOSTIC\n\t\t\t\tprintf(\"%s: overflow %d>%d, cmd %c%d\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tlen, buflen,\n\t\t\t\t\thdr->cmd_letter, hdr->cmd_fn);\n#endif\n\t\t\t\trln_rx_pdata(sc, buf, buflen, &pd);\n\t\t\t\t/* Drain the rest somewhere. */\n\t\t\t\trln_rx_pdata(sc, data, len - buflen, &pd);\n\t\t\t}\n\t\t}\n\t\trln_rx_end(sc);\n\n\t\t/* This message can now be handled by the waiter. */\n\t\trln_mbox_unlock(sc, hdr->cmd_seq, len + sizeof *hdr);\n\t\treturn;\n\t} \n\n\t/* Otherwise, handle the message, right here, right now. */\n\n\t/* Check if we can cope with the size of this message. */\n\tif (len > sizeof data) {\n\t\tprintf(\"%s: msg too big (%d)\\n\", sc->sc_dev.dv_xname, len);\n\t\tifp->if_ierrors++;\n\t\trln_rx_end(sc);\n\t\t/* rln_need_reset(sc); */\n\t\treturn;\n\t}\n\n\t/* Check for error results. */\n\tif (hdr->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d len=%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\thdr->cmd_error & ~0x80,\n\t\t\thdr->cmd_letter, hdr->cmd_fn,\n\t\t\tlen);\n\t\tifp->if_ierrors++;\n\t\trln_rx_end(sc);\n\t\trln_need_reset(sc);\n\t\treturn;\n\t}\n\n\t/*\n\t * \"b1\": Receiving a packet is a special case.\n\t * We wish to read the data with pio straight into an \n\t * mbuf to avoid a memory-memory copy.\n\t */\n\tif (hdr->cmd_letter == 'b' && hdr->cmd_fn == 1) {\n\t\tm = rlnget(sc, hdr, len);\n\t\trln_rx_end(sc);\n\t\tif (m == NULL) \n\t\t\treturn;\n\t\tifp->if_ipackets++;\n#ifdef DIAGNOSTIC\n\t\tif (bcmp(mtod(m, u_int8_t *), \"prox\", 4) == 0) {\n\t\t\tprintf(\"%s: proxim special packet received\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t}\n#endif\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\t/* Split the ether header from the mbuf */\n\t\teh = mtod(m, struct ether_header *);\n\t\tm_adj(m, sizeof *eh);\n\n\t\tether_input(ifp, eh, m);\n\t\treturn;\n\t}\n\n\n\t/* Otherwise we read the packet into a buffer on the stack. */\n\tbcopy(hdr, data, sizeof *hdr);\n\tif (len > sizeof *hdr) \n\t\trln_rx_pdata(sc, data + sizeof *hdr, len - sizeof *hdr, &pd);\n\trln_rx_end(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname,\n\t    hdr->cmd_letter, hdr->cmd_fn, hdr->cmd_seq);\n\tRLNDUMPHEX(hdr, sizeof hdr);\n\tprintf(\":\");\n\tRLNDUMPHEX(data + sizeof hdr, len - sizeof hdr);\n\tprintf(\"\\n\");\n#endif\n\n\tswitch (RLN_MM_CMD(hdr->cmd_letter, hdr->cmd_fn)) {\n\tcase RLN_MM_CMD('b', 0):\t\t\t/* b0: Transmit done. */\n#ifdef DIAGNOSTIC\n\t\tif (len != 7)\n\t\t\tprintf(\"%s: 'b0' len %d != 7\\n\",\n\t\t\t    sc->sc_dev.dv_xname, len);\n#endif\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tifp->if_opackets++;\n\t\ts = splnet();\n\t\trlnstart(ifp);\n\t\tsplx(s);\n\t\tbreak;\n\n\tcase RLN_MM_CMD('a', 20):\t\t\t/* a20: Card fault. */\n\t\tprintf(\"%s: hardware fault\\n\", sc->sc_dev.dv_xname);\n\t\tbreak;\n\n\tcase RLN_MM_CMD('a', 4):\t\t\t/* a4: Sync'd. */\n\t\tif (bcmp(syncp->enaddr, sc->sc_arpcom.ac_enaddr,\n\t\t    ETHER_ADDR_LEN) == 0) {\n\t\t\t/* Sync'd to own enaddr. */\n /*\n  * From http://www.proxim.com/support/faq/7400.shtml\n  * 3. RLNSETUP reports that I'm synchronized to my own MAC address. What\n  *    does that mean?\n  *    You are the acting Master for this network. Either you are\n  *    configured as the Master or as an Alternate Master. If you are an\n  *    Alternate Master, you may be out of range or on a different Domain\n  *    and Security ID from the true Master.\n  */\n\n\t\t\tprintf(\"%s: nothing to sync to; now master \",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t}\n\t\telse\n\t\t\tprintf(\"%s: synchronised to \", sc->sc_dev.dv_xname);\n\t\tprintf(\"%.11s (%s) channel %d/%d\\n\",\n\t\t    syncp->mastername,\n\t\t    ether_sprintf(syncp->enaddr),\n\t\t    syncp->channel,\n\t\t    syncp->subchannel);\n\n\t\t/* Record the new circumstances. */\n\t\tsc->sc_param.rp_channel = syncp->channel;\n\t\tsc->sc_param.rp_subchannel = syncp->subchannel;\n\t\tsc->sc_state |= RLN_STATE_SYNC;\n\n\t\t/* Resume sending. */\n\t\ts = splnet();\n\t\trlnstart(ifp);\n\t\tsplx(s);\n\t\tbreak;\n\n\tcase RLN_MM_CMD('a', 5):\t\t\t/* a4: Lost sync. */\n\t\tprintf(\"%s: lost sync\\n\", sc->sc_dev.dv_xname);\n\t\tsc->sc_state &= ~RLN_STATE_SYNC;\n\t\tbreak;\n\n\tcase RLN_MM_CMD('a', 18):\t\t\t/* a18: Roaming. */\n\t\tprintf(\"%s: roaming\\n\", sc->sc_dev.dv_xname);\n\t\tbreak;\n\tdefault:\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: msg `%c%d' seq %d data {\",\n\t\t    sc->sc_dev.dv_xname, \n\t\t    hdr->cmd_letter, hdr->cmd_fn, hdr->cmd_seq);\n\t\tRLNDUMPHEX(hdr, sizeof hdr);\n\t\tprintf(\":\");\n\t\tRLNDUMPHEX(data, len);\n\t\tprintf(\"}\\n\");\n#endif\n\t\tbreak;\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_rx_data",
          "args": [
            "sc",
            "&hdr",
            "sizeof hdr"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "rln_rx_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "485-522",
          "snippet": "int\nrln_rx_data(sc, buf, len)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\t/* RxData() */\n\tstruct rln_pdata\tpd = { 0, 0 };\n\tint\t\t\ts;\n\tint\t\t\ti;\n\tu_int8_t\t\tstatus;\n\n\tdprintf(\" Rd[\");\n\trln_status_rx_write(sc, RLN_STATUS_RX_HILEN_ACCEPT);\n\trln_status_rx_int(sc);\n\ts = spl0();\n\tfor (i = 0; i < 600; i++) {\n\t\tstatus = rln_status_rx_read(sc);\n\t\tif (status == RLN_STATUS_RX_XFR)\n\t\t\tbreak;\n\t\tDELAY(1000);\n\t}\n\tsplx(s);\n\tif (status != RLN_STATUS_RX_XFR) {\n\t\tdprintf(\"]=-1\");\n\t\treturn (-1);\n\t}\n\n\trln_rx_pdata(sc, buf, len, &pd);\n#ifdef DIAGNOSTIC\n\t/* We should have nothing left over. */\n\tif (pd.p_nremain || len & 1)\n\t\tpanic(\"rln_rx_data: leftover\");\n#endif\n\n\tdprintf(\"]=0\");\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_rx_data(sc, buf, len)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\t/* RxData() */\n\tstruct rln_pdata\tpd = { 0, 0 };\n\tint\t\t\ts;\n\tint\t\t\ti;\n\tu_int8_t\t\tstatus;\n\n\tdprintf(\" Rd[\");\n\trln_status_rx_write(sc, RLN_STATUS_RX_HILEN_ACCEPT);\n\trln_status_rx_int(sc);\n\ts = spl0();\n\tfor (i = 0; i < 600; i++) {\n\t\tstatus = rln_status_rx_read(sc);\n\t\tif (status == RLN_STATUS_RX_XFR)\n\t\t\tbreak;\n\t\tDELAY(1000);\n\t}\n\tsplx(s);\n\tif (status != RLN_STATUS_RX_XFR) {\n\t\tdprintf(\"]=-1\");\n\t\treturn (-1);\n\t}\n\n\trln_rx_pdata(sc, buf, len, &pd);\n#ifdef DIAGNOSTIC\n\t/* We should have nothing left over. */\n\tif (pd.p_nremain || len & 1)\n\t\tpanic(\"rln_rx_data: leftover\");\n#endif\n\n\tdprintf(\"]=0\");\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_rx_end",
          "args": [
            "sc"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "rln_rx_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "524-535",
          "snippet": "void\nrln_rx_end(sc)\n\tstruct rln_softc * sc;\n{\n\t/* EndOfRx() */\n\n\tdprintf(\" Re[\");\n\trln_status_rx_write(sc, RLN_STATUS_RX_XFR_COMPLETE);\n\trln_status_rx_int(sc);\n\t/* rln_wakeup(sc, 0); */\n\tdprintf(\"]\");\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nrln_rx_end(sc)\n\tstruct rln_softc * sc;\n{\n\t/* EndOfRx() */\n\n\tdprintf(\" Re[\");\n\trln_status_rx_write(sc, RLN_STATUS_RX_XFR_COMPLETE);\n\trln_status_rx_int(sc);\n\t/* rln_wakeup(sc, 0); */\n\tdprintf(\"]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_need_reset",
          "args": [
            "sc"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_rx_request",
          "args": [
            "sc",
            "300"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "rln_rx_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "355-425",
          "snippet": "int\nrln_rx_request(sc, timeo)\n\tstruct rln_softc *\tsc;\n\tint \t\t\ttimeo;\t/* milliseconds */\n{\n\t/* RxRequest */\n\tint\t\t\ts;\n\tint\t\t\tlen = 0;\n\tint\t\t\ti;\n\tu_int8_t\t\tstatus;\n\tu_int8_t\t\thi, lo;\n\n\tdprintf(\" Rr[\");\n\tstatus = rln_status_rx_read(sc);\n\n\t/* Short wait for states 1|5|6. */\n\ts = spl0();\n\tfor (i = 0; i < timeo; i++) {\n\t\tif (status == RLN_STATUS_RX_LOLEN_AVAIL || \n\t\t    status == RLN_STATUS_RX_HILEN_AVAIL || \n\t\t    status == RLN_STATUS_RX_ERROR)\n\t\t\tbreak;\n\t\tDELAY(1000);\n\t\tstatus = rln_status_rx_read(sc);\n\t}\n\tsplx(s);\n\tdprintf(\" (%dms)\",i);\n\n\tif (sc->sc_width == 16) {\n\t\tif (status != RLN_STATUS_RX_HILEN_AVAIL)\n\t\t\tgoto badstatus_quiet;\n\t\t/* Read 2 octets. */\n\t\tlen = rln_data_read_2(sc);\n\t} else if (sc->sc_width == 8) {\n\t\tif (status != RLN_STATUS_RX_LOLEN_AVAIL)\n\t\t\tgoto badstatus_quiet;\n\t\t/* Read low octet. */\n\t\tlo = rln_data_read_1(sc);\n\t\trln_status_rx_write(sc, RLN_STATUS_RX_LOLEN_ACCEPT);\n\t\trln_status_rx_int(sc);\n\t\ts = spl0();\n\t\tfor (i = 0; i < 600; i++) {\n\t\t\tstatus = rln_status_rx_read(sc);\n\t\t\tif (status == RLN_STATUS_RX_HILEN_AVAIL)\n\t\t\t\tbreak;\n\t\t\tDELAY(1000);\n\t\t}\n\t\tsplx(s);\n\t\tif (status != RLN_STATUS_RX_HILEN_AVAIL)\n\t\t\tgoto badstatus;\n\t\t/* Read high octet. */\n\t\thi = rln_data_read_1(sc);\n\t\tlen = lo | (hi << 8);\n\t}\n#ifdef DIAGNOSTIC\n\telse\n\t\tpanic(\"rln: bus width %d\", sc->sc_width);\n#endif\n\n\tdprintf(\" len=%d]\", len);\n\treturn (len);\n\nbadstatus:\n\tprintf(\"%s: rx_request timed out, status %02x\\n\", \n\t    sc->sc_dev.dv_xname, status);\nbadstatus_quiet:\n\tif (status == RLN_STATUS_RX_ERROR)\n\t\tprintf(\"%s: rx protocol error (nak)\\n\", sc->sc_dev.dv_xname);\n\tdprintf(\"]\");\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_rx_request(sc, timeo)\n\tstruct rln_softc *\tsc;\n\tint \t\t\ttimeo;\t/* milliseconds */\n{\n\t/* RxRequest */\n\tint\t\t\ts;\n\tint\t\t\tlen = 0;\n\tint\t\t\ti;\n\tu_int8_t\t\tstatus;\n\tu_int8_t\t\thi, lo;\n\n\tdprintf(\" Rr[\");\n\tstatus = rln_status_rx_read(sc);\n\n\t/* Short wait for states 1|5|6. */\n\ts = spl0();\n\tfor (i = 0; i < timeo; i++) {\n\t\tif (status == RLN_STATUS_RX_LOLEN_AVAIL || \n\t\t    status == RLN_STATUS_RX_HILEN_AVAIL || \n\t\t    status == RLN_STATUS_RX_ERROR)\n\t\t\tbreak;\n\t\tDELAY(1000);\n\t\tstatus = rln_status_rx_read(sc);\n\t}\n\tsplx(s);\n\tdprintf(\" (%dms)\",i);\n\n\tif (sc->sc_width == 16) {\n\t\tif (status != RLN_STATUS_RX_HILEN_AVAIL)\n\t\t\tgoto badstatus_quiet;\n\t\t/* Read 2 octets. */\n\t\tlen = rln_data_read_2(sc);\n\t} else if (sc->sc_width == 8) {\n\t\tif (status != RLN_STATUS_RX_LOLEN_AVAIL)\n\t\t\tgoto badstatus_quiet;\n\t\t/* Read low octet. */\n\t\tlo = rln_data_read_1(sc);\n\t\trln_status_rx_write(sc, RLN_STATUS_RX_LOLEN_ACCEPT);\n\t\trln_status_rx_int(sc);\n\t\ts = spl0();\n\t\tfor (i = 0; i < 600; i++) {\n\t\t\tstatus = rln_status_rx_read(sc);\n\t\t\tif (status == RLN_STATUS_RX_HILEN_AVAIL)\n\t\t\t\tbreak;\n\t\t\tDELAY(1000);\n\t\t}\n\t\tsplx(s);\n\t\tif (status != RLN_STATUS_RX_HILEN_AVAIL)\n\t\t\tgoto badstatus;\n\t\t/* Read high octet. */\n\t\thi = rln_data_read_1(sc);\n\t\tlen = lo | (hi << 8);\n\t}\n#ifdef DIAGNOSTIC\n\telse\n\t\tpanic(\"rln: bus width %d\", sc->sc_width);\n#endif\n\n\tdprintf(\" len=%d]\", len);\n\treturn (len);\n\nbadstatus:\n\tprintf(\"%s: rx_request timed out, status %02x\\n\", \n\t    sc->sc_dev.dv_xname, status);\nbadstatus_quiet:\n\tif (status == RLN_STATUS_RX_ERROR)\n\t\tprintf(\"%s: rx protocol error (nak)\\n\", sc->sc_dev.dv_xname);\n\tdprintf(\"]\");\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" si(\""
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splsoftnet",
          "args": [],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\trlnsoftintr;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\nstruct rln_mm_cmd *hdr;\n\nvoid\nrlnsoftintr(arg)\n\tvoid * arg;\n{\n\tstruct rln_softc *sc = (struct rln_softc *)arg;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint len;\n\tu_int8_t w;\n\tstruct rln_mm_cmd hdr;\n\tint s;\n\n\ts = splsoftnet();\n\tdprintf(\" si(\");\n\n    again:\n\t/* Save wakeup state. */\n\tw = rln_wakeup(sc, RLN_WAKEUP_SET);\n\n\tif ((len = rln_rx_request(sc, 300)) < 0) {\n\t\t/* Error in transfer. */\n\t\trln_need_reset(sc);\n\t\trln_rx_end(sc);\n\t} else if (len < sizeof hdr) {\n\t\t/* Short message. */\n\t\trln_rx_end(sc);\n\t\tprintf(\"%s: short msg (%d)\\n\", sc->sc_dev.dv_xname, len);\n\t\tifp->if_ierrors++;\n\t} else {\n\t\t/* Valid message: read header and process. */\n\t\trln_rx_data(sc, &hdr, sizeof hdr);\n\t\trlnread(sc, &hdr, len);\n\t}\n\n\t/* Ensure that wakeup state is unchanged if transmitting. */\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\tw |= RLN_WAKEUP_NOCHANGE;\n\trln_wakeup(sc, w);\n\n\t/* Check for more interrupts. */\n\tif ((sc->sc_state & RLN_STATE_NEEDINIT) == 0 && \n\t    rln_status_rx_ready(sc)) {\n\t\tif (rln_status_rx_read(sc) == RLN_STATUS_RX_ERROR) {\n#ifdef DIAGNOSTIC\n\t\t\tprintf(\"%s: protocol error\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\t\tDELAY(100 * 1000);\t/* Woah, baby. */\n\t\t\trln_clear_nak(sc);\n\t\t} else {\n#ifdef DIAGNOSTIC\n\t\t\tprintf(\"%s: intr piggyback\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\trln_eoi(sc);\n\trln_enable(sc, 1);\n\n\tdprintf(\")\");\n\tsplx(s);\n}"
  },
  {
    "function_name": "rlnintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "407-427",
    "snippet": "int\nrlnintr(arg)\n\tvoid *\targ;\n{\n\tstruct rln_softc * sc = (struct rln_softc *)arg;\n\textern int cold;\n\n\tdprintf(\"!\");\n\n\t/* Tell card not to interrupt any more. */\n\trln_enable(sc, 0);\n\n\tif (cold)\n\t\t/* During autoconfig - must handle interrupts now. */\n\t\trlnsoftintr(sc);\n\telse\n\t\t/* Handle later. */\n\t\ttimeout(rlnsoftintr, sc, 1);\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\trlnsoftintr",
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "rlnsoftintr",
            "sc",
            "1"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rlnsoftintr",
          "args": [
            "sc"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "rlnsoftintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
          "lines": "430-490",
          "snippet": "void\nrlnsoftintr(arg)\n\tvoid * arg;\n{\n\tstruct rln_softc *sc = (struct rln_softc *)arg;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint len;\n\tu_int8_t w;\n\tstruct rln_mm_cmd hdr;\n\tint s;\n\n\ts = splsoftnet();\n\tdprintf(\" si(\");\n\n    again:\n\t/* Save wakeup state. */\n\tw = rln_wakeup(sc, RLN_WAKEUP_SET);\n\n\tif ((len = rln_rx_request(sc, 300)) < 0) {\n\t\t/* Error in transfer. */\n\t\trln_need_reset(sc);\n\t\trln_rx_end(sc);\n\t} else if (len < sizeof hdr) {\n\t\t/* Short message. */\n\t\trln_rx_end(sc);\n\t\tprintf(\"%s: short msg (%d)\\n\", sc->sc_dev.dv_xname, len);\n\t\tifp->if_ierrors++;\n\t} else {\n\t\t/* Valid message: read header and process. */\n\t\trln_rx_data(sc, &hdr, sizeof hdr);\n\t\trlnread(sc, &hdr, len);\n\t}\n\n\t/* Ensure that wakeup state is unchanged if transmitting. */\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\tw |= RLN_WAKEUP_NOCHANGE;\n\trln_wakeup(sc, w);\n\n\t/* Check for more interrupts. */\n\tif ((sc->sc_state & RLN_STATE_NEEDINIT) == 0 && \n\t    rln_status_rx_ready(sc)) {\n\t\tif (rln_status_rx_read(sc) == RLN_STATUS_RX_ERROR) {\n#ifdef DIAGNOSTIC\n\t\t\tprintf(\"%s: protocol error\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\t\tDELAY(100 * 1000);\t/* Woah, baby. */\n\t\t\trln_clear_nak(sc);\n\t\t} else {\n#ifdef DIAGNOSTIC\n\t\t\tprintf(\"%s: intr piggyback\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\trln_eoi(sc);\n\trln_enable(sc, 1);\n\n\tdprintf(\")\");\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\trlnsoftintr",
            "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;",
            "struct rln_mm_cmd *hdr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\trlnsoftintr;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\nstruct rln_mm_cmd *hdr;\n\nvoid\nrlnsoftintr(arg)\n\tvoid * arg;\n{\n\tstruct rln_softc *sc = (struct rln_softc *)arg;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint len;\n\tu_int8_t w;\n\tstruct rln_mm_cmd hdr;\n\tint s;\n\n\ts = splsoftnet();\n\tdprintf(\" si(\");\n\n    again:\n\t/* Save wakeup state. */\n\tw = rln_wakeup(sc, RLN_WAKEUP_SET);\n\n\tif ((len = rln_rx_request(sc, 300)) < 0) {\n\t\t/* Error in transfer. */\n\t\trln_need_reset(sc);\n\t\trln_rx_end(sc);\n\t} else if (len < sizeof hdr) {\n\t\t/* Short message. */\n\t\trln_rx_end(sc);\n\t\tprintf(\"%s: short msg (%d)\\n\", sc->sc_dev.dv_xname, len);\n\t\tifp->if_ierrors++;\n\t} else {\n\t\t/* Valid message: read header and process. */\n\t\trln_rx_data(sc, &hdr, sizeof hdr);\n\t\trlnread(sc, &hdr, len);\n\t}\n\n\t/* Ensure that wakeup state is unchanged if transmitting. */\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\tw |= RLN_WAKEUP_NOCHANGE;\n\trln_wakeup(sc, w);\n\n\t/* Check for more interrupts. */\n\tif ((sc->sc_state & RLN_STATE_NEEDINIT) == 0 && \n\t    rln_status_rx_ready(sc)) {\n\t\tif (rln_status_rx_read(sc) == RLN_STATUS_RX_ERROR) {\n#ifdef DIAGNOSTIC\n\t\t\tprintf(\"%s: protocol error\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\t\tDELAY(100 * 1000);\t/* Woah, baby. */\n\t\t\trln_clear_nak(sc);\n\t\t} else {\n#ifdef DIAGNOSTIC\n\t\t\tprintf(\"%s: intr piggyback\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\trln_eoi(sc);\n\trln_enable(sc, 1);\n\n\tdprintf(\")\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_enable",
          "args": [
            "sc",
            "0"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "rln_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "48-67",
          "snippet": "int\nrln_enable(sc, enable)\n\tstruct rln_softc * sc;\n\tint\t\tenable;\n{\n\tint\t\ts;\n\tint\t\twas_enabled;\n\n\ts = splhigh();\n\twas_enabled = (sc->sc_intsel & RLN_INTSEL_ENABLE) ? 1 : 0;\n\tif (enable != was_enabled) {\n\t\tif (enable)\n\t\t\tsc->sc_intsel |= RLN_INTSEL_ENABLE;\n\t\telse\n\t\t\tsc->sc_intsel &=~RLN_INTSEL_ENABLE;\n\t\t_rln_register_write_1(sc, RLN_REG_INTSEL, sc->sc_intsel);\n\t}\n\tsplx(s);\n\treturn (was_enabled);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_enable(sc, enable)\n\tstruct rln_softc * sc;\n\tint\t\tenable;\n{\n\tint\t\ts;\n\tint\t\twas_enabled;\n\n\ts = splhigh();\n\twas_enabled = (sc->sc_intsel & RLN_INTSEL_ENABLE) ? 1 : 0;\n\tif (enable != was_enabled) {\n\t\tif (enable)\n\t\t\tsc->sc_intsel |= RLN_INTSEL_ENABLE;\n\t\telse\n\t\t\tsc->sc_intsel &=~RLN_INTSEL_ENABLE;\n\t\t_rln_register_write_1(sc, RLN_REG_INTSEL, sc->sc_intsel);\n\t}\n\tsplx(s);\n\treturn (was_enabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"!\""
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\trlnsoftintr;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrlnintr(arg)\n\tvoid *\targ;\n{\n\tstruct rln_softc * sc = (struct rln_softc *)arg;\n\textern int cold;\n\n\tdprintf(\"!\");\n\n\t/* Tell card not to interrupt any more. */\n\trln_enable(sc, 0);\n\n\tif (cold)\n\t\t/* During autoconfig - must handle interrupts now. */\n\t\trlnsoftintr(sc);\n\telse\n\t\t/* Handle later. */\n\t\ttimeout(rlnsoftintr, sc, 1);\n\n\treturn (1);\n}"
  },
  {
    "function_name": "rlnwatchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "394-404",
    "snippet": "void\nrlnwatchdog(ifp)\n\tstruct ifnet * ifp;\n{\n\tstruct rln_softc * sc = (struct rln_softc *)ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++sc->sc_arpcom.ac_if.if_oerrors;\n\trlninit(sc);\n\trln_enable(sc, 1);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\trlninit",
      "void\trlnwatchdog",
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rln_enable",
          "args": [
            "sc",
            "1"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "rln_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "48-67",
          "snippet": "int\nrln_enable(sc, enable)\n\tstruct rln_softc * sc;\n\tint\t\tenable;\n{\n\tint\t\ts;\n\tint\t\twas_enabled;\n\n\ts = splhigh();\n\twas_enabled = (sc->sc_intsel & RLN_INTSEL_ENABLE) ? 1 : 0;\n\tif (enable != was_enabled) {\n\t\tif (enable)\n\t\t\tsc->sc_intsel |= RLN_INTSEL_ENABLE;\n\t\telse\n\t\t\tsc->sc_intsel &=~RLN_INTSEL_ENABLE;\n\t\t_rln_register_write_1(sc, RLN_REG_INTSEL, sc->sc_intsel);\n\t}\n\tsplx(s);\n\treturn (was_enabled);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_enable(sc, enable)\n\tstruct rln_softc * sc;\n\tint\t\tenable;\n{\n\tint\t\ts;\n\tint\t\twas_enabled;\n\n\ts = splhigh();\n\twas_enabled = (sc->sc_intsel & RLN_INTSEL_ENABLE) ? 1 : 0;\n\tif (enable != was_enabled) {\n\t\tif (enable)\n\t\t\tsc->sc_intsel |= RLN_INTSEL_ENABLE;\n\t\telse\n\t\t\tsc->sc_intsel &=~RLN_INTSEL_ENABLE;\n\t\t_rln_register_write_1(sc, RLN_REG_INTSEL, sc->sc_intsel);\n\t}\n\tsplx(s);\n\treturn (was_enabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rlninit",
          "args": [
            "sc"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "rlninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
          "lines": "152-211",
          "snippet": "void\nrlninit(sc)\n\tstruct rln_softc * sc;\n{\n\t/* LLDInit() */\n\tstruct ifnet * ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\textern int cold;\n\n\ts = splnet();\n\tdprintf(\" [init]\");\n\n\tsc->sc_intsel = 0;\n\tsc->sc_status = 0;\n\tsc->sc_control = 0;\n\tifp->if_flags &= ~IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Do a hard reset. */\n\tif (rln_reset(sc)) {\n\t\tprintf(\"%s: could not reset card\\n\", sc->sc_dev.dv_xname);\n\t\tgoto fail;\n\t}\n\tsc->sc_state = 0;\t/* Also clears RLN_STATE_NEEDINIT. */\n\n\t/* Use this host's name as a master name. */\n\tif (!cold && sc->sc_param.rp_master[0] == '\\0') {\n\t\tbcopy(hostname, sc->sc_param.rp_master, \n\t\t    min(hostnamelen, sizeof sc->sc_param.rp_master));\n\t}\n\n\trln_enable(sc, 1);\n\n\t/* Initialise operational params. */\n\tif (rln_sendinit(sc)) {\n\t\tprintf(\"%s: could not set card parameters\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto fail;\n\t}\n#if 0\n\trln_roamconfig(sc);\n\t/* rln_lockprom(sc); */\n\t/* SendSetITO() */\n\trln_multicast(sc, 1);\n\trln_roam(sc);\n\n\t/* Synchronise with something. */\n\trln_searchsync(sc);\n#endif\n\tifp->if_flags |= IFF_RUNNING;\n\trlnstart(ifp);\n\tsplx(s);\n\n\treturn;\n\n    fail:\n\tifp->if_flags &= ~IFF_UP;\n\tsplx(s);\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\trlninit",
            "void\trlnstart",
            "int\trln_sendinit",
            "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\trlninit;\nvoid\trlnstart;\nint\trln_sendinit;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nvoid\nrlninit(sc)\n\tstruct rln_softc * sc;\n{\n\t/* LLDInit() */\n\tstruct ifnet * ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\textern int cold;\n\n\ts = splnet();\n\tdprintf(\" [init]\");\n\n\tsc->sc_intsel = 0;\n\tsc->sc_status = 0;\n\tsc->sc_control = 0;\n\tifp->if_flags &= ~IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Do a hard reset. */\n\tif (rln_reset(sc)) {\n\t\tprintf(\"%s: could not reset card\\n\", sc->sc_dev.dv_xname);\n\t\tgoto fail;\n\t}\n\tsc->sc_state = 0;\t/* Also clears RLN_STATE_NEEDINIT. */\n\n\t/* Use this host's name as a master name. */\n\tif (!cold && sc->sc_param.rp_master[0] == '\\0') {\n\t\tbcopy(hostname, sc->sc_param.rp_master, \n\t\t    min(hostnamelen, sizeof sc->sc_param.rp_master));\n\t}\n\n\trln_enable(sc, 1);\n\n\t/* Initialise operational params. */\n\tif (rln_sendinit(sc)) {\n\t\tprintf(\"%s: could not set card parameters\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto fail;\n\t}\n#if 0\n\trln_roamconfig(sc);\n\t/* rln_lockprom(sc); */\n\t/* SendSetITO() */\n\trln_multicast(sc, 1);\n\trln_roam(sc);\n\n\t/* Synchronise with something. */\n\trln_searchsync(sc);\n#endif\n\tifp->if_flags |= IFF_RUNNING;\n\trlnstart(ifp);\n\tsplx(s);\n\n\treturn;\n\n    fail:\n\tifp->if_flags &= ~IFF_UP;\n\tsplx(s);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: device timeout\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\trlninit;\nvoid\trlnwatchdog;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nvoid\nrlnwatchdog(ifp)\n\tstruct ifnet * ifp;\n{\n\tstruct rln_softc * sc = (struct rln_softc *)ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++sc->sc_arpcom.ac_if.if_oerrors;\n\trlninit(sc);\n\trln_enable(sc, 1);\n}"
  },
  {
    "function_name": "rln_transmit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "301-391",
    "snippet": "int\nrln_transmit(sc, m0, len, pad)\n\tstruct rln_softc *\tsc;\n\tstruct mbuf *\tm0;\n\tint \t\tlen;\n\tint \t\tpad;\n{\n\tstruct mbuf *\tm;\n\tint \t\tzfirst;\n\tint \t\tactlen;\n\tint \t\ttlen = len + pad;\n\tstruct rln_msg_tx_state state;\n\tstatic u_int8_t zeroes[60];\n\tstruct rln_mm_sendpacket cmd = { RLN_MM_SENDPACKET };\n\n\t/* Does the packet start with a zero bit? */\n\tzfirst = ((*mtod(m0, u_int8_t *) & 1) == 0);\n\n\tcmd.mode = \n\t\tRLN_MM_SENDPACKET_MODE_BIT7 | \n\t\t   (zfirst ? RLN_MM_SENDPACKET_MODE_ZFIRST : 0) |\n\t\t   (0 ? RLN_MM_SENDPACKET_MODE_QFSK : 0),\t/* sc->qfsk? */\n\tcmd.power = 0x70;\t/* 0x70 or 0xf0 */\n\tcmd.length_lo = htons(4 + tlen) & 0xff;\n\tcmd.length_hi = (htons(4 + tlen) >> 8) & 0xff;\n\tcmd.xxx1 = 0;\n\tcmd.xxx2 = 0;\n\tcmd.xxx3 = 0;\n\n\t/* A unique packet-level sequence number, independent of sc_seq. */\n\tcmd.sequence = sc->sc_txseq;\n\tsc->sc_txseq++;\n\tif (sc->sc_txseq > RLN_MAXSEQ)\n\t\tsc->sc_txseq = 0;\n\n\tdprintf(\" T[%d+%d\", len, pad);\n\n\tif (rln_msg_tx_start(sc, &cmd, sizeof cmd + tlen, &state))\n\t\tgoto error;\n\n\tcmd.mm_cmd.cmd_seq = rln_newseq(sc);\n\n\t/* Send the SENDPACKET command header  */\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname,\n\t    cmd.mm_cmd.cmd_letter, cmd.mm_cmd.cmd_fn, cmd.mm_cmd.cmd_seq);\n\tRLNDUMPHEX(&cmd, sizeof cmd);\n\tprintf(\":\");\n#endif\n\trln_msg_tx_data(sc, &cmd, sizeof cmd, &state);\n\n\t/* XXX do we need to insert a hardware header here??? */\n\n\t/* Follow the header immediately with the packet payload */\n\tactlen = 0;\n\tfor (m = m0; m; m = m->m_next)\t{\n\t\tif (m->m_len) {\n#ifdef RLNDUMP\n\t\t\tRLNDUMPHEX(mtod(m, void *), m->m_len);\n#endif\n\t\t\trln_msg_tx_data(sc, mtod(m, void *), m->m_len, &state);\n\t\t}\n\t\tif (m->m_next)\n\t\t\tprintf(\"|\");\n\t\tactlen += m->m_len;\n\t}\n#ifdef DIAGNOSTIC\n\tif (actlen != len)\n\t\tpanic(\"rln_transmit: len %d != %d\", actlen, len);\n\tif (pad > sizeof zeroes)\n\t\tpanic(\"rln_transmit: pad %d > %d\", pad, sizeof zeroes);\n#endif\n\tif (pad) {\n#ifdef RLNDUMP\n\t\tprintf(\":\");\n\t\tRLNDUMPHEX(zeroes, pad);\n#endif\n\t\trln_msg_tx_data(sc, zeroes, pad, &state);\n\t}\n\n#ifdef RLNDUMP\n\tprintf(\"\\n\");\n#endif\n\tif (rln_msg_tx_end(sc, &state))\n\t\tgoto error;\n\treturn (0);\n\n    error:\n\tdprintf(\" error]\");\n\treturn (-1);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\trln_transmit",
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" error]\""
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_msg_tx_end",
          "args": [
            "sc",
            "&state"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "rln_msg_tx_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "638-659",
          "snippet": "int\nrln_msg_tx_end(sc, state)\n\tstruct rln_softc *\tsc;\n\tstruct rln_msg_tx_state * state;\n{\n\tint\t\t\tret;\n\n\t/* Flush the tx buffer. */\n\tif (state->pd.p_nremain)\n\t\trln_msg_tx_data(sc, NULL, 0, state);\n\n#ifdef DIAGNOSTIC\n\tif (state->pd.p_nremain)\n\t\tpanic(\"rln_msg_tx_end remain %d\", state->pd.p_nremain);\n#endif\n\tret = rln_tx_end(sc);\n\tif (sc->sc_arpcom.ac_if.if_flags & IFF_OACTIVE)\n\t\tstate->w = RLN_WAKEUP_NOCHANGE;\n\trln_wakeup(sc, state->w);\n\trln_enable(sc, state->ien);\n\treturn (ret);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\trln_tx_end"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\trln_tx_end;\n\nint\nrln_msg_tx_end(sc, state)\n\tstruct rln_softc *\tsc;\n\tstruct rln_msg_tx_state * state;\n{\n\tint\t\t\tret;\n\n\t/* Flush the tx buffer. */\n\tif (state->pd.p_nremain)\n\t\trln_msg_tx_data(sc, NULL, 0, state);\n\n#ifdef DIAGNOSTIC\n\tif (state->pd.p_nremain)\n\t\tpanic(\"rln_msg_tx_end remain %d\", state->pd.p_nremain);\n#endif\n\tret = rln_tx_end(sc);\n\tif (sc->sc_arpcom.ac_if.if_flags & IFF_OACTIVE)\n\t\tstate->w = RLN_WAKEUP_NOCHANGE;\n\trln_wakeup(sc, state->w);\n\trln_enable(sc, state->ien);\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_msg_tx_data",
          "args": [
            "sc",
            "zeroes",
            "pad",
            "&state"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "rln_msg_tx_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "587-635",
          "snippet": "void\nrln_msg_tx_data(sc, buf, len, state)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tu_int16_t\t\tlen;\n\tstruct rln_msg_tx_state * state;\n{\n\tchar *\t\t\tdata = (char *)buf;\n\n\tif (sc->sc_width == 16 && state->pd.p_nremain) {\n\t\t/* XXX htons() needed? */\n\t\tunion {\n\t\t\tu_int8_t  b[2];\n\t\t\tu_int16_t w;\n\t\t} u;\n\n\t\tu.b[0] = state->pd.p_data;\n\t\tif (len) {\n\t\t\tu.b[1] = *data++;\n\t\t\tlen--;\n\t\t} else\n\t\t\tu.b[1] = '\\0';\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D<%02x%02x\", u.b[0], u.b[1]);\n#endif\n\t\trln_data_write_2(sc, u.w);\n\t\tstate->pd.p_nremain = 0;\n\t} \n\n\tif (len) {\n\t\tif (sc->sc_width == 16) {\n\t\t\tif (len >= 2)\n\t\t\t\trln_data_write_multi_2(sc, buf, len / 2);\n\t\t\tif (len & 1) {\n\t\t\t\tstate->pd.p_nremain = 1;\n\t\t\t\tstate->pd.p_data = data[len - 1];\n\t\t\t}\n\t\t} else if (sc->sc_width == 8)\n\t\t\trln_data_write_multi_1(sc, buf, len);\n#ifdef DIAGNOSTIC\n\t\telse\n\t\t\tpanic(\"rln_msg_tx_data width %d\", sc->sc_width);\n#endif\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D<\"); \n\t\tdprinthex(data, len);\n#endif\n\t}\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nrln_msg_tx_data(sc, buf, len, state)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tu_int16_t\t\tlen;\n\tstruct rln_msg_tx_state * state;\n{\n\tchar *\t\t\tdata = (char *)buf;\n\n\tif (sc->sc_width == 16 && state->pd.p_nremain) {\n\t\t/* XXX htons() needed? */\n\t\tunion {\n\t\t\tu_int8_t  b[2];\n\t\t\tu_int16_t w;\n\t\t} u;\n\n\t\tu.b[0] = state->pd.p_data;\n\t\tif (len) {\n\t\t\tu.b[1] = *data++;\n\t\t\tlen--;\n\t\t} else\n\t\t\tu.b[1] = '\\0';\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D<%02x%02x\", u.b[0], u.b[1]);\n#endif\n\t\trln_data_write_2(sc, u.w);\n\t\tstate->pd.p_nremain = 0;\n\t} \n\n\tif (len) {\n\t\tif (sc->sc_width == 16) {\n\t\t\tif (len >= 2)\n\t\t\t\trln_data_write_multi_2(sc, buf, len / 2);\n\t\t\tif (len & 1) {\n\t\t\t\tstate->pd.p_nremain = 1;\n\t\t\t\tstate->pd.p_data = data[len - 1];\n\t\t\t}\n\t\t} else if (sc->sc_width == 8)\n\t\t\trln_data_write_multi_1(sc, buf, len);\n#ifdef DIAGNOSTIC\n\t\telse\n\t\t\tpanic(\"rln_msg_tx_data width %d\", sc->sc_width);\n#endif\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D<\"); \n\t\tdprinthex(data, len);\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RLNDUMPHEX",
          "args": [
            "zeroes",
            "pad"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"rln_transmit: pad %d > %d\"",
            "pad",
            "sizeof zeroes"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"rln_transmit: len %d != %d\"",
            "actlen",
            "len"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "void*"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RLNDUMPHEX",
          "args": [
            "&cmd",
            "sizeof cmd"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_newseq",
          "args": [
            "sc"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "rln_newseq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "662-675",
          "snippet": "u_int8_t\nrln_newseq(sc)\n\tstruct rln_softc * sc;\n{\n\tint s;\n\tu_int8_t seq;\n\n\ts = splhigh();\n\tseq = sc->sc_pktseq++;\n\tif (sc->sc_pktseq > RLN_MAXSEQ)\n\t\tsc->sc_pktseq = 0;\n\tsplx(s);\n\treturn (seq);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_newseq(sc)\n\tstruct rln_softc * sc;\n{\n\tint s;\n\tu_int8_t seq;\n\n\ts = splhigh();\n\tseq = sc->sc_pktseq++;\n\tif (sc->sc_pktseq > RLN_MAXSEQ)\n\t\tsc->sc_pktseq = 0;\n\tsplx(s);\n\treturn (seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_msg_tx_start",
          "args": [
            "sc",
            "&cmd",
            "sizeof cmd + tlen",
            "&state"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "rln_msg_tx_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "554-585",
          "snippet": "int\nrln_msg_tx_start(sc, buf, pktlen, state)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tint\t\t\tpktlen;\n\tstruct rln_msg_tx_state * state;\n{\n\tstruct rln_mm_cmd *\tcmd = (struct rln_mm_cmd *)buf;\n\tint\t\t\tret;\n\n\tstate->ien = rln_enable(sc, 0);\n\tstate->pd.p_nremain = 0;\n\n\tif (!(cmd->cmd_letter == 'A' && cmd->cmd_fn == 6)) \t/* Standby. */\n\t\tstate->w = rln_wakeup(sc, RLN_WAKEUP_SET); \n\telse\n\t\tstate->w = RLN_WAKEUP_NOCHANGE;\n\n\tret = rln_tx_request(sc, pktlen);\n\tif (ret == 2) {\n\t\trln_clear_nak(sc);\n\t\tif (sc->sc_cardtype & RLN_CTYPE_OEM)\n\t\t\trln_need_reset(sc);\n\t\tret = 2;\n\t}\n\telse if (ret == 1) {\n\t\t/* Timeout. */\n\t\trln_status_tx_write(sc, RLN_STATUS_TX_XFR);\n\t\tret = -1;\n\t}\n\treturn (ret);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\trln_tx_request"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\trln_tx_request;\n\nint\nrln_msg_tx_start(sc, buf, pktlen, state)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tint\t\t\tpktlen;\n\tstruct rln_msg_tx_state * state;\n{\n\tstruct rln_mm_cmd *\tcmd = (struct rln_mm_cmd *)buf;\n\tint\t\t\tret;\n\n\tstate->ien = rln_enable(sc, 0);\n\tstate->pd.p_nremain = 0;\n\n\tif (!(cmd->cmd_letter == 'A' && cmd->cmd_fn == 6)) \t/* Standby. */\n\t\tstate->w = rln_wakeup(sc, RLN_WAKEUP_SET); \n\telse\n\t\tstate->w = RLN_WAKEUP_NOCHANGE;\n\n\tret = rln_tx_request(sc, pktlen);\n\tif (ret == 2) {\n\t\trln_clear_nak(sc);\n\t\tif (sc->sc_cardtype & RLN_CTYPE_OEM)\n\t\t\trln_need_reset(sc);\n\t\tret = 2;\n\t}\n\telse if (ret == 1) {\n\t\t/* Timeout. */\n\t\trln_status_tx_write(sc, RLN_STATUS_TX_XFR);\n\t\tret = -1;\n\t}\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" T[%d+%d\"",
            "len",
            "pad"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "4 + tlen"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "4 + tlen"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m0",
            "u_int8_t*"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\trln_transmit;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_transmit(sc, m0, len, pad)\n\tstruct rln_softc *\tsc;\n\tstruct mbuf *\tm0;\n\tint \t\tlen;\n\tint \t\tpad;\n{\n\tstruct mbuf *\tm;\n\tint \t\tzfirst;\n\tint \t\tactlen;\n\tint \t\ttlen = len + pad;\n\tstruct rln_msg_tx_state state;\n\tstatic u_int8_t zeroes[60];\n\tstruct rln_mm_sendpacket cmd = { RLN_MM_SENDPACKET };\n\n\t/* Does the packet start with a zero bit? */\n\tzfirst = ((*mtod(m0, u_int8_t *) & 1) == 0);\n\n\tcmd.mode = \n\t\tRLN_MM_SENDPACKET_MODE_BIT7 | \n\t\t   (zfirst ? RLN_MM_SENDPACKET_MODE_ZFIRST : 0) |\n\t\t   (0 ? RLN_MM_SENDPACKET_MODE_QFSK : 0),\t/* sc->qfsk? */\n\tcmd.power = 0x70;\t/* 0x70 or 0xf0 */\n\tcmd.length_lo = htons(4 + tlen) & 0xff;\n\tcmd.length_hi = (htons(4 + tlen) >> 8) & 0xff;\n\tcmd.xxx1 = 0;\n\tcmd.xxx2 = 0;\n\tcmd.xxx3 = 0;\n\n\t/* A unique packet-level sequence number, independent of sc_seq. */\n\tcmd.sequence = sc->sc_txseq;\n\tsc->sc_txseq++;\n\tif (sc->sc_txseq > RLN_MAXSEQ)\n\t\tsc->sc_txseq = 0;\n\n\tdprintf(\" T[%d+%d\", len, pad);\n\n\tif (rln_msg_tx_start(sc, &cmd, sizeof cmd + tlen, &state))\n\t\tgoto error;\n\n\tcmd.mm_cmd.cmd_seq = rln_newseq(sc);\n\n\t/* Send the SENDPACKET command header  */\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname,\n\t    cmd.mm_cmd.cmd_letter, cmd.mm_cmd.cmd_fn, cmd.mm_cmd.cmd_seq);\n\tRLNDUMPHEX(&cmd, sizeof cmd);\n\tprintf(\":\");\n#endif\n\trln_msg_tx_data(sc, &cmd, sizeof cmd, &state);\n\n\t/* XXX do we need to insert a hardware header here??? */\n\n\t/* Follow the header immediately with the packet payload */\n\tactlen = 0;\n\tfor (m = m0; m; m = m->m_next)\t{\n\t\tif (m->m_len) {\n#ifdef RLNDUMP\n\t\t\tRLNDUMPHEX(mtod(m, void *), m->m_len);\n#endif\n\t\t\trln_msg_tx_data(sc, mtod(m, void *), m->m_len, &state);\n\t\t}\n\t\tif (m->m_next)\n\t\t\tprintf(\"|\");\n\t\tactlen += m->m_len;\n\t}\n#ifdef DIAGNOSTIC\n\tif (actlen != len)\n\t\tpanic(\"rln_transmit: len %d != %d\", actlen, len);\n\tif (pad > sizeof zeroes)\n\t\tpanic(\"rln_transmit: pad %d > %d\", pad, sizeof zeroes);\n#endif\n\tif (pad) {\n#ifdef RLNDUMP\n\t\tprintf(\":\");\n\t\tRLNDUMPHEX(zeroes, pad);\n#endif\n\t\trln_msg_tx_data(sc, zeroes, pad, &state);\n\t}\n\n#ifdef RLNDUMP\n\tprintf(\"\\n\");\n#endif\n\tif (rln_msg_tx_end(sc, &state))\n\t\tgoto error;\n\treturn (0);\n\n    error:\n\tdprintf(\" error]\");\n\treturn (-1);\n}"
  },
  {
    "function_name": "rlnstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "214-298",
    "snippet": "void\nrlnstart(ifp)\n\tstruct ifnet *\tifp;\n{\n\tstruct rln_softc * sc = (struct rln_softc *)ifp->if_softc;\n\tstruct mbuf *\tm0;\n\tint\t\tlen, pad, ret, s;\n\n\tdprintf(\" start[\");\n\n\tif (sc->sc_state & RLN_STATE_NEEDINIT)\n\t\trlninit(sc);\n\n\t/* Don't transmit if interface is busy or not running. */\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING) {\n\t\tdprintf(\" %s] \", (ifp->if_flags & IFF_OACTIVE) ? \n\t\t    \"busy\" : \"stopped\");\n\t\treturn;\n\t}\n\n\t/* Don't transmit if we are not synchronised. */\n\tif ((sc->sc_state & RLN_STATE_SYNC) == 0) {\n\t\tdprintf(\" nosync]\");\n\t\treturn;\n\t}\n\n\trln_enable(sc, 1);\n\n    startagain:\n\ts = splimp();\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tsplx(s);\n\n\tif (m0 == NULL) {\n\t\tdprintf(\" empty]\");\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/* Tap packet stream here for BPF listeners. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/* We need to use m->m_pkthdr.len, so require the header. */\n\tif ((m0->m_flags & M_PKTHDR) == 0) {\n\t\tprintf(\"%s: no mbuf header\\n\", sc->sc_dev.dv_xname);\n\t\tgoto oerror;\n\t}\n\n\tlen = m0->m_pkthdr.len;\n\n#define PACKETMIN\t(sizeof (struct ether_header) + ETHERMIN)\n#define PACKETMAX\t(sizeof (struct ether_header) + ETHERMTU + 4)\n\n\t/* Packet size has to be an even number between 60 and 1518 octets. */\n\tpad = len & 1;\n\tif (len + pad < PACKETMIN)\n\t\tpad = PACKETMIN - len;\n\n\tif (len + pad > PACKETMAX) {\n\t\tprintf(\"%s: packet too big (%d > %d)\\n\",\n\t\t    sc->sc_dev.dv_xname, len + pad,\n\t\t    PACKETMAX);\n\t\t++ifp->if_oerrors;\n\t\tm_freem(m0);\n\t\tgoto startagain;\n\t}\n\n\tret = rln_transmit(sc, m0, len, pad);\n\tif (ret)\n\t\tgoto oerror;\n\n\tifp->if_flags |= IFF_OACTIVE;\n\tm_freem(m0);\n\n\tdprintf(\" sent]\");\n\treturn;\n\noerror:\n\t++ifp->if_oerrors;\n\tm_freem(m0);\n\trln_need_reset(sc);\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define PACKETMAX\t(sizeof (struct ether_header) + ETHERMTU + 4)",
      "#define PACKETMIN\t(sizeof (struct ether_header) + ETHERMIN)"
    ],
    "globals_used": [
      "void\trlninit",
      "void\trlnstart",
      "int\trln_transmit",
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rln_need_reset",
          "args": [
            "sc"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" sent]\""
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_transmit",
          "args": [
            "sc",
            "m0",
            "len",
            "pad"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "rln_transmit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
          "lines": "301-391",
          "snippet": "int\nrln_transmit(sc, m0, len, pad)\n\tstruct rln_softc *\tsc;\n\tstruct mbuf *\tm0;\n\tint \t\tlen;\n\tint \t\tpad;\n{\n\tstruct mbuf *\tm;\n\tint \t\tzfirst;\n\tint \t\tactlen;\n\tint \t\ttlen = len + pad;\n\tstruct rln_msg_tx_state state;\n\tstatic u_int8_t zeroes[60];\n\tstruct rln_mm_sendpacket cmd = { RLN_MM_SENDPACKET };\n\n\t/* Does the packet start with a zero bit? */\n\tzfirst = ((*mtod(m0, u_int8_t *) & 1) == 0);\n\n\tcmd.mode = \n\t\tRLN_MM_SENDPACKET_MODE_BIT7 | \n\t\t   (zfirst ? RLN_MM_SENDPACKET_MODE_ZFIRST : 0) |\n\t\t   (0 ? RLN_MM_SENDPACKET_MODE_QFSK : 0),\t/* sc->qfsk? */\n\tcmd.power = 0x70;\t/* 0x70 or 0xf0 */\n\tcmd.length_lo = htons(4 + tlen) & 0xff;\n\tcmd.length_hi = (htons(4 + tlen) >> 8) & 0xff;\n\tcmd.xxx1 = 0;\n\tcmd.xxx2 = 0;\n\tcmd.xxx3 = 0;\n\n\t/* A unique packet-level sequence number, independent of sc_seq. */\n\tcmd.sequence = sc->sc_txseq;\n\tsc->sc_txseq++;\n\tif (sc->sc_txseq > RLN_MAXSEQ)\n\t\tsc->sc_txseq = 0;\n\n\tdprintf(\" T[%d+%d\", len, pad);\n\n\tif (rln_msg_tx_start(sc, &cmd, sizeof cmd + tlen, &state))\n\t\tgoto error;\n\n\tcmd.mm_cmd.cmd_seq = rln_newseq(sc);\n\n\t/* Send the SENDPACKET command header  */\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname,\n\t    cmd.mm_cmd.cmd_letter, cmd.mm_cmd.cmd_fn, cmd.mm_cmd.cmd_seq);\n\tRLNDUMPHEX(&cmd, sizeof cmd);\n\tprintf(\":\");\n#endif\n\trln_msg_tx_data(sc, &cmd, sizeof cmd, &state);\n\n\t/* XXX do we need to insert a hardware header here??? */\n\n\t/* Follow the header immediately with the packet payload */\n\tactlen = 0;\n\tfor (m = m0; m; m = m->m_next)\t{\n\t\tif (m->m_len) {\n#ifdef RLNDUMP\n\t\t\tRLNDUMPHEX(mtod(m, void *), m->m_len);\n#endif\n\t\t\trln_msg_tx_data(sc, mtod(m, void *), m->m_len, &state);\n\t\t}\n\t\tif (m->m_next)\n\t\t\tprintf(\"|\");\n\t\tactlen += m->m_len;\n\t}\n#ifdef DIAGNOSTIC\n\tif (actlen != len)\n\t\tpanic(\"rln_transmit: len %d != %d\", actlen, len);\n\tif (pad > sizeof zeroes)\n\t\tpanic(\"rln_transmit: pad %d > %d\", pad, sizeof zeroes);\n#endif\n\tif (pad) {\n#ifdef RLNDUMP\n\t\tprintf(\":\");\n\t\tRLNDUMPHEX(zeroes, pad);\n#endif\n\t\trln_msg_tx_data(sc, zeroes, pad, &state);\n\t}\n\n#ifdef RLNDUMP\n\tprintf(\"\\n\");\n#endif\n\tif (rln_msg_tx_end(sc, &state))\n\t\tgoto error;\n\treturn (0);\n\n    error:\n\tdprintf(\" error]\");\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\trln_transmit",
            "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\trln_transmit;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_transmit(sc, m0, len, pad)\n\tstruct rln_softc *\tsc;\n\tstruct mbuf *\tm0;\n\tint \t\tlen;\n\tint \t\tpad;\n{\n\tstruct mbuf *\tm;\n\tint \t\tzfirst;\n\tint \t\tactlen;\n\tint \t\ttlen = len + pad;\n\tstruct rln_msg_tx_state state;\n\tstatic u_int8_t zeroes[60];\n\tstruct rln_mm_sendpacket cmd = { RLN_MM_SENDPACKET };\n\n\t/* Does the packet start with a zero bit? */\n\tzfirst = ((*mtod(m0, u_int8_t *) & 1) == 0);\n\n\tcmd.mode = \n\t\tRLN_MM_SENDPACKET_MODE_BIT7 | \n\t\t   (zfirst ? RLN_MM_SENDPACKET_MODE_ZFIRST : 0) |\n\t\t   (0 ? RLN_MM_SENDPACKET_MODE_QFSK : 0),\t/* sc->qfsk? */\n\tcmd.power = 0x70;\t/* 0x70 or 0xf0 */\n\tcmd.length_lo = htons(4 + tlen) & 0xff;\n\tcmd.length_hi = (htons(4 + tlen) >> 8) & 0xff;\n\tcmd.xxx1 = 0;\n\tcmd.xxx2 = 0;\n\tcmd.xxx3 = 0;\n\n\t/* A unique packet-level sequence number, independent of sc_seq. */\n\tcmd.sequence = sc->sc_txseq;\n\tsc->sc_txseq++;\n\tif (sc->sc_txseq > RLN_MAXSEQ)\n\t\tsc->sc_txseq = 0;\n\n\tdprintf(\" T[%d+%d\", len, pad);\n\n\tif (rln_msg_tx_start(sc, &cmd, sizeof cmd + tlen, &state))\n\t\tgoto error;\n\n\tcmd.mm_cmd.cmd_seq = rln_newseq(sc);\n\n\t/* Send the SENDPACKET command header  */\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname,\n\t    cmd.mm_cmd.cmd_letter, cmd.mm_cmd.cmd_fn, cmd.mm_cmd.cmd_seq);\n\tRLNDUMPHEX(&cmd, sizeof cmd);\n\tprintf(\":\");\n#endif\n\trln_msg_tx_data(sc, &cmd, sizeof cmd, &state);\n\n\t/* XXX do we need to insert a hardware header here??? */\n\n\t/* Follow the header immediately with the packet payload */\n\tactlen = 0;\n\tfor (m = m0; m; m = m->m_next)\t{\n\t\tif (m->m_len) {\n#ifdef RLNDUMP\n\t\t\tRLNDUMPHEX(mtod(m, void *), m->m_len);\n#endif\n\t\t\trln_msg_tx_data(sc, mtod(m, void *), m->m_len, &state);\n\t\t}\n\t\tif (m->m_next)\n\t\t\tprintf(\"|\");\n\t\tactlen += m->m_len;\n\t}\n#ifdef DIAGNOSTIC\n\tif (actlen != len)\n\t\tpanic(\"rln_transmit: len %d != %d\", actlen, len);\n\tif (pad > sizeof zeroes)\n\t\tpanic(\"rln_transmit: pad %d > %d\", pad, sizeof zeroes);\n#endif\n\tif (pad) {\n#ifdef RLNDUMP\n\t\tprintf(\":\");\n\t\tRLNDUMPHEX(zeroes, pad);\n#endif\n\t\trln_msg_tx_data(sc, zeroes, pad, &state);\n\t}\n\n#ifdef RLNDUMP\n\tprintf(\"\\n\");\n#endif\n\tif (rln_msg_tx_end(sc, &state))\n\t\tgoto error;\n\treturn (0);\n\n    error:\n\tdprintf(\" error]\");\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: packet too big (%d > %d)\\n\"",
            "sc->sc_dev.dv_xname",
            "len + pad",
            "PACKETMAX"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m0"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" empty]\""
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_enable",
          "args": [
            "sc",
            "1"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "rln_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "48-67",
          "snippet": "int\nrln_enable(sc, enable)\n\tstruct rln_softc * sc;\n\tint\t\tenable;\n{\n\tint\t\ts;\n\tint\t\twas_enabled;\n\n\ts = splhigh();\n\twas_enabled = (sc->sc_intsel & RLN_INTSEL_ENABLE) ? 1 : 0;\n\tif (enable != was_enabled) {\n\t\tif (enable)\n\t\t\tsc->sc_intsel |= RLN_INTSEL_ENABLE;\n\t\telse\n\t\t\tsc->sc_intsel &=~RLN_INTSEL_ENABLE;\n\t\t_rln_register_write_1(sc, RLN_REG_INTSEL, sc->sc_intsel);\n\t}\n\tsplx(s);\n\treturn (was_enabled);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_enable(sc, enable)\n\tstruct rln_softc * sc;\n\tint\t\tenable;\n{\n\tint\t\ts;\n\tint\t\twas_enabled;\n\n\ts = splhigh();\n\twas_enabled = (sc->sc_intsel & RLN_INTSEL_ENABLE) ? 1 : 0;\n\tif (enable != was_enabled) {\n\t\tif (enable)\n\t\t\tsc->sc_intsel |= RLN_INTSEL_ENABLE;\n\t\telse\n\t\t\tsc->sc_intsel &=~RLN_INTSEL_ENABLE;\n\t\t_rln_register_write_1(sc, RLN_REG_INTSEL, sc->sc_intsel);\n\t}\n\tsplx(s);\n\treturn (was_enabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" nosync]\""
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" %s] \"",
            "(ifp->if_flags & IFF_OACTIVE) ? \n\t\t    \"busy\" : \"stopped\""
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlninit",
          "args": [
            "sc"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "rlninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
          "lines": "152-211",
          "snippet": "void\nrlninit(sc)\n\tstruct rln_softc * sc;\n{\n\t/* LLDInit() */\n\tstruct ifnet * ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\textern int cold;\n\n\ts = splnet();\n\tdprintf(\" [init]\");\n\n\tsc->sc_intsel = 0;\n\tsc->sc_status = 0;\n\tsc->sc_control = 0;\n\tifp->if_flags &= ~IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Do a hard reset. */\n\tif (rln_reset(sc)) {\n\t\tprintf(\"%s: could not reset card\\n\", sc->sc_dev.dv_xname);\n\t\tgoto fail;\n\t}\n\tsc->sc_state = 0;\t/* Also clears RLN_STATE_NEEDINIT. */\n\n\t/* Use this host's name as a master name. */\n\tif (!cold && sc->sc_param.rp_master[0] == '\\0') {\n\t\tbcopy(hostname, sc->sc_param.rp_master, \n\t\t    min(hostnamelen, sizeof sc->sc_param.rp_master));\n\t}\n\n\trln_enable(sc, 1);\n\n\t/* Initialise operational params. */\n\tif (rln_sendinit(sc)) {\n\t\tprintf(\"%s: could not set card parameters\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto fail;\n\t}\n#if 0\n\trln_roamconfig(sc);\n\t/* rln_lockprom(sc); */\n\t/* SendSetITO() */\n\trln_multicast(sc, 1);\n\trln_roam(sc);\n\n\t/* Synchronise with something. */\n\trln_searchsync(sc);\n#endif\n\tifp->if_flags |= IFF_RUNNING;\n\trlnstart(ifp);\n\tsplx(s);\n\n\treturn;\n\n    fail:\n\tifp->if_flags &= ~IFF_UP;\n\tsplx(s);\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\trlninit",
            "void\trlnstart",
            "int\trln_sendinit",
            "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\trlninit;\nvoid\trlnstart;\nint\trln_sendinit;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nvoid\nrlninit(sc)\n\tstruct rln_softc * sc;\n{\n\t/* LLDInit() */\n\tstruct ifnet * ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\textern int cold;\n\n\ts = splnet();\n\tdprintf(\" [init]\");\n\n\tsc->sc_intsel = 0;\n\tsc->sc_status = 0;\n\tsc->sc_control = 0;\n\tifp->if_flags &= ~IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Do a hard reset. */\n\tif (rln_reset(sc)) {\n\t\tprintf(\"%s: could not reset card\\n\", sc->sc_dev.dv_xname);\n\t\tgoto fail;\n\t}\n\tsc->sc_state = 0;\t/* Also clears RLN_STATE_NEEDINIT. */\n\n\t/* Use this host's name as a master name. */\n\tif (!cold && sc->sc_param.rp_master[0] == '\\0') {\n\t\tbcopy(hostname, sc->sc_param.rp_master, \n\t\t    min(hostnamelen, sizeof sc->sc_param.rp_master));\n\t}\n\n\trln_enable(sc, 1);\n\n\t/* Initialise operational params. */\n\tif (rln_sendinit(sc)) {\n\t\tprintf(\"%s: could not set card parameters\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto fail;\n\t}\n#if 0\n\trln_roamconfig(sc);\n\t/* rln_lockprom(sc); */\n\t/* SendSetITO() */\n\trln_multicast(sc, 1);\n\trln_roam(sc);\n\n\t/* Synchronise with something. */\n\trln_searchsync(sc);\n#endif\n\tifp->if_flags |= IFF_RUNNING;\n\trlnstart(ifp);\n\tsplx(s);\n\n\treturn;\n\n    fail:\n\tifp->if_flags &= ~IFF_UP;\n\tsplx(s);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" start[\""
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PACKETMAX\t(sizeof (struct ether_header) + ETHERMTU + 4)\n#define PACKETMIN\t(sizeof (struct ether_header) + ETHERMIN)\n\nvoid\trlninit;\nvoid\trlnstart;\nint\trln_transmit;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nvoid\nrlnstart(ifp)\n\tstruct ifnet *\tifp;\n{\n\tstruct rln_softc * sc = (struct rln_softc *)ifp->if_softc;\n\tstruct mbuf *\tm0;\n\tint\t\tlen, pad, ret, s;\n\n\tdprintf(\" start[\");\n\n\tif (sc->sc_state & RLN_STATE_NEEDINIT)\n\t\trlninit(sc);\n\n\t/* Don't transmit if interface is busy or not running. */\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING) {\n\t\tdprintf(\" %s] \", (ifp->if_flags & IFF_OACTIVE) ? \n\t\t    \"busy\" : \"stopped\");\n\t\treturn;\n\t}\n\n\t/* Don't transmit if we are not synchronised. */\n\tif ((sc->sc_state & RLN_STATE_SYNC) == 0) {\n\t\tdprintf(\" nosync]\");\n\t\treturn;\n\t}\n\n\trln_enable(sc, 1);\n\n    startagain:\n\ts = splimp();\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tsplx(s);\n\n\tif (m0 == NULL) {\n\t\tdprintf(\" empty]\");\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/* Tap packet stream here for BPF listeners. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/* We need to use m->m_pkthdr.len, so require the header. */\n\tif ((m0->m_flags & M_PKTHDR) == 0) {\n\t\tprintf(\"%s: no mbuf header\\n\", sc->sc_dev.dv_xname);\n\t\tgoto oerror;\n\t}\n\n\tlen = m0->m_pkthdr.len;\n\n#define PACKETMIN\t(sizeof (struct ether_header) + ETHERMIN)\n#define PACKETMAX\t(sizeof (struct ether_header) + ETHERMTU + 4)\n\n\t/* Packet size has to be an even number between 60 and 1518 octets. */\n\tpad = len & 1;\n\tif (len + pad < PACKETMIN)\n\t\tpad = PACKETMIN - len;\n\n\tif (len + pad > PACKETMAX) {\n\t\tprintf(\"%s: packet too big (%d > %d)\\n\",\n\t\t    sc->sc_dev.dv_xname, len + pad,\n\t\t    PACKETMAX);\n\t\t++ifp->if_oerrors;\n\t\tm_freem(m0);\n\t\tgoto startagain;\n\t}\n\n\tret = rln_transmit(sc, m0, len, pad);\n\tif (ret)\n\t\tgoto oerror;\n\n\tifp->if_flags |= IFF_OACTIVE;\n\tm_freem(m0);\n\n\tdprintf(\" sent]\");\n\treturn;\n\noerror:\n\t++ifp->if_oerrors;\n\tm_freem(m0);\n\trln_need_reset(sc);\n\treturn;\n}"
  },
  {
    "function_name": "rlninit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "152-211",
    "snippet": "void\nrlninit(sc)\n\tstruct rln_softc * sc;\n{\n\t/* LLDInit() */\n\tstruct ifnet * ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\textern int cold;\n\n\ts = splnet();\n\tdprintf(\" [init]\");\n\n\tsc->sc_intsel = 0;\n\tsc->sc_status = 0;\n\tsc->sc_control = 0;\n\tifp->if_flags &= ~IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Do a hard reset. */\n\tif (rln_reset(sc)) {\n\t\tprintf(\"%s: could not reset card\\n\", sc->sc_dev.dv_xname);\n\t\tgoto fail;\n\t}\n\tsc->sc_state = 0;\t/* Also clears RLN_STATE_NEEDINIT. */\n\n\t/* Use this host's name as a master name. */\n\tif (!cold && sc->sc_param.rp_master[0] == '\\0') {\n\t\tbcopy(hostname, sc->sc_param.rp_master, \n\t\t    min(hostnamelen, sizeof sc->sc_param.rp_master));\n\t}\n\n\trln_enable(sc, 1);\n\n\t/* Initialise operational params. */\n\tif (rln_sendinit(sc)) {\n\t\tprintf(\"%s: could not set card parameters\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto fail;\n\t}\n#if 0\n\trln_roamconfig(sc);\n\t/* rln_lockprom(sc); */\n\t/* SendSetITO() */\n\trln_multicast(sc, 1);\n\trln_roam(sc);\n\n\t/* Synchronise with something. */\n\trln_searchsync(sc);\n#endif\n\tifp->if_flags |= IFF_RUNNING;\n\trlnstart(ifp);\n\tsplx(s);\n\n\treturn;\n\n    fail:\n\tifp->if_flags &= ~IFF_UP;\n\tsplx(s);\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\trlninit",
      "void\trlnstart",
      "int\trln_sendinit",
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlnstart",
          "args": [
            "ifp"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "rlnstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
          "lines": "214-298",
          "snippet": "void\nrlnstart(ifp)\n\tstruct ifnet *\tifp;\n{\n\tstruct rln_softc * sc = (struct rln_softc *)ifp->if_softc;\n\tstruct mbuf *\tm0;\n\tint\t\tlen, pad, ret, s;\n\n\tdprintf(\" start[\");\n\n\tif (sc->sc_state & RLN_STATE_NEEDINIT)\n\t\trlninit(sc);\n\n\t/* Don't transmit if interface is busy or not running. */\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING) {\n\t\tdprintf(\" %s] \", (ifp->if_flags & IFF_OACTIVE) ? \n\t\t    \"busy\" : \"stopped\");\n\t\treturn;\n\t}\n\n\t/* Don't transmit if we are not synchronised. */\n\tif ((sc->sc_state & RLN_STATE_SYNC) == 0) {\n\t\tdprintf(\" nosync]\");\n\t\treturn;\n\t}\n\n\trln_enable(sc, 1);\n\n    startagain:\n\ts = splimp();\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tsplx(s);\n\n\tif (m0 == NULL) {\n\t\tdprintf(\" empty]\");\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/* Tap packet stream here for BPF listeners. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/* We need to use m->m_pkthdr.len, so require the header. */\n\tif ((m0->m_flags & M_PKTHDR) == 0) {\n\t\tprintf(\"%s: no mbuf header\\n\", sc->sc_dev.dv_xname);\n\t\tgoto oerror;\n\t}\n\n\tlen = m0->m_pkthdr.len;\n\n#define PACKETMIN\t(sizeof (struct ether_header) + ETHERMIN)\n#define PACKETMAX\t(sizeof (struct ether_header) + ETHERMTU + 4)\n\n\t/* Packet size has to be an even number between 60 and 1518 octets. */\n\tpad = len & 1;\n\tif (len + pad < PACKETMIN)\n\t\tpad = PACKETMIN - len;\n\n\tif (len + pad > PACKETMAX) {\n\t\tprintf(\"%s: packet too big (%d > %d)\\n\",\n\t\t    sc->sc_dev.dv_xname, len + pad,\n\t\t    PACKETMAX);\n\t\t++ifp->if_oerrors;\n\t\tm_freem(m0);\n\t\tgoto startagain;\n\t}\n\n\tret = rln_transmit(sc, m0, len, pad);\n\tif (ret)\n\t\tgoto oerror;\n\n\tifp->if_flags |= IFF_OACTIVE;\n\tm_freem(m0);\n\n\tdprintf(\" sent]\");\n\treturn;\n\noerror:\n\t++ifp->if_oerrors;\n\tm_freem(m0);\n\trln_need_reset(sc);\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PACKETMAX\t(sizeof (struct ether_header) + ETHERMTU + 4)",
            "#define PACKETMIN\t(sizeof (struct ether_header) + ETHERMIN)"
          ],
          "globals_used": [
            "void\trlninit",
            "void\trlnstart",
            "int\trln_transmit",
            "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PACKETMAX\t(sizeof (struct ether_header) + ETHERMTU + 4)\n#define PACKETMIN\t(sizeof (struct ether_header) + ETHERMIN)\n\nvoid\trlninit;\nvoid\trlnstart;\nint\trln_transmit;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nvoid\nrlnstart(ifp)\n\tstruct ifnet *\tifp;\n{\n\tstruct rln_softc * sc = (struct rln_softc *)ifp->if_softc;\n\tstruct mbuf *\tm0;\n\tint\t\tlen, pad, ret, s;\n\n\tdprintf(\" start[\");\n\n\tif (sc->sc_state & RLN_STATE_NEEDINIT)\n\t\trlninit(sc);\n\n\t/* Don't transmit if interface is busy or not running. */\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING) {\n\t\tdprintf(\" %s] \", (ifp->if_flags & IFF_OACTIVE) ? \n\t\t    \"busy\" : \"stopped\");\n\t\treturn;\n\t}\n\n\t/* Don't transmit if we are not synchronised. */\n\tif ((sc->sc_state & RLN_STATE_SYNC) == 0) {\n\t\tdprintf(\" nosync]\");\n\t\treturn;\n\t}\n\n\trln_enable(sc, 1);\n\n    startagain:\n\ts = splimp();\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tsplx(s);\n\n\tif (m0 == NULL) {\n\t\tdprintf(\" empty]\");\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/* Tap packet stream here for BPF listeners. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/* We need to use m->m_pkthdr.len, so require the header. */\n\tif ((m0->m_flags & M_PKTHDR) == 0) {\n\t\tprintf(\"%s: no mbuf header\\n\", sc->sc_dev.dv_xname);\n\t\tgoto oerror;\n\t}\n\n\tlen = m0->m_pkthdr.len;\n\n#define PACKETMIN\t(sizeof (struct ether_header) + ETHERMIN)\n#define PACKETMAX\t(sizeof (struct ether_header) + ETHERMTU + 4)\n\n\t/* Packet size has to be an even number between 60 and 1518 octets. */\n\tpad = len & 1;\n\tif (len + pad < PACKETMIN)\n\t\tpad = PACKETMIN - len;\n\n\tif (len + pad > PACKETMAX) {\n\t\tprintf(\"%s: packet too big (%d > %d)\\n\",\n\t\t    sc->sc_dev.dv_xname, len + pad,\n\t\t    PACKETMAX);\n\t\t++ifp->if_oerrors;\n\t\tm_freem(m0);\n\t\tgoto startagain;\n\t}\n\n\tret = rln_transmit(sc, m0, len, pad);\n\tif (ret)\n\t\tgoto oerror;\n\n\tifp->if_flags |= IFF_OACTIVE;\n\tm_freem(m0);\n\n\tdprintf(\" sent]\");\n\treturn;\n\noerror:\n\t++ifp->if_oerrors;\n\tm_freem(m0);\n\trln_need_reset(sc);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_searchsync",
          "args": [
            "sc"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "rln_searchsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
          "lines": "1095-1112",
          "snippet": "int\nrln_searchsync(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct rln_mm_search search = { RLN_MM_SEARCH };\n\tstruct rln_mm_searching response;\n\n\tbzero(search.xxx1, sizeof search.xxx1);\n\tsearch.domain = sc->sc_param.rp_domain;\n\tsearch.roaming = 1;\n\tsearch.xxx3 = 0;\n\tsearch.xxx4 = 1;\n\tsearch.xxx5 = 0;\n\tbzero(search.xxx6, sizeof search.xxx6);\n\n\treturn (rln_msg_txrx(sc, &search, sizeof search,\n\t\t&response, sizeof response));\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_searchsync(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct rln_mm_search search = { RLN_MM_SEARCH };\n\tstruct rln_mm_searching response;\n\n\tbzero(search.xxx1, sizeof search.xxx1);\n\tsearch.domain = sc->sc_param.rp_domain;\n\tsearch.roaming = 1;\n\tsearch.xxx3 = 0;\n\tsearch.xxx4 = 1;\n\tsearch.xxx5 = 0;\n\tbzero(search.xxx6, sizeof search.xxx6);\n\n\treturn (rln_msg_txrx(sc, &search, sizeof search,\n\t\t&response, sizeof response));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_roam",
          "args": [
            "sc"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "rln_roam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
          "lines": "1059-1068",
          "snippet": "int\nrln_roam(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct rln_mm_cmd roam = RLN_MM_ROAM;\n\tstruct rln_mm_cmd response;\n\n\treturn (rln_msg_txrx(sc, &roam, sizeof roam,\n\t    &response, sizeof response));\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_roam(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct rln_mm_cmd roam = RLN_MM_ROAM;\n\tstruct rln_mm_cmd response;\n\n\treturn (rln_msg_txrx(sc, &roam, sizeof roam,\n\t    &response, sizeof response));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_multicast",
          "args": [
            "sc",
            "1"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "rln_multicast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
          "lines": "1071-1092",
          "snippet": "int\nrln_multicast(sc, enable)\n\tstruct rln_softc *sc;\n\tint enable;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct rln_mm_multicast mcast = { RLN_MM_MULTICAST };\n\tstruct rln_mm_cmd response;\n\tint ret;\n\n\tmcast.enable = enable;\n\n\tret = rln_msg_txrx(sc, &mcast, sizeof mcast,\n\t    &response, sizeof response);\n\tif (ret == 0) {\n\t\tif (enable)\n\t\t\tifp->if_flags |= IFF_MULTICAST;\n\t\telse\n\t\t\tifp->if_flags &= ~IFF_MULTICAST;\n\t}\n\treturn (ret);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_multicast(sc, enable)\n\tstruct rln_softc *sc;\n\tint enable;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct rln_mm_multicast mcast = { RLN_MM_MULTICAST };\n\tstruct rln_mm_cmd response;\n\tint ret;\n\n\tmcast.enable = enable;\n\n\tret = rln_msg_txrx(sc, &mcast, sizeof mcast,\n\t    &response, sizeof response);\n\tif (ret == 0) {\n\t\tif (enable)\n\t\t\tifp->if_flags |= IFF_MULTICAST;\n\t\telse\n\t\t\tifp->if_flags &= ~IFF_MULTICAST;\n\t}\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_roamconfig",
          "args": [
            "sc"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "rln_roamconfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
          "lines": "1030-1056",
          "snippet": "int\nrln_roamconfig(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct rln_mm_setroaming roam = { RLN_MM_SETROAMING };\n\tstruct rln_mm_cmd response;\n\tstatic int retry[3] = { 6, 6, 4 };\n\tstatic int rssi[3] = { 5, 15, 5 };\n\n\tdprintf(\" [roamconfig]\");\n#ifdef DIAGNOSTIC\n\tif (sc->sc_param.rp_roam_config > 2)\n\t\tpanic(\"roamconfig\");\n#endif\n\troam.sync_alarm = 0;\n\troam.retry_thresh = retry[sc->sc_param.rp_roam_config];\n\troam.rssi_threshold = rssi[sc->sc_param.rp_roam_config];\n\troam.xxx1 = 0x5a;\n\troam.sync_rssi_threshold = 0;\n\troam.xxx2 = 0x5a;\n\troam.missed_sync = 0x4;\n\tif (rln_msg_txrx(sc, &roam, sizeof roam,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_roamconfig(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct rln_mm_setroaming roam = { RLN_MM_SETROAMING };\n\tstruct rln_mm_cmd response;\n\tstatic int retry[3] = { 6, 6, 4 };\n\tstatic int rssi[3] = { 5, 15, 5 };\n\n\tdprintf(\" [roamconfig]\");\n#ifdef DIAGNOSTIC\n\tif (sc->sc_param.rp_roam_config > 2)\n\t\tpanic(\"roamconfig\");\n#endif\n\troam.sync_alarm = 0;\n\troam.retry_thresh = retry[sc->sc_param.rp_roam_config];\n\troam.rssi_threshold = rssi[sc->sc_param.rp_roam_config];\n\troam.xxx1 = 0x5a;\n\troam.sync_rssi_threshold = 0;\n\troam.xxx2 = 0x5a;\n\troam.missed_sync = 0x4;\n\tif (rln_msg_txrx(sc, &roam, sizeof roam,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: could not set card parameters\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_sendinit",
          "args": [
            "sc"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "rln_sendinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
          "lines": "958-1026",
          "snippet": "int\nrln_sendinit(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct rln_mm_init init = { RLN_MM_INIT };\n\tstruct rln_mm_initted iresponse;\n#if 0\n\tstruct rln_mm_setmagic magic = { RLN_MM_SETMAGIC };\n\tstruct rln_mm_disablehopping hop = { RLN_MM_DISABLEHOPPING };\n\tstruct rln_mm_cmd response;\n#endif\n\n\tbzero((char*)&init + sizeof init.mm_cmd,\n\t\tsizeof init - sizeof init.mm_cmd);\n\n\tdprintf(\" [setting parameters]\");\n\tinit.opmode = (sc->sc_state & RLN_STATE_PROMISC ?\n\t    RLN_MM_INIT_OPMODE_PROMISC : RLN_MM_INIT_OPMODE_NORMAL);\n\tinit.stationtype = sc->sc_param.rp_station_type;\n\n\t/* Spread-spectrum frequency hopping. */\n\tinit.hop_period = 1;\n\tinit.bfreq = 2;\n\tinit.sfreq = 7;\n\n\t/* Choose channel. */\n\tinit.channel = sc->sc_param.rp_channel;\n\tinit.subchannel = sc->sc_param.rp_subchannel;\n\tinit.domain = sc->sc_param.rp_domain;\n\n\t/* Name of this station when acting as master. */\n\tbcopy(sc->sc_param.rp_master, init.mastername, sizeof init.mastername);\n\n\t/* Security params. */\n\tinit.sec1 = (sc->sc_param.rp_security & 0x0000ff) >> 0;\n\tinit.sec2 = (sc->sc_param.rp_security & 0x00ff00) >> 8;\n\tinit.sec3 = (sc->sc_param.rp_security & 0xff0000) >> 16;\n\n\tinit.sync_to = 1;\n\tbzero(init.syncname, sizeof init.syncname);\n\n\tif (rln_msg_txrx(sc, &init, sizeof init,\n\t    &iresponse, sizeof iresponse))\n\t\treturn (-1);\n#if 0\n\tdprintf(\" [setting magic]\");\n\tmagic.fairness_slot = 3;\t/* lite: 1, norm: 3, off: -1 */\n\tmagic.deferral_slot = 3;\t/* lite: 0, norm: 3, off: -1 */\n\tmagic.regular_mac_retry = 7;\n\tmagic.frag_mac_retry = 10;\n\tmagic.regular_mac_qfsk = 2;\n\tmagic.frag_mac_qfsk = 5;\n\tmagic.xxx1 = 0xff;\n\tmagic.xxx2 = 0xff;\n\tmagic.xxx3 = 0xff;\n\tmagic.xxx4 = 0x00;\n\tif (rln_msg_txrx(sc, &magic, sizeof magic,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\n\tdprintf(\" [disabling freq hopping]\");\n\thop.hopflag = RLN_MM_DISABLEHOPPING_HOPFLAG_DISABLE;\n\tif (rln_msg_txrx(sc, &hop, sizeof hop,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\n#endif\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\trln_sendinit",
            "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\trln_sendinit;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_sendinit(sc)\n\tstruct rln_softc *sc;\n{\n\tstruct rln_mm_init init = { RLN_MM_INIT };\n\tstruct rln_mm_initted iresponse;\n#if 0\n\tstruct rln_mm_setmagic magic = { RLN_MM_SETMAGIC };\n\tstruct rln_mm_disablehopping hop = { RLN_MM_DISABLEHOPPING };\n\tstruct rln_mm_cmd response;\n#endif\n\n\tbzero((char*)&init + sizeof init.mm_cmd,\n\t\tsizeof init - sizeof init.mm_cmd);\n\n\tdprintf(\" [setting parameters]\");\n\tinit.opmode = (sc->sc_state & RLN_STATE_PROMISC ?\n\t    RLN_MM_INIT_OPMODE_PROMISC : RLN_MM_INIT_OPMODE_NORMAL);\n\tinit.stationtype = sc->sc_param.rp_station_type;\n\n\t/* Spread-spectrum frequency hopping. */\n\tinit.hop_period = 1;\n\tinit.bfreq = 2;\n\tinit.sfreq = 7;\n\n\t/* Choose channel. */\n\tinit.channel = sc->sc_param.rp_channel;\n\tinit.subchannel = sc->sc_param.rp_subchannel;\n\tinit.domain = sc->sc_param.rp_domain;\n\n\t/* Name of this station when acting as master. */\n\tbcopy(sc->sc_param.rp_master, init.mastername, sizeof init.mastername);\n\n\t/* Security params. */\n\tinit.sec1 = (sc->sc_param.rp_security & 0x0000ff) >> 0;\n\tinit.sec2 = (sc->sc_param.rp_security & 0x00ff00) >> 8;\n\tinit.sec3 = (sc->sc_param.rp_security & 0xff0000) >> 16;\n\n\tinit.sync_to = 1;\n\tbzero(init.syncname, sizeof init.syncname);\n\n\tif (rln_msg_txrx(sc, &init, sizeof init,\n\t    &iresponse, sizeof iresponse))\n\t\treturn (-1);\n#if 0\n\tdprintf(\" [setting magic]\");\n\tmagic.fairness_slot = 3;\t/* lite: 1, norm: 3, off: -1 */\n\tmagic.deferral_slot = 3;\t/* lite: 0, norm: 3, off: -1 */\n\tmagic.regular_mac_retry = 7;\n\tmagic.frag_mac_retry = 10;\n\tmagic.regular_mac_qfsk = 2;\n\tmagic.frag_mac_qfsk = 5;\n\tmagic.xxx1 = 0xff;\n\tmagic.xxx2 = 0xff;\n\tmagic.xxx3 = 0xff;\n\tmagic.xxx4 = 0x00;\n\tif (rln_msg_txrx(sc, &magic, sizeof magic,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\n\tdprintf(\" [disabling freq hopping]\");\n\thop.hopflag = RLN_MM_DISABLEHOPPING_HOPFLAG_DISABLE;\n\tif (rln_msg_txrx(sc, &hop, sizeof hop,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\n#endif\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_enable",
          "args": [
            "sc",
            "1"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "rln_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "48-67",
          "snippet": "int\nrln_enable(sc, enable)\n\tstruct rln_softc * sc;\n\tint\t\tenable;\n{\n\tint\t\ts;\n\tint\t\twas_enabled;\n\n\ts = splhigh();\n\twas_enabled = (sc->sc_intsel & RLN_INTSEL_ENABLE) ? 1 : 0;\n\tif (enable != was_enabled) {\n\t\tif (enable)\n\t\t\tsc->sc_intsel |= RLN_INTSEL_ENABLE;\n\t\telse\n\t\t\tsc->sc_intsel &=~RLN_INTSEL_ENABLE;\n\t\t_rln_register_write_1(sc, RLN_REG_INTSEL, sc->sc_intsel);\n\t}\n\tsplx(s);\n\treturn (was_enabled);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_enable(sc, enable)\n\tstruct rln_softc * sc;\n\tint\t\tenable;\n{\n\tint\t\ts;\n\tint\t\twas_enabled;\n\n\ts = splhigh();\n\twas_enabled = (sc->sc_intsel & RLN_INTSEL_ENABLE) ? 1 : 0;\n\tif (enable != was_enabled) {\n\t\tif (enable)\n\t\t\tsc->sc_intsel |= RLN_INTSEL_ENABLE;\n\t\telse\n\t\t\tsc->sc_intsel &=~RLN_INTSEL_ENABLE;\n\t\t_rln_register_write_1(sc, RLN_REG_INTSEL, sc->sc_intsel);\n\t}\n\tsplx(s);\n\treturn (was_enabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "hostname",
            "sc->sc_param.rp_master",
            "min(hostnamelen, sizeof sc->sc_param.rp_master)"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "hostnamelen",
            "sizeof sc->sc_param.rp_master"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_meminit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "231-295",
          "snippet": "void\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_reset",
          "args": [
            "sc"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "rln_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "77-163",
          "snippet": "int\nrln_reset(sc)\n\tstruct rln_softc * sc;\n{\n\tint\t\ts;\n\tint\t\ti;\n\tint\t\tstatus;\n\tu_int8_t\top = 0x00;\n\n\ts = splhigh();\n\tdprintf(\" R[\");\n\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | RLN_CTYPE_ONE_PIECE))\n\t\top = 0x04;\n\tif (rln_status_read(sc) & RLN_STATUS_WAKEUP) {\n\t\trln_control_write(sc, op);\n\t\trln_control_write(sc, op | RLN_CONTROL_RESET);\n\t\tdprintf(\" 7ms\");\n\t\tDELAY(7000);\n\t\trln_control_write(sc, op);\n\t\tdprintf(\" 7ms\");\n\t\tDELAY(7000);\n\t}\n\trln_control_write(sc, op);\n\trln_control_write(sc, op);\n\trln_control_write(sc, op | RLN_CONTROL_BIT3);\n\tdprintf(\" 67ms\");\n\tDELAY(67000);\n\trln_status_write(sc, 0x00);\n\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | RLN_CTYPE_ONE_PIECE))\n\t\trln_control_write(sc, 0x38); \n\t\t/* RLN_CONTROL_BIT3 | RLN_CONTROL_RESET | RLN_CONTROL_16BIT */\n\telse\n\t\trln_control_write(sc, 0x2c);\n\t\t/* RLN_CONTROL_BIT3 | RLN_CONTROL_BIT2  | RLN_CONTROL_16BIT */\n\tdprintf(\" 67ms\");\n\tDELAY(67000);\n\trln_data_write_2(sc, 0xaa55);\n\trln_status_write(sc, 0x5a);\n\tsplx(s);\n\tfor (i = 0; i < 200 * 10; i++) {\t/* Proxim says 200. */\n\t\tif ((status = rln_status_read(sc)) == 0x5a)\n\t\t\tbreak;\n\t\tDELAY(1000);\n\t}\n\tdprintf(\" (%dms)\", i);\n\ts = splhigh();\n\tif (status != 0x5a) {\n\t\tsplx(s);\n\t\t/* Only winge if bus width not yet probed */\n\t\tif (sc->sc_width != 0)\n\t\t\tprintf(\"%s: reset timeout\\n\", sc->sc_dev.dv_xname);\n\t\tdprintf(\"]=-1\");\n\t\treturn (-1);\n\t}\n\tif (sc->sc_width == 8) {\n\t\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | RLN_CTYPE_ONE_PIECE))\n\t\t\trln_control_write(sc, RLN_CONTROL_BIT3);\n\t\telse\n\t\t\trln_control_write(sc, RLN_CONTROL_BIT3 | \n\t\t\t    RLN_CONTROL_BIT2);\n\t\trln_data_write_1(sc, 0x20);\n\t} else if (sc->sc_width == 16) {\n\t\trln_data_write_2(sc, 0x0000);\n\t} else {\n\t\tif (rln_data_read_2(sc) == 0x55aa) {\n\t\t\trln_data_write_2(sc, 0x0000);\n\t\t\tsc->sc_width = 16;\n\t\t} else {\n\t\t\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | \n\t\t\t    RLN_CTYPE_ONE_PIECE))\n\t\t\t\trln_control_write(sc, RLN_CONTROL_BIT3);\n\t\t\telse\n\t\t\t\trln_control_write(sc, RLN_CONTROL_BIT3 | \n\t\t\t\t    RLN_CONTROL_BIT2);\n\t\t\trln_data_write_1(sc, 0x20);\n\t\t\tsc->sc_width = 8;\n\t\t}\n\t\t/* printf(\"%s: %d bit bus\\n\", sc->sc_dev.dv_xname, \n\t\t   sc->sc_width); */\n\t}\n\trln_status_write(sc, 0x00);\n\tsc->sc_intsel = 0;\n\trln_intsel_write(sc, sc->sc_irq);\n\tsplx(s);\n\tdprintf(\"]\");\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_reset(sc)\n\tstruct rln_softc * sc;\n{\n\tint\t\ts;\n\tint\t\ti;\n\tint\t\tstatus;\n\tu_int8_t\top = 0x00;\n\n\ts = splhigh();\n\tdprintf(\" R[\");\n\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | RLN_CTYPE_ONE_PIECE))\n\t\top = 0x04;\n\tif (rln_status_read(sc) & RLN_STATUS_WAKEUP) {\n\t\trln_control_write(sc, op);\n\t\trln_control_write(sc, op | RLN_CONTROL_RESET);\n\t\tdprintf(\" 7ms\");\n\t\tDELAY(7000);\n\t\trln_control_write(sc, op);\n\t\tdprintf(\" 7ms\");\n\t\tDELAY(7000);\n\t}\n\trln_control_write(sc, op);\n\trln_control_write(sc, op);\n\trln_control_write(sc, op | RLN_CONTROL_BIT3);\n\tdprintf(\" 67ms\");\n\tDELAY(67000);\n\trln_status_write(sc, 0x00);\n\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | RLN_CTYPE_ONE_PIECE))\n\t\trln_control_write(sc, 0x38); \n\t\t/* RLN_CONTROL_BIT3 | RLN_CONTROL_RESET | RLN_CONTROL_16BIT */\n\telse\n\t\trln_control_write(sc, 0x2c);\n\t\t/* RLN_CONTROL_BIT3 | RLN_CONTROL_BIT2  | RLN_CONTROL_16BIT */\n\tdprintf(\" 67ms\");\n\tDELAY(67000);\n\trln_data_write_2(sc, 0xaa55);\n\trln_status_write(sc, 0x5a);\n\tsplx(s);\n\tfor (i = 0; i < 200 * 10; i++) {\t/* Proxim says 200. */\n\t\tif ((status = rln_status_read(sc)) == 0x5a)\n\t\t\tbreak;\n\t\tDELAY(1000);\n\t}\n\tdprintf(\" (%dms)\", i);\n\ts = splhigh();\n\tif (status != 0x5a) {\n\t\tsplx(s);\n\t\t/* Only winge if bus width not yet probed */\n\t\tif (sc->sc_width != 0)\n\t\t\tprintf(\"%s: reset timeout\\n\", sc->sc_dev.dv_xname);\n\t\tdprintf(\"]=-1\");\n\t\treturn (-1);\n\t}\n\tif (sc->sc_width == 8) {\n\t\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | RLN_CTYPE_ONE_PIECE))\n\t\t\trln_control_write(sc, RLN_CONTROL_BIT3);\n\t\telse\n\t\t\trln_control_write(sc, RLN_CONTROL_BIT3 | \n\t\t\t    RLN_CONTROL_BIT2);\n\t\trln_data_write_1(sc, 0x20);\n\t} else if (sc->sc_width == 16) {\n\t\trln_data_write_2(sc, 0x0000);\n\t} else {\n\t\tif (rln_data_read_2(sc) == 0x55aa) {\n\t\t\trln_data_write_2(sc, 0x0000);\n\t\t\tsc->sc_width = 16;\n\t\t} else {\n\t\t\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | \n\t\t\t    RLN_CTYPE_ONE_PIECE))\n\t\t\t\trln_control_write(sc, RLN_CONTROL_BIT3);\n\t\t\telse\n\t\t\t\trln_control_write(sc, RLN_CONTROL_BIT3 | \n\t\t\t\t    RLN_CONTROL_BIT2);\n\t\t\trln_data_write_1(sc, 0x20);\n\t\t\tsc->sc_width = 8;\n\t\t}\n\t\t/* printf(\"%s: %d bit bus\\n\", sc->sc_dev.dv_xname, \n\t\t   sc->sc_width); */\n\t}\n\trln_status_write(sc, 0x00);\n\tsc->sc_intsel = 0;\n\trln_intsel_write(sc, sc->sc_irq);\n\tsplx(s);\n\tdprintf(\"]\");\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" [init]\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\trlninit;\nvoid\trlnstart;\nint\trln_sendinit;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nvoid\nrlninit(sc)\n\tstruct rln_softc * sc;\n{\n\t/* LLDInit() */\n\tstruct ifnet * ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\textern int cold;\n\n\ts = splnet();\n\tdprintf(\" [init]\");\n\n\tsc->sc_intsel = 0;\n\tsc->sc_status = 0;\n\tsc->sc_control = 0;\n\tifp->if_flags &= ~IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Do a hard reset. */\n\tif (rln_reset(sc)) {\n\t\tprintf(\"%s: could not reset card\\n\", sc->sc_dev.dv_xname);\n\t\tgoto fail;\n\t}\n\tsc->sc_state = 0;\t/* Also clears RLN_STATE_NEEDINIT. */\n\n\t/* Use this host's name as a master name. */\n\tif (!cold && sc->sc_param.rp_master[0] == '\\0') {\n\t\tbcopy(hostname, sc->sc_param.rp_master, \n\t\t    min(hostnamelen, sizeof sc->sc_param.rp_master));\n\t}\n\n\trln_enable(sc, 1);\n\n\t/* Initialise operational params. */\n\tif (rln_sendinit(sc)) {\n\t\tprintf(\"%s: could not set card parameters\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto fail;\n\t}\n#if 0\n\trln_roamconfig(sc);\n\t/* rln_lockprom(sc); */\n\t/* SendSetITO() */\n\trln_multicast(sc, 1);\n\trln_roam(sc);\n\n\t/* Synchronise with something. */\n\trln_searchsync(sc);\n#endif\n\tifp->if_flags |= IFF_RUNNING;\n\trlnstart(ifp);\n\tsplx(s);\n\n\treturn;\n\n    fail:\n\tifp->if_flags &= ~IFF_UP;\n\tsplx(s);\n\treturn;\n}"
  },
  {
    "function_name": "rlnconfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
    "lines": "82-149",
    "snippet": "void\nrlnconfig(sc)\n\tstruct rln_softc * sc;\n{\n\tstruct ifnet *\tifp = &sc->sc_arpcom.ac_if;\n\tchar\t\tpromvers[7];\n\tint\t\ti;\n\n\tdprintf(\" [attach %p]\", sc);\n\n\t/* Use the flags supplied from config. */\n\tsc->sc_cardtype |= sc->sc_dev.dv_cfdata->cf_flags;\n\n\t/* Initialise values in the soft state. */\n\tsc->sc_pktseq = 0;\t/* rln_newseq() */\n\tsc->sc_txseq = 0;\n\tsc->sc_state = 0;\n\n\t/* Initialise user-configurable params. */\n\tsc->sc_param.rp_roam_config = RLN_ROAM_NORMAL;\n\tsc->sc_param.rp_security = RLN_SECURITY_DEFAULT;\n\tsc->sc_param.rp_station_type = RLN_STATIONTYPE_ALTMASTER;\n\tsc->sc_param.rp_domain = 0;\n\tsc->sc_param.rp_channel = 1;\n\tsc->sc_param.rp_subchannel = 1;\n\n\tbzero(sc->sc_param.rp_master, sizeof sc->sc_param.rp_master);\n\n\t/* Initialise the message mailboxes. */\n\tfor (i = 0; i < RLN_NMBOX; i++)\n\t\tsc->sc_mbox[i].mb_state = RLNMBOX_VOID;\n\n\t/* Probe for some properties. */\n\tprintf(\", %s-piece\", \n\t    (sc->sc_cardtype & RLN_CTYPE_ONE_PIECE) ? \"one\" : \"two\");\n\tif (sc->sc_cardtype & RLN_CTYPE_OEM)\n\t\tprintf(\" oem\");\n\tif (sc->sc_cardtype & RLN_CTYPE_UISA)\n\t\tprintf(\" micro-isa\");\n\n\t/* Read the card's PROM revision. */\n\tif (rln_getpromvers(sc, promvers, sizeof promvers)) {\n\t\tprintf(\": could not read PROM version\\n\");\n\t\treturn;\n\t}\n\tprintf(\", fw %.7s\", promvers);\n\n\t/* Fetch the card's MAC address. */\n\tif (rln_getenaddr(sc, sc->sc_arpcom.ac_enaddr)) {\n\t\tprintf(\": could not read MAC address\\n\");\n\t\treturn;\n\t}\n\tprintf(\", addr %s\", ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\t/* Attach as a network interface. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = rlnstart;\n\tifp->if_ioctl = rlnioctl;\n\tifp->if_watchdog = rlnwatchdog;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof (struct ether_header));\n#endif\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\trlnstart",
      "void\trlnwatchdog",
      "int\trlnioctl",
      "int\trln_getenaddr",
      "int\trln_getpromvers",
      "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&ifp->if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof (struct ether_header)"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\", addr %s\"",
            "ether_sprintf(sc->sc_arpcom.ac_enaddr)"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->sc_arpcom.ac_enaddr"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_getenaddr",
          "args": [
            "sc",
            "sc->sc_arpcom.ac_enaddr"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "rln_getenaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
          "lines": "916-929",
          "snippet": "int\nrln_getenaddr(sc, enaddr)\n\tstruct rln_softc *sc;\n\tu_int8_t * enaddr;\n{\n\tstruct rln_mm_cmd query = RLN_MM_GETENADDR;\n\tstruct rln_mm_gotenaddr response = { RLN_MM_GETENADDR };\n\n\tif (rln_msg_txrx(sc, &query, sizeof query,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\tbcopy(response.enaddr, enaddr, sizeof response.enaddr);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\trln_getenaddr",
            "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\trln_getenaddr;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_getenaddr(sc, enaddr)\n\tstruct rln_softc *sc;\n\tu_int8_t * enaddr;\n{\n\tstruct rln_mm_cmd query = RLN_MM_GETENADDR;\n\tstruct rln_mm_gotenaddr response = { RLN_MM_GETENADDR };\n\n\tif (rln_msg_txrx(sc, &query, sizeof query,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\tbcopy(response.enaddr, enaddr, sizeof response.enaddr);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_getpromvers",
          "args": [
            "sc",
            "promvers",
            "sizeof promvers"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "rln_getpromvers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
          "lines": "932-955",
          "snippet": "int\nrln_getpromvers(sc, ver, verlen)\n\tstruct rln_softc *sc;\n\tchar *ver;\n\tint verlen;\n{\n\tstruct rln_mm_cmd query = RLN_MM_GETPROMVERSION;\n\tstruct rln_mm_gotpromversion response = { RLN_MM_GOTPROMVERSION };\n\tint i;\n\n#ifdef DIAGNOSTIC\n\tif (verlen != sizeof response.version)\n\t\tpanic(\"rln_getpromvers\");\n#endif\n\n\tif (rln_msg_txrx(sc, &query, sizeof query,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\tbcopy(response.version, ver, verlen);\n\t/* Nul trailing spaces. */\n\tfor (i = verlen - 1; i >= 0 && ver[i] <= ' '; i--)\n\t\tver[i] = '\\0';\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\trln_getpromvers",
            "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\trln_getpromvers;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nint\nrln_getpromvers(sc, ver, verlen)\n\tstruct rln_softc *sc;\n\tchar *ver;\n\tint verlen;\n{\n\tstruct rln_mm_cmd query = RLN_MM_GETPROMVERSION;\n\tstruct rln_mm_gotpromversion response = { RLN_MM_GOTPROMVERSION };\n\tint i;\n\n#ifdef DIAGNOSTIC\n\tif (verlen != sizeof response.version)\n\t\tpanic(\"rln_getpromvers\");\n#endif\n\n\tif (rln_msg_txrx(sc, &query, sizeof query,\n\t    &response, sizeof response))\n\t\treturn (-1);\n\tbcopy(response.version, ver, verlen);\n\t/* Nul trailing spaces. */\n\tfor (i = verlen - 1; i >= 0 && ver[i] <= ' '; i--)\n\t\tver[i] = '\\0';\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->sc_param.rp_master",
            "sizeof sc->sc_param.rp_master"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" [attach %p]\"",
            "sc"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\trlnstart;\nvoid\trlnwatchdog;\nint\trlnioctl;\nint\trln_getenaddr;\nint\trln_getpromvers;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nvoid\nrlnconfig(sc)\n\tstruct rln_softc * sc;\n{\n\tstruct ifnet *\tifp = &sc->sc_arpcom.ac_if;\n\tchar\t\tpromvers[7];\n\tint\t\ti;\n\n\tdprintf(\" [attach %p]\", sc);\n\n\t/* Use the flags supplied from config. */\n\tsc->sc_cardtype |= sc->sc_dev.dv_cfdata->cf_flags;\n\n\t/* Initialise values in the soft state. */\n\tsc->sc_pktseq = 0;\t/* rln_newseq() */\n\tsc->sc_txseq = 0;\n\tsc->sc_state = 0;\n\n\t/* Initialise user-configurable params. */\n\tsc->sc_param.rp_roam_config = RLN_ROAM_NORMAL;\n\tsc->sc_param.rp_security = RLN_SECURITY_DEFAULT;\n\tsc->sc_param.rp_station_type = RLN_STATIONTYPE_ALTMASTER;\n\tsc->sc_param.rp_domain = 0;\n\tsc->sc_param.rp_channel = 1;\n\tsc->sc_param.rp_subchannel = 1;\n\n\tbzero(sc->sc_param.rp_master, sizeof sc->sc_param.rp_master);\n\n\t/* Initialise the message mailboxes. */\n\tfor (i = 0; i < RLN_NMBOX; i++)\n\t\tsc->sc_mbox[i].mb_state = RLNMBOX_VOID;\n\n\t/* Probe for some properties. */\n\tprintf(\", %s-piece\", \n\t    (sc->sc_cardtype & RLN_CTYPE_ONE_PIECE) ? \"one\" : \"two\");\n\tif (sc->sc_cardtype & RLN_CTYPE_OEM)\n\t\tprintf(\" oem\");\n\tif (sc->sc_cardtype & RLN_CTYPE_UISA)\n\t\tprintf(\" micro-isa\");\n\n\t/* Read the card's PROM revision. */\n\tif (rln_getpromvers(sc, promvers, sizeof promvers)) {\n\t\tprintf(\": could not read PROM version\\n\");\n\t\treturn;\n\t}\n\tprintf(\", fw %.7s\", promvers);\n\n\t/* Fetch the card's MAC address. */\n\tif (rln_getenaddr(sc, sc->sc_arpcom.ac_enaddr)) {\n\t\tprintf(\": could not read MAC address\\n\");\n\t\treturn;\n\t}\n\tprintf(\", addr %s\", ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\t/* Attach as a network interface. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = rlnstart;\n\tifp->if_ioctl = rlnioctl;\n\tifp->if_watchdog = rlnwatchdog;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof (struct ether_header));\n#endif\n}"
  }
]