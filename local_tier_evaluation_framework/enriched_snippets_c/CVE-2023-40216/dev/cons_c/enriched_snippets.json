[
  {
    "function_name": "nullcnpollc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cons.c",
    "lines": "263-269",
    "snippet": "void\nnullcnpollc(dev, on)\n\tdev_t dev;\n\tint on;\n{\n\n}",
    "includes": [
      "#include <dev/cons.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/buf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/cons.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nnullcnpollc(dev, on)\n\tdev_t dev;\n\tint on;\n{\n\n}"
  },
  {
    "function_name": "cnpollc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cons.c",
    "lines": "247-261",
    "snippet": "void\ncnpollc(on)\n\tint on;\n{\n\tstatic int refcount = 0;\n\n\tif (cn_tab == NULL)\n\t\treturn;\n\tif (!on)\n\t\t--refcount;\n\tif (refcount == 0)\n\t\t(*cn_tab->cn_pollc)(cn_tab->cn_dev, on);\n\tif (on)\n\t\t++refcount;\n}",
    "includes": [
      "#include <dev/cons.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/buf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct\tconsdev *cn_tab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "cn_tab->cn_dev",
            "on"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/cons.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct\tconsdev *cn_tab;\n\nvoid\ncnpollc(on)\n\tint on;\n{\n\tstatic int refcount = 0;\n\n\tif (cn_tab == NULL)\n\t\treturn;\n\tif (!on)\n\t\t--refcount;\n\tif (refcount == 0)\n\t\t(*cn_tab->cn_pollc)(cn_tab->cn_dev, on);\n\tif (on)\n\t\t++refcount;\n}"
  },
  {
    "function_name": "cnputc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cons.c",
    "lines": "232-245",
    "snippet": "void\ncnputc(c)\n\tregister int c;\n{\n\n\tif (cn_tab == NULL)\n\t\treturn;\t\t\t\n\n\tif (c) {\n\t\t(*cn_tab->cn_putc)(cn_tab->cn_dev, c);\n\t\tif (c == '\\n')\n\t\t\t(*cn_tab->cn_putc)(cn_tab->cn_dev, '\\r');\n\t}\n}",
    "includes": [
      "#include <dev/cons.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/buf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct\tconsdev *cn_tab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "cn_tab->cn_dev",
            "'\\r'"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cn_tab->cn_dev",
            "c"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/cons.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct\tconsdev *cn_tab;\n\nvoid\ncnputc(c)\n\tregister int c;\n{\n\n\tif (cn_tab == NULL)\n\t\treturn;\t\t\t\n\n\tif (c) {\n\t\t(*cn_tab->cn_putc)(cn_tab->cn_dev, c);\n\t\tif (c == '\\n')\n\t\t\t(*cn_tab->cn_putc)(cn_tab->cn_dev, '\\r');\n\t}\n}"
  },
  {
    "function_name": "cngetc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cons.c",
    "lines": "223-230",
    "snippet": "int\ncngetc()\n{\n\n\tif (cn_tab == NULL)\n\t\treturn (0);\n\treturn ((*cn_tab->cn_getc)(cn_tab->cn_dev));\n}",
    "includes": [
      "#include <dev/cons.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/buf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct\tconsdev *cn_tab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "cn_tab->cn_dev"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/cons.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct\tconsdev *cn_tab;\n\nint\ncngetc()\n{\n\n\tif (cn_tab == NULL)\n\t\treturn (0);\n\treturn ((*cn_tab->cn_getc)(cn_tab->cn_dev));\n}"
  },
  {
    "function_name": "cnselect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cons.c",
    "lines": "202-221",
    "snippet": "int\ncnselect(dev, rw, p)\n\tdev_t dev;\n\tint rw;\n\tstruct proc *p;\n{\n\n\t/*\n\t * Redirect the select, if that's appropriate.\n\t * I don't want to think of the possible side effects\n\t * of console redirection here.\n\t */\n\tif (constty != NULL && (cn_tab == NULL || cn_tab->cn_pri != CN_REMOTE))\n\t\tdev = constty->t_dev;\n\telse if (cn_tab == NULL)\n\t\treturn ENXIO;\n\telse\n\t\tdev = cn_tab->cn_dev;\n\treturn (ttselect(cn_tab->cn_dev, rw, p));\n}",
    "includes": [
      "#include <dev/cons.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/buf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct\ttty *constty = NULL;",
      "struct\tconsdev *cn_tab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ttselect",
          "args": [
            "cn_tab->cn_dev",
            "rw",
            "p"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/cons.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct\ttty *constty = NULL;\nstruct\tconsdev *cn_tab;\n\nint\ncnselect(dev, rw, p)\n\tdev_t dev;\n\tint rw;\n\tstruct proc *p;\n{\n\n\t/*\n\t * Redirect the select, if that's appropriate.\n\t * I don't want to think of the possible side effects\n\t * of console redirection here.\n\t */\n\tif (constty != NULL && (cn_tab == NULL || cn_tab->cn_pri != CN_REMOTE))\n\t\tdev = constty->t_dev;\n\telse if (cn_tab == NULL)\n\t\treturn ENXIO;\n\telse\n\t\tdev = cn_tab->cn_dev;\n\treturn (ttselect(cn_tab->cn_dev, rw, p));\n}"
  },
  {
    "function_name": "cnioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cons.c",
    "lines": "164-199",
    "snippet": "int\ncnioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\n\t/*\n\t * Superuser can always use this to wrest control of console\n\t * output from the \"virtual\" console.\n\t */\n\tif (cmd == TIOCCONS && constty != NULL) {\n\t\terror = suser(p->p_ucred, (u_short *) NULL);\n\t\tif (error)\n\t\t\treturn (error);\n\t\tconstty = NULL;\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Redirect the ioctl, if that's appropriate.\n\t * Note that strange things can happen, if a program does\n\t * ioctls on /dev/console, then the console is redirected\n\t * out from under it.\n\t */\n\tif (constty != NULL && (cn_tab == NULL || cn_tab->cn_pri != CN_REMOTE))\n\t\tdev = constty->t_dev;\n\telse if (cn_tab == NULL)\n\t\treturn ENXIO;\n\telse\n\t\tdev = cn_tab->cn_dev;\n\treturn ((*cdevsw[major(dev)].d_ioctl)(dev, cmd, data, flag, p));\n}",
    "includes": [
      "#include <dev/cons.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/buf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct\ttty *constty = NULL;",
      "struct\tconsdev *cn_tab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "dev",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "major",
          "args": [
            "dev"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suser",
          "args": [
            "p->p_ucred",
            "(u_short *) NULL"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/cons.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct\ttty *constty = NULL;\nstruct\tconsdev *cn_tab;\n\nint\ncnioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\n\t/*\n\t * Superuser can always use this to wrest control of console\n\t * output from the \"virtual\" console.\n\t */\n\tif (cmd == TIOCCONS && constty != NULL) {\n\t\terror = suser(p->p_ucred, (u_short *) NULL);\n\t\tif (error)\n\t\t\treturn (error);\n\t\tconstty = NULL;\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Redirect the ioctl, if that's appropriate.\n\t * Note that strange things can happen, if a program does\n\t * ioctls on /dev/console, then the console is redirected\n\t * out from under it.\n\t */\n\tif (constty != NULL && (cn_tab == NULL || cn_tab->cn_pri != CN_REMOTE))\n\t\tdev = constty->t_dev;\n\telse if (cn_tab == NULL)\n\t\treturn ENXIO;\n\telse\n\t\tdev = cn_tab->cn_dev;\n\treturn ((*cdevsw[major(dev)].d_ioctl)(dev, cmd, data, flag, p));\n}"
  },
  {
    "function_name": "cnstop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cons.c",
    "lines": "156-162",
    "snippet": "int\ncnstop(tp, flag)\n\tstruct tty *tp;\n\tint flag;\n{\n\treturn (0);\n}",
    "includes": [
      "#include <dev/cons.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/buf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/cons.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ncnstop(tp, flag)\n\tstruct tty *tp;\n\tint flag;\n{\n\treturn (0);\n}"
  },
  {
    "function_name": "cnwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cons.c",
    "lines": "136-154",
    "snippet": "int\ncnwrite(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\n\t/*\n\t * Redirect output, if that's appropriate.\n\t * If there's no real console, return ENXIO.\n\t */\n\tif (constty != NULL && (cn_tab == NULL || cn_tab->cn_pri != CN_REMOTE))\n\t\tdev = constty->t_dev;\n\telse if (cn_tab == NULL)\n\t\treturn ENXIO;\n\telse\n\t\tdev = cn_tab->cn_dev;\n\treturn ((*cdevsw[major(dev)].d_write)(dev, uio, flag));\n}",
    "includes": [
      "#include <dev/cons.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/buf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct\ttty *constty = NULL;",
      "struct\tconsdev *cn_tab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "dev",
            "uio",
            "flag"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "major",
          "args": [
            "dev"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/cons.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct\ttty *constty = NULL;\nstruct\tconsdev *cn_tab;\n\nint\ncnwrite(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\n\t/*\n\t * Redirect output, if that's appropriate.\n\t * If there's no real console, return ENXIO.\n\t */\n\tif (constty != NULL && (cn_tab == NULL || cn_tab->cn_pri != CN_REMOTE))\n\t\tdev = constty->t_dev;\n\telse if (cn_tab == NULL)\n\t\treturn ENXIO;\n\telse\n\t\tdev = cn_tab->cn_dev;\n\treturn ((*cdevsw[major(dev)].d_write)(dev, uio, flag));\n}"
  },
  {
    "function_name": "cnread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cons.c",
    "lines": "113-134",
    "snippet": "int\ncnread(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\n\t/*\n\t * If we would redirect input, punt.  This will keep strange\n\t * things from happening to people who are using the real\n\t * console.  Nothing should be using /dev/console for\n\t * input (except a shell in single-user mode, but then,\n\t * one wouldn't TIOCCONS then).\n\t */\n\tif (constty != NULL && (cn_tab == NULL || cn_tab->cn_pri != CN_REMOTE))\n\t\treturn 0;\n\telse if (cn_tab == NULL)\n\t\treturn ENXIO;\n\n\tdev = cn_tab->cn_dev;\n\treturn ((*cdevsw[major(dev)].d_read)(dev, uio, flag));\n}",
    "includes": [
      "#include <dev/cons.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/buf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct\ttty *constty = NULL;",
      "struct\tconsdev *cn_tab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "dev",
            "uio",
            "flag"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "major",
          "args": [
            "dev"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/cons.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct\ttty *constty = NULL;\nstruct\tconsdev *cn_tab;\n\nint\ncnread(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\n\t/*\n\t * If we would redirect input, punt.  This will keep strange\n\t * things from happening to people who are using the real\n\t * console.  Nothing should be using /dev/console for\n\t * input (except a shell in single-user mode, but then,\n\t * one wouldn't TIOCCONS then).\n\t */\n\tif (constty != NULL && (cn_tab == NULL || cn_tab->cn_pri != CN_REMOTE))\n\t\treturn 0;\n\telse if (cn_tab == NULL)\n\t\treturn ENXIO;\n\n\tdev = cn_tab->cn_dev;\n\treturn ((*cdevsw[major(dev)].d_read)(dev, uio, flag));\n}"
  },
  {
    "function_name": "cnclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cons.c",
    "lines": "86-111",
    "snippet": "int\ncnclose(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag, mode;\n\tstruct proc *p;\n{\n\tstruct vnode *vp;\n\n\tif (cn_tab == NULL)\n\t\treturn (0);\n\n\t/*\n\t * If the real console isn't otherwise open, close it.\n\t * If it's otherwise open, don't close it, because that'll\n\t * screw up others who have it open.\n\t */\n\tdev = cn_tab->cn_dev;\n\tif (cn_devvp != NULLVP) {\n\t\t/* release our reference to real dev's vnode */\n\t\tvrele(cn_devvp);\n\t\tcn_devvp = NULLVP;\n\t}\n\tif (vfinddev(dev, VCHR, &vp) && vcount(vp))\n\t\treturn (0);\n\treturn ((*cdevsw[major(dev)].d_close)(dev, flag, mode, p));\n}",
    "includes": [
      "#include <dev/cons.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/buf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct\tconsdev *cn_tab;",
      "struct\tvnode *cn_devvp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "dev",
            "flag",
            "mode",
            "p"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "major",
          "args": [
            "dev"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcount",
          "args": [
            "vp"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfinddev",
          "args": [
            "dev",
            "VCHR",
            "&vp"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vrele",
          "args": [
            "cn_devvp"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/cons.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct\tconsdev *cn_tab;\nstruct\tvnode *cn_devvp;\n\nint\ncnclose(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag, mode;\n\tstruct proc *p;\n{\n\tstruct vnode *vp;\n\n\tif (cn_tab == NULL)\n\t\treturn (0);\n\n\t/*\n\t * If the real console isn't otherwise open, close it.\n\t * If it's otherwise open, don't close it, because that'll\n\t * screw up others who have it open.\n\t */\n\tdev = cn_tab->cn_dev;\n\tif (cn_devvp != NULLVP) {\n\t\t/* release our reference to real dev's vnode */\n\t\tvrele(cn_devvp);\n\t\tcn_devvp = NULLVP;\n\t}\n\tif (vfinddev(dev, VCHR, &vp) && vcount(vp))\n\t\treturn (0);\n\treturn ((*cdevsw[major(dev)].d_close)(dev, flag, mode, p));\n}"
  },
  {
    "function_name": "cnopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cons.c",
    "lines": "63-84",
    "snippet": "int\ncnopen(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag, mode;\n\tstruct proc *p;\n{\n\n\tif (cn_tab == NULL)\n\t\treturn (0);\n\n\t/*\n\t * always open the 'real' console device, so we don't get nailed\n\t * later.  This follows normal device semantics; they always get\n\t * open() calls.\n\t */\n\tdev = cn_tab->cn_dev;\n\tif (cn_devvp == NULLVP) {\n\t\t/* try to get a reference on its vnode, but fail silently */\n\t\tcdevvp(dev, &cn_devvp);\n\t}\n\treturn ((*cdevsw[major(dev)].d_open)(dev, flag, mode, p));\n}",
    "includes": [
      "#include <dev/cons.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/buf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct\tconsdev *cn_tab;",
      "struct\tvnode *cn_devvp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "dev",
            "flag",
            "mode",
            "p"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "major",
          "args": [
            "dev"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cdevvp",
          "args": [
            "dev",
            "&cn_devvp"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/cons.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct\tconsdev *cn_tab;\nstruct\tvnode *cn_devvp;\n\nint\ncnopen(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag, mode;\n\tstruct proc *p;\n{\n\n\tif (cn_tab == NULL)\n\t\treturn (0);\n\n\t/*\n\t * always open the 'real' console device, so we don't get nailed\n\t * later.  This follows normal device semantics; they always get\n\t * open() calls.\n\t */\n\tdev = cn_tab->cn_dev;\n\tif (cn_devvp == NULLVP) {\n\t\t/* try to get a reference on its vnode, but fail silently */\n\t\tcdevvp(dev, &cn_devvp);\n\t}\n\treturn ((*cdevsw[major(dev)].d_open)(dev, flag, mode, p));\n}"
  }
]