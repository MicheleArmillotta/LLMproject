[
  {
    "function_name": "rf_ReleaseBufferWaiter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconbuffer.c",
    "lines": "450-470",
    "snippet": "void \nrf_ReleaseBufferWaiter(rcPtr, rbuf)\n\tRF_ReconCtrl_t *rcPtr;\n\tRF_ReconBuffer_t *rbuf;\n{\n\tRF_CallbackDesc_t *cb, *cbt;\n\n\tfor (cbt = NULL, cb = rcPtr->bufferWaitList; cb; cbt = cb, cb = cb->next) {\n\t\tif ((cb->callbackArg.v == rbuf->parityStripeID) && (cb->callbackArg2.v == rbuf->which_ru)) {\n\t\t\tDprintf2(\"RECON: Dropping row %d col %d from buffer wait list\\n\", cb->row, cb->col);\n\t\t\tif (cbt)\n\t\t\t\tcbt->next = cb->next;\n\t\t\telse\n\t\t\t\trcPtr->bufferWaitList = cb->next;\n\t\t\trf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr, cb->row, cb->col, (void *) 0, RF_REVENT_BUFREADY);\t/* arg==0 => no\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t * committed buffer */\n\t\t\trf_FreeCallbackDesc(cb);\n\t\t\treturn;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_raid.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_FreeCallbackDesc",
          "args": [
            "cb"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeCallbackDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_callback.c",
          "lines": "89-94",
          "snippet": "void \nrf_FreeCallbackDesc(p)\n\tRF_CallbackDesc_t *p;\n{\n\tRF_FREELIST_FREE(rf_callback_freelist, p, next);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_callback_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_callback.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_callback_freelist;\n\nvoid \nrf_FreeCallbackDesc(p)\n\tRF_CallbackDesc_t *p;\n{\n\tRF_FREELIST_FREE(rf_callback_freelist, p, next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_CauseReconEvent",
          "args": [
            "(RF_Raid_t *) rbuf->raidPtr",
            "cb->row",
            "cb->col",
            "(void *) 0",
            "RF_REVENT_BUFREADY"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CauseReconEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_revent.c",
          "lines": "169-194",
          "snippet": "void \nrf_CauseReconEvent(raidPtr, row, col, arg, type)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n\tvoid   *arg;\n\tRF_Revent_t type;\n{\n\tRF_ReconCtrl_t *rctrl = raidPtr->reconControl[row];\n\tRF_ReconEvent_t *event = GetReconEventDesc(row, col, arg, type);\n\n\tif (type == RF_REVENT_BUFCLEAR) {\n\t\tRF_ASSERT(col != rctrl->fcol);\n\t}\n\tRF_ASSERT(row >= 0 && row <= raidPtr->numRow && col >= 0 && col <= raidPtr->numCol);\n\tRF_LOCK_MUTEX(rctrl->eq_mutex);\n\tRF_ASSERT((rctrl->eventQueue == NULL) == (rctrl->eq_count == 0));\t/* q null and count==0\n\t\t\t\t\t\t\t\t\t\t * must be equivalent\n\t\t\t\t\t\t\t\t\t\t * conditions */\n\tevent->next = rctrl->eventQueue;\n\trctrl->eventQueue = event;\n\trctrl->eq_count++;\n\tRF_UNLOCK_MUTEX(rctrl->eq_mutex);\n\n\tDO_SIGNAL(rctrl);\n}",
          "includes": [
            "#include <sys/proc.h>",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_ReconEvent_t *\nGetReconEventDesc(RF_RowCol_t row, RF_RowCol_t col,\n    void *arg, RF_Revent_t type);",
            "RF_RowCol_t row;",
            "static RF_ReconEvent_t *\nGetReconEventDesc(row, col, arg, type)\n\tRF_RowCol_t row;",
            "RF_RowCol_t col;",
            "void   *arg;",
            "RF_Revent_t type;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/proc.h>\n#include \"rf_shutdown.h\"\n#include \"rf_desc.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_revent.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n\nstatic RF_ReconEvent_t *\nGetReconEventDesc(RF_RowCol_t row, RF_RowCol_t col,\n    void *arg, RF_Revent_t type);\nRF_RowCol_t row;\nstatic RF_ReconEvent_t *\nGetReconEventDesc(row, col, arg, type)\n\tRF_RowCol_t row;\nRF_RowCol_t col;\nvoid   *arg;\nRF_Revent_t type;\n\nvoid \nrf_CauseReconEvent(raidPtr, row, col, arg, type)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n\tvoid   *arg;\n\tRF_Revent_t type;\n{\n\tRF_ReconCtrl_t *rctrl = raidPtr->reconControl[row];\n\tRF_ReconEvent_t *event = GetReconEventDesc(row, col, arg, type);\n\n\tif (type == RF_REVENT_BUFCLEAR) {\n\t\tRF_ASSERT(col != rctrl->fcol);\n\t}\n\tRF_ASSERT(row >= 0 && row <= raidPtr->numRow && col >= 0 && col <= raidPtr->numCol);\n\tRF_LOCK_MUTEX(rctrl->eq_mutex);\n\tRF_ASSERT((rctrl->eventQueue == NULL) == (rctrl->eq_count == 0));\t/* q null and count==0\n\t\t\t\t\t\t\t\t\t\t * must be equivalent\n\t\t\t\t\t\t\t\t\t\t * conditions */\n\tevent->next = rctrl->eventQueue;\n\trctrl->eventQueue = event;\n\trctrl->eq_count++;\n\tRF_UNLOCK_MUTEX(rctrl->eq_mutex);\n\n\tDO_SIGNAL(rctrl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf2",
          "args": [
            "\"RECON: Dropping row %d col %d from buffer wait list\\n\"",
            "cb->row",
            "cb->col"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_nwayxor.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_revent.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_raid.h\"\n\nvoid \nrf_ReleaseBufferWaiter(rcPtr, rbuf)\n\tRF_ReconCtrl_t *rcPtr;\n\tRF_ReconBuffer_t *rbuf;\n{\n\tRF_CallbackDesc_t *cb, *cbt;\n\n\tfor (cbt = NULL, cb = rcPtr->bufferWaitList; cb; cbt = cb, cb = cb->next) {\n\t\tif ((cb->callbackArg.v == rbuf->parityStripeID) && (cb->callbackArg2.v == rbuf->which_ru)) {\n\t\t\tDprintf2(\"RECON: Dropping row %d col %d from buffer wait list\\n\", cb->row, cb->col);\n\t\t\tif (cbt)\n\t\t\t\tcbt->next = cb->next;\n\t\t\telse\n\t\t\t\trcPtr->bufferWaitList = cb->next;\n\t\t\trf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr, cb->row, cb->col, (void *) 0, RF_REVENT_BUFREADY);\t/* arg==0 => no\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t * committed buffer */\n\t\t\trf_FreeCallbackDesc(cb);\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rf_ReleaseBufferWaiters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconbuffer.c",
    "lines": "423-442",
    "snippet": "void \nrf_ReleaseBufferWaiters(raidPtr, pssPtr)\n\tRF_Raid_t *raidPtr;\n\tRF_ReconParityStripeStatus_t *pssPtr;\n{\n\tRF_CallbackDesc_t *cb1, *cb = pssPtr->bufWaitList;\n\n\tDprintf2(\"RECON: releasing buf waiters for psid %ld ru %d\\n\",\n\t    (long) pssPtr->parityStripeID, pssPtr->which_ru);\n\tpssPtr->flags &= ~RF_PSS_BUFFERWAIT;\n\twhile (cb) {\n\t\tcb1 = cb->next;\n\t\tcb->next = NULL;\n\t\trf_CauseReconEvent(raidPtr, cb->row, cb->col, (void *) 0, RF_REVENT_BUFCLEAR);\t/* arg==0 => we haven't\n\t\t\t\t\t\t\t\t\t\t\t\t * committed a buffer */\n\t\trf_FreeCallbackDesc(cb);\n\t\tcb = cb1;\n\t}\n\tpssPtr->bufWaitList = NULL;\n}",
    "includes": [
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_raid.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_FreeCallbackDesc",
          "args": [
            "cb"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeCallbackDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_callback.c",
          "lines": "89-94",
          "snippet": "void \nrf_FreeCallbackDesc(p)\n\tRF_CallbackDesc_t *p;\n{\n\tRF_FREELIST_FREE(rf_callback_freelist, p, next);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_callback_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_callback.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_callback_freelist;\n\nvoid \nrf_FreeCallbackDesc(p)\n\tRF_CallbackDesc_t *p;\n{\n\tRF_FREELIST_FREE(rf_callback_freelist, p, next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_CauseReconEvent",
          "args": [
            "raidPtr",
            "cb->row",
            "cb->col",
            "(void *) 0",
            "RF_REVENT_BUFCLEAR"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CauseReconEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_revent.c",
          "lines": "169-194",
          "snippet": "void \nrf_CauseReconEvent(raidPtr, row, col, arg, type)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n\tvoid   *arg;\n\tRF_Revent_t type;\n{\n\tRF_ReconCtrl_t *rctrl = raidPtr->reconControl[row];\n\tRF_ReconEvent_t *event = GetReconEventDesc(row, col, arg, type);\n\n\tif (type == RF_REVENT_BUFCLEAR) {\n\t\tRF_ASSERT(col != rctrl->fcol);\n\t}\n\tRF_ASSERT(row >= 0 && row <= raidPtr->numRow && col >= 0 && col <= raidPtr->numCol);\n\tRF_LOCK_MUTEX(rctrl->eq_mutex);\n\tRF_ASSERT((rctrl->eventQueue == NULL) == (rctrl->eq_count == 0));\t/* q null and count==0\n\t\t\t\t\t\t\t\t\t\t * must be equivalent\n\t\t\t\t\t\t\t\t\t\t * conditions */\n\tevent->next = rctrl->eventQueue;\n\trctrl->eventQueue = event;\n\trctrl->eq_count++;\n\tRF_UNLOCK_MUTEX(rctrl->eq_mutex);\n\n\tDO_SIGNAL(rctrl);\n}",
          "includes": [
            "#include <sys/proc.h>",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_ReconEvent_t *\nGetReconEventDesc(RF_RowCol_t row, RF_RowCol_t col,\n    void *arg, RF_Revent_t type);",
            "RF_RowCol_t row;",
            "static RF_ReconEvent_t *\nGetReconEventDesc(row, col, arg, type)\n\tRF_RowCol_t row;",
            "RF_RowCol_t col;",
            "void   *arg;",
            "RF_Revent_t type;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/proc.h>\n#include \"rf_shutdown.h\"\n#include \"rf_desc.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_revent.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n\nstatic RF_ReconEvent_t *\nGetReconEventDesc(RF_RowCol_t row, RF_RowCol_t col,\n    void *arg, RF_Revent_t type);\nRF_RowCol_t row;\nstatic RF_ReconEvent_t *\nGetReconEventDesc(row, col, arg, type)\n\tRF_RowCol_t row;\nRF_RowCol_t col;\nvoid   *arg;\nRF_Revent_t type;\n\nvoid \nrf_CauseReconEvent(raidPtr, row, col, arg, type)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n\tvoid   *arg;\n\tRF_Revent_t type;\n{\n\tRF_ReconCtrl_t *rctrl = raidPtr->reconControl[row];\n\tRF_ReconEvent_t *event = GetReconEventDesc(row, col, arg, type);\n\n\tif (type == RF_REVENT_BUFCLEAR) {\n\t\tRF_ASSERT(col != rctrl->fcol);\n\t}\n\tRF_ASSERT(row >= 0 && row <= raidPtr->numRow && col >= 0 && col <= raidPtr->numCol);\n\tRF_LOCK_MUTEX(rctrl->eq_mutex);\n\tRF_ASSERT((rctrl->eventQueue == NULL) == (rctrl->eq_count == 0));\t/* q null and count==0\n\t\t\t\t\t\t\t\t\t\t * must be equivalent\n\t\t\t\t\t\t\t\t\t\t * conditions */\n\tevent->next = rctrl->eventQueue;\n\trctrl->eventQueue = event;\n\trctrl->eq_count++;\n\tRF_UNLOCK_MUTEX(rctrl->eq_mutex);\n\n\tDO_SIGNAL(rctrl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf2",
          "args": [
            "\"RECON: releasing buf waiters for psid %ld ru %d\\n\"",
            "(long) pssPtr->parityStripeID",
            "pssPtr->which_ru"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_nwayxor.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_revent.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_raid.h\"\n\nvoid \nrf_ReleaseBufferWaiters(raidPtr, pssPtr)\n\tRF_Raid_t *raidPtr;\n\tRF_ReconParityStripeStatus_t *pssPtr;\n{\n\tRF_CallbackDesc_t *cb1, *cb = pssPtr->bufWaitList;\n\n\tDprintf2(\"RECON: releasing buf waiters for psid %ld ru %d\\n\",\n\t    (long) pssPtr->parityStripeID, pssPtr->which_ru);\n\tpssPtr->flags &= ~RF_PSS_BUFFERWAIT;\n\twhile (cb) {\n\t\tcb1 = cb->next;\n\t\tcb->next = NULL;\n\t\trf_CauseReconEvent(raidPtr, cb->row, cb->col, (void *) 0, RF_REVENT_BUFCLEAR);\t/* arg==0 => we haven't\n\t\t\t\t\t\t\t\t\t\t\t\t * committed a buffer */\n\t\trf_FreeCallbackDesc(cb);\n\t\tcb = cb1;\n\t}\n\tpssPtr->bufWaitList = NULL;\n}"
  },
  {
    "function_name": "rf_ReleaseFloatingReconBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconbuffer.c",
    "lines": "392-419",
    "snippet": "void \nrf_ReleaseFloatingReconBuffer(raidPtr, row, rbuf)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_ReconBuffer_t *rbuf;\n{\n\tRF_ReconCtrl_t *rcPtr = raidPtr->reconControl[row];\n\tRF_CallbackDesc_t *cb;\n\n\tDprintf2(\"RECON: releasing rbuf for psid %ld ru %d\\n\",\n\t    (long) rbuf->parityStripeID, rbuf->which_ru);\n\n\t/* if anyone is waiting on buffers, wake one of them up.  They will\n\t * subsequently wake up anyone else waiting on their RU */\n\tif (rcPtr->bufferWaitList) {\n\t\trbuf->next = rcPtr->committedRbufs;\n\t\trcPtr->committedRbufs = rbuf;\n\t\tcb = rcPtr->bufferWaitList;\n\t\trcPtr->bufferWaitList = cb->next;\n\t\trf_CauseReconEvent(raidPtr, cb->row, cb->col, (void *) 1, RF_REVENT_BUFCLEAR);\t/* arg==1 => we've\n\t\t\t\t\t\t\t\t\t\t\t\t * committed a buffer */\n\t\trf_FreeCallbackDesc(cb);\n\t\traidPtr->procsInBufWait--;\n\t} else {\n\t\trbuf->next = rcPtr->floatingRbufs;\n\t\trcPtr->floatingRbufs = rbuf;\n\t}\n}",
    "includes": [
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_raid.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_FreeCallbackDesc",
          "args": [
            "cb"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeCallbackDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_callback.c",
          "lines": "89-94",
          "snippet": "void \nrf_FreeCallbackDesc(p)\n\tRF_CallbackDesc_t *p;\n{\n\tRF_FREELIST_FREE(rf_callback_freelist, p, next);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_callback_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_callback.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_callback_freelist;\n\nvoid \nrf_FreeCallbackDesc(p)\n\tRF_CallbackDesc_t *p;\n{\n\tRF_FREELIST_FREE(rf_callback_freelist, p, next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_CauseReconEvent",
          "args": [
            "raidPtr",
            "cb->row",
            "cb->col",
            "(void *) 1",
            "RF_REVENT_BUFCLEAR"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CauseReconEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_revent.c",
          "lines": "169-194",
          "snippet": "void \nrf_CauseReconEvent(raidPtr, row, col, arg, type)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n\tvoid   *arg;\n\tRF_Revent_t type;\n{\n\tRF_ReconCtrl_t *rctrl = raidPtr->reconControl[row];\n\tRF_ReconEvent_t *event = GetReconEventDesc(row, col, arg, type);\n\n\tif (type == RF_REVENT_BUFCLEAR) {\n\t\tRF_ASSERT(col != rctrl->fcol);\n\t}\n\tRF_ASSERT(row >= 0 && row <= raidPtr->numRow && col >= 0 && col <= raidPtr->numCol);\n\tRF_LOCK_MUTEX(rctrl->eq_mutex);\n\tRF_ASSERT((rctrl->eventQueue == NULL) == (rctrl->eq_count == 0));\t/* q null and count==0\n\t\t\t\t\t\t\t\t\t\t * must be equivalent\n\t\t\t\t\t\t\t\t\t\t * conditions */\n\tevent->next = rctrl->eventQueue;\n\trctrl->eventQueue = event;\n\trctrl->eq_count++;\n\tRF_UNLOCK_MUTEX(rctrl->eq_mutex);\n\n\tDO_SIGNAL(rctrl);\n}",
          "includes": [
            "#include <sys/proc.h>",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_ReconEvent_t *\nGetReconEventDesc(RF_RowCol_t row, RF_RowCol_t col,\n    void *arg, RF_Revent_t type);",
            "RF_RowCol_t row;",
            "static RF_ReconEvent_t *\nGetReconEventDesc(row, col, arg, type)\n\tRF_RowCol_t row;",
            "RF_RowCol_t col;",
            "void   *arg;",
            "RF_Revent_t type;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/proc.h>\n#include \"rf_shutdown.h\"\n#include \"rf_desc.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_revent.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n\nstatic RF_ReconEvent_t *\nGetReconEventDesc(RF_RowCol_t row, RF_RowCol_t col,\n    void *arg, RF_Revent_t type);\nRF_RowCol_t row;\nstatic RF_ReconEvent_t *\nGetReconEventDesc(row, col, arg, type)\n\tRF_RowCol_t row;\nRF_RowCol_t col;\nvoid   *arg;\nRF_Revent_t type;\n\nvoid \nrf_CauseReconEvent(raidPtr, row, col, arg, type)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n\tvoid   *arg;\n\tRF_Revent_t type;\n{\n\tRF_ReconCtrl_t *rctrl = raidPtr->reconControl[row];\n\tRF_ReconEvent_t *event = GetReconEventDesc(row, col, arg, type);\n\n\tif (type == RF_REVENT_BUFCLEAR) {\n\t\tRF_ASSERT(col != rctrl->fcol);\n\t}\n\tRF_ASSERT(row >= 0 && row <= raidPtr->numRow && col >= 0 && col <= raidPtr->numCol);\n\tRF_LOCK_MUTEX(rctrl->eq_mutex);\n\tRF_ASSERT((rctrl->eventQueue == NULL) == (rctrl->eq_count == 0));\t/* q null and count==0\n\t\t\t\t\t\t\t\t\t\t * must be equivalent\n\t\t\t\t\t\t\t\t\t\t * conditions */\n\tevent->next = rctrl->eventQueue;\n\trctrl->eventQueue = event;\n\trctrl->eq_count++;\n\tRF_UNLOCK_MUTEX(rctrl->eq_mutex);\n\n\tDO_SIGNAL(rctrl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf2",
          "args": [
            "\"RECON: releasing rbuf for psid %ld ru %d\\n\"",
            "(long) rbuf->parityStripeID",
            "rbuf->which_ru"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_nwayxor.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_revent.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_raid.h\"\n\nvoid \nrf_ReleaseFloatingReconBuffer(raidPtr, row, rbuf)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_ReconBuffer_t *rbuf;\n{\n\tRF_ReconCtrl_t *rcPtr = raidPtr->reconControl[row];\n\tRF_CallbackDesc_t *cb;\n\n\tDprintf2(\"RECON: releasing rbuf for psid %ld ru %d\\n\",\n\t    (long) rbuf->parityStripeID, rbuf->which_ru);\n\n\t/* if anyone is waiting on buffers, wake one of them up.  They will\n\t * subsequently wake up anyone else waiting on their RU */\n\tif (rcPtr->bufferWaitList) {\n\t\trbuf->next = rcPtr->committedRbufs;\n\t\trcPtr->committedRbufs = rbuf;\n\t\tcb = rcPtr->bufferWaitList;\n\t\trcPtr->bufferWaitList = cb->next;\n\t\trf_CauseReconEvent(raidPtr, cb->row, cb->col, (void *) 1, RF_REVENT_BUFCLEAR);\t/* arg==1 => we've\n\t\t\t\t\t\t\t\t\t\t\t\t * committed a buffer */\n\t\trf_FreeCallbackDesc(cb);\n\t\traidPtr->procsInBufWait--;\n\t} else {\n\t\trbuf->next = rcPtr->floatingRbufs;\n\t\trcPtr->floatingRbufs = rbuf;\n\t}\n}"
  },
  {
    "function_name": "rf_CheckForFullRbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconbuffer.c",
    "lines": "349-386",
    "snippet": "int \nrf_CheckForFullRbuf(raidPtr, reconCtrl, pssPtr, numDataCol)\n\tRF_Raid_t *raidPtr;\n\tRF_ReconCtrl_t *reconCtrl;\n\tRF_ReconParityStripeStatus_t *pssPtr;\n\tint     numDataCol;\n{\n\tRF_ReconBuffer_t *p, *pt, *rbuf = (RF_ReconBuffer_t *) pssPtr->rbuf;\n\n\tif (rbuf->count == numDataCol) {\n\t\traidPtr->numFullReconBuffers++;\n\t\tDprintf2(\"RECON: rbuf for psid %ld ru %d has filled\\n\",\n\t\t    (long) rbuf->parityStripeID, rbuf->which_ru);\n\t\tif (!reconCtrl->fullBufferList || (rbuf->failedDiskSectorOffset < reconCtrl->fullBufferList->failedDiskSectorOffset)) {\n\t\t\tDprintf2(\"RECON: rbuf for psid %ld ru %d is head of list\\n\",\n\t\t\t    (long) rbuf->parityStripeID, rbuf->which_ru);\n\t\t\trbuf->next = reconCtrl->fullBufferList;\n\t\t\treconCtrl->fullBufferList = rbuf;\n\t\t} else {\n\t\t\tfor (pt = reconCtrl->fullBufferList, p = pt->next; p && p->failedDiskSectorOffset < rbuf->failedDiskSectorOffset; pt = p, p = p->next);\n\t\t\trbuf->next = p;\n\t\t\tpt->next = rbuf;\n\t\t\tDprintf2(\"RECON: rbuf for psid %ld ru %d is in list\\n\",\n\t\t\t    (long) rbuf->parityStripeID, rbuf->which_ru);\n\t\t}\n#if 0\n\t\tpssPtr->writeRbuf = pssPtr->rbuf;\t/* DEBUG ONLY:  we like\n\t\t\t\t\t\t\t * to be able to find\n\t\t\t\t\t\t\t * this rbuf while it's\n\t\t\t\t\t\t\t * awaiting write */\n#else\n\t\trbuf->pssPtr = pssPtr;\n#endif\n\t\tpssPtr->rbuf = NULL;\n\t\trf_CauseReconEvent(raidPtr, rbuf->row, rbuf->col, NULL, RF_REVENT_BUFREADY);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_raid.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_CauseReconEvent",
          "args": [
            "raidPtr",
            "rbuf->row",
            "rbuf->col",
            "NULL",
            "RF_REVENT_BUFREADY"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CauseReconEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_revent.c",
          "lines": "169-194",
          "snippet": "void \nrf_CauseReconEvent(raidPtr, row, col, arg, type)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n\tvoid   *arg;\n\tRF_Revent_t type;\n{\n\tRF_ReconCtrl_t *rctrl = raidPtr->reconControl[row];\n\tRF_ReconEvent_t *event = GetReconEventDesc(row, col, arg, type);\n\n\tif (type == RF_REVENT_BUFCLEAR) {\n\t\tRF_ASSERT(col != rctrl->fcol);\n\t}\n\tRF_ASSERT(row >= 0 && row <= raidPtr->numRow && col >= 0 && col <= raidPtr->numCol);\n\tRF_LOCK_MUTEX(rctrl->eq_mutex);\n\tRF_ASSERT((rctrl->eventQueue == NULL) == (rctrl->eq_count == 0));\t/* q null and count==0\n\t\t\t\t\t\t\t\t\t\t * must be equivalent\n\t\t\t\t\t\t\t\t\t\t * conditions */\n\tevent->next = rctrl->eventQueue;\n\trctrl->eventQueue = event;\n\trctrl->eq_count++;\n\tRF_UNLOCK_MUTEX(rctrl->eq_mutex);\n\n\tDO_SIGNAL(rctrl);\n}",
          "includes": [
            "#include <sys/proc.h>",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_ReconEvent_t *\nGetReconEventDesc(RF_RowCol_t row, RF_RowCol_t col,\n    void *arg, RF_Revent_t type);",
            "RF_RowCol_t row;",
            "static RF_ReconEvent_t *\nGetReconEventDesc(row, col, arg, type)\n\tRF_RowCol_t row;",
            "RF_RowCol_t col;",
            "void   *arg;",
            "RF_Revent_t type;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/proc.h>\n#include \"rf_shutdown.h\"\n#include \"rf_desc.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_revent.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n\nstatic RF_ReconEvent_t *\nGetReconEventDesc(RF_RowCol_t row, RF_RowCol_t col,\n    void *arg, RF_Revent_t type);\nRF_RowCol_t row;\nstatic RF_ReconEvent_t *\nGetReconEventDesc(row, col, arg, type)\n\tRF_RowCol_t row;\nRF_RowCol_t col;\nvoid   *arg;\nRF_Revent_t type;\n\nvoid \nrf_CauseReconEvent(raidPtr, row, col, arg, type)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n\tvoid   *arg;\n\tRF_Revent_t type;\n{\n\tRF_ReconCtrl_t *rctrl = raidPtr->reconControl[row];\n\tRF_ReconEvent_t *event = GetReconEventDesc(row, col, arg, type);\n\n\tif (type == RF_REVENT_BUFCLEAR) {\n\t\tRF_ASSERT(col != rctrl->fcol);\n\t}\n\tRF_ASSERT(row >= 0 && row <= raidPtr->numRow && col >= 0 && col <= raidPtr->numCol);\n\tRF_LOCK_MUTEX(rctrl->eq_mutex);\n\tRF_ASSERT((rctrl->eventQueue == NULL) == (rctrl->eq_count == 0));\t/* q null and count==0\n\t\t\t\t\t\t\t\t\t\t * must be equivalent\n\t\t\t\t\t\t\t\t\t\t * conditions */\n\tevent->next = rctrl->eventQueue;\n\trctrl->eventQueue = event;\n\trctrl->eq_count++;\n\tRF_UNLOCK_MUTEX(rctrl->eq_mutex);\n\n\tDO_SIGNAL(rctrl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf2",
          "args": [
            "\"RECON: rbuf for psid %ld ru %d is in list\\n\"",
            "(long) rbuf->parityStripeID",
            "rbuf->which_ru"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf2",
          "args": [
            "\"RECON: rbuf for psid %ld ru %d is head of list\\n\"",
            "(long) rbuf->parityStripeID",
            "rbuf->which_ru"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf2",
          "args": [
            "\"RECON: rbuf for psid %ld ru %d has filled\\n\"",
            "(long) rbuf->parityStripeID",
            "rbuf->which_ru"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_nwayxor.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_revent.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_raid.h\"\n\nint \nrf_CheckForFullRbuf(raidPtr, reconCtrl, pssPtr, numDataCol)\n\tRF_Raid_t *raidPtr;\n\tRF_ReconCtrl_t *reconCtrl;\n\tRF_ReconParityStripeStatus_t *pssPtr;\n\tint     numDataCol;\n{\n\tRF_ReconBuffer_t *p, *pt, *rbuf = (RF_ReconBuffer_t *) pssPtr->rbuf;\n\n\tif (rbuf->count == numDataCol) {\n\t\traidPtr->numFullReconBuffers++;\n\t\tDprintf2(\"RECON: rbuf for psid %ld ru %d has filled\\n\",\n\t\t    (long) rbuf->parityStripeID, rbuf->which_ru);\n\t\tif (!reconCtrl->fullBufferList || (rbuf->failedDiskSectorOffset < reconCtrl->fullBufferList->failedDiskSectorOffset)) {\n\t\t\tDprintf2(\"RECON: rbuf for psid %ld ru %d is head of list\\n\",\n\t\t\t    (long) rbuf->parityStripeID, rbuf->which_ru);\n\t\t\trbuf->next = reconCtrl->fullBufferList;\n\t\t\treconCtrl->fullBufferList = rbuf;\n\t\t} else {\n\t\t\tfor (pt = reconCtrl->fullBufferList, p = pt->next; p && p->failedDiskSectorOffset < rbuf->failedDiskSectorOffset; pt = p, p = p->next);\n\t\t\trbuf->next = p;\n\t\t\tpt->next = rbuf;\n\t\t\tDprintf2(\"RECON: rbuf for psid %ld ru %d is in list\\n\",\n\t\t\t    (long) rbuf->parityStripeID, rbuf->which_ru);\n\t\t}\n#if 0\n\t\tpssPtr->writeRbuf = pssPtr->rbuf;\t/* DEBUG ONLY:  we like\n\t\t\t\t\t\t\t * to be able to find\n\t\t\t\t\t\t\t * this rbuf while it's\n\t\t\t\t\t\t\t * awaiting write */\n#else\n\t\trbuf->pssPtr = pssPtr;\n#endif\n\t\tpssPtr->rbuf = NULL;\n\t\trf_CauseReconEvent(raidPtr, rbuf->row, rbuf->col, NULL, RF_REVENT_BUFREADY);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_MultiWayReconXor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconbuffer.c",
    "lines": "275-315",
    "snippet": "int \nrf_MultiWayReconXor(raidPtr, pssPtr)\n\tRF_Raid_t *raidPtr;\n\tRF_ReconParityStripeStatus_t *pssPtr;\t/* the pss descriptor for this\n\t\t\t\t\t\t * parity stripe */\n{\n\tint     i, numBufs = pssPtr->xorBufCount;\n\tint     numBytes = rf_RaidAddressToByte(raidPtr, raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU);\n\tRF_ReconBuffer_t **rbufs = (RF_ReconBuffer_t **) pssPtr->rbufsForXor;\n\tRF_ReconBuffer_t *targetRbuf = (RF_ReconBuffer_t *) pssPtr->rbuf;\n\n\tRF_ASSERT(pssPtr->rbuf != NULL);\n\tRF_ASSERT(numBufs > 0 && numBufs < RF_PS_MAX_BUFS);\n#ifdef _KERNEL\n#if !defined(__NetBSD__) && !defined(__OpenBSD__)\n\tthread_block();\t\t/* yield the processor before doing a big XOR */\n#endif\n#endif\t\t\t\t/* _KERNEL */\n\t/*\n         * XXX\n         *\n         * What if more than 9 bufs?\n         */\n\tnWayXorFuncs[numBufs] (pssPtr->rbufsForXor, targetRbuf, numBytes / sizeof(long));\n\n\t/* release all the reconstruction buffers except the last one, which\n\t * belongs to the the disk who's submission caused this XOR to take\n\t * place */\n\tfor (i = 0; i < numBufs - 1; i++) {\n\t\tif (rbufs[i]->type == RF_RBUF_TYPE_FLOATING)\n\t\t\trf_ReleaseFloatingReconBuffer(raidPtr, rbufs[i]->row, rbufs[i]);\n\t\telse\n\t\t\tif (rbufs[i]->type == RF_RBUF_TYPE_FORCED)\n\t\t\t\trf_FreeReconBuffer(rbufs[i]);\n\t\t\telse\n\t\t\t\tRF_ASSERT(0);\n\t}\n\ttargetRbuf->count += pssPtr->xorBufCount;\n\tpssPtr->xorBufCount = 0;\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_raid.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RF_VoidFuncPtr nWayXorFuncs[] = {\n\tNULL,\n\t(RF_VoidFuncPtr) rf_nWayXor1,\n\t(RF_VoidFuncPtr) rf_nWayXor2,\n\t(RF_VoidFuncPtr) rf_nWayXor3,\n\t(RF_VoidFuncPtr) rf_nWayXor4,\n\t(RF_VoidFuncPtr) rf_nWayXor5,\n\t(RF_VoidFuncPtr) rf_nWayXor6,\n\t(RF_VoidFuncPtr) rf_nWayXor7,\n\t(RF_VoidFuncPtr) rf_nWayXor8,\n\t(RF_VoidFuncPtr) rf_nWayXor9\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "0"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_FreeReconBuffer",
          "args": [
            "rbufs[i]"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeReconBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconutil.c",
          "lines": "256-266",
          "snippet": "void \nrf_FreeReconBuffer(rbuf)\n\tRF_ReconBuffer_t *rbuf;\n{\n\tRF_Raid_t *raidPtr = rbuf->raidPtr;\n\tu_int   recon_buffer_size = rf_RaidAddressToByte(raidPtr, raidPtr->Layout.SUsPerRU * raidPtr->Layout.sectorsPerStripeUnit);\n\n\tRF_Free(rbuf->arrived, raidPtr->numCol * sizeof(char));\n\tRF_Free(rbuf->buffer, recon_buffer_size);\n\tRF_Free(rbuf, sizeof(*rbuf));\n}",
          "includes": [
            "#include \"rf_chaindecluster.h\"",
            "#include \"rf_interdecluster.h\"",
            "#include \"rf_raid5_rotatedspare.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_chaindecluster.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid5_rotatedspare.h\"\n#include \"rf_decluster.h\"\n#include \"rf_general.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_desc.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_FreeReconBuffer(rbuf)\n\tRF_ReconBuffer_t *rbuf;\n{\n\tRF_Raid_t *raidPtr = rbuf->raidPtr;\n\tu_int   recon_buffer_size = rf_RaidAddressToByte(raidPtr, raidPtr->Layout.SUsPerRU * raidPtr->Layout.sectorsPerStripeUnit);\n\n\tRF_Free(rbuf->arrived, raidPtr->numCol * sizeof(char));\n\tRF_Free(rbuf->buffer, recon_buffer_size);\n\tRF_Free(rbuf, sizeof(*rbuf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_ReleaseFloatingReconBuffer",
          "args": [
            "raidPtr",
            "rbufs[i]->row",
            "rbufs[i]"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ReleaseFloatingReconBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconbuffer.c",
          "lines": "392-419",
          "snippet": "void \nrf_ReleaseFloatingReconBuffer(raidPtr, row, rbuf)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_ReconBuffer_t *rbuf;\n{\n\tRF_ReconCtrl_t *rcPtr = raidPtr->reconControl[row];\n\tRF_CallbackDesc_t *cb;\n\n\tDprintf2(\"RECON: releasing rbuf for psid %ld ru %d\\n\",\n\t    (long) rbuf->parityStripeID, rbuf->which_ru);\n\n\t/* if anyone is waiting on buffers, wake one of them up.  They will\n\t * subsequently wake up anyone else waiting on their RU */\n\tif (rcPtr->bufferWaitList) {\n\t\trbuf->next = rcPtr->committedRbufs;\n\t\trcPtr->committedRbufs = rbuf;\n\t\tcb = rcPtr->bufferWaitList;\n\t\trcPtr->bufferWaitList = cb->next;\n\t\trf_CauseReconEvent(raidPtr, cb->row, cb->col, (void *) 1, RF_REVENT_BUFCLEAR);\t/* arg==1 => we've\n\t\t\t\t\t\t\t\t\t\t\t\t * committed a buffer */\n\t\trf_FreeCallbackDesc(cb);\n\t\traidPtr->procsInBufWait--;\n\t} else {\n\t\trbuf->next = rcPtr->floatingRbufs;\n\t\trcPtr->floatingRbufs = rbuf;\n\t}\n}",
          "includes": [
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_raid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_nwayxor.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_revent.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_raid.h\"\n\nvoid \nrf_ReleaseFloatingReconBuffer(raidPtr, row, rbuf)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_ReconBuffer_t *rbuf;\n{\n\tRF_ReconCtrl_t *rcPtr = raidPtr->reconControl[row];\n\tRF_CallbackDesc_t *cb;\n\n\tDprintf2(\"RECON: releasing rbuf for psid %ld ru %d\\n\",\n\t    (long) rbuf->parityStripeID, rbuf->which_ru);\n\n\t/* if anyone is waiting on buffers, wake one of them up.  They will\n\t * subsequently wake up anyone else waiting on their RU */\n\tif (rcPtr->bufferWaitList) {\n\t\trbuf->next = rcPtr->committedRbufs;\n\t\trcPtr->committedRbufs = rbuf;\n\t\tcb = rcPtr->bufferWaitList;\n\t\trcPtr->bufferWaitList = cb->next;\n\t\trf_CauseReconEvent(raidPtr, cb->row, cb->col, (void *) 1, RF_REVENT_BUFCLEAR);\t/* arg==1 => we've\n\t\t\t\t\t\t\t\t\t\t\t\t * committed a buffer */\n\t\trf_FreeCallbackDesc(cb);\n\t\traidPtr->procsInBufWait--;\n\t} else {\n\t\trbuf->next = rcPtr->floatingRbufs;\n\t\trcPtr->floatingRbufs = rbuf;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nWayXorFuncs[numBufs]",
          "args": [
            "pssPtr->rbufsForXor",
            "targetRbuf",
            "numBytes / sizeof(long)"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_block",
          "args": [],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "numBufs > 0 && numBufs < RF_PS_MAX_BUFS"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "pssPtr->rbuf != NULL"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_nwayxor.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_revent.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_raid.h\"\n\nstatic RF_VoidFuncPtr nWayXorFuncs[] = {\n\tNULL,\n\t(RF_VoidFuncPtr) rf_nWayXor1,\n\t(RF_VoidFuncPtr) rf_nWayXor2,\n\t(RF_VoidFuncPtr) rf_nWayXor3,\n\t(RF_VoidFuncPtr) rf_nWayXor4,\n\t(RF_VoidFuncPtr) rf_nWayXor5,\n\t(RF_VoidFuncPtr) rf_nWayXor6,\n\t(RF_VoidFuncPtr) rf_nWayXor7,\n\t(RF_VoidFuncPtr) rf_nWayXor8,\n\t(RF_VoidFuncPtr) rf_nWayXor9\n};\n\nint \nrf_MultiWayReconXor(raidPtr, pssPtr)\n\tRF_Raid_t *raidPtr;\n\tRF_ReconParityStripeStatus_t *pssPtr;\t/* the pss descriptor for this\n\t\t\t\t\t\t * parity stripe */\n{\n\tint     i, numBufs = pssPtr->xorBufCount;\n\tint     numBytes = rf_RaidAddressToByte(raidPtr, raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU);\n\tRF_ReconBuffer_t **rbufs = (RF_ReconBuffer_t **) pssPtr->rbufsForXor;\n\tRF_ReconBuffer_t *targetRbuf = (RF_ReconBuffer_t *) pssPtr->rbuf;\n\n\tRF_ASSERT(pssPtr->rbuf != NULL);\n\tRF_ASSERT(numBufs > 0 && numBufs < RF_PS_MAX_BUFS);\n#ifdef _KERNEL\n#if !defined(__NetBSD__) && !defined(__OpenBSD__)\n\tthread_block();\t\t/* yield the processor before doing a big XOR */\n#endif\n#endif\t\t\t\t/* _KERNEL */\n\t/*\n         * XXX\n         *\n         * What if more than 9 bufs?\n         */\n\tnWayXorFuncs[numBufs] (pssPtr->rbufsForXor, targetRbuf, numBytes / sizeof(long));\n\n\t/* release all the reconstruction buffers except the last one, which\n\t * belongs to the the disk who's submission caused this XOR to take\n\t * place */\n\tfor (i = 0; i < numBufs - 1; i++) {\n\t\tif (rbufs[i]->type == RF_RBUF_TYPE_FLOATING)\n\t\t\trf_ReleaseFloatingReconBuffer(raidPtr, rbufs[i]->row, rbufs[i]);\n\t\telse\n\t\t\tif (rbufs[i]->type == RF_RBUF_TYPE_FORCED)\n\t\t\t\trf_FreeReconBuffer(rbufs[i]);\n\t\t\telse\n\t\t\t\tRF_ASSERT(0);\n\t}\n\ttargetRbuf->count += pssPtr->xorBufCount;\n\tpssPtr->xorBufCount = 0;\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_SubmitReconBufferBasic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconbuffer.c",
    "lines": "104-273",
    "snippet": "int \nrf_SubmitReconBufferBasic(rbuf, keep_it, use_committed)\n\tRF_ReconBuffer_t *rbuf;\t/* the recon buffer to submit */\n\tint     keep_it;\t/* whether we can keep this buffer or we have\n\t\t\t\t * to return it */\n\tint     use_committed;\t/* whether to use a committed or an available\n\t\t\t\t * recon buffer */\n{\n\tRF_Raid_t *raidPtr = rbuf->raidPtr;\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_ReconCtrl_t *reconCtrlPtr = raidPtr->reconControl[rbuf->row];\n\tRF_ReconParityStripeStatus_t *pssPtr;\n\tRF_ReconBuffer_t *targetRbuf, *t = NULL;\t/* temporary rbuf\n\t\t\t\t\t\t\t * pointers */\n\tcaddr_t ta;\t\t/* temporary data buffer pointer */\n\tRF_CallbackDesc_t *cb, *p;\n\tint     retcode = 0, created = 0;\n\n\tRF_Etimer_t timer;\n\n\t/* makes no sense to have a submission from the failed disk */\n\tRF_ASSERT(rbuf);\n\tRF_ASSERT(rbuf->col != reconCtrlPtr->fcol);\n\n\tDprintf5(\"RECON: submission by row %d col %d for psid %ld ru %d (failed offset %ld)\\n\",\n\t    rbuf->row, rbuf->col, (long) rbuf->parityStripeID, rbuf->which_ru, (long) rbuf->failedDiskSectorOffset);\n\n\tRF_LOCK_PSS_MUTEX(raidPtr, rbuf->row, rbuf->parityStripeID);\n\n\tRF_LOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\n\tpssPtr = rf_LookupRUStatus(raidPtr, reconCtrlPtr->pssTable, rbuf->parityStripeID, rbuf->which_ru, RF_PSS_NONE, &created);\n\tRF_ASSERT(pssPtr);\t/* if it didn't exist, we wouldn't have gotten\n\t\t\t\t * an rbuf for it */\n\n\t/* check to see if enough buffers have accumulated to do an XOR.  If\n\t * so, there's no need to acquire a floating rbuf.  Before we can do\n\t * any XORing, we must have acquired a destination buffer.  If we\n\t * have, then we can go ahead and do the XOR if (1) including this\n\t * buffer, enough bufs have accumulated, or (2) this is the last\n\t * submission for this stripe. Otherwise, we have to go acquire a\n\t * floating rbuf. */\n\n\ttargetRbuf = (RF_ReconBuffer_t *) pssPtr->rbuf;\n\tif ((targetRbuf != NULL) &&\n\t    ((pssPtr->xorBufCount == rf_numBufsToAccumulate - 1) || (targetRbuf->count + pssPtr->xorBufCount + 1 == layoutPtr->numDataCol))) {\n\t\tpssPtr->rbufsForXor[pssPtr->xorBufCount++] = rbuf;\t/* install this buffer */\n\t\tDprintf3(\"RECON: row %d col %d invoking a %d-way XOR\\n\", rbuf->row, rbuf->col, pssPtr->xorBufCount);\n\t\tRF_ETIMER_START(timer);\n\t\trf_MultiWayReconXor(raidPtr, pssPtr);\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\traidPtr->accumXorTimeUs += RF_ETIMER_VAL_US(timer);\n\t\tif (!keep_it) {\n\t\t\traidPtr->recon_tracerecs[rbuf->col].xor_us = RF_ETIMER_VAL_US(timer);\n\t\t\tRF_ETIMER_STOP(raidPtr->recon_tracerecs[rbuf->col].recon_timer);\n\t\t\tRF_ETIMER_EVAL(raidPtr->recon_tracerecs[rbuf->col].recon_timer);\n\t\t\traidPtr->recon_tracerecs[rbuf->col].specific.recon.recon_return_to_submit_us +=\n\t\t\t    RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[rbuf->col].recon_timer);\n\t\t\tRF_ETIMER_START(raidPtr->recon_tracerecs[rbuf->col].recon_timer);\n\n\t\t\trf_LogTraceRec(raidPtr, &raidPtr->recon_tracerecs[rbuf->col]);\n\t\t}\n\t\trf_CheckForFullRbuf(raidPtr, reconCtrlPtr, pssPtr, layoutPtr->numDataCol);\n\n\t\t/* if use_committed is on, we _must_ consume a buffer off the\n\t\t * committed list. */\n\t\tif (use_committed) {\n\t\t\tt = reconCtrlPtr->committedRbufs;\n\t\t\tRF_ASSERT(t);\n\t\t\treconCtrlPtr->committedRbufs = t->next;\n\t\t\trf_ReleaseFloatingReconBuffer(raidPtr, rbuf->row, t);\n\t\t}\n\t\tif (keep_it) {\n\t\t\tRF_UNLOCK_PSS_MUTEX(raidPtr, rbuf->row, rbuf->parityStripeID);\n\t\t\tRF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\t\t\trf_FreeReconBuffer(rbuf);\n\t\t\treturn (retcode);\n\t\t}\n\t\tgoto out;\n\t}\n\t/* set the value of \"t\", which we'll use as the rbuf from here on */\n\tif (keep_it) {\n\t\tt = rbuf;\n\t} else {\n\t\tif (use_committed) {\t/* if a buffer has been committed to\n\t\t\t\t\t * us, use it */\n\t\t\tt = reconCtrlPtr->committedRbufs;\n\t\t\tRF_ASSERT(t);\n\t\t\treconCtrlPtr->committedRbufs = t->next;\n\t\t\tt->next = NULL;\n\t\t} else\n\t\t\tif (reconCtrlPtr->floatingRbufs) {\n\t\t\t\tt = reconCtrlPtr->floatingRbufs;\n\t\t\t\treconCtrlPtr->floatingRbufs = t->next;\n\t\t\t\tt->next = NULL;\n\t\t\t}\n\t}\n\n\t/* If we weren't able to acquire a buffer, append to the end of the\n\t * buf list in the recon ctrl struct. */\n\tif (!t) {\n\t\tRF_ASSERT(!keep_it && !use_committed);\n\t\tDprintf2(\"RECON: row %d col %d failed to acquire floating rbuf\\n\", rbuf->row, rbuf->col);\n\n\t\traidPtr->procsInBufWait++;\n\t\tif ((raidPtr->procsInBufWait == raidPtr->numCol - 1) && (raidPtr->numFullReconBuffers == 0)) {\n\t\t\tprintf(\"Buffer wait deadlock detected.  Exiting.\\n\");\n\t\t\trf_PrintPSStatusTable(raidPtr, rbuf->row);\n\t\t\tRF_PANIC();\n\t\t}\n\t\tpssPtr->flags |= RF_PSS_BUFFERWAIT;\n\t\tcb = rf_AllocCallbackDesc();\t/* append to buf wait list in\n\t\t\t\t\t\t * recon ctrl structure */\n\t\tcb->row = rbuf->row;\n\t\tcb->col = rbuf->col;\n\t\tcb->callbackArg.v = rbuf->parityStripeID;\n\t\tcb->callbackArg2.v = rbuf->which_ru;\n\t\tcb->next = NULL;\n\t\tif (!reconCtrlPtr->bufferWaitList)\n\t\t\treconCtrlPtr->bufferWaitList = cb;\n\t\telse {\t\t/* might want to maintain head/tail pointers\n\t\t\t\t * here rather than search for end of list */\n\t\t\tfor (p = reconCtrlPtr->bufferWaitList; p->next; p = p->next);\n\t\t\tp->next = cb;\n\t\t}\n\t\tretcode = 1;\n\t\tgoto out;\n\t}\n\tDprintf2(\"RECON: row %d col %d acquired rbuf\\n\", rbuf->row, rbuf->col);\n\tRF_ETIMER_STOP(raidPtr->recon_tracerecs[rbuf->col].recon_timer);\n\tRF_ETIMER_EVAL(raidPtr->recon_tracerecs[rbuf->col].recon_timer);\n\traidPtr->recon_tracerecs[rbuf->col].specific.recon.recon_return_to_submit_us +=\n\t    RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[rbuf->col].recon_timer);\n\tRF_ETIMER_START(raidPtr->recon_tracerecs[rbuf->col].recon_timer);\n\n\trf_LogTraceRec(raidPtr, &raidPtr->recon_tracerecs[rbuf->col]);\n\n\t/* initialize the buffer */\n\tif (t != rbuf) {\n\t\tt->row = rbuf->row;\n\t\tt->col = reconCtrlPtr->fcol;\n\t\tt->parityStripeID = rbuf->parityStripeID;\n\t\tt->which_ru = rbuf->which_ru;\n\t\tt->failedDiskSectorOffset = rbuf->failedDiskSectorOffset;\n\t\tt->spRow = rbuf->spRow;\n\t\tt->spCol = rbuf->spCol;\n\t\tt->spOffset = rbuf->spOffset;\n\n\t\tta = t->buffer;\n\t\tt->buffer = rbuf->buffer;\n\t\trbuf->buffer = ta;\t/* swap buffers */\n\t}\n\t/* the first installation always gets installed as the destination\n\t * buffer. subsequent installations get stacked up to allow for\n\t * multi-way XOR */\n\tif (!pssPtr->rbuf) {\n\t\tpssPtr->rbuf = t;\n\t\tt->count = 1;\n\t} else\n\t\tpssPtr->rbufsForXor[pssPtr->xorBufCount++] = t;\t/* install this buffer */\n\n\trf_CheckForFullRbuf(raidPtr, reconCtrlPtr, pssPtr, layoutPtr->numDataCol);\t/* the buffer is full if\n\t\t\t\t\t\t\t\t\t\t\t * G=2 */\n\nout:\n\tRF_UNLOCK_PSS_MUTEX(raidPtr, rbuf->row, rbuf->parityStripeID);\n\tRF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\treturn (retcode);\n}",
    "includes": [
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_raid.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "RF_ReconBuffer_t *\nrf_GetFullReconBuffer(reconCtrlPtr)\n\tRF_ReconCtrl_t *reconCtrlPtr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "reconCtrlPtr->rb_mutex"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_PSS_MUTEX",
          "args": [
            "raidPtr",
            "rbuf->row",
            "rbuf->parityStripeID"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CheckForFullRbuf",
          "args": [
            "raidPtr",
            "reconCtrlPtr",
            "pssPtr",
            "layoutPtr->numDataCol"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CheckForFullRbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconbuffer.c",
          "lines": "349-386",
          "snippet": "int \nrf_CheckForFullRbuf(raidPtr, reconCtrl, pssPtr, numDataCol)\n\tRF_Raid_t *raidPtr;\n\tRF_ReconCtrl_t *reconCtrl;\n\tRF_ReconParityStripeStatus_t *pssPtr;\n\tint     numDataCol;\n{\n\tRF_ReconBuffer_t *p, *pt, *rbuf = (RF_ReconBuffer_t *) pssPtr->rbuf;\n\n\tif (rbuf->count == numDataCol) {\n\t\traidPtr->numFullReconBuffers++;\n\t\tDprintf2(\"RECON: rbuf for psid %ld ru %d has filled\\n\",\n\t\t    (long) rbuf->parityStripeID, rbuf->which_ru);\n\t\tif (!reconCtrl->fullBufferList || (rbuf->failedDiskSectorOffset < reconCtrl->fullBufferList->failedDiskSectorOffset)) {\n\t\t\tDprintf2(\"RECON: rbuf for psid %ld ru %d is head of list\\n\",\n\t\t\t    (long) rbuf->parityStripeID, rbuf->which_ru);\n\t\t\trbuf->next = reconCtrl->fullBufferList;\n\t\t\treconCtrl->fullBufferList = rbuf;\n\t\t} else {\n\t\t\tfor (pt = reconCtrl->fullBufferList, p = pt->next; p && p->failedDiskSectorOffset < rbuf->failedDiskSectorOffset; pt = p, p = p->next);\n\t\t\trbuf->next = p;\n\t\t\tpt->next = rbuf;\n\t\t\tDprintf2(\"RECON: rbuf for psid %ld ru %d is in list\\n\",\n\t\t\t    (long) rbuf->parityStripeID, rbuf->which_ru);\n\t\t}\n#if 0\n\t\tpssPtr->writeRbuf = pssPtr->rbuf;\t/* DEBUG ONLY:  we like\n\t\t\t\t\t\t\t * to be able to find\n\t\t\t\t\t\t\t * this rbuf while it's\n\t\t\t\t\t\t\t * awaiting write */\n#else\n\t\trbuf->pssPtr = pssPtr;\n#endif\n\t\tpssPtr->rbuf = NULL;\n\t\trf_CauseReconEvent(raidPtr, rbuf->row, rbuf->col, NULL, RF_REVENT_BUFREADY);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_raid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_nwayxor.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_revent.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_raid.h\"\n\nint \nrf_CheckForFullRbuf(raidPtr, reconCtrl, pssPtr, numDataCol)\n\tRF_Raid_t *raidPtr;\n\tRF_ReconCtrl_t *reconCtrl;\n\tRF_ReconParityStripeStatus_t *pssPtr;\n\tint     numDataCol;\n{\n\tRF_ReconBuffer_t *p, *pt, *rbuf = (RF_ReconBuffer_t *) pssPtr->rbuf;\n\n\tif (rbuf->count == numDataCol) {\n\t\traidPtr->numFullReconBuffers++;\n\t\tDprintf2(\"RECON: rbuf for psid %ld ru %d has filled\\n\",\n\t\t    (long) rbuf->parityStripeID, rbuf->which_ru);\n\t\tif (!reconCtrl->fullBufferList || (rbuf->failedDiskSectorOffset < reconCtrl->fullBufferList->failedDiskSectorOffset)) {\n\t\t\tDprintf2(\"RECON: rbuf for psid %ld ru %d is head of list\\n\",\n\t\t\t    (long) rbuf->parityStripeID, rbuf->which_ru);\n\t\t\trbuf->next = reconCtrl->fullBufferList;\n\t\t\treconCtrl->fullBufferList = rbuf;\n\t\t} else {\n\t\t\tfor (pt = reconCtrl->fullBufferList, p = pt->next; p && p->failedDiskSectorOffset < rbuf->failedDiskSectorOffset; pt = p, p = p->next);\n\t\t\trbuf->next = p;\n\t\t\tpt->next = rbuf;\n\t\t\tDprintf2(\"RECON: rbuf for psid %ld ru %d is in list\\n\",\n\t\t\t    (long) rbuf->parityStripeID, rbuf->which_ru);\n\t\t}\n#if 0\n\t\tpssPtr->writeRbuf = pssPtr->rbuf;\t/* DEBUG ONLY:  we like\n\t\t\t\t\t\t\t * to be able to find\n\t\t\t\t\t\t\t * this rbuf while it's\n\t\t\t\t\t\t\t * awaiting write */\n#else\n\t\trbuf->pssPtr = pssPtr;\n#endif\n\t\tpssPtr->rbuf = NULL;\n\t\trf_CauseReconEvent(raidPtr, rbuf->row, rbuf->col, NULL, RF_REVENT_BUFREADY);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_LogTraceRec",
          "args": [
            "raidPtr",
            "&raidPtr->recon_tracerecs[rbuf->col]"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "rf_LogTraceRec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_acctrace.c",
          "lines": "104-156",
          "snippet": "void \nrf_LogTraceRec(raid, rec)\n\tRF_Raid_t *raid;\n\tRF_AccTraceEntry_t *rec;\n{\n\tRF_AccTotals_t *acc = &raid->acc_totals;\n#if 0\n\tRF_Etimer_t timer;\n\tint     i, n;\n#endif\n\n\tif (rf_stopCollectingTraces || ((rf_maxNumTraces >= 0) && (numTracesSoFar >= rf_maxNumTraces)))\n\t\treturn;\n\n\t/* update AccTotals for this device */\n\tif (!raid->keep_acc_totals)\n\t\treturn;\n\tacc->num_log_ents++;\n\tif (rec->reconacc) {\n\t\tacc->recon_start_to_fetch_us += rec->specific.recon.recon_start_to_fetch_us;\n\t\tacc->recon_fetch_to_return_us += rec->specific.recon.recon_fetch_to_return_us;\n\t\tacc->recon_return_to_submit_us += rec->specific.recon.recon_return_to_submit_us;\n\t\tacc->recon_num_phys_ios += rec->num_phys_ios;\n\t\tacc->recon_phys_io_us += rec->phys_io_us;\n\t\tacc->recon_diskwait_us += rec->diskwait_us;\n\t\tacc->recon_reccount++;\n\t} else {\n\t\tRF_HIST_ADD(acc->tot_hist, rec->total_us);\n\t\tRF_HIST_ADD(acc->dw_hist, rec->diskwait_us);\n\t\t/* count of physical ios which are too big.  often due to\n\t\t * thermal recalibration */\n\t\t/* if bigvals > 0, you should probably ignore this data set */\n\t\tif (rec->diskwait_us > 100000)\n\t\t\tacc->bigvals++;\n\t\tacc->total_us += rec->total_us;\n\t\tacc->suspend_ovhd_us += rec->specific.user.suspend_ovhd_us;\n\t\tacc->map_us += rec->specific.user.map_us;\n\t\tacc->lock_us += rec->specific.user.lock_us;\n\t\tacc->dag_create_us += rec->specific.user.dag_create_us;\n\t\tacc->dag_retry_us += rec->specific.user.dag_retry_us;\n\t\tacc->exec_us += rec->specific.user.exec_us;\n\t\tacc->cleanup_us += rec->specific.user.cleanup_us;\n\t\tacc->exec_engine_us += rec->specific.user.exec_engine_us;\n\t\tacc->xor_us += rec->xor_us;\n\t\tacc->q_us += rec->q_us;\n\t\tacc->plog_us += rec->plog_us;\n\t\tacc->diskqueue_us += rec->diskqueue_us;\n\t\tacc->diskwait_us += rec->diskwait_us;\n\t\tacc->num_phys_ios += rec->num_phys_ios;\n\t\tacc->phys_io_us = rec->phys_io_us;\n\t\tacc->user_reccount++;\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_hist.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long numTracesSoFar;",
            "int     rf_stopCollectingTraces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_hist.h\"\n#include \"rf_etimer.h\"\n#include \"rf_raid.h\"\n#include \"rf_general.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_types.h\"\n#include \"rf_threadstuff.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n\nstatic long numTracesSoFar;\nint     rf_stopCollectingTraces;\n\nvoid \nrf_LogTraceRec(raid, rec)\n\tRF_Raid_t *raid;\n\tRF_AccTraceEntry_t *rec;\n{\n\tRF_AccTotals_t *acc = &raid->acc_totals;\n#if 0\n\tRF_Etimer_t timer;\n\tint     i, n;\n#endif\n\n\tif (rf_stopCollectingTraces || ((rf_maxNumTraces >= 0) && (numTracesSoFar >= rf_maxNumTraces)))\n\t\treturn;\n\n\t/* update AccTotals for this device */\n\tif (!raid->keep_acc_totals)\n\t\treturn;\n\tacc->num_log_ents++;\n\tif (rec->reconacc) {\n\t\tacc->recon_start_to_fetch_us += rec->specific.recon.recon_start_to_fetch_us;\n\t\tacc->recon_fetch_to_return_us += rec->specific.recon.recon_fetch_to_return_us;\n\t\tacc->recon_return_to_submit_us += rec->specific.recon.recon_return_to_submit_us;\n\t\tacc->recon_num_phys_ios += rec->num_phys_ios;\n\t\tacc->recon_phys_io_us += rec->phys_io_us;\n\t\tacc->recon_diskwait_us += rec->diskwait_us;\n\t\tacc->recon_reccount++;\n\t} else {\n\t\tRF_HIST_ADD(acc->tot_hist, rec->total_us);\n\t\tRF_HIST_ADD(acc->dw_hist, rec->diskwait_us);\n\t\t/* count of physical ios which are too big.  often due to\n\t\t * thermal recalibration */\n\t\t/* if bigvals > 0, you should probably ignore this data set */\n\t\tif (rec->diskwait_us > 100000)\n\t\t\tacc->bigvals++;\n\t\tacc->total_us += rec->total_us;\n\t\tacc->suspend_ovhd_us += rec->specific.user.suspend_ovhd_us;\n\t\tacc->map_us += rec->specific.user.map_us;\n\t\tacc->lock_us += rec->specific.user.lock_us;\n\t\tacc->dag_create_us += rec->specific.user.dag_create_us;\n\t\tacc->dag_retry_us += rec->specific.user.dag_retry_us;\n\t\tacc->exec_us += rec->specific.user.exec_us;\n\t\tacc->cleanup_us += rec->specific.user.cleanup_us;\n\t\tacc->exec_engine_us += rec->specific.user.exec_engine_us;\n\t\tacc->xor_us += rec->xor_us;\n\t\tacc->q_us += rec->q_us;\n\t\tacc->plog_us += rec->plog_us;\n\t\tacc->diskqueue_us += rec->diskqueue_us;\n\t\tacc->diskwait_us += rec->diskwait_us;\n\t\tacc->num_phys_ios += rec->num_phys_ios;\n\t\tacc->phys_io_us = rec->phys_io_us;\n\t\tacc->user_reccount++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "raidPtr->recon_tracerecs[rbuf->col].recon_timer"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "raidPtr->recon_tracerecs[rbuf->col].recon_timer"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "raidPtr->recon_tracerecs[rbuf->col].recon_timer"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "raidPtr->recon_tracerecs[rbuf->col].recon_timer"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf2",
          "args": [
            "\"RECON: row %d col %d acquired rbuf\\n\"",
            "rbuf->row",
            "rbuf->col"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_AllocCallbackDesc",
          "args": [],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "rf_AllocCallbackDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_callback.c",
          "lines": "80-87",
          "snippet": "RF_CallbackDesc_t *\nrf_AllocCallbackDesc()\n{\n\tRF_CallbackDesc_t *p;\n\n\tRF_FREELIST_GET(rf_callback_freelist, p, next, (RF_CallbackDesc_t *));\n\treturn (p);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_callback_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_callback.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_callback_freelist;\n\nRF_CallbackDesc_t *\nrf_AllocCallbackDesc()\n{\n\tRF_CallbackDesc_t *p;\n\n\tRF_FREELIST_GET(rf_callback_freelist, p, next, (RF_CallbackDesc_t *));\n\treturn (p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_PrintPSStatusTable",
          "args": [
            "raidPtr",
            "rbuf->row"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "rf_PrintPSStatusTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
          "lines": "369-376",
          "snippet": "void \nrf_PrintPSStatusTable(raidPtr, row)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n{\n\tRF_PSStatusHeader_t *pssTable = raidPtr->reconControl[row]->pssTable;\n\tRealPrintPSStatusTable(raidPtr, pssTable);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_psstatus.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);",
            "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
            "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nvoid \nrf_PrintPSStatusTable(raidPtr, row)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n{\n\tRF_PSStatusHeader_t *pssTable = raidPtr->reconControl[row]->pssTable;\n\tRealPrintPSStatusTable(raidPtr, pssTable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Buffer wait deadlock detected.  Exiting.\\n\""
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf2",
          "args": [
            "\"RECON: row %d col %d failed to acquire floating rbuf\\n\"",
            "rbuf->row",
            "rbuf->col"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "!keep_it && !use_committed"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "t"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_FreeReconBuffer",
          "args": [
            "rbuf"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeReconBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconutil.c",
          "lines": "256-266",
          "snippet": "void \nrf_FreeReconBuffer(rbuf)\n\tRF_ReconBuffer_t *rbuf;\n{\n\tRF_Raid_t *raidPtr = rbuf->raidPtr;\n\tu_int   recon_buffer_size = rf_RaidAddressToByte(raidPtr, raidPtr->Layout.SUsPerRU * raidPtr->Layout.sectorsPerStripeUnit);\n\n\tRF_Free(rbuf->arrived, raidPtr->numCol * sizeof(char));\n\tRF_Free(rbuf->buffer, recon_buffer_size);\n\tRF_Free(rbuf, sizeof(*rbuf));\n}",
          "includes": [
            "#include \"rf_chaindecluster.h\"",
            "#include \"rf_interdecluster.h\"",
            "#include \"rf_raid5_rotatedspare.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_chaindecluster.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid5_rotatedspare.h\"\n#include \"rf_decluster.h\"\n#include \"rf_general.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_desc.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_FreeReconBuffer(rbuf)\n\tRF_ReconBuffer_t *rbuf;\n{\n\tRF_Raid_t *raidPtr = rbuf->raidPtr;\n\tu_int   recon_buffer_size = rf_RaidAddressToByte(raidPtr, raidPtr->Layout.SUsPerRU * raidPtr->Layout.sectorsPerStripeUnit);\n\n\tRF_Free(rbuf->arrived, raidPtr->numCol * sizeof(char));\n\tRF_Free(rbuf->buffer, recon_buffer_size);\n\tRF_Free(rbuf, sizeof(*rbuf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "reconCtrlPtr->rb_mutex"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_PSS_MUTEX",
          "args": [
            "raidPtr",
            "rbuf->row",
            "rbuf->parityStripeID"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ReleaseFloatingReconBuffer",
          "args": [
            "raidPtr",
            "rbuf->row",
            "t"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ReleaseFloatingReconBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconbuffer.c",
          "lines": "392-419",
          "snippet": "void \nrf_ReleaseFloatingReconBuffer(raidPtr, row, rbuf)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_ReconBuffer_t *rbuf;\n{\n\tRF_ReconCtrl_t *rcPtr = raidPtr->reconControl[row];\n\tRF_CallbackDesc_t *cb;\n\n\tDprintf2(\"RECON: releasing rbuf for psid %ld ru %d\\n\",\n\t    (long) rbuf->parityStripeID, rbuf->which_ru);\n\n\t/* if anyone is waiting on buffers, wake one of them up.  They will\n\t * subsequently wake up anyone else waiting on their RU */\n\tif (rcPtr->bufferWaitList) {\n\t\trbuf->next = rcPtr->committedRbufs;\n\t\trcPtr->committedRbufs = rbuf;\n\t\tcb = rcPtr->bufferWaitList;\n\t\trcPtr->bufferWaitList = cb->next;\n\t\trf_CauseReconEvent(raidPtr, cb->row, cb->col, (void *) 1, RF_REVENT_BUFCLEAR);\t/* arg==1 => we've\n\t\t\t\t\t\t\t\t\t\t\t\t * committed a buffer */\n\t\trf_FreeCallbackDesc(cb);\n\t\traidPtr->procsInBufWait--;\n\t} else {\n\t\trbuf->next = rcPtr->floatingRbufs;\n\t\trcPtr->floatingRbufs = rbuf;\n\t}\n}",
          "includes": [
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_raid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_nwayxor.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_revent.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_raid.h\"\n\nvoid \nrf_ReleaseFloatingReconBuffer(raidPtr, row, rbuf)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_ReconBuffer_t *rbuf;\n{\n\tRF_ReconCtrl_t *rcPtr = raidPtr->reconControl[row];\n\tRF_CallbackDesc_t *cb;\n\n\tDprintf2(\"RECON: releasing rbuf for psid %ld ru %d\\n\",\n\t    (long) rbuf->parityStripeID, rbuf->which_ru);\n\n\t/* if anyone is waiting on buffers, wake one of them up.  They will\n\t * subsequently wake up anyone else waiting on their RU */\n\tif (rcPtr->bufferWaitList) {\n\t\trbuf->next = rcPtr->committedRbufs;\n\t\trcPtr->committedRbufs = rbuf;\n\t\tcb = rcPtr->bufferWaitList;\n\t\trcPtr->bufferWaitList = cb->next;\n\t\trf_CauseReconEvent(raidPtr, cb->row, cb->col, (void *) 1, RF_REVENT_BUFCLEAR);\t/* arg==1 => we've\n\t\t\t\t\t\t\t\t\t\t\t\t * committed a buffer */\n\t\trf_FreeCallbackDesc(cb);\n\t\traidPtr->procsInBufWait--;\n\t} else {\n\t\trbuf->next = rcPtr->floatingRbufs;\n\t\trcPtr->floatingRbufs = rbuf;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "t"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "raidPtr->recon_tracerecs[rbuf->col].recon_timer"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "raidPtr->recon_tracerecs[rbuf->col].recon_timer"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "raidPtr->recon_tracerecs[rbuf->col].recon_timer"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "raidPtr->recon_tracerecs[rbuf->col].recon_timer"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_MultiWayReconXor",
          "args": [
            "raidPtr",
            "pssPtr"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "rf_MultiWayReconXor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconbuffer.c",
          "lines": "275-315",
          "snippet": "int \nrf_MultiWayReconXor(raidPtr, pssPtr)\n\tRF_Raid_t *raidPtr;\n\tRF_ReconParityStripeStatus_t *pssPtr;\t/* the pss descriptor for this\n\t\t\t\t\t\t * parity stripe */\n{\n\tint     i, numBufs = pssPtr->xorBufCount;\n\tint     numBytes = rf_RaidAddressToByte(raidPtr, raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU);\n\tRF_ReconBuffer_t **rbufs = (RF_ReconBuffer_t **) pssPtr->rbufsForXor;\n\tRF_ReconBuffer_t *targetRbuf = (RF_ReconBuffer_t *) pssPtr->rbuf;\n\n\tRF_ASSERT(pssPtr->rbuf != NULL);\n\tRF_ASSERT(numBufs > 0 && numBufs < RF_PS_MAX_BUFS);\n#ifdef _KERNEL\n#if !defined(__NetBSD__) && !defined(__OpenBSD__)\n\tthread_block();\t\t/* yield the processor before doing a big XOR */\n#endif\n#endif\t\t\t\t/* _KERNEL */\n\t/*\n         * XXX\n         *\n         * What if more than 9 bufs?\n         */\n\tnWayXorFuncs[numBufs] (pssPtr->rbufsForXor, targetRbuf, numBytes / sizeof(long));\n\n\t/* release all the reconstruction buffers except the last one, which\n\t * belongs to the the disk who's submission caused this XOR to take\n\t * place */\n\tfor (i = 0; i < numBufs - 1; i++) {\n\t\tif (rbufs[i]->type == RF_RBUF_TYPE_FLOATING)\n\t\t\trf_ReleaseFloatingReconBuffer(raidPtr, rbufs[i]->row, rbufs[i]);\n\t\telse\n\t\t\tif (rbufs[i]->type == RF_RBUF_TYPE_FORCED)\n\t\t\t\trf_FreeReconBuffer(rbufs[i]);\n\t\t\telse\n\t\t\t\tRF_ASSERT(0);\n\t}\n\ttargetRbuf->count += pssPtr->xorBufCount;\n\tpssPtr->xorBufCount = 0;\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_raid.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_VoidFuncPtr nWayXorFuncs[] = {\n\tNULL,\n\t(RF_VoidFuncPtr) rf_nWayXor1,\n\t(RF_VoidFuncPtr) rf_nWayXor2,\n\t(RF_VoidFuncPtr) rf_nWayXor3,\n\t(RF_VoidFuncPtr) rf_nWayXor4,\n\t(RF_VoidFuncPtr) rf_nWayXor5,\n\t(RF_VoidFuncPtr) rf_nWayXor6,\n\t(RF_VoidFuncPtr) rf_nWayXor7,\n\t(RF_VoidFuncPtr) rf_nWayXor8,\n\t(RF_VoidFuncPtr) rf_nWayXor9\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_nwayxor.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_revent.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_raid.h\"\n\nstatic RF_VoidFuncPtr nWayXorFuncs[] = {\n\tNULL,\n\t(RF_VoidFuncPtr) rf_nWayXor1,\n\t(RF_VoidFuncPtr) rf_nWayXor2,\n\t(RF_VoidFuncPtr) rf_nWayXor3,\n\t(RF_VoidFuncPtr) rf_nWayXor4,\n\t(RF_VoidFuncPtr) rf_nWayXor5,\n\t(RF_VoidFuncPtr) rf_nWayXor6,\n\t(RF_VoidFuncPtr) rf_nWayXor7,\n\t(RF_VoidFuncPtr) rf_nWayXor8,\n\t(RF_VoidFuncPtr) rf_nWayXor9\n};\n\nint \nrf_MultiWayReconXor(raidPtr, pssPtr)\n\tRF_Raid_t *raidPtr;\n\tRF_ReconParityStripeStatus_t *pssPtr;\t/* the pss descriptor for this\n\t\t\t\t\t\t * parity stripe */\n{\n\tint     i, numBufs = pssPtr->xorBufCount;\n\tint     numBytes = rf_RaidAddressToByte(raidPtr, raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU);\n\tRF_ReconBuffer_t **rbufs = (RF_ReconBuffer_t **) pssPtr->rbufsForXor;\n\tRF_ReconBuffer_t *targetRbuf = (RF_ReconBuffer_t *) pssPtr->rbuf;\n\n\tRF_ASSERT(pssPtr->rbuf != NULL);\n\tRF_ASSERT(numBufs > 0 && numBufs < RF_PS_MAX_BUFS);\n#ifdef _KERNEL\n#if !defined(__NetBSD__) && !defined(__OpenBSD__)\n\tthread_block();\t\t/* yield the processor before doing a big XOR */\n#endif\n#endif\t\t\t\t/* _KERNEL */\n\t/*\n         * XXX\n         *\n         * What if more than 9 bufs?\n         */\n\tnWayXorFuncs[numBufs] (pssPtr->rbufsForXor, targetRbuf, numBytes / sizeof(long));\n\n\t/* release all the reconstruction buffers except the last one, which\n\t * belongs to the the disk who's submission caused this XOR to take\n\t * place */\n\tfor (i = 0; i < numBufs - 1; i++) {\n\t\tif (rbufs[i]->type == RF_RBUF_TYPE_FLOATING)\n\t\t\trf_ReleaseFloatingReconBuffer(raidPtr, rbufs[i]->row, rbufs[i]);\n\t\telse\n\t\t\tif (rbufs[i]->type == RF_RBUF_TYPE_FORCED)\n\t\t\t\trf_FreeReconBuffer(rbufs[i]);\n\t\t\telse\n\t\t\t\tRF_ASSERT(0);\n\t}\n\ttargetRbuf->count += pssPtr->xorBufCount;\n\tpssPtr->xorBufCount = 0;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"RECON: row %d col %d invoking a %d-way XOR\\n\"",
            "rbuf->row",
            "rbuf->col",
            "pssPtr->xorBufCount"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "pssPtr"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_LookupRUStatus",
          "args": [
            "raidPtr",
            "reconCtrlPtr->pssTable",
            "rbuf->parityStripeID",
            "rbuf->which_ru",
            "RF_PSS_NONE",
            "&created"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "rf_LookupRUStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
          "lines": "170-218",
          "snippet": "RF_ReconParityStripeStatus_t *\nrf_LookupRUStatus(\n    RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable,\n    RF_StripeNum_t psID,\n    RF_ReconUnitNum_t which_ru,\n    RF_PSSFlags_t flags,\t/* whether or not to create it if it doesn't\n\t\t\t\t * exist + what flags to set initially */\n    int *created)\n{\n\tRF_PSStatusHeader_t *hdr = &pssTable[RF_HASH_PSID(raidPtr, psID)];\n\tRF_ReconParityStripeStatus_t *p, *pssPtr = hdr->chain;\n\n\t*created = 0;\n\tfor (p = pssPtr; p; p = p->next) {\n\t\tif (p->parityStripeID == psID && p->which_ru == which_ru)\n\t\t\tbreak;\n\t}\n\n\tif (!p && (flags & RF_PSS_CREATE)) {\n\t\tDprintf2(\"PSS: creating pss for psid %ld ru %d\\n\", psID, which_ru);\n\t\tp = rf_AllocPSStatus(raidPtr);\n\t\tp->next = hdr->chain;\n\t\thdr->chain = p;\n\n\t\tp->parityStripeID = psID;\n\t\tp->which_ru = which_ru;\n\t\tp->flags = flags;\n\t\tp->rbuf = NULL;\n\t\tp->writeRbuf = NULL;\n\t\tp->blockCount = 0;\n\t\tp->procWaitList = NULL;\n\t\tp->blockWaitList = NULL;\n\t\tp->bufWaitList = NULL;\n\t\t*created = 1;\n\t} else\n\t\tif (p) {\t/* we didn't create, but we want to specify\n\t\t\t\t * some new status */\n\t\t\tp->flags |= flags;\t/* add in whatever flags we're\n\t\t\t\t\t\t * specifying */\n\t\t}\n\tif (p && (flags & RF_PSS_RECON_BLOCKED)) {\n\t\tp->blockCount++;/* if we're asking to block recon, bump the\n\t\t\t\t * count */\n\t\tDprintf3(\"raid%d: Blocked recon on psid %ld.  count now %d\\n\",\n\t\t\t raidPtr->raidid, psID, p->blockCount);\n\t}\n\treturn (p);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_psstatus.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);",
            "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
            "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nRF_ReconParityStripeStatus_t *\nrf_LookupRUStatus(\n    RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable,\n    RF_StripeNum_t psID,\n    RF_ReconUnitNum_t which_ru,\n    RF_PSSFlags_t flags,\t/* whether or not to create it if it doesn't\n\t\t\t\t * exist + what flags to set initially */\n    int *created)\n{\n\tRF_PSStatusHeader_t *hdr = &pssTable[RF_HASH_PSID(raidPtr, psID)];\n\tRF_ReconParityStripeStatus_t *p, *pssPtr = hdr->chain;\n\n\t*created = 0;\n\tfor (p = pssPtr; p; p = p->next) {\n\t\tif (p->parityStripeID == psID && p->which_ru == which_ru)\n\t\t\tbreak;\n\t}\n\n\tif (!p && (flags & RF_PSS_CREATE)) {\n\t\tDprintf2(\"PSS: creating pss for psid %ld ru %d\\n\", psID, which_ru);\n\t\tp = rf_AllocPSStatus(raidPtr);\n\t\tp->next = hdr->chain;\n\t\thdr->chain = p;\n\n\t\tp->parityStripeID = psID;\n\t\tp->which_ru = which_ru;\n\t\tp->flags = flags;\n\t\tp->rbuf = NULL;\n\t\tp->writeRbuf = NULL;\n\t\tp->blockCount = 0;\n\t\tp->procWaitList = NULL;\n\t\tp->blockWaitList = NULL;\n\t\tp->bufWaitList = NULL;\n\t\t*created = 1;\n\t} else\n\t\tif (p) {\t/* we didn't create, but we want to specify\n\t\t\t\t * some new status */\n\t\t\tp->flags |= flags;\t/* add in whatever flags we're\n\t\t\t\t\t\t * specifying */\n\t\t}\n\tif (p && (flags & RF_PSS_RECON_BLOCKED)) {\n\t\tp->blockCount++;/* if we're asking to block recon, bump the\n\t\t\t\t * count */\n\t\tDprintf3(\"raid%d: Blocked recon on psid %ld.  count now %d\\n\",\n\t\t\t raidPtr->raidid, psID, p->blockCount);\n\t}\n\treturn (p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "reconCtrlPtr->rb_mutex"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_PSS_MUTEX",
          "args": [
            "raidPtr",
            "rbuf->row",
            "rbuf->parityStripeID"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf5",
          "args": [
            "\"RECON: submission by row %d col %d for psid %ld ru %d (failed offset %ld)\\n\"",
            "rbuf->row",
            "rbuf->col",
            "(long) rbuf->parityStripeID",
            "rbuf->which_ru",
            "(long) rbuf->failedDiskSectorOffset"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "rbuf->col != reconCtrlPtr->fcol"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "rbuf"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_nwayxor.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_revent.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_raid.h\"\n\nRF_ReconBuffer_t *\nrf_GetFullReconBuffer(reconCtrlPtr)\n\tRF_ReconCtrl_t *reconCtrlPtr;\n\nint \nrf_SubmitReconBufferBasic(rbuf, keep_it, use_committed)\n\tRF_ReconBuffer_t *rbuf;\t/* the recon buffer to submit */\n\tint     keep_it;\t/* whether we can keep this buffer or we have\n\t\t\t\t * to return it */\n\tint     use_committed;\t/* whether to use a committed or an available\n\t\t\t\t * recon buffer */\n{\n\tRF_Raid_t *raidPtr = rbuf->raidPtr;\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_ReconCtrl_t *reconCtrlPtr = raidPtr->reconControl[rbuf->row];\n\tRF_ReconParityStripeStatus_t *pssPtr;\n\tRF_ReconBuffer_t *targetRbuf, *t = NULL;\t/* temporary rbuf\n\t\t\t\t\t\t\t * pointers */\n\tcaddr_t ta;\t\t/* temporary data buffer pointer */\n\tRF_CallbackDesc_t *cb, *p;\n\tint     retcode = 0, created = 0;\n\n\tRF_Etimer_t timer;\n\n\t/* makes no sense to have a submission from the failed disk */\n\tRF_ASSERT(rbuf);\n\tRF_ASSERT(rbuf->col != reconCtrlPtr->fcol);\n\n\tDprintf5(\"RECON: submission by row %d col %d for psid %ld ru %d (failed offset %ld)\\n\",\n\t    rbuf->row, rbuf->col, (long) rbuf->parityStripeID, rbuf->which_ru, (long) rbuf->failedDiskSectorOffset);\n\n\tRF_LOCK_PSS_MUTEX(raidPtr, rbuf->row, rbuf->parityStripeID);\n\n\tRF_LOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\n\tpssPtr = rf_LookupRUStatus(raidPtr, reconCtrlPtr->pssTable, rbuf->parityStripeID, rbuf->which_ru, RF_PSS_NONE, &created);\n\tRF_ASSERT(pssPtr);\t/* if it didn't exist, we wouldn't have gotten\n\t\t\t\t * an rbuf for it */\n\n\t/* check to see if enough buffers have accumulated to do an XOR.  If\n\t * so, there's no need to acquire a floating rbuf.  Before we can do\n\t * any XORing, we must have acquired a destination buffer.  If we\n\t * have, then we can go ahead and do the XOR if (1) including this\n\t * buffer, enough bufs have accumulated, or (2) this is the last\n\t * submission for this stripe. Otherwise, we have to go acquire a\n\t * floating rbuf. */\n\n\ttargetRbuf = (RF_ReconBuffer_t *) pssPtr->rbuf;\n\tif ((targetRbuf != NULL) &&\n\t    ((pssPtr->xorBufCount == rf_numBufsToAccumulate - 1) || (targetRbuf->count + pssPtr->xorBufCount + 1 == layoutPtr->numDataCol))) {\n\t\tpssPtr->rbufsForXor[pssPtr->xorBufCount++] = rbuf;\t/* install this buffer */\n\t\tDprintf3(\"RECON: row %d col %d invoking a %d-way XOR\\n\", rbuf->row, rbuf->col, pssPtr->xorBufCount);\n\t\tRF_ETIMER_START(timer);\n\t\trf_MultiWayReconXor(raidPtr, pssPtr);\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\traidPtr->accumXorTimeUs += RF_ETIMER_VAL_US(timer);\n\t\tif (!keep_it) {\n\t\t\traidPtr->recon_tracerecs[rbuf->col].xor_us = RF_ETIMER_VAL_US(timer);\n\t\t\tRF_ETIMER_STOP(raidPtr->recon_tracerecs[rbuf->col].recon_timer);\n\t\t\tRF_ETIMER_EVAL(raidPtr->recon_tracerecs[rbuf->col].recon_timer);\n\t\t\traidPtr->recon_tracerecs[rbuf->col].specific.recon.recon_return_to_submit_us +=\n\t\t\t    RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[rbuf->col].recon_timer);\n\t\t\tRF_ETIMER_START(raidPtr->recon_tracerecs[rbuf->col].recon_timer);\n\n\t\t\trf_LogTraceRec(raidPtr, &raidPtr->recon_tracerecs[rbuf->col]);\n\t\t}\n\t\trf_CheckForFullRbuf(raidPtr, reconCtrlPtr, pssPtr, layoutPtr->numDataCol);\n\n\t\t/* if use_committed is on, we _must_ consume a buffer off the\n\t\t * committed list. */\n\t\tif (use_committed) {\n\t\t\tt = reconCtrlPtr->committedRbufs;\n\t\t\tRF_ASSERT(t);\n\t\t\treconCtrlPtr->committedRbufs = t->next;\n\t\t\trf_ReleaseFloatingReconBuffer(raidPtr, rbuf->row, t);\n\t\t}\n\t\tif (keep_it) {\n\t\t\tRF_UNLOCK_PSS_MUTEX(raidPtr, rbuf->row, rbuf->parityStripeID);\n\t\t\tRF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\t\t\trf_FreeReconBuffer(rbuf);\n\t\t\treturn (retcode);\n\t\t}\n\t\tgoto out;\n\t}\n\t/* set the value of \"t\", which we'll use as the rbuf from here on */\n\tif (keep_it) {\n\t\tt = rbuf;\n\t} else {\n\t\tif (use_committed) {\t/* if a buffer has been committed to\n\t\t\t\t\t * us, use it */\n\t\t\tt = reconCtrlPtr->committedRbufs;\n\t\t\tRF_ASSERT(t);\n\t\t\treconCtrlPtr->committedRbufs = t->next;\n\t\t\tt->next = NULL;\n\t\t} else\n\t\t\tif (reconCtrlPtr->floatingRbufs) {\n\t\t\t\tt = reconCtrlPtr->floatingRbufs;\n\t\t\t\treconCtrlPtr->floatingRbufs = t->next;\n\t\t\t\tt->next = NULL;\n\t\t\t}\n\t}\n\n\t/* If we weren't able to acquire a buffer, append to the end of the\n\t * buf list in the recon ctrl struct. */\n\tif (!t) {\n\t\tRF_ASSERT(!keep_it && !use_committed);\n\t\tDprintf2(\"RECON: row %d col %d failed to acquire floating rbuf\\n\", rbuf->row, rbuf->col);\n\n\t\traidPtr->procsInBufWait++;\n\t\tif ((raidPtr->procsInBufWait == raidPtr->numCol - 1) && (raidPtr->numFullReconBuffers == 0)) {\n\t\t\tprintf(\"Buffer wait deadlock detected.  Exiting.\\n\");\n\t\t\trf_PrintPSStatusTable(raidPtr, rbuf->row);\n\t\t\tRF_PANIC();\n\t\t}\n\t\tpssPtr->flags |= RF_PSS_BUFFERWAIT;\n\t\tcb = rf_AllocCallbackDesc();\t/* append to buf wait list in\n\t\t\t\t\t\t * recon ctrl structure */\n\t\tcb->row = rbuf->row;\n\t\tcb->col = rbuf->col;\n\t\tcb->callbackArg.v = rbuf->parityStripeID;\n\t\tcb->callbackArg2.v = rbuf->which_ru;\n\t\tcb->next = NULL;\n\t\tif (!reconCtrlPtr->bufferWaitList)\n\t\t\treconCtrlPtr->bufferWaitList = cb;\n\t\telse {\t\t/* might want to maintain head/tail pointers\n\t\t\t\t * here rather than search for end of list */\n\t\t\tfor (p = reconCtrlPtr->bufferWaitList; p->next; p = p->next);\n\t\t\tp->next = cb;\n\t\t}\n\t\tretcode = 1;\n\t\tgoto out;\n\t}\n\tDprintf2(\"RECON: row %d col %d acquired rbuf\\n\", rbuf->row, rbuf->col);\n\tRF_ETIMER_STOP(raidPtr->recon_tracerecs[rbuf->col].recon_timer);\n\tRF_ETIMER_EVAL(raidPtr->recon_tracerecs[rbuf->col].recon_timer);\n\traidPtr->recon_tracerecs[rbuf->col].specific.recon.recon_return_to_submit_us +=\n\t    RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[rbuf->col].recon_timer);\n\tRF_ETIMER_START(raidPtr->recon_tracerecs[rbuf->col].recon_timer);\n\n\trf_LogTraceRec(raidPtr, &raidPtr->recon_tracerecs[rbuf->col]);\n\n\t/* initialize the buffer */\n\tif (t != rbuf) {\n\t\tt->row = rbuf->row;\n\t\tt->col = reconCtrlPtr->fcol;\n\t\tt->parityStripeID = rbuf->parityStripeID;\n\t\tt->which_ru = rbuf->which_ru;\n\t\tt->failedDiskSectorOffset = rbuf->failedDiskSectorOffset;\n\t\tt->spRow = rbuf->spRow;\n\t\tt->spCol = rbuf->spCol;\n\t\tt->spOffset = rbuf->spOffset;\n\n\t\tta = t->buffer;\n\t\tt->buffer = rbuf->buffer;\n\t\trbuf->buffer = ta;\t/* swap buffers */\n\t}\n\t/* the first installation always gets installed as the destination\n\t * buffer. subsequent installations get stacked up to allow for\n\t * multi-way XOR */\n\tif (!pssPtr->rbuf) {\n\t\tpssPtr->rbuf = t;\n\t\tt->count = 1;\n\t} else\n\t\tpssPtr->rbufsForXor[pssPtr->xorBufCount++] = t;\t/* install this buffer */\n\n\trf_CheckForFullRbuf(raidPtr, reconCtrlPtr, pssPtr, layoutPtr->numDataCol);\t/* the buffer is full if\n\t\t\t\t\t\t\t\t\t\t\t * G=2 */\n\nout:\n\tRF_UNLOCK_PSS_MUTEX(raidPtr, rbuf->row, rbuf->parityStripeID);\n\tRF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\treturn (retcode);\n}"
  },
  {
    "function_name": "rf_SubmitReconBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconbuffer.c",
    "lines": "88-102",
    "snippet": "int \nrf_SubmitReconBuffer(rbuf, keep_it, use_committed)\n\tRF_ReconBuffer_t *rbuf;\t/* the recon buffer to submit */\n\tint     keep_it;\t/* whether we can keep this buffer or we have\n\t\t\t\t * to return it */\n\tint     use_committed;\t/* whether to use a committed or an available\n\t\t\t\t * recon buffer */\n{\n\tRF_LayoutSW_t *lp;\n\tint     rc;\n\n\tlp = rbuf->raidPtr->Layout.map;\n\trc = lp->SubmitReconBuffer(rbuf, keep_it, use_committed);\n\treturn (rc);\n}",
    "includes": [
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_raid.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lp->SubmitReconBuffer",
          "args": [
            "rbuf",
            "keep_it",
            "use_committed"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_nwayxor.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_revent.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_raid.h\"\n\nint \nrf_SubmitReconBuffer(rbuf, keep_it, use_committed)\n\tRF_ReconBuffer_t *rbuf;\t/* the recon buffer to submit */\n\tint     keep_it;\t/* whether we can keep this buffer or we have\n\t\t\t\t * to return it */\n\tint     use_committed;\t/* whether to use a committed or an available\n\t\t\t\t * recon buffer */\n{\n\tRF_LayoutSW_t *lp;\n\tint     rc;\n\n\tlp = rbuf->raidPtr->Layout.map;\n\trc = lp->SubmitReconBuffer(rbuf, keep_it, use_committed);\n\treturn (rc);\n}"
  }
]