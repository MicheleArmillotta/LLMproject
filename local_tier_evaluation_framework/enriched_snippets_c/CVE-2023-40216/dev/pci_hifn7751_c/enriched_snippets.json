[
  {
    "function_name": "hifn_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
    "lines": "1351-1417",
    "snippet": "void\nhifn_callback(sc, cmd, macbuf)\n\tstruct hifn_softc *sc;\n\tstruct hifn_command *cmd;\n\tu_int8_t *macbuf;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\tstruct cryptop *crp = (struct cryptop *)cmd->private_data;\n\tstruct cryptodesc *crd;\n\tstruct mbuf *m;\n\n\tif ((crp->crp_flags & CRYPTO_F_IMBUF) && (cmd->src_m != cmd->dst_m)) {\n\t\tm_freem(cmd->src_m);\n\t\tcrp->crp_buf = (caddr_t)cmd->dst_m;\n\t}\n\n\tif ((m = cmd->dst_m) != NULL) {\n\t\tint totlen = cmd->src_l, len;\n\n\t\twhile (m) {\n\t\t\tlen = dma->dstr[dma->dstk].l & HIFN_D_LENGTH;\n\t\t\tif (len > totlen)\n\t\t\t\tlen = totlen;\n\t\t\telse\n\t\t\t\ttotlen -= len;\n\t\t\tm->m_len = len;\n\t\t\thifnstats.hst_obytes += m->m_len;\n\t\t\tm = m->m_next;\n\t\t\tif (++dma->dstk == HIFN_D_DST_RSIZE)\n\t\t\t\tdma->dstk = 0;\n\t\t\tdma->dstu--;\n\t\t}\n\t}\n\telse {\n\t\thifnstats.hst_obytes += dma->dstr[dma->dstk].l & HIFN_D_LENGTH;\n\t\tif (++dma->dstk == HIFN_D_DST_RSIZE)\n\t\t\tdma->dstk = 0;\n\t\tdma->dstu--;\n\t}\n\n\tif ((cmd->base_masks & (HIFN_BASE_CMD_CRYPT | HIFN_BASE_CMD_DECODE)) ==\n\t    HIFN_BASE_CMD_CRYPT) {\n\t\tfor (crd = crp->crp_desc; crd; crd = crd->crd_next) {\n\t\t\tif (crd->crd_alg != CRYPTO_DES_CBC &&\n\t\t\t    crd->crd_alg != CRYPTO_3DES_CBC)\n\t\t\t\tcontinue;\n\t\t\tm_copydata((struct mbuf *)crp->crp_buf,\n\t\t\t    crd->crd_skip + crd->crd_len - 8, 8,\n\t\t\t    cmd->softc->sc_sessions[cmd->session_num].hs_iv);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (macbuf != NULL) {\n\t\tfor (crd = crp->crp_desc; crd; crd = crd->crd_next) {\n\t\t\tif (crd->crd_alg != CRYPTO_MD5_HMAC96 &&\n\t\t\t    crd->crd_alg != CRYPTO_SHA1_HMAC96)\n\t\t\t\tcontinue;\n\t\t\tm_copyback((struct mbuf *)crp->crp_buf,\n\t\t\t    crd->crd_inject, 12, macbuf);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(cmd, M_DEVBUF);\n\tcrp->crp_callback(crp);\n}",
    "includes": [
      "#include <dev/pci/hifn7751reg.h>",
      "#include <dev/pci/hifn7751var.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/rndvar.h>",
      "#include <crypto/crypto.h>",
      "#include <sys/device.h>",
      "#include <machine/pmap.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\thifn_callback",
      "struct hifn_stats {\n\tu_int64_t hst_ibytes;\n\tu_int64_t hst_obytes;\n\tu_int32_t hst_ipackets;\n\tu_int32_t hst_opackets;\n\tu_int32_t hst_invalid;\n\tu_int32_t hst_nomem;\n} hifnstats;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "crp->crp_callback",
          "args": [
            "crp"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cmd",
            "M_DEVBUF"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_freesession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "1151-1170",
          "snippet": "int\nhifn_freesession(tid)\n\tu_int64_t tid;\n{\n\tstruct hifn_softc *sc;\n\tint card, session;\n\tu_int32_t sid = (tid >> 31) & 0xffffffff;\n\n\tcard = HIFN_CARD(sid);\n\tif (card >= hifn_cd.cd_ndevs || hifn_cd.cd_devs[card] == NULL)\n\t\treturn (EINVAL);\n\n\tsc = hifn_cd.cd_devs[card];\n\tsession = HIFN_SESSION(sid);\n\tif (session >= sc->sc_maxses)\n\t\treturn (EINVAL);\n\n\tsc->sc_sessions[session].hs_flags = 0;\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cfdriver hifn_cd = {\n\t0, \"hifn\", DV_DULL\n};",
            "int\thifn_freesession"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct cfdriver hifn_cd = {\n\t0, \"hifn\", DV_DULL\n};\nint\thifn_freesession;\n\nint\nhifn_freesession(tid)\n\tu_int64_t tid;\n{\n\tstruct hifn_softc *sc;\n\tint card, session;\n\tu_int32_t sid = (tid >> 31) & 0xffffffff;\n\n\tcard = HIFN_CARD(sid);\n\tif (card >= hifn_cd.cd_ndevs || hifn_cd.cd_devs[card] == NULL)\n\t\treturn (EINVAL);\n\n\tsc = hifn_cd.cd_devs[card];\n\tsession = HIFN_SESSION(sid);\n\tif (session >= sc->sc_maxses)\n\t\treturn (EINVAL);\n\n\tsc->sc_sessions[session].hs_flags = 0;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_copyback",
          "args": [
            "(struct mbuf *)crp->crp_buf",
            "crd->crd_inject",
            "12",
            "macbuf"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "(struct mbuf *)crp->crp_buf",
            "crd->crd_skip + crd->crd_len - 8",
            "8",
            "cmd->softc->sc_sessions[cmd->session_num].hs_iv"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "cmd->src_m"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\thifn_callback;\nstruct hifn_stats {\n\tu_int64_t hst_ibytes;\n\tu_int64_t hst_obytes;\n\tu_int32_t hst_ipackets;\n\tu_int32_t hst_opackets;\n\tu_int32_t hst_invalid;\n\tu_int32_t hst_nomem;\n} hifnstats;\n\nvoid\nhifn_callback(sc, cmd, macbuf)\n\tstruct hifn_softc *sc;\n\tstruct hifn_command *cmd;\n\tu_int8_t *macbuf;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\tstruct cryptop *crp = (struct cryptop *)cmd->private_data;\n\tstruct cryptodesc *crd;\n\tstruct mbuf *m;\n\n\tif ((crp->crp_flags & CRYPTO_F_IMBUF) && (cmd->src_m != cmd->dst_m)) {\n\t\tm_freem(cmd->src_m);\n\t\tcrp->crp_buf = (caddr_t)cmd->dst_m;\n\t}\n\n\tif ((m = cmd->dst_m) != NULL) {\n\t\tint totlen = cmd->src_l, len;\n\n\t\twhile (m) {\n\t\t\tlen = dma->dstr[dma->dstk].l & HIFN_D_LENGTH;\n\t\t\tif (len > totlen)\n\t\t\t\tlen = totlen;\n\t\t\telse\n\t\t\t\ttotlen -= len;\n\t\t\tm->m_len = len;\n\t\t\thifnstats.hst_obytes += m->m_len;\n\t\t\tm = m->m_next;\n\t\t\tif (++dma->dstk == HIFN_D_DST_RSIZE)\n\t\t\t\tdma->dstk = 0;\n\t\t\tdma->dstu--;\n\t\t}\n\t}\n\telse {\n\t\thifnstats.hst_obytes += dma->dstr[dma->dstk].l & HIFN_D_LENGTH;\n\t\tif (++dma->dstk == HIFN_D_DST_RSIZE)\n\t\t\tdma->dstk = 0;\n\t\tdma->dstu--;\n\t}\n\n\tif ((cmd->base_masks & (HIFN_BASE_CMD_CRYPT | HIFN_BASE_CMD_DECODE)) ==\n\t    HIFN_BASE_CMD_CRYPT) {\n\t\tfor (crd = crp->crp_desc; crd; crd = crd->crd_next) {\n\t\t\tif (crd->crd_alg != CRYPTO_DES_CBC &&\n\t\t\t    crd->crd_alg != CRYPTO_3DES_CBC)\n\t\t\t\tcontinue;\n\t\t\tm_copydata((struct mbuf *)crp->crp_buf,\n\t\t\t    crd->crd_skip + crd->crd_len - 8, 8,\n\t\t\t    cmd->softc->sc_sessions[cmd->session_num].hs_iv);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (macbuf != NULL) {\n\t\tfor (crd = crp->crp_desc; crd; crd = crd->crd_next) {\n\t\t\tif (crd->crd_alg != CRYPTO_MD5_HMAC96 &&\n\t\t\t    crd->crd_alg != CRYPTO_SHA1_HMAC96)\n\t\t\t\tcontinue;\n\t\t\tm_copyback((struct mbuf *)crp->crp_buf,\n\t\t\t    crd->crd_inject, 12, macbuf);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(cmd, M_DEVBUF);\n\tcrp->crp_callback(crp);\n}"
  },
  {
    "function_name": "hifn_process",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
    "lines": "1172-1349",
    "snippet": "int\nhifn_process(crp)\n\tstruct cryptop *crp;\n{\n\tstruct hifn_command *cmd = NULL;\n\tint card, session, err;\n\tstruct hifn_softc *sc;\n\tstruct cryptodesc *crd1, *crd2, *maccrd, *enccrd;\n\n\tif (crp == NULL || crp->crp_callback == NULL) {\n\t\thifnstats.hst_invalid++;\n\t\treturn (EINVAL);\n\t}\n\n\tcard = HIFN_CARD(crp->crp_sid);\n\tif (card >= hifn_cd.cd_ndevs || hifn_cd.cd_devs[card] == NULL) {\n\t\terr = EINVAL;\n\t\tgoto errout;\n\t}\n\n\tsc = hifn_cd.cd_devs[card];\n\tsession = HIFN_SESSION(crp->crp_sid);\n\tif (session >= sc->sc_maxses) {\n\t\terr = EINVAL;\n\t\tgoto errout;\n\t}\n\n\tcmd = (struct hifn_command *)malloc(sizeof(struct hifn_command),\n\t    M_DEVBUF, M_NOWAIT);\n\tif (cmd == NULL) {\n\t\terr = ENOMEM;\n\t\tgoto errout;\n\t}\n\tbzero(cmd, sizeof(struct hifn_command));\n\n\tif (crp->crp_flags & CRYPTO_F_IMBUF) {\n\t\tcmd->src_m = (struct mbuf *)crp->crp_buf;\n\t\tcmd->dst_m = (struct mbuf *)crp->crp_buf;\n\t}\n\telse {\n\t\terr = EINVAL;\n\t\tgoto errout;\t/* XXX only handle mbufs right now */\n\t}\n\n\tcrd1 = crp->crp_desc;\n\tif (crd1 == NULL) {\n\t\terr = EINVAL;\n\t\tgoto errout;\n\t}\n\tcrd2 = crd1->crd_next;\n\n\tif (crd2 == NULL) {\n\t\tif (crd1->crd_alg == CRYPTO_MD5_HMAC96 ||\n\t\t    crd1->crd_alg == CRYPTO_SHA1_HMAC96) {\n\t\t\tmaccrd = crd1;\n\t\t\tenccrd = NULL;\n\t\t}\n\t\telse if (crd1->crd_alg == CRYPTO_DES_CBC ||\n\t\t\t crd1->crd_alg == CRYPTO_3DES_CBC) {\n\t\t\tif ((crd1->crd_flags & CRD_F_ENCRYPT) == 0)\n\t\t\t\tcmd->base_masks |= HIFN_BASE_CMD_DECODE;\n\t\t\tmaccrd = NULL;\n\t\t\tenccrd = crd1;\n\t\t}\n\t\telse {\n\t\t\terr = EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\telse {\n\t\tif ((crd1->crd_alg == CRYPTO_MD5_HMAC96 ||\n\t\t    crd1->crd_alg == CRYPTO_SHA1_HMAC96) &&\n\t\t    (crd2->crd_alg == CRYPTO_DES_CBC ||\n\t\t\tcrd2->crd_alg == CRYPTO_3DES_CBC) &&\n\t\t    ((crd2->crd_flags & CRD_F_ENCRYPT) == 0)) {\n\t\t\tcmd->base_masks = HIFN_BASE_CMD_DECODE;\n\t\t\tmaccrd = crd1;\n\t\t\tenccrd = crd2;\n\t\t}\n\t\telse if ((crd1->crd_alg == CRYPTO_DES_CBC ||\n\t\t    crd1->crd_alg == CRYPTO_3DES_CBC) &&\n\t\t    (crd2->crd_alg == CRYPTO_MD5_HMAC96 ||\n\t\t\tcrd2->crd_alg == CRYPTO_SHA1_HMAC96) &&\n\t\t    (crd1->crd_flags & CRD_F_ENCRYPT)) {\n\t\t\tenccrd = crd1;\n\t\t\tmaccrd = crd2;\n\t\t}\n\t\telse {\n\t\t\t/*\n\t\t\t * We cannot order the 7751 as requested\n\t\t\t */\n\t\t\terr = EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tif (enccrd) {\n\t\tcmd->base_masks |= HIFN_BASE_CMD_CRYPT;\n\t\tcmd->cry_masks |= HIFN_CRYPT_CMD_MODE_CBC |\n\t\t    HIFN_CRYPT_CMD_NEW_IV;\n\t\tif (enccrd->crd_flags & CRD_F_ENCRYPT) {\n\t\t\tif (enccrd->crd_flags & CRD_F_IV_EXPLICIT)\n\t\t\t\tbcopy(enccrd->crd_iv, cmd->iv, HIFN_IV_LENGTH);\n\t\t\telse\n\t\t\t\tbcopy(sc->sc_sessions[session].hs_iv,\n\t\t\t\t    cmd->iv, HIFN_IV_LENGTH);\n\n\t\t\tif ((enccrd->crd_flags & CRD_F_IV_PRESENT) == 0)\n\t\t\t\tm_copyback(cmd->src_m, enccrd->crd_inject,\n\t\t\t\t    HIFN_IV_LENGTH, cmd->iv);\n\t\t}\n\t\telse {\n\t\t\tif (enccrd->crd_flags & CRD_F_IV_EXPLICIT)\n\t\t\t\tbcopy(enccrd->crd_iv, cmd->iv, HIFN_IV_LENGTH);\n\t\t\telse\n\t\t\t\tm_copydata(cmd->src_m, enccrd->crd_inject,\n\t\t\t\t    HIFN_IV_LENGTH, cmd->iv);\n\t\t}\n\n\t\tif (enccrd->crd_alg == CRYPTO_DES_CBC)\n\t\t\tcmd->cry_masks |= HIFN_CRYPT_CMD_ALG_DES;\n\t\telse\n\t\t\tcmd->cry_masks |= HIFN_CRYPT_CMD_ALG_3DES;\n\n\t\tcmd->crypt_header_skip = enccrd->crd_skip;\n\t\tcmd->crypt_process_len = enccrd->crd_len;\n\t\tcmd->ck = enccrd->crd_key;\n\n\t\tif (sc->sc_sessions[session].hs_flags == 1)\n\t\t\tcmd->cry_masks |= HIFN_CRYPT_CMD_NEW_KEY;\n\t}\n\n\tif (maccrd) {\n\t\tcmd->base_masks |= HIFN_BASE_CMD_MAC;\n\t\tcmd->mac_masks |= HIFN_MAC_CMD_RESULT |\n\t\t    HIFN_MAC_CMD_MODE_HMAC | HIFN_MAC_CMD_RESULT |\n\t\t    HIFN_MAC_CMD_POS_IPSEC | HIFN_MAC_CMD_TRUNC;\n\n\t\tif (maccrd->crd_alg == CRYPTO_MD5_HMAC96)\n\t\t\tcmd->mac_masks |= HIFN_MAC_CMD_ALG_MD5;\n\t\telse\n\t\t\tcmd->mac_masks |= HIFN_MAC_CMD_ALG_SHA1;\n\n\t\tif (sc->sc_sessions[session].hs_flags == 1) {\n\t\t\tcmd->mac_masks |= HIFN_MAC_CMD_NEW_KEY;\n\t\t\tbcopy(maccrd->crd_key, cmd->mac, maccrd->crd_klen >> 3);\n\t\t\tbzero(cmd->mac + (maccrd->crd_klen >> 3),\n\t\t\t    HIFN_MAC_KEY_LENGTH - (maccrd->crd_klen >> 3));\n\t\t}\n\n\t\tcmd->mac_header_skip = maccrd->crd_skip;\n\t\tcmd->mac_process_len = maccrd->crd_len;\n\t}\n\n\tif (sc->sc_sessions[session].hs_flags == 1)\n\t\tsc->sc_sessions[session].hs_flags = 2;\n\n\tcmd->dest_ready_callback = hifn_callback;\n\tcmd->private_data = (u_long)crp;\n\tcmd->session_num = session;\n\tcmd->softc = sc;\n\n\tif (hifn_crypto(sc, cmd) == 0)\n\t\treturn (0);\n\n\terr = ENOMEM;\n\nerrout:\n\tif (cmd != NULL)\n\t\tfree(cmd, M_DEVBUF);\n\tif (err == EINVAL)\n\t\thifnstats.hst_invalid++;\n\telse\n\t\thifnstats.hst_nomem++;\n\tcrp->crp_etype = err;\n\tcrp->crp_callback(crp);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/hifn7751reg.h>",
      "#include <dev/pci/hifn7751var.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/rndvar.h>",
      "#include <crypto/crypto.h>",
      "#include <sys/device.h>",
      "#include <machine/pmap.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver hifn_cd = {\n\t0, \"hifn\", DV_DULL\n};",
      "int\thifn_process",
      "void\thifn_callback",
      "int\thifn_crypto",
      "struct hifn_stats {\n\tu_int64_t hst_ibytes;\n\tu_int64_t hst_obytes;\n\tu_int32_t hst_ipackets;\n\tu_int32_t hst_opackets;\n\tu_int32_t hst_invalid;\n\tu_int32_t hst_nomem;\n} hifnstats;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "crp->crp_callback",
          "args": [
            "crp"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cmd",
            "M_DEVBUF"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_freesession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "1151-1170",
          "snippet": "int\nhifn_freesession(tid)\n\tu_int64_t tid;\n{\n\tstruct hifn_softc *sc;\n\tint card, session;\n\tu_int32_t sid = (tid >> 31) & 0xffffffff;\n\n\tcard = HIFN_CARD(sid);\n\tif (card >= hifn_cd.cd_ndevs || hifn_cd.cd_devs[card] == NULL)\n\t\treturn (EINVAL);\n\n\tsc = hifn_cd.cd_devs[card];\n\tsession = HIFN_SESSION(sid);\n\tif (session >= sc->sc_maxses)\n\t\treturn (EINVAL);\n\n\tsc->sc_sessions[session].hs_flags = 0;\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cfdriver hifn_cd = {\n\t0, \"hifn\", DV_DULL\n};",
            "int\thifn_freesession"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct cfdriver hifn_cd = {\n\t0, \"hifn\", DV_DULL\n};\nint\thifn_freesession;\n\nint\nhifn_freesession(tid)\n\tu_int64_t tid;\n{\n\tstruct hifn_softc *sc;\n\tint card, session;\n\tu_int32_t sid = (tid >> 31) & 0xffffffff;\n\n\tcard = HIFN_CARD(sid);\n\tif (card >= hifn_cd.cd_ndevs || hifn_cd.cd_devs[card] == NULL)\n\t\treturn (EINVAL);\n\n\tsc = hifn_cd.cd_devs[card];\n\tsession = HIFN_SESSION(sid);\n\tif (session >= sc->sc_maxses)\n\t\treturn (EINVAL);\n\n\tsc->sc_sessions[session].hs_flags = 0;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hifn_crypto",
          "args": [
            "sc",
            "cmd"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_crypto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "823-999",
          "snippet": "int \nhifn_crypto(sc, cmd)\n\tstruct hifn_softc *sc;\n\tstruct hifn_command *cmd;\n{\n\tu_int32_t cmdlen;\n\tstruct\thifn_dma *dma = sc->sc_dma;\n\tint\tcmdi, srci, dsti, resi, nicealign = 0;\n\tint     s, i;\n\n\tif (cmd->src_npa == 0 && cmd->src_m)\n\t\tcmd->src_l = mbuf2pages(cmd->src_m, &cmd->src_npa,\n\t\t    cmd->src_packp, cmd->src_packl, MAX_SCATTER, &nicealign);\n\tif (cmd->src_l == 0)\n\t\treturn (-1);\n\n\tif (nicealign == 0) {\n\t\tint totlen, len;\n\t\tstruct mbuf *m, *top, **mp;\n\n\t\ttotlen = cmd->dst_l = cmd->src_l;\n\t\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\t\tM_COPY_PKTHDR(m, cmd->src_m);\n\t\tif (m == NULL)\n\t\t\treturn (-1);\n\t\tlen = MHLEN;\n\t\tif (totlen >= MINCLSIZE) {\n\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\tif (m->m_flags & M_EXT)\n\t\t\t\tlen = MCLBYTES;\n\t\t}\n\t\tm->m_len = len;\n\t\ttop = NULL;\n\t\tmp = &top;\n\n\t\twhile (totlen > 0) {\n\t\t\tif (top) {\n\t\t\t\tMGET(m, M_DONTWAIT, MT_DATA);\n\t\t\t\tif (m == NULL) {\n\t\t\t\t\tm_freem(top);\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t\tlen = MLEN;\n\t\t\t}\n\t\t\tif (top && totlen >= MINCLSIZE) {\n\t\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\t\tif (m->m_flags & M_EXT)\n\t\t\t\t\tlen = MCLBYTES;\n\t\t\t}\n\t\t\tm->m_len = len;\n\t\t\ttotlen -= len;\n\t\t\t*mp = m;\n\t\t\tmp = &m->m_next;\n\t\t}\n\t\tcmd->dst_m = top;\n\t}\n\telse\n\t\tcmd->dst_m = cmd->src_m;\n\n\tcmd->dst_l = mbuf2pages(cmd->dst_m, &cmd->dst_npa,\n\t    cmd->dst_packp, cmd->dst_packl, MAX_SCATTER, NULL);\n\tif (cmd->dst_l == 0)\n\t\treturn (-1);\n\n#ifdef HIFN_DEBUG\n\tprintf(\"%s: Entering cmd: stat %8x ien %8x u %d/%d/%d/%d n %d/%d\\n\",\n\t    sc->sc_dv.dv_xname,\n\t    READ_REG_1(sc, HIFN_1_DMA_CSR), READ_REG_1(sc, HIFN_1_DMA_IER),\n\t    dma->cmdu, dma->srcu, dma->dstu, dma->resu, cmd->src_npa,\n\t    cmd->dst_npa);\n#endif\n\n\ts = splnet();\n\n\t/*\n\t * need 1 cmd, and 1 res\n\t * need N src, and N dst\n\t */\n\tif (dma->cmdu+1 > HIFN_D_CMD_RSIZE ||\n\t    dma->srcu+cmd->src_npa > HIFN_D_SRC_RSIZE ||\n\t    dma->dstu+cmd->dst_npa > HIFN_D_DST_RSIZE ||\n\t    dma->resu+1 > HIFN_D_RES_RSIZE) {\n\t\t\tsplx(s);\n\t\t\treturn (HIFN_CRYPTO_RINGS_FULL);\n\t}\n\n\tif (dma->cmdi == HIFN_D_CMD_RSIZE) {\n\t\tdma->cmdi = 0;\n\t\tdma->cmdr[HIFN_D_CMD_RSIZE].l = HIFN_D_VALID | HIFN_D_LAST |\n\t\t    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP;\n\t}\n\tcmdi = dma->cmdi++;\n\n\tif (dma->resi == HIFN_D_RES_RSIZE) {\n\t\tdma->resi = 0;\n\t\tdma->resr[HIFN_D_RES_RSIZE].l = HIFN_D_VALID | HIFN_D_LAST |\n\t\t    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP;\n\t}\n\tresi = dma->resi++;\n\n\tcmdlen = hifn_write_command(cmd, dma->command_bufs[cmdi]);\n#ifdef HIFN_DEBUG\n\tprintf(\"write_command %d (nice %d)\\n\", cmdlen, nicealign);\n#endif\n\t/* .p for command/result already set */\n\tdma->cmdr[cmdi].l = cmdlen | HIFN_D_VALID | HIFN_D_LAST |\n\t    HIFN_D_MASKDONEIRQ;\n\tdma->cmdu++;\n\n\t/*\n\t * We don't worry about missing an interrupt (which a \"command wait\"\n\t * interrupt salvages us from), unless there is more than one command\n\t * in the queue.\n\t */\n\tif (dma->cmdu > 1)\n\t\tWRITE_REG_1(sc, HIFN_1_DMA_IER,\n\t\t    HIFN_DMAIER_C_WAIT | HIFN_DMAIER_R_DONE);\n\n\thifnstats.hst_ipackets++;\n\n\tfor (i = 0; i < cmd->src_npa; i++) {\n\t\tint last = 0;\n\n\t\tif (i == cmd->src_npa-1)\n\t\t\tlast = HIFN_D_LAST;\n\n\t\tif (dma->srci == HIFN_D_SRC_RSIZE) {\n\t\t\tsrci = 0, dma->srci = 1;\n\t\t\tdma->srcr[HIFN_D_SRC_RSIZE].l = HIFN_D_VALID |\n\t\t\t    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP | HIFN_D_LAST;\n\t\t} else\n\t\t\tsrci = dma->srci++;\n\t\tdma->srcr[srci].p = cmd->src_packp[i];\n\t\tdma->srcr[srci].l = cmd->src_packl[i] | HIFN_D_VALID |\n\t\t    HIFN_D_MASKDONEIRQ | last;\n\t\thifnstats.hst_ibytes += cmd->src_packl[i];\n\t}\n\tdma->srcu += cmd->src_npa;\n\n\tfor (i = 0; i < cmd->dst_npa; i++) {\n\t\tint last = 0;\n\n\t\tif (i == cmd->dst_npa-1)\n\t\t\tlast = HIFN_D_LAST;\n\n\t\tif (dma->dsti == HIFN_D_DST_RSIZE) {\n\t\t\tdsti = 0, dma->dsti = 1;\n\t\t\tdma->dstr[HIFN_D_DST_RSIZE].l = HIFN_D_VALID |\n\t\t\t    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP | HIFN_D_LAST;\n\t\t} else\n\t\t\tdsti = dma->dsti++;\n\t\tdma->dstr[dsti].p = cmd->dst_packp[i];\n\t\tdma->dstr[dsti].l = cmd->dst_packl[i] | HIFN_D_VALID |\n\t\t    HIFN_D_MASKDONEIRQ | last;\n\t}\n\tdma->dstu += cmd->dst_npa;\n\n\t/*\n\t * Unlike other descriptors, we don't mask done interrupt from\n\t * result descriptor.\n\t */\n#ifdef HIFN_DEBUG\n\tprintf(\"load res\\n\");\n#endif\n\tdma->hifn_commands[resi] = cmd;\n\tdma->resr[resi].l = HIFN_MAX_RESULT | HIFN_D_VALID | HIFN_D_LAST;\n\tdma->resu++;\n\n#ifdef HIFN_DEBUG\n\tprintf(\"%s: command: stat %8x ier %8x\\n\",\n\t    sc->sc_dv.dv_xname,\n\t    READ_REG_1(sc, HIFN_1_DMA_CSR), READ_REG_1(sc, HIFN_1_DMA_IER));\n#endif\n\n\tsplx(s);\n\treturn 0;\t\t/* success */\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_int\thifn_write_command",
            "int\thifn_crypto",
            "struct hifn_stats {\n\tu_int64_t hst_ibytes;\n\tu_int64_t hst_obytes;\n\tu_int32_t hst_ipackets;\n\tu_int32_t hst_opackets;\n\tu_int32_t hst_invalid;\n\tu_int32_t hst_nomem;\n} hifnstats;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int\thifn_write_command;\nint\thifn_crypto;\nstruct hifn_stats {\n\tu_int64_t hst_ibytes;\n\tu_int64_t hst_obytes;\n\tu_int32_t hst_ipackets;\n\tu_int32_t hst_opackets;\n\tu_int32_t hst_invalid;\n\tu_int32_t hst_nomem;\n} hifnstats;\n\nint \nhifn_crypto(sc, cmd)\n\tstruct hifn_softc *sc;\n\tstruct hifn_command *cmd;\n{\n\tu_int32_t cmdlen;\n\tstruct\thifn_dma *dma = sc->sc_dma;\n\tint\tcmdi, srci, dsti, resi, nicealign = 0;\n\tint     s, i;\n\n\tif (cmd->src_npa == 0 && cmd->src_m)\n\t\tcmd->src_l = mbuf2pages(cmd->src_m, &cmd->src_npa,\n\t\t    cmd->src_packp, cmd->src_packl, MAX_SCATTER, &nicealign);\n\tif (cmd->src_l == 0)\n\t\treturn (-1);\n\n\tif (nicealign == 0) {\n\t\tint totlen, len;\n\t\tstruct mbuf *m, *top, **mp;\n\n\t\ttotlen = cmd->dst_l = cmd->src_l;\n\t\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\t\tM_COPY_PKTHDR(m, cmd->src_m);\n\t\tif (m == NULL)\n\t\t\treturn (-1);\n\t\tlen = MHLEN;\n\t\tif (totlen >= MINCLSIZE) {\n\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\tif (m->m_flags & M_EXT)\n\t\t\t\tlen = MCLBYTES;\n\t\t}\n\t\tm->m_len = len;\n\t\ttop = NULL;\n\t\tmp = &top;\n\n\t\twhile (totlen > 0) {\n\t\t\tif (top) {\n\t\t\t\tMGET(m, M_DONTWAIT, MT_DATA);\n\t\t\t\tif (m == NULL) {\n\t\t\t\t\tm_freem(top);\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t\tlen = MLEN;\n\t\t\t}\n\t\t\tif (top && totlen >= MINCLSIZE) {\n\t\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\t\tif (m->m_flags & M_EXT)\n\t\t\t\t\tlen = MCLBYTES;\n\t\t\t}\n\t\t\tm->m_len = len;\n\t\t\ttotlen -= len;\n\t\t\t*mp = m;\n\t\t\tmp = &m->m_next;\n\t\t}\n\t\tcmd->dst_m = top;\n\t}\n\telse\n\t\tcmd->dst_m = cmd->src_m;\n\n\tcmd->dst_l = mbuf2pages(cmd->dst_m, &cmd->dst_npa,\n\t    cmd->dst_packp, cmd->dst_packl, MAX_SCATTER, NULL);\n\tif (cmd->dst_l == 0)\n\t\treturn (-1);\n\n#ifdef HIFN_DEBUG\n\tprintf(\"%s: Entering cmd: stat %8x ien %8x u %d/%d/%d/%d n %d/%d\\n\",\n\t    sc->sc_dv.dv_xname,\n\t    READ_REG_1(sc, HIFN_1_DMA_CSR), READ_REG_1(sc, HIFN_1_DMA_IER),\n\t    dma->cmdu, dma->srcu, dma->dstu, dma->resu, cmd->src_npa,\n\t    cmd->dst_npa);\n#endif\n\n\ts = splnet();\n\n\t/*\n\t * need 1 cmd, and 1 res\n\t * need N src, and N dst\n\t */\n\tif (dma->cmdu+1 > HIFN_D_CMD_RSIZE ||\n\t    dma->srcu+cmd->src_npa > HIFN_D_SRC_RSIZE ||\n\t    dma->dstu+cmd->dst_npa > HIFN_D_DST_RSIZE ||\n\t    dma->resu+1 > HIFN_D_RES_RSIZE) {\n\t\t\tsplx(s);\n\t\t\treturn (HIFN_CRYPTO_RINGS_FULL);\n\t}\n\n\tif (dma->cmdi == HIFN_D_CMD_RSIZE) {\n\t\tdma->cmdi = 0;\n\t\tdma->cmdr[HIFN_D_CMD_RSIZE].l = HIFN_D_VALID | HIFN_D_LAST |\n\t\t    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP;\n\t}\n\tcmdi = dma->cmdi++;\n\n\tif (dma->resi == HIFN_D_RES_RSIZE) {\n\t\tdma->resi = 0;\n\t\tdma->resr[HIFN_D_RES_RSIZE].l = HIFN_D_VALID | HIFN_D_LAST |\n\t\t    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP;\n\t}\n\tresi = dma->resi++;\n\n\tcmdlen = hifn_write_command(cmd, dma->command_bufs[cmdi]);\n#ifdef HIFN_DEBUG\n\tprintf(\"write_command %d (nice %d)\\n\", cmdlen, nicealign);\n#endif\n\t/* .p for command/result already set */\n\tdma->cmdr[cmdi].l = cmdlen | HIFN_D_VALID | HIFN_D_LAST |\n\t    HIFN_D_MASKDONEIRQ;\n\tdma->cmdu++;\n\n\t/*\n\t * We don't worry about missing an interrupt (which a \"command wait\"\n\t * interrupt salvages us from), unless there is more than one command\n\t * in the queue.\n\t */\n\tif (dma->cmdu > 1)\n\t\tWRITE_REG_1(sc, HIFN_1_DMA_IER,\n\t\t    HIFN_DMAIER_C_WAIT | HIFN_DMAIER_R_DONE);\n\n\thifnstats.hst_ipackets++;\n\n\tfor (i = 0; i < cmd->src_npa; i++) {\n\t\tint last = 0;\n\n\t\tif (i == cmd->src_npa-1)\n\t\t\tlast = HIFN_D_LAST;\n\n\t\tif (dma->srci == HIFN_D_SRC_RSIZE) {\n\t\t\tsrci = 0, dma->srci = 1;\n\t\t\tdma->srcr[HIFN_D_SRC_RSIZE].l = HIFN_D_VALID |\n\t\t\t    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP | HIFN_D_LAST;\n\t\t} else\n\t\t\tsrci = dma->srci++;\n\t\tdma->srcr[srci].p = cmd->src_packp[i];\n\t\tdma->srcr[srci].l = cmd->src_packl[i] | HIFN_D_VALID |\n\t\t    HIFN_D_MASKDONEIRQ | last;\n\t\thifnstats.hst_ibytes += cmd->src_packl[i];\n\t}\n\tdma->srcu += cmd->src_npa;\n\n\tfor (i = 0; i < cmd->dst_npa; i++) {\n\t\tint last = 0;\n\n\t\tif (i == cmd->dst_npa-1)\n\t\t\tlast = HIFN_D_LAST;\n\n\t\tif (dma->dsti == HIFN_D_DST_RSIZE) {\n\t\t\tdsti = 0, dma->dsti = 1;\n\t\t\tdma->dstr[HIFN_D_DST_RSIZE].l = HIFN_D_VALID |\n\t\t\t    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP | HIFN_D_LAST;\n\t\t} else\n\t\t\tdsti = dma->dsti++;\n\t\tdma->dstr[dsti].p = cmd->dst_packp[i];\n\t\tdma->dstr[dsti].l = cmd->dst_packl[i] | HIFN_D_VALID |\n\t\t    HIFN_D_MASKDONEIRQ | last;\n\t}\n\tdma->dstu += cmd->dst_npa;\n\n\t/*\n\t * Unlike other descriptors, we don't mask done interrupt from\n\t * result descriptor.\n\t */\n#ifdef HIFN_DEBUG\n\tprintf(\"load res\\n\");\n#endif\n\tdma->hifn_commands[resi] = cmd;\n\tdma->resr[resi].l = HIFN_MAX_RESULT | HIFN_D_VALID | HIFN_D_LAST;\n\tdma->resu++;\n\n#ifdef HIFN_DEBUG\n\tprintf(\"%s: command: stat %8x ier %8x\\n\",\n\t    sc->sc_dv.dv_xname,\n\t    READ_REG_1(sc, HIFN_1_DMA_CSR), READ_REG_1(sc, HIFN_1_DMA_IER));\n#endif\n\n\tsplx(s);\n\treturn 0;\t\t/* success */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "cmd->mac + (maccrd->crd_klen >> 3)",
            "HIFN_MAC_KEY_LENGTH - (maccrd->crd_klen >> 3)"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "maccrd->crd_key",
            "cmd->mac",
            "maccrd->crd_klen >> 3"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "cmd->src_m",
            "enccrd->crd_inject",
            "HIFN_IV_LENGTH",
            "cmd->iv"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copyback",
          "args": [
            "cmd->src_m",
            "enccrd->crd_inject",
            "HIFN_IV_LENGTH",
            "cmd->iv"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "cmd",
            "sizeof(struct hifn_command)"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct hifn_command)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "HIFN_SESSION",
          "args": [
            "crp->crp_sid"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HIFN_CARD",
          "args": [
            "crp->crp_sid"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct cfdriver hifn_cd = {\n\t0, \"hifn\", DV_DULL\n};\nint\thifn_process;\nvoid\thifn_callback;\nint\thifn_crypto;\nstruct hifn_stats {\n\tu_int64_t hst_ibytes;\n\tu_int64_t hst_obytes;\n\tu_int32_t hst_ipackets;\n\tu_int32_t hst_opackets;\n\tu_int32_t hst_invalid;\n\tu_int32_t hst_nomem;\n} hifnstats;\n\nint\nhifn_process(crp)\n\tstruct cryptop *crp;\n{\n\tstruct hifn_command *cmd = NULL;\n\tint card, session, err;\n\tstruct hifn_softc *sc;\n\tstruct cryptodesc *crd1, *crd2, *maccrd, *enccrd;\n\n\tif (crp == NULL || crp->crp_callback == NULL) {\n\t\thifnstats.hst_invalid++;\n\t\treturn (EINVAL);\n\t}\n\n\tcard = HIFN_CARD(crp->crp_sid);\n\tif (card >= hifn_cd.cd_ndevs || hifn_cd.cd_devs[card] == NULL) {\n\t\terr = EINVAL;\n\t\tgoto errout;\n\t}\n\n\tsc = hifn_cd.cd_devs[card];\n\tsession = HIFN_SESSION(crp->crp_sid);\n\tif (session >= sc->sc_maxses) {\n\t\terr = EINVAL;\n\t\tgoto errout;\n\t}\n\n\tcmd = (struct hifn_command *)malloc(sizeof(struct hifn_command),\n\t    M_DEVBUF, M_NOWAIT);\n\tif (cmd == NULL) {\n\t\terr = ENOMEM;\n\t\tgoto errout;\n\t}\n\tbzero(cmd, sizeof(struct hifn_command));\n\n\tif (crp->crp_flags & CRYPTO_F_IMBUF) {\n\t\tcmd->src_m = (struct mbuf *)crp->crp_buf;\n\t\tcmd->dst_m = (struct mbuf *)crp->crp_buf;\n\t}\n\telse {\n\t\terr = EINVAL;\n\t\tgoto errout;\t/* XXX only handle mbufs right now */\n\t}\n\n\tcrd1 = crp->crp_desc;\n\tif (crd1 == NULL) {\n\t\terr = EINVAL;\n\t\tgoto errout;\n\t}\n\tcrd2 = crd1->crd_next;\n\n\tif (crd2 == NULL) {\n\t\tif (crd1->crd_alg == CRYPTO_MD5_HMAC96 ||\n\t\t    crd1->crd_alg == CRYPTO_SHA1_HMAC96) {\n\t\t\tmaccrd = crd1;\n\t\t\tenccrd = NULL;\n\t\t}\n\t\telse if (crd1->crd_alg == CRYPTO_DES_CBC ||\n\t\t\t crd1->crd_alg == CRYPTO_3DES_CBC) {\n\t\t\tif ((crd1->crd_flags & CRD_F_ENCRYPT) == 0)\n\t\t\t\tcmd->base_masks |= HIFN_BASE_CMD_DECODE;\n\t\t\tmaccrd = NULL;\n\t\t\tenccrd = crd1;\n\t\t}\n\t\telse {\n\t\t\terr = EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\telse {\n\t\tif ((crd1->crd_alg == CRYPTO_MD5_HMAC96 ||\n\t\t    crd1->crd_alg == CRYPTO_SHA1_HMAC96) &&\n\t\t    (crd2->crd_alg == CRYPTO_DES_CBC ||\n\t\t\tcrd2->crd_alg == CRYPTO_3DES_CBC) &&\n\t\t    ((crd2->crd_flags & CRD_F_ENCRYPT) == 0)) {\n\t\t\tcmd->base_masks = HIFN_BASE_CMD_DECODE;\n\t\t\tmaccrd = crd1;\n\t\t\tenccrd = crd2;\n\t\t}\n\t\telse if ((crd1->crd_alg == CRYPTO_DES_CBC ||\n\t\t    crd1->crd_alg == CRYPTO_3DES_CBC) &&\n\t\t    (crd2->crd_alg == CRYPTO_MD5_HMAC96 ||\n\t\t\tcrd2->crd_alg == CRYPTO_SHA1_HMAC96) &&\n\t\t    (crd1->crd_flags & CRD_F_ENCRYPT)) {\n\t\t\tenccrd = crd1;\n\t\t\tmaccrd = crd2;\n\t\t}\n\t\telse {\n\t\t\t/*\n\t\t\t * We cannot order the 7751 as requested\n\t\t\t */\n\t\t\terr = EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tif (enccrd) {\n\t\tcmd->base_masks |= HIFN_BASE_CMD_CRYPT;\n\t\tcmd->cry_masks |= HIFN_CRYPT_CMD_MODE_CBC |\n\t\t    HIFN_CRYPT_CMD_NEW_IV;\n\t\tif (enccrd->crd_flags & CRD_F_ENCRYPT) {\n\t\t\tif (enccrd->crd_flags & CRD_F_IV_EXPLICIT)\n\t\t\t\tbcopy(enccrd->crd_iv, cmd->iv, HIFN_IV_LENGTH);\n\t\t\telse\n\t\t\t\tbcopy(sc->sc_sessions[session].hs_iv,\n\t\t\t\t    cmd->iv, HIFN_IV_LENGTH);\n\n\t\t\tif ((enccrd->crd_flags & CRD_F_IV_PRESENT) == 0)\n\t\t\t\tm_copyback(cmd->src_m, enccrd->crd_inject,\n\t\t\t\t    HIFN_IV_LENGTH, cmd->iv);\n\t\t}\n\t\telse {\n\t\t\tif (enccrd->crd_flags & CRD_F_IV_EXPLICIT)\n\t\t\t\tbcopy(enccrd->crd_iv, cmd->iv, HIFN_IV_LENGTH);\n\t\t\telse\n\t\t\t\tm_copydata(cmd->src_m, enccrd->crd_inject,\n\t\t\t\t    HIFN_IV_LENGTH, cmd->iv);\n\t\t}\n\n\t\tif (enccrd->crd_alg == CRYPTO_DES_CBC)\n\t\t\tcmd->cry_masks |= HIFN_CRYPT_CMD_ALG_DES;\n\t\telse\n\t\t\tcmd->cry_masks |= HIFN_CRYPT_CMD_ALG_3DES;\n\n\t\tcmd->crypt_header_skip = enccrd->crd_skip;\n\t\tcmd->crypt_process_len = enccrd->crd_len;\n\t\tcmd->ck = enccrd->crd_key;\n\n\t\tif (sc->sc_sessions[session].hs_flags == 1)\n\t\t\tcmd->cry_masks |= HIFN_CRYPT_CMD_NEW_KEY;\n\t}\n\n\tif (maccrd) {\n\t\tcmd->base_masks |= HIFN_BASE_CMD_MAC;\n\t\tcmd->mac_masks |= HIFN_MAC_CMD_RESULT |\n\t\t    HIFN_MAC_CMD_MODE_HMAC | HIFN_MAC_CMD_RESULT |\n\t\t    HIFN_MAC_CMD_POS_IPSEC | HIFN_MAC_CMD_TRUNC;\n\n\t\tif (maccrd->crd_alg == CRYPTO_MD5_HMAC96)\n\t\t\tcmd->mac_masks |= HIFN_MAC_CMD_ALG_MD5;\n\t\telse\n\t\t\tcmd->mac_masks |= HIFN_MAC_CMD_ALG_SHA1;\n\n\t\tif (sc->sc_sessions[session].hs_flags == 1) {\n\t\t\tcmd->mac_masks |= HIFN_MAC_CMD_NEW_KEY;\n\t\t\tbcopy(maccrd->crd_key, cmd->mac, maccrd->crd_klen >> 3);\n\t\t\tbzero(cmd->mac + (maccrd->crd_klen >> 3),\n\t\t\t    HIFN_MAC_KEY_LENGTH - (maccrd->crd_klen >> 3));\n\t\t}\n\n\t\tcmd->mac_header_skip = maccrd->crd_skip;\n\t\tcmd->mac_process_len = maccrd->crd_len;\n\t}\n\n\tif (sc->sc_sessions[session].hs_flags == 1)\n\t\tsc->sc_sessions[session].hs_flags = 2;\n\n\tcmd->dest_ready_callback = hifn_callback;\n\tcmd->private_data = (u_long)crp;\n\tcmd->session_num = session;\n\tcmd->softc = sc;\n\n\tif (hifn_crypto(sc, cmd) == 0)\n\t\treturn (0);\n\n\terr = ENOMEM;\n\nerrout:\n\tif (cmd != NULL)\n\t\tfree(cmd, M_DEVBUF);\n\tif (err == EINVAL)\n\t\thifnstats.hst_invalid++;\n\telse\n\t\thifnstats.hst_nomem++;\n\tcrp->crp_etype = err;\n\tcrp->crp_callback(crp);\n\treturn (0);\n}"
  },
  {
    "function_name": "hifn_freesession",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
    "lines": "1151-1170",
    "snippet": "int\nhifn_freesession(tid)\n\tu_int64_t tid;\n{\n\tstruct hifn_softc *sc;\n\tint card, session;\n\tu_int32_t sid = (tid >> 31) & 0xffffffff;\n\n\tcard = HIFN_CARD(sid);\n\tif (card >= hifn_cd.cd_ndevs || hifn_cd.cd_devs[card] == NULL)\n\t\treturn (EINVAL);\n\n\tsc = hifn_cd.cd_devs[card];\n\tsession = HIFN_SESSION(sid);\n\tif (session >= sc->sc_maxses)\n\t\treturn (EINVAL);\n\n\tsc->sc_sessions[session].hs_flags = 0;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/hifn7751reg.h>",
      "#include <dev/pci/hifn7751var.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/rndvar.h>",
      "#include <crypto/crypto.h>",
      "#include <sys/device.h>",
      "#include <machine/pmap.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver hifn_cd = {\n\t0, \"hifn\", DV_DULL\n};",
      "int\thifn_freesession"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "HIFN_SESSION",
          "args": [
            "sid"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HIFN_CARD",
          "args": [
            "sid"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct cfdriver hifn_cd = {\n\t0, \"hifn\", DV_DULL\n};\nint\thifn_freesession;\n\nint\nhifn_freesession(tid)\n\tu_int64_t tid;\n{\n\tstruct hifn_softc *sc;\n\tint card, session;\n\tu_int32_t sid = (tid >> 31) & 0xffffffff;\n\n\tcard = HIFN_CARD(sid);\n\tif (card >= hifn_cd.cd_ndevs || hifn_cd.cd_devs[card] == NULL)\n\t\treturn (EINVAL);\n\n\tsc = hifn_cd.cd_devs[card];\n\tsession = HIFN_SESSION(sid);\n\tif (session >= sc->sc_maxses)\n\t\treturn (EINVAL);\n\n\tsc->sc_sessions[session].hs_flags = 0;\n\treturn (0);\n}"
  },
  {
    "function_name": "hifn_newsession",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
    "lines": "1091-1144",
    "snippet": "int\nhifn_newsession(sidp, cri)\n\tu_int32_t *sidp;\n\tstruct cryptoini *cri;\n{\n\tstruct cryptoini *c;\n\tstruct hifn_softc *sc = NULL;\n\tint i, mac = 0, cry = 0;\n\n\tif (sidp == NULL || cri == NULL)\n\t\treturn (EINVAL);\n\n\tfor (i = 0; i < hifn_cd.cd_ndevs; i++) {\n\t\tsc = hifn_cd.cd_devs[i];\n\t\tif (sc == NULL)\n\t\t\tbreak;\n\t\tif (sc->sc_cid == (*sidp))\n\t\t\tbreak;\n\t}\n\tif (sc == NULL)\n\t\treturn (EINVAL);\n\n\tfor (i = 0; i < sc->sc_maxses; i++) {\n\t\tif (sc->sc_sessions[i].hs_flags == 0)\n\t\t\tbreak;\n\t}\n\tif (i == sc->sc_maxses)\n\t\treturn (ENOMEM);\n\n\tfor (c = cri; c != NULL; c = c->cri_next) {\n\t\tif (c->cri_alg == CRYPTO_MD5_HMAC96 ||\n\t\t    c->cri_alg == CRYPTO_SHA1_HMAC96) {\n\t\t\tif (mac)\n\t\t\t\treturn (EINVAL);\n\t\t\tmac = 1;\n\t\t}\n\t\telse if (c->cri_alg == CRYPTO_DES_CBC ||\n\t\t    c->cri_alg == CRYPTO_3DES_CBC) {\n\t\t\tif (cry)\n\t\t\t\treturn (EINVAL);\n\t\t\tcry = 1;\n\t\t}\n\t\telse\n\t\t\treturn (EINVAL);\n\t}\n\tif (mac == 0 && cry == 0)\n\t\treturn (EINVAL);\n\n\t*sidp = HIFN_SID(sc->sc_dv.dv_unit, i);\n\tsc->sc_sessions[i].hs_flags = 1;\n\tget_random_bytes(sc->sc_sessions[i].hs_iv, HIFN_IV_LENGTH);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/hifn7751reg.h>",
      "#include <dev/pci/hifn7751var.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/rndvar.h>",
      "#include <crypto/crypto.h>",
      "#include <sys/device.h>",
      "#include <machine/pmap.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver hifn_cd = {\n\t0, \"hifn\", DV_DULL\n};",
      "int\thifn_newsession"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "sc->sc_sessions[i].hs_iv",
            "HIFN_IV_LENGTH"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "get_random_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rnd.c",
          "lines": "901-908",
          "snippet": "void\nget_random_bytes(buf, nbytes)\n\tvoid\t*buf;\n\tsize_t\tnbytes;\n{\n\textract_entropy((u_int8_t *) buf, nbytes);\n\trndstats.rnd_used += nbytes * 8;\n}",
          "includes": [
            "#include <dev/rndioctl.h>",
            "#include <dev/rndvar.h>",
            "#include <sys/timeout.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/md5k.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/disk.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rndstats rndstats;",
            "static __inline void extract_entropy",
            "__P((register u_int8_t *, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/rndioctl.h>\n#include <dev/rndvar.h>\n#include <sys/timeout.h>\n#include <sys/sysctl.h>\n#include <sys/md5k.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct rndstats rndstats;\nstatic __inline void extract_entropy;\n__P((register u_int8_t *, int));\n\nvoid\nget_random_bytes(buf, nbytes)\n\tvoid\t*buf;\n\tsize_t\tnbytes;\n{\n\textract_entropy((u_int8_t *) buf, nbytes);\n\trndstats.rnd_used += nbytes * 8;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HIFN_SID",
          "args": [
            "sc->sc_dv.dv_unit",
            "i"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct cfdriver hifn_cd = {\n\t0, \"hifn\", DV_DULL\n};\nint\thifn_newsession;\n\nint\nhifn_newsession(sidp, cri)\n\tu_int32_t *sidp;\n\tstruct cryptoini *cri;\n{\n\tstruct cryptoini *c;\n\tstruct hifn_softc *sc = NULL;\n\tint i, mac = 0, cry = 0;\n\n\tif (sidp == NULL || cri == NULL)\n\t\treturn (EINVAL);\n\n\tfor (i = 0; i < hifn_cd.cd_ndevs; i++) {\n\t\tsc = hifn_cd.cd_devs[i];\n\t\tif (sc == NULL)\n\t\t\tbreak;\n\t\tif (sc->sc_cid == (*sidp))\n\t\t\tbreak;\n\t}\n\tif (sc == NULL)\n\t\treturn (EINVAL);\n\n\tfor (i = 0; i < sc->sc_maxses; i++) {\n\t\tif (sc->sc_sessions[i].hs_flags == 0)\n\t\t\tbreak;\n\t}\n\tif (i == sc->sc_maxses)\n\t\treturn (ENOMEM);\n\n\tfor (c = cri; c != NULL; c = c->cri_next) {\n\t\tif (c->cri_alg == CRYPTO_MD5_HMAC96 ||\n\t\t    c->cri_alg == CRYPTO_SHA1_HMAC96) {\n\t\t\tif (mac)\n\t\t\t\treturn (EINVAL);\n\t\t\tmac = 1;\n\t\t}\n\t\telse if (c->cri_alg == CRYPTO_DES_CBC ||\n\t\t    c->cri_alg == CRYPTO_3DES_CBC) {\n\t\t\tif (cry)\n\t\t\t\treturn (EINVAL);\n\t\t\tcry = 1;\n\t\t}\n\t\telse\n\t\t\treturn (EINVAL);\n\t}\n\tif (mac == 0 && cry == 0)\n\t\treturn (EINVAL);\n\n\t*sidp = HIFN_SID(sc->sc_dv.dv_unit, i);\n\tsc->sc_sessions[i].hs_flags = 1;\n\tget_random_bytes(sc->sc_sessions[i].hs_iv, HIFN_IV_LENGTH);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "hifn_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
    "lines": "1001-1084",
    "snippet": "int \nhifn_intr(arg)\n\tvoid *arg;\n{\n\tstruct hifn_softc *sc = arg;\n\tstruct hifn_dma *dma = sc->sc_dma;\n\tu_int32_t dmacsr;\n\tint i, u;\n\n\tdmacsr = READ_REG_1(sc, HIFN_1_DMA_CSR);\n\n#ifdef HIFN_DEBUG\n\tprintf(\"%s: irq: stat %08x ien %08x u %d/%d/%d/%d\\n\",\n\t    sc->sc_dv.dv_xname,\n\t    dmacsr, READ_REG_1(sc, HIFN_1_DMA_IER),\n\t    dma->cmdu, dma->srcu, dma->dstu, dma->resu);\n#endif\n\n\tif ((dmacsr & (HIFN_DMACSR_R_DONE | HIFN_DMACSR_C_WAIT)) == 0)\n\t\treturn (0);\n\n\tif (dma->resu > HIFN_D_RES_RSIZE)\n\t\tprintf(\"%s: Internal Error -- ring overflow\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\n\tif ((dmacsr & HIFN_DMACSR_C_WAIT) && (dma->cmdu == 0)) {\n\t\t/*\n\t\t * If no slots to process and we receive a \"waiting on\n\t\t * command\" interrupt, we disable the \"waiting on command\"\n\t\t * (by clearing it).\n\t\t */\n\t\tWRITE_REG_1(sc, HIFN_1_DMA_IER, HIFN_DMAIER_R_DONE);\n\t}\n\n\twhile (dma->resu > 0) {\n\t\tstruct hifn_command *cmd;\n\t\tu_int8_t *macbuf = NULL;\n\n\t\tcmd = dma->hifn_commands[dma->resk];\n\n\t\t/* if still valid, stop processing */\n\t\tif (dma->resr[dma->resk].l & HIFN_D_VALID)\n\t\t\tbreak;\n\n\t\tif (cmd->base_masks & HIFN_BASE_CMD_MAC) {\n\t\t\tmacbuf = dma->result_bufs[dma->resk];\n\t\t\tmacbuf += 12;\n\t\t}\n\n\t\t/* position is done, notify producer with callback */\n\t\tcmd->dest_ready_callback(sc, cmd, macbuf);\n\t\n\t\tif (++dma->resk == HIFN_D_RES_RSIZE)\n\t\t\tdma->resk = 0;\n\t\tdma->resu--;\n\t\thifnstats.hst_opackets++;\n\t}\n\n\t/* clear the rings */\n\n\ti = dma->srck; u = dma->srcu;\n\twhile (u != 0 && (dma->srcr[i].l & HIFN_D_VALID) == 0) {\n\t\tif (++i == HIFN_D_SRC_RSIZE)\n\t\t\ti = 0;\n\t\tu--;\n\t}\n\tdma->srck = i; dma->srcu = u;\n\n\ti = dma->cmdk; u = dma->cmdu;\n\twhile (u != 0 && (dma->cmdr[i].l & HIFN_D_VALID) == 0) {\n\t\tif (++i == HIFN_D_CMD_RSIZE)\n\t\t\ti = 0;\n\t\tu--;\n\t}\n\tdma->cmdk = i; dma->cmdu = u;\n\n\t/*\n\t * Clear \"result done\" and \"command wait\" flags in status register.\n\t * If we still have slots to process and we received a \"command wait\"\n\t * interrupt, this will interupt us again.\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_R_DONE|HIFN_DMACSR_C_WAIT);\n\treturn (1);\n}",
    "includes": [
      "#include <dev/pci/hifn7751reg.h>",
      "#include <dev/pci/hifn7751var.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/rndvar.h>",
      "#include <crypto/crypto.h>",
      "#include <sys/device.h>",
      "#include <machine/pmap.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\thifn_intr",
      "struct hifn_stats {\n\tu_int64_t hst_ibytes;\n\tu_int64_t hst_obytes;\n\tu_int32_t hst_ipackets;\n\tu_int32_t hst_opackets;\n\tu_int32_t hst_invalid;\n\tu_int32_t hst_nomem;\n} hifnstats;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_CSR",
            "HIFN_DMACSR_R_DONE|HIFN_DMACSR_C_WAIT"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd->dest_ready_callback",
          "args": [
            "sc",
            "cmd",
            "macbuf"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_IER",
            "HIFN_DMAIER_R_DONE"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: Internal Error -- ring overflow\\n\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_IER"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_CSR"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\thifn_intr;\nstruct hifn_stats {\n\tu_int64_t hst_ibytes;\n\tu_int64_t hst_obytes;\n\tu_int32_t hst_ipackets;\n\tu_int32_t hst_opackets;\n\tu_int32_t hst_invalid;\n\tu_int32_t hst_nomem;\n} hifnstats;\n\nint \nhifn_intr(arg)\n\tvoid *arg;\n{\n\tstruct hifn_softc *sc = arg;\n\tstruct hifn_dma *dma = sc->sc_dma;\n\tu_int32_t dmacsr;\n\tint i, u;\n\n\tdmacsr = READ_REG_1(sc, HIFN_1_DMA_CSR);\n\n#ifdef HIFN_DEBUG\n\tprintf(\"%s: irq: stat %08x ien %08x u %d/%d/%d/%d\\n\",\n\t    sc->sc_dv.dv_xname,\n\t    dmacsr, READ_REG_1(sc, HIFN_1_DMA_IER),\n\t    dma->cmdu, dma->srcu, dma->dstu, dma->resu);\n#endif\n\n\tif ((dmacsr & (HIFN_DMACSR_R_DONE | HIFN_DMACSR_C_WAIT)) == 0)\n\t\treturn (0);\n\n\tif (dma->resu > HIFN_D_RES_RSIZE)\n\t\tprintf(\"%s: Internal Error -- ring overflow\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\n\tif ((dmacsr & HIFN_DMACSR_C_WAIT) && (dma->cmdu == 0)) {\n\t\t/*\n\t\t * If no slots to process and we receive a \"waiting on\n\t\t * command\" interrupt, we disable the \"waiting on command\"\n\t\t * (by clearing it).\n\t\t */\n\t\tWRITE_REG_1(sc, HIFN_1_DMA_IER, HIFN_DMAIER_R_DONE);\n\t}\n\n\twhile (dma->resu > 0) {\n\t\tstruct hifn_command *cmd;\n\t\tu_int8_t *macbuf = NULL;\n\n\t\tcmd = dma->hifn_commands[dma->resk];\n\n\t\t/* if still valid, stop processing */\n\t\tif (dma->resr[dma->resk].l & HIFN_D_VALID)\n\t\t\tbreak;\n\n\t\tif (cmd->base_masks & HIFN_BASE_CMD_MAC) {\n\t\t\tmacbuf = dma->result_bufs[dma->resk];\n\t\t\tmacbuf += 12;\n\t\t}\n\n\t\t/* position is done, notify producer with callback */\n\t\tcmd->dest_ready_callback(sc, cmd, macbuf);\n\t\n\t\tif (++dma->resk == HIFN_D_RES_RSIZE)\n\t\t\tdma->resk = 0;\n\t\tdma->resu--;\n\t\thifnstats.hst_opackets++;\n\t}\n\n\t/* clear the rings */\n\n\ti = dma->srck; u = dma->srcu;\n\twhile (u != 0 && (dma->srcr[i].l & HIFN_D_VALID) == 0) {\n\t\tif (++i == HIFN_D_SRC_RSIZE)\n\t\t\ti = 0;\n\t\tu--;\n\t}\n\tdma->srck = i; dma->srcu = u;\n\n\ti = dma->cmdk; u = dma->cmdu;\n\twhile (u != 0 && (dma->cmdr[i].l & HIFN_D_VALID) == 0) {\n\t\tif (++i == HIFN_D_CMD_RSIZE)\n\t\t\ti = 0;\n\t\tu--;\n\t}\n\tdma->cmdk = i; dma->cmdu = u;\n\n\t/*\n\t * Clear \"result done\" and \"command wait\" flags in status register.\n\t * If we still have slots to process and we received a \"command wait\"\n\t * interrupt, this will interupt us again.\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_R_DONE|HIFN_DMACSR_C_WAIT);\n\treturn (1);\n}"
  },
  {
    "function_name": "hifn_crypto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
    "lines": "823-999",
    "snippet": "int \nhifn_crypto(sc, cmd)\n\tstruct hifn_softc *sc;\n\tstruct hifn_command *cmd;\n{\n\tu_int32_t cmdlen;\n\tstruct\thifn_dma *dma = sc->sc_dma;\n\tint\tcmdi, srci, dsti, resi, nicealign = 0;\n\tint     s, i;\n\n\tif (cmd->src_npa == 0 && cmd->src_m)\n\t\tcmd->src_l = mbuf2pages(cmd->src_m, &cmd->src_npa,\n\t\t    cmd->src_packp, cmd->src_packl, MAX_SCATTER, &nicealign);\n\tif (cmd->src_l == 0)\n\t\treturn (-1);\n\n\tif (nicealign == 0) {\n\t\tint totlen, len;\n\t\tstruct mbuf *m, *top, **mp;\n\n\t\ttotlen = cmd->dst_l = cmd->src_l;\n\t\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\t\tM_COPY_PKTHDR(m, cmd->src_m);\n\t\tif (m == NULL)\n\t\t\treturn (-1);\n\t\tlen = MHLEN;\n\t\tif (totlen >= MINCLSIZE) {\n\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\tif (m->m_flags & M_EXT)\n\t\t\t\tlen = MCLBYTES;\n\t\t}\n\t\tm->m_len = len;\n\t\ttop = NULL;\n\t\tmp = &top;\n\n\t\twhile (totlen > 0) {\n\t\t\tif (top) {\n\t\t\t\tMGET(m, M_DONTWAIT, MT_DATA);\n\t\t\t\tif (m == NULL) {\n\t\t\t\t\tm_freem(top);\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t\tlen = MLEN;\n\t\t\t}\n\t\t\tif (top && totlen >= MINCLSIZE) {\n\t\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\t\tif (m->m_flags & M_EXT)\n\t\t\t\t\tlen = MCLBYTES;\n\t\t\t}\n\t\t\tm->m_len = len;\n\t\t\ttotlen -= len;\n\t\t\t*mp = m;\n\t\t\tmp = &m->m_next;\n\t\t}\n\t\tcmd->dst_m = top;\n\t}\n\telse\n\t\tcmd->dst_m = cmd->src_m;\n\n\tcmd->dst_l = mbuf2pages(cmd->dst_m, &cmd->dst_npa,\n\t    cmd->dst_packp, cmd->dst_packl, MAX_SCATTER, NULL);\n\tif (cmd->dst_l == 0)\n\t\treturn (-1);\n\n#ifdef HIFN_DEBUG\n\tprintf(\"%s: Entering cmd: stat %8x ien %8x u %d/%d/%d/%d n %d/%d\\n\",\n\t    sc->sc_dv.dv_xname,\n\t    READ_REG_1(sc, HIFN_1_DMA_CSR), READ_REG_1(sc, HIFN_1_DMA_IER),\n\t    dma->cmdu, dma->srcu, dma->dstu, dma->resu, cmd->src_npa,\n\t    cmd->dst_npa);\n#endif\n\n\ts = splnet();\n\n\t/*\n\t * need 1 cmd, and 1 res\n\t * need N src, and N dst\n\t */\n\tif (dma->cmdu+1 > HIFN_D_CMD_RSIZE ||\n\t    dma->srcu+cmd->src_npa > HIFN_D_SRC_RSIZE ||\n\t    dma->dstu+cmd->dst_npa > HIFN_D_DST_RSIZE ||\n\t    dma->resu+1 > HIFN_D_RES_RSIZE) {\n\t\t\tsplx(s);\n\t\t\treturn (HIFN_CRYPTO_RINGS_FULL);\n\t}\n\n\tif (dma->cmdi == HIFN_D_CMD_RSIZE) {\n\t\tdma->cmdi = 0;\n\t\tdma->cmdr[HIFN_D_CMD_RSIZE].l = HIFN_D_VALID | HIFN_D_LAST |\n\t\t    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP;\n\t}\n\tcmdi = dma->cmdi++;\n\n\tif (dma->resi == HIFN_D_RES_RSIZE) {\n\t\tdma->resi = 0;\n\t\tdma->resr[HIFN_D_RES_RSIZE].l = HIFN_D_VALID | HIFN_D_LAST |\n\t\t    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP;\n\t}\n\tresi = dma->resi++;\n\n\tcmdlen = hifn_write_command(cmd, dma->command_bufs[cmdi]);\n#ifdef HIFN_DEBUG\n\tprintf(\"write_command %d (nice %d)\\n\", cmdlen, nicealign);\n#endif\n\t/* .p for command/result already set */\n\tdma->cmdr[cmdi].l = cmdlen | HIFN_D_VALID | HIFN_D_LAST |\n\t    HIFN_D_MASKDONEIRQ;\n\tdma->cmdu++;\n\n\t/*\n\t * We don't worry about missing an interrupt (which a \"command wait\"\n\t * interrupt salvages us from), unless there is more than one command\n\t * in the queue.\n\t */\n\tif (dma->cmdu > 1)\n\t\tWRITE_REG_1(sc, HIFN_1_DMA_IER,\n\t\t    HIFN_DMAIER_C_WAIT | HIFN_DMAIER_R_DONE);\n\n\thifnstats.hst_ipackets++;\n\n\tfor (i = 0; i < cmd->src_npa; i++) {\n\t\tint last = 0;\n\n\t\tif (i == cmd->src_npa-1)\n\t\t\tlast = HIFN_D_LAST;\n\n\t\tif (dma->srci == HIFN_D_SRC_RSIZE) {\n\t\t\tsrci = 0, dma->srci = 1;\n\t\t\tdma->srcr[HIFN_D_SRC_RSIZE].l = HIFN_D_VALID |\n\t\t\t    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP | HIFN_D_LAST;\n\t\t} else\n\t\t\tsrci = dma->srci++;\n\t\tdma->srcr[srci].p = cmd->src_packp[i];\n\t\tdma->srcr[srci].l = cmd->src_packl[i] | HIFN_D_VALID |\n\t\t    HIFN_D_MASKDONEIRQ | last;\n\t\thifnstats.hst_ibytes += cmd->src_packl[i];\n\t}\n\tdma->srcu += cmd->src_npa;\n\n\tfor (i = 0; i < cmd->dst_npa; i++) {\n\t\tint last = 0;\n\n\t\tif (i == cmd->dst_npa-1)\n\t\t\tlast = HIFN_D_LAST;\n\n\t\tif (dma->dsti == HIFN_D_DST_RSIZE) {\n\t\t\tdsti = 0, dma->dsti = 1;\n\t\t\tdma->dstr[HIFN_D_DST_RSIZE].l = HIFN_D_VALID |\n\t\t\t    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP | HIFN_D_LAST;\n\t\t} else\n\t\t\tdsti = dma->dsti++;\n\t\tdma->dstr[dsti].p = cmd->dst_packp[i];\n\t\tdma->dstr[dsti].l = cmd->dst_packl[i] | HIFN_D_VALID |\n\t\t    HIFN_D_MASKDONEIRQ | last;\n\t}\n\tdma->dstu += cmd->dst_npa;\n\n\t/*\n\t * Unlike other descriptors, we don't mask done interrupt from\n\t * result descriptor.\n\t */\n#ifdef HIFN_DEBUG\n\tprintf(\"load res\\n\");\n#endif\n\tdma->hifn_commands[resi] = cmd;\n\tdma->resr[resi].l = HIFN_MAX_RESULT | HIFN_D_VALID | HIFN_D_LAST;\n\tdma->resu++;\n\n#ifdef HIFN_DEBUG\n\tprintf(\"%s: command: stat %8x ier %8x\\n\",\n\t    sc->sc_dv.dv_xname,\n\t    READ_REG_1(sc, HIFN_1_DMA_CSR), READ_REG_1(sc, HIFN_1_DMA_IER));\n#endif\n\n\tsplx(s);\n\treturn 0;\t\t/* success */\n}",
    "includes": [
      "#include <dev/pci/hifn7751reg.h>",
      "#include <dev/pci/hifn7751var.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/rndvar.h>",
      "#include <crypto/crypto.h>",
      "#include <sys/device.h>",
      "#include <machine/pmap.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_int\thifn_write_command",
      "int\thifn_crypto",
      "struct hifn_stats {\n\tu_int64_t hst_ibytes;\n\tu_int64_t hst_obytes;\n\tu_int32_t hst_ipackets;\n\tu_int32_t hst_opackets;\n\tu_int32_t hst_invalid;\n\tu_int32_t hst_nomem;\n} hifnstats;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: command: stat %8x ier %8x\\n\"",
            "sc->sc_dv.dv_xname",
            "READ_REG_1(sc, HIFN_1_DMA_CSR)",
            "READ_REG_1(sc, HIFN_1_DMA_IER)"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_IER"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_CSR"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_IER",
            "HIFN_DMAIER_C_WAIT | HIFN_DMAIER_R_DONE"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hifn_write_command",
          "args": [
            "cmd",
            "dma->command_bufs[cmdi]"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_write_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "760-821",
          "snippet": "u_int\nhifn_write_command(cmd, buf)\n\tstruct hifn_command *cmd;\n\tu_int8_t *buf;\n{\n\tu_int8_t *buf_pos;\n\thifn_base_command_t *base_cmd;\n\thifn_mac_command_t *mac_cmd;\n\thifn_crypt_command_t *cry_cmd;\n\tint using_mac, using_crypt, len;\n\n\tbuf_pos = buf;\n\tusing_mac = cmd->base_masks & HIFN_BASE_CMD_MAC;\n\tusing_crypt = cmd->base_masks & HIFN_BASE_CMD_CRYPT;\n\n\tbase_cmd = (hifn_base_command_t *)buf_pos;\n\tbase_cmd->masks = cmd->base_masks;\n\tbase_cmd->total_source_count = cmd->src_l;\n\tbase_cmd->total_dest_count = cmd->dst_l;\n\tbase_cmd->session_num = cmd->session_num;\n\tbuf_pos += sizeof(hifn_base_command_t);\n\n\tif (using_mac) {\n\t\tmac_cmd = (hifn_mac_command_t *)buf_pos;\n\t\tmac_cmd->masks = cmd->mac_masks;\n\t\tmac_cmd->header_skip = cmd->mac_header_skip;\n\t\tmac_cmd->source_count = cmd->mac_process_len;\n\t\tbuf_pos += sizeof(hifn_mac_command_t);\n\t}\n\n\tif (using_crypt) {\n\t\tcry_cmd = (hifn_crypt_command_t *)buf_pos;\n\t\tcry_cmd->masks = cmd->cry_masks;\n\t\tcry_cmd->header_skip = cmd->crypt_header_skip;\n\t\tcry_cmd->source_count = cmd->crypt_process_len;\n\t\tbuf_pos += sizeof(hifn_crypt_command_t);\n\t}\n\n\tif (using_mac && mac_cmd->masks & HIFN_MAC_CMD_NEW_KEY) {\n\t\tbcopy(cmd->mac, buf_pos, HIFN_MAC_KEY_LENGTH);\n\t\tbuf_pos += HIFN_MAC_KEY_LENGTH;\n\t}\n\n\tif (using_crypt && cry_cmd->masks & HIFN_CRYPT_CMD_NEW_KEY) {\n\t\tlen = (cry_cmd->masks & HIFN_CRYPT_CMD_ALG_3DES) ?\n\t\t    HIFN_3DES_KEY_LENGTH : HIFN_DES_KEY_LENGTH;\n\t\tbcopy(cmd->ck, buf_pos, len);\n\t\tbuf_pos += len;\n\t}\n\n\tif (using_crypt && cry_cmd->masks & HIFN_CRYPT_CMD_NEW_IV) {\n\t\tbcopy(cmd->iv, buf_pos, HIFN_IV_LENGTH);\n\t\tbuf_pos += HIFN_IV_LENGTH;\n\t}\n\n\tif ((base_cmd->masks & (HIFN_BASE_CMD_MAC | HIFN_BASE_CMD_CRYPT)) == 0) {\n\t\tbzero(buf_pos, 8);\n\t\tbuf_pos += 8;\n\t}\n\n\treturn (buf_pos - buf);\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_int\thifn_write_command"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int\thifn_write_command;\n\nu_int\nhifn_write_command(cmd, buf)\n\tstruct hifn_command *cmd;\n\tu_int8_t *buf;\n{\n\tu_int8_t *buf_pos;\n\thifn_base_command_t *base_cmd;\n\thifn_mac_command_t *mac_cmd;\n\thifn_crypt_command_t *cry_cmd;\n\tint using_mac, using_crypt, len;\n\n\tbuf_pos = buf;\n\tusing_mac = cmd->base_masks & HIFN_BASE_CMD_MAC;\n\tusing_crypt = cmd->base_masks & HIFN_BASE_CMD_CRYPT;\n\n\tbase_cmd = (hifn_base_command_t *)buf_pos;\n\tbase_cmd->masks = cmd->base_masks;\n\tbase_cmd->total_source_count = cmd->src_l;\n\tbase_cmd->total_dest_count = cmd->dst_l;\n\tbase_cmd->session_num = cmd->session_num;\n\tbuf_pos += sizeof(hifn_base_command_t);\n\n\tif (using_mac) {\n\t\tmac_cmd = (hifn_mac_command_t *)buf_pos;\n\t\tmac_cmd->masks = cmd->mac_masks;\n\t\tmac_cmd->header_skip = cmd->mac_header_skip;\n\t\tmac_cmd->source_count = cmd->mac_process_len;\n\t\tbuf_pos += sizeof(hifn_mac_command_t);\n\t}\n\n\tif (using_crypt) {\n\t\tcry_cmd = (hifn_crypt_command_t *)buf_pos;\n\t\tcry_cmd->masks = cmd->cry_masks;\n\t\tcry_cmd->header_skip = cmd->crypt_header_skip;\n\t\tcry_cmd->source_count = cmd->crypt_process_len;\n\t\tbuf_pos += sizeof(hifn_crypt_command_t);\n\t}\n\n\tif (using_mac && mac_cmd->masks & HIFN_MAC_CMD_NEW_KEY) {\n\t\tbcopy(cmd->mac, buf_pos, HIFN_MAC_KEY_LENGTH);\n\t\tbuf_pos += HIFN_MAC_KEY_LENGTH;\n\t}\n\n\tif (using_crypt && cry_cmd->masks & HIFN_CRYPT_CMD_NEW_KEY) {\n\t\tlen = (cry_cmd->masks & HIFN_CRYPT_CMD_ALG_3DES) ?\n\t\t    HIFN_3DES_KEY_LENGTH : HIFN_DES_KEY_LENGTH;\n\t\tbcopy(cmd->ck, buf_pos, len);\n\t\tbuf_pos += len;\n\t}\n\n\tif (using_crypt && cry_cmd->masks & HIFN_CRYPT_CMD_NEW_IV) {\n\t\tbcopy(cmd->iv, buf_pos, HIFN_IV_LENGTH);\n\t\tbuf_pos += HIFN_IV_LENGTH;\n\t}\n\n\tif ((base_cmd->masks & (HIFN_BASE_CMD_MAC | HIFN_BASE_CMD_CRYPT)) == 0) {\n\t\tbzero(buf_pos, 8);\n\t\tbuf_pos += 8;\n\t}\n\n\treturn (buf_pos - buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_IER"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_CSR"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mbuf2pages",
          "args": [
            "cmd->dst_m",
            "&cmd->dst_npa",
            "cmd->dst_packp",
            "cmd->dst_packl",
            "MAX_SCATTER",
            "NULL"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m",
            "M_DONTWAIT"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "top"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGET",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m",
            "M_DONTWAIT"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_COPY_PKTHDR",
          "args": [
            "m",
            "cmd->src_m"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mbuf2pages",
          "args": [
            "cmd->src_m",
            "&cmd->src_npa",
            "cmd->src_packp",
            "cmd->src_packl",
            "MAX_SCATTER",
            "&nicealign"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int\thifn_write_command;\nint\thifn_crypto;\nstruct hifn_stats {\n\tu_int64_t hst_ibytes;\n\tu_int64_t hst_obytes;\n\tu_int32_t hst_ipackets;\n\tu_int32_t hst_opackets;\n\tu_int32_t hst_invalid;\n\tu_int32_t hst_nomem;\n} hifnstats;\n\nint \nhifn_crypto(sc, cmd)\n\tstruct hifn_softc *sc;\n\tstruct hifn_command *cmd;\n{\n\tu_int32_t cmdlen;\n\tstruct\thifn_dma *dma = sc->sc_dma;\n\tint\tcmdi, srci, dsti, resi, nicealign = 0;\n\tint     s, i;\n\n\tif (cmd->src_npa == 0 && cmd->src_m)\n\t\tcmd->src_l = mbuf2pages(cmd->src_m, &cmd->src_npa,\n\t\t    cmd->src_packp, cmd->src_packl, MAX_SCATTER, &nicealign);\n\tif (cmd->src_l == 0)\n\t\treturn (-1);\n\n\tif (nicealign == 0) {\n\t\tint totlen, len;\n\t\tstruct mbuf *m, *top, **mp;\n\n\t\ttotlen = cmd->dst_l = cmd->src_l;\n\t\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\t\tM_COPY_PKTHDR(m, cmd->src_m);\n\t\tif (m == NULL)\n\t\t\treturn (-1);\n\t\tlen = MHLEN;\n\t\tif (totlen >= MINCLSIZE) {\n\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\tif (m->m_flags & M_EXT)\n\t\t\t\tlen = MCLBYTES;\n\t\t}\n\t\tm->m_len = len;\n\t\ttop = NULL;\n\t\tmp = &top;\n\n\t\twhile (totlen > 0) {\n\t\t\tif (top) {\n\t\t\t\tMGET(m, M_DONTWAIT, MT_DATA);\n\t\t\t\tif (m == NULL) {\n\t\t\t\t\tm_freem(top);\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t\tlen = MLEN;\n\t\t\t}\n\t\t\tif (top && totlen >= MINCLSIZE) {\n\t\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\t\tif (m->m_flags & M_EXT)\n\t\t\t\t\tlen = MCLBYTES;\n\t\t\t}\n\t\t\tm->m_len = len;\n\t\t\ttotlen -= len;\n\t\t\t*mp = m;\n\t\t\tmp = &m->m_next;\n\t\t}\n\t\tcmd->dst_m = top;\n\t}\n\telse\n\t\tcmd->dst_m = cmd->src_m;\n\n\tcmd->dst_l = mbuf2pages(cmd->dst_m, &cmd->dst_npa,\n\t    cmd->dst_packp, cmd->dst_packl, MAX_SCATTER, NULL);\n\tif (cmd->dst_l == 0)\n\t\treturn (-1);\n\n#ifdef HIFN_DEBUG\n\tprintf(\"%s: Entering cmd: stat %8x ien %8x u %d/%d/%d/%d n %d/%d\\n\",\n\t    sc->sc_dv.dv_xname,\n\t    READ_REG_1(sc, HIFN_1_DMA_CSR), READ_REG_1(sc, HIFN_1_DMA_IER),\n\t    dma->cmdu, dma->srcu, dma->dstu, dma->resu, cmd->src_npa,\n\t    cmd->dst_npa);\n#endif\n\n\ts = splnet();\n\n\t/*\n\t * need 1 cmd, and 1 res\n\t * need N src, and N dst\n\t */\n\tif (dma->cmdu+1 > HIFN_D_CMD_RSIZE ||\n\t    dma->srcu+cmd->src_npa > HIFN_D_SRC_RSIZE ||\n\t    dma->dstu+cmd->dst_npa > HIFN_D_DST_RSIZE ||\n\t    dma->resu+1 > HIFN_D_RES_RSIZE) {\n\t\t\tsplx(s);\n\t\t\treturn (HIFN_CRYPTO_RINGS_FULL);\n\t}\n\n\tif (dma->cmdi == HIFN_D_CMD_RSIZE) {\n\t\tdma->cmdi = 0;\n\t\tdma->cmdr[HIFN_D_CMD_RSIZE].l = HIFN_D_VALID | HIFN_D_LAST |\n\t\t    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP;\n\t}\n\tcmdi = dma->cmdi++;\n\n\tif (dma->resi == HIFN_D_RES_RSIZE) {\n\t\tdma->resi = 0;\n\t\tdma->resr[HIFN_D_RES_RSIZE].l = HIFN_D_VALID | HIFN_D_LAST |\n\t\t    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP;\n\t}\n\tresi = dma->resi++;\n\n\tcmdlen = hifn_write_command(cmd, dma->command_bufs[cmdi]);\n#ifdef HIFN_DEBUG\n\tprintf(\"write_command %d (nice %d)\\n\", cmdlen, nicealign);\n#endif\n\t/* .p for command/result already set */\n\tdma->cmdr[cmdi].l = cmdlen | HIFN_D_VALID | HIFN_D_LAST |\n\t    HIFN_D_MASKDONEIRQ;\n\tdma->cmdu++;\n\n\t/*\n\t * We don't worry about missing an interrupt (which a \"command wait\"\n\t * interrupt salvages us from), unless there is more than one command\n\t * in the queue.\n\t */\n\tif (dma->cmdu > 1)\n\t\tWRITE_REG_1(sc, HIFN_1_DMA_IER,\n\t\t    HIFN_DMAIER_C_WAIT | HIFN_DMAIER_R_DONE);\n\n\thifnstats.hst_ipackets++;\n\n\tfor (i = 0; i < cmd->src_npa; i++) {\n\t\tint last = 0;\n\n\t\tif (i == cmd->src_npa-1)\n\t\t\tlast = HIFN_D_LAST;\n\n\t\tif (dma->srci == HIFN_D_SRC_RSIZE) {\n\t\t\tsrci = 0, dma->srci = 1;\n\t\t\tdma->srcr[HIFN_D_SRC_RSIZE].l = HIFN_D_VALID |\n\t\t\t    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP | HIFN_D_LAST;\n\t\t} else\n\t\t\tsrci = dma->srci++;\n\t\tdma->srcr[srci].p = cmd->src_packp[i];\n\t\tdma->srcr[srci].l = cmd->src_packl[i] | HIFN_D_VALID |\n\t\t    HIFN_D_MASKDONEIRQ | last;\n\t\thifnstats.hst_ibytes += cmd->src_packl[i];\n\t}\n\tdma->srcu += cmd->src_npa;\n\n\tfor (i = 0; i < cmd->dst_npa; i++) {\n\t\tint last = 0;\n\n\t\tif (i == cmd->dst_npa-1)\n\t\t\tlast = HIFN_D_LAST;\n\n\t\tif (dma->dsti == HIFN_D_DST_RSIZE) {\n\t\t\tdsti = 0, dma->dsti = 1;\n\t\t\tdma->dstr[HIFN_D_DST_RSIZE].l = HIFN_D_VALID |\n\t\t\t    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP | HIFN_D_LAST;\n\t\t} else\n\t\t\tdsti = dma->dsti++;\n\t\tdma->dstr[dsti].p = cmd->dst_packp[i];\n\t\tdma->dstr[dsti].l = cmd->dst_packl[i] | HIFN_D_VALID |\n\t\t    HIFN_D_MASKDONEIRQ | last;\n\t}\n\tdma->dstu += cmd->dst_npa;\n\n\t/*\n\t * Unlike other descriptors, we don't mask done interrupt from\n\t * result descriptor.\n\t */\n#ifdef HIFN_DEBUG\n\tprintf(\"load res\\n\");\n#endif\n\tdma->hifn_commands[resi] = cmd;\n\tdma->resr[resi].l = HIFN_MAX_RESULT | HIFN_D_VALID | HIFN_D_LAST;\n\tdma->resu++;\n\n#ifdef HIFN_DEBUG\n\tprintf(\"%s: command: stat %8x ier %8x\\n\",\n\t    sc->sc_dv.dv_xname,\n\t    READ_REG_1(sc, HIFN_1_DMA_CSR), READ_REG_1(sc, HIFN_1_DMA_IER));\n#endif\n\n\tsplx(s);\n\treturn 0;\t\t/* success */\n}"
  },
  {
    "function_name": "hifn_write_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
    "lines": "760-821",
    "snippet": "u_int\nhifn_write_command(cmd, buf)\n\tstruct hifn_command *cmd;\n\tu_int8_t *buf;\n{\n\tu_int8_t *buf_pos;\n\thifn_base_command_t *base_cmd;\n\thifn_mac_command_t *mac_cmd;\n\thifn_crypt_command_t *cry_cmd;\n\tint using_mac, using_crypt, len;\n\n\tbuf_pos = buf;\n\tusing_mac = cmd->base_masks & HIFN_BASE_CMD_MAC;\n\tusing_crypt = cmd->base_masks & HIFN_BASE_CMD_CRYPT;\n\n\tbase_cmd = (hifn_base_command_t *)buf_pos;\n\tbase_cmd->masks = cmd->base_masks;\n\tbase_cmd->total_source_count = cmd->src_l;\n\tbase_cmd->total_dest_count = cmd->dst_l;\n\tbase_cmd->session_num = cmd->session_num;\n\tbuf_pos += sizeof(hifn_base_command_t);\n\n\tif (using_mac) {\n\t\tmac_cmd = (hifn_mac_command_t *)buf_pos;\n\t\tmac_cmd->masks = cmd->mac_masks;\n\t\tmac_cmd->header_skip = cmd->mac_header_skip;\n\t\tmac_cmd->source_count = cmd->mac_process_len;\n\t\tbuf_pos += sizeof(hifn_mac_command_t);\n\t}\n\n\tif (using_crypt) {\n\t\tcry_cmd = (hifn_crypt_command_t *)buf_pos;\n\t\tcry_cmd->masks = cmd->cry_masks;\n\t\tcry_cmd->header_skip = cmd->crypt_header_skip;\n\t\tcry_cmd->source_count = cmd->crypt_process_len;\n\t\tbuf_pos += sizeof(hifn_crypt_command_t);\n\t}\n\n\tif (using_mac && mac_cmd->masks & HIFN_MAC_CMD_NEW_KEY) {\n\t\tbcopy(cmd->mac, buf_pos, HIFN_MAC_KEY_LENGTH);\n\t\tbuf_pos += HIFN_MAC_KEY_LENGTH;\n\t}\n\n\tif (using_crypt && cry_cmd->masks & HIFN_CRYPT_CMD_NEW_KEY) {\n\t\tlen = (cry_cmd->masks & HIFN_CRYPT_CMD_ALG_3DES) ?\n\t\t    HIFN_3DES_KEY_LENGTH : HIFN_DES_KEY_LENGTH;\n\t\tbcopy(cmd->ck, buf_pos, len);\n\t\tbuf_pos += len;\n\t}\n\n\tif (using_crypt && cry_cmd->masks & HIFN_CRYPT_CMD_NEW_IV) {\n\t\tbcopy(cmd->iv, buf_pos, HIFN_IV_LENGTH);\n\t\tbuf_pos += HIFN_IV_LENGTH;\n\t}\n\n\tif ((base_cmd->masks & (HIFN_BASE_CMD_MAC | HIFN_BASE_CMD_CRYPT)) == 0) {\n\t\tbzero(buf_pos, 8);\n\t\tbuf_pos += 8;\n\t}\n\n\treturn (buf_pos - buf);\n}",
    "includes": [
      "#include <dev/pci/hifn7751reg.h>",
      "#include <dev/pci/hifn7751var.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/rndvar.h>",
      "#include <crypto/crypto.h>",
      "#include <sys/device.h>",
      "#include <machine/pmap.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_int\thifn_write_command"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "buf_pos",
            "8"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "cmd->iv",
            "buf_pos",
            "HIFN_IV_LENGTH"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int\thifn_write_command;\n\nu_int\nhifn_write_command(cmd, buf)\n\tstruct hifn_command *cmd;\n\tu_int8_t *buf;\n{\n\tu_int8_t *buf_pos;\n\thifn_base_command_t *base_cmd;\n\thifn_mac_command_t *mac_cmd;\n\thifn_crypt_command_t *cry_cmd;\n\tint using_mac, using_crypt, len;\n\n\tbuf_pos = buf;\n\tusing_mac = cmd->base_masks & HIFN_BASE_CMD_MAC;\n\tusing_crypt = cmd->base_masks & HIFN_BASE_CMD_CRYPT;\n\n\tbase_cmd = (hifn_base_command_t *)buf_pos;\n\tbase_cmd->masks = cmd->base_masks;\n\tbase_cmd->total_source_count = cmd->src_l;\n\tbase_cmd->total_dest_count = cmd->dst_l;\n\tbase_cmd->session_num = cmd->session_num;\n\tbuf_pos += sizeof(hifn_base_command_t);\n\n\tif (using_mac) {\n\t\tmac_cmd = (hifn_mac_command_t *)buf_pos;\n\t\tmac_cmd->masks = cmd->mac_masks;\n\t\tmac_cmd->header_skip = cmd->mac_header_skip;\n\t\tmac_cmd->source_count = cmd->mac_process_len;\n\t\tbuf_pos += sizeof(hifn_mac_command_t);\n\t}\n\n\tif (using_crypt) {\n\t\tcry_cmd = (hifn_crypt_command_t *)buf_pos;\n\t\tcry_cmd->masks = cmd->cry_masks;\n\t\tcry_cmd->header_skip = cmd->crypt_header_skip;\n\t\tcry_cmd->source_count = cmd->crypt_process_len;\n\t\tbuf_pos += sizeof(hifn_crypt_command_t);\n\t}\n\n\tif (using_mac && mac_cmd->masks & HIFN_MAC_CMD_NEW_KEY) {\n\t\tbcopy(cmd->mac, buf_pos, HIFN_MAC_KEY_LENGTH);\n\t\tbuf_pos += HIFN_MAC_KEY_LENGTH;\n\t}\n\n\tif (using_crypt && cry_cmd->masks & HIFN_CRYPT_CMD_NEW_KEY) {\n\t\tlen = (cry_cmd->masks & HIFN_CRYPT_CMD_ALG_3DES) ?\n\t\t    HIFN_3DES_KEY_LENGTH : HIFN_DES_KEY_LENGTH;\n\t\tbcopy(cmd->ck, buf_pos, len);\n\t\tbuf_pos += len;\n\t}\n\n\tif (using_crypt && cry_cmd->masks & HIFN_CRYPT_CMD_NEW_IV) {\n\t\tbcopy(cmd->iv, buf_pos, HIFN_IV_LENGTH);\n\t\tbuf_pos += HIFN_IV_LENGTH;\n\t}\n\n\tif ((base_cmd->masks & (HIFN_BASE_CMD_MAC | HIFN_BASE_CMD_CRYPT)) == 0) {\n\t\tbzero(buf_pos, 8);\n\t\tbuf_pos += 8;\n\t}\n\n\treturn (buf_pos - buf);\n}"
  },
  {
    "function_name": "hifn_init_dma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
    "lines": "734-754",
    "snippet": "void \nhifn_init_dma(sc)\n\tstruct hifn_softc *sc;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\tint i;\n\n\t/* initialize static pointer values */\n\tfor (i = 0; i < HIFN_D_CMD_RSIZE; i++)\n\t\tdma->cmdr[i].p = vtophys(dma->command_bufs[i]);\n\tfor (i = 0; i < HIFN_D_RES_RSIZE; i++)\n\t\tdma->resr[i].p = vtophys(dma->result_bufs[i]);\n\n\tdma->cmdr[HIFN_D_CMD_RSIZE].p = vtophys(dma->cmdr);\n\tdma->srcr[HIFN_D_SRC_RSIZE].p = vtophys(dma->srcr);\n\tdma->dstr[HIFN_D_DST_RSIZE].p = vtophys(dma->dstr);\n\tdma->resr[HIFN_D_RES_RSIZE].p = vtophys(dma->resr);\n\tdma->cmdu = dma->srcu = dma->dstu = dma->resu = 0;\n\tdma->cmdi = dma->srci = dma->dsti = dma->resi = 0;\n\tdma->cmdk = dma->srck = dma->dstk = dma->resk = 0;\n}",
    "includes": [
      "#include <dev/pci/hifn7751reg.h>",
      "#include <dev/pci/hifn7751var.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/rndvar.h>",
      "#include <crypto/crypto.h>",
      "#include <sys/device.h>",
      "#include <machine/pmap.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\thifn_init_dma"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "dma->resr"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "dma->dstr"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "dma->srcr"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "dma->cmdr"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "dma->result_bufs[i]"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "dma->command_bufs[i]"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\thifn_init_dma;\n\nvoid \nhifn_init_dma(sc)\n\tstruct hifn_softc *sc;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\tint i;\n\n\t/* initialize static pointer values */\n\tfor (i = 0; i < HIFN_D_CMD_RSIZE; i++)\n\t\tdma->cmdr[i].p = vtophys(dma->command_bufs[i]);\n\tfor (i = 0; i < HIFN_D_RES_RSIZE; i++)\n\t\tdma->resr[i].p = vtophys(dma->result_bufs[i]);\n\n\tdma->cmdr[HIFN_D_CMD_RSIZE].p = vtophys(dma->cmdr);\n\tdma->srcr[HIFN_D_SRC_RSIZE].p = vtophys(dma->srcr);\n\tdma->dstr[HIFN_D_DST_RSIZE].p = vtophys(dma->dstr);\n\tdma->resr[HIFN_D_RES_RSIZE].p = vtophys(dma->resr);\n\tdma->cmdu = dma->srcu = dma->dstu = dma->resu = 0;\n\tdma->cmdi = dma->srci = dma->dsti = dma->resi = 0;\n\tdma->cmdk = dma->srck = dma->dstk = dma->resk = 0;\n}"
  },
  {
    "function_name": "hifn_readramaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
    "lines": "696-729",
    "snippet": "int\nhifn_readramaddr(sc, addr, data, slot)\n\tstruct hifn_softc *sc;\n\tint addr, slot;\n\tu_int8_t *data;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\thifn_base_command_t rc;\n\tconst u_int32_t masks = HIFN_D_VALID | HIFN_D_LAST | HIFN_D_MASKDONEIRQ;\n\tu_int64_t src, dst;\n\n\trc.masks = 2 << 13;\n\trc.session_num = addr >> 14;\n\trc.total_source_count = addr & 0x3fff;\n\trc.total_dest_count = 8;\n\n\t*(hifn_base_command_t *) sc->sc_dma->command_bufs[slot] = rc;\n\n\tdma->srcr[slot].p = vtophys(&src);\n\tdma->dstr[slot].p = vtophys(&dst);\n\tdma->cmdr[slot].l = 16 | masks;\n\tdma->srcr[slot].l = 8 | masks;\n\tdma->dstr[slot].l = 8 | masks;\n\tdma->resr[slot].l = HIFN_MAX_RESULT | masks;\n\n\tDELAY(1000);\t/* let read command execute */\n\tif (dma->resr[slot].l & HIFN_D_VALID) {\n\t\tprintf(\"%s: SRAM/DRAM detection error -- \"\n\t\t    \"result[%d] valid still set\\n\", sc->sc_dv.dv_xname, slot);\n\t\treturn (-1);\n\t}\n\tbcopy(&dst, data, sizeof(dst));\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/hifn7751reg.h>",
      "#include <dev/pci/hifn7751var.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/rndvar.h>",
      "#include <crypto/crypto.h>",
      "#include <sys/device.h>",
      "#include <machine/pmap.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\thifn_readramaddr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "&dst",
            "data",
            "sizeof(dst)"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: SRAM/DRAM detection error -- \"\n\t\t    \"result[%d] valid still set\\n\"",
            "sc->sc_dv.dv_xname",
            "slot"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&dst"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&src"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\thifn_readramaddr;\n\nint\nhifn_readramaddr(sc, addr, data, slot)\n\tstruct hifn_softc *sc;\n\tint addr, slot;\n\tu_int8_t *data;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\thifn_base_command_t rc;\n\tconst u_int32_t masks = HIFN_D_VALID | HIFN_D_LAST | HIFN_D_MASKDONEIRQ;\n\tu_int64_t src, dst;\n\n\trc.masks = 2 << 13;\n\trc.session_num = addr >> 14;\n\trc.total_source_count = addr & 0x3fff;\n\trc.total_dest_count = 8;\n\n\t*(hifn_base_command_t *) sc->sc_dma->command_bufs[slot] = rc;\n\n\tdma->srcr[slot].p = vtophys(&src);\n\tdma->dstr[slot].p = vtophys(&dst);\n\tdma->cmdr[slot].l = 16 | masks;\n\tdma->srcr[slot].l = 8 | masks;\n\tdma->dstr[slot].l = 8 | masks;\n\tdma->resr[slot].l = HIFN_MAX_RESULT | masks;\n\n\tDELAY(1000);\t/* let read command execute */\n\tif (dma->resr[slot].l & HIFN_D_VALID) {\n\t\tprintf(\"%s: SRAM/DRAM detection error -- \"\n\t\t    \"result[%d] valid still set\\n\", sc->sc_dv.dv_xname, slot);\n\t\treturn (-1);\n\t}\n\tbcopy(&dst, data, sizeof(dst));\n\treturn (0);\n}"
  },
  {
    "function_name": "hifn_writeramaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
    "lines": "659-694",
    "snippet": "int\nhifn_writeramaddr(sc, addr, data, slot)\n\tstruct hifn_softc *sc;\n\tint addr, slot;\n\tu_int8_t *data;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\thifn_base_command_t wc;\n\tconst u_int32_t masks = HIFN_D_VALID | HIFN_D_LAST | HIFN_D_MASKDONEIRQ;\n\tu_int64_t src, dst;\n\n\twc.masks = 3 << 13;\n\twc.session_num = addr >> 14;\n\twc.total_source_count = 8;\n\twc.total_dest_count = addr & 0x3fff;;\n\n\t/* build write command */\n\t*(hifn_base_command_t *) sc->sc_dma->command_bufs[slot] = wc;\n\tbcopy(data, &src, sizeof(src));\n\n\tdma->srcr[slot].p = vtophys(&src);\n\tdma->dstr[slot].p = vtophys(&dst);\n\n\tdma->cmdr[slot].l = 16 | masks;\n\tdma->srcr[slot].l = 8 | masks;\n\tdma->dstr[slot].l = 8 | masks;\n\tdma->resr[slot].l = HIFN_MAX_RESULT | masks;\n\n\tDELAY(1000);\t/* let write command execute */\n\tif (dma->resr[slot].l & HIFN_D_VALID) {\n\t\tprintf(\"%s: SRAM/DRAM detection error -- \"\n\t\t    \"result[%d] valid still set\\n\", sc->sc_dv.dv_xname, slot);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/hifn7751reg.h>",
      "#include <dev/pci/hifn7751var.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/rndvar.h>",
      "#include <crypto/crypto.h>",
      "#include <sys/device.h>",
      "#include <machine/pmap.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\thifn_writeramaddr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: SRAM/DRAM detection error -- \"\n\t\t    \"result[%d] valid still set\\n\"",
            "sc->sc_dv.dv_xname",
            "slot"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&dst"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&src"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "data",
            "&src",
            "sizeof(src)"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\thifn_writeramaddr;\n\nint\nhifn_writeramaddr(sc, addr, data, slot)\n\tstruct hifn_softc *sc;\n\tint addr, slot;\n\tu_int8_t *data;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\thifn_base_command_t wc;\n\tconst u_int32_t masks = HIFN_D_VALID | HIFN_D_LAST | HIFN_D_MASKDONEIRQ;\n\tu_int64_t src, dst;\n\n\twc.masks = 3 << 13;\n\twc.session_num = addr >> 14;\n\twc.total_source_count = 8;\n\twc.total_dest_count = addr & 0x3fff;;\n\n\t/* build write command */\n\t*(hifn_base_command_t *) sc->sc_dma->command_bufs[slot] = wc;\n\tbcopy(data, &src, sizeof(src));\n\n\tdma->srcr[slot].p = vtophys(&src);\n\tdma->dstr[slot].p = vtophys(&dst);\n\n\tdma->cmdr[slot].l = 16 | masks;\n\tdma->srcr[slot].l = 8 | masks;\n\tdma->dstr[slot].l = 8 | masks;\n\tdma->resr[slot].l = HIFN_MAX_RESULT | masks;\n\n\tDELAY(1000);\t/* let write command execute */\n\tif (dma->resr[slot].l & HIFN_D_VALID) {\n\t\tprintf(\"%s: SRAM/DRAM detection error -- \"\n\t\t    \"result[%d] valid still set\\n\", sc->sc_dv.dv_xname, slot);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "hifn_dramsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
    "lines": "647-657",
    "snippet": "int\nhifn_dramsize(sc)\n\tstruct hifn_softc *sc;\n{\n\tu_int32_t cnfg;\n\n\tcnfg = READ_REG_0(sc, HIFN_0_PUCNFG) &\n\t    HIFN_PUCNFG_DRAMMASK;\n\tsc->sc_ramsize = 1 << ((cnfg >> 13) + 18);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/hifn7751reg.h>",
      "#include <dev/pci/hifn7751var.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/rndvar.h>",
      "#include <crypto/crypto.h>",
      "#include <sys/device.h>",
      "#include <machine/pmap.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\thifn_dramsize"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_REG_0",
          "args": [
            "sc",
            "HIFN_0_PUCNFG"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\thifn_dramsize;\n\nint\nhifn_dramsize(sc)\n\tstruct hifn_softc *sc;\n{\n\tu_int32_t cnfg;\n\n\tcnfg = READ_REG_0(sc, HIFN_0_PUCNFG) &\n\t    HIFN_PUCNFG_DRAMMASK;\n\tsc->sc_ramsize = 1 << ((cnfg >> 13) + 18);\n\treturn (0);\n}"
  },
  {
    "function_name": "hifn_sramsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
    "lines": "591-640",
    "snippet": "int\nhifn_sramsize(sc)\n\tstruct hifn_softc *sc;\n{\n\tu_int32_t a = 0, end;\n\tu_int8_t data[8], dataexpect[8];\n\n\tfor (a = 0; a < sizeof(data); a++)\n\t\tdata[a] = dataexpect[a] = 0x5a;\n\n\thifn_reset_board(sc);\n\thifn_init_dma(sc);\n\thifn_init_pci_registers(sc);\n\tend = 1 << 20;\t/* 1MB */\n\tfor (a = 0; a < end; a += 16384) {\n\t\tif (hifn_writeramaddr(sc, a, data, 0) < 0)\n\t\t\treturn (0);\n\t\tif (hifn_readramaddr(sc, a, data, 1) < 0)\n\t\t\treturn (0);\n\t\tif (bcmp(data, dataexpect, sizeof(data)) != 0)\n\t\t\treturn (0);\n\t\thifn_reset_board(sc);\n\t\thifn_init_dma(sc);\n\t\thifn_init_pci_registers(sc);\n\t\tsc->sc_ramsize = a + 16384;\n\t}\n\n\tfor (a = 0; a < sizeof(data); a++)\n\t\tdata[a] = dataexpect[a] = 0xa5;\n\tif (hifn_writeramaddr(sc, 0, data, 0) < 0)\n\t\treturn (0);\n\n\tend = sc->sc_ramsize;\n\tfor (a = 0; a < end; a += 16384) {\n\t\thifn_reset_board(sc);\n\t\thifn_init_dma(sc);\n\t\thifn_init_pci_registers(sc);\n\t\tif (hifn_readramaddr(sc, a, data, 0) < 0)\n\t\t\treturn (0);\n\t\tif (a != 0 && bcmp(data, dataexpect, sizeof(data)) == 0)\n\t\t\treturn (0);\n\t\tsc->sc_ramsize = a + 16384;\n\t}\n\n\thifn_reset_board(sc);\n\thifn_init_dma(sc);\n\thifn_init_pci_registers(sc);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/hifn7751reg.h>",
      "#include <dev/pci/hifn7751var.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/rndvar.h>",
      "#include <crypto/crypto.h>",
      "#include <sys/device.h>",
      "#include <machine/pmap.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\thifn_reset_board",
      "void\thifn_init_dma",
      "void\thifn_init_pci_registers",
      "int\thifn_sramsize",
      "int\thifn_readramaddr",
      "int\thifn_writeramaddr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hifn_init_pci_registers",
          "args": [
            "sc"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_init_pci_registers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "482-518",
          "snippet": "void \nhifn_init_pci_registers(sc)\n\tstruct hifn_softc *sc;\n{\n\t/* write fixed values needed by the Initialization registers */\n\tWRITE_REG_0(sc, HIFN_0_PUCTRL, HIFN_PUCTRL_DMAENA);\n\tWRITE_REG_0(sc, HIFN_0_FIFOCNFG, HIFN_FIFOCNFG_THRESHOLD);\n\tWRITE_REG_0(sc, HIFN_0_PUIER, HIFN_PUIER_DSTOVER);\n\n\t/* write all 4 ring address registers */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CRAR, vtophys(sc->sc_dma->cmdr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_SRAR, vtophys(sc->sc_dma->srcr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_DRAR, vtophys(sc->sc_dma->dstr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_RRAR, vtophys(sc->sc_dma->resr));\n\n\t/* write status register */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_D_CTRL_ENA |\n\t    HIFN_DMACSR_R_CTRL_ENA | HIFN_DMACSR_S_CTRL_ENA |\n\t    HIFN_DMACSR_C_CTRL_ENA);\n\tWRITE_REG_1(sc, HIFN_1_DMA_IER, HIFN_DMAIER_R_DONE);\n\n#if 0\n#if BYTE_ORDER == BIG_ENDIAN\n\t    (0x1 << 7) |\n#endif\n#endif\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG, HIFN_PUCNFG_COMPSING |\n\t    HIFN_PUCNFG_DRFR_128 | HIFN_PUCNFG_TCALLPHASES |\n\t    HIFN_PUCNFG_TCDRVTOTEM | HIFN_PUCNFG_BUS32 |\n\t    (sc->sc_drammodel ? HIFN_PUCNFG_DRAM : HIFN_PUCNFG_SRAM));\n\n\tWRITE_REG_0(sc, HIFN_0_PUISR, HIFN_PUISR_DSTOVER);\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE | HIFN_DMACNFG_LAST |\n\t    ((HIFN_POLL_FREQUENCY << 16 ) & HIFN_DMACNFG_POLLFREQ) |\n\t    ((HIFN_POLL_SCALAR << 8) & HIFN_DMACNFG_POLLINVAL));\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\thifn_init_pci_registers"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\thifn_init_pci_registers;\n\nvoid \nhifn_init_pci_registers(sc)\n\tstruct hifn_softc *sc;\n{\n\t/* write fixed values needed by the Initialization registers */\n\tWRITE_REG_0(sc, HIFN_0_PUCTRL, HIFN_PUCTRL_DMAENA);\n\tWRITE_REG_0(sc, HIFN_0_FIFOCNFG, HIFN_FIFOCNFG_THRESHOLD);\n\tWRITE_REG_0(sc, HIFN_0_PUIER, HIFN_PUIER_DSTOVER);\n\n\t/* write all 4 ring address registers */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CRAR, vtophys(sc->sc_dma->cmdr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_SRAR, vtophys(sc->sc_dma->srcr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_DRAR, vtophys(sc->sc_dma->dstr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_RRAR, vtophys(sc->sc_dma->resr));\n\n\t/* write status register */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_D_CTRL_ENA |\n\t    HIFN_DMACSR_R_CTRL_ENA | HIFN_DMACSR_S_CTRL_ENA |\n\t    HIFN_DMACSR_C_CTRL_ENA);\n\tWRITE_REG_1(sc, HIFN_1_DMA_IER, HIFN_DMAIER_R_DONE);\n\n#if 0\n#if BYTE_ORDER == BIG_ENDIAN\n\t    (0x1 << 7) |\n#endif\n#endif\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG, HIFN_PUCNFG_COMPSING |\n\t    HIFN_PUCNFG_DRFR_128 | HIFN_PUCNFG_TCALLPHASES |\n\t    HIFN_PUCNFG_TCDRVTOTEM | HIFN_PUCNFG_BUS32 |\n\t    (sc->sc_drammodel ? HIFN_PUCNFG_DRAM : HIFN_PUCNFG_SRAM));\n\n\tWRITE_REG_0(sc, HIFN_0_PUISR, HIFN_PUISR_DSTOVER);\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE | HIFN_DMACNFG_LAST |\n\t    ((HIFN_POLL_FREQUENCY << 16 ) & HIFN_DMACNFG_POLLFREQ) |\n\t    ((HIFN_POLL_SCALAR << 8) & HIFN_DMACNFG_POLLINVAL));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hifn_init_dma",
          "args": [
            "sc"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_init_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "734-754",
          "snippet": "void \nhifn_init_dma(sc)\n\tstruct hifn_softc *sc;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\tint i;\n\n\t/* initialize static pointer values */\n\tfor (i = 0; i < HIFN_D_CMD_RSIZE; i++)\n\t\tdma->cmdr[i].p = vtophys(dma->command_bufs[i]);\n\tfor (i = 0; i < HIFN_D_RES_RSIZE; i++)\n\t\tdma->resr[i].p = vtophys(dma->result_bufs[i]);\n\n\tdma->cmdr[HIFN_D_CMD_RSIZE].p = vtophys(dma->cmdr);\n\tdma->srcr[HIFN_D_SRC_RSIZE].p = vtophys(dma->srcr);\n\tdma->dstr[HIFN_D_DST_RSIZE].p = vtophys(dma->dstr);\n\tdma->resr[HIFN_D_RES_RSIZE].p = vtophys(dma->resr);\n\tdma->cmdu = dma->srcu = dma->dstu = dma->resu = 0;\n\tdma->cmdi = dma->srci = dma->dsti = dma->resi = 0;\n\tdma->cmdk = dma->srck = dma->dstk = dma->resk = 0;\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\thifn_init_dma"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\thifn_init_dma;\n\nvoid \nhifn_init_dma(sc)\n\tstruct hifn_softc *sc;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\tint i;\n\n\t/* initialize static pointer values */\n\tfor (i = 0; i < HIFN_D_CMD_RSIZE; i++)\n\t\tdma->cmdr[i].p = vtophys(dma->command_bufs[i]);\n\tfor (i = 0; i < HIFN_D_RES_RSIZE; i++)\n\t\tdma->resr[i].p = vtophys(dma->result_bufs[i]);\n\n\tdma->cmdr[HIFN_D_CMD_RSIZE].p = vtophys(dma->cmdr);\n\tdma->srcr[HIFN_D_SRC_RSIZE].p = vtophys(dma->srcr);\n\tdma->dstr[HIFN_D_DST_RSIZE].p = vtophys(dma->dstr);\n\tdma->resr[HIFN_D_RES_RSIZE].p = vtophys(dma->resr);\n\tdma->cmdu = dma->srcu = dma->dstu = dma->resu = 0;\n\tdma->cmdi = dma->srci = dma->dsti = dma->resi = 0;\n\tdma->cmdk = dma->srck = dma->dstk = dma->resk = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hifn_reset_board",
          "args": [
            "sc"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_reset_board",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "290-323",
          "snippet": "void\nhifn_reset_board(sc)\n\tstruct hifn_softc *sc;\n{\n\t/*\n\t * Set polling in the DMA configuration register to zero.  0x7 avoids\n\t * resetting the board and zeros out the other fields.\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n\n\t/*\n\t * Now that polling has been disabled, we have to wait 1 ms\n\t * before resetting the board.\n\t */\n\tDELAY(1000);\n\n\t/* Reset the board.  We do this by writing zeros to the DMA reset\n\t * field, the BRD reset field, and the manditory 1 at position 2.\n\t * Every other field is set to zero.\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MODE);\n\n\t/*\n\t * Wait another millisecond for the board to reset.\n\t */\n\tDELAY(1000);\n\n\t/*\n\t * Turn off the reset!  (No joke.)\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\thifn_reset_board"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\thifn_reset_board;\n\nvoid\nhifn_reset_board(sc)\n\tstruct hifn_softc *sc;\n{\n\t/*\n\t * Set polling in the DMA configuration register to zero.  0x7 avoids\n\t * resetting the board and zeros out the other fields.\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n\n\t/*\n\t * Now that polling has been disabled, we have to wait 1 ms\n\t * before resetting the board.\n\t */\n\tDELAY(1000);\n\n\t/* Reset the board.  We do this by writing zeros to the DMA reset\n\t * field, the BRD reset field, and the manditory 1 at position 2.\n\t * Every other field is set to zero.\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MODE);\n\n\t/*\n\t * Wait another millisecond for the board to reset.\n\t */\n\tDELAY(1000);\n\n\t/*\n\t * Turn off the reset!  (No joke.)\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "data",
            "dataexpect",
            "sizeof(data)"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hifn_readramaddr",
          "args": [
            "sc",
            "a",
            "data",
            "0"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_readramaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "696-729",
          "snippet": "int\nhifn_readramaddr(sc, addr, data, slot)\n\tstruct hifn_softc *sc;\n\tint addr, slot;\n\tu_int8_t *data;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\thifn_base_command_t rc;\n\tconst u_int32_t masks = HIFN_D_VALID | HIFN_D_LAST | HIFN_D_MASKDONEIRQ;\n\tu_int64_t src, dst;\n\n\trc.masks = 2 << 13;\n\trc.session_num = addr >> 14;\n\trc.total_source_count = addr & 0x3fff;\n\trc.total_dest_count = 8;\n\n\t*(hifn_base_command_t *) sc->sc_dma->command_bufs[slot] = rc;\n\n\tdma->srcr[slot].p = vtophys(&src);\n\tdma->dstr[slot].p = vtophys(&dst);\n\tdma->cmdr[slot].l = 16 | masks;\n\tdma->srcr[slot].l = 8 | masks;\n\tdma->dstr[slot].l = 8 | masks;\n\tdma->resr[slot].l = HIFN_MAX_RESULT | masks;\n\n\tDELAY(1000);\t/* let read command execute */\n\tif (dma->resr[slot].l & HIFN_D_VALID) {\n\t\tprintf(\"%s: SRAM/DRAM detection error -- \"\n\t\t    \"result[%d] valid still set\\n\", sc->sc_dv.dv_xname, slot);\n\t\treturn (-1);\n\t}\n\tbcopy(&dst, data, sizeof(dst));\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\thifn_readramaddr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\thifn_readramaddr;\n\nint\nhifn_readramaddr(sc, addr, data, slot)\n\tstruct hifn_softc *sc;\n\tint addr, slot;\n\tu_int8_t *data;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\thifn_base_command_t rc;\n\tconst u_int32_t masks = HIFN_D_VALID | HIFN_D_LAST | HIFN_D_MASKDONEIRQ;\n\tu_int64_t src, dst;\n\n\trc.masks = 2 << 13;\n\trc.session_num = addr >> 14;\n\trc.total_source_count = addr & 0x3fff;\n\trc.total_dest_count = 8;\n\n\t*(hifn_base_command_t *) sc->sc_dma->command_bufs[slot] = rc;\n\n\tdma->srcr[slot].p = vtophys(&src);\n\tdma->dstr[slot].p = vtophys(&dst);\n\tdma->cmdr[slot].l = 16 | masks;\n\tdma->srcr[slot].l = 8 | masks;\n\tdma->dstr[slot].l = 8 | masks;\n\tdma->resr[slot].l = HIFN_MAX_RESULT | masks;\n\n\tDELAY(1000);\t/* let read command execute */\n\tif (dma->resr[slot].l & HIFN_D_VALID) {\n\t\tprintf(\"%s: SRAM/DRAM detection error -- \"\n\t\t    \"result[%d] valid still set\\n\", sc->sc_dv.dv_xname, slot);\n\t\treturn (-1);\n\t}\n\tbcopy(&dst, data, sizeof(dst));\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hifn_writeramaddr",
          "args": [
            "sc",
            "0",
            "data",
            "0"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_writeramaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "659-694",
          "snippet": "int\nhifn_writeramaddr(sc, addr, data, slot)\n\tstruct hifn_softc *sc;\n\tint addr, slot;\n\tu_int8_t *data;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\thifn_base_command_t wc;\n\tconst u_int32_t masks = HIFN_D_VALID | HIFN_D_LAST | HIFN_D_MASKDONEIRQ;\n\tu_int64_t src, dst;\n\n\twc.masks = 3 << 13;\n\twc.session_num = addr >> 14;\n\twc.total_source_count = 8;\n\twc.total_dest_count = addr & 0x3fff;;\n\n\t/* build write command */\n\t*(hifn_base_command_t *) sc->sc_dma->command_bufs[slot] = wc;\n\tbcopy(data, &src, sizeof(src));\n\n\tdma->srcr[slot].p = vtophys(&src);\n\tdma->dstr[slot].p = vtophys(&dst);\n\n\tdma->cmdr[slot].l = 16 | masks;\n\tdma->srcr[slot].l = 8 | masks;\n\tdma->dstr[slot].l = 8 | masks;\n\tdma->resr[slot].l = HIFN_MAX_RESULT | masks;\n\n\tDELAY(1000);\t/* let write command execute */\n\tif (dma->resr[slot].l & HIFN_D_VALID) {\n\t\tprintf(\"%s: SRAM/DRAM detection error -- \"\n\t\t    \"result[%d] valid still set\\n\", sc->sc_dv.dv_xname, slot);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\thifn_writeramaddr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\thifn_writeramaddr;\n\nint\nhifn_writeramaddr(sc, addr, data, slot)\n\tstruct hifn_softc *sc;\n\tint addr, slot;\n\tu_int8_t *data;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\thifn_base_command_t wc;\n\tconst u_int32_t masks = HIFN_D_VALID | HIFN_D_LAST | HIFN_D_MASKDONEIRQ;\n\tu_int64_t src, dst;\n\n\twc.masks = 3 << 13;\n\twc.session_num = addr >> 14;\n\twc.total_source_count = 8;\n\twc.total_dest_count = addr & 0x3fff;;\n\n\t/* build write command */\n\t*(hifn_base_command_t *) sc->sc_dma->command_bufs[slot] = wc;\n\tbcopy(data, &src, sizeof(src));\n\n\tdma->srcr[slot].p = vtophys(&src);\n\tdma->dstr[slot].p = vtophys(&dst);\n\n\tdma->cmdr[slot].l = 16 | masks;\n\tdma->srcr[slot].l = 8 | masks;\n\tdma->dstr[slot].l = 8 | masks;\n\tdma->resr[slot].l = HIFN_MAX_RESULT | masks;\n\n\tDELAY(1000);\t/* let write command execute */\n\tif (dma->resr[slot].l & HIFN_D_VALID) {\n\t\tprintf(\"%s: SRAM/DRAM detection error -- \"\n\t\t    \"result[%d] valid still set\\n\", sc->sc_dv.dv_xname, slot);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "data",
            "dataexpect",
            "sizeof(data)"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\thifn_reset_board;\nvoid\thifn_init_dma;\nvoid\thifn_init_pci_registers;\nint\thifn_sramsize;\nint\thifn_readramaddr;\nint\thifn_writeramaddr;\n\nint\nhifn_sramsize(sc)\n\tstruct hifn_softc *sc;\n{\n\tu_int32_t a = 0, end;\n\tu_int8_t data[8], dataexpect[8];\n\n\tfor (a = 0; a < sizeof(data); a++)\n\t\tdata[a] = dataexpect[a] = 0x5a;\n\n\thifn_reset_board(sc);\n\thifn_init_dma(sc);\n\thifn_init_pci_registers(sc);\n\tend = 1 << 20;\t/* 1MB */\n\tfor (a = 0; a < end; a += 16384) {\n\t\tif (hifn_writeramaddr(sc, a, data, 0) < 0)\n\t\t\treturn (0);\n\t\tif (hifn_readramaddr(sc, a, data, 1) < 0)\n\t\t\treturn (0);\n\t\tif (bcmp(data, dataexpect, sizeof(data)) != 0)\n\t\t\treturn (0);\n\t\thifn_reset_board(sc);\n\t\thifn_init_dma(sc);\n\t\thifn_init_pci_registers(sc);\n\t\tsc->sc_ramsize = a + 16384;\n\t}\n\n\tfor (a = 0; a < sizeof(data); a++)\n\t\tdata[a] = dataexpect[a] = 0xa5;\n\tif (hifn_writeramaddr(sc, 0, data, 0) < 0)\n\t\treturn (0);\n\n\tend = sc->sc_ramsize;\n\tfor (a = 0; a < end; a += 16384) {\n\t\thifn_reset_board(sc);\n\t\thifn_init_dma(sc);\n\t\thifn_init_pci_registers(sc);\n\t\tif (hifn_readramaddr(sc, a, data, 0) < 0)\n\t\t\treturn (0);\n\t\tif (a != 0 && bcmp(data, dataexpect, sizeof(data)) == 0)\n\t\t\treturn (0);\n\t\tsc->sc_ramsize = a + 16384;\n\t}\n\n\thifn_reset_board(sc);\n\thifn_init_dma(sc);\n\thifn_init_pci_registers(sc);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "hifn_ramtype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
    "lines": "551-585",
    "snippet": "void\nhifn_ramtype(sc)\n\tstruct hifn_softc *sc;\n{\n\tu_int8_t data[8], dataexpect[8];\n\tint i;\n\n\thifn_reset_board(sc);\n\thifn_init_dma(sc);\n\thifn_init_pci_registers(sc);\n\n\tfor (i = 0; i < sizeof(data); i++)\n\t\tdata[i] = dataexpect[i] = 0x55;\n\tif (hifn_writeramaddr(sc, 0, data, 0) < 0)\n\t\treturn;\n\tif (hifn_readramaddr(sc, 0, data, 1) < 0)\n\t\treturn;\n\tif (bcmp(data, dataexpect, sizeof(data)) != 0) {\n\t\tsc->sc_drammodel = 1;\n\t\treturn;\n\t}\n\n\thifn_reset_board(sc);\n\thifn_init_dma(sc);\n\thifn_init_pci_registers(sc);\n\n\tfor (i = 0; i < sizeof(data); i++)\n\t\tdata[i] = dataexpect[i] = 0xaa;\n\tif (hifn_writeramaddr(sc, 0, data, 0) < 0)\n\t\treturn;\n\tif (hifn_readramaddr(sc, 0, data, 1) < 0)\n\t\treturn;\n\tif (bcmp(data, dataexpect, sizeof(data)) != 0)\n\t\tsc->sc_drammodel = 1;\n}",
    "includes": [
      "#include <dev/pci/hifn7751reg.h>",
      "#include <dev/pci/hifn7751var.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/rndvar.h>",
      "#include <crypto/crypto.h>",
      "#include <sys/device.h>",
      "#include <machine/pmap.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\thifn_reset_board",
      "void\thifn_init_dma",
      "void\thifn_init_pci_registers",
      "void\thifn_ramtype",
      "int\thifn_readramaddr",
      "int\thifn_writeramaddr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "data",
            "dataexpect",
            "sizeof(data)"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hifn_readramaddr",
          "args": [
            "sc",
            "0",
            "data",
            "1"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_readramaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "696-729",
          "snippet": "int\nhifn_readramaddr(sc, addr, data, slot)\n\tstruct hifn_softc *sc;\n\tint addr, slot;\n\tu_int8_t *data;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\thifn_base_command_t rc;\n\tconst u_int32_t masks = HIFN_D_VALID | HIFN_D_LAST | HIFN_D_MASKDONEIRQ;\n\tu_int64_t src, dst;\n\n\trc.masks = 2 << 13;\n\trc.session_num = addr >> 14;\n\trc.total_source_count = addr & 0x3fff;\n\trc.total_dest_count = 8;\n\n\t*(hifn_base_command_t *) sc->sc_dma->command_bufs[slot] = rc;\n\n\tdma->srcr[slot].p = vtophys(&src);\n\tdma->dstr[slot].p = vtophys(&dst);\n\tdma->cmdr[slot].l = 16 | masks;\n\tdma->srcr[slot].l = 8 | masks;\n\tdma->dstr[slot].l = 8 | masks;\n\tdma->resr[slot].l = HIFN_MAX_RESULT | masks;\n\n\tDELAY(1000);\t/* let read command execute */\n\tif (dma->resr[slot].l & HIFN_D_VALID) {\n\t\tprintf(\"%s: SRAM/DRAM detection error -- \"\n\t\t    \"result[%d] valid still set\\n\", sc->sc_dv.dv_xname, slot);\n\t\treturn (-1);\n\t}\n\tbcopy(&dst, data, sizeof(dst));\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\thifn_readramaddr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\thifn_readramaddr;\n\nint\nhifn_readramaddr(sc, addr, data, slot)\n\tstruct hifn_softc *sc;\n\tint addr, slot;\n\tu_int8_t *data;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\thifn_base_command_t rc;\n\tconst u_int32_t masks = HIFN_D_VALID | HIFN_D_LAST | HIFN_D_MASKDONEIRQ;\n\tu_int64_t src, dst;\n\n\trc.masks = 2 << 13;\n\trc.session_num = addr >> 14;\n\trc.total_source_count = addr & 0x3fff;\n\trc.total_dest_count = 8;\n\n\t*(hifn_base_command_t *) sc->sc_dma->command_bufs[slot] = rc;\n\n\tdma->srcr[slot].p = vtophys(&src);\n\tdma->dstr[slot].p = vtophys(&dst);\n\tdma->cmdr[slot].l = 16 | masks;\n\tdma->srcr[slot].l = 8 | masks;\n\tdma->dstr[slot].l = 8 | masks;\n\tdma->resr[slot].l = HIFN_MAX_RESULT | masks;\n\n\tDELAY(1000);\t/* let read command execute */\n\tif (dma->resr[slot].l & HIFN_D_VALID) {\n\t\tprintf(\"%s: SRAM/DRAM detection error -- \"\n\t\t    \"result[%d] valid still set\\n\", sc->sc_dv.dv_xname, slot);\n\t\treturn (-1);\n\t}\n\tbcopy(&dst, data, sizeof(dst));\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hifn_writeramaddr",
          "args": [
            "sc",
            "0",
            "data",
            "0"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_writeramaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "659-694",
          "snippet": "int\nhifn_writeramaddr(sc, addr, data, slot)\n\tstruct hifn_softc *sc;\n\tint addr, slot;\n\tu_int8_t *data;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\thifn_base_command_t wc;\n\tconst u_int32_t masks = HIFN_D_VALID | HIFN_D_LAST | HIFN_D_MASKDONEIRQ;\n\tu_int64_t src, dst;\n\n\twc.masks = 3 << 13;\n\twc.session_num = addr >> 14;\n\twc.total_source_count = 8;\n\twc.total_dest_count = addr & 0x3fff;;\n\n\t/* build write command */\n\t*(hifn_base_command_t *) sc->sc_dma->command_bufs[slot] = wc;\n\tbcopy(data, &src, sizeof(src));\n\n\tdma->srcr[slot].p = vtophys(&src);\n\tdma->dstr[slot].p = vtophys(&dst);\n\n\tdma->cmdr[slot].l = 16 | masks;\n\tdma->srcr[slot].l = 8 | masks;\n\tdma->dstr[slot].l = 8 | masks;\n\tdma->resr[slot].l = HIFN_MAX_RESULT | masks;\n\n\tDELAY(1000);\t/* let write command execute */\n\tif (dma->resr[slot].l & HIFN_D_VALID) {\n\t\tprintf(\"%s: SRAM/DRAM detection error -- \"\n\t\t    \"result[%d] valid still set\\n\", sc->sc_dv.dv_xname, slot);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\thifn_writeramaddr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\thifn_writeramaddr;\n\nint\nhifn_writeramaddr(sc, addr, data, slot)\n\tstruct hifn_softc *sc;\n\tint addr, slot;\n\tu_int8_t *data;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\thifn_base_command_t wc;\n\tconst u_int32_t masks = HIFN_D_VALID | HIFN_D_LAST | HIFN_D_MASKDONEIRQ;\n\tu_int64_t src, dst;\n\n\twc.masks = 3 << 13;\n\twc.session_num = addr >> 14;\n\twc.total_source_count = 8;\n\twc.total_dest_count = addr & 0x3fff;;\n\n\t/* build write command */\n\t*(hifn_base_command_t *) sc->sc_dma->command_bufs[slot] = wc;\n\tbcopy(data, &src, sizeof(src));\n\n\tdma->srcr[slot].p = vtophys(&src);\n\tdma->dstr[slot].p = vtophys(&dst);\n\n\tdma->cmdr[slot].l = 16 | masks;\n\tdma->srcr[slot].l = 8 | masks;\n\tdma->dstr[slot].l = 8 | masks;\n\tdma->resr[slot].l = HIFN_MAX_RESULT | masks;\n\n\tDELAY(1000);\t/* let write command execute */\n\tif (dma->resr[slot].l & HIFN_D_VALID) {\n\t\tprintf(\"%s: SRAM/DRAM detection error -- \"\n\t\t    \"result[%d] valid still set\\n\", sc->sc_dv.dv_xname, slot);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hifn_init_pci_registers",
          "args": [
            "sc"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_init_pci_registers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "482-518",
          "snippet": "void \nhifn_init_pci_registers(sc)\n\tstruct hifn_softc *sc;\n{\n\t/* write fixed values needed by the Initialization registers */\n\tWRITE_REG_0(sc, HIFN_0_PUCTRL, HIFN_PUCTRL_DMAENA);\n\tWRITE_REG_0(sc, HIFN_0_FIFOCNFG, HIFN_FIFOCNFG_THRESHOLD);\n\tWRITE_REG_0(sc, HIFN_0_PUIER, HIFN_PUIER_DSTOVER);\n\n\t/* write all 4 ring address registers */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CRAR, vtophys(sc->sc_dma->cmdr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_SRAR, vtophys(sc->sc_dma->srcr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_DRAR, vtophys(sc->sc_dma->dstr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_RRAR, vtophys(sc->sc_dma->resr));\n\n\t/* write status register */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_D_CTRL_ENA |\n\t    HIFN_DMACSR_R_CTRL_ENA | HIFN_DMACSR_S_CTRL_ENA |\n\t    HIFN_DMACSR_C_CTRL_ENA);\n\tWRITE_REG_1(sc, HIFN_1_DMA_IER, HIFN_DMAIER_R_DONE);\n\n#if 0\n#if BYTE_ORDER == BIG_ENDIAN\n\t    (0x1 << 7) |\n#endif\n#endif\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG, HIFN_PUCNFG_COMPSING |\n\t    HIFN_PUCNFG_DRFR_128 | HIFN_PUCNFG_TCALLPHASES |\n\t    HIFN_PUCNFG_TCDRVTOTEM | HIFN_PUCNFG_BUS32 |\n\t    (sc->sc_drammodel ? HIFN_PUCNFG_DRAM : HIFN_PUCNFG_SRAM));\n\n\tWRITE_REG_0(sc, HIFN_0_PUISR, HIFN_PUISR_DSTOVER);\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE | HIFN_DMACNFG_LAST |\n\t    ((HIFN_POLL_FREQUENCY << 16 ) & HIFN_DMACNFG_POLLFREQ) |\n\t    ((HIFN_POLL_SCALAR << 8) & HIFN_DMACNFG_POLLINVAL));\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\thifn_init_pci_registers"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\thifn_init_pci_registers;\n\nvoid \nhifn_init_pci_registers(sc)\n\tstruct hifn_softc *sc;\n{\n\t/* write fixed values needed by the Initialization registers */\n\tWRITE_REG_0(sc, HIFN_0_PUCTRL, HIFN_PUCTRL_DMAENA);\n\tWRITE_REG_0(sc, HIFN_0_FIFOCNFG, HIFN_FIFOCNFG_THRESHOLD);\n\tWRITE_REG_0(sc, HIFN_0_PUIER, HIFN_PUIER_DSTOVER);\n\n\t/* write all 4 ring address registers */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CRAR, vtophys(sc->sc_dma->cmdr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_SRAR, vtophys(sc->sc_dma->srcr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_DRAR, vtophys(sc->sc_dma->dstr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_RRAR, vtophys(sc->sc_dma->resr));\n\n\t/* write status register */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_D_CTRL_ENA |\n\t    HIFN_DMACSR_R_CTRL_ENA | HIFN_DMACSR_S_CTRL_ENA |\n\t    HIFN_DMACSR_C_CTRL_ENA);\n\tWRITE_REG_1(sc, HIFN_1_DMA_IER, HIFN_DMAIER_R_DONE);\n\n#if 0\n#if BYTE_ORDER == BIG_ENDIAN\n\t    (0x1 << 7) |\n#endif\n#endif\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG, HIFN_PUCNFG_COMPSING |\n\t    HIFN_PUCNFG_DRFR_128 | HIFN_PUCNFG_TCALLPHASES |\n\t    HIFN_PUCNFG_TCDRVTOTEM | HIFN_PUCNFG_BUS32 |\n\t    (sc->sc_drammodel ? HIFN_PUCNFG_DRAM : HIFN_PUCNFG_SRAM));\n\n\tWRITE_REG_0(sc, HIFN_0_PUISR, HIFN_PUISR_DSTOVER);\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE | HIFN_DMACNFG_LAST |\n\t    ((HIFN_POLL_FREQUENCY << 16 ) & HIFN_DMACNFG_POLLFREQ) |\n\t    ((HIFN_POLL_SCALAR << 8) & HIFN_DMACNFG_POLLINVAL));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hifn_init_dma",
          "args": [
            "sc"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_init_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "734-754",
          "snippet": "void \nhifn_init_dma(sc)\n\tstruct hifn_softc *sc;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\tint i;\n\n\t/* initialize static pointer values */\n\tfor (i = 0; i < HIFN_D_CMD_RSIZE; i++)\n\t\tdma->cmdr[i].p = vtophys(dma->command_bufs[i]);\n\tfor (i = 0; i < HIFN_D_RES_RSIZE; i++)\n\t\tdma->resr[i].p = vtophys(dma->result_bufs[i]);\n\n\tdma->cmdr[HIFN_D_CMD_RSIZE].p = vtophys(dma->cmdr);\n\tdma->srcr[HIFN_D_SRC_RSIZE].p = vtophys(dma->srcr);\n\tdma->dstr[HIFN_D_DST_RSIZE].p = vtophys(dma->dstr);\n\tdma->resr[HIFN_D_RES_RSIZE].p = vtophys(dma->resr);\n\tdma->cmdu = dma->srcu = dma->dstu = dma->resu = 0;\n\tdma->cmdi = dma->srci = dma->dsti = dma->resi = 0;\n\tdma->cmdk = dma->srck = dma->dstk = dma->resk = 0;\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\thifn_init_dma"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\thifn_init_dma;\n\nvoid \nhifn_init_dma(sc)\n\tstruct hifn_softc *sc;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\tint i;\n\n\t/* initialize static pointer values */\n\tfor (i = 0; i < HIFN_D_CMD_RSIZE; i++)\n\t\tdma->cmdr[i].p = vtophys(dma->command_bufs[i]);\n\tfor (i = 0; i < HIFN_D_RES_RSIZE; i++)\n\t\tdma->resr[i].p = vtophys(dma->result_bufs[i]);\n\n\tdma->cmdr[HIFN_D_CMD_RSIZE].p = vtophys(dma->cmdr);\n\tdma->srcr[HIFN_D_SRC_RSIZE].p = vtophys(dma->srcr);\n\tdma->dstr[HIFN_D_DST_RSIZE].p = vtophys(dma->dstr);\n\tdma->resr[HIFN_D_RES_RSIZE].p = vtophys(dma->resr);\n\tdma->cmdu = dma->srcu = dma->dstu = dma->resu = 0;\n\tdma->cmdi = dma->srci = dma->dsti = dma->resi = 0;\n\tdma->cmdk = dma->srck = dma->dstk = dma->resk = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hifn_reset_board",
          "args": [
            "sc"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_reset_board",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "290-323",
          "snippet": "void\nhifn_reset_board(sc)\n\tstruct hifn_softc *sc;\n{\n\t/*\n\t * Set polling in the DMA configuration register to zero.  0x7 avoids\n\t * resetting the board and zeros out the other fields.\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n\n\t/*\n\t * Now that polling has been disabled, we have to wait 1 ms\n\t * before resetting the board.\n\t */\n\tDELAY(1000);\n\n\t/* Reset the board.  We do this by writing zeros to the DMA reset\n\t * field, the BRD reset field, and the manditory 1 at position 2.\n\t * Every other field is set to zero.\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MODE);\n\n\t/*\n\t * Wait another millisecond for the board to reset.\n\t */\n\tDELAY(1000);\n\n\t/*\n\t * Turn off the reset!  (No joke.)\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\thifn_reset_board"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\thifn_reset_board;\n\nvoid\nhifn_reset_board(sc)\n\tstruct hifn_softc *sc;\n{\n\t/*\n\t * Set polling in the DMA configuration register to zero.  0x7 avoids\n\t * resetting the board and zeros out the other fields.\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n\n\t/*\n\t * Now that polling has been disabled, we have to wait 1 ms\n\t * before resetting the board.\n\t */\n\tDELAY(1000);\n\n\t/* Reset the board.  We do this by writing zeros to the DMA reset\n\t * field, the BRD reset field, and the manditory 1 at position 2.\n\t * Every other field is set to zero.\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MODE);\n\n\t/*\n\t * Wait another millisecond for the board to reset.\n\t */\n\tDELAY(1000);\n\n\t/*\n\t * Turn off the reset!  (No joke.)\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "data",
            "dataexpect",
            "sizeof(data)"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\thifn_reset_board;\nvoid\thifn_init_dma;\nvoid\thifn_init_pci_registers;\nvoid\thifn_ramtype;\nint\thifn_readramaddr;\nint\thifn_writeramaddr;\n\nvoid\nhifn_ramtype(sc)\n\tstruct hifn_softc *sc;\n{\n\tu_int8_t data[8], dataexpect[8];\n\tint i;\n\n\thifn_reset_board(sc);\n\thifn_init_dma(sc);\n\thifn_init_pci_registers(sc);\n\n\tfor (i = 0; i < sizeof(data); i++)\n\t\tdata[i] = dataexpect[i] = 0x55;\n\tif (hifn_writeramaddr(sc, 0, data, 0) < 0)\n\t\treturn;\n\tif (hifn_readramaddr(sc, 0, data, 1) < 0)\n\t\treturn;\n\tif (bcmp(data, dataexpect, sizeof(data)) != 0) {\n\t\tsc->sc_drammodel = 1;\n\t\treturn;\n\t}\n\n\thifn_reset_board(sc);\n\thifn_init_dma(sc);\n\thifn_init_pci_registers(sc);\n\n\tfor (i = 0; i < sizeof(data); i++)\n\t\tdata[i] = dataexpect[i] = 0xaa;\n\tif (hifn_writeramaddr(sc, 0, data, 0) < 0)\n\t\treturn;\n\tif (hifn_readramaddr(sc, 0, data, 1) < 0)\n\t\treturn;\n\tif (bcmp(data, dataexpect, sizeof(data)) != 0)\n\t\tsc->sc_drammodel = 1;\n}"
  },
  {
    "function_name": "hifn_sessions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
    "lines": "527-549",
    "snippet": "void\nhifn_sessions(sc)\n\tstruct hifn_softc *sc;\n{\n\tu_int32_t pucnfg;\n\tint ctxsize;\n\n\tpucnfg = READ_REG_0(sc, HIFN_0_PUCNFG);\n\n\tif (pucnfg & HIFN_PUCNFG_COMPSING) {\n\t\tif (pucnfg & HIFN_PUCNFG_ENCCNFG)\n\t\t\tctxsize = 128;\n\t\telse\n\t\t\tctxsize = 512;\n\t\tsc->sc_maxses = 1 +\n\t\t    ((sc->sc_ramsize - 32768) / ctxsize);\n\t}\n\telse\n\t\tsc->sc_maxses = sc->sc_ramsize / 16384;\n\n\tif (sc->sc_maxses > 2048)\n\t\tsc->sc_maxses = 2048;\n}",
    "includes": [
      "#include <dev/pci/hifn7751reg.h>",
      "#include <dev/pci/hifn7751var.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/rndvar.h>",
      "#include <crypto/crypto.h>",
      "#include <sys/device.h>",
      "#include <machine/pmap.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\thifn_sessions"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_REG_0",
          "args": [
            "sc",
            "HIFN_0_PUCNFG"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\thifn_sessions;\n\nvoid\nhifn_sessions(sc)\n\tstruct hifn_softc *sc;\n{\n\tu_int32_t pucnfg;\n\tint ctxsize;\n\n\tpucnfg = READ_REG_0(sc, HIFN_0_PUCNFG);\n\n\tif (pucnfg & HIFN_PUCNFG_COMPSING) {\n\t\tif (pucnfg & HIFN_PUCNFG_ENCCNFG)\n\t\t\tctxsize = 128;\n\t\telse\n\t\t\tctxsize = 512;\n\t\tsc->sc_maxses = 1 +\n\t\t    ((sc->sc_ramsize - 32768) / ctxsize);\n\t}\n\telse\n\t\tsc->sc_maxses = sc->sc_ramsize / 16384;\n\n\tif (sc->sc_maxses > 2048)\n\t\tsc->sc_maxses = 2048;\n}"
  },
  {
    "function_name": "hifn_init_pci_registers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
    "lines": "482-518",
    "snippet": "void \nhifn_init_pci_registers(sc)\n\tstruct hifn_softc *sc;\n{\n\t/* write fixed values needed by the Initialization registers */\n\tWRITE_REG_0(sc, HIFN_0_PUCTRL, HIFN_PUCTRL_DMAENA);\n\tWRITE_REG_0(sc, HIFN_0_FIFOCNFG, HIFN_FIFOCNFG_THRESHOLD);\n\tWRITE_REG_0(sc, HIFN_0_PUIER, HIFN_PUIER_DSTOVER);\n\n\t/* write all 4 ring address registers */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CRAR, vtophys(sc->sc_dma->cmdr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_SRAR, vtophys(sc->sc_dma->srcr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_DRAR, vtophys(sc->sc_dma->dstr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_RRAR, vtophys(sc->sc_dma->resr));\n\n\t/* write status register */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_D_CTRL_ENA |\n\t    HIFN_DMACSR_R_CTRL_ENA | HIFN_DMACSR_S_CTRL_ENA |\n\t    HIFN_DMACSR_C_CTRL_ENA);\n\tWRITE_REG_1(sc, HIFN_1_DMA_IER, HIFN_DMAIER_R_DONE);\n\n#if 0\n#if BYTE_ORDER == BIG_ENDIAN\n\t    (0x1 << 7) |\n#endif\n#endif\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG, HIFN_PUCNFG_COMPSING |\n\t    HIFN_PUCNFG_DRFR_128 | HIFN_PUCNFG_TCALLPHASES |\n\t    HIFN_PUCNFG_TCDRVTOTEM | HIFN_PUCNFG_BUS32 |\n\t    (sc->sc_drammodel ? HIFN_PUCNFG_DRAM : HIFN_PUCNFG_SRAM));\n\n\tWRITE_REG_0(sc, HIFN_0_PUISR, HIFN_PUISR_DSTOVER);\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE | HIFN_DMACNFG_LAST |\n\t    ((HIFN_POLL_FREQUENCY << 16 ) & HIFN_DMACNFG_POLLFREQ) |\n\t    ((HIFN_POLL_SCALAR << 8) & HIFN_DMACNFG_POLLINVAL));\n}",
    "includes": [
      "#include <dev/pci/hifn7751reg.h>",
      "#include <dev/pci/hifn7751var.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/rndvar.h>",
      "#include <crypto/crypto.h>",
      "#include <sys/device.h>",
      "#include <machine/pmap.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\thifn_init_pci_registers"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_CNFG",
            "HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE | HIFN_DMACNFG_LAST |\n\t    ((HIFN_POLL_FREQUENCY << 16 ) & HIFN_DMACNFG_POLLFREQ) |\n\t    ((HIFN_POLL_SCALAR << 8) & HIFN_DMACNFG_POLLINVAL)"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_0",
          "args": [
            "sc",
            "HIFN_0_PUISR",
            "HIFN_PUISR_DSTOVER"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_0",
          "args": [
            "sc",
            "HIFN_0_PUCNFG",
            "HIFN_PUCNFG_COMPSING |\n\t    HIFN_PUCNFG_DRFR_128 | HIFN_PUCNFG_TCALLPHASES |\n\t    HIFN_PUCNFG_TCDRVTOTEM | HIFN_PUCNFG_BUS32 |\n\t    (sc->sc_drammodel ? HIFN_PUCNFG_DRAM : HIFN_PUCNFG_SRAM)"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_IER",
            "HIFN_DMAIER_R_DONE"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_CSR",
            "HIFN_DMACSR_D_CTRL_ENA |\n\t    HIFN_DMACSR_R_CTRL_ENA | HIFN_DMACSR_S_CTRL_ENA |\n\t    HIFN_DMACSR_C_CTRL_ENA"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_RRAR",
            "vtophys(sc->sc_dma->resr)"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->sc_dma->resr"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_DRAR",
            "vtophys(sc->sc_dma->dstr)"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->sc_dma->dstr"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_SRAR",
            "vtophys(sc->sc_dma->srcr)"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->sc_dma->srcr"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_CRAR",
            "vtophys(sc->sc_dma->cmdr)"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->sc_dma->cmdr"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_0",
          "args": [
            "sc",
            "HIFN_0_PUIER",
            "HIFN_PUIER_DSTOVER"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_0",
          "args": [
            "sc",
            "HIFN_0_FIFOCNFG",
            "HIFN_FIFOCNFG_THRESHOLD"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_0",
          "args": [
            "sc",
            "HIFN_0_PUCTRL",
            "HIFN_PUCTRL_DMAENA"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\thifn_init_pci_registers;\n\nvoid \nhifn_init_pci_registers(sc)\n\tstruct hifn_softc *sc;\n{\n\t/* write fixed values needed by the Initialization registers */\n\tWRITE_REG_0(sc, HIFN_0_PUCTRL, HIFN_PUCTRL_DMAENA);\n\tWRITE_REG_0(sc, HIFN_0_FIFOCNFG, HIFN_FIFOCNFG_THRESHOLD);\n\tWRITE_REG_0(sc, HIFN_0_PUIER, HIFN_PUIER_DSTOVER);\n\n\t/* write all 4 ring address registers */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CRAR, vtophys(sc->sc_dma->cmdr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_SRAR, vtophys(sc->sc_dma->srcr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_DRAR, vtophys(sc->sc_dma->dstr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_RRAR, vtophys(sc->sc_dma->resr));\n\n\t/* write status register */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_D_CTRL_ENA |\n\t    HIFN_DMACSR_R_CTRL_ENA | HIFN_DMACSR_S_CTRL_ENA |\n\t    HIFN_DMACSR_C_CTRL_ENA);\n\tWRITE_REG_1(sc, HIFN_1_DMA_IER, HIFN_DMAIER_R_DONE);\n\n#if 0\n#if BYTE_ORDER == BIG_ENDIAN\n\t    (0x1 << 7) |\n#endif\n#endif\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG, HIFN_PUCNFG_COMPSING |\n\t    HIFN_PUCNFG_DRFR_128 | HIFN_PUCNFG_TCALLPHASES |\n\t    HIFN_PUCNFG_TCDRVTOTEM | HIFN_PUCNFG_BUS32 |\n\t    (sc->sc_drammodel ? HIFN_PUCNFG_DRAM : HIFN_PUCNFG_SRAM));\n\n\tWRITE_REG_0(sc, HIFN_0_PUISR, HIFN_PUISR_DSTOVER);\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE | HIFN_DMACNFG_LAST |\n\t    ((HIFN_POLL_FREQUENCY << 16 ) & HIFN_DMACNFG_POLLFREQ) |\n\t    ((HIFN_POLL_SCALAR << 8) & HIFN_DMACNFG_POLLINVAL));\n}"
  },
  {
    "function_name": "hifn_enable_crypto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
    "lines": "380-476",
    "snippet": "int \nhifn_enable_crypto(sc, pciid)\n\tstruct hifn_softc *sc;\n\tpcireg_t pciid;\n{\n\tu_int32_t dmacfg, ramcfg, encl, addr, i;\n\tchar *offtbl = NULL;\n\n\tfor (i = 0; i < sizeof(pci2id)/sizeof(pci2id[0]); i++) {\n\t\tif (pci2id[i].pci_vendor == PCI_VENDOR(pciid) &&\n\t\t    pci2id[i].pci_prod == PCI_PRODUCT(pciid)) {\n\t\t\tofftbl = pci2id[i].card_id;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (offtbl == NULL) {\n#ifdef HIFN_DEBUG\n\t\tprintf(\"%s: Unknown card!\\n\", sc->sc_dv.dv_xname);\n#endif\n\t\treturn (1);\n\t}\n\n\tramcfg = READ_REG_0(sc, HIFN_0_PUCNFG);\n\tdmacfg = READ_REG_1(sc, HIFN_1_DMA_CNFG);\n\n\t/*\n\t * The RAM config register's encrypt level bit needs to be set before\n\t * every read performed on the encryption level register.\n\t */\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg | HIFN_PUCNFG_CHIPID);\n\n\tencl = READ_REG_0(sc, HIFN_0_PUSTAT) & HIFN_PUSTAT_CHIPENA;\n\n\t/*\n\t * Make sure we don't re-unlock.  Two unlocks kills chip until the\n\t * next reboot.\n\t */\n\tif (encl == HIFN_PUSTAT_ENA_1 || encl == HIFN_PUSTAT_ENA_2) {\n#ifdef HIFN_DEBUG\n\t\tprintf(\"%s: Strong Crypto already enabled!\\n\",\n\t\t    sc->sc_dv.dv_xname);\n#endif\n\t\tWRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg);\n\t\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, dmacfg);\n\t\treturn 0;\t/* success */\n\t}\n\n\tif (encl != 0 && encl != HIFN_PUSTAT_ENA_0) {\n#ifdef HIFN_DEBUG\n\t\tprintf(\"%: Unknown encryption level\\n\",  sc->sc_dv.dv_xname);\n#endif\n\t\treturn 1;\n\t}\n\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_UNLOCK |\n\t    HIFN_DMACNFG_MSTRESET | HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n\taddr = READ_REG_1(sc, HIFN_UNLOCK_SECRET1);\n\tWRITE_REG_1(sc, HIFN_UNLOCK_SECRET2, 0);\n\n\tfor (i = 0; i <= 12; i++) {\n\t\taddr = hifn_next_signature(addr, offtbl[i] + 0x101);\n\t\tWRITE_REG_1(sc, HIFN_UNLOCK_SECRET2, addr);\n\n\t\tDELAY(1000);\n\t}\n\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg | HIFN_PUCNFG_CHIPID);\n\tencl = READ_REG_0(sc, HIFN_0_PUSTAT) & HIFN_PUSTAT_CHIPENA;\n\n#ifdef HIFN_DEBUG\n\tif (encl != HIFN_PUSTAT_ENA_1 && encl != HIFN_PUSTAT_ENA_2)\n\t\tprintf(\"Encryption engine is permanently locked until next system reset.\");\n\telse\n\t\tprintf(\"Encryption engine enabled successfully!\");\n#endif\n\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg);\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, dmacfg);\n\n\tswitch(encl) {\n\tcase HIFN_PUSTAT_ENA_0:\n\t\tprintf(\": no encr/auth\");\n\t\tbreak;\n\tcase HIFN_PUSTAT_ENA_1:\n\t\tprintf(\": DES enabled\");\n\t\tbreak;\n\tcase HIFN_PUSTAT_ENA_2:\n\t\tprintf(\": fully enabled\");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\": disabled\");\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/hifn7751reg.h>",
      "#include <dev/pci/hifn7751var.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/rndvar.h>",
      "#include <crypto/crypto.h>",
      "#include <sys/device.h>",
      "#include <machine/pmap.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\thifn_enable_crypto",
      "u_int32_t hifn_next_signature",
      "struct pci2id {\n\tu_short\t\tpci_vendor;\n\tu_short\t\tpci_prod;\n\tchar\t\tcard_id[13];\n} pci2id[] = {\n\t{\n\t\tPCI_VENDOR_NETSEC,\n\t\tPCI_PRODUCT_NETSEC_7751,\n\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t  0x00, 0x00, 0x00, 0x00, 0x00 }\n\t}, {\n\t\tPCI_VENDOR_INVERTEX,\n\t\tPCI_PRODUCT_INVERTEX_AEON,\n\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t  0x00, 0x00, 0x00, 0x00, 0x00 }\n\t}, {\n\t\t/*\n\t\t * Other vendors share this PCI ID as well, such as\n\t\t * http://www.powercrypt.com, and obviously they also\n\t\t * use the same key.\n\t\t */\n\t\tPCI_VENDOR_HIFN,\n\t\tPCI_PRODUCT_HIFN_7751,\n\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t  0x00, 0x00, 0x00, 0x00, 0x00 }\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": disabled\""
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_CNFG",
            "dmacfg"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_0",
          "args": [
            "sc",
            "HIFN_0_PUCNFG",
            "ramcfg"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_REG_0",
          "args": [
            "sc",
            "HIFN_0_PUSTAT"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_0",
          "args": [
            "sc",
            "HIFN_0_PUCNFG",
            "ramcfg | HIFN_PUCNFG_CHIPID"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_1",
          "args": [
            "sc",
            "HIFN_UNLOCK_SECRET2",
            "addr"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hifn_next_signature",
          "args": [
            "addr",
            "offtbl[i] + 0x101"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_next_signature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "325-345",
          "snippet": "u_int32_t\nhifn_next_signature(a, cnt)\n\tu_int a, cnt;\n{\n\tint i, v;\n\n\tfor (i = 0; i < cnt; i++) {\n\n\t\t/* get the parity */\n\t\tv = a & 0x80080125;\n\t\tv ^= v >> 16;\n\t\tv ^= v >> 8;\n\t\tv ^= v >> 4;\n\t\tv ^= v >> 2;\n\t\tv ^= v >> 1;\n\n\t\ta = (v & 1) ^ (a << 1);\n\t}\n\n\treturn a;\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_int32_t hifn_next_signature",
            "__P((u_int a, u_int cnt));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int32_t hifn_next_signature;\n__P((u_int a, u_int cnt));\n\nu_int32_t\nhifn_next_signature(a, cnt)\n\tu_int a, cnt;\n{\n\tint i, v;\n\n\tfor (i = 0; i < cnt; i++) {\n\n\t\t/* get the parity */\n\t\tv = a & 0x80080125;\n\t\tv ^= v >> 16;\n\t\tv ^= v >> 8;\n\t\tv ^= v >> 4;\n\t\tv ^= v >> 2;\n\t\tv ^= v >> 1;\n\n\t\ta = (v & 1) ^ (a << 1);\n\t}\n\n\treturn a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_REG_1",
          "args": [
            "sc",
            "HIFN_UNLOCK_SECRET2",
            "0"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_REG_1",
          "args": [
            "sc",
            "HIFN_UNLOCK_SECRET1"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_CNFG",
            "HIFN_DMACNFG_UNLOCK |\n\t    HIFN_DMACNFG_MSTRESET | HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_CNFG",
            "dmacfg"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_0",
          "args": [
            "sc",
            "HIFN_0_PUCNFG",
            "ramcfg"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_REG_0",
          "args": [
            "sc",
            "HIFN_0_PUSTAT"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_0",
          "args": [
            "sc",
            "HIFN_0_PUCNFG",
            "ramcfg | HIFN_PUCNFG_CHIPID"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_CNFG"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_REG_0",
          "args": [
            "sc",
            "HIFN_0_PUCNFG"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pciid"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pciid"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\thifn_enable_crypto;\nu_int32_t hifn_next_signature;\nstruct pci2id {\n\tu_short\t\tpci_vendor;\n\tu_short\t\tpci_prod;\n\tchar\t\tcard_id[13];\n} pci2id[] = {\n\t{\n\t\tPCI_VENDOR_NETSEC,\n\t\tPCI_PRODUCT_NETSEC_7751,\n\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t  0x00, 0x00, 0x00, 0x00, 0x00 }\n\t}, {\n\t\tPCI_VENDOR_INVERTEX,\n\t\tPCI_PRODUCT_INVERTEX_AEON,\n\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t  0x00, 0x00, 0x00, 0x00, 0x00 }\n\t}, {\n\t\t/*\n\t\t * Other vendors share this PCI ID as well, such as\n\t\t * http://www.powercrypt.com, and obviously they also\n\t\t * use the same key.\n\t\t */\n\t\tPCI_VENDOR_HIFN,\n\t\tPCI_PRODUCT_HIFN_7751,\n\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t  0x00, 0x00, 0x00, 0x00, 0x00 }\n\t},\n};\n\nint \nhifn_enable_crypto(sc, pciid)\n\tstruct hifn_softc *sc;\n\tpcireg_t pciid;\n{\n\tu_int32_t dmacfg, ramcfg, encl, addr, i;\n\tchar *offtbl = NULL;\n\n\tfor (i = 0; i < sizeof(pci2id)/sizeof(pci2id[0]); i++) {\n\t\tif (pci2id[i].pci_vendor == PCI_VENDOR(pciid) &&\n\t\t    pci2id[i].pci_prod == PCI_PRODUCT(pciid)) {\n\t\t\tofftbl = pci2id[i].card_id;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (offtbl == NULL) {\n#ifdef HIFN_DEBUG\n\t\tprintf(\"%s: Unknown card!\\n\", sc->sc_dv.dv_xname);\n#endif\n\t\treturn (1);\n\t}\n\n\tramcfg = READ_REG_0(sc, HIFN_0_PUCNFG);\n\tdmacfg = READ_REG_1(sc, HIFN_1_DMA_CNFG);\n\n\t/*\n\t * The RAM config register's encrypt level bit needs to be set before\n\t * every read performed on the encryption level register.\n\t */\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg | HIFN_PUCNFG_CHIPID);\n\n\tencl = READ_REG_0(sc, HIFN_0_PUSTAT) & HIFN_PUSTAT_CHIPENA;\n\n\t/*\n\t * Make sure we don't re-unlock.  Two unlocks kills chip until the\n\t * next reboot.\n\t */\n\tif (encl == HIFN_PUSTAT_ENA_1 || encl == HIFN_PUSTAT_ENA_2) {\n#ifdef HIFN_DEBUG\n\t\tprintf(\"%s: Strong Crypto already enabled!\\n\",\n\t\t    sc->sc_dv.dv_xname);\n#endif\n\t\tWRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg);\n\t\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, dmacfg);\n\t\treturn 0;\t/* success */\n\t}\n\n\tif (encl != 0 && encl != HIFN_PUSTAT_ENA_0) {\n#ifdef HIFN_DEBUG\n\t\tprintf(\"%: Unknown encryption level\\n\",  sc->sc_dv.dv_xname);\n#endif\n\t\treturn 1;\n\t}\n\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_UNLOCK |\n\t    HIFN_DMACNFG_MSTRESET | HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n\taddr = READ_REG_1(sc, HIFN_UNLOCK_SECRET1);\n\tWRITE_REG_1(sc, HIFN_UNLOCK_SECRET2, 0);\n\n\tfor (i = 0; i <= 12; i++) {\n\t\taddr = hifn_next_signature(addr, offtbl[i] + 0x101);\n\t\tWRITE_REG_1(sc, HIFN_UNLOCK_SECRET2, addr);\n\n\t\tDELAY(1000);\n\t}\n\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg | HIFN_PUCNFG_CHIPID);\n\tencl = READ_REG_0(sc, HIFN_0_PUSTAT) & HIFN_PUSTAT_CHIPENA;\n\n#ifdef HIFN_DEBUG\n\tif (encl != HIFN_PUSTAT_ENA_1 && encl != HIFN_PUSTAT_ENA_2)\n\t\tprintf(\"Encryption engine is permanently locked until next system reset.\");\n\telse\n\t\tprintf(\"Encryption engine enabled successfully!\");\n#endif\n\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg);\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, dmacfg);\n\n\tswitch(encl) {\n\tcase HIFN_PUSTAT_ENA_0:\n\t\tprintf(\": no encr/auth\");\n\t\tbreak;\n\tcase HIFN_PUSTAT_ENA_1:\n\t\tprintf(\": DES enabled\");\n\t\tbreak;\n\tcase HIFN_PUSTAT_ENA_2:\n\t\tprintf(\": fully enabled\");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\": disabled\");\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hifn_next_signature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
    "lines": "325-345",
    "snippet": "u_int32_t\nhifn_next_signature(a, cnt)\n\tu_int a, cnt;\n{\n\tint i, v;\n\n\tfor (i = 0; i < cnt; i++) {\n\n\t\t/* get the parity */\n\t\tv = a & 0x80080125;\n\t\tv ^= v >> 16;\n\t\tv ^= v >> 8;\n\t\tv ^= v >> 4;\n\t\tv ^= v >> 2;\n\t\tv ^= v >> 1;\n\n\t\ta = (v & 1) ^ (a << 1);\n\t}\n\n\treturn a;\n}",
    "includes": [
      "#include <dev/pci/hifn7751reg.h>",
      "#include <dev/pci/hifn7751var.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/rndvar.h>",
      "#include <crypto/crypto.h>",
      "#include <sys/device.h>",
      "#include <machine/pmap.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_int32_t hifn_next_signature",
      "__P((u_int a, u_int cnt));"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int32_t hifn_next_signature;\n__P((u_int a, u_int cnt));\n\nu_int32_t\nhifn_next_signature(a, cnt)\n\tu_int a, cnt;\n{\n\tint i, v;\n\n\tfor (i = 0; i < cnt; i++) {\n\n\t\t/* get the parity */\n\t\tv = a & 0x80080125;\n\t\tv ^= v >> 16;\n\t\tv ^= v >> 8;\n\t\tv ^= v >> 4;\n\t\tv ^= v >> 2;\n\t\tv ^= v >> 1;\n\n\t\ta = (v & 1) ^ (a << 1);\n\t}\n\n\treturn a;\n}"
  },
  {
    "function_name": "hifn_reset_board",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
    "lines": "290-323",
    "snippet": "void\nhifn_reset_board(sc)\n\tstruct hifn_softc *sc;\n{\n\t/*\n\t * Set polling in the DMA configuration register to zero.  0x7 avoids\n\t * resetting the board and zeros out the other fields.\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n\n\t/*\n\t * Now that polling has been disabled, we have to wait 1 ms\n\t * before resetting the board.\n\t */\n\tDELAY(1000);\n\n\t/* Reset the board.  We do this by writing zeros to the DMA reset\n\t * field, the BRD reset field, and the manditory 1 at position 2.\n\t * Every other field is set to zero.\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MODE);\n\n\t/*\n\t * Wait another millisecond for the board to reset.\n\t */\n\tDELAY(1000);\n\n\t/*\n\t * Turn off the reset!  (No joke.)\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n}",
    "includes": [
      "#include <dev/pci/hifn7751reg.h>",
      "#include <dev/pci/hifn7751var.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/rndvar.h>",
      "#include <crypto/crypto.h>",
      "#include <sys/device.h>",
      "#include <machine/pmap.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\thifn_reset_board"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_CNFG",
            "HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_CNFG",
            "HIFN_DMACNFG_MODE"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_1",
          "args": [
            "sc",
            "HIFN_1_DMA_CNFG",
            "HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\thifn_reset_board;\n\nvoid\nhifn_reset_board(sc)\n\tstruct hifn_softc *sc;\n{\n\t/*\n\t * Set polling in the DMA configuration register to zero.  0x7 avoids\n\t * resetting the board and zeros out the other fields.\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n\n\t/*\n\t * Now that polling has been disabled, we have to wait 1 ms\n\t * before resetting the board.\n\t */\n\tDELAY(1000);\n\n\t/* Reset the board.  We do this by writing zeros to the DMA reset\n\t * field, the BRD reset field, and the manditory 1 at position 2.\n\t * Every other field is set to zero.\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MODE);\n\n\t/*\n\t * Wait another millisecond for the board to reset.\n\t */\n\tDELAY(1000);\n\n\t/*\n\t * Turn off the reset!  (No joke.)\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n}"
  },
  {
    "function_name": "hifn_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
    "lines": "129-284",
    "snippet": "void \nhifn_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct hifn_softc *sc = (struct hifn_softc *)self;\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr = NULL;\n\tchar rbase;\n\tbus_addr_t iobase;\n\tbus_size_t iosize;\n\tu_int32_t cmd;\n\tu_int16_t ena;\n\tbus_dma_segment_t seg;\n\tbus_dmamap_t dmamap;\n\tint rseg;\n\tcaddr_t kva;\n\n\tcmd = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\tcmd |= PCI_COMMAND_MEM_ENABLE | PCI_COMMAND_MASTER_ENABLE;\n\tpci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, cmd);\n\tcmd = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\n\tif (!(cmd & PCI_COMMAND_MEM_ENABLE)) {\n\t\tprintf(\": failed to enable memory mapping\\n\");\n\t\treturn;\n\t}\n\n\tif (pci_mem_find(pc, pa->pa_tag, HIFN_BAR0, &iobase, &iosize, NULL)) {\n\t\tprintf(\": can't find mem space\\n\");\n\t\treturn;\n\t}\n\tif (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->sc_sh0)) {\n\t\tprintf(\": can't map mem space\\n\");\n\t\treturn;\n\t}\n\tsc->sc_st0 = pa->pa_memt;\n\n\tif (pci_mem_find(pc, pa->pa_tag, HIFN_BAR1, &iobase, &iosize, NULL)) {\n\t\tprintf(\": can't find mem space\\n\");\n\t\treturn;\n\t}\n\tif (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->sc_sh1)) {\n\t\tprintf(\": can't map mem space\\n\");\n\t\treturn;\n\t}\n\tsc->sc_st1 = pa->pa_memt;\n\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (bus_dmamem_alloc(sc->sc_dmat, sizeof(*sc->sc_dma), PAGE_SIZE, 0,\n\t    &seg, 1, &rseg, BUS_DMA_NOWAIT)) {\n\t\tprintf(\": can't alloc dma buffer\\n\");\n\t\treturn;\n        }\n\tif (bus_dmamem_map(sc->sc_dmat, &seg, rseg, sizeof(*sc->sc_dma), &kva,\n\t    BUS_DMA_NOWAIT)) {\n\t\tprintf(\": can't map dma buffers (%d bytes)\\n\",\n\t\t    sizeof(*sc->sc_dma));\n\t\tbus_dmamem_free(sc->sc_dmat, &seg, rseg);\n\t\treturn;\n\t}\n\tif (bus_dmamap_create(sc->sc_dmat, sizeof(*sc->sc_dma), 1,\n\t    sizeof(*sc->sc_dma), 0, BUS_DMA_NOWAIT, &dmamap)) {\n\t\tprintf(\": can't create dma map\\n\");\n\t\tbus_dmamem_unmap(sc->sc_dmat, kva, sizeof(*sc->sc_dma));\n\t\tbus_dmamem_free(sc->sc_dmat, &seg, rseg);\n\t\treturn;\n\t}\n\tif (bus_dmamap_load(sc->sc_dmat, dmamap, kva, sizeof(*sc->sc_dma),\n\t    NULL, BUS_DMA_NOWAIT)) {\n\t\tprintf(\": can't load dma map\\n\");\n\t\tbus_dmamap_destroy(sc->sc_dmat, dmamap);\n\t\tbus_dmamem_unmap(sc->sc_dmat, kva, sizeof(*sc->sc_dma));\n\t\tbus_dmamem_free(sc->sc_dmat, &seg, rseg);\n\t\treturn;\n\t}\n\tsc->sc_dma = (struct hifn_dma *)kva;\n\tbzero(sc->sc_dma, sizeof(*sc->sc_dma));\n\n\thifn_reset_board(sc);\n\n\tif (hifn_enable_crypto(sc, pa->pa_id) != 0) {\n\t\tprintf(\"%s: crypto enabling failed\\n\", sc->sc_dv.dv_xname);\n\t\treturn;\n\t}\n\n\thifn_init_dma(sc);\n\thifn_init_pci_registers(sc);\n\n\thifn_ramtype(sc);\n\n\tif (sc->sc_drammodel == 0)\n\t\thifn_sramsize(sc);\n\telse\n\t\thifn_dramsize(sc);\n\n\t/*\n\t * Reinitialize again, since the DRAM/SRAM detection shifted our ring\n\t * pointers and may have changed the value we send to the RAM Config\n\t * Register.\n\t */\n\thifn_reset_board(sc);\n\thifn_init_dma(sc);\n\thifn_init_pci_registers(sc);\n\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, hifn_intr, sc,\n\t    self->dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\": couldn't establish interrupt\\n\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\n\thifn_sessions(sc);\n\n\trseg = sc->sc_ramsize / 1024;\n\trbase = 'K';\n\tif (sc->sc_ramsize >= (1024 * 1024)) {\n\t\trbase = 'M';\n\t\trseg /= 1024;\n\t}\n\tprintf(\", %d%cB %cram, %s\\n\", rseg, rbase,\n\t    sc->sc_drammodel ? 'd' : 's', intrstr);\n\n\tsc->sc_cid = crypto_get_driverid();\n\tif (sc->sc_cid < 0)\n\t\treturn;\n\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG,\n\t    READ_REG_0(sc, HIFN_0_PUCNFG) | HIFN_PUCNFG_CHIPID);\n\tena = READ_REG_0(sc, HIFN_0_PUSTAT) & HIFN_PUSTAT_CHIPENA;\n\n\tswitch (ena) {\n\tcase HIFN_PUSTAT_ENA_2:\n\t\tcrypto_register(sc->sc_cid, CRYPTO_3DES_CBC,\n\t\t    hifn_newsession, hifn_freesession, hifn_process);\n\t\t/*FALLTHROUGH*/\n\tcase HIFN_PUSTAT_ENA_1:\n\t\tcrypto_register(sc->sc_cid, CRYPTO_MD5_HMAC96,\n\t\t    hifn_newsession, hifn_freesession, hifn_process);\n\t\tcrypto_register(sc->sc_cid, CRYPTO_SHA1_HMAC96,\n\t\t    NULL, NULL, NULL);\n\t\tcrypto_register(sc->sc_cid, CRYPTO_DES_CBC,\n\t\t    NULL, NULL, NULL);\n\t}\n}",
    "includes": [
      "#include <dev/pci/hifn7751reg.h>",
      "#include <dev/pci/hifn7751var.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/rndvar.h>",
      "#include <crypto/crypto.h>",
      "#include <sys/device.h>",
      "#include <machine/pmap.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void hifn_attach",
      "void\thifn_reset_board",
      "int\thifn_enable_crypto",
      "void\thifn_init_dma",
      "void\thifn_init_pci_registers",
      "int\thifn_sramsize",
      "int\thifn_dramsize",
      "void\thifn_ramtype",
      "void\thifn_sessions",
      "int\thifn_intr",
      "int\thifn_newsession",
      "int\thifn_freesession",
      "int\thifn_process"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypto_register",
          "args": [
            "sc->sc_cid",
            "CRYPTO_DES_CBC",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_register",
          "args": [
            "sc->sc_cid",
            "CRYPTO_SHA1_HMAC96",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_register",
          "args": [
            "sc->sc_cid",
            "CRYPTO_MD5_HMAC96",
            "hifn_newsession",
            "hifn_freesession",
            "hifn_process"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_register",
          "args": [
            "sc->sc_cid",
            "CRYPTO_3DES_CBC",
            "hifn_newsession",
            "hifn_freesession",
            "hifn_process"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_REG_0",
          "args": [
            "sc",
            "HIFN_0_PUSTAT"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_REG_0",
          "args": [
            "sc",
            "HIFN_0_PUCNFG",
            "READ_REG_0(sc, HIFN_0_PUCNFG) | HIFN_PUCNFG_CHIPID"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_REG_0",
          "args": [
            "sc",
            "HIFN_0_PUCNFG"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_get_driverid",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\", %d%cB %cram, %s\\n\"",
            "rseg",
            "rbase",
            "sc->sc_drammodel ? 'd' : 's'",
            "intrstr"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hifn_sessions",
          "args": [
            "sc"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_sessions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "527-549",
          "snippet": "void\nhifn_sessions(sc)\n\tstruct hifn_softc *sc;\n{\n\tu_int32_t pucnfg;\n\tint ctxsize;\n\n\tpucnfg = READ_REG_0(sc, HIFN_0_PUCNFG);\n\n\tif (pucnfg & HIFN_PUCNFG_COMPSING) {\n\t\tif (pucnfg & HIFN_PUCNFG_ENCCNFG)\n\t\t\tctxsize = 128;\n\t\telse\n\t\t\tctxsize = 512;\n\t\tsc->sc_maxses = 1 +\n\t\t    ((sc->sc_ramsize - 32768) / ctxsize);\n\t}\n\telse\n\t\tsc->sc_maxses = sc->sc_ramsize / 16384;\n\n\tif (sc->sc_maxses > 2048)\n\t\tsc->sc_maxses = 2048;\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\thifn_sessions"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\thifn_sessions;\n\nvoid\nhifn_sessions(sc)\n\tstruct hifn_softc *sc;\n{\n\tu_int32_t pucnfg;\n\tint ctxsize;\n\n\tpucnfg = READ_REG_0(sc, HIFN_0_PUCNFG);\n\n\tif (pucnfg & HIFN_PUCNFG_COMPSING) {\n\t\tif (pucnfg & HIFN_PUCNFG_ENCCNFG)\n\t\t\tctxsize = 128;\n\t\telse\n\t\t\tctxsize = 512;\n\t\tsc->sc_maxses = 1 +\n\t\t    ((sc->sc_ramsize - 32768) / ctxsize);\n\t}\n\telse\n\t\tsc->sc_maxses = sc->sc_ramsize / 16384;\n\n\tif (sc->sc_maxses > 2048)\n\t\tsc->sc_maxses = 2048;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pc",
            "ih",
            "IPL_NET",
            "hifn_intr",
            "sc",
            "self->dv_xname"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pc",
            "ih"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&ih"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hifn_init_pci_registers",
          "args": [
            "sc"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_init_pci_registers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "482-518",
          "snippet": "void \nhifn_init_pci_registers(sc)\n\tstruct hifn_softc *sc;\n{\n\t/* write fixed values needed by the Initialization registers */\n\tWRITE_REG_0(sc, HIFN_0_PUCTRL, HIFN_PUCTRL_DMAENA);\n\tWRITE_REG_0(sc, HIFN_0_FIFOCNFG, HIFN_FIFOCNFG_THRESHOLD);\n\tWRITE_REG_0(sc, HIFN_0_PUIER, HIFN_PUIER_DSTOVER);\n\n\t/* write all 4 ring address registers */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CRAR, vtophys(sc->sc_dma->cmdr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_SRAR, vtophys(sc->sc_dma->srcr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_DRAR, vtophys(sc->sc_dma->dstr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_RRAR, vtophys(sc->sc_dma->resr));\n\n\t/* write status register */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_D_CTRL_ENA |\n\t    HIFN_DMACSR_R_CTRL_ENA | HIFN_DMACSR_S_CTRL_ENA |\n\t    HIFN_DMACSR_C_CTRL_ENA);\n\tWRITE_REG_1(sc, HIFN_1_DMA_IER, HIFN_DMAIER_R_DONE);\n\n#if 0\n#if BYTE_ORDER == BIG_ENDIAN\n\t    (0x1 << 7) |\n#endif\n#endif\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG, HIFN_PUCNFG_COMPSING |\n\t    HIFN_PUCNFG_DRFR_128 | HIFN_PUCNFG_TCALLPHASES |\n\t    HIFN_PUCNFG_TCDRVTOTEM | HIFN_PUCNFG_BUS32 |\n\t    (sc->sc_drammodel ? HIFN_PUCNFG_DRAM : HIFN_PUCNFG_SRAM));\n\n\tWRITE_REG_0(sc, HIFN_0_PUISR, HIFN_PUISR_DSTOVER);\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE | HIFN_DMACNFG_LAST |\n\t    ((HIFN_POLL_FREQUENCY << 16 ) & HIFN_DMACNFG_POLLFREQ) |\n\t    ((HIFN_POLL_SCALAR << 8) & HIFN_DMACNFG_POLLINVAL));\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\thifn_init_pci_registers"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\thifn_init_pci_registers;\n\nvoid \nhifn_init_pci_registers(sc)\n\tstruct hifn_softc *sc;\n{\n\t/* write fixed values needed by the Initialization registers */\n\tWRITE_REG_0(sc, HIFN_0_PUCTRL, HIFN_PUCTRL_DMAENA);\n\tWRITE_REG_0(sc, HIFN_0_FIFOCNFG, HIFN_FIFOCNFG_THRESHOLD);\n\tWRITE_REG_0(sc, HIFN_0_PUIER, HIFN_PUIER_DSTOVER);\n\n\t/* write all 4 ring address registers */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CRAR, vtophys(sc->sc_dma->cmdr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_SRAR, vtophys(sc->sc_dma->srcr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_DRAR, vtophys(sc->sc_dma->dstr));\n\tWRITE_REG_1(sc, HIFN_1_DMA_RRAR, vtophys(sc->sc_dma->resr));\n\n\t/* write status register */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_D_CTRL_ENA |\n\t    HIFN_DMACSR_R_CTRL_ENA | HIFN_DMACSR_S_CTRL_ENA |\n\t    HIFN_DMACSR_C_CTRL_ENA);\n\tWRITE_REG_1(sc, HIFN_1_DMA_IER, HIFN_DMAIER_R_DONE);\n\n#if 0\n#if BYTE_ORDER == BIG_ENDIAN\n\t    (0x1 << 7) |\n#endif\n#endif\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG, HIFN_PUCNFG_COMPSING |\n\t    HIFN_PUCNFG_DRFR_128 | HIFN_PUCNFG_TCALLPHASES |\n\t    HIFN_PUCNFG_TCDRVTOTEM | HIFN_PUCNFG_BUS32 |\n\t    (sc->sc_drammodel ? HIFN_PUCNFG_DRAM : HIFN_PUCNFG_SRAM));\n\n\tWRITE_REG_0(sc, HIFN_0_PUISR, HIFN_PUISR_DSTOVER);\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE | HIFN_DMACNFG_LAST |\n\t    ((HIFN_POLL_FREQUENCY << 16 ) & HIFN_DMACNFG_POLLFREQ) |\n\t    ((HIFN_POLL_SCALAR << 8) & HIFN_DMACNFG_POLLINVAL));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hifn_init_dma",
          "args": [
            "sc"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_init_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "734-754",
          "snippet": "void \nhifn_init_dma(sc)\n\tstruct hifn_softc *sc;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\tint i;\n\n\t/* initialize static pointer values */\n\tfor (i = 0; i < HIFN_D_CMD_RSIZE; i++)\n\t\tdma->cmdr[i].p = vtophys(dma->command_bufs[i]);\n\tfor (i = 0; i < HIFN_D_RES_RSIZE; i++)\n\t\tdma->resr[i].p = vtophys(dma->result_bufs[i]);\n\n\tdma->cmdr[HIFN_D_CMD_RSIZE].p = vtophys(dma->cmdr);\n\tdma->srcr[HIFN_D_SRC_RSIZE].p = vtophys(dma->srcr);\n\tdma->dstr[HIFN_D_DST_RSIZE].p = vtophys(dma->dstr);\n\tdma->resr[HIFN_D_RES_RSIZE].p = vtophys(dma->resr);\n\tdma->cmdu = dma->srcu = dma->dstu = dma->resu = 0;\n\tdma->cmdi = dma->srci = dma->dsti = dma->resi = 0;\n\tdma->cmdk = dma->srck = dma->dstk = dma->resk = 0;\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\thifn_init_dma"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\thifn_init_dma;\n\nvoid \nhifn_init_dma(sc)\n\tstruct hifn_softc *sc;\n{\n\tstruct hifn_dma *dma = sc->sc_dma;\n\tint i;\n\n\t/* initialize static pointer values */\n\tfor (i = 0; i < HIFN_D_CMD_RSIZE; i++)\n\t\tdma->cmdr[i].p = vtophys(dma->command_bufs[i]);\n\tfor (i = 0; i < HIFN_D_RES_RSIZE; i++)\n\t\tdma->resr[i].p = vtophys(dma->result_bufs[i]);\n\n\tdma->cmdr[HIFN_D_CMD_RSIZE].p = vtophys(dma->cmdr);\n\tdma->srcr[HIFN_D_SRC_RSIZE].p = vtophys(dma->srcr);\n\tdma->dstr[HIFN_D_DST_RSIZE].p = vtophys(dma->dstr);\n\tdma->resr[HIFN_D_RES_RSIZE].p = vtophys(dma->resr);\n\tdma->cmdu = dma->srcu = dma->dstu = dma->resu = 0;\n\tdma->cmdi = dma->srci = dma->dsti = dma->resi = 0;\n\tdma->cmdk = dma->srck = dma->dstk = dma->resk = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hifn_reset_board",
          "args": [
            "sc"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_reset_board",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "290-323",
          "snippet": "void\nhifn_reset_board(sc)\n\tstruct hifn_softc *sc;\n{\n\t/*\n\t * Set polling in the DMA configuration register to zero.  0x7 avoids\n\t * resetting the board and zeros out the other fields.\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n\n\t/*\n\t * Now that polling has been disabled, we have to wait 1 ms\n\t * before resetting the board.\n\t */\n\tDELAY(1000);\n\n\t/* Reset the board.  We do this by writing zeros to the DMA reset\n\t * field, the BRD reset field, and the manditory 1 at position 2.\n\t * Every other field is set to zero.\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MODE);\n\n\t/*\n\t * Wait another millisecond for the board to reset.\n\t */\n\tDELAY(1000);\n\n\t/*\n\t * Turn off the reset!  (No joke.)\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\thifn_reset_board"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\thifn_reset_board;\n\nvoid\nhifn_reset_board(sc)\n\tstruct hifn_softc *sc;\n{\n\t/*\n\t * Set polling in the DMA configuration register to zero.  0x7 avoids\n\t * resetting the board and zeros out the other fields.\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n\n\t/*\n\t * Now that polling has been disabled, we have to wait 1 ms\n\t * before resetting the board.\n\t */\n\tDELAY(1000);\n\n\t/* Reset the board.  We do this by writing zeros to the DMA reset\n\t * field, the BRD reset field, and the manditory 1 at position 2.\n\t * Every other field is set to zero.\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MODE);\n\n\t/*\n\t * Wait another millisecond for the board to reset.\n\t */\n\tDELAY(1000);\n\n\t/*\n\t * Turn off the reset!  (No joke.)\n\t */\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hifn_dramsize",
          "args": [
            "sc"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_dramsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "647-657",
          "snippet": "int\nhifn_dramsize(sc)\n\tstruct hifn_softc *sc;\n{\n\tu_int32_t cnfg;\n\n\tcnfg = READ_REG_0(sc, HIFN_0_PUCNFG) &\n\t    HIFN_PUCNFG_DRAMMASK;\n\tsc->sc_ramsize = 1 << ((cnfg >> 13) + 18);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\thifn_dramsize"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\thifn_dramsize;\n\nint\nhifn_dramsize(sc)\n\tstruct hifn_softc *sc;\n{\n\tu_int32_t cnfg;\n\n\tcnfg = READ_REG_0(sc, HIFN_0_PUCNFG) &\n\t    HIFN_PUCNFG_DRAMMASK;\n\tsc->sc_ramsize = 1 << ((cnfg >> 13) + 18);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hifn_sramsize",
          "args": [
            "sc"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_sramsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "591-640",
          "snippet": "int\nhifn_sramsize(sc)\n\tstruct hifn_softc *sc;\n{\n\tu_int32_t a = 0, end;\n\tu_int8_t data[8], dataexpect[8];\n\n\tfor (a = 0; a < sizeof(data); a++)\n\t\tdata[a] = dataexpect[a] = 0x5a;\n\n\thifn_reset_board(sc);\n\thifn_init_dma(sc);\n\thifn_init_pci_registers(sc);\n\tend = 1 << 20;\t/* 1MB */\n\tfor (a = 0; a < end; a += 16384) {\n\t\tif (hifn_writeramaddr(sc, a, data, 0) < 0)\n\t\t\treturn (0);\n\t\tif (hifn_readramaddr(sc, a, data, 1) < 0)\n\t\t\treturn (0);\n\t\tif (bcmp(data, dataexpect, sizeof(data)) != 0)\n\t\t\treturn (0);\n\t\thifn_reset_board(sc);\n\t\thifn_init_dma(sc);\n\t\thifn_init_pci_registers(sc);\n\t\tsc->sc_ramsize = a + 16384;\n\t}\n\n\tfor (a = 0; a < sizeof(data); a++)\n\t\tdata[a] = dataexpect[a] = 0xa5;\n\tif (hifn_writeramaddr(sc, 0, data, 0) < 0)\n\t\treturn (0);\n\n\tend = sc->sc_ramsize;\n\tfor (a = 0; a < end; a += 16384) {\n\t\thifn_reset_board(sc);\n\t\thifn_init_dma(sc);\n\t\thifn_init_pci_registers(sc);\n\t\tif (hifn_readramaddr(sc, a, data, 0) < 0)\n\t\t\treturn (0);\n\t\tif (a != 0 && bcmp(data, dataexpect, sizeof(data)) == 0)\n\t\t\treturn (0);\n\t\tsc->sc_ramsize = a + 16384;\n\t}\n\n\thifn_reset_board(sc);\n\thifn_init_dma(sc);\n\thifn_init_pci_registers(sc);\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\thifn_reset_board",
            "void\thifn_init_dma",
            "void\thifn_init_pci_registers",
            "int\thifn_sramsize",
            "int\thifn_readramaddr",
            "int\thifn_writeramaddr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\thifn_reset_board;\nvoid\thifn_init_dma;\nvoid\thifn_init_pci_registers;\nint\thifn_sramsize;\nint\thifn_readramaddr;\nint\thifn_writeramaddr;\n\nint\nhifn_sramsize(sc)\n\tstruct hifn_softc *sc;\n{\n\tu_int32_t a = 0, end;\n\tu_int8_t data[8], dataexpect[8];\n\n\tfor (a = 0; a < sizeof(data); a++)\n\t\tdata[a] = dataexpect[a] = 0x5a;\n\n\thifn_reset_board(sc);\n\thifn_init_dma(sc);\n\thifn_init_pci_registers(sc);\n\tend = 1 << 20;\t/* 1MB */\n\tfor (a = 0; a < end; a += 16384) {\n\t\tif (hifn_writeramaddr(sc, a, data, 0) < 0)\n\t\t\treturn (0);\n\t\tif (hifn_readramaddr(sc, a, data, 1) < 0)\n\t\t\treturn (0);\n\t\tif (bcmp(data, dataexpect, sizeof(data)) != 0)\n\t\t\treturn (0);\n\t\thifn_reset_board(sc);\n\t\thifn_init_dma(sc);\n\t\thifn_init_pci_registers(sc);\n\t\tsc->sc_ramsize = a + 16384;\n\t}\n\n\tfor (a = 0; a < sizeof(data); a++)\n\t\tdata[a] = dataexpect[a] = 0xa5;\n\tif (hifn_writeramaddr(sc, 0, data, 0) < 0)\n\t\treturn (0);\n\n\tend = sc->sc_ramsize;\n\tfor (a = 0; a < end; a += 16384) {\n\t\thifn_reset_board(sc);\n\t\thifn_init_dma(sc);\n\t\thifn_init_pci_registers(sc);\n\t\tif (hifn_readramaddr(sc, a, data, 0) < 0)\n\t\t\treturn (0);\n\t\tif (a != 0 && bcmp(data, dataexpect, sizeof(data)) == 0)\n\t\t\treturn (0);\n\t\tsc->sc_ramsize = a + 16384;\n\t}\n\n\thifn_reset_board(sc);\n\thifn_init_dma(sc);\n\thifn_init_pci_registers(sc);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hifn_ramtype",
          "args": [
            "sc"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_ramtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "551-585",
          "snippet": "void\nhifn_ramtype(sc)\n\tstruct hifn_softc *sc;\n{\n\tu_int8_t data[8], dataexpect[8];\n\tint i;\n\n\thifn_reset_board(sc);\n\thifn_init_dma(sc);\n\thifn_init_pci_registers(sc);\n\n\tfor (i = 0; i < sizeof(data); i++)\n\t\tdata[i] = dataexpect[i] = 0x55;\n\tif (hifn_writeramaddr(sc, 0, data, 0) < 0)\n\t\treturn;\n\tif (hifn_readramaddr(sc, 0, data, 1) < 0)\n\t\treturn;\n\tif (bcmp(data, dataexpect, sizeof(data)) != 0) {\n\t\tsc->sc_drammodel = 1;\n\t\treturn;\n\t}\n\n\thifn_reset_board(sc);\n\thifn_init_dma(sc);\n\thifn_init_pci_registers(sc);\n\n\tfor (i = 0; i < sizeof(data); i++)\n\t\tdata[i] = dataexpect[i] = 0xaa;\n\tif (hifn_writeramaddr(sc, 0, data, 0) < 0)\n\t\treturn;\n\tif (hifn_readramaddr(sc, 0, data, 1) < 0)\n\t\treturn;\n\tif (bcmp(data, dataexpect, sizeof(data)) != 0)\n\t\tsc->sc_drammodel = 1;\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\thifn_reset_board",
            "void\thifn_init_dma",
            "void\thifn_init_pci_registers",
            "void\thifn_ramtype",
            "int\thifn_readramaddr",
            "int\thifn_writeramaddr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\thifn_reset_board;\nvoid\thifn_init_dma;\nvoid\thifn_init_pci_registers;\nvoid\thifn_ramtype;\nint\thifn_readramaddr;\nint\thifn_writeramaddr;\n\nvoid\nhifn_ramtype(sc)\n\tstruct hifn_softc *sc;\n{\n\tu_int8_t data[8], dataexpect[8];\n\tint i;\n\n\thifn_reset_board(sc);\n\thifn_init_dma(sc);\n\thifn_init_pci_registers(sc);\n\n\tfor (i = 0; i < sizeof(data); i++)\n\t\tdata[i] = dataexpect[i] = 0x55;\n\tif (hifn_writeramaddr(sc, 0, data, 0) < 0)\n\t\treturn;\n\tif (hifn_readramaddr(sc, 0, data, 1) < 0)\n\t\treturn;\n\tif (bcmp(data, dataexpect, sizeof(data)) != 0) {\n\t\tsc->sc_drammodel = 1;\n\t\treturn;\n\t}\n\n\thifn_reset_board(sc);\n\thifn_init_dma(sc);\n\thifn_init_pci_registers(sc);\n\n\tfor (i = 0; i < sizeof(data); i++)\n\t\tdata[i] = dataexpect[i] = 0xaa;\n\tif (hifn_writeramaddr(sc, 0, data, 0) < 0)\n\t\treturn;\n\tif (hifn_readramaddr(sc, 0, data, 1) < 0)\n\t\treturn;\n\tif (bcmp(data, dataexpect, sizeof(data)) != 0)\n\t\tsc->sc_drammodel = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hifn_enable_crypto",
          "args": [
            "sc",
            "pa->pa_id"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "hifn_enable_crypto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
          "lines": "380-476",
          "snippet": "int \nhifn_enable_crypto(sc, pciid)\n\tstruct hifn_softc *sc;\n\tpcireg_t pciid;\n{\n\tu_int32_t dmacfg, ramcfg, encl, addr, i;\n\tchar *offtbl = NULL;\n\n\tfor (i = 0; i < sizeof(pci2id)/sizeof(pci2id[0]); i++) {\n\t\tif (pci2id[i].pci_vendor == PCI_VENDOR(pciid) &&\n\t\t    pci2id[i].pci_prod == PCI_PRODUCT(pciid)) {\n\t\t\tofftbl = pci2id[i].card_id;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (offtbl == NULL) {\n#ifdef HIFN_DEBUG\n\t\tprintf(\"%s: Unknown card!\\n\", sc->sc_dv.dv_xname);\n#endif\n\t\treturn (1);\n\t}\n\n\tramcfg = READ_REG_0(sc, HIFN_0_PUCNFG);\n\tdmacfg = READ_REG_1(sc, HIFN_1_DMA_CNFG);\n\n\t/*\n\t * The RAM config register's encrypt level bit needs to be set before\n\t * every read performed on the encryption level register.\n\t */\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg | HIFN_PUCNFG_CHIPID);\n\n\tencl = READ_REG_0(sc, HIFN_0_PUSTAT) & HIFN_PUSTAT_CHIPENA;\n\n\t/*\n\t * Make sure we don't re-unlock.  Two unlocks kills chip until the\n\t * next reboot.\n\t */\n\tif (encl == HIFN_PUSTAT_ENA_1 || encl == HIFN_PUSTAT_ENA_2) {\n#ifdef HIFN_DEBUG\n\t\tprintf(\"%s: Strong Crypto already enabled!\\n\",\n\t\t    sc->sc_dv.dv_xname);\n#endif\n\t\tWRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg);\n\t\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, dmacfg);\n\t\treturn 0;\t/* success */\n\t}\n\n\tif (encl != 0 && encl != HIFN_PUSTAT_ENA_0) {\n#ifdef HIFN_DEBUG\n\t\tprintf(\"%: Unknown encryption level\\n\",  sc->sc_dv.dv_xname);\n#endif\n\t\treturn 1;\n\t}\n\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_UNLOCK |\n\t    HIFN_DMACNFG_MSTRESET | HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n\taddr = READ_REG_1(sc, HIFN_UNLOCK_SECRET1);\n\tWRITE_REG_1(sc, HIFN_UNLOCK_SECRET2, 0);\n\n\tfor (i = 0; i <= 12; i++) {\n\t\taddr = hifn_next_signature(addr, offtbl[i] + 0x101);\n\t\tWRITE_REG_1(sc, HIFN_UNLOCK_SECRET2, addr);\n\n\t\tDELAY(1000);\n\t}\n\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg | HIFN_PUCNFG_CHIPID);\n\tencl = READ_REG_0(sc, HIFN_0_PUSTAT) & HIFN_PUSTAT_CHIPENA;\n\n#ifdef HIFN_DEBUG\n\tif (encl != HIFN_PUSTAT_ENA_1 && encl != HIFN_PUSTAT_ENA_2)\n\t\tprintf(\"Encryption engine is permanently locked until next system reset.\");\n\telse\n\t\tprintf(\"Encryption engine enabled successfully!\");\n#endif\n\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg);\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, dmacfg);\n\n\tswitch(encl) {\n\tcase HIFN_PUSTAT_ENA_0:\n\t\tprintf(\": no encr/auth\");\n\t\tbreak;\n\tcase HIFN_PUSTAT_ENA_1:\n\t\tprintf(\": DES enabled\");\n\t\tbreak;\n\tcase HIFN_PUSTAT_ENA_2:\n\t\tprintf(\": fully enabled\");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\": disabled\");\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/hifn7751reg.h>",
            "#include <dev/pci/hifn7751var.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/rndvar.h>",
            "#include <crypto/crypto.h>",
            "#include <sys/device.h>",
            "#include <machine/pmap.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\thifn_enable_crypto",
            "u_int32_t hifn_next_signature",
            "struct pci2id {\n\tu_short\t\tpci_vendor;\n\tu_short\t\tpci_prod;\n\tchar\t\tcard_id[13];\n} pci2id[] = {\n\t{\n\t\tPCI_VENDOR_NETSEC,\n\t\tPCI_PRODUCT_NETSEC_7751,\n\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t  0x00, 0x00, 0x00, 0x00, 0x00 }\n\t}, {\n\t\tPCI_VENDOR_INVERTEX,\n\t\tPCI_PRODUCT_INVERTEX_AEON,\n\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t  0x00, 0x00, 0x00, 0x00, 0x00 }\n\t}, {\n\t\t/*\n\t\t * Other vendors share this PCI ID as well, such as\n\t\t * http://www.powercrypt.com, and obviously they also\n\t\t * use the same key.\n\t\t */\n\t\tPCI_VENDOR_HIFN,\n\t\tPCI_PRODUCT_HIFN_7751,\n\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t  0x00, 0x00, 0x00, 0x00, 0x00 }\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\thifn_enable_crypto;\nu_int32_t hifn_next_signature;\nstruct pci2id {\n\tu_short\t\tpci_vendor;\n\tu_short\t\tpci_prod;\n\tchar\t\tcard_id[13];\n} pci2id[] = {\n\t{\n\t\tPCI_VENDOR_NETSEC,\n\t\tPCI_PRODUCT_NETSEC_7751,\n\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t  0x00, 0x00, 0x00, 0x00, 0x00 }\n\t}, {\n\t\tPCI_VENDOR_INVERTEX,\n\t\tPCI_PRODUCT_INVERTEX_AEON,\n\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t  0x00, 0x00, 0x00, 0x00, 0x00 }\n\t}, {\n\t\t/*\n\t\t * Other vendors share this PCI ID as well, such as\n\t\t * http://www.powercrypt.com, and obviously they also\n\t\t * use the same key.\n\t\t */\n\t\tPCI_VENDOR_HIFN,\n\t\tPCI_PRODUCT_HIFN_7751,\n\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t  0x00, 0x00, 0x00, 0x00, 0x00 }\n\t},\n};\n\nint \nhifn_enable_crypto(sc, pciid)\n\tstruct hifn_softc *sc;\n\tpcireg_t pciid;\n{\n\tu_int32_t dmacfg, ramcfg, encl, addr, i;\n\tchar *offtbl = NULL;\n\n\tfor (i = 0; i < sizeof(pci2id)/sizeof(pci2id[0]); i++) {\n\t\tif (pci2id[i].pci_vendor == PCI_VENDOR(pciid) &&\n\t\t    pci2id[i].pci_prod == PCI_PRODUCT(pciid)) {\n\t\t\tofftbl = pci2id[i].card_id;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (offtbl == NULL) {\n#ifdef HIFN_DEBUG\n\t\tprintf(\"%s: Unknown card!\\n\", sc->sc_dv.dv_xname);\n#endif\n\t\treturn (1);\n\t}\n\n\tramcfg = READ_REG_0(sc, HIFN_0_PUCNFG);\n\tdmacfg = READ_REG_1(sc, HIFN_1_DMA_CNFG);\n\n\t/*\n\t * The RAM config register's encrypt level bit needs to be set before\n\t * every read performed on the encryption level register.\n\t */\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg | HIFN_PUCNFG_CHIPID);\n\n\tencl = READ_REG_0(sc, HIFN_0_PUSTAT) & HIFN_PUSTAT_CHIPENA;\n\n\t/*\n\t * Make sure we don't re-unlock.  Two unlocks kills chip until the\n\t * next reboot.\n\t */\n\tif (encl == HIFN_PUSTAT_ENA_1 || encl == HIFN_PUSTAT_ENA_2) {\n#ifdef HIFN_DEBUG\n\t\tprintf(\"%s: Strong Crypto already enabled!\\n\",\n\t\t    sc->sc_dv.dv_xname);\n#endif\n\t\tWRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg);\n\t\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, dmacfg);\n\t\treturn 0;\t/* success */\n\t}\n\n\tif (encl != 0 && encl != HIFN_PUSTAT_ENA_0) {\n#ifdef HIFN_DEBUG\n\t\tprintf(\"%: Unknown encryption level\\n\",  sc->sc_dv.dv_xname);\n#endif\n\t\treturn 1;\n\t}\n\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_UNLOCK |\n\t    HIFN_DMACNFG_MSTRESET | HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n\taddr = READ_REG_1(sc, HIFN_UNLOCK_SECRET1);\n\tWRITE_REG_1(sc, HIFN_UNLOCK_SECRET2, 0);\n\n\tfor (i = 0; i <= 12; i++) {\n\t\taddr = hifn_next_signature(addr, offtbl[i] + 0x101);\n\t\tWRITE_REG_1(sc, HIFN_UNLOCK_SECRET2, addr);\n\n\t\tDELAY(1000);\n\t}\n\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg | HIFN_PUCNFG_CHIPID);\n\tencl = READ_REG_0(sc, HIFN_0_PUSTAT) & HIFN_PUSTAT_CHIPENA;\n\n#ifdef HIFN_DEBUG\n\tif (encl != HIFN_PUSTAT_ENA_1 && encl != HIFN_PUSTAT_ENA_2)\n\t\tprintf(\"Encryption engine is permanently locked until next system reset.\");\n\telse\n\t\tprintf(\"Encryption engine enabled successfully!\");\n#endif\n\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg);\n\tWRITE_REG_1(sc, HIFN_1_DMA_CNFG, dmacfg);\n\n\tswitch(encl) {\n\tcase HIFN_PUSTAT_ENA_0:\n\t\tprintf(\": no encr/auth\");\n\t\tbreak;\n\tcase HIFN_PUSTAT_ENA_1:\n\t\tprintf(\": DES enabled\");\n\t\tbreak;\n\tcase HIFN_PUSTAT_ENA_2:\n\t\tprintf(\": fully enabled\");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\": disabled\");\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->sc_dma",
            "sizeof(*sc->sc_dma)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "sc->sc_dmat",
            "&seg",
            "rseg"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "sc->sc_dmat",
            "kva",
            "sizeof(*sc->sc_dma)"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_destroy",
          "args": [
            "sc->sc_dmat",
            "dmamap"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "sc->sc_dmat",
            "dmamap",
            "kva",
            "sizeof(*sc->sc_dma)",
            "NULL",
            "BUS_DMA_NOWAIT"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "sc->sc_dmat",
            "&seg",
            "rseg"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "sc->sc_dmat",
            "kva",
            "sizeof(*sc->sc_dma)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "sc->sc_dmat",
            "sizeof(*sc->sc_dma)",
            "1",
            "sizeof(*sc->sc_dma)",
            "0",
            "BUS_DMA_NOWAIT",
            "&dmamap"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "sc->sc_dmat",
            "&seg",
            "rseg"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_map",
          "args": [
            "sc->sc_dmat",
            "&seg",
            "rseg",
            "sizeof(*sc->sc_dma)",
            "&kva",
            "BUS_DMA_NOWAIT"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_alloc",
          "args": [
            "sc->sc_dmat",
            "sizeof(*sc->sc_dma)",
            "PAGE_SIZE",
            "0",
            "&seg",
            "1",
            "&rseg",
            "BUS_DMA_NOWAIT"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "pa->pa_memt",
            "iobase",
            "iosize",
            "0",
            "&sc->sc_sh1"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_mem_find",
          "args": [
            "pc",
            "pa->pa_tag",
            "HIFN_BAR1",
            "&iobase",
            "&iosize",
            "NULL"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mem_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "197-208",
          "snippet": "int\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_mem_find;\n\nint\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "pa->pa_memt",
            "iobase",
            "iosize",
            "0",
            "&sc->sc_sh0"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG",
            "cmd"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid hifn_attach;\nvoid\thifn_reset_board;\nint\thifn_enable_crypto;\nvoid\thifn_init_dma;\nvoid\thifn_init_pci_registers;\nint\thifn_sramsize;\nint\thifn_dramsize;\nvoid\thifn_ramtype;\nvoid\thifn_sessions;\nint\thifn_intr;\nint\thifn_newsession;\nint\thifn_freesession;\nint\thifn_process;\n\nvoid \nhifn_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct hifn_softc *sc = (struct hifn_softc *)self;\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr = NULL;\n\tchar rbase;\n\tbus_addr_t iobase;\n\tbus_size_t iosize;\n\tu_int32_t cmd;\n\tu_int16_t ena;\n\tbus_dma_segment_t seg;\n\tbus_dmamap_t dmamap;\n\tint rseg;\n\tcaddr_t kva;\n\n\tcmd = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\tcmd |= PCI_COMMAND_MEM_ENABLE | PCI_COMMAND_MASTER_ENABLE;\n\tpci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, cmd);\n\tcmd = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\n\tif (!(cmd & PCI_COMMAND_MEM_ENABLE)) {\n\t\tprintf(\": failed to enable memory mapping\\n\");\n\t\treturn;\n\t}\n\n\tif (pci_mem_find(pc, pa->pa_tag, HIFN_BAR0, &iobase, &iosize, NULL)) {\n\t\tprintf(\": can't find mem space\\n\");\n\t\treturn;\n\t}\n\tif (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->sc_sh0)) {\n\t\tprintf(\": can't map mem space\\n\");\n\t\treturn;\n\t}\n\tsc->sc_st0 = pa->pa_memt;\n\n\tif (pci_mem_find(pc, pa->pa_tag, HIFN_BAR1, &iobase, &iosize, NULL)) {\n\t\tprintf(\": can't find mem space\\n\");\n\t\treturn;\n\t}\n\tif (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->sc_sh1)) {\n\t\tprintf(\": can't map mem space\\n\");\n\t\treturn;\n\t}\n\tsc->sc_st1 = pa->pa_memt;\n\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (bus_dmamem_alloc(sc->sc_dmat, sizeof(*sc->sc_dma), PAGE_SIZE, 0,\n\t    &seg, 1, &rseg, BUS_DMA_NOWAIT)) {\n\t\tprintf(\": can't alloc dma buffer\\n\");\n\t\treturn;\n        }\n\tif (bus_dmamem_map(sc->sc_dmat, &seg, rseg, sizeof(*sc->sc_dma), &kva,\n\t    BUS_DMA_NOWAIT)) {\n\t\tprintf(\": can't map dma buffers (%d bytes)\\n\",\n\t\t    sizeof(*sc->sc_dma));\n\t\tbus_dmamem_free(sc->sc_dmat, &seg, rseg);\n\t\treturn;\n\t}\n\tif (bus_dmamap_create(sc->sc_dmat, sizeof(*sc->sc_dma), 1,\n\t    sizeof(*sc->sc_dma), 0, BUS_DMA_NOWAIT, &dmamap)) {\n\t\tprintf(\": can't create dma map\\n\");\n\t\tbus_dmamem_unmap(sc->sc_dmat, kva, sizeof(*sc->sc_dma));\n\t\tbus_dmamem_free(sc->sc_dmat, &seg, rseg);\n\t\treturn;\n\t}\n\tif (bus_dmamap_load(sc->sc_dmat, dmamap, kva, sizeof(*sc->sc_dma),\n\t    NULL, BUS_DMA_NOWAIT)) {\n\t\tprintf(\": can't load dma map\\n\");\n\t\tbus_dmamap_destroy(sc->sc_dmat, dmamap);\n\t\tbus_dmamem_unmap(sc->sc_dmat, kva, sizeof(*sc->sc_dma));\n\t\tbus_dmamem_free(sc->sc_dmat, &seg, rseg);\n\t\treturn;\n\t}\n\tsc->sc_dma = (struct hifn_dma *)kva;\n\tbzero(sc->sc_dma, sizeof(*sc->sc_dma));\n\n\thifn_reset_board(sc);\n\n\tif (hifn_enable_crypto(sc, pa->pa_id) != 0) {\n\t\tprintf(\"%s: crypto enabling failed\\n\", sc->sc_dv.dv_xname);\n\t\treturn;\n\t}\n\n\thifn_init_dma(sc);\n\thifn_init_pci_registers(sc);\n\n\thifn_ramtype(sc);\n\n\tif (sc->sc_drammodel == 0)\n\t\thifn_sramsize(sc);\n\telse\n\t\thifn_dramsize(sc);\n\n\t/*\n\t * Reinitialize again, since the DRAM/SRAM detection shifted our ring\n\t * pointers and may have changed the value we send to the RAM Config\n\t * Register.\n\t */\n\thifn_reset_board(sc);\n\thifn_init_dma(sc);\n\thifn_init_pci_registers(sc);\n\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, hifn_intr, sc,\n\t    self->dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\": couldn't establish interrupt\\n\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\n\thifn_sessions(sc);\n\n\trseg = sc->sc_ramsize / 1024;\n\trbase = 'K';\n\tif (sc->sc_ramsize >= (1024 * 1024)) {\n\t\trbase = 'M';\n\t\trseg /= 1024;\n\t}\n\tprintf(\", %d%cB %cram, %s\\n\", rseg, rbase,\n\t    sc->sc_drammodel ? 'd' : 's', intrstr);\n\n\tsc->sc_cid = crypto_get_driverid();\n\tif (sc->sc_cid < 0)\n\t\treturn;\n\n\tWRITE_REG_0(sc, HIFN_0_PUCNFG,\n\t    READ_REG_0(sc, HIFN_0_PUCNFG) | HIFN_PUCNFG_CHIPID);\n\tena = READ_REG_0(sc, HIFN_0_PUSTAT) & HIFN_PUSTAT_CHIPENA;\n\n\tswitch (ena) {\n\tcase HIFN_PUSTAT_ENA_2:\n\t\tcrypto_register(sc->sc_cid, CRYPTO_3DES_CBC,\n\t\t    hifn_newsession, hifn_freesession, hifn_process);\n\t\t/*FALLTHROUGH*/\n\tcase HIFN_PUSTAT_ENA_1:\n\t\tcrypto_register(sc->sc_cid, CRYPTO_MD5_HMAC96,\n\t\t    hifn_newsession, hifn_freesession, hifn_process);\n\t\tcrypto_register(sc->sc_cid, CRYPTO_SHA1_HMAC96,\n\t\t    NULL, NULL, NULL);\n\t\tcrypto_register(sc->sc_cid, CRYPTO_DES_CBC,\n\t\t    NULL, NULL, NULL);\n\t}\n}"
  },
  {
    "function_name": "hifn_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/hifn7751.c",
    "lines": "109-127",
    "snippet": "int\nhifn_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = (struct pci_attach_args *) aux;\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INVERTEX &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INVERTEX_AEON)\n\t\treturn (1);\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_HIFN &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7751)\n\t\treturn (1);\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_NETSEC &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NETSEC_7751)\n\t\treturn (1);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/hifn7751reg.h>",
      "#include <dev/pci/hifn7751var.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/rndvar.h>",
      "#include <crypto/crypto.h>",
      "#include <sys/device.h>",
      "#include <machine/pmap.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int hifn_probe"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/hifn7751reg.h>\n#include <dev/pci/hifn7751var.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/rndvar.h>\n#include <crypto/crypto.h>\n#include <sys/device.h>\n#include <machine/pmap.h>\n#include <vm/pmap.h>\n#include <vm/vm_extern.h>\n#include <vm/vm.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint hifn_probe;\n\nint\nhifn_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = (struct pci_attach_args *) aux;\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INVERTEX &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INVERTEX_AEON)\n\t\treturn (1);\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_HIFN &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7751)\n\t\treturn (1);\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_NETSEC &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NETSEC_7751)\n\t\treturn (1);\n\treturn (0);\n}"
  }
]