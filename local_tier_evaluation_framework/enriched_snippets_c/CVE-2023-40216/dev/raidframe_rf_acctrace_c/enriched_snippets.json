[
  {
    "function_name": "rf_FlushAccessTraceBuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_acctrace.c",
    "lines": "163-167",
    "snippet": "void \nrf_FlushAccessTraceBuf()\n{\n\taccessTraceBufCount = 0;\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_hist.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int accessTraceBufCount = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_hist.h\"\n#include \"rf_etimer.h\"\n#include \"rf_raid.h\"\n#include \"rf_general.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_types.h\"\n#include \"rf_threadstuff.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n\nstatic int accessTraceBufCount = 0;\n\nvoid \nrf_FlushAccessTraceBuf()\n{\n\taccessTraceBufCount = 0;\n}"
  },
  {
    "function_name": "rf_LogTraceRec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_acctrace.c",
    "lines": "104-156",
    "snippet": "void \nrf_LogTraceRec(raid, rec)\n\tRF_Raid_t *raid;\n\tRF_AccTraceEntry_t *rec;\n{\n\tRF_AccTotals_t *acc = &raid->acc_totals;\n#if 0\n\tRF_Etimer_t timer;\n\tint     i, n;\n#endif\n\n\tif (rf_stopCollectingTraces || ((rf_maxNumTraces >= 0) && (numTracesSoFar >= rf_maxNumTraces)))\n\t\treturn;\n\n\t/* update AccTotals for this device */\n\tif (!raid->keep_acc_totals)\n\t\treturn;\n\tacc->num_log_ents++;\n\tif (rec->reconacc) {\n\t\tacc->recon_start_to_fetch_us += rec->specific.recon.recon_start_to_fetch_us;\n\t\tacc->recon_fetch_to_return_us += rec->specific.recon.recon_fetch_to_return_us;\n\t\tacc->recon_return_to_submit_us += rec->specific.recon.recon_return_to_submit_us;\n\t\tacc->recon_num_phys_ios += rec->num_phys_ios;\n\t\tacc->recon_phys_io_us += rec->phys_io_us;\n\t\tacc->recon_diskwait_us += rec->diskwait_us;\n\t\tacc->recon_reccount++;\n\t} else {\n\t\tRF_HIST_ADD(acc->tot_hist, rec->total_us);\n\t\tRF_HIST_ADD(acc->dw_hist, rec->diskwait_us);\n\t\t/* count of physical ios which are too big.  often due to\n\t\t * thermal recalibration */\n\t\t/* if bigvals > 0, you should probably ignore this data set */\n\t\tif (rec->diskwait_us > 100000)\n\t\t\tacc->bigvals++;\n\t\tacc->total_us += rec->total_us;\n\t\tacc->suspend_ovhd_us += rec->specific.user.suspend_ovhd_us;\n\t\tacc->map_us += rec->specific.user.map_us;\n\t\tacc->lock_us += rec->specific.user.lock_us;\n\t\tacc->dag_create_us += rec->specific.user.dag_create_us;\n\t\tacc->dag_retry_us += rec->specific.user.dag_retry_us;\n\t\tacc->exec_us += rec->specific.user.exec_us;\n\t\tacc->cleanup_us += rec->specific.user.cleanup_us;\n\t\tacc->exec_engine_us += rec->specific.user.exec_engine_us;\n\t\tacc->xor_us += rec->xor_us;\n\t\tacc->q_us += rec->q_us;\n\t\tacc->plog_us += rec->plog_us;\n\t\tacc->diskqueue_us += rec->diskqueue_us;\n\t\tacc->diskwait_us += rec->diskwait_us;\n\t\tacc->num_phys_ios += rec->num_phys_ios;\n\t\tacc->phys_io_us = rec->phys_io_us;\n\t\tacc->user_reccount++;\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_hist.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long numTracesSoFar;",
      "int     rf_stopCollectingTraces;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_HIST_ADD",
          "args": [
            "acc->dw_hist",
            "rec->diskwait_us"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_HIST_ADD",
          "args": [
            "acc->tot_hist",
            "rec->total_us"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_hist.h\"\n#include \"rf_etimer.h\"\n#include \"rf_raid.h\"\n#include \"rf_general.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_types.h\"\n#include \"rf_threadstuff.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n\nstatic long numTracesSoFar;\nint     rf_stopCollectingTraces;\n\nvoid \nrf_LogTraceRec(raid, rec)\n\tRF_Raid_t *raid;\n\tRF_AccTraceEntry_t *rec;\n{\n\tRF_AccTotals_t *acc = &raid->acc_totals;\n#if 0\n\tRF_Etimer_t timer;\n\tint     i, n;\n#endif\n\n\tif (rf_stopCollectingTraces || ((rf_maxNumTraces >= 0) && (numTracesSoFar >= rf_maxNumTraces)))\n\t\treturn;\n\n\t/* update AccTotals for this device */\n\tif (!raid->keep_acc_totals)\n\t\treturn;\n\tacc->num_log_ents++;\n\tif (rec->reconacc) {\n\t\tacc->recon_start_to_fetch_us += rec->specific.recon.recon_start_to_fetch_us;\n\t\tacc->recon_fetch_to_return_us += rec->specific.recon.recon_fetch_to_return_us;\n\t\tacc->recon_return_to_submit_us += rec->specific.recon.recon_return_to_submit_us;\n\t\tacc->recon_num_phys_ios += rec->num_phys_ios;\n\t\tacc->recon_phys_io_us += rec->phys_io_us;\n\t\tacc->recon_diskwait_us += rec->diskwait_us;\n\t\tacc->recon_reccount++;\n\t} else {\n\t\tRF_HIST_ADD(acc->tot_hist, rec->total_us);\n\t\tRF_HIST_ADD(acc->dw_hist, rec->diskwait_us);\n\t\t/* count of physical ios which are too big.  often due to\n\t\t * thermal recalibration */\n\t\t/* if bigvals > 0, you should probably ignore this data set */\n\t\tif (rec->diskwait_us > 100000)\n\t\t\tacc->bigvals++;\n\t\tacc->total_us += rec->total_us;\n\t\tacc->suspend_ovhd_us += rec->specific.user.suspend_ovhd_us;\n\t\tacc->map_us += rec->specific.user.map_us;\n\t\tacc->lock_us += rec->specific.user.lock_us;\n\t\tacc->dag_create_us += rec->specific.user.dag_create_us;\n\t\tacc->dag_retry_us += rec->specific.user.dag_retry_us;\n\t\tacc->exec_us += rec->specific.user.exec_us;\n\t\tacc->cleanup_us += rec->specific.user.cleanup_us;\n\t\tacc->exec_engine_us += rec->specific.user.exec_engine_us;\n\t\tacc->xor_us += rec->xor_us;\n\t\tacc->q_us += rec->q_us;\n\t\tacc->plog_us += rec->plog_us;\n\t\tacc->diskqueue_us += rec->diskqueue_us;\n\t\tacc->diskwait_us += rec->diskwait_us;\n\t\tacc->num_phys_ios += rec->num_phys_ios;\n\t\tacc->phys_io_us = rec->phys_io_us;\n\t\tacc->user_reccount++;\n\t}\n}"
  },
  {
    "function_name": "rf_ConfigureAccessTrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_acctrace.c",
    "lines": "72-100",
    "snippet": "int \nrf_ConfigureAccessTrace(listp)\n\tRF_ShutdownList_t **listp;\n{\n\tint     rc;\n\n\tnumTracesSoFar = accessTraceBufCount = rf_stopCollectingTraces = 0;\n\tif (rf_accessTraceBufSize) {\n\t\tRF_Malloc(access_tracebuf, rf_accessTraceBufSize * sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));\n\t\taccessTraceBufCount = 0;\n\t}\n\ttraceCount = 0;\n\tnumTracesSoFar = 0;\n\trc = rf_mutex_init(&rf_tracing_mutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t}\n\trc = rf_ShutdownCreate(listp, rf_ShutdownAccessTrace, NULL);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\tif (rf_accessTraceBufSize) {\n\t\t\tRF_Free(access_tracebuf, rf_accessTraceBufSize * sizeof(RF_AccTraceEntry_t));\n\t\t\trf_mutex_destroy(&rf_tracing_mutex);\n\t\t}\n\t}\n\treturn (rc);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_hist.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long numTracesSoFar;",
      "static int accessTraceBufCount = 0;",
      "static RF_AccTraceEntry_t *access_tracebuf;",
      "static long traceCount;",
      "int     rf_stopCollectingTraces;",
      "static void rf_ShutdownAccessTrace(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&rf_tracing_mutex"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "access_tracebuf",
            "rf_accessTraceBufSize * sizeof(RF_AccTraceEntry_t)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to add to shutdown list file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownCreate",
          "args": [
            "listp",
            "rf_ShutdownAccessTrace",
            "NULL"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to init mutex file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_init",
          "args": [
            "&rf_tracing_mutex"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "rf_mutex_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_threadstuff.c",
          "lines": "173-186",
          "snippet": "int \nrf_mutex_init(m)\ndecl_simple_lock_data(, *m)\n{\n\tsimple_lock_init(m);\n\treturn (0);\n}\n\nint \nrf_mutex_destroy(m)\ndecl_simple_lock_data(, *m)\n{\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nint \nrf_mutex_init(m)\ndecl_simple_lock_data(, *m)\n{\n\tsimple_lock_init(m);\n\treturn (0);\n}\n\nint \nrf_mutex_destroy(m)\ndecl_simple_lock_data(, *m)\n{\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "access_tracebuf",
            "rf_accessTraceBufSize * sizeof(RF_AccTraceEntry_t)",
            "(RF_AccTraceEntry_t *)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_hist.h\"\n#include \"rf_etimer.h\"\n#include \"rf_raid.h\"\n#include \"rf_general.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_types.h\"\n#include \"rf_threadstuff.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n\nstatic long numTracesSoFar;\nstatic int accessTraceBufCount = 0;\nstatic RF_AccTraceEntry_t *access_tracebuf;\nstatic long traceCount;\nint     rf_stopCollectingTraces;\nstatic void rf_ShutdownAccessTrace(void *);\n\nint \nrf_ConfigureAccessTrace(listp)\n\tRF_ShutdownList_t **listp;\n{\n\tint     rc;\n\n\tnumTracesSoFar = accessTraceBufCount = rf_stopCollectingTraces = 0;\n\tif (rf_accessTraceBufSize) {\n\t\tRF_Malloc(access_tracebuf, rf_accessTraceBufSize * sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));\n\t\taccessTraceBufCount = 0;\n\t}\n\ttraceCount = 0;\n\tnumTracesSoFar = 0;\n\trc = rf_mutex_init(&rf_tracing_mutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t}\n\trc = rf_ShutdownCreate(listp, rf_ShutdownAccessTrace, NULL);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\tif (rf_accessTraceBufSize) {\n\t\t\tRF_Free(access_tracebuf, rf_accessTraceBufSize * sizeof(RF_AccTraceEntry_t));\n\t\t\trf_mutex_destroy(&rf_tracing_mutex);\n\t\t}\n\t}\n\treturn (rc);\n}"
  },
  {
    "function_name": "rf_ShutdownAccessTrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_acctrace.c",
    "lines": "61-70",
    "snippet": "static void rf_ShutdownAccessTrace(ignored)\n\tvoid   *ignored;\n{\n\tif (rf_accessTraceBufSize) {\n\t\tif (accessTraceBufCount)\n\t\t\trf_FlushAccessTraceBuf();\n\t\tRF_Free(access_tracebuf, rf_accessTraceBufSize * sizeof(RF_AccTraceEntry_t));\n\t}\n\trf_mutex_destroy(&rf_tracing_mutex);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_hist.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int accessTraceBufCount = 0;",
      "static RF_AccTraceEntry_t *access_tracebuf;",
      "static void rf_ShutdownAccessTrace(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&rf_tracing_mutex"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "access_tracebuf",
            "rf_accessTraceBufSize * sizeof(RF_AccTraceEntry_t)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_FlushAccessTraceBuf",
          "args": [],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FlushAccessTraceBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_acctrace.c",
          "lines": "163-167",
          "snippet": "void \nrf_FlushAccessTraceBuf()\n{\n\taccessTraceBufCount = 0;\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_hist.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int accessTraceBufCount = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_hist.h\"\n#include \"rf_etimer.h\"\n#include \"rf_raid.h\"\n#include \"rf_general.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_types.h\"\n#include \"rf_threadstuff.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n\nstatic int accessTraceBufCount = 0;\n\nvoid \nrf_FlushAccessTraceBuf()\n{\n\taccessTraceBufCount = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_hist.h\"\n#include \"rf_etimer.h\"\n#include \"rf_raid.h\"\n#include \"rf_general.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_types.h\"\n#include \"rf_threadstuff.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n\nstatic int accessTraceBufCount = 0;\nstatic RF_AccTraceEntry_t *access_tracebuf;\nstatic void rf_ShutdownAccessTrace(void *);\n\nstatic void rf_ShutdownAccessTrace(ignored)\n\tvoid   *ignored;\n{\n\tif (rf_accessTraceBufSize) {\n\t\tif (accessTraceBufCount)\n\t\t\trf_FlushAccessTraceBuf();\n\t\tRF_Free(access_tracebuf, rf_accessTraceBufSize * sizeof(RF_AccTraceEntry_t));\n\t}\n\trf_mutex_destroy(&rf_tracing_mutex);\n}"
  }
]